pthread_mutex_t *FigSimpleMutexCreate()
{
  return FigSimpleMutexCreateWithAttr((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 0);
}

pthread_mutex_t *FigSimpleMutexCreateWithAttr(const __CFAllocator *a1, const pthread_mutexattr_t *a2)
{
  pthread_mutex_t *v4;
  pthread_mutex_t *v5;
  CFTypeRef v6;

  v4 = (pthread_mutex_t *)CFAllocatorAllocate(a1, 72, 0);
  v5 = v4;
  if (v4)
  {
    if (pthread_mutex_init(v4, a2))
    {
      CFAllocatorDeallocate(a1, v5);
      return 0;
    }
    else
    {
      if (a1)
        v6 = CFRetain(a1);
      else
        v6 = 0;
      v5[1].__sig = (uint64_t)v6;
    }
  }
  return v5;
}

uint64_t FigThreadCreate(uint64_t a1, uint64_t a2, unsigned int a3, int a4, const __CFDictionary *a5, pthread_t *a6)
{
  uint64_t v12;
  int v13;
  uint64_t v14;
  qos_class_t QualityOfServiceClassForFigThreadPriority;
  uint64_t v16;
  const __CFNumber *Value;
  const __CFNumber *v19;
  CFTypeID v20;
  int v21;
  uint64_t v22;
  const void *v23;
  const void *v24;
  CFTypeID v25;
  const void *v26;
  void *v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t valuePtr;
  pthread_t v32;
  pthread_attr_t __attr;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  v32 = 0;
  memset(&__attr, 0, sizeof(__attr));
  if (a3 >= 0x32)
  {
    v12 = FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
    v13 = 0;
    if (!a4)
      goto LABEL_12;
    goto LABEL_10;
  }
  if (a3 != 5)
  {
    v13 = 0;
    v12 = 0;
    if (!a4)
      goto LABEL_12;
    goto LABEL_10;
  }
  if (!FigCFDictionaryGetInt32IfPresent((uint64_t)a5, CFSTR("com.apple.fig.ThreadCreateKey_MachThreadPriority"), &valuePtr)|| (int)valuePtr <= 0)
  {
    return FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  }
  v12 = 0;
  v13 = 1;
  if (a4)
  {
LABEL_10:
    if (!a6)
      v12 = FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  }
LABEL_12:
  if (!(_DWORD)v12)
  {
    v14 = pthread_attr_init(&__attr);
    if ((_DWORD)v14)
    {
      v12 = v14;
LABEL_17:
      FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
      return v12;
    }
    QualityOfServiceClassForFigThreadPriority = FigGetQualityOfServiceClassForFigThreadPriority(a3);
    v16 = pthread_attr_set_qos_class_np(&__attr, QualityOfServiceClassForFigThreadPriority, 0);
    if ((_DWORD)v16)
    {
      v12 = v16;
      FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      goto LABEL_17;
    }
    if (a5)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(a5, CFSTR("com.apple.fig.ThreadCreateKey_StackSize"));
      if (Value)
      {
        v19 = Value;
        v20 = CFGetTypeID(Value);
        if (v20 == CFNumberGetTypeID())
          CFNumberGetValue(v19, kCFNumberSInt32Type, (char *)&valuePtr + 4);
      }
    }
    if (a4)
      v21 = 1;
    else
      v21 = 2;
    v12 = pthread_attr_setdetachstate(&__attr, v21);
    if ((_DWORD)v12)
      goto LABEL_44;
    if (SHIDWORD(valuePtr) > 0x4000)
    {
      v12 = pthread_attr_setstacksize(&__attr, HIDWORD(valuePtr));
      if ((_DWORD)v12)
        goto LABEL_44;
    }
    v22 = FigThreadLockAbortList();
    if ((_DWORD)v22)
    {
      v12 = v22;
      goto LABEL_45;
    }
    if (a5 && (v23 = CFDictionaryGetValue(a5, CFSTR("com.apple.fig.ThreadCreateKey_Identifier"))) != 0)
    {
      v24 = v23;
      v25 = CFGetTypeID(v23);
      if (v25 == CFStringGetTypeID())
        v26 = v24;
      else
        v26 = 0;
    }
    else
    {
      v26 = 0;
    }
    v27 = malloc_type_calloc(1uLL, 0x38uLL, 0x10E00404CF1D47AuLL);
    *(_QWORD *)v27 = a1;
    *((_QWORD *)v27 + 1) = a2;
    if (v26)
      *((_QWORD *)v27 + 2) = CFRetain(v26);
    *((_DWORD *)v27 + 6) = a3;
    if (a5)
      *((_QWORD *)v27 + 4) = CFRetain(a5);
    *((_BYTE *)v27 + 40) = 1;
    *((_QWORD *)v27 + 6) = 0;
    FigCFDictionaryGetBooleanIfPresent((uint64_t)a5, CFSTR("com.apple.fig.ThreadCreateKey_AdoptVoucher"), (Boolean *)v27 + 40);
    if (*((_BYTE *)v27 + 40))
      *((_QWORD *)v27 + 6) = voucher_copy();
    v28 = pthread_create(&v32, &__attr, (void *(__cdecl *)(void *))figThreadMain, v27);
    if ((_DWORD)v28)
    {
      v12 = v28;
      FigThreadUnlockAbortList();
LABEL_44:
      FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
LABEL_45:
      pthread_attr_destroy(&__attr);
      return v12;
    }
    if (a3 == 16)
    {
      figSetPThreadBackground(v32, 1);
    }
    else
    {
      v29 = valuePtr;
      if ((_DWORD)valuePtr)
        v30 = v13;
      else
        v30 = 0;
      if (v30 != 1)
        v29 = kNativePriorityMap[a3];
      figSetPThreadPriority(v32, v29);
    }
    FigThreadRemoveFromAbortListAndCleanup((uint64_t)v32);
    FigThreadUnlockAbortList();
    if (gGMFigKTraceEnabled == 1)
    {
      FigThreadGetMachThreadPriorityValue(a3);
      kdebug_trace();
    }
    v12 = 0;
    if (a6)
      *a6 = v32;
  }
  return v12;
}

uint64_t figSetMachThreadPriority(thread_act_t a1, int a2)
{
  pid_t v4;
  uint64_t result;
  integer_t policy_info;
  _OWORD buffer[14];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  memset(buffer, 0, sizeof(buffer));
  v4 = getpid();
  if (proc_pidinfo(v4, 2, 0, buffer, 232) < 1)
  {
    result = 0xFFFFFFFFLL;
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  policy_info = a2 - HIDWORD(v8);
  result = thread_policy_set(a1, 3u, &policy_info, 1u);
  if ((_DWORD)result)
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t figGetMachThreadPriority(thread_inspect_t a1, _DWORD *a2)
{
  uint64_t v4;
  char *v5;
  uint64_t result;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  mach_msg_type_number_t thread_info_outCnt;
  integer_t thread_info_out[4];
  __int128 v13;
  uint64_t v14;

  v14 = 0;
  *(_OWORD *)thread_info_out = 0u;
  v13 = 0u;
  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  v7 = 0u;
  thread_info_outCnt = 10;
  v4 = thread_info(a1, 3u, thread_info_out, &thread_info_outCnt);
  if ((_DWORD)v4)
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  if (DWORD1(v13) == 4)
  {
    thread_info_outCnt = 4;
    v4 = thread_info(a1, 0xCu, (thread_info_t)&v9 + 2, &thread_info_outCnt);
    if ((_DWORD)v4)
      return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    v5 = (char *)&v9 + 12;
  }
  else
  {
    if (DWORD1(v13) != 2)
    {
      if (DWORD1(v13) == 1)
      {
        thread_info_outCnt = 5;
        v4 = thread_info(a1, 0xAu, (thread_info_t)&v7, &thread_info_outCnt);
        if (!(_DWORD)v4)
        {
          v5 = (char *)&v7 + 4;
          goto LABEL_11;
        }
      }
      else
      {
        v4 = 4294954503;
      }
      return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    }
    thread_info_outCnt = 5;
    v4 = thread_info(a1, 0xBu, (thread_info_t)&v8 + 1, &thread_info_outCnt);
    if ((_DWORD)v4)
      return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    v5 = (char *)&v8 + 8;
  }
LABEL_11:
  result = 0;
  if (a2)
    *a2 = *(_DWORD *)v5;
  return result;
}

uint64_t fig_note_initialize_logging()
{
  return FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
}

uint64_t fig_note_init_logging_once()
{
  gFigLogControlMutex = (uint64_t)FigReentrantMutexCreate();
  return fig_note_read_control_preferences();
}

uint64_t FigAtomicCompareAndSwap32(int a1, unsigned int a2, unsigned int *a3)
{
  unsigned int v3;
  uint64_t result;

  while (1)
  {
    v3 = __ldxr(a3);
    if (v3 != a1)
      break;
    if (!__stxr(a2, a3))
      return 1;
  }
  result = 0;
  __clrex();
  return result;
}

void fig_note_initialize_work(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  fig_note_initialize_category_with_default_work(a1, a2, a3, (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, a7, 0);
}

pthread_mutex_t *FigReentrantMutexCreate()
{
  return FigReentrantMutexCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
}

CFPropertyListRef CelestialCFCreatePropertyList(const __CFString *a1)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("com.apple.MediaToolbox"), a1, (const __CFString *)CelestialGetModelSpecificName_sModelNameStr);
}

uint64_t CelestialGetModelSpecificName()
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  return CelestialGetModelSpecificName_sModelNameStr;
}

CFPropertyListRef FigCFCreatePropertyListFromBundleIdentifier(CFStringRef bundleID, const __CFString *a2, const __CFString *a3)
{
  return FigCreatePropertyListFromBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E0C9AE00], bundleID, a2, a3);
}

_QWORD *FigSemaphoreCreate(uint64_t a1, uint64_t a2)
{
  return FigSemaphoreCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, a2);
}

uint64_t FigSemaphoreWaitRelative(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  pthread_mutex_t *v11;
  pthread_cond_t *v12;
  uint64_t v13;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;

  v2 = a2;
  if (a2 < 0)
  {
    v5 = 1;
  }
  else
  {
    v17 = 0;
    v4 = RelativeTimeToAbsoluteTime(a2, &v17);
    if (v4)
      v2 = v17;
    v5 = v4 ^ 1;
  }
  v6 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if ((_DWORD)v6)
    return v6;
  v7 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = v7 + 1;
  if (*(_BYTE *)(a1 + 80))
  {
LABEL_21:
    *(_QWORD *)(a1 + 72) = v7;
    v13 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v8 = 0;
    while (1)
    {
      v9 = *(_QWORD *)(a1 + 56);
      if (v9 || v8 != 0)
        break;
      v11 = *(pthread_mutex_t **)a1;
      v12 = (pthread_cond_t *)(a1 + 8);
      if (v2 < 0)
      {
        v8 = WaitOnCondition(v12, v11);
      }
      else if (v5)
      {
        v8 = WaitOnConditionTimedRelative(v12, v11, v2);
      }
      else
      {
        v8 = WaitOnConditionTimed(v12, v11, v2);
      }
      if (*(_BYTE *)(a1 + 80))
      {
        v7 = *(_QWORD *)(a1 + 72) - 1;
        goto LABEL_21;
      }
    }
    --*(_QWORD *)(a1 + 72);
    if (v8)
    {
      if (v8 == 60)
        v13 = 4294954504;
      else
        v13 = v8;
    }
    else
    {
      v15 = v9 < 1;
      v16 = v9 - 1;
      if (v15)
      {
        v13 = 4294954504;
      }
      else
      {
        v13 = 0;
        *(_QWORD *)(a1 + 56) = v16;
      }
    }
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v13;
}

uint64_t WaitOnCondition(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = pthread_cond_wait(a1, a2);
  v3 = v2;
  if ((_DWORD)v2)
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  return v3;
}

void FigMemoryBarrier()
{
  __dmb(0xBu);
}

uint64_t FigAtomicIncrement32(unsigned int *a1)
{
  unsigned int v1;
  uint64_t v2;

  do
  {
    v1 = __ldxr(a1);
    v2 = v1 + 1;
  }
  while (__stxr(v2, a1));
  return v2;
}

uint64_t FigAtomicDecrement32(unsigned int *a1)
{
  unsigned int v1;
  uint64_t v2;

  do
  {
    v1 = __ldxr(a1);
    v2 = v1 - 1;
  }
  while (__stxr(v2, a1));
  return v2;
}

void *FigBaseGetClassID()
{
  return &kFigBaseClassID;
}

uint64_t FigBaseClassRegisterClass(uint64_t a1, _QWORD *a2, char a3, _QWORD *a4)
{
  _QWORD *v8;
  malloc_zone_t *MallocZoneForPermanentAllocations;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  malloc_zone_t *v16;

  if (!a1 || !a2 || !a4)
  {
LABEL_13:
    v15 = 4294954516;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  if ((a3 & 1) != 0)
  {
    v8 = a2;
    while (!v8[14])
    {
      v8 = (_QWORD *)*v8;
      if (!v8)
        goto LABEL_8;
    }
    goto LABEL_13;
  }
LABEL_8:
  MallocZoneForPermanentAllocations = (malloc_zone_t *)FigGetMallocZoneForPermanentAllocations();
  v10 = malloc_type_zone_calloc(MallocZoneForPermanentAllocations, 1uLL, 0x78uLL, 0x10F0040C6888576uLL);
  if (!v10)
  {
    v15 = 4294954510;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  v11 = v10;
  *v10 = a2;
  v10[1] = a1;
  if ((a3 & 1) == 0)
    goto LABEL_11;
  v10[2] = 0;
  v10[3] = *(_QWORD *)(a1 + 8);
  v10[4] = FigBaseObjectInit;
  v10[5] = 0;
  v10[6] = FigBaseObjectFinalize;
  v10[7] = FigBaseObjectEqual;
  v10[8] = 0;
  v10[9] = *(_QWORD *)(a1 + 24);
  v10[10] = FigBaseObjectCopyDebugDescription;
  v12 = _CFRuntimeRegisterClass();
  v11[14] = v12;
  if (!v12)
  {
    v13 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)v13)
    {
      v16 = (malloc_zone_t *)FigGetMallocZoneForPermanentAllocations();
      malloc_zone_free(v16, v11);
    }
  }
  else
  {
LABEL_11:
    v13 = 0;
    *a4 = v11;
  }
  return v13;
}

uint64_t FigBaseObjectInit(uint64_t result)
{
  *(_QWORD *)(result + 24) = 0;
  return result;
}

uint64_t FigBaseObjectGetDerivedStorage(uint64_t a1)
{
  if (a1)
    return a1 + 32;
  else
    return 0;
}

uint64_t FigBaseObjectGetVTable(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

BOOL FigReentrantMutexTryLock(pthread_mutex_t *a1)
{
  return pthread_mutex_trylock(a1) == 0;
}

uint64_t FigSemaphoreSignal(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;

  v2 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if ((_DWORD)v2)
    return v2;
  if (!*(_BYTE *)(a1 + 80))
  {
    v4 = *(_QWORD *)(a1 + 56);
    if (v4 >= *(_QWORD *)(a1 + 64))
    {
      LOBYTE(v3) = 1;
    }
    else
    {
      LOBYTE(v3) = 0;
      *(_QWORD *)(a1 + 56) = v4 + 1;
    }
    goto LABEL_8;
  }
  v3 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
  if (!(_DWORD)v3)
  {
LABEL_8:
    v5 = pthread_cond_signal((pthread_cond_t *)(a1 + 8));
    if ((v3 & (v5 == 0)) != 0)
      v3 = 4294954505;
    else
      v3 = v5;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v3;
}

uint64_t createHostTimeClock()
{
  uint64_t v0;
  __int128 v2;
  uint64_t v3;

  v0 = *MEMORY[0x1E0C9AE00];
  v2 = *(_OWORD *)&kCMTimeZero.value;
  v3 = 0;
  return FigDerivedClockCreateWithGetTimeCallback(v0, gFigHostTimeClockCallbacks, 0, &v2, 0, &sHostTimeClock);
}

uint64_t FigDerivedClockCreateWithGetTimeCallback(uint64_t a1, _QWORD *a2, const void *a3, __int128 *a4, char a5, uint64_t *a6)
{
  size_t v11;
  uint64_t Instance;
  uint64_t v13;
  CFTypeRef v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  __int128 v19;
  CMTime time2;
  CMTime time1;

  if (!a2 || !a6 || !a2[6])
  {
    v15 = 4294954551;
    goto LABEL_11;
  }
  if (*a2 != 1)
  {
    v15 = 4294954550;
LABEL_11:
    v16 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    v13 = 0;
    if (!(_DWORD)v16)
      goto LABEL_14;
    goto LABEL_12;
  }
  v11 = a2[1];
  FigThreadRunOnce(&CMClockGetTypeID_sRegisterFigClockOnce, (void (*)(void))registerFigClock);
  Instance = _CFRuntimeCreateInstance();
  v13 = Instance;
  if (Instance)
  {
    if (v11)
      bzero((void *)(Instance + 208), v11);
    if (a3)
      v14 = CFRetain(a3);
    else
      v14 = 0;
    *(_QWORD *)(v13 + 32) = v14;
  }
  else
  {
    v18 = FigSignalErrorAt(4294954549, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)v18)
    {
      v16 = v18;
      v13 = 0;
      goto LABEL_15;
    }
  }
  *(_QWORD *)(v13 + 24) = a2;
  *(_DWORD *)(v13 + 44) = 1735680866;
  *(_BYTE *)(v13 + 73) = a5;
  v19 = *a4;
  *(_QWORD *)(v13 + 64) = *((_QWORD *)a4 + 2);
  *(_OWORD *)(v13 + 48) = v19;
  *(_QWORD *)(v13 + 16) = FigReentrantMutexCreate();
  *(_BYTE *)(v13 + 74) = 1;
  *(_BYTE *)(v13 + 72) = 0;
  if ((*(_DWORD *)(v13 + 60) & 0x1D) != 1
    || (time1 = *(CMTime *)(v13 + 48),
        *(_OWORD *)&time2.value = *(_OWORD *)&kCMTimeZero.value,
        time2.epoch = 0,
        !CMTimeCompare(&time1, &time2)))
  {
    *(_BYTE *)(v13 + 72) = 1;
    goto LABEL_28;
  }
  if (*(_BYTE *)(v13 + 72))
  {
LABEL_28:
    v16 = 0;
    *(_BYTE *)(v13 + 41) = 1;
    goto LABEL_15;
  }
  if (*(_QWORD *)(v13 + 32))
  {
    *(_OWORD *)(v13 + 152) = *(_OWORD *)&kCMTimeZero.value;
    *(_QWORD *)(v13 + 168) = 0;
    *(_OWORD *)(v13 + 128) = *(_OWORD *)&kCMTimeZero.value;
    *(_QWORD *)(v13 + 144) = 0;
    goto LABEL_28;
  }
  v16 = FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v16)
  {
LABEL_12:
    if (v13)
    {
      CFRelease((CFTypeRef)v13);
      v13 = 0;
    }
  }
LABEL_14:
  if (a6)
LABEL_15:
    *a6 = v13;
  return v16;
}

uint64_t registerFigClock()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigClockID = result;
  return result;
}

double fcInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[11] = 0u;
  a1[12] = 0u;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

CFTypeRef FigClockRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void FigClockRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t figTimebaseCreate(uint64_t a1, char a2, _QWORD *a3)
{
  unsigned int v5;
  uint64_t Instance;
  _QWORD *v7;
  pthread_mutex_t *v8;
  dispatch_queue_t v9;
  CFNotificationCenterRef DefaultLocalCenter;
  uint64_t v11;
  uint64_t v12;

  v5 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimebaseTrace[1], CFSTR("timebase_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v5, 0, gFigTimebaseTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1ECDA8438, CFSTR("timebase_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1ECDA8430);
  if (!a3)
  {
    v12 = 4294954548;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  FigThreadRunOnce(&CMTimebaseGetTypeID_sRegisterFigTimebaseOnce, (void (*)(void))registerFigTimebase);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v12 = 4294954546;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v7 = (_QWORD *)Instance;
  v8 = FigReentrantMutexCreate();
  v7[14] = v8;
  if (!v8
    || (a2 & 1) != 0
    && (v9 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.timebase.notification", 0, 0),
        (v7[15] = v9) == 0))
  {
    v11 = FigSignalErrorAt(4294954546, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  v11 = CMNotificationCenterRegisterForBarrierSupport((uint64_t)DefaultLocalCenter, (uint64_t)v7);
  if ((_DWORD)v11)
  {
LABEL_12:
    CFRelease(v7);
    return v11;
  }
  *a3 = v7;
  return v11;
}

uint64_t registerFigTimebase()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigTimebaseID = result;
  return result;
}

double ftbInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 320) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void FigTimebaseRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

CFTypeRef FigTimebaseRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

uint64_t figTimebaseFindUltimateMasterClock(pthread_mutex_t **a1, uint64_t *a2)
{
  pthread_mutex_t **v3;
  pthread_mutex_t **v4;
  uint64_t UltimateMasterClock;
  uint64_t v6;
  uint64_t v8;

  v3 = figTimebaseCopyTargetTimebase(a1);
  v4 = v3;
  UltimateMasterClock = (uint64_t)v3[16];
  if (UltimateMasterClock)
  {
    if (a2)
    {
      v6 = 1;
LABEL_6:
      *a2 = v6;
    }
  }
  else
  {
    v8 = 0;
    UltimateMasterClock = figTimebaseFindUltimateMasterClock(v3[17], &v8);
    if (a2)
    {
      v6 = v8 + 1;
      goto LABEL_6;
    }
  }
  CFRelease(v4);
  return UltimateMasterClock;
}

uint64_t figTimebaseSwitchListenersToNewMaster(void *a1, const void *a2, unint64_t a3)
{
  __CFNotificationCenter *DefaultLocalCenter;
  __CFNotificationCenter *v7;
  __CFNotificationCenter *v8;
  __CFNotificationCenter *v9;
  __CFNotificationCenter *v10;
  __CFNotificationCenter *v11;
  uint64_t result;
  __CFNotificationCenter *v13;
  __CFNotificationCenter *v14;
  __CFNotificationCenter *v15;
  __CFNotificationCenter *v16;

  if (a2)
  {
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)figTimebaseEffectiveRateChangedNotificationCallback, CFSTR("CMTimebaseEffectiveRateChanged"), a2);
    v7 = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(v7, a1, (uint64_t)figTimebaseTimeJumpedNotificationCallback, CFSTR("CMTimebaseTimeJumped"), a2);
    v8 = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(v8, a1, (uint64_t)figTimebaseTimeJumpedNotificationCallback, CFSTR("CMTimebaseTimeAdjusted"), a2);
    v9 = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(v9, a1, (uint64_t)figTimebaseMasterDidChangeNotificationCallback, CFSTR("CMTimebaseMasterDidChange"), a2);
    v10 = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(v10, a1, (uint64_t)figTimebaseMasterWillChangeNotificationCallback, CFSTR("CMTimebaseMasterWillChange"), a2);
  }
  if (!a3)
    return 0;
  v11 = CMNotificationCenterGetDefaultLocalCenter();
  result = FigNotificationCenterAddWeakListener(v11, a1, (CFNotificationCallback)figTimebaseEffectiveRateChangedNotificationCallback, CFSTR("CMTimebaseEffectiveRateChanged"), a3, 0, 0);
  if (!(_DWORD)result)
  {
    v13 = CMNotificationCenterGetDefaultLocalCenter();
    result = FigNotificationCenterAddWeakListener(v13, a1, (CFNotificationCallback)figTimebaseTimeJumpedNotificationCallback, CFSTR("CMTimebaseTimeJumped"), a3, 0, 0);
    if (!(_DWORD)result)
    {
      v14 = CMNotificationCenterGetDefaultLocalCenter();
      result = FigNotificationCenterAddWeakListener(v14, a1, (CFNotificationCallback)figTimebaseTimeJumpedNotificationCallback, CFSTR("CMTimebaseTimeAdjusted"), a3, 0, 0);
      if (!(_DWORD)result)
      {
        v15 = CMNotificationCenterGetDefaultLocalCenter();
        result = FigNotificationCenterAddWeakListener(v15, a1, (CFNotificationCallback)figTimebaseMasterDidChangeNotificationCallback, CFSTR("CMTimebaseMasterDidChange"), a3, 0, 0);
        if (!(_DWORD)result)
        {
          v16 = CMNotificationCenterGetDefaultLocalCenter();
          return FigNotificationCenterAddWeakListener(v16, a1, (CFNotificationCallback)figTimebaseMasterWillChangeNotificationCallback, CFSTR("CMTimebaseMasterWillChange"), a3, 0, 0);
        }
      }
    }
  }
  return result;
}

unint64_t FigGetUpTimeNanoseconds()
{
  uint64_t v0;

  v0 = mach_absolute_time();
  return FigHostTimeToNanoseconds(v0);
}

unint64_t FigHostTimeToNanoseconds(int64_t a1)
{
  unint64_t result;
  uint64_t v4;
  uint64_t v5;

  v4 = 0;
  v5 = 0;
  FigGetHostTimeToNanosecondsScale(&v5, &v4);
  result = a1;
  if (v5 != 1 || v4 != 1)
    return FigInt64MulDiv(a1, v5, v4, 0);
  return result;
}

void FigGetHostTimeToNanosecondsScale(_QWORD *a1, _QWORD *a2)
{
  uint32_t denom;
  mach_timebase_info info;

  denom = FigGetHostTimeToNanosecondsScale_denom;
  if (!FigGetHostTimeToNanosecondsScale_denom)
  {
    info = 0;
    if (mach_timebase_info(&info))
    {
      denom = FigGetHostTimeToNanosecondsScale_denom;
    }
    else
    {
      FigGetHostTimeToNanosecondsScale_numer = info.numer;
      FigMemoryBarrier();
      denom = info.denom;
      FigGetHostTimeToNanosecondsScale_denom = info.denom;
    }
  }
  *a1 = FigGetHostTimeToNanosecondsScale_numer;
  *a2 = denom;
}

unint64_t FigInt64MulDiv(int64_t a1, signed int a2, signed int a3, _DWORD *a4)
{
  _BOOL4 v5;
  _BOOL4 v6;
  int v7;
  int v8;
  unint64_t result;
  unint64_t v10;

  v5 = a1 >= 0;
  if (a1 < 0)
    a1 = -a1;
  v6 = a2 >= 0;
  if (a2 < 0)
    a2 = -a2;
  v7 = v5 ^ v6;
  v8 = a3 < 0;
  if (a3 < 0)
    a3 = -a3;
  result = FigUInt64MulDiv(a1, a2, a3, a4);
  v10 = result;
  if (result >= 0x7FFFFFFFFFFFFFFFLL)
    result = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 != v8)
  {
    if (a4)
      *a4 = -*a4;
    if (v10 <= 0x7FFFFFFFFFFFFFFELL)
      return -(uint64_t)result;
    else
      return 0x8000000000000000;
  }
  return result;
}

unint64_t FigUInt64MulDiv(unint64_t a1, unsigned int a2, unsigned int a3, _DWORD *a4)
{
  int v4;
  unint64_t v5;
  int v6;
  unint64_t v7;

  if (!a3)
    goto LABEL_11;
  if (!a2)
  {
    v4 = 0;
    LODWORD(a1) = 0;
    LODWORD(v5) = 0;
    goto LABEL_12;
  }
  if (a2 == a3)
  {
    v4 = 0;
    v5 = HIDWORD(a1);
    goto LABEL_12;
  }
  if (!(a1 >> 15) && !HIWORD(a2))
  {
    LODWORD(v5) = 0;
    v6 = a1 * a2;
    LODWORD(a1) = a1 * a2 / a3;
    v4 = v6 - a1 * a3;
    goto LABEL_12;
  }
  v7 = a1 * (unint64_t)a2;
  v5 = HIDWORD(v7) + HIDWORD(a1) * (unint64_t)a2;
  if (HIDWORD(v5) < a3)
  {
    a1 = (v7 | ((v5 % a3) << 32)) / a3;
    v4 = v7 - a1 * a3;
    LODWORD(v5) = v5 / a3;
  }
  else
  {
LABEL_11:
    v4 = 0;
    LODWORD(a1) = -1;
    LODWORD(v5) = -1;
  }
LABEL_12:
  if (a4)
    *a4 = v4;
  return a1 | ((unint64_t)v5 << 32);
}

double FigSyncGetRelativeRate(void *a1, void *a2)
{
  int PivotTransform;
  double result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = 0;
  v5 = 0u;
  v6 = 0u;
  v4 = 0u;
  PivotTransform = figSyncGetPivotTransform(a2, a1, (uint64_t)&v4);
  result = *((double *)&v5 + 1);
  if (PivotTransform)
    return NAN;
  return result;
}

uint64_t figSyncGetPivotTransform(void *a1, void *a2, uint64_t a3)
{
  void *v4;
  pthread_mutex_t *v6;
  int v7;
  BOOL v8;
  CFTypeID v9;
  pthread_mutex_t **v10;
  int v11;
  uint64_t TransformRelativeToMaster;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  uint64_t TransformRelativeToUltimateMasterClock;
  CFTypeID v17;
  pthread_mutex_t *v18;
  OpaqueCMTimebase *v19;
  OpaqueCMTimebase *v20;
  OpaqueCMTimebase *v21;
  OpaqueCMTimebase *v22;
  const void *v23;
  __int128 v24;
  uint64_t v26;
  CMClockOrTimebaseRef v27;
  pthread_mutex_t *v28;
  pthread_mutex_t *v29;
  int64_t v30;
  int64_t v31;
  OpaqueCMTimebase *v32;
  BOOL v33;
  pthread_mutex_t **v34;
  uint64_t v35;
  OpaqueCMTimebase *v36;
  pthread_mutex_t *v37;
  CMTimebaseRef v38;
  BOOL v39;
  OpaqueCMTimebase *v40;
  OpaqueCMTimebase *v41;
  CMTimebaseRef v42;
  char *v43;
  uint64_t TransformRelativeToMasterAtHeight;
  uint64_t v45;
  pthread_mutex_t *v46;
  pthread_mutex_t *v47;
  CMClockOrTimebaseRef v48;
  pthread_mutex_t *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  pthread_mutex_t *v58;
  pthread_mutex_t *v59;
  _OWORD v60[3];
  uint64_t v61;
  __int128 v62[3];
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;

  v67 = 0;
  v65 = 0u;
  v66 = 0u;
  v64 = 0u;
  v63 = 0;
  memset(v62, 0, sizeof(v62));
  v61 = 0;
  memset(v60, 0, sizeof(v60));
  v58 = 0;
  v59 = 0;
  if (!a1 || (v4 = a2) == 0 || !a3)
  {
    TransformRelativeToMaster = FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
    goto LABEL_44;
  }
  if (a1 == a2)
  {
    v66 = *(_OWORD *)&kCMTimeZero.value;
    v67 = 0;
    v64 = *(_OWORD *)&kCMTimeZero.value;
    *(_QWORD *)&v65 = 0;
    *((_QWORD *)&v65 + 1) = 0x3FF0000000000000;
LABEL_45:
    TransformRelativeToMaster = 0;
    v24 = v65;
    *(_OWORD *)a3 = v64;
    *(_OWORD *)(a3 + 16) = v24;
    *(_OWORD *)(a3 + 32) = v66;
    *(_QWORD *)(a3 + 48) = v67;
    return TransformRelativeToMaster;
  }
  v6 = figSyncCopyUltimateMasterClockAndHeight(a1, &v59);
  v49 = figSyncCopyUltimateMasterClockAndHeight(v4, &v58);
  v7 = CFEqual(v6, v49);
  if (v58)
    v8 = v59 == 0;
  else
    v8 = 1;
  if (v8 && v7)
  {
    v9 = CFGetTypeID(a1);
    if (v9 == CMClockGetTypeID())
    {
      v10 = (pthread_mutex_t **)v4;
      v11 = 1;
    }
    else
    {
      v10 = (pthread_mutex_t **)a1;
      v11 = 0;
    }
    TransformRelativeToUltimateMasterClock = FigTimebaseGetTransformRelativeToUltimateMasterClock(v10, v11, (uint64_t)&v64);
    goto LABEL_25;
  }
  if (v7)
  {
    v13 = CFGetTypeID(a1);
    if (v13 != CMClockGetTypeID())
    {
      v14 = CFGetTypeID(v4);
      if (v14 != CMClockGetTypeID())
      {
        v48 = CMTimebaseCopySource((CMTimebaseRef)a1);
        if (v48 == v4)
        {
          TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMaster((pthread_mutex_t **)a1, 0, (uint64_t)&v64);
          v19 = 0;
          v20 = 0;
          v21 = 0;
          v22 = 0;
          goto LABEL_27;
        }
        v27 = CMTimebaseCopySource((CMTimebaseRef)v4);
        if (v27 == a1)
        {
          TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMaster((pthread_mutex_t **)v4, 1, (uint64_t)&v64);
          v19 = 0;
          v20 = 0;
          v21 = 0;
          v22 = 0;
          v23 = a1;
        }
        else
        {
          v23 = v27;
          v47 = v6;
          v29 = v58;
          v28 = v59;
          v30 = (char *)v59 - (char *)v58;
          v19 = (OpaqueCMTimebase *)CFRetain(a1);
          v20 = (OpaqueCMTimebase *)CFRetain(v4);
          if (v30 < 1)
          {
            if (v30 < 0)
            {
              do
              {
                v36 = v20;
                v20 = CMTimebaseCopySourceTimebase(v20);
                CFRelease(v36);
                v33 = __CFADD__(v30++, 1);
              }
              while (!v33);
            }
            v34 = &v59;
          }
          else
          {
            v31 = (char *)v29 - (char *)v28;
            do
            {
              v32 = v19;
              v19 = CMTimebaseCopySourceTimebase(v19);
              CFRelease(v32);
              v33 = __CFADD__(v31++, 1);
            }
            while (!v33);
            v34 = &v58;
          }
          v37 = *v34;
          v21 = CMTimebaseCopySourceTimebase(v19);
          v38 = CMTimebaseCopySourceTimebase(v20);
          v22 = v38;
          if (v37)
            v39 = v21 == v38;
          else
            v39 = 1;
          if (!v39)
          {
            do
            {
              v40 = v19;
              v41 = v20;
              v19 = v21;
              v20 = v22;
              CFRelease(v40);
              v21 = CMTimebaseCopySourceTimebase(v21);
              CFRelease(v41);
              v42 = CMTimebaseCopySourceTimebase(v22);
              v22 = v42;
              v37 = (pthread_mutex_t *)((char *)v37 - 1);
            }
            while (v37 && v21 != v42);
          }
          v43 = &v37[-1].__opaque[55];
          v46 = v58;
          TransformRelativeToMasterAtHeight = FigTimebaseGetTransformRelativeToMasterAtHeight((pthread_mutex_t **)a1, (char *)v59 - v43, 0, (uint64_t)v62);
          if (!(_DWORD)TransformRelativeToMasterAtHeight)
          {
            TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMasterAtHeight((pthread_mutex_t **)v4, (char *)v46 - v43, 1, (uint64_t)v60);
            v6 = v47;
            v4 = (void *)v48;
            v18 = v49;
            if ((_DWORD)TransformRelativeToMaster)
              goto LABEL_28;
            goto LABEL_80;
          }
          TransformRelativeToMaster = TransformRelativeToMasterAtHeight;
          v6 = v47;
        }
        v4 = (void *)v48;
        v18 = v49;
        goto LABEL_28;
      }
    }
  }
  v15 = CFGetTypeID(a1);
  if (v15 == CMClockGetTypeID())
  {
    TransformRelativeToUltimateMasterClock = FigClockGetTransformRelativeToHostTimeClock((uint64_t)a1, 0, (uint64_t)v62);
    if ((_DWORD)TransformRelativeToUltimateMasterClock)
    {
LABEL_25:
      TransformRelativeToMaster = TransformRelativeToUltimateMasterClock;
LABEL_26:
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v4 = 0;
LABEL_27:
      v23 = 0;
      v18 = v49;
      goto LABEL_28;
    }
  }
  else
  {
    v57 = 0;
    v55 = 0u;
    v56 = 0u;
    v54 = 0u;
    v53 = 0;
    v51 = 0u;
    v52 = 0u;
    v50 = 0u;
    TransformRelativeToMaster = FigTimebaseGetTransformRelativeToUltimateMasterClock((pthread_mutex_t **)a1, 0, (uint64_t)&v54);
    if ((_DWORD)TransformRelativeToMaster)
      goto LABEL_26;
    TransformRelativeToMaster = FigClockGetTransformRelativeToHostTimeClock((uint64_t)v6, 0, (uint64_t)&v50);
    if ((_DWORD)TransformRelativeToMaster)
      goto LABEL_26;
    FigSyncCombineTransforms(&v54, (uint64_t)&v50, (uint64_t)v62);
    TransformRelativeToMaster = v26;
    if ((_DWORD)v26)
      goto LABEL_26;
  }
  v17 = CFGetTypeID(v4);
  v18 = v49;
  if (v17 != CMClockGetTypeID())
  {
    v57 = 0;
    v55 = 0u;
    v56 = 0u;
    v54 = 0u;
    v53 = 0;
    v51 = 0u;
    v52 = 0u;
    v50 = 0u;
    TransformRelativeToMaster = FigClockGetTransformRelativeToHostTimeClock((uint64_t)v49, 1, (uint64_t)&v54);
    if ((_DWORD)TransformRelativeToMaster
      || (TransformRelativeToMaster = FigTimebaseGetTransformRelativeToUltimateMasterClock((pthread_mutex_t **)v4, 1, (uint64_t)&v50), (_DWORD)TransformRelativeToMaster)|| (FigSyncCombineTransforms(&v54, (uint64_t)&v50, (uint64_t)v60), TransformRelativeToMaster = v35, (_DWORD)v35))
    {
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v4 = 0;
      v23 = 0;
      goto LABEL_28;
    }
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v4 = 0;
    v23 = 0;
LABEL_80:
    FigSyncCombineTransforms(v62, (uint64_t)v60, (uint64_t)&v64);
    TransformRelativeToMaster = v45;
    goto LABEL_28;
  }
  TransformRelativeToMaster = FigClockGetTransformRelativeToHostTimeClock((uint64_t)v4, 1, (uint64_t)v60);
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v4 = 0;
  v23 = 0;
  if (!(_DWORD)TransformRelativeToMaster)
    goto LABEL_80;
LABEL_28:
  if (v6)
    CFRelease(v6);
  if (v18)
    CFRelease(v18);
  if (v19)
    CFRelease(v19);
  if (v20)
    CFRelease(v20);
  if (v21)
    CFRelease(v21);
  if (v22)
    CFRelease(v22);
  if (v4)
    CFRelease(v4);
  if (v23)
    CFRelease(v23);
LABEL_44:
  if (!(_DWORD)TransformRelativeToMaster)
    goto LABEL_45;
  return TransformRelativeToMaster;
}

uint64_t figTimebaseSetRateAndMaybeAnchorTime(uint64_t a1, __int128 *a2, CMTime *a3, int a4, double a5)
{
  CMTime *v6;
  CMTimeFlags flags;
  BOOL v11;
  _BOOL4 v13;
  uint64_t v14;
  int v15;
  CFMutableDictionaryRef Mutable;
  __CFNotificationCenter *DefaultLocalCenter;
  _OWORD *v18;
  double EffectiveRate;
  _OWORD *v21;
  __int128 v22;
  __int128 v23;
  int v24;
  double v25;
  double v26;
  char v27;
  double v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  const __CFAllocator *v34;
  CFDictionaryRef v35;
  CMTime v36;
  CMTime v37;
  CMTime v38;
  CMTime time1;

  v6 = a3;
  flags = a3->flags;
  memset(&v38, 0, sizeof(v38));
  memset(&v37, 0, sizeof(v37));
  v11 = (a4 & 1) == 0;
  if (a5 != 0.0 || (a4 & 2) == 0)
    v13 = 0;
  else
    v13 = (*((_BYTE *)a2 + 12) & 1) == 0 && (flags & 1) == 0;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 16) == 1)
    {
      v14 = 4294954539;
      return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    }
    if (((*((_DWORD *)a2 + 3) ^ flags) & 1) != 0)
    {
      v14 = 4294954547;
      return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    }
    v15 = flags & 1;
    time1 = *(CMTime *)a2;
    v36 = *a3;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    FigCFDictionarySetDouble(Mutable, CFSTR("CMTimebaseRate"), a5);
    FigCFDictionarySetCMTime(Mutable, CFSTR("CMTimebaseTimebaseTime"), &time1);
    time1 = v36;
    FigCFDictionarySetCMTime(Mutable, CFSTR("CMTimebaseSourceTime"), &time1);
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("CMTimebaseWillUpdateTiming"), (const void *)a1, Mutable);
    if (Mutable)
      CFRelease(Mutable);
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 112));
    v18 = (_OWORD *)(a1 + 160);
    if (*(double *)(a1 + 184) == a5)
    {
      if (!v15
        || a5 == 0.0
        && (time1 = *(CMTime *)(a1 + 192), v36 = *(CMTime *)a2, !CMTimeCompare(&time1, &v36))
        && (*(_OWORD *)&time1.value = *v18, time1.epoch = *(_QWORD *)(a1 + 176), v36 = *v6, !CMTimeCompare(&time1, &v36)))
      {
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
        return 0;
      }
    }
    EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    figTimebaseGetMasterTime((pthread_mutex_t **)a1, (uint64_t)&v38);
    if (v13)
    {
      LOBYTE(v36.value) = 0;
      memset(&time1, 0, sizeof(time1));
      figTimebaseGetAnchorTimebaseTimeIfClamped((pthread_mutex_t **)a1, (char *)&v36, (uint64_t)&time1);
      if (LOBYTE(v36.value))
      {
        *(CMTime *)a2 = time1;
        *v6 = v38;
        v15 = 1;
      }
    }
    v21 = (_OWORD *)(a1 + 192);
    if (v15)
    {
      v22 = *a2;
      *(_QWORD *)(a1 + 208) = *((_QWORD *)a2 + 2);
      *v21 = v22;
    }
    else
    {
      figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a1, 1, 0, &time1);
      *v21 = *(_OWORD *)&time1.value;
      *(_QWORD *)(a1 + 208) = time1.epoch;
      v6 = &v38;
    }
    v23 = *(_OWORD *)&v6->value;
    *(_QWORD *)(a1 + 176) = v6->epoch;
    *v18 = v23;
    *(double *)(a1 + 184) = a5;
    *(_BYTE *)(a1 + 216) = 0;
    if (a5 != 0.0)
    {
      FigSyncInvertTransform(a1 + 160, a1 + 224);
      if (!v24)
        *(_BYTE *)(a1 + 216) = 1;
    }
    time1 = v38;
    figTimebaseGetTimeAtMasterTime((pthread_mutex_t **)a1, &time1, &v37);
    v25 = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    v26 = v25;
    if (v15)
    {
      v27 = a4 & 1;
    }
    else
    {
      v11 = 1;
      v27 = 1;
      if (v25 == EffectiveRate)
        goto LABEL_50;
    }
    v28 = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    v29 = *(_DWORD *)(a1 + 320);
    if (v28 > 0.0)
      v30 = 1;
    else
      v30 = -1;
    if (v28 == 0.0)
      v30 = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 320) = v30;
    v31 = a4 & (v15 != 0);
    if (v26 != EffectiveRate)
      v31 = 0;
    if (v29 == v30)
      v32 = 1;
    else
      v32 = v31;
    v33 = (a4 | (v15 == 0)) & v32;
    if (*(_QWORD *)(a1 + 280))
    {
      time1 = v37;
      rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a1, &time1, v33);
    }
    if (*(_QWORD *)(a1 + 304))
    {
      time1 = v37;
      rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a1, &time1, v33);
    }
LABEL_50:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    v34 = CFGetAllocator((CFTypeRef)a1);
    time1 = v37;
    v35 = figTimebaseCreatePayloadForNotificationAtTime(v34, &time1);
    if (v26 != EffectiveRate)
      figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseEffectiveRateChanged"), v35);
    if ((v27 & 1) != 0)
    {
      if (v11)
        goto LABEL_54;
    }
    else
    {
      figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseTimeJumped"), v35);
      if (v11)
      {
LABEL_54:
        if (v35)
LABEL_55:
          CFRelease(v35);
        return 0;
      }
    }
    figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseTimeAdjusted"), v35);
    if (!v35)
      return 0;
    goto LABEL_55;
  }
  return 4294954548;
}

void figTimebaseGetMasterTime(pthread_mutex_t **a1@<X0>, uint64_t a2@<X8>)
{
  pthread_mutex_t **v3;
  pthread_mutex_t *v4;
  OpaqueCMClock *v5;
  pthread_mutex_t *v6;
  pthread_mutex_t **v7;

  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v3 = figTimebaseCopyTargetTimebase(a1);
  FigReentrantMutexLock(v3[14]);
  v4 = v3[16];
  if (v4)
    v5 = (OpaqueCMClock *)CFRetain(v4);
  else
    v5 = 0;
  v6 = v3[17];
  if (v6)
    v7 = (pthread_mutex_t **)CFRetain(v6);
  else
    v7 = 0;
  FigReentrantMutexUnlock(v3[14]);
  if (v5)
  {
    CMClockGetTime((CMTime *)a2, v5);
    if (!v7)
      goto LABEL_10;
    goto LABEL_9;
  }
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v7, 1, 0, (CMTime *)a2);
  if (v7)
LABEL_9:
    CFRelease(v7);
LABEL_10:
  if (v5)
    CFRelease(v5);
  CFRelease(v3);
}

__n128 FigSyncInvertTransform(uint64_t a1, uint64_t a2)
{
  double v3;
  uint64_t v4;
  __n128 result;
  double v6;
  __n128 v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v9 = 0uLL;
  v8 = 0;
  v7 = 0uLL;
  if (a1 && (*(_DWORD *)(a1 + 44) & 0x1D) == 1 && (*(_DWORD *)(a1 + 12) & 0x1D) == 1)
  {
    v3 = *(double *)(a1 + 24);
    if (v3 != 0.0)
    {
      v7 = *(__n128 *)a1;
      v8 = *(_QWORD *)(a1 + 16);
      v9 = *(_OWORD *)(a1 + 32);
      v10 = *(_QWORD *)(a1 + 48);
      v6 = 1.0 / v3;
      goto LABEL_9;
    }
    v4 = 4294954541;
  }
  else
  {
    v4 = 4294954544;
  }
  if (FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0))
    return result;
  v6 = 0.0;
LABEL_9:
  *(_OWORD *)a2 = v9;
  *(_QWORD *)(a2 + 16) = v10;
  *(double *)(a2 + 24) = v6;
  result = v7;
  *(__n128 *)(a2 + 32) = v7;
  *(_QWORD *)(a2 + 48) = v8;
  return result;
}

uint64_t FigTimebaseGetTransformRelativeToUltimateMasterClock(pthread_mutex_t **a1, int a2, uint64_t a3)
{
  uint64_t v3;
  pthread_mutex_t **v6;
  pthread_mutex_t **v7;
  uint64_t TransformRelativeToMaster;
  __int128 *v9;
  __int128 *v10;
  uint64_t v11;
  CMTimebaseRef v12;
  __int128 v13;
  _OWORD v15[3];
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v3 = 4294954548;
  if (a1 && a3)
  {
    v23 = *(_OWORD *)&kCMTimeZero.value;
    v24 = 0;
    v21 = *(_OWORD *)&kCMTimeZero.value;
    *(_QWORD *)&v22 = 0;
    *((_QWORD *)&v22 + 1) = 0x3FF0000000000000;
    v6 = figTimebaseCopyTargetTimebase(a1);
    if (v6)
    {
      v7 = v6;
      while (1)
      {
        v20 = 0;
        v18 = 0u;
        v19 = 0u;
        v17 = 0u;
        v16 = 0;
        memset(v15, 0, sizeof(v15));
        TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMaster(v7, a2, (uint64_t)v15);
        if ((_DWORD)TransformRelativeToMaster)
          break;
        v17 = v21;
        v18 = v22;
        v19 = v23;
        v20 = v24;
        if (a2)
        {
          v9 = v15;
          v10 = &v17;
        }
        else
        {
          v9 = &v17;
          v10 = v15;
        }
        FigSyncCombineTransforms(v9, (uint64_t)v10, (uint64_t)&v21);
        v3 = v11;
        if ((_DWORD)v11)
          goto LABEL_13;
        v12 = CMTimebaseCopySourceTimebase((CMTimebaseRef)v7);
        CFRelease(v7);
        v7 = (pthread_mutex_t **)v12;
        if (!v12)
          goto LABEL_11;
      }
      v3 = TransformRelativeToMaster;
LABEL_13:
      CFRelease(v7);
    }
    else
    {
LABEL_11:
      v3 = 0;
      v13 = v22;
      *(_OWORD *)a3 = v21;
      *(_OWORD *)(a3 + 16) = v13;
      *(_OWORD *)(a3 + 32) = v23;
      *(_QWORD *)(a3 + 48) = v24;
    }
  }
  return v3;
}

uint64_t FigTimebaseGetTransformRelativeToMaster(pthread_mutex_t **a1, int a2, uint64_t a3)
{
  uint64_t v3;
  pthread_mutex_t **v6;
  pthread_mutex_t **v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  pthread_mutex_t *v13;

  v3 = 4294954548;
  if (a1 && a3)
  {
    v6 = figTimebaseCopyTargetTimebase(a1);
    FigReentrantMutexLock(v6[14]);
    if (a2)
    {
      v7 = v6 + 20;
LABEL_5:
      v10 = *(_OWORD *)v7;
      v11 = *((_OWORD *)v7 + 1);
      v12 = *((_OWORD *)v7 + 2);
      v13 = v7[6];
      FigReentrantMutexUnlock(v6[14]);
      v3 = 0;
      *(_OWORD *)a3 = v10;
      *(_OWORD *)(a3 + 16) = v11;
      *(_OWORD *)(a3 + 32) = v12;
      *(_QWORD *)(a3 + 48) = v13;
LABEL_9:
      CFRelease(v6);
      return v3;
    }
    if (CMTimebaseGetRate((CMTimebaseRef)v6) == 0.0)
    {
      v3 = 4294954541;
    }
    else
    {
      if (*((_BYTE *)v6 + 216))
      {
        v7 = v6 + 28;
        goto LABEL_5;
      }
      v7 = v6 + 28;
      FigSyncInvertTransform((uint64_t)(v6 + 20), (uint64_t)(v6 + 28));
      v3 = v9;
      if (!(_DWORD)v9)
      {
        *((_BYTE *)v6 + 216) = 1;
        goto LABEL_5;
      }
    }
    FigReentrantMutexUnlock(v6[14]);
    goto LABEL_9;
  }
  return v3;
}

double FigSyncCombineTransforms(__int128 *a1, uint64_t a2, uint64_t a3)
{
  double v6;
  double result;
  CMTime v8;
  CMTime v9;
  __int128 v10;
  uint64_t v11;

  v11 = 0;
  v10 = 0uLL;
  memset(&v9, 0, sizeof(v9));
  if ((*((_DWORD *)a1 + 11) & 0x1D) == 1
    && (*((_DWORD *)a1 + 3) & 0x1D) == 1
    && (*(_DWORD *)(a2 + 44) & 0x1D) == 1
    && (*(_DWORD *)(a2 + 12) & 0x1D) == 1)
  {
    v8 = *(CMTime *)(a1 + 2);
    FigSyncApplyTransform(&v8, a2, &v9);
    v10 = *a1;
    v11 = *((_QWORD *)a1 + 2);
    v6 = *((double *)a1 + 3) * *(double *)(a2 + 24);
  }
  else
  {
    if (FigSignalErrorAt(4294954543, 0, 0, 0, 0, 0, 0))
      return result;
    v6 = 0.0;
  }
  *(_OWORD *)a3 = v10;
  *(_QWORD *)(a3 + 16) = v11;
  *(double *)(a3 + 24) = v6;
  result = *(double *)&v9.value;
  *(CMTime *)(a3 + 32) = v9;
  return result;
}

CMTime *FigSyncApplyTransform@<X0>(CMTime *a1@<X0>, uint64_t a2@<X1>, CMTime *a3@<X8>)
{
  _OWORD *v5;
  CMTime v7;
  CMTime lhs;
  CMTime time;
  CMTime v10;

  *(_OWORD *)&a3->value = *(_OWORD *)&kCMTimeInvalid.value;
  a3->epoch = 0;
  if (!a2 || (a1->flags & 0x1D) != 1 || (*(_DWORD *)(a2 + 44) & 0x1D) != 1 || (*(_DWORD *)(a2 + 12) & 0x1D) != 1)
    return (CMTime *)FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
  v5 = (_OWORD *)(a2 + 32);
  lhs = *a1;
  v7 = *(CMTime *)a2;
  CMTimeSubtract(&time, &lhs, &v7);
  CMTimeMultiplyByFloat64(&v10, &time, *(Float64 *)(a2 + 24));
  *(_OWORD *)&lhs.value = *v5;
  lhs.epoch = *(_QWORD *)(a2 + 48);
  return CMTimeAdd(a3, &v10, &lhs);
}

void figTimebaseEffectiveRateChangedNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  double EffectiveRate;
  int v9;
  int v10;
  _BOOL4 v11;
  const __CFAllocator *v12;
  CFDictionaryRef v13;
  CMTime v14;
  CMTime v15;

  memset(&v15, 0, sizeof(v15));
  if (!a2)
  {
    FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
    return;
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
  if (*(_QWORD *)(a2 + 136) != a4)
  {
    FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
LABEL_6:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
    return;
  }
  figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(a5, a2, &v15);
  if (*(double *)(a2 + 184) == 0.0)
    goto LABEL_6;
  EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)a2);
  v9 = *(_DWORD *)(a2 + 320);
  if (EffectiveRate > 0.0)
    v10 = 1;
  else
    v10 = -1;
  if (EffectiveRate == 0.0)
    v10 = *(_DWORD *)(a2 + 320);
  *(_DWORD *)(a2 + 320) = v10;
  v11 = v9 == v10;
  if (*(_QWORD *)(a2 + 280))
  {
    v14 = v15;
    rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a2, &v14, v11);
  }
  if (*(_QWORD *)(a2 + 304))
  {
    v14 = v15;
    rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a2, &v14, v11);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
  v12 = CFGetAllocator((CFTypeRef)a2);
  v14 = v15;
  v13 = figTimebaseCreatePayloadForNotificationAtTime(v12, &v14);
  figTimebasePostNotification((_QWORD *)a2, CFSTR("CMTimebaseEffectiveRateChanged"), v13);
  if (v13)
    CFRelease(v13);
}

CMTime *FigSyncConvertTime@<X0>(CMTime *a1@<X0>, const void *a2@<X1>, const void *a3@<X2>, CMTime *a4@<X8>)
{
  CMTime v5;

  v5 = *a1;
  return CMSyncConvertTime(a4, &v5, a2, a3);
}

uint64_t FigTimebaseSetRateAndAnchorTime(OpaqueCMTimebase *a1, CMTime *a2, CMTime *a3, Float64 a4)
{
  CMTime v5;
  CMTime timebaseTime;

  timebaseTime = *a2;
  v5 = *a3;
  return CMTimebaseSetRateAndAnchorTime(a1, a4, &timebaseTime, &v5);
}

uint64_t FigFilePathCreateFromNativePath(int a1, CFStringRef theString, uint64_t *a3)
{
  char *CStringPtrAndBufferToFree;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v11;

  v11 = 0;
  CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(theString, 0x8000100u, (char **)&v11);
  if (CStringPtrAndBufferToFree)
  {
    v6 = CStringPtrAndBufferToFree;
    if (!strncasecmp(CStringPtrAndBufferToFree, "file://", 7uLL))
      v7 = 7;
    else
      v7 = 0;
    v8 = FigFilePathCreateFromDarwinPath(a1, &v6[v7], a3);
  }
  else
  {
    v8 = FigSignalErrorAt(4294967246, 0, 0, 0, 0, 0, 0);
  }
  v9 = v8;
  free(v11);
  return v9;
}

uint64_t FigFilePathCreateFromDarwinPath(int a1, char *a2, uint64_t *a3)
{
  const char *v4;
  char *v5;
  size_t v6;
  uint64_t Instance;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  char v11[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a2 || !a3)
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  v4 = a2;
  v5 = realpath_DARWIN_EXTSN(a2, v11);
  if (v5)
    v4 = v5;
  v6 = strlen(v4) + 1;
  if (v6 >= 0x401)
  {
    v10 = 4294955096;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  FigFilePathGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v10 = 0xFFFFFFFFLL;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v8 = Instance;
  memcpy((void *)(Instance + 16), v4, v6);
  result = 0;
  *a3 = v8;
  return result;
}

uint64_t FigFilePathGetTypeID()
{
  FigThreadRunOnce(&FigFilePathGetTypeID_sRegisterFigFilePathTypeOnce, (void (*)(void))RegisterFigFilePathType);
  return sFigFilePathID;
}

uint64_t RegisterFigFilePathType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigFilePathID = result;
  return result;
}

uint64_t FigFilePathInit(uint64_t result)
{
  *(_BYTE *)(result + 16) = 0;
  return result;
}

uint64_t RegisterFigBlockBufferType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigBlockBufferID = result;
  return result;
}

void FigRuntimeRegisterAttachmentBearerWithTypeID(_QWORD *a1, const void *a2)
{
  uint64_t v4;

  FigThreadRunOnce(&sFigAttachmentsEnsureAttachmentBearerRegistrationDictionaryOnce, (void (*)(void))figAttachmentsMakeAttachmentBearerRegistrationDictionary);
  if (*a1 || !a1[1] || !a1[2] || !a1[3] || !a1[4] || !a1[5])
    goto LABEL_2;
  v4 = sFigAttachmentBearerCallbacksPerTypeID;
  if (!sFigAttachmentBearerCallbacksPerTypeID)
    goto LABEL_3;
  if (CFDictionaryGetCountOfKey((CFDictionaryRef)sFigAttachmentBearerCallbacksPerTypeID, a2))
  {
LABEL_2:
    v4 = 0;
LABEL_3:
    FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    return;
  }
  CFDictionarySetValue((CFMutableDictionaryRef)sFigAttachmentBearerCallbacksPerTypeID, a2, a1);
}

double BBufInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

uint64_t NewBufferSubBlock(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  uint64_t result;
  const __CFAllocator *v14;
  CMBlockBufferFlags v15;
  uint64_t v16;
  uint64_t v17;

  v17 = 0;
  v6 = *(_DWORD *)(a1 + 32);
  v7 = *(int *)(a1 + 36);
  v8 = v7 - 1;
  if (v6 < (int)v7 - 1)
  {
    v9 = a1 + 48 * v6;
    v17 = v9 + 48;
    *(_QWORD *)(v9 + 64) = a2;
    *(_DWORD *)(a1 + 32) = v6 + 1;
LABEL_6:
    result = 0;
    *(_QWORD *)(a1 + 40) += a2;
    goto LABEL_7;
  }
  v10 = a1 + 48 * v8;
  v12 = *(_DWORD *)(v10 + 48);
  v11 = (_DWORD *)(v10 + 48);
  if (!v12)
  {
    v14 = CFGetAllocator((CFTypeRef)a1);
    result = CMBlockBufferCreateEmpty(v14, *(_DWORD *)(a1 + 36), v15, (CMBlockBufferRef *)(a1 + 48 * v8 + 72));
    if ((_DWORD)result)
      goto LABEL_7;
    *v11 = 1;
    v16 = a1 + 48 * v8;
    *(_QWORD *)(v16 + 56) = 0;
    *(_QWORD *)(v16 + 64) = 0;
    ++*(_DWORD *)(a1 + 32);
  }
  result = NewBufferSubBlock(*(_QWORD *)(a1 + 48 * v8 + 72), a2, &v17);
  if (!(_DWORD)result)
  {
    *(_QWORD *)(a1 + 48 * v8 + 64) += a2;
    goto LABEL_6;
  }
LABEL_7:
  *a3 = v17;
  return result;
}

BOOL FigSimpleMutexTryLock(pthread_mutex_t *a1)
{
  return pthread_mutex_trylock(a1) == 0;
}

uint64_t FigFileForkOpenMainByPath(uint64_t a1, unsigned int a2, int **a3)
{
  int v6;
  int *v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v6 = a2 & 3;
  v7 = (int *)malloc_type_malloc(4uLL, 0x100004052888210uLL);
  if (v7)
  {
    v8 = v7;
    if ((a2 & 0x20) != 0)
      v9 = 16778240;
    else
      v9 = 0x1000000;
    v10 = (a2 >> 2) & 0x20 | v9;
    v11 = (32 * a2) & 0x200;
    if ((a2 & 0x200) != 0)
      v11 = 2560;
    v6 |= v10 | v11;
    v12 = open((const char *)(a1 + 16), v6, 420);
    *v8 = v12;
    if (v12 == -1)
    {
      if (*__error())
        v15 = *__error();
      else
        v15 = 0xFFFFFFFFLL;
      v14 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      if (((a2 & 0x40) == 0 || fcntl(v12, 48, 1) != -1) && ((a2 & 0x100) == 0 || fcntl(*v8, 68, 1) != -1))
      {
        *a3 = v8;
        return 0;
      }
      if (*__error())
        v16 = *__error();
      else
        v16 = 0xFFFFFFFFLL;
      v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      close(*v8);
    }
    free(v8);
  }
  else
  {
    v14 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
  }
  return convertPOSIXErrorToFigFileError(v14, v6);
}

uint64_t FigFileGetDarwinFileDesc(unsigned int *a1)
{
  return *a1;
}

uint64_t FigFileForkClose(int *a1)
{
  int v2;
  uint64_t v3;

  if (!a1)
    return 0;
  v2 = *a1;
  if (v2 == -1 || !close(v2))
    v3 = 0;
  else
    v3 = *__error();
  *a1 = 0;
  free(a1);
  return v3;
}

uint64_t FigByteStreamCreateForFile(uint64_t a1, unsigned int a2, const __CFAllocator *a3, CFTypeRef *a4)
{
  const char *DarwinPath;
  size_t v8;
  CFURLRef v9;
  uint64_t v10;

  DarwinPath = (const char *)FigFileGetDarwinPath(a1);
  v8 = strlen(DarwinPath);
  v9 = CFURLCreateFromFileSystemRepresentation(a3, (const UInt8 *)DarwinPath, v8, 0);
  v10 = CMByteStreamCreateForFileURL((uint64_t)a3, v9, a2, a4);
  if (v9)
    CFRelease(v9);
  return v10;
}

uint64_t RegisterFigByteStreamBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigByteStreamClassDesc, ClassID, 1, &sFigByteStreamClassID);
}

uint64_t FigFileByteStreamRead(uint64_t a1, size_t a2, off_t a3, char *a4, unint64_t *a5)
{
  uint64_t DerivedStorage;
  unint64_t UpTimeNanoseconds;
  int v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  off_t v15;
  BOOL v16;
  size_t v17;
  size_t v18;
  off_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int *v24;
  unint64_t v25;
  unint64_t v26;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v25 = 0;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  if (a2 > 0x1000 || !*(_BYTE *)(DerivedStorage + 4144))
  {
    v20 = FigFileForkReadWithIOPolicy(*(int **)(DerivedStorage + 8), *(_DWORD *)(DerivedStorage + 4216), a4, a2, a3, (uint64_t *)&v25);
    goto LABEL_16;
  }
  v24 = *(int **)(DerivedStorage + 8);
  v11 = *(_DWORD *)(DerivedStorage + 4216);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 4136));
  v12 = *(_QWORD *)(DerivedStorage + 4120);
  v13 = __OFSUB__(a3, v12);
  v14 = a3 - v12;
  if (v14 < 0 == v13)
  {
    v15 = *(_QWORD *)(DerivedStorage + 4128);
    v16 = v15 <= a3;
    v17 = v15 - a3;
    if (!v16)
    {
      if (v17 >= a2)
        v18 = a2;
      else
        v18 = v17;
      memcpy(a4, (const void *)(DerivedStorage + 24 + v14), v18);
      a2 -= v18;
      v19 = v18 + a3;
      if (!a2)
        goto LABEL_9;
LABEL_12:
      v26 = 0;
      v20 = FigFileForkReadWithIOPolicy(v24, v11, (void *)(DerivedStorage + 24), 0x1000uLL, v19, (uint64_t *)&v26);
      *(_QWORD *)(DerivedStorage + 4120) = v19;
      v21 = v26;
      *(_QWORD *)(DerivedStorage + 4128) = v26 + v19;
      if (v21 < a2)
        a2 = v21;
      memcpy(&a4[v18], (const void *)(DerivedStorage + 24), a2);
      v18 += a2;
      goto LABEL_15;
    }
  }
  v18 = 0;
  v19 = a3;
  if (a2)
    goto LABEL_12;
LABEL_9:
  v20 = 0;
LABEL_15:
  v25 = v18;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 4136));
LABEL_16:
  v22 = FigGetUpTimeNanoseconds();
  FigByteStreamStatsLogOneRead((pthread_mutex_t *)(DerivedStorage + 4152), UpTimeNanoseconds, v22, v20, a3, v25);
  if ((_DWORD)v20)
  {
    FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    if (a5)
LABEL_18:
      *a5 = v25;
  }
  else
  {
    if (v25)
      v20 = 0;
    else
      v20 = 4294954423;
    if (a5)
      goto LABEL_18;
  }
  return v20;
}

uint64_t FigFileByteStreamCopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFURLRef *a4)
{
  uint64_t DerivedStorage;
  uint64_t v9;
  const __CFAllocator *v10;
  uint64_t *v11;
  CFNumberType v12;
  CFURLRef StatsDictionary;
  uint64_t AllocatedStorageSpaceLength;
  const __CFURL *v16;
  const void **v17;
  _QWORD v18[3];
  uint64_t valuePtr[128];
  _BYTE v20[32];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, CFSTR("FBS_EntireLength")) || CFEqual(a2, CFSTR("FBS_AvailableLength")))
  {
    valuePtr[0] = 0;
    v9 = CMBaseObjectGetDerivedStorage(a1);
    FigFileForkGetLengthAtOffset(*(int **)(v9 + 8), 0, valuePtr);
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v11 = valuePtr;
    v12 = kCFNumberSInt64Type;
LABEL_4:
    StatsDictionary = CFNumberCreate(v10, v12, v11);
LABEL_5:
    AllocatedStorageSpaceLength = 0;
    goto LABEL_6;
  }
  if (CFEqual(a2, CFSTR("FBS_EntireLengthAvailableOnDemand")))
  {
    if (*(_QWORD *)DerivedStorage)
    {
      StatsDictionary = (CFURLRef)*MEMORY[0x1E0C9AE50];
LABEL_13:
      StatsDictionary = (CFURLRef)CFRetain(StatsDictionary);
      goto LABEL_5;
    }
    return 4294954513;
  }
  if (CFEqual(a2, CFSTR("FBS_URL")))
  {
    StatsDictionary = *(CFURLRef *)DerivedStorage;
    if (*(_QWORD *)DerivedStorage)
      goto LABEL_13;
    return 4294954513;
  }
  if (!CFEqual(a2, CFSTR("FBS_FileType")))
  {
    if (CFEqual(a2, CFSTR("FBS_IOPolicy")))
    {
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v11 = (uint64_t *)(DerivedStorage + 4216);
LABEL_22:
      v12 = kCFNumberIntType;
      goto LABEL_4;
    }
    if (CFEqual(a2, CFSTR("FBS_MIMEType")))
      return 4294954512;
    if (CFEqual(a2, CFSTR("FBS_ReadStats")))
    {
      StatsDictionary = FigByteStreamStatsCreateStatsDictionary(a3, CFSTR("FileByteStream"), *(CFURLRef *)DerivedStorage, DerivedStorage + 4152);
      goto LABEL_5;
    }
    if (CFEqual(a2, CFSTR("FBS_ReadSupported")))
    {
      v17 = (const void **)MEMORY[0x1E0C9AE50];
      if ((*(_BYTE *)(DerivedStorage + 16) & 1) != 0)
        v17 = (const void **)MEMORY[0x1E0C9AE40];
    }
    else
    {
      if (!CFEqual(a2, CFSTR("FBS_WriteSupported")))
      {
        if (CFEqual(a2, CFSTR("FBS_FileDescriptor")))
        {
          LODWORD(valuePtr[0]) = FigFileGetDarwinFileDesc(*(unsigned int **)(DerivedStorage + 8));
          v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v11 = valuePtr;
          goto LABEL_22;
        }
        if (CFEqual(a2, CFSTR("FBS_AllocatedStorageSpaceLength")))
        {
          valuePtr[0] = 0;
          AllocatedStorageSpaceLength = FigFileForkGetAllocatedStorageSpaceLength(*(int **)(DerivedStorage + 8), valuePtr);
          if ((_DWORD)AllocatedStorageSpaceLength)
            return AllocatedStorageSpaceLength;
          StatsDictionary = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], valuePtr[0]);
          goto LABEL_6;
        }
        return 4294954512;
      }
      v17 = (const void **)MEMORY[0x1E0C9AE50];
      if ((*(_BYTE *)(DerivedStorage + 16) & 3) == 0)
        v17 = (const void **)MEMORY[0x1E0C9AE40];
    }
    StatsDictionary = (CFURLRef)*v17;
    if (!*v17)
      goto LABEL_5;
    goto LABEL_13;
  }
  v16 = *(const __CFURL **)DerivedStorage;
  if (!v16)
    return 4294954513;
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  v18[1] = 0;
  v18[2] = 0;
  bzero(valuePtr, 0x400uLL);
  v18[0] = 0x400000000005;
  if (!CFURLGetFileSystemRepresentation(v16, 1u, (UInt8 *)valuePtr, 1024))
    return 4294954513;
  AllocatedStorageSpaceLength = getattrlist((const char *)valuePtr, v18, v20, 0x24uLL, 0);
  if ((_DWORD)AllocatedStorageSpaceLength)
    return AllocatedStorageSpaceLength;
  StatsDictionary = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v20[4]);
LABEL_6:
  *a4 = StatsDictionary;
  return AllocatedStorageSpaceLength;
}

uint64_t FigSemaphoreDestroy(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!a1)
    return 0;
  v2 = *(const __CFAllocator **)(a1 + 88);
  v3 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if ((_DWORD)v3)
    return v3;
  *(_BYTE *)(a1 + 80) = 1;
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  if (*(_QWORD *)(a1 + 72) && !pthread_cond_broadcast((pthread_cond_t *)(a1 + 8)))
  {
    while (!pthread_mutex_lock(*(pthread_mutex_t **)a1))
    {
      v4 = *(_QWORD *)(a1 + 72);
      pthread_mutex_unlock(*(pthread_mutex_t **)a1);
      if (!v4)
        break;
      sched_yield();
    }
  }
  FigSimpleMutexDestroy(*(_QWORD *)a1);
  v5 = pthread_cond_destroy((pthread_cond_t *)(a1 + 8));
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  CFAllocatorDeallocate(v2, (void *)a1);
  if (v2)
    CFRelease(v2);
  return v5;
}

const __CFAllocator *FigSimpleMutexDestroy(uint64_t a1)
{
  uint64_t v2;
  const __CFAllocator *v3;

  if (!a1)
    return 0;
  v2 = pthread_mutex_destroy((pthread_mutex_t *)a1);
  if (!(_DWORD)v2)
  {
    v3 = *(const __CFAllocator **)(a1 + 64);
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_QWORD *)(a1 + 64) = 0;
    CFAllocatorDeallocate(v3, (void *)a1);
    if (!v3)
      return v3;
    CFRelease(v3);
    return 0;
  }
  v3 = (const __CFAllocator *)v2;
  FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  return v3;
}

uint64_t FigFileGetDarwinPath(uint64_t a1)
{
  return a1 + 16;
}

uint64_t FigAtomicBitAnd32(int a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;

  do
  {
    v2 = __ldxr(a2);
    v3 = v2 & a1;
  }
  while (__stxr(v3, a2));
  return v3;
}

uint64_t FindDataReference(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t *a5)
{
  uint64_t v6;
  unint64_t v8;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;

  v6 = *(unsigned int *)(a2 + 32);
  if ((int)v6 < 1)
  {
    v24 = 0;
    LOBYTE(result) = 0;
  }
  else
  {
    v8 = a3;
    v11 = 0;
    v12 = 0;
    while (1)
    {
      v13 = *(_QWORD *)(a2 + v11 + 64) + v12;
      if ((*(_DWORD *)(a2 + v11 + 48) - 2) <= 3)
      {
        v14 = *(_QWORD *)(a1 + 16);
        if (v14 + a3 >= v12 && v13 > a3)
          break;
      }
      v11 += 48;
      v12 = v13;
      if (48 * v6 == v11)
      {
        v16 = 0;
        v17 = 0;
        LOBYTE(result) = 0;
        *a5 = 0;
        v19 = (_QWORD *)(a2 + 72);
        do
        {
          if (!*(_QWORD *)(a1 + 16))
            break;
          v20 = *(v19 - 1);
          v21 = v20 + v17;
          if (v8 < v20 + v17 && *((_DWORD *)v19 - 6) == 1)
          {
            v26 = 0;
            if (v17 - v8 + v20 >= a4)
              v22 = a4;
            else
              v22 = v17 - v8 + v20;
            LODWORD(result) = FindDataReference(a1, *v19, v8 - v17 + *(v19 - 2), v22, &v26);
            if ((_DWORD)result)
            {
              v23 = v26;
              if (v26 >= v22)
                v23 = v22;
              v8 += v23;
              *a5 += v23;
            }
            LODWORD(v6) = *(_DWORD *)(a2 + 32);
          }
          ++v16;
          v19 += 6;
          v17 = v21;
        }
        while (v16 < (int)v6);
        return result;
      }
    }
    v25 = *(_QWORD *)(a2 + 40) - a3;
    if (v25 >= a4)
      v25 = a4;
    if (v14 >= v25)
      v24 = v25;
    else
      v24 = *(_QWORD *)(a1 + 16);
    AppendBufferReferenceSubBlock(*(_QWORD *)(a1 + 8), (const void *)a2, a3, v24);
    *(_QWORD *)(a1 + 16) -= v24;
    LOBYTE(result) = 1;
  }
  *a5 = v24;
  return result;
}

uint64_t AppendBufferReferenceSubBlock(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  int v8;
  int v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  uint64_t result;
  const __CFAllocator *v24;
  CMBlockBufferFlags v25;
  uint64_t v26;

  v9 = *(_DWORD *)(a1 + 32);
  v8 = *(_DWORD *)(a1 + 36);
  v10 = v9;
  if (v9)
    v11 = v9 < v8;
  else
    v11 = 0;
  if (v11)
  {
    v12 = v9 - 1;
    if (*(_DWORD *)(a1 + 48 * (v10 - 1) + 48) == 1 && *(const void **)(a1 + 48 * v12 + 72) == a2)
    {
      v13 = a1 + 48 * v12;
      v16 = *(_QWORD *)(v13 + 64);
      v14 = (_QWORD *)(v13 + 64);
      v15 = v16;
      if (v16 + *(v14 - 1) == a3)
      {
        *v14 = v15 + a4;
LABEL_15:
        result = 0;
        *(_QWORD *)(a1 + 40) += a4;
        return result;
      }
    }
  }
  v17 = v8 - 1;
  if ((int)v10 < v17)
  {
    v18 = a1 + 48 * (int)v10;
    *(_DWORD *)(v18 + 48) = 1;
    *(_QWORD *)(v18 + 56) = a3;
    *(_QWORD *)(v18 + 64) = a4;
    *(_QWORD *)(v18 + 72) = CFRetain(a2);
    ++*(_DWORD *)(a1 + 32);
    goto LABEL_15;
  }
  v19 = v17;
  v20 = a1 + 48 * v17;
  v22 = *(_DWORD *)(v20 + 48);
  v21 = (_DWORD *)(v20 + 48);
  if (v22)
  {
LABEL_13:
    result = AppendBufferReferenceSubBlock(*(_QWORD *)(a1 + 48 * v19 + 72), a2, a3, a4);
    if ((_DWORD)result)
      return result;
    *(_QWORD *)(a1 + 48 * v19 + 64) += a4;
    goto LABEL_15;
  }
  v24 = CFGetAllocator((CFTypeRef)a1);
  result = CMBlockBufferCreateEmpty(v24, *(_DWORD *)(a1 + 36), v25, (CMBlockBufferRef *)(a1 + 48 * v19 + 72));
  if (!(_DWORD)result)
  {
    *v21 = 1;
    v26 = a1 + 48 * v19;
    *(_QWORD *)(v26 + 56) = 0;
    *(_QWORD *)(v26 + 64) = 0;
    ++*(_DWORD *)(a1 + 32);
    goto LABEL_13;
  }
  return result;
}

void FigBlockBufferRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void BBufFinalize(CFAllocatorRef *cf)
{
  uint64_t v2;
  const __CFAllocator *v3;
  CFAllocatorRef *v4;
  int v5;
  CFAllocatorRef *v6;
  void (*v7)(_QWORD, CFAllocatorRef, _QWORD);
  const __CFAllocator *v8;
  CFAllocatorRef v9;
  uint64_t v10;
  char v11;
  char v12;
  char *v13;
  const void *v14;
  _QWORD *v15;
  const void *v16;

  if (*((int *)cf + 8) >= 1)
  {
    v2 = 0;
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
    v4 = cf + 11;
    do
    {
      v5 = *((_DWORD *)v4 - 10);
      if ((v5 - 2) < 2)
      {
        v6 = v4 - 2;
        v9 = v3;
        if (*v4 != v3)
        {
          if (*v6)
            CFAllocatorDeallocate(*v4, *v6);
          v9 = *v4;
        }
        CFRelease(v9);
      }
      else
      {
        if ((v5 - 4) >= 2)
        {
          if (v5 == 1)
          {
            CFRelease(*(v4 - 2));
            *(v4 - 2) = 0;
          }
          goto LABEL_18;
        }
        v6 = v4 - 2;
        v7 = *(void (**)(_QWORD, CFAllocatorRef, _QWORD))((char *)*v4 + 12);
        if (v7 && *v6)
          v7(*(_QWORD *)((char *)*v4 + 20), *v6, *(v4 - 1));
        v8 = CFGetAllocator(cf);
        CFAllocatorDeallocate(v8, *v4);
      }
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
LABEL_18:
      *((_DWORD *)v4 - 10) = 0;
      ++v2;
      *(v4 - 4) = 0;
      *(v4 - 3) = 0;
      v4 += 6;
    }
    while (v2 < *((int *)cf + 8));
  }
  v10 = 0;
  v11 = 1;
  do
  {
    v12 = v11;
    v13 = (char *)&cf[v10];
    v16 = (const void *)*((_QWORD *)v13 + 2);
    v15 = v13 + 16;
    v14 = v16;
    if (v16)
    {
      CFRelease(v14);
      *v15 = 0;
    }
    v11 = 0;
    v10 = 1;
  }
  while ((v12 & 1) != 0);
  *((_DWORD *)cf + 8) = 0;
  cf[5] = 0;
}

CFTypeRef FigBlockBufferRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

uint64_t AudioToolbox_AudioFormatGetProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t result;

  v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))pAudioFormatGetProperty;
  if (pAudioFormatGetProperty)
    return v10(a1, a2, a3, a4, a5);
  FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce);
  result = gAudioToolboxBundleStatus ? 4294965266 : 0;
  v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))pAudioFormatGetProperty;
  if (pAudioFormatGetProperty)
    return v10(a1, a2, a3, a4, a5);
  return result;
}

void *loadAudioToolboxPointersOnce()
{
  __CFBundle *BundleWithIdentifier;
  void *result;
  FILE *v2;
  const char *v3;
  size_t v4;

  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.audio.toolbox.AudioToolbox"));
  gAudioToolboxBundle = (uint64_t)BundleWithIdentifier;
  if (!BundleWithIdentifier)
  {
    v2 = (FILE *)*MEMORY[0x1E0C80C10];
    v3 = "Failed to get AudioToolbox bundle!\n";
    v4 = 35;
    goto LABEL_13;
  }
  pAudioConverterGetProperty = CFBundleGetFunctionPointerForName(BundleWithIdentifier, CFSTR("AudioConverterGetProperty"));
  if (!pAudioConverterGetProperty)
  {
    v2 = (FILE *)*MEMORY[0x1E0C80C10];
    v3 = "Failed to get AudioToolbox symbol (pAudioConverterGetProperty)!\n";
LABEL_12:
    v4 = 64;
    goto LABEL_13;
  }
  pAudioConverterSetProperty = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, CFSTR("AudioConverterSetProperty"));
  if (!pAudioConverterSetProperty)
  {
    v2 = (FILE *)*MEMORY[0x1E0C80C10];
    v3 = "Failed to get AudioToolbox symbol (pAudioConverterSetProperty)!\n";
    goto LABEL_12;
  }
  pAudioFormatGetProperty = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, CFSTR("AudioFormatGetProperty"));
  if (pAudioFormatGetProperty)
  {
    pAudioFormatGetPropertyInfo = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, CFSTR("AudioFormatGetPropertyInfo"));
    if (pAudioFormatGetPropertyInfo)
    {
      pAudioConverterDispose = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, CFSTR("AudioConverterDispose"));
      if (pAudioConverterDispose)
      {
        result = CFBundleGetFunctionPointerForName((CFBundleRef)gAudioToolboxBundle, CFSTR("AudioConverterNew"));
        pAudioConverterNew = result;
        if (result)
          return result;
        v2 = (FILE *)*MEMORY[0x1E0C80C10];
        v3 = "Failed to get AudioToolbox symbol (pAudioConverterNew)!\n";
        v4 = 56;
      }
      else
      {
        v2 = (FILE *)*MEMORY[0x1E0C80C10];
        v3 = "Failed to get AudioToolbox symbol (pAudioConverterDispose)!\n";
        v4 = 60;
      }
    }
    else
    {
      v2 = (FILE *)*MEMORY[0x1E0C80C10];
      v3 = "Failed to get AudioToolbox symbol (pAudioFormatGetPropertyInfo)!\n";
      v4 = 65;
    }
  }
  else
  {
    v2 = (FILE *)*MEMORY[0x1E0C80C10];
    v3 = "Failed to get AudioToolbox symbol (pAudioFormatGetProperty)!\n";
    v4 = 61;
  }
LABEL_13:
  result = (void *)fwrite(v3, v4, 1uLL, v2);
  gAudioToolboxBundleStatus = 1;
  return result;
}

uint64_t AudioToolbox_AudioFormatGetPropertyInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t result;

  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioFormatGetPropertyInfo;
  if (pAudioFormatGetPropertyInfo)
    return v8(a1, a2, a3, a4);
  FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce);
  result = gAudioToolboxBundleStatus ? 4294965266 : 0;
  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioFormatGetPropertyInfo;
  if (pAudioFormatGetPropertyInfo)
    return v8(a1, a2, a3, a4);
  return result;
}

uint64_t FigAudioFormatDescriptionRegisterOnce()
{
  int v1;
  uint64_t v2;
  uint64_t (*v3)(const opaqueCMFormatDescription *, const opaqueCMFormatDescription *, unint64_t, unint64_t);
  __CFString *(*v4)(const void *);
  void (*v5)(const void *);

  v1 = 0;
  v2 = 128;
  v4 = figAudioFormatDescriptionCopyDebugDesc;
  v5 = figAudioFormatDescriptionFinalize;
  v3 = figAudioFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x736F756Eu, (__int128 *)&v1);
}

uint64_t FigDerivedFormatDescriptionRegister(unsigned int a1, __int128 *a2)
{
  uint64_t v3;
  _OWORD *v6;
  const void *v7;
  __int128 v8;
  __int128 v9;

  if (!a2)
  {
    v3 = 4294954586;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*(_DWORD *)a2 || !*(_QWORD *)((char *)a2 + 12))
  {
    v3 = 4294954586;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  FigThreadRunOnce(&sCreateRegistryGuard, (void (*)(void))createDescriptionRegistry);
  if (!sFigFormatDescriptionRegistry
    || !sRegistryLock
    || (v6 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 36, 0)) == 0)
  {
    v3 = 4294954585;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  v7 = v6;
  v8 = *a2;
  v9 = a2[1];
  *((_DWORD *)v6 + 8) = *((_DWORD *)a2 + 8);
  *v6 = v8;
  v6[1] = v9;
  FigSimpleMutexLock((pthread_mutex_t *)sRegistryLock);
  CFDictionaryAddValue((CFMutableDictionaryRef)sFigFormatDescriptionRegistry, (const void *)a1, v7);
  FigSimpleMutexUnlock((pthread_mutex_t *)sRegistryLock);
  return 0;
}

pthread_mutex_t *createDescriptionRegistry()
{
  pthread_mutex_t *result;
  CFDictionaryValueCallBacks v1;

  *(_OWORD *)&v1.version = xmmword_1E28D8A78;
  *(_OWORD *)&v1.release = *(_OWORD *)&off_1E28D8A88;
  v1.equal = 0;
  sFigFormatDescriptionRegistry = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, &v1);
  result = FigSimpleMutexCreate();
  sRegistryLock = (uint64_t)result;
  return result;
}

uint64_t FigDerivedFormatDescriptionCreate(const __CFAllocator *a1, void *key, int a3, const void *a4, uint64_t *a5)
{
  int v5;
  char *Value;
  uint64_t v11;
  uint64_t Instance;
  uint64_t v13;
  CFPropertyListRef DeepCopy;
  uint64_t v15;
  uint64_t v16;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v19;
  uint64_t v20;
  unsigned int v21;
  char *v22;
  os_log_type_t type;
  int v24[2];
  const char *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a5)
    goto LABEL_32;
  v5 = (int)key;
  if (!(_DWORD)key || !sFigFormatDescriptionRegistry)
    goto LABEL_32;
  Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)key);
  if (Value)
    goto LABEL_28;
  if (v5 > 1885954931)
  {
    if (v5 > 1952606065)
    {
      if (v5 == 1952606066)
      {
        FigTaggedBufferGroupFormatDescriptionRegister();
        goto LABEL_25;
      }
      if (v5 == 1953325924)
      {
        FigTimeCodeFormatDescriptionRegister();
        goto LABEL_25;
      }
      v11 = 1734700658;
      if (v5 != 1986618469)
        goto LABEL_26;
      goto LABEL_18;
    }
    if (v5 != 1885954932)
    {
      v11 = 1734700658;
      if (v5 == 1936684398)
      {
        FigAudioFormatDescriptionRegister();
        goto LABEL_25;
      }
      goto LABEL_26;
    }
LABEL_18:
    FigVideoFormatDescriptionRegister();
    goto LABEL_25;
  }
  if (v5 > 1835365472)
  {
    if (v5 == 1835365473)
    {
      FigMetadataFormatDescriptionRegister();
      goto LABEL_25;
    }
    v11 = 1734700658;
    if (v5 == 1836415096)
    {
      FigMuxedFormatDescriptionRegister();
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  if (v5 == 1635088502)
    goto LABEL_18;
  v11 = 1734700658;
  if (v5 == 1668310898)
  {
    FigCaptionGroupFormatDescriptionRegister();
LABEL_25:
    v11 = v5;
  }
LABEL_26:
  Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)v11);
  if (!Value)
  {
    Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)0x67656E72);
    if (!Value)
    {
LABEL_32:
      v16 = 4294954586;
      return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    }
  }
LABEL_28:
  FigThreadRunOnce(&CMFormatDescriptionGetTypeID_sRegisterFigFormatDescriptionOnce, (void (*)(void))registerFigFormatDescription);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v16 = 4294954585;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  v13 = Instance;
  bzero((void *)(Instance + 32), *(_QWORD *)(Value + 4));
  *(_DWORD *)(v13 + 16) = v5;
  *(_DWORD *)(v13 + 20) = a3;
  if (a4 && (DeepCopy = CFPropertyListCreateDeepCopy(a1, a4, 0), (*(_QWORD *)(v13 + 24) = DeepCopy) == 0))
  {
    v15 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    v24[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E40, 0, v24, &type);
    v19 = v24[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v21 = v19;
    else
      v21 = v19 & 0xFFFFFFFE;
    if (v21)
    {
      v24[1] = 136315138;
      v25 = "FigDerivedFormatDescriptionCreate";
      v22 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v19) = v24[0];
    }
    else
    {
      v22 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E40, 0, 0, v22, v22 != &v26, v19, 0, v20);
    CFRelease((CFTypeRef)v13);
  }
  else
  {
    v15 = 0;
    *a5 = v13;
  }
  return v15;
}

uint64_t registerFigFormatDescription()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigFormatDescriptionID = result;
  return result;
}

uint64_t figFormatDescriptionInit(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

uint64_t FigDerivedFormatDescriptionGetDerivedStorage(uint64_t a1)
{
  if (a1)
    return a1 + 32;
  FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  return 0;
}

void FigFormatDescriptionRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t FigBaseObjectFinalize(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  CFNotificationCenterRef DefaultLocalCenter;
  uint64_t (*v4)(uint64_t);

  v1 = result;
  v2 = *(_QWORD *)(*(_QWORD *)(result + 24) + 8);
  if (*(_QWORD *)v2 >= 2uLL && *(uint64_t (**)(uint64_t))(v2 + 64) == FigBaseObjectStandardNotificationBarrier)
  {
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    result = CMNotificationCenterUnregisterForBarrierSupport((uint64_t)DefaultLocalCenter, v1);
    v2 = *(_QWORD *)(*(_QWORD *)(v1 + 24) + 8);
  }
  v4 = *(uint64_t (**)(uint64_t))(v2 + 32);
  if (v4)
    result = v4(v1);
  *(_QWORD *)(v1 + 24) = 0;
  return result;
}

CFTypeRef FigFormatDescriptionRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

uint64_t registerFigBufferQueueType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigBufferQueueID = result;
  return result;
}

double bufQInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 256) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t fig_note_initialize_timestamps()
{
  return FigThreadRunOnce(&sFigNoteInit, (void (*)(void))fig_note_init_timestamps_once);
}

uint64_t fig_note_init_timestamps_once()
{
  return gettimeofday((timeval *)&sStartTime, 0);
}

CFTypeRef FigBufferQueueRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

uint64_t bufQInstallTrigger(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, int a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFAllocator *v19;
  CFMutableSetRef v20;
  const __CFAllocator *v21;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  CFSetCallBacks v26;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(_BYTE *)(a1 + 168))
  {
    v16 = 4294954530;
    goto LABEL_3;
  }
  if (!*(_QWORD *)(a1 + 160))
  {
    v26 = *(CFSetCallBacks *)byte_1E28D7D50;
    v19 = CFGetAllocator((CFTypeRef)a1);
    v20 = CFSetCreateMutable(v19, 0, &v26);
    *(_QWORD *)(a1 + 160) = v20;
    if (!v20)
    {
      v16 = 4294954536;
LABEL_3:
      v17 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      v18 = 0;
      if (!a8)
        goto LABEL_15;
      goto LABEL_14;
    }
  }
  v21 = CFGetAllocator((CFTypeRef)a1);
  v22 = CFAllocatorAllocate(v21, 72, 0);
  v18 = (uint64_t)v22;
  if (!v22)
  {
    v17 = FigSignalErrorAt(4294954536, 0, 0, 0, 0, 0, 0);
    if (!a8)
      goto LABEL_15;
    goto LABEL_14;
  }
  *v22 = a2;
  v22[1] = a3;
  v22[2] = _Block_copy(a4);
  *(_DWORD *)(v18 + 24) = a5;
  v23 = *(_QWORD *)(a6 + 16);
  *(_OWORD *)(v18 + 28) = *(_OWORD *)a6;
  *(_QWORD *)(v18 + 44) = v23;
  *(_QWORD *)(v18 + 56) = a7;
  *(_BYTE *)(v18 + 64) = 0;
  CFSetSetValue(*(CFMutableSetRef *)(a1 + 160), (const void *)v18);
  v24 = *(unsigned __int8 *)(a1 + 169);
  *(_BYTE *)(a1 + 169) = 0;
  CFSetApplyFunction(*(CFSetRef *)(a1 + 160), (CFSetApplierFunction)bufQCheckForDataBecomesReadyTrigger, (void *)a1);
  if (!v24 && *(_BYTE *)(a1 + 169))
    bufQStartListeningForHeadBufferBecomingReady(a1);
  if (a8)
    *a8 = v18;
  evaluateAndMaybeFireTrigger(v18, (char *)a1);
  v17 = 0;
  if (a8)
LABEL_14:
    *a8 = v18;
LABEL_15:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v17;
}

uint64_t bufQCheckForDataBecomesReadyTrigger(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 24) == 7)
    *(_BYTE *)(a2 + 169) = 1;
  return result;
}

uint64_t bufQStartListeningForHeadBufferBecomingReady(uint64_t result)
{
  uint64_t v1;
  const __CFString **v2;
  const __CFString *v3;
  const __CFArray *v4;
  const void *ValueAtIndex;
  unint64_t v6;
  unsigned int (*v7)(void);
  __CFNotificationCenter *DefaultLocalCenter;

  if (*(_BYTE *)(result + 169))
  {
    v1 = result;
    if (*(_BYTE *)(result + 120))
    {
      if (!*(_QWORD *)(result + 84))
        return result;
      v2 = (const __CFString **)(result + 100);
    }
    else
    {
      if (!*(_QWORD *)(result + 80))
        return result;
      v2 = (const __CFString **)(result + 96);
    }
    v3 = *v2;
    if (*v2)
    {
      FigReentrantMutexLock(*(pthread_mutex_t **)(result + 16));
      v4 = *(const __CFArray **)(v1 + 24);
      if (v4)
      {
        if (CFArrayGetCount(v4) >= 1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 24), 0);
          if (ValueAtIndex)
          {
            v6 = (unint64_t)ValueAtIndex;
            if (*(_BYTE *)(v1 + 120))
              v7 = *(unsigned int (**)(void))(v1 + 84);
            else
              v7 = *(unsigned int (**)(void))(*(_QWORD *)(v1 + 80) + 16);
            if (!v7())
            {
              DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
              CMNotificationCenterAddListener(DefaultLocalCenter, (const void *)v1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))bufQDataBecameReady, v3, v6);
              *(_QWORD *)(v1 + 176) = v6;
            }
          }
        }
      }
      return FigReentrantMutexUnlock(*(pthread_mutex_t **)(v1 + 16));
    }
  }
  return result;
}

uint64_t evaluateAndMaybeFireTrigger(uint64_t result, char *queue)
{
  uint64_t v3;
  int v4;
  unsigned int v5;
  BOOL v6;
  BOOL v7;
  uint64_t v8;
  CMTimeEpoch epoch;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  _BYTE *v14;
  CMTime v15;
  CMTime time1;
  CMTime v17;
  CMTime v18;

  v3 = result;
  v4 = *(unsigned __int8 *)(result + 64);
  memset(&v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  switch(*(_DWORD *)(result + 24))
  {
    case 1:
      time1 = *(CMTime *)(queue + 124);
      v15 = *(CMTime *)(result + 28);
      result = CMTimeCompare(&time1, &v15);
      v5 = result >> 31;
      goto LABEL_36;
    case 2:
      time1 = *(CMTime *)(queue + 124);
      v15 = *(CMTime *)(result + 28);
      result = CMTimeCompare(&time1, &v15);
      v6 = (int)result < 1;
      goto LABEL_23;
    case 3:
      time1 = *(CMTime *)(queue + 124);
      v15 = *(CMTime *)(result + 28);
      result = CMTimeCompare(&time1, &v15);
      v7 = (int)result <= 0;
      goto LABEL_28;
    case 4:
      time1 = *(CMTime *)(queue + 124);
      v15 = *(CMTime *)(result + 28);
      result = CMTimeCompare(&time1, &v15);
      LOBYTE(v5) = (int)result >= 0;
      goto LABEL_36;
    case 5:
      CMBufferQueueGetMinPresentationTimeStamp(&v18, (CMBufferQueueRef)queue);
      time1 = *(CMTime *)(v3 + 28);
      v15 = v18;
      result = CMTimeCompare(&time1, &v15);
      *(_BYTE *)(v3 + 64) = (_DWORD)result != 0;
      if (!(_DWORD)result)
        return result;
      v8 = v3 + 28;
      *(_OWORD *)(v3 + 28) = *(_OWORD *)&v18.value;
      epoch = v18.epoch;
      goto LABEL_11;
    case 6:
      CMBufferQueueGetMaxPresentationTimeStamp(&v17, (CMBufferQueueRef)queue);
      time1 = *(CMTime *)(v3 + 28);
      v15 = v17;
      result = CMTimeCompare(&time1, &v15);
      *(_BYTE *)(v3 + 64) = (_DWORD)result != 0;
      if (!(_DWORD)result)
        return result;
      v8 = v3 + 28;
      *(_OWORD *)(v3 + 28) = *(_OWORD *)&v17.value;
      epoch = v17.epoch;
LABEL_11:
      *(_QWORD *)(v8 + 16) = epoch;
      goto LABEL_39;
    case 7:
      *(_BYTE *)(result + 64) = 0;
      result = *((_QWORD *)queue + 3);
      if (!result)
        goto LABEL_37;
      result = CFArrayGetCount((CFArrayRef)result);
      if (result < 1)
        goto LABEL_37;
      result = (uint64_t)CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
      v10 = result;
      if (queue[120])
      {
        v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(queue + 84);
        if (v11)
        {
          v12 = *(_QWORD *)(queue + 52);
LABEL_34:
          result = v11(result, v12, v10);
          LOBYTE(v5) = (_DWORD)result != 0;
          goto LABEL_36;
        }
      }
      else
      {
        result = *((_QWORD *)queue + 10);
        if (result)
        {
          v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(result + 16);
          v12 = v10;
          goto LABEL_34;
        }
      }
LABEL_35:
      LOBYTE(v5) = 1;
LABEL_36:
      *(_BYTE *)(v3 + 64) = v5;
LABEL_37:
      if (v4 || !*(_BYTE *)(v3 + 64))
        return result;
LABEL_39:
      v13 = *(uint64_t (**)(uint64_t, uint64_t))v3;
      if (*(_QWORD *)v3)
      {
        queue[168] = 1;
        v14 = queue + 168;
        result = *(_QWORD *)(v3 + 8);
      }
      else
      {
        result = *(_QWORD *)(v3 + 16);
        if (!result)
          return result;
        queue[168] = 1;
        v14 = queue + 168;
        v13 = *(uint64_t (**)(uint64_t, uint64_t))(result + 16);
      }
      result = v13(result, v3);
      *v14 = 0;
      return result;
    case 8:
      *(_BYTE *)(result + 64) = 0;
      if (queue[121])
      {
        result = *((_QWORD *)queue + 3);
        if (!result)
          goto LABEL_35;
        result = CFArrayGetCount((CFArrayRef)result);
        if (!result)
          goto LABEL_35;
      }
      goto LABEL_37;
    case 9:
      LOBYTE(v5) = queue[184];
      goto LABEL_36;
    case 0xA:
      result = CMBufferQueueGetBufferCount((CMBufferQueueRef)queue);
      v6 = result < *(_QWORD *)(v3 + 56);
LABEL_23:
      LOBYTE(v5) = v6;
      goto LABEL_36;
    case 0xB:
      goto LABEL_27;
    case 0xC:
      time1 = *(CMTime *)(queue + 124);
      v15 = *(CMTime *)(result + 28);
      result = CMTimeCompare(&time1, &v15);
      if ((result & 0x80000000) != 0)
        goto LABEL_31;
LABEL_27:
      result = CMBufferQueueGetBufferCount((CMBufferQueueRef)queue);
      v7 = result <= *(_QWORD *)(v3 + 56);
LABEL_28:
      LOBYTE(v5) = !v7;
      goto LABEL_36;
    default:
      result = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
LABEL_31:
      LOBYTE(v5) = 0;
      goto LABEL_36;
  }
}

uint64_t figAudioDeviceClockCreateCommon(uint64_t a1, uint64_t a2, int a3, CFTypeRef *a4)
{
  CMClockRef HostTimeClock;
  uint64_t TimeCallback;
  uint64_t DerivedStorage;
  dispatch_queue_t v11;
  pthread_mutex_t **v12;
  pthread_mutex_t **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v19[7];
  int v20;
  _QWORD block[5];
  CMTime v22;
  CFTypeRef cf;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;

  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = 0;
  cf = 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFADCTrace[1], CFSTR("fadc_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFADCTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1EE141EC8, CFSTR("fadc_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1EE141EC0);
  if (!a4)
  {
    v17 = 4294954551;
LABEL_17:
    v15 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v25 + 6) = v15;
    if ((_DWORD)v15)
      goto LABEL_12;
LABEL_18:
    *a4 = cf;
    goto LABEL_19;
  }
  HostTimeClock = CMClockGetHostTimeClock();
  CMTimeMake(&v22, 1, 2);
  TimeCallback = FigDerivedClockCreateWithGetTimeCallback(a1, gFigAudioDeviceClockCallbacks, HostTimeClock, (__int128 *)&v22.value, 1, (uint64_t *)&cf);
  *((_DWORD *)v25 + 6) = TimeCallback;
  if ((_DWORD)TimeCallback)
  {
LABEL_15:
    v15 = TimeCallback;
    goto LABEL_12;
  }
  DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)cf);
  v11 = dispatch_queue_create("com.apple.coremedia.audiodeviceclock", 0);
  *(_QWORD *)(DerivedStorage + 128) = v11;
  if (!v11
    || (v12 = FigReadWriteLockCreate(0), (*(_QWORD *)(DerivedStorage + 136) = v12) == 0)
    || (*(_DWORD *)(DerivedStorage + 120) = 0,
        v13 = FigReadWriteLockCreate(0),
        (*(_QWORD *)(DerivedStorage + 64) = v13) == 0))
  {
    v17 = 4294954549;
    goto LABEL_17;
  }
  v14 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figAudioDeviceClockCreateCommon_block_invoke;
  block[3] = &unk_1E28D9AF0;
  block[4] = &v24;
  if (figAudioDeviceClockCreateCommon_fadcInitWeakReferenceTableOnce != -1)
    dispatch_once(&figAudioDeviceClockCreateCommon_fadcInitWeakReferenceTableOnce, block);
  v15 = *((unsigned int *)v25 + 6);
  if ((_DWORD)v15)
    goto LABEL_12;
  *(_QWORD *)(DerivedStorage + 144) = 0;
  TimeCallback = FigCFWeakReferenceTableAddValueAndGetKey(gFigAudioDeviceClockRegistry, (uint64_t)cf, (_QWORD *)(DerivedStorage + 144));
  *((_DWORD *)v25 + 6) = TimeCallback;
  if ((_DWORD)TimeCallback)
    goto LABEL_15;
  FigGetHostTimeToNanosecondsScale((_QWORD *)(DerivedStorage + 16), (_QWORD *)(DerivedStorage + 24));
  *(_QWORD *)(DerivedStorage + 104) = 0;
  v19[0] = v14;
  v19[1] = 0x40000000;
  v19[2] = __figAudioDeviceClockCreateCommon_block_invoke_2;
  v19[3] = &unk_1E28D9B18;
  v20 = a3;
  v19[4] = &v24;
  v19[5] = cf;
  v19[6] = a2;
  v16 = writeProtectedStorageSync((uint64_t)cf, (uint64_t)v19);
  v15 = *((unsigned int *)v25 + 6);
  if (!(_DWORD)v15)
  {
    *((_DWORD *)v25 + 6) = v16;
    v15 = v16;
    if (!(_DWORD)v16)
      goto LABEL_18;
  }
LABEL_12:
  if (cf)
  {
    CFRelease(cf);
    v15 = *((unsigned int *)v25 + 6);
  }
LABEL_19:
  _Block_object_dispose(&v24, 8);
  return v15;
}

uint64_t FigDerivedClockGetDerivedStorage(uint64_t a1)
{
  if (a1)
    return a1 + 208;
  FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t fadcSetAudioDeviceUID(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage;
  const void *v5;
  uint64_t PropertyData;
  int v7;
  uint64_t result;
  AudioObjectPropertyAddress v9;
  UInt32 ioDataSize;
  const void *inQualifierData;
  AudioObjectPropertyAddress *outData;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  __int128 inAddress;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v5 = *(const void **)(DerivedStorage + 80);
  *(_QWORD *)(DerivedStorage + 80) = a2;
  if (a2)
    CFRetain(a2);
  if (v5)
    CFRelease(v5);
  if ((in_audio_mx_server_process() & 1) != 0)
  {
    if (a2)
    {
      inAddress = *(unint64_t *)"diudbolg";
      inQualifierData = a2;
      outData = (AudioObjectPropertyAddress *)&inQualifierData;
      v13 = 8;
      v14 = (char *)&inAddress + 12;
      v15 = 4;
      ioDataSize = 32;
      PropertyData = AudioObjectGetPropertyData(1u, (const AudioObjectPropertyAddress *)&inAddress, 0, 0, &ioDataSize, &outData);
      if (!HIDWORD(inAddress))
      {
        v9.mElement = 0;
        ioDataSize = 4;
        *(_QWORD *)&v9.mSelector = *(_QWORD *)"cdiubolg";
        PropertyData = AudioObjectGetPropertyData(1u, &v9, 8u, &inQualifierData, &ioDataSize, (char *)&inAddress + 12);
      }
      if ((_DWORD)PropertyData)
        FigSignalErrorAt(PropertyData, 0, 0, 0, 0, 0, 0);
      v7 = HIDWORD(inAddress);
      if (!HIDWORD(inAddress))
        return 4294954550;
    }
    else
    {
      *(_BYTE *)(DerivedStorage + 72) = 1;
      inAddress = *(unint64_t *)"diudbolg";
      *(_QWORD *)&v9.mSelector = CFSTR("VirtualAudioDevice_Default");
      outData = &v9;
      v13 = 8;
      v14 = (char *)&inAddress + 12;
      v15 = 4;
      LODWORD(inQualifierData) = 32;
      if (AudioObjectGetPropertyData(1u, (const AudioObjectPropertyAddress *)&inAddress, 0, 0, (UInt32 *)&inQualifierData, &outData)|| (v7 = HIDWORD(inAddress)) == 0)
      {
        FigSignalErrorAt(4294967195, 0, 0, 0, 0, 0, 0);
        v7 = HIDWORD(inAddress);
      }
    }
    return switchToNewDeviceID(a1, v7);
  }
  else
  {
    result = 0;
    *(_BYTE *)(DerivedStorage + 72) = 1;
    *(_BYTE *)DerivedStorage = 0;
  }
  return result;
}

uint64_t switchToNewDeviceID(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v9;
  int v10;

  FigDerivedClockGetDerivedStorage(a1);
  if (!a2)
    return 4294954550;
  FigDerivedClockDiscontinuityOccurred(a1);
  removeAllTracesOfDevice(a1);
  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  *(_DWORD *)(DerivedStorage + 88) = a2;
  v5 = addPropertyListener(a1, 0x676F696Eu);
  if ((_DWORD)v5)
    goto LABEL_8;
  v5 = addPropertyListener(a1, 0x6F766572u);
  if ((_DWORD)v5)
    goto LABEL_8;
  v5 = addPropertyListener(a1, 0x6E737274u);
  if ((_DWORD)v5)
    goto LABEL_8;
  v10 = 0;
  v9 = *(_QWORD *)"niog****";
  v5 = propertyListenerDispatch(a1, &v9);
  v6 = 0;
  if (!*(_BYTE *)(DerivedStorage + 1))
  {
    v7 = FigDerivedClockGetDerivedStorage(a1);
    v6 = FigAudioDeviceSupportsPresentationTime(*(_DWORD *)(v7 + 88));
  }
  *(_BYTE *)(DerivedStorage + 112) = v6;
  if ((_DWORD)v5)
LABEL_8:
    removeAllTracesOfDevice(a1);
  return v5;
}

void FigDerivedClockDiscontinuityOccurred(uint64_t a1)
{
  if (a1)
  {
    FigAtomicIncrement32((unsigned int *)(a1 + 200));
    FigMemoryBarrier();
  }
}

uint64_t removeAllTracesOfDevice(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = FigDerivedClockGetDerivedStorage(a1);
  v3 = result;
  if (*(_DWORD *)(result + 88))
  {
    removePropertyListener(a1, 0x676F696Eu);
    removePropertyListener(a1, 0x6F766572u);
    result = removePropertyListener(a1, 0x6E737274u);
  }
  *(_DWORD *)(v3 + 88) = 0;
  *(_BYTE *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 104) = 0;
  return result;
}

uint64_t addPropertyListener(uint64_t a1, AudioObjectPropertySelector a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  AudioObjectID v5;
  uint64_t v6;
  uint64_t v7;
  AudioObjectPropertyAddress inAddress;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v4 = DerivedStorage;
  if (a2 == 1735354734 || a2 == 1870030194 || a2 == 1853059700)
  {
    v5 = *(_DWORD *)(DerivedStorage + 88);
  }
  else
  {
    v6 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if ((_DWORD)v6)
      return v6;
  }
  inAddress.mSelector = a2;
  *(_QWORD *)&inAddress.mScope = 707406378;
  v7 = AudioObjectAddPropertyListener(v5, &inAddress, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(v4 + 144));
  if ((_DWORD)v7)
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  else
    return 0;
}

uint64_t propertyListenerDispatch(uint64_t a1, const AudioObjectPropertyAddress *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  AudioObjectPropertySelector mSelector;
  uint64_t PropertyData;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  AudioObjectPropertyAddress v12;
  uint64_t v13;
  int outData;
  UInt32 ioDataSize;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v5 = DerivedStorage;
  mSelector = a2->mSelector;
  if (a2->mSelector != 1735354734)
  {
    if (mSelector == 1853059700)
    {
      if (*(_BYTE *)DerivedStorage)
        switchToNewDeviceID(a1, *(_DWORD *)(DerivedStorage + 88));
    }
    else if (mSelector == 1870030194)
    {
      FigDerivedClockDiscontinuityOccurred(a1);
    }
    else
    {
      FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  v13 = 0;
  outData = 0;
  ioDataSize = 4;
  PropertyData = AudioObjectGetPropertyData(*(_DWORD *)(DerivedStorage + 88), a2, 0, 0, &ioDataSize, &outData);
  if ((_DWORD)PropertyData)
    return FigSignalErrorAt(PropertyData, 0, 0, 0, 0, 0, 0);
  if (!outData)
  {
    if (*(_BYTE *)v5)
    {
      *(_BYTE *)v5 = 0;
      FigDerivedClockDiscontinuityOccurred(a1);
      v9 = 0;
      *(_QWORD *)(v5 + 104) = 0;
      return v9;
    }
    return 0;
  }
  if (*(_BYTE *)v5)
    return 0;
  v12 = *a2;
  v12.mSelector = 1853059700;
  ioDataSize = 8;
  v8 = AudioObjectGetPropertyData(*(_DWORD *)(v5 + 88), &v12, 0, 0, &ioDataSize, &v13);
  v9 = v8;
  if ((_DWORD)v8)
  {
    FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v11 = v13;
    *(_QWORD *)(v5 + 8) = v13;
    *(float64x2_t *)(v5 + 32) = vdivq_f64((float64x2_t)vdupq_lane_s64(v11, 0), (float64x2_t)xmmword_18EDDCB30);
    *(double *)(v5 + 48) = *(double *)&v11
                         * (double)*(uint64_t *)(v5 + 16)
                         / (double)(1000000000 * *(_QWORD *)(v5 + 24));
    *(_BYTE *)v5 = 1;
  }
  return v9;
}

uint64_t FigTimebaseSetTime(OpaqueCMTimebase *a1, CMTime *a2)
{
  CMTime v3;

  v3 = *a2;
  return CMTimebaseSetTime(a1, &v3);
}

uint64_t FigTimebaseSetAnchorTime(OpaqueCMTimebase *a1, CMTime *a2, CMTime *a3)
{
  CMTime v4;
  CMTime timebaseTime;

  timebaseTime = *a2;
  v4 = *a3;
  return CMTimebaseSetAnchorTime(a1, &timebaseTime, &v4);
}

CFTypeRef cfDataFigTimeRetain(int a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

uint64_t FigClockGetTransformRelativeToHostTimeClock(uint64_t a1, int a2, uint64_t a3)
{
  BOOL v5;
  char v6;
  uint64_t v7;
  _QWORD *v9;
  uint64_t TransformRelativeToReferenceClock;
  __int128 *v11;
  __int128 *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  _OWORD v17[3];
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = 0;
  v24 = 0u;
  v25 = 0u;
  v23 = 0u;
  if (a1)
    v5 = a3 == 0;
  else
    v5 = 1;
  v6 = v5;
  if (v5)
  {
    v7 = 4294954551;
LABEL_23:
    TransformRelativeToReferenceClock = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    goto LABEL_24;
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (!*(_BYTE *)(a1 + 41))
  {
    v7 = 4294954550;
    goto LABEL_23;
  }
  v25 = *(_OWORD *)&kCMTimeZero.value;
  v26 = 0;
  v23 = *(_OWORD *)&kCMTimeZero.value;
  *(_QWORD *)&v24 = 0;
  *((_QWORD *)&v24 + 1) = 0x3FF0000000000000;
  if (CMClockGetHostTimeClock() == (CMClockRef)a1 || CMClockGetHostTimeClock() == (CMClockRef)a1)
  {
LABEL_26:
    v14 = 0;
    v15 = v24;
    *(_OWORD *)a3 = v23;
    *(_OWORD *)(a3 + 16) = v15;
    *(_OWORD *)(a3 + 32) = v25;
    *(_QWORD *)(a3 + 48) = v26;
    goto LABEL_27;
  }
  v9 = (_QWORD *)a1;
  while (1)
  {
    v22 = 0;
    v20 = 0u;
    v21 = 0u;
    v19 = 0u;
    v18 = 0;
    memset(v17, 0, sizeof(v17));
    TransformRelativeToReferenceClock = FigClockGetTransformRelativeToReferenceClock((uint64_t)v9, a2, (uint64_t)v17);
    if ((_DWORD)TransformRelativeToReferenceClock)
      break;
    v19 = v23;
    v20 = v24;
    v21 = v25;
    v22 = v26;
    if (a2)
    {
      v11 = v17;
      v12 = &v19;
    }
    else
    {
      v11 = &v19;
      v12 = v17;
    }
    FigSyncCombineTransforms(v11, (uint64_t)v12, (uint64_t)&v23);
    v14 = v13;
    if ((_DWORD)v13)
      goto LABEL_25;
    v9 = (_QWORD *)v9[4];
    if (!v9)
    {
      v7 = 4294954543;
      goto LABEL_23;
    }
    if (v9 == (_QWORD *)CMClockGetHostTimeClock())
      goto LABEL_26;
  }
LABEL_24:
  v14 = TransformRelativeToReferenceClock;
LABEL_25:
  if (!(_DWORD)v14)
    goto LABEL_26;
LABEL_27:
  if ((v6 & 1) == 0)
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v14;
}

uint64_t FigClockGetTransformRelativeToReferenceClock(uint64_t a1, int a2, uint64_t a3)
{
  CMTime *v6;
  OpaqueCMClock *v7;
  CMTime *v8;
  uint64_t AnchorTime;
  uint64_t v10;
  double (*v11)(uint64_t);
  double v12;
  __int128 v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  if (a3)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    if (*(_BYTE *)(a1 + 41))
    {
      if (CMClockGetHostTimeClock() == (CMClockRef)a1)
      {
        v17 = *(_OWORD *)&kCMTimeZero.value;
        v18 = 0;
        v15 = *(_OWORD *)&kCMTimeZero.value;
        *(_QWORD *)&v16 = 0;
        *((_QWORD *)&v16 + 1) = 0x3FF0000000000000;
        goto LABEL_19;
      }
      if (a2)
      {
        v6 = (CMTime *)&v15;
        v7 = (OpaqueCMClock *)a1;
        v8 = (CMTime *)&v17;
      }
      else
      {
        v8 = (CMTime *)&v15;
        v7 = (OpaqueCMClock *)a1;
        v6 = (CMTime *)&v17;
      }
      AnchorTime = CMClockGetAnchorTime(v7, v8, v6);
      if ((_DWORD)AnchorTime)
        goto LABEL_20;
      v11 = *(double (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 40);
      if (!v11)
      {
        FigSignalErrorAt(4294967292, 0, 0, 0, 0, 0, 0);
        goto LABEL_19;
      }
      v12 = v11(a1);
      *((double *)&v16 + 1) = v12;
      if (a2)
      {
LABEL_19:
        AnchorTime = 0;
        v13 = v16;
        *(_OWORD *)a3 = v15;
        *(_OWORD *)(a3 + 16) = v13;
        *(_OWORD *)(a3 + 32) = v17;
        *(_QWORD *)(a3 + 48) = v18;
        goto LABEL_20;
      }
      if (v12 != 0.0)
      {
        *((double *)&v16 + 1) = 1.0 / v12;
        goto LABEL_19;
      }
      v10 = 4294954541;
    }
    else
    {
      v10 = 4294954550;
    }
    AnchorTime = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)AnchorTime)
    {
LABEL_20:
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
      return AnchorTime;
    }
    goto LABEL_19;
  }
  AnchorTime = FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  if (!(_DWORD)AnchorTime)
    goto LABEL_19;
  return AnchorTime;
}

double fadcGetRate(void (*a1)(_QWORD))
{
  void (*DerivedStorage)(_QWORD);
  double v3;
  void (*v5[7])(_QWORD);
  uint64_t v6;
  double *v7;
  uint64_t v8;
  uint64_t v9;

  DerivedStorage = (void (*)(_QWORD))FigDerivedClockGetDerivedStorage((uint64_t)a1);
  v6 = 0;
  v7 = (double *)&v6;
  v8 = 0x2000000000;
  v9 = 0x3FF0000000000000;
  v5[0] = (void (*)(_QWORD))MEMORY[0x1E0C809B0];
  v5[1] = (void (*)(_QWORD))0x40000000;
  v5[2] = (void (*)(_QWORD))__fadcGetRate_block_invoke;
  v5[3] = (void (*)(_QWORD))&unk_1E28D9BF8;
  v5[5] = DerivedStorage;
  v5[6] = a1;
  v5[4] = (void (*)(_QWORD))&v6;
  readProtectedStorageSync((uint64_t)a1, v5);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t FigTimebaseSetTimerNextFireTime(OpaqueCMTimebase *a1, __CFRunLoopTimer *a2, CMTime *a3)
{
  CMTime v4;

  v4 = *a3;
  return CMTimebaseSetTimerNextFireTime(a1, a2, &v4, 0);
}

void cfDataFigTimeRelease(int a1, CFTypeRef cf)
{
  CFRelease(cf);
}

void rescheduleTimer(__CFRunLoopTimer *a1, __CFRunLoop *a2, CMTime *a3, OpaqueCMTimebase *a4, CMTime *a5, int a6, char a7)
{
  int IsValid;
  double v15;
  double EffectiveRate;
  double v17;
  int timescale;
  CMTimeValue value;
  CMClockRef HostTimeClock;
  double Current;
  OpaqueCMClock *v22;
  _BOOL4 v23;
  double Seconds;
  CMTime v25;
  CMTime time1;
  CMTime time;
  CMTime v28;
  CMTime v29;

  memset(&v29, 0, sizeof(v29));
  memset(&v28, 0, sizeof(v28));
  IsValid = CFRunLoopTimerIsValid(a1);
  if (a2 && IsValid)
  {
    v15 = 8073216000.0;
    if ((a3->flags & 0x1D) != 1)
      goto LABEL_21;
    if (a3->timescale < 1)
      goto LABEL_21;
    EffectiveRate = CMTimebaseGetEffectiveRate(a4);
    if (EffectiveRate == 0.0)
      goto LABEL_21;
    v17 = EffectiveRate;
    timescale = a3->timescale;
    if (timescale <= 1023)
    {
      do
      {
        value = a3->value;
        if ((unint64_t)(a3->value + 0x3FFFFFFFFFFFFFFFLL) > 0x7FFFFFFFFFFFFFFDLL)
          break;
        memset(&time, 0, sizeof(time));
        CMTimeMake(&time, 2 * value, 2 * timescale);
        *a3 = time;
        timescale = a3->timescale;
      }
      while (timescale < 1024);
    }
    HostTimeClock = CMClockGetHostTimeClock();
    time = *a3;
    CMSyncConvertTime(&v29, &time, a4, HostTimeClock);
    Current = CFAbsoluteTimeGetCurrent();
    memset(&time, 0, sizeof(time));
    v22 = CMClockGetHostTimeClock();
    CMClockGetTime(&time, v22);
    v23 = 1;
    if (v17 <= 0.0 || (time1 = *a3, v25 = *a5, (CMTimeCompare(&time1, &v25) & 0x80000000) == 0))
    {
      if (v17 >= 0.0 || (time1 = *a3, v25 = *a5, CMTimeCompare(&time1, &v25) < 1))
        v23 = 0;
    }
    time1 = v29;
    v25 = time;
    CMTimeSubtract(&v28, &time1, &v25);
    time1 = v28;
    Seconds = CMTimeGetSeconds(&time1);
    if ((a7 & 1) == 0 && v23)
    {
      if (!a6)
      {
        v15 = 8073216000.0;
        goto LABEL_21;
      }
      if (a6 == 1)
        return;
    }
    v15 = Current + Seconds;
LABEL_21:
    CFRunLoopTimerSetNextFireDate(a1, v15);
    CFRunLoopWakeUp(a2);
  }
}

uint64_t sBufCreate(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, _QWORD *a5)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *Instance;
  _QWORD *v17;
  _QWORD *v18;
  char *v19;

  if (!a5)
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  if (!a2)
  {
    v9 = 0;
    if (a3)
      goto LABEL_7;
LABEL_17:
    v10 = 0;
    if (a4)
      goto LABEL_11;
    goto LABEL_18;
  }
  if ((a2 & 0x8000000000000000) != 0)
    goto LABEL_29;
  if (a2 > 0x38E38E38E38E38ELL)
    goto LABEL_29;
  v9 = 72 * a2;
  if (!(72 * a2))
    goto LABEL_29;
  if (!a3)
    goto LABEL_17;
LABEL_7:
  if ((a3 & 0x8000000000000000) != 0)
    goto LABEL_29;
  if (a3 >> 61)
    goto LABEL_29;
  v10 = 8 * a3;
  if (!(8 * a3))
    goto LABEL_29;
  if (a4)
  {
LABEL_11:
    if ((a4 & 0x8000000000000000) != 0)
      goto LABEL_29;
    if (a4 >> 60)
      goto LABEL_29;
    v11 = 16 * a4;
    if (!(16 * a4))
      goto LABEL_29;
    goto LABEL_19;
  }
LABEL_18:
  v11 = 0;
LABEL_19:
  if (v9 < 0xFFFFFFFFFFFFFEA0)
  {
    v13 = v9 + 359;
    v14 = v13 & 0xFFFFFFFFFFFFFFF8;
    if (!__CFADD__(v10, v13 & 0xFFFFFFFFFFFFFFF8))
    {
      v15 = (v10 + v13) & 0xFFFFFFFFFFFFFFF8;
      if (!__CFADD__(v11, v15))
      {
        FigThreadRunOnce(&sRegisterFigSampleBufferTypeOnce, (void (*)(void))registerFigSampleBufferType);
        Instance = (_QWORD *)_CFRuntimeCreateInstance();
        if (Instance)
        {
          v17 = Instance;
          v18 = Instance + 44;
          if (!a2)
            v18 = 0;
          Instance[11] = a2;
          Instance[12] = v18;
          v19 = (char *)Instance + v14;
          if (!a3)
            v19 = 0;
          Instance[13] = a3;
          Instance[14] = v19;
          result = 0;
          if (a4)
          {
            v17[41] = (char *)v17 + v15;
            v17[42] = a4;
            *((_BYTE *)v17 + 344) = 0;
          }
          goto LABEL_30;
        }
      }
    }
  }
LABEL_29:
  result = FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
  v17 = 0;
LABEL_30:
  *a5 = v17;
  return result;
}

uint64_t registerFigSampleBufferType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigSampleBufferID = result;
  return result;
}

double sBufInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

__n128 sbufUpdateCachedTimestamps(uint64_t a1, __n128 result)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CMTime *v8;
  uint64_t v9;
  _OWORD *v10;
  _OWORD *v11;
  __n128 v12;
  _OWORD *v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  int32_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  int32_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  CMTime v27;
  CMTime time;
  CMTime time1;

  v2 = *(_QWORD *)(a1 + 88);
  if (v2 >= 1)
  {
    v4 = *(_QWORD *)(a1 + 96);
    v5 = *(_QWORD *)(v4 + 64);
    *(_OWORD *)(a1 + 160) = *(_OWORD *)(v4 + 48);
    *(_QWORD *)(a1 + 176) = v5;
    v6 = *(_QWORD *)(v4 + 40);
    *(_OWORD *)(a1 + 184) = *(_OWORD *)(v4 + 24);
    *(_QWORD *)(a1 + 200) = v6;
    if (v2 == 1)
    {
      v7 = *(_QWORD *)(a1 + 80);
      v8 = (CMTime *)(a1 + 208);
      result = *(__n128 *)v4;
      if (v7)
      {
        time.epoch = *(_QWORD *)(v4 + 16);
        *(__n128 *)&time.value = result;
        CMTimeMultiply(&time1, &time, v7);
        result.n128_u64[0] = time1.value;
        *v8 = time1;
      }
      else
      {
        *(_QWORD *)(a1 + 224) = *(_QWORD *)(v4 + 16);
        *(__n128 *)&v8->value = result;
      }
    }
    else
    {
      v9 = 0;
      v10 = (_OWORD *)(a1 + 160);
      v11 = (_OWORD *)(a1 + 184);
      v12 = *(__n128 *)v4;
      v13 = (_OWORD *)(a1 + 208);
      *(_QWORD *)(a1 + 224) = *(_QWORD *)(v4 + 16);
      *(__n128 *)(a1 + 208) = v12;
      v14 = 1;
      do
      {
        v15 = *(_QWORD *)(a1 + 96) + v9;
        v16 = *(_OWORD *)(v15 + 96);
        time1.epoch = *(_QWORD *)(v15 + 112);
        *(_OWORD *)&time1.value = v16;
        *(_OWORD *)&time.value = *v11;
        time.epoch = *(_QWORD *)(a1 + 200);
        v17 = CMTimeCompare(&time1, &time);
        v18 = *(_QWORD *)(a1 + 96);
        if (v17 < 0)
        {
          v19 = *(_OWORD *)(v18 + v9 + 96);
          *(_QWORD *)(a1 + 200) = *(_QWORD *)(v18 + v9 + 112);
          *v11 = v19;
        }
        v20 = v18 + v9;
        v21 = *(_OWORD *)(v20 + 120);
        time1.epoch = *(_QWORD *)(v20 + 136);
        *(_OWORD *)&time1.value = v21;
        *(_OWORD *)&time.value = *v10;
        time.epoch = *(_QWORD *)(a1 + 176);
        v22 = CMTimeCompare(&time1, &time);
        v23 = *(_QWORD *)(a1 + 96);
        if (v22 < 0)
        {
          v24 = *(_OWORD *)(v23 + v9 + 120);
          *(_QWORD *)(a1 + 176) = *(_QWORD *)(v23 + v9 + 136);
          *v10 = v24;
        }
        v25 = v23 + v9;
        *(_OWORD *)&time.value = *v13;
        time.epoch = *(_QWORD *)(a1 + 224);
        v26 = *(_OWORD *)(v25 + 72);
        v27.epoch = *(_QWORD *)(v25 + 88);
        *(_OWORD *)&v27.value = v26;
        CMTimeAdd(&time1, &time, &v27);
        result.n128_u64[0] = time1.value;
        *v13 = *(_OWORD *)&time1.value;
        *(_QWORD *)(a1 + 224) = time1.epoch;
        ++v14;
        v9 += 72;
      }
      while (v14 < *(_QWORD *)(a1 + 88));
    }
  }
  return result;
}

size_t figSampleBufferCheckDataSize(size_t result)
{
  size_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v7;
  uint64_t v8;
  unsigned int v9;
  size_t DataLength;
  char *v11;
  os_log_type_t type;
  int v13[2];
  const char *v14;
  __int16 v15;
  size_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  size_t v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(result + 25))
  {
    v1 = result;
    if (!*(_DWORD *)(result + 28))
    {
      result = *(_QWORD *)(result + 16);
      if (result)
      {
        v2 = *(_QWORD *)(v1 + 104);
        if (v2)
        {
          if (v2 == 1)
          {
            v3 = **(_QWORD **)(v1 + 112) * *(_QWORD *)(v1 + 80);
          }
          else
          {
            if (v2 < 1)
              return result;
            v3 = 0;
            v4 = *(uint64_t **)(v1 + 112);
            do
            {
              v5 = *v4++;
              v3 += v5;
              --v2;
            }
            while (v2);
          }
          if (v3)
          {
            result = CMBlockBufferGetDataLength((CMBlockBufferRef)result);
            if (v3 != result)
            {
              v13[0] = 0;
              type = OS_LOG_TYPE_DEFAULT;
              os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E80, 0, v13, &type);
              v7 = v13[0];
              if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
                v9 = v7;
              else
                v9 = v7 & 0xFFFFFFFE;
              if (v9)
              {
                DataLength = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(v1 + 16));
                v13[1] = 136315906;
                v14 = "figSampleBufferCheckDataSize";
                v15 = 2048;
                v16 = v1;
                v17 = 2048;
                v18 = v3;
                v19 = 2048;
                v20 = DataLength;
                v11 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v7) = v13[0];
              }
              else
              {
                v11 = 0;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E80, 0, 0, v11, v11 != &v21, v7, 0, v8);
              return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
            }
          }
        }
      }
    }
  }
  return result;
}

void FigAttachmentsRegisterCVBuffer()
{
  const void *TypeID;

  TypeID = (const void *)CVPixelBufferGetTypeID();
  FigRuntimeRegisterAttachmentBearerWithTypeID(sFigCVBufferAttachmentBearerCallbacks, TypeID);
}

const void *FigRuntimeGetAttachmentBearerCallbacksWithTypeID(const void *a1)
{
  const void *result;

  FigThreadRunOnce(&sFigAttachmentsRegisterInternalBearersOnce, figAttachmentsRegisterInternalBearers);
  result = (const void *)sFigAttachmentBearerCallbacksPerTypeID;
  if (sFigAttachmentBearerCallbacksPerTypeID)
    return CFDictionaryGetValue((CFDictionaryRef)sFigAttachmentBearerCallbacksPerTypeID, a1);
  return result;
}

const __CFDictionary *sBufGetAttachment(uint64_t a1, void *key, _DWORD *a3)
{
  const __CFDictionary *result;
  const __CFDictionary *v7;

  if (*(_BYTE *)(a1 + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else
  {
    v7 = *(const __CFDictionary **)(a1 + 312);
    if (v7 && (result = (const __CFDictionary *)CFDictionaryGetValue(v7, key)) != 0)
    {
      if (a3)
        *a3 = 1;
    }
    else
    {
      result = *(const __CFDictionary **)(a1 + 320);
      if (result)
      {
        result = (const __CFDictionary *)CFDictionaryGetValue(result, key);
        if (a3)
        {
          if (result)
            *a3 = 0;
        }
      }
    }
  }
  return result;
}

double sBufSetAttachment(__CFDictionary **cf, void *key, void *value, int a4)
{
  uint64_t v4;
  __CFDictionary **v5;
  CFMutableDictionaryRef *v6;
  double result;
  __CFDictionary *Mutable;
  const __CFAllocator *v12;

  if (a4 == 1)
    v4 = 39;
  else
    v4 = 40;
  if (a4 == 1)
    v5 = cf + 39;
  else
    v5 = cf + 40;
  if (a4 == 1)
    v6 = cf + 40;
  else
    v6 = cf + 39;
  if (*((_BYTE *)cf + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    Mutable = *v5;
    if (*v5
      || (v12 = CFGetAllocator(cf),
          Mutable = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]),
          (cf[v4] = Mutable) != 0))
    {
      if (value)
        CFDictionarySetValue(Mutable, key, value);
      else
        CFDictionaryRemoveValue(Mutable, key);
    }
    if (*v6)
      CFDictionaryRemoveValue(*v6, key);
    return checkCacheKeys((uint64_t)cf, key);
  }
  return result;
}

double checkCacheKeys(uint64_t a1, CFTypeRef cf1)
{
  double result;

  if (CFEqual(cf1, CFSTR("TrimDurationAtStart"))
    || CFEqual(cf1, CFSTR("TrimDurationAtEnd"))
    || CFEqual(cf1, CFSTR("SpeedMultiplier"))
    || CFEqual(cf1, CFSTR("Reverse")))
  {
    result = *(double *)&kCMTimeInvalid.value;
    *(_OWORD *)(a1 + 232) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(a1 + 248) = 0;
    *(_OWORD *)(a1 + 256) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(a1 + 272) = 0;
    *(_OWORD *)(a1 + 280) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(a1 + 296) = 0;
  }
  return result;
}

uint64_t bufQInsertElementAtIndex(uint64_t a1, CFIndex a2, const void *a3)
{
  CFIndex Count;
  _OWORD *v7;
  uint64_t (*v8)(_QWORD *, const void *);
  const void *v9;
  _QWORD *v10;
  uint64_t v11;
  const __CFSet *v12;
  CMTime v14;
  CMTime lhs;
  CMTime v16;
  CMTime rhs;
  CMTime time2;
  CMTime time1;
  CMTime v20;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (!a2)
    bufQStopListeningForHeadBufferBecomingReady(a1);
  if (*(_BYTE *)(a1 + 120))
  {
    if (!*(_QWORD *)(a1 + 68))
    {
LABEL_21:
      (*(void (**)(CMTime *__return_ptr, const void *, _QWORD))(a1 + 76))(&v20, a3, *(_QWORD *)(a1 + 52));
      goto LABEL_23;
    }
  }
  else if (!*(_QWORD *)(a1 + 64))
  {
    goto LABEL_22;
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  memset(&v20, 0, sizeof(v20));
  if (*(_BYTE *)(a1 + 120))
    (*(void (**)(CMTime *__return_ptr, const void *, _QWORD))(a1 + 68))(&v20, a3, *(_QWORD *)(a1 + 52));
  else
    (*(void (**)(CMTime *__return_ptr, _QWORD, const void *))(*(_QWORD *)(a1 + 64) + 16))(&v20, *(_QWORD *)(a1 + 64), a3);
  if (Count < 1)
  {
    *(_OWORD *)(a1 + 240) = *(_OWORD *)&kCMTimeZero.value;
    *(_QWORD *)(a1 + 256) = 0;
    *(_OWORD *)(a1 + 216) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(a1 + 232) = 0;
  }
  else if ((v20.flags & 1) != 0 && (*(_BYTE *)(a1 + 228) & 1) != 0)
  {
    time1 = v20;
    time2 = *(CMTime *)(a1 + 216);
    if (CMTimeCompare(&time1, &time2) < 0)
    {
      memset(&time1, 0, sizeof(time1));
      time2 = *(CMTime *)(a1 + 216);
      rhs = v20;
      CMTimeSubtract(&time1, &time2, &rhs);
      rhs = *(CMTime *)(a1 + 240);
      v16 = time1;
      CMTimeMaximum(&time2, &rhs, &v16);
      *(CMTime *)(a1 + 240) = time2;
    }
  }
  v7 = (_OWORD *)(a1 + 216);
  if ((*(_BYTE *)(a1 + 228) & 1) == 0
    || (v20.flags & 1) != 0
    && (time1 = v20,
        *(_OWORD *)&time2.value = *v7,
        time2.epoch = *(_QWORD *)(a1 + 232),
        CMTimeCompare(&time1, &time2) >= 1))
  {
    *v7 = *(_OWORD *)&v20.value;
    *(_QWORD *)(a1 + 232) = v20.epoch;
  }
  if (*(_BYTE *)(a1 + 120))
    goto LABEL_21;
LABEL_22:
  (*(void (**)(CMTime *__return_ptr, _QWORD, const void *))(*(_QWORD *)(a1 + 72) + 16))(&v20, *(_QWORD *)(a1 + 72), a3);
LABEL_23:
  *(_OWORD *)&rhs.value = *(_OWORD *)&v20.value;
  if (v20.epoch)
    FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), a2, a3);
  time1 = *(CMTime *)(a1 + 124);
  *(_OWORD *)&time2.value = *(_OWORD *)&rhs.value;
  time2.epoch = 0;
  CMTimeAdd(&v20, &time1, &time2);
  *(CMTime *)(a1 + 124) = v20;
  if (*(_BYTE *)(a1 + 120))
  {
    v8 = *(uint64_t (**)(_QWORD *, const void *))(a1 + 108);
    if (!v8)
      goto LABEL_31;
    v9 = *(const void **)(a1 + 52);
    v10 = a3;
  }
  else
  {
    v10 = *(_QWORD **)(a1 + 104);
    if (!v10)
      goto LABEL_31;
    v8 = (uint64_t (*)(_QWORD *, const void *))v10[2];
    v9 = a3;
  }
  v11 = v8(v10, v9);
  FigCFDictionarySetInt64(*(void **)(a1 + 32), a3, v11);
  *(_QWORD *)(a1 + 152) += v11;
LABEL_31:
  if ((*(_DWORD *)(a1 + 136) & 0x1D) != 1)
  {
    CMBufferQueueGetMaxPresentationTimeStamp(&lhs, (CMBufferQueueRef)a1);
    CMBufferQueueGetMinPresentationTimeStamp(&v14, (CMBufferQueueRef)a1);
    CMTimeSubtract(&v20, &lhs, &v14);
    *(CMTime *)(a1 + 124) = v20;
  }
  if (!a2)
    bufQStartListeningForHeadBufferBecomingReady(a1);
  *(_BYTE *)(a1 + 184) = 0;
  v12 = *(const __CFSet **)(a1 + 160);
  if (v12)
    CFSetApplyFunction(v12, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, (void *)a1);
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
}

uint64_t bufQStopListeningForHeadBufferBecomingReady(uint64_t result)
{
  uint64_t v1;
  const __CFString **v2;
  const __CFString *v3;
  __CFNotificationCenter *DefaultLocalCenter;

  v1 = result;
  if (*(_BYTE *)(result + 120))
  {
    if (!*(_QWORD *)(result + 84))
      return result;
    v2 = (const __CFString **)(result + 100);
  }
  else
  {
    if (!*(_QWORD *)(result + 80))
      return result;
    v2 = (const __CFString **)(result + 96);
  }
  v3 = *v2;
  if (*v2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(result + 16));
    if (*(_QWORD *)(v1 + 176))
    {
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterRemoveListener(DefaultLocalCenter, (const void *)v1, (int)bufQDataBecameReady, v3, *(void **)(v1 + 176));
      *(_QWORD *)(v1 + 176) = 0;
    }
    return FigReentrantMutexUnlock(*(pthread_mutex_t **)(v1 + 16));
  }
  return result;
}

uint64_t FigDeferNotificationToRunLoop(const void *a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, __CFRunLoop *a7, CFAllocatorRef allocator)
{
  const void **v16;
  const void **v17;
  const void *v18;
  const void *v19;
  CFAbsoluteTime Current;
  CFRunLoopTimerRef v21;
  __CFRunLoopTimer *v22;
  uint64_t v23;
  CFRunLoopTimerContext v25;

  memset(&v25, 0, sizeof(v25));
  v16 = (const void **)CFAllocatorAllocate(allocator, 64, 0);
  if (!v16)
    return FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
  v17 = v16;
  *v16 = a2;
  v16[1] = a1;
  v16[2] = a3;
  v16[3] = a4;
  v16[4] = a5;
  v16[5] = a6;
  v16[6] = allocator;
  v25.info = v16;
  v25.release = (void (__cdecl *)(const void *))figDeferredNotificationRelease;
  if (a2)
  {
    CFRetain(a2);
    a4 = v17[3];
  }
  if (a4)
    CFRetain(a4);
  v18 = v17[5];
  if (v18)
    CFRetain(v18);
  v19 = v17[6];
  if (v19)
    CFRetain(v19);
  Current = CFAbsoluteTimeGetCurrent();
  v21 = CFRunLoopTimerCreate(allocator, Current, 0.0, 0, 0, (CFRunLoopTimerCallBack)figDeferredNotificationRun, &v25);
  if (v21)
  {
    v22 = v21;
    CFRetain(v21);
    CFRunLoopAddTimer(a7, v22, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
    CFRunLoopAddTimer(a7, v22, (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
    CFRunLoopAddTimer(a7, v22, CFSTR("FigDeferredNotificationMode"));
    CFRelease(v22);
    CFRunLoopWakeUp(a7);
    return 0;
  }
  else
  {
    v23 = FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
    figDeferredNotificationRelease(v17);
  }
  return v23;
}

_QWORD *findBestTimeStamp(uint64_t a1, uint64_t *a2)
{
  _QWORD *result;
  __int128 *v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  CMTime v9;
  CMTime time1;
  CMTime v11;

  memset(&v11, 0, sizeof(v11));
  result = ((_QWORD *(*)(CMTime *__return_ptr, uint64_t, uint64_t))a2[1])(&v11, a1, a2[2]);
  if ((v11.flags & 1) != 0)
  {
    v4 = (__int128 *)*a2;
    if ((*(_BYTE *)(*a2 + 12) & 1) == 0)
      goto LABEL_5;
    if (*((_BYTE *)a2 + 24))
    {
      time1 = v11;
      v5 = *v4;
      v9.epoch = *((_QWORD *)v4 + 2);
      *(_OWORD *)&v9.value = v5;
      result = (_QWORD *)CMTimeCompare(&time1, &v9);
      if ((int)result <= 0)
        return result;
      goto LABEL_5;
    }
    time1 = v11;
    v8 = *v4;
    v9.epoch = *((_QWORD *)v4 + 2);
    *(_OWORD *)&v9.value = v8;
    result = (_QWORD *)CMTimeCompare(&time1, &v9);
    if ((result & 0x80000000) != 0)
    {
LABEL_5:
      v6 = *a2;
      v7 = *(_OWORD *)&v11.value;
      *(_QWORD *)(v6 + 16) = v11.epoch;
      *(_OWORD *)v6 = v7;
    }
  }
  return result;
}

CMTime *bufQGetEndPTS@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, CMTime *a3@<X8>)
{
  CMTime v7;
  CMTime lhs;

  (*(void (**)(CMTime *__return_ptr, uint64_t, _QWORD))(a2 + 20))(&lhs, a1, *(_QWORD *)(a2 + 4));
  (*(void (**)(CMTime *__return_ptr, uint64_t, _QWORD))(a2 + 28))(&v7, a1, *(_QWORD *)(a2 + 4));
  return CMTimeAdd(a3, &lhs, &v7);
}

uint64_t FigTimebaseGetTransformRelativeToMasterAtHeight(pthread_mutex_t **a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  pthread_mutex_t **v8;
  pthread_mutex_t **v9;
  uint64_t TransformRelativeToMaster;
  __int128 *v11;
  __int128 *v12;
  uint64_t v13;
  CMTimebaseRef v14;
  __int128 v16;
  _OWORD v18[3];
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v4 = 4294954548;
  if (a1)
  {
    v5 = a2 - 1;
    if (a2 >= 1)
    {
      if (a4)
      {
        v26 = *(_OWORD *)&kCMTimeZero.value;
        v27 = 0;
        v24 = *(_OWORD *)&kCMTimeZero.value;
        *(_QWORD *)&v25 = 0;
        *((_QWORD *)&v25 + 1) = 0x3FF0000000000000;
        v8 = figTimebaseCopyTargetTimebase(a1);
        if (!v8)
          goto LABEL_23;
        v9 = v8;
        while (1)
        {
          v23 = 0;
          v21 = 0u;
          v22 = 0u;
          v20 = 0u;
          v19 = 0;
          memset(v18, 0, sizeof(v18));
          TransformRelativeToMaster = FigTimebaseGetTransformRelativeToMaster(v9, a3, (uint64_t)v18);
          if ((_DWORD)TransformRelativeToMaster)
          {
            v4 = TransformRelativeToMaster;
            goto LABEL_19;
          }
          v20 = v24;
          v21 = v25;
          v22 = v26;
          v23 = v27;
          if (a3)
          {
            v11 = v18;
            v12 = &v20;
          }
          else
          {
            v11 = &v20;
            v12 = v18;
          }
          FigSyncCombineTransforms(v11, (uint64_t)v12, (uint64_t)&v24);
          v4 = v13;
          if ((_DWORD)v13)
            goto LABEL_19;
          v14 = CMTimebaseCopySourceTimebase((CMTimebaseRef)v9);
          CFRelease(v9);
          if (v5)
          {
            if (!v14)
              break;
          }
          v4 = 0;
          if (v5-- != 0)
          {
            v9 = (pthread_mutex_t **)v14;
            if (v14)
              continue;
          }
          goto LABEL_20;
        }
        v4 = FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
        v9 = 0;
LABEL_19:
        v14 = (CMTimebaseRef)v9;
LABEL_20:
        if (v14)
          CFRelease(v14);
        if (!(_DWORD)v4)
        {
LABEL_23:
          v4 = 0;
          v16 = v25;
          *(_OWORD *)a4 = v24;
          *(_OWORD *)(a4 + 16) = v16;
          *(_OWORD *)(a4 + 32) = v26;
          *(_QWORD *)(a4 + 48) = v27;
        }
      }
    }
  }
  return v4;
}

uint64_t FigFileByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a3)
    return FigFileForkGetLengthAtOffset(*(int **)(DerivedStorage + 8), a2, a3);
  else
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
}

uint64_t figDeferredNotificationRun(__CFRunLoopTimer *a1, _QWORD *a2)
{
  void (*v2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

  v2 = (void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a2[1];
  if (v2)
  {
    v2(*a2, a2[2], a2[3], a2[4], a2[5]);
    a2[1] = 0;
    CFRunLoopTimerInvalidate(a1);
    CFRelease(a1);
  }
  return FigAtomicIncrement32((unsigned int *)&sFigDeferredNotificationRunSeed);
}

uint64_t bufQRemoveElementAtIndex(uint64_t a1)
{
  const void *ValueAtIndex;
  CFTypeRef v3;
  _OWORD *v4;
  CFIndex Count;
  const __CFSet *v6;
  CMTime v8;
  CMTime v9;
  CMTime rhs;
  CMTime lhs;
  CMTime time1;
  CMTime v13;

  memset(&v13, 0, sizeof(v13));
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  bufQStopListeningForHeadBufferBecomingReady(a1);
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
  v3 = CFRetain(ValueAtIndex);
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 24), 0);
  if (*(_BYTE *)(a1 + 120))
    (*(void (**)(CMTime *__return_ptr, CFTypeRef, _QWORD))(a1 + 76))(&v13, v3, *(_QWORD *)(a1 + 52));
  else
    (*(void (**)(CMTime *__return_ptr, _QWORD, CFTypeRef))(*(_QWORD *)(a1 + 72) + 16))(&v13, *(_QWORD *)(a1 + 72), v3);
  lhs = *(CMTime *)(a1 + 124);
  rhs = v13;
  CMTimeSubtract(&time1, &lhs, &rhs);
  *(CMTime *)(a1 + 124) = time1;
  if (*(_BYTE *)(a1 + 120))
  {
    if (!*(_QWORD *)(a1 + 108))
      goto LABEL_7;
    goto LABEL_6;
  }
  if (*(_QWORD *)(a1 + 104))
  {
LABEL_6:
    time1.value = 0;
    FigCFDictionaryGetInt64IfPresent(*(_QWORD *)(a1 + 32), v3, &time1);
    *(_QWORD *)(a1 + 152) -= time1.value;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v3);
  }
LABEL_7:
  v4 = (_OWORD *)(a1 + 124);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count)
  {
    *(_OWORD *)&time1.value = *v4;
    time1.epoch = *(_QWORD *)(a1 + 140);
    *(_OWORD *)&lhs.value = *(_OWORD *)&kCMTimeZero.value;
    lhs.epoch = 0;
    if (!CMTimeCompare(&time1, &lhs))
    {
      *v4 = *(_OWORD *)&kCMTimeZero.value;
      *(_QWORD *)(a1 + 140) = 0;
    }
  }
  else
  {
    *v4 = *(_OWORD *)&kCMTimeZero.value;
    *(_QWORD *)(a1 + 140) = 0;
    *(_QWORD *)(a1 + 152) = 0;
  }
  if ((*(_DWORD *)(a1 + 136) & 0x1D) != 1)
  {
    CMBufferQueueGetMaxPresentationTimeStamp(&v9, (CMBufferQueueRef)a1);
    CMBufferQueueGetMinPresentationTimeStamp(&v8, (CMBufferQueueRef)a1);
    CMTimeSubtract(&time1, &v9, &v8);
    *v4 = *(_OWORD *)&time1.value;
    *(_QWORD *)(a1 + 140) = time1.epoch;
  }
  bufQStartListeningForHeadBufferBecomingReady(a1);
  if (Count <= 1)
  {
    *(_OWORD *)(a1 + 240) = *(_OWORD *)&kCMTimeZero.value;
    *(_QWORD *)(a1 + 256) = 0;
    if (!Count)
    {
      *(_OWORD *)(a1 + 216) = *(_OWORD *)&kCMTimeInvalid.value;
      *(_QWORD *)(a1 + 232) = 0;
    }
  }
  v6 = *(const __CFSet **)(a1 + 160);
  if (v6)
    CFSetApplyFunction(v6, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, (void *)a1);
  CFRelease(v3);
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
}

uint64_t FigAtomicAdd32(int a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;

  do
  {
    v2 = __ldxr(a2);
    v3 = v2 + a1;
  }
  while (__stxr(v3, a2));
  return v3;
}

uint64_t coreAudioObjectPropertyListener(uint64_t a1, int a2, int *a3, void *a4)
{
  uint64_t v5;
  id v6;
  const void *v7;
  uint64_t DerivedStorage;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  _QWORD v16[5];
  _QWORD block[7];

  LODWORD(v5) = a2;
  v6 = FigCFWeakReferenceTableCopyValue(gFigAudioDeviceClockRegistry, a4);
  if (v6)
  {
    v7 = v6;
    DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)v6);
    FigReadWriteLockLockForRead(*(_QWORD *)(DerivedStorage + 64));
    if ((_DWORD)v5)
    {
      v9 = 0;
      v5 = v5;
      do
      {
        v11 = *a3;
        a3 += 3;
        v10 = v11;
        if (v11 == 1735354734)
        {
          v9 |= 4u;
        }
        else if (v10 == 1853059700)
        {
          v9 |= 8u;
        }
        else if (v10 == 1870030194)
        {
          v9 |= 2u;
        }
        else
        {
          FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
        }
        --v5;
      }
      while (v5);
      if ((v9 & 0xF) != 0)
      {
        FigAtomicBitOr32(v9, (unsigned int *)(DerivedStorage + 56));
        v12 = MEMORY[0x1E0C809B0];
        v16[0] = MEMORY[0x1E0C809B0];
        v16[1] = 0x40000000;
        v16[2] = __coreAudioObjectPropertyListener_block_invoke;
        v16[3] = &__block_descriptor_tmp_22;
        v16[4] = v7;
        CFRetain(v7);
        v13 = FigDerivedClockGetDerivedStorage((uint64_t)v7);
        FigAtomicIncrement32((unsigned int *)(v13 + 120));
        v14 = *(NSObject **)(v13 + 128);
        block[0] = v12;
        block[1] = 0x40000000;
        block[2] = __writeProtectedStorageAsync_block_invoke;
        block[3] = &unk_1E28D9B80;
        block[4] = v16;
        block[5] = v13;
        block[6] = v7;
        dispatch_async(v14, block);
      }
    }
    FigReadWriteLockUnlockForRead(*(_QWORD *)(DerivedStorage + 64));
    CFRelease(v7);
  }
  return 0;
}

void rescheduleValidAndRemoveInvalidTimers(CFDictionaryRef *a1, CMTime *a2, int a3)
{
  CFIndex Count;
  uint64_t v7;
  const __CFAllocator *v8;
  const void **v9;
  const void **v10;
  const __CFAllocator *v11;
  const void **v12;
  const void **v13;
  const __CFData *v14;
  const void **v15;
  CFDataRef *v16;
  __CFRunLoop *Value;
  char v18;
  __CFRunLoopTimer *v19;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  CMTime v22;
  CMTime v23;

  Count = CFDictionaryGetCount(a1[35]);
  if (Count)
  {
    v7 = Count;
    if (Count == CFDictionaryGetCount(a1[37]))
    {
      v8 = CFGetAllocator(a1);
      v9 = (const void **)CFAllocatorAllocate(v8, 8 * v7, 0);
      if (v9)
      {
        v10 = v9;
        v11 = CFGetAllocator(a1);
        v12 = (const void **)CFAllocatorAllocate(v11, 8 * v7, 0);
        if (v12)
        {
          v13 = v12;
          CFDictionaryGetKeysAndValues(a1[35], v10, v12);
          if (v7 >= 1)
          {
            v14 = (const __CFData *)*MEMORY[0x1E0C9AE40];
            v15 = v10;
            v16 = (CFDataRef *)v13;
            do
            {
              if (CFRunLoopTimerIsValid((CFRunLoopTimerRef)*v15))
              {
                if (v14 != *v16)
                {
                  v23 = *(CMTime *)CFDataGetBytePtr(*v16);
                  Value = (__CFRunLoop *)CFDictionaryGetValue(a1[37], *v15);
                  v18 = CFDictionaryGetValue(a1[36], *v15);
                  v19 = (__CFRunLoopTimer *)*v15;
                  v22 = *a2;
                  rescheduleTimer(v19, Value, &v23, (OpaqueCMTimebase *)a1, &v22, a3, v18);
                }
              }
              else
              {
                CFDictionaryRemoveValue(a1[35], *v15);
                CFDictionaryRemoveValue(a1[36], *v15);
                CFDictionaryRemoveValue(a1[37], *v15);
              }
              ++v16;
              ++v15;
              --v7;
            }
            while (v7);
          }
          v20 = CFGetAllocator(a1);
          CFAllocatorDeallocate(v20, v10);
        }
        else
        {
          v13 = v10;
        }
        v21 = CFGetAllocator(a1);
        CFAllocatorDeallocate(v21, v13);
      }
    }
  }
}

void figDeferredNotificationRelease(const void **ptr)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const __CFAllocator *v5;

  v2 = *ptr;
  if (v2)
    CFRelease(v2);
  v3 = ptr[3];
  if (v3)
    CFRelease(v3);
  v4 = ptr[5];
  if (v4)
    CFRelease(v4);
  v5 = (const __CFAllocator *)ptr[6];
  CFAllocatorDeallocate(v5, ptr);
  if (v5)
    CFRelease(v5);
}

uint64_t FigBaseObjectEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t (*v5)(void);

  if (a1 == a2)
    return 1;
  v2 = 0;
  if (!a1 || !a2)
    return v2;
  v3 = *(_QWORD *)(a1 + 24);
  if (v3 != *(_QWORD *)(a2 + 24))
    return 0;
  v5 = *(uint64_t (**)(void))(*(_QWORD *)(v3 + 8) + 16);
  if (!v5)
    return 0;
  return v5();
}

double sBufFinalize(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  void *v8;
  double result;

  switch(*(_DWORD *)(a1 + 28))
  {
    case 0:
    case 1:
    case 2:
    case 3:
      v2 = *(const void **)(a1 + 16);
      if (v2)
        CFRelease(v2);
      break;
    default:
      break;
  }
  if (*(_BYTE *)(a1 + 27))
    _Block_release(*(const void **)(a1 + 48));
  if (*(_QWORD *)(a1 + 32) == 1)
    _Block_release(*(const void **)(a1 + 40));
  v3 = *(const void **)(a1 + 152);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 64);
  if (v4)
    CFRelease(v4);
  FigFormatDescriptionRelease(*(CFTypeRef *)(a1 + 72));
  v5 = *(const void **)(a1 + 304);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 312);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 320);
  if (v7)
    CFRelease(v7);
  if (*(_BYTE *)(a1 + 120))
  {
    v8 = *(void **)(a1 + 112);
    if (v8)
    {
      *(_QWORD *)(a1 + 112) = 0;
      free(v8);
    }
  }
  result = 0.0;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void FigSampleBufferRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void ftbFinalize(uint64_t a1)
{
  const void **v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  __CFDictionary *v7;
  __CFDictionary *v8;
  __CFDictionary *v9;
  __CFDictionary *v10;
  __CFDictionary *v11;
  CFNotificationCenterRef DefaultLocalCenter;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;

  v2 = (const void **)(a1 + 136);
  figTimebaseSwitchListenersToNewMaster((void *)a1, *(const void **)(a1 + 136), 0);
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    figTimebaseUninstallReadOnlyTimebaseNotifications((const void *)a1, v3);
    v4 = *(const void **)(a1 + 24);
    if (!v4)
      goto LABEL_6;
    v2 = (const void **)(a1 + 24);
  }
  else
  {
    v4 = *v2;
    if (!*v2)
      goto LABEL_6;
  }
  CFRelease(v4);
  *v2 = 0;
LABEL_6:
  v5 = *(const void **)(a1 + 128);
  if (v5)
    CFRelease(v5);
  *(_QWORD *)(a1 + 128) = 0;
  v6 = *(const void **)(a1 + 144);
  if (v6)
    CFRelease(v6);
  *(_QWORD *)(a1 + 144) = 0;
  v7 = *(__CFDictionary **)(a1 + 280);
  if (v7)
  {
    CFDictionaryRemoveAllValues(v7);
    CFRelease(*(CFTypeRef *)(a1 + 280));
    *(_QWORD *)(a1 + 280) = 0;
  }
  v8 = *(__CFDictionary **)(a1 + 288);
  if (v8)
  {
    CFDictionaryRemoveAllValues(v8);
    CFRelease(*(CFTypeRef *)(a1 + 288));
    *(_QWORD *)(a1 + 288) = 0;
  }
  v9 = *(__CFDictionary **)(a1 + 296);
  if (v9)
  {
    CFDictionaryRemoveAllValues(v9);
    CFRelease(*(CFTypeRef *)(a1 + 296));
    *(_QWORD *)(a1 + 296) = 0;
  }
  v10 = *(__CFDictionary **)(a1 + 304);
  if (v10)
  {
    CFDictionaryRemoveAllValues(v10);
    CFRelease(*(CFTypeRef *)(a1 + 304));
    *(_QWORD *)(a1 + 304) = 0;
  }
  v11 = *(__CFDictionary **)(a1 + 312);
  if (v11)
  {
    CFDictionaryRemoveAllValues(v11);
    CFRelease(*(CFTypeRef *)(a1 + 312));
    *(_QWORD *)(a1 + 312) = 0;
  }
  if (*(_QWORD *)(a1 + 112))
  {
    FigReentrantMutexDestroy();
    *(_QWORD *)(a1 + 112) = 0;
  }
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterUnregisterForBarrierSupport((uint64_t)DefaultLocalCenter, a1);
  v13 = *(NSObject **)(a1 + 120);
  if (v13)
  {
    dispatch_release(v13);
    *(_QWORD *)(a1 + 120) = 0;
  }
  if (*(_DWORD *)(a1 + 16) == 1)
  {
    v14 = *(NSObject **)(a1 + 104);
    if (v14)
    {
      dispatch_source_cancel(v14);
      dispatch_release(*(dispatch_object_t *)(a1 + 104));
    }
    v15 = *(NSObject **)(a1 + 96);
    if (v15)
      dispatch_release(v15);
  }
}

uint64_t FigThreadAbort(uint64_t a1)
{
  uint64_t result;
  _QWORD *v3;
  void (*v4)(_QWORD);
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;

  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (!(_DWORD)result)
  {
    if ((gAbortingNow & 1) == 0)
    {
      gAbortingNow = 1;
      v3 = (_QWORD *)gAbortActionList;
      if (gAbortActionList)
      {
        do
        {
          if (*v3 == a1)
          {
            v4 = (void (*)(_QWORD))v3[2];
            if (v4)
              v4(v3[3]);
          }
          v3 = (_QWORD *)v3[4];
        }
        while (v3);
        v5 = (_QWORD *)gAbortActionList;
        if (gAbortActionList)
        {
          while (1)
          {
            v6 = (_QWORD *)v5[4];
            if (!v5[2])
              break;
LABEL_18:
            v5 = v6;
            if (!v6)
              goto LABEL_19;
          }
          v7 = gAbortActionList;
          if ((_QWORD *)gAbortActionList == v5)
          {
            gAbortActionList = v5[4];
            if (v6)
            {
LABEL_17:
              free(v5);
              goto LABEL_18;
            }
            v9 = &gAbortActionList;
          }
          else
          {
            do
            {
              v8 = v7;
              v7 = *(_QWORD *)(v7 + 32);
            }
            while ((_QWORD *)v7 != v5);
            *(_QWORD *)(v8 + 32) = v6;
            v9 = (uint64_t *)(v8 + 32);
            if (v6)
              goto LABEL_17;
          }
          qword_1ECDA85D8 = (uint64_t)v9;
          goto LABEL_17;
        }
      }
LABEL_19:
      gAbortingNow = 0;
    }
    return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
  }
  return result;
}

pthread_mutex_t *abortActionInitOnce()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  pthread_mutex_t *result;

  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  result = FigReentrantMutexCreateWithFlags(AllocatorForPermanentAllocations);
  gAbortActionLock = (uint64_t)result;
  gAbortActionList = 0;
  qword_1ECDA85D8 = (uint64_t)&gAbortActionList;
  return result;
}

uint64_t FigThreadJoin(pthread_t a1, void **a2)
{
  uint64_t v4;
  uint64_t v5;

  if (gAnyFigThreadIsPidBound == 1)
    figThreadBindToPID(a1);
  v4 = pthread_join(a1, a2);
  v5 = 4294954500;
  if ((_DWORD)v4 == 22 || (_DWORD)v4 == 11)
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v4 == 3)
  {
    v5 = 4294954502;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  return v4;
}

void triggerRelease(const __CFAllocator *a1, const void **a2)
{
  _Block_release(a2[2]);
  CFAllocatorDeallocate(a1, a2);
}

void FigBufferQueueRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

double bufQFinalize(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  CFNotificationCenterRef DefaultLocalCenter;
  double result;

  bufQStopListeningForHeadBufferBecomingReady(a1);
  if (*(_BYTE *)(a1 + 120))
  {
    v2 = *(const void **)(a1 + 100);
    if (v2)
      CFRelease(v2);
  }
  else
  {
    v3 = *(const void **)(a1 + 96);
    if (v3)
      CFRelease(v3);
    _Block_release(*(const void **)(a1 + 56));
    _Block_release(*(const void **)(a1 + 64));
    _Block_release(*(const void **)(a1 + 72));
    _Block_release(*(const void **)(a1 + 80));
    _Block_release(*(const void **)(a1 + 88));
    if (*(_QWORD *)(a1 + 48))
      _Block_release(*(const void **)(a1 + 104));
  }
  if (*(_QWORD *)(a1 + 16))
    FigReentrantMutexDestroy();
  v4 = *(const void **)(a1 + 24);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 32);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 160);
  if (v6)
    CFRelease(v6);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterUnregisterForBarrierSupport((uint64_t)DefaultLocalCenter, a1);
  _Block_release(*(const void **)(a1 + 192));
  *(_QWORD *)(a1 + 256) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t FigRunDeferredNotificationsOnCurrentRunLoop()
{
  int v0;
  BOOL v1;

  v0 = sFigDeferredNotificationRunSeed;
  do
  {
    CFRunLoopRunInMode(CFSTR("FigDeferredNotificationMode"), 0.0, 1u);
    v1 = v0 == sFigDeferredNotificationRunSeed;
    v0 = sFigDeferredNotificationRunSeed;
  }
  while (!v1);
  return 0;
}

BOOL FigFilePathEqual(uint64_t a1, uint64_t a2)
{
  return strcmp((const char *)(a1 + 16), (const char *)(a2 + 16)) == 0;
}

uint64_t fcFinalize(OpaqueCMClock *a1)
{
  uint64_t result;

  CMClockInvalidate(a1);
  result = *((_QWORD *)a1 + 2);
  if (result)
  {
    result = FigReentrantMutexDestroy();
    *((_QWORD *)a1 + 2) = 0;
  }
  return result;
}

const __CFAllocator *fadcFinalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  int v2;
  uint64_t v3;
  const void *v4;
  const __CFAllocator *result;
  _QWORD v6[5];
  int v7;
  char v8;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  FigCFWeakReferenceTableRemoveValue(gFigAudioDeviceClockRegistry, *(_QWORD *)(DerivedStorage + 144));
  v2 = *(_DWORD *)(DerivedStorage + 88);
  v3 = *(_QWORD *)(DerivedStorage + 144);
  if (fadcDeferRemovePropertyListeners_deferredFadcRemoveQueueOnce != -1)
    dispatch_once_f(&fadcDeferRemovePropertyListeners_deferredFadcRemoveQueueOnce, &fadcDeferRemovePropertyListeners_deferredFadcRemoveQueue, (dispatch_function_t)fadcInitDeferredRemoveQueue);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __fadcDeferRemovePropertyListeners_block_invoke;
  v6[3] = &__block_descriptor_tmp_20;
  v7 = v2;
  v6[4] = v3;
  v8 = 0;
  dispatch_async((dispatch_queue_t)fadcDeferRemovePropertyListeners_deferredFadcRemoveQueue, v6);
  FigReadWriteLockLockForWrite(*(_QWORD *)(DerivedStorage + 64));
  FigReadWriteLockUnlockForWrite(*(_QWORD *)(DerivedStorage + 64));
  v4 = *(const void **)(DerivedStorage + 80);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(DerivedStorage + 80) = 0;
  }
  dispatch_release(*(dispatch_object_t *)(DerivedStorage + 128));
  FigReadWriteLockDestroy(*(uint64_t **)(DerivedStorage + 136));
  result = FigReadWriteLockDestroy(*(uint64_t **)(DerivedStorage + 64));
  *(_QWORD *)(DerivedStorage + 64) = 0;
  return result;
}

uint64_t removePropertyListener(uint64_t a1, AudioObjectPropertySelector a2)
{
  uint64_t DerivedStorage;
  AudioObjectID v4;
  AudioObjectPropertyAddress inAddress;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  if (a2 != 1735354734 && a2 != 1870030194 && a2 != 1853059700)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v4 = *(_DWORD *)(DerivedStorage + 88);
  inAddress.mSelector = a2;
  *(_QWORD *)&inAddress.mScope = 707406378;
  return AudioObjectRemovePropertyListener(v4, &inAddress, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(DerivedStorage + 144));
}

void figFormatDescriptionFinalize(uint64_t a1)
{
  const void *v2;
  char *Value;
  void (*v4)(uint64_t);
  const void *v5;

  v2 = (const void *)*(unsigned int *)(a1 + 16);
  if ((_DWORD)v2 && (Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, v2)) != 0
    || (Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)0x67656E72)) != 0)
  {
    v4 = *(void (**)(uint64_t))(Value + 28);
    if (v4)
      v4(a1);
  }
  v5 = *(const void **)(a1 + 24);
  if (v5)
    CFRelease(v5);
}

void figAudioFormatDescriptionFinalize(const void *a1)
{
  void **DerivedStorage;
  const __CFAllocator *v3;
  const __CFAllocator *v4;
  const __CFAllocator *v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;

  DerivedStorage = (void **)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (DerivedStorage[6])
  {
    v3 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v3, DerivedStorage[6]);
  }
  if (DerivedStorage[8])
  {
    v4 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v4, DerivedStorage[8]);
  }
  if (DerivedStorage[11])
  {
    v5 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v5, DerivedStorage[11]);
  }
  if (DerivedStorage[13])
  {
    v6 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v6, DerivedStorage[13]);
  }
  if (DerivedStorage[15])
  {
    v7 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v7, DerivedStorage[15]);
  }
}

double FigFileByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v2 = *(_QWORD *)(DerivedStorage + 4136);
  if (v2)
  {
    FigSimpleMutexDestroy(v2);
    *(_QWORD *)(DerivedStorage + 4136) = 0;
    *(_BYTE *)(DerivedStorage + 4144) = 0;
  }
  if (*(_BYTE *)(DerivedStorage + 4220))
    FigFileForkClose(*(int **)(DerivedStorage + 8));
  if (*(_QWORD *)DerivedStorage)
    CFRelease(*(CFTypeRef *)DerivedStorage);
  return FigByteStreamStatsTeardownWorker(DerivedStorage + 4152);
}

uint64_t FigFilePathCreateFromParent(int a1, uint64_t a2, const char *a3, uint64_t *a4)
{
  const char *v8;
  size_t v9;
  const char *v10;
  char __str[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v8 = (const char *)(a2 + 16);
  v9 = strlen((const char *)(a2 + 16));
  if (v9 + strlen(a3) - 1022 <= 0xFFFFFFFFFFFFFBFFLL)
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  v10 = "/";
  if (v9)
  {
    if (*(_BYTE *)(v9 + a2 + 15) == 47)
      v10 = "";
  }
  snprintf(__str, 0x400uLL, "%s%s%s", v8, v10, a3);
  return FigFilePathCreateFromDarwinPath(a1, __str, a4);
}

uint64_t FigByteStreamCreateFromOpenFile(unsigned int *a1, uint64_t a2, CFTypeRef *a3)
{
  return FigByteStreamCreateFromOpenFileWithFlags(a1, a2, 0, a3);
}

uint64_t FigThreadRegisterAbortAction(uint64_t (*a1)(), _opaque_pthread_t *a2, _QWORD *a3)
{
  pthread_t Current;
  _opaque_pthread_t *specific;
  pthread_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  pthread_t *v13;
  uint64_t (*v14)();
  _QWORD *v15;

  Current = FigThreadGetCurrent();
  specific = (_opaque_pthread_t *)dispatch_get_specific(&kFigThreadDispatchQueueAbortabilityKey);
  if (a3)
  {
    v8 = specific;
    FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
    v9 = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
    if ((_DWORD)v9)
      return v9;
    if ((gAbortingNow & 1) != 0)
    {
      v10 = 4294954498;
    }
    else
    {
      v13 = (pthread_t *)gAbortActionList;
      if (gAbortActionList)
      {
        do
        {
          v14 = (uint64_t (*)())v13[2];
          if (v14 == a1 && v13[3] == a2)
          {
            if (*v13 == Current || v8 && v13[1] == v8)
            {
              v12 = 0;
              v11 = 4294949736;
              goto LABEL_21;
            }
          }
          else if (v14 == kSpecialAction_ThreadWasAbortedForTeardown
                 && !v13[3]
                 && (*v13 == Current || v8 && v13[1] == v8))
          {
            v11 = FigSignalErrorAt(4294949735, 0, 0, 0, 0, 0, 0);
            v12 = 1;
            goto LABEL_21;
          }
          v13 = (pthread_t *)v13[4];
        }
        while (v13);
      }
      v15 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040D3751E5BuLL);
      if (v15)
      {
        v11 = 0;
        v12 = 0;
        *v15 = Current;
        v15[1] = v8;
        v15[4] = 0;
        v15[2] = a1;
        v15[3] = a2;
        *(_QWORD *)qword_1ECDA85D8 = v15;
        qword_1ECDA85D8 = (uint64_t)(v15 + 4);
        *a3 = v15;
LABEL_21:
        FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
        if (a1)
        {
          if (v12)
            ((void (*)(_opaque_pthread_t *))a1)(a2);
        }
        return v11;
      }
      v10 = 4294954497;
    }
    v11 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    v12 = 0;
    goto LABEL_21;
  }
  return FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
}

uint64_t FigThreadGetGlobalNetworkBufferingRunloop()
{
  FigThreadRunOnce(&sNetworkThreadInitOnce, (void (*)(void))networkThreadInitOnce);
  return sNetworkRunLoop;
}

_QWORD *networkThreadInitOnce()
{
  return networkThreadCommonInit(CFSTR("com.apple.coremedia.networkbuffering"), (uint64_t)FigThreadGlobalNetworkBufferingRunloop, 7u, &sNetworkThread);
}

uint64_t FigThreadGlobalNetworkBufferingRunloop(uint64_t a1)
{
  FigThreadGlobalNetworkBufferingCommonSetupRunloop(a1, (CFRunLoopRef *)&sNetworkRunLoop, (__CFRunLoopTimer **)&sNetworkRunLoopTimer);
  CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E0C9B280], 1.79769313e308, 0);
  if (sNetworkRunLoopTimer)
  {
    CFRelease((CFTypeRef)sNetworkRunLoopTimer);
    sNetworkRunLoopTimer = 0;
  }
  return 0;
}

uint64_t FigThreadUnregisterAbortAction(uint64_t result)
{
  _QWORD *v1;
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (result)
  {
    v1 = (_QWORD *)result;
    FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
    result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
    if (!(_DWORD)result)
    {
      v2 = &gAbortActionList;
      v3 = &gAbortActionList;
      do
      {
        v4 = (_QWORD *)*v3;
        v3 = (uint64_t *)(*v3 + 32);
        if (v4)
          v5 = v4 == v1;
        else
          v5 = 1;
      }
      while (!v5);
      if (!v4)
        return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
      if ((gAbortingNow & 1) != 0)
      {
        v4[2] = 0;
        v4[3] = 0;
        return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
      }
      v6 = gAbortActionList;
      if ((_QWORD *)gAbortActionList == v4)
      {
        gAbortActionList = *v3;
        if (gAbortActionList)
          goto LABEL_16;
      }
      else
      {
        do
        {
          v7 = v6;
          v6 = *(_QWORD *)(v6 + 32);
        }
        while ((_QWORD *)v6 != v4);
        v8 = *v3;
        *(_QWORD *)(v7 + 32) = v8;
        v2 = (uint64_t *)(v7 + 32);
        if (v8)
          goto LABEL_16;
      }
      qword_1ECDA85D8 = (uint64_t)v2;
LABEL_16:
      free(v4);
      return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
    }
  }
  return result;
}

uint64_t FigDebugSettingGetKeyAsInteger(const __CFString *a1, CFIndex *a2)
{
  Boolean keyExistsAndHasValidFormat;

  keyExistsAndHasValidFormat = 0;
  *a2 = CFPreferencesGetAppIntegerValue(a1, CFSTR("com.apple.coremedia"), &keyExistsAndHasValidFormat);
  return keyExistsAndHasValidFormat;
}

uint64_t FigFileByteStreamWrite(uint64_t a1, size_t a2, off_t a3, void *a4, _QWORD *a5)
{
  uint64_t DerivedStorage;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v14 = 0;
  v10 = FigFileForkWriteWithIOPolicy(*(int **)(DerivedStorage + 8), *(_DWORD *)(DerivedStorage + 4216), a4, a2, a3, &v14);
  v11 = v10;
  if ((_DWORD)v10)
    FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  v12 = v14;
  if (a5)
    *a5 = v14;
  if (v12 == a2)
    return 0;
  else
    return v11;
}

uint64_t FigFilePathCreateFromChild(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v8;
  char v9[1024];
  uint64_t v10;

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v10 = *MEMORY[0x1E0C80C00];
  while (1)
  {
    v6 = *(unsigned __int8 *)(a2 + v3 + 16);
    if (v6 != 47)
      break;
    v5 = v4;
    v4 = a2 + v3 + 16;
LABEL_6:
    v9[v3++] = v6;
  }
  if (*(_BYTE *)(a2 + v3 + 16))
    goto LABEL_6;
  if (a2 + v3 + 15 == v4)
    v4 = v5;
  if (v4)
  {
    v9[v4 - (a2 + 16) + 1] = 0;
    if (v9[0])
      return FigFilePathCreateFromDarwinPath(a1, v9, a3);
    v8 = 4294967253;
  }
  else
  {
    v8 = 4294955096;
  }
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t figBridge_WalkAndConvertImageDescriptionExtensions(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, size_t *a7, size_t count, const void *a9)
{
  uint64_t v10;
  CFTypeRef *v14;
  size_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  CFIndex v22;
  int v23;
  unsigned int *v24;
  CFTypeRef v25;
  CFStringRef v26;
  int v27;
  CFTypeRef v28;
  CFNumberRef v29;
  uint64_t v30;
  const __CFAllocator *v31;
  uint64_t v32;
  uint64_t v33;
  UInt8 *v34;
  CFIndex v35;
  const __CFString *v36;
  CFTypeRef v37;
  CFNumberRef v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  int32x4_t v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  CFTypeRef v48;
  CFIndex v49;
  uint64_t v50;
  CFTypeRef v51;
  CFDataRef v52;
  CFTypeRef v53;
  const __CFAllocator *v54;
  unsigned int v55;
  CFTypeRef v56;
  CFNumberRef v57;
  CFTypeRef v58;
  CFTypeRef v59;
  uint64_t v60;
  unsigned int v61;
  CFTypeRef *v62;
  uint64_t v63;
  char v64;
  char v65;
  uint64_t v66;
  const void *v67;
  const void *v68;
  CFTypeRef v69;
  CFTypeRef v70;
  uint64_t v71;
  int v72;
  CFTypeRef v73;
  const void *v74;
  _BOOL4 v76;
  BOOL v77;
  CFTypeRef v78;
  _BOOL4 v79;
  unsigned int v80;
  unsigned int v81;
  CFStringRef StringForIntegerCodePoint;
  CFStringRef v83;
  int v84;
  CFStringRef v85;
  CFTypeRef v86;
  CFTypeRef v87;
  uint64_t v88;
  CFTypeRef v89;
  CFNumberRef v90;
  uint64_t v91;
  uint64_t v92;
  CFTypeRef *v93;
  uint64_t v94;
  const void **v95;
  CFTypeRef v96;
  CFTypeRef v97;
  uint64_t v98;
  CFTypeRef v99;
  CFTypeRef v100;
  uint64_t v101;
  CFTypeRef v102;
  uint64_t v103;
  CFTypeRef v104;
  CFTypeRef v105;
  uint64_t v106;
  uint64_t v107;
  CFDictionaryRef v108;
  const void *v109;
  CFTypeRef v110;
  CFTypeRef v111;
  void **v112;
  CFTypeRef v113;
  CFTypeRef v114;
  uint64_t v115;
  uint64_t v116;
  CFTypeRef v117;
  _QWORD *v118;
  _QWORD *v119;
  void *v120;
  void *v121;
  CFIndex v122;
  uint64_t v123;
  int *v124;
  _DWORD *v125;
  size_t v126;
  int v127;
  CFStringRef v128;
  uint64_t v129;
  int *v130;
  uint64_t v131;
  int v132;
  CFIndex v133;
  size_t v134;
  _DWORD *v135;
  CFArrayRef v136;
  CFDictionaryRef v137;
  uint64_t i;
  const void *v139;
  uint64_t j;
  const void *v141;
  CFTypeRef *v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  unsigned int v146;
  unsigned int v147;
  int v148;
  unsigned int v149;
  _BOOL4 v150;
  CFTypeRef v151;
  void *v152;
  CFTypeRef v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  CFTypeRef v158;
  const void *v159;
  CFTypeRef v160;
  CFTypeRef v161;
  CFTypeRef v162;
  CFTypeRef v163;
  const void *v164;
  CFTypeRef v165;
  CFTypeRef v166;
  CFTypeRef *v167;
  CFTypeRef *v168;
  const __CFAllocator *alloc;
  uint64_t v170;
  size_t v171;
  _QWORD *v172;
  const void *v173;
  const void **v176;
  uint64_t v178;
  uint64_t v179;
  double v180;
  double v181;
  double v182;
  double v183;
  _OWORD valuePtr[16];
  void *values[2];
  __int128 v186;
  __int128 v187;
  __int128 v188;
  uint64_t v189;

  v10 = a6;
  v189 = *MEMORY[0x1E0C80C00];
  v179 = 0;
  if (count)
  {
    v14 = (CFTypeRef *)malloc_type_calloc(count, 0x18uLL, 0x1060040D0FAAE32uLL);
    if (!v14)
      return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v14 = 0;
  }
  v171 = count;
  v172 = (_QWORD *)a4;
  if (a3 < 8)
  {
    v16 = 0;
LABEL_7:
    if (v172)
      *v172 = v179;
    if (a7)
    {
      v17 = 0;
      *a7 = v16;
      if (!v14)
        return v17;
    }
    else if (v16 == v171)
    {
      v17 = 0;
      v16 = v171;
      if (!v14)
        return v17;
    }
    else
    {
      strcpy((char *)valuePtr, "Image description data could have changed");
      v17 = 4294954584;
      v116 = 4294954584;
LABEL_271:
      FigSignalErrorAt(v116, 0, 0, 0, 0, 0, 0);
      figSoundBridge_ReportParsingFailureMessage((uint64_t)a9, (uint64_t)valuePtr);
      if (!v14)
        return v17;
    }
LABEL_319:
    if (v16)
    {
LABEL_320:
      v142 = v14 + 1;
      do
      {
        if (*v142)
          CFRelease(*v142);
        v142 += 3;
        --v16;
      }
      while (v16);
    }
LABEL_324:
    free(v14);
    return v17;
  }
  v16 = 0;
  v18 = 0;
  v170 = 0;
  v165 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v164 = (const void *)*MEMORY[0x1E0CA8CE8];
  v173 = (const void *)*MEMORY[0x1E0CA8CE0];
  v163 = (CFTypeRef)*MEMORY[0x1E0CA8DF8];
  v161 = (CFTypeRef)*MEMORY[0x1E0CA8D68];
  v166 = (CFTypeRef)*MEMORY[0x1E0CA8E98];
  v160 = (CFTypeRef)*MEMORY[0x1E0CA8EE8];
  v158 = (CFTypeRef)*MEMORY[0x1E0CA8D50];
  v159 = (const void *)*MEMORY[0x1E0C9AE40];
  v156 = *MEMORY[0x1E0CA8D40];
  v157 = *MEMORY[0x1E0CA8D60];
  v155 = *MEMORY[0x1E0CA8D48];
  v154 = *MEMORY[0x1E0CA8D58];
  v153 = (CFTypeRef)*MEMORY[0x1E0CA8E68];
  v152 = (void *)*MEMORY[0x1E0CA8E60];
  v162 = (CFTypeRef)*MEMORY[0x1E0CA8DC8];
  v151 = (CFTypeRef)*MEMORY[0x1E0CA8DD0];
  v178 = v10;
  v19 = a2;
  while (1)
  {
    v20 = v19 + v18;
    v21 = bswap32(*(_DWORD *)(v19 + v18));
    v22 = (v21 - 8);
    if (v21 < 8)
    {
LABEL_260:
      if (BYTE4(v170) && (_DWORD)v170)
      {
        if (a5)
        {
          v113 = CFRetain(v166);
          *(_QWORD *)(a5 + 8 * v179) = v113;
        }
        if (v10)
        {
          v114 = CFRetain((CFTypeRef)*MEMORY[0x1E0CA8ED8]);
          v115 = v179;
          *(_QWORD *)(v10 + 8 * v179) = v114;
        }
        else
        {
          v115 = v179;
        }
        v179 = v115 + 1;
      }
      if (!v16)
        goto LABEL_7;
      if (a5)
      {
        v117 = CFRetain(CFSTR("SampleDescriptionExtensionAtoms"));
        *(_QWORD *)(a5 + 8 * v179) = v117;
      }
      if (v10)
      {
        v118 = malloc_type_calloc(v16, 8uLL, 0x6004044C4A2DFuLL);
        v119 = malloc_type_calloc(v16, 8uLL, 0x6004044C4A2DFuLL);
        v120 = malloc_type_calloc(v16, 8uLL, 0x6004044C4A2DFuLL);
        v121 = v120;
        if (!v118 || !v119 || !v120)
        {
          v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          if (!v118)
            goto LABEL_309;
LABEL_304:
          for (i = 0; i != v16; ++i)
          {
            v139 = (const void *)v118[i];
            if (v139)
              CFRelease(v139);
          }
          free(v118);
LABEL_309:
          if (v119)
          {
            for (j = 0; j != v16; ++j)
            {
              v141 = (const void *)v119[j];
              if (v141)
                CFRelease(v141);
            }
            free(v119);
          }
          if (v121)
            free(v121);
          if (!(_DWORD)v17)
            goto LABEL_7;
LABEL_318:
          if (!v14)
            return v17;
          goto LABEL_319;
        }
        v176 = (const void **)v119;
        v122 = 0;
        v123 = 0;
        v124 = (int *)(v14 + 3);
        v125 = v14 + 2;
        v126 = v16;
        v168 = v14;
        do
        {
          if (!LODWORD(v14[3 * v123 + 2]))
          {
            v127 = (int)v14[3 * v123];
            LOBYTE(valuePtr[0]) = 4;
            BYTE1(valuePtr[0]) = HIBYTE(v127);
            BYTE2(valuePtr[0]) = BYTE2(v127);
            BYTE3(valuePtr[0]) = BYTE1(v127);
            BYTE4(valuePtr[0]) = v127;
            v128 = CFStringCreateWithPascalString(a1, (ConstStr255Param)valuePtr, 0);
            v118[v122] = v128;
            if (!v128)
            {
              v129 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              if ((_DWORD)v129)
              {
                v14 = v168;
                v17 = v129;
                v119 = v176;
                goto LABEL_304;
              }
            }
            v130 = v124;
            v131 = v123;
            do
            {
              if (++v131 >= v16)
              {
                v14 = v168;
                v176[v122] = CFRetain(v168[3 * v123 + 1]);
                goto LABEL_296;
              }
              v132 = *v130;
              v130 += 6;
            }
            while (v127 != v132);
            v133 = 0;
            v134 = v126;
            v135 = v125;
            do
            {
              if (v127 == *(v135 - 4))
              {
                *((_QWORD *)v121 + v133++) = *((_QWORD *)v135 - 1);
                *v135 = 1;
              }
              v135 += 6;
              --v134;
            }
            while (v134);
            v136 = CFArrayCreate(a1, (const void **)v121, v133, MEMORY[0x1E0C9B378]);
            v176[v122] = v136;
            v14 = v168;
            if (!v136)
            {
              v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              v119 = v176;
              goto LABEL_304;
            }
LABEL_296:
            ++v122;
          }
          ++v123;
          v124 += 6;
          v125 += 6;
          --v126;
        }
        while (v123 != v16);
        v119 = v176;
        v137 = CFDictionaryCreate(a1, (const void **)v118, v176, v122, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(v178 + 8 * v179) = v137;
        if (v137)
          v17 = 0;
        else
          v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        v17 = 0;
        v118 = 0;
        v119 = 0;
        v121 = 0;
      }
      ++v179;
      if (!v118)
        goto LABEL_309;
      goto LABEL_304;
    }
    v18 += v21;
    if (v18 > a3)
    {
      strcpy((char *)valuePtr, "Image description extension size exceeds image description size");
      v17 = 4294954582;
      v116 = 4294954582;
      goto LABEL_271;
    }
    v23 = bswap32(*(_DWORD *)(v20 + 4));
    v24 = (unsigned int *)(v20 + 8);
    if (v23 > 1718773092)
      break;
    if (v23 > 1667789420)
    {
      if (v23 <= 1668050024)
      {
        if (v23 == 1667789421)
        {
          if (v21 != 10)
            goto LABEL_129;
          v63 = 0;
          v64 = 1;
          v10 = v178;
          do
          {
            v65 = v64;
            v66 = figConvertChromaLocationIndexToString(*((unsigned __int8 *)v24 + v63));
            if (v66)
            {
              v67 = (const void *)v66;
              if (a5)
              {
                if ((v65 & 1) != 0)
                  v68 = v164;
                else
                  v68 = v173;
                v69 = CFRetain(v68);
                *(_QWORD *)(a5 + 8 * v179) = v69;
              }
              if (v178)
              {
                v70 = CFRetain(v67);
                v71 = v179;
                *(_QWORD *)(v178 + 8 * v179) = v70;
              }
              else
              {
                v71 = v179;
              }
              v179 = v71 + 1;
            }
            v64 = 0;
            v63 = 1;
          }
          while ((v65 & 1) != 0);
LABEL_218:
          v19 = a2;
          goto LABEL_259;
        }
        if (v23 != 1668047216)
          goto LABEL_174;
        if (v21 == 40
          && (v39 = *(_QWORD *)(v20 + 8),
              v40 = *(_DWORD *)(v20 + 20),
              v41 = *(_DWORD *)(v20 + 28),
              v42.i64[0] = v39,
              v42.i64[1] = __PAIR64__(v41, v40),
              (vmaxv_u16((uint16x4_t)vmovn_s32(vceqzq_s32(v42))) & 1) == 0)
          && (v43 = *(_DWORD *)(v20 + 16)) != 0
          && (v44 = *(_DWORD *)(v20 + 36)) != 0)
        {
          v45 = HIDWORD(v39);
          v46 = bswap32(*(_DWORD *)(v20 + 24));
          v47 = bswap32(*(_DWORD *)(v20 + 32));
          v143 = bswap32(HIDWORD(v39));
          v144 = bswap32(v39);
          v145 = bswap32(v40);
          v146 = bswap32(v43);
          v182 = (double)v146 / (double)v145;
          v183 = (double)v144 / (double)v143;
          v147 = bswap32(v41);
          v148 = v46;
          v149 = bswap32(v44);
          v180 = (double)v47 / (double)v149;
          v181 = (double)v46 / (double)v147;
          if (a5)
          {
            v48 = CFRetain(v158);
            *(_QWORD *)(a5 + 8 * v179) = v48;
          }
          memset(valuePtr, 0, 64);
          *(_OWORD *)values = 0u;
          v186 = 0u;
          v187 = 0u;
          v188 = 0u;
          if (v178)
          {
            *(_QWORD *)&valuePtr[0] = v157;
            values[0] = CFNumberCreate(alloc, kCFNumberDoubleType, &v183);
            *((_QWORD *)&valuePtr[0] + 1) = v156;
            values[1] = CFNumberCreate(alloc, kCFNumberDoubleType, &v182);
            *(_QWORD *)&valuePtr[1] = v155;
            *(_QWORD *)&v186 = CFNumberCreate(alloc, kCFNumberDoubleType, &v181);
            *((_QWORD *)&valuePtr[1] + 1) = v154;
            *((_QWORD *)&v186 + 1) = CFNumberCreate(alloc, kCFNumberDoubleType, &v180);
            if (v45 == 0x1000000)
            {
              v49 = 4;
            }
            else
            {
              *(_QWORD *)&valuePtr[2] = CFSTR("WidthAsRational");
              *(_QWORD *)&v187 = figBridge_CFArrayCreateWithTwoIntegers(a1, v144, v143);
              v49 = 5;
            }
            if (v40 != 0x1000000)
            {
              *((_QWORD *)valuePtr + v49) = CFSTR("HeightAsRational");
              values[v49++] = figBridge_CFArrayCreateWithTwoIntegers(a1, v146, v145);
            }
            v10 = v178;
            if (v41 != 0x1000000)
            {
              *((_QWORD *)valuePtr + v49) = CFSTR("HorizontalOffsetAsRational");
              values[v49++] = figBridge_CFArrayCreateWithTwoIntegers(a1, v148, v147);
            }
            if (v44 != 0x1000000)
            {
              *((_QWORD *)valuePtr + v49) = CFSTR("VerticalOffsetAsRational");
              values[v49++] = figBridge_CFArrayCreateWithTwoIntegers(a1, v47, v149);
            }
            v107 = 0;
            do
            {
              if (!values[v107])
              {
                v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                goto LABEL_252;
              }
              ++v107;
            }
            while (v49 != v107);
            v108 = CFDictionaryCreate(a1, (const void **)valuePtr, (const void **)values, v49, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            *(_QWORD *)(v178 + 8 * v179) = v108;
            if (v108)
              v17 = 0;
            else
              v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          }
          else
          {
            v17 = 0;
            v49 = 0;
            v10 = 0;
          }
          ++v179;
LABEL_252:
          if ((int)v49 >= 1)
          {
            v112 = values;
            do
            {
              if (*v112)
                CFRelease(*v112);
              ++v112;
              --v49;
            }
            while (v49);
          }
        }
        else
        {
          FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
          v17 = 0;
          v10 = v178;
        }
        goto LABEL_257;
      }
      if (v23 == 1668050025)
      {
        v31 = a1;
        v10 = v178;
        v32 = a5;
        v33 = v178;
        v34 = (UInt8 *)(v20 + 8);
        v35 = (v21 - 8);
        v36 = CFSTR("ContentLightLevelInfo");
        goto LABEL_120;
      }
      if (v23 == 1668246642)
      {
        if (v22 < 5)
          v55 = 0;
        else
          v55 = *v24;
        v10 = v178;
        v76 = v21 == 19 && v55 == 2020369262;
        v77 = v55 == 1668047726 && (_DWORD)v22 == 10;
        if (v77 || v76)
        {
          v167 = v14;
          v79 = v55 != 2020369262 || *(char *)(v20 + 18) >= 0;
          v150 = v79;
          v80 = *(unsigned __int16 *)(v20 + 14);
          v81 = bswap32(*(unsigned __int16 *)(v20 + 16)) >> 16;
          StringForIntegerCodePoint = CVColorPrimariesGetStringForIntegerCodePoint(bswap32(*(unsigned __int16 *)(v20 + 12)) >> 16);
          v83 = CVTransferFunctionGetStringForIntegerCodePoint(__rev16(v80));
          v84 = HIDWORD(v170);
          if (v80 == 512)
            v84 = 1;
          HIDWORD(v170) = v84;
          v85 = CVYCbCrMatrixGetStringForIntegerCodePoint(v81);
          v14 = v167;
          v10 = v178;
          if (StringForIntegerCodePoint)
          {
            if (a5)
            {
              v86 = CFRetain(v161);
              *(_QWORD *)(a5 + 8 * v179) = v86;
            }
            if (v178)
            {
              v87 = CFRetain(StringForIntegerCodePoint);
              v88 = v179;
              *(_QWORD *)(v178 + 8 * v179) = v87;
            }
            else
            {
              v88 = v179;
            }
            v179 = v88 + 1;
          }
          if (v83)
          {
            if (a5)
            {
              v96 = CFRetain(v166);
              *(_QWORD *)(a5 + 8 * v179) = v96;
            }
            if (v178)
            {
              v97 = CFRetain(v83);
              v98 = v179;
              *(_QWORD *)(v178 + 8 * v179) = v97;
            }
            else
            {
              v98 = v179;
            }
            v179 = v98 + 1;
          }
          if (v85)
          {
            if (a5)
            {
              v99 = CFRetain(v160);
              *(_QWORD *)(a5 + 8 * v179) = v99;
            }
            if (v178)
            {
              v100 = CFRetain(v85);
              v101 = v179;
              *(_QWORD *)(v178 + 8 * v179) = v100;
            }
            else
            {
              v101 = v179;
            }
            v179 = v101 + 1;
          }
          if (v55 == 2020369262)
          {
            v19 = a2;
            if (a5)
            {
              v102 = CFRetain(CFSTR("FullRangeVideo"));
              *(_QWORD *)(a5 + 8 * v179) = v102;
            }
            if (v178)
            {
              if (v150)
                v74 = v159;
              else
                v74 = v165;
LABEL_216:
              v74 = CFRetain(v74);
LABEL_217:
              v103 = v179;
              *(_QWORD *)(v10 + 8 * v179) = v74;
LABEL_220:
              v179 = v103 + 1;
              goto LABEL_259;
            }
LABEL_219:
            v103 = v179;
            goto LABEL_220;
          }
          goto LABEL_218;
        }
        if (v55 == 1718579824 || v55 == 1128483186)
        {
          if (a5)
          {
            v78 = CFRetain(CFSTR("CVImageBufferICCProfile"));
            *(_QWORD *)(a5 + 8 * v179) = v78;
          }
          if (!v178)
            goto LABEL_152;
          v52 = CFDataCreate(a1, (const UInt8 *)(v20 + 12), v22 - 4);
          goto LABEL_151;
        }
        goto LABEL_155;
      }
      if (v23 != 1718183276)
        goto LABEL_174;
      if (v21 != 10)
        goto LABEL_129;
      LOBYTE(valuePtr[0]) = *(_BYTE *)(v20 + 8);
      v27 = *(unsigned __int8 *)(v20 + 9);
      v10 = v178;
      if (a5)
      {
        v28 = CFRetain(v162);
        *(_QWORD *)(a5 + 8 * v179) = v28;
      }
      if (v178
        && (v29 = CFNumberCreate(alloc, kCFNumberSInt8Type, valuePtr), (*(_QWORD *)(v178 + 8 * v179) = v29) == 0))
      {
        v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        v17 = 0;
      }
      v94 = ++v179;
      if (LOBYTE(valuePtr[0]) >= 2u)
      {
        if (v27 > 8)
        {
          if (v27 == 9)
          {
            v95 = (const void **)MEMORY[0x1E0CA8DD8];
          }
          else
          {
            if (v27 != 14)
              goto LABEL_257;
            v95 = (const void **)MEMORY[0x1E0CA8DE0];
          }
        }
        else
        {
          if (v27 != 1)
          {
            if (v27 == 6)
            {
              v95 = (const void **)MEMORY[0x1E0CA8DE8];
              goto LABEL_244;
            }
            goto LABEL_257;
          }
          v95 = (const void **)MEMORY[0x1E0CA8DF0];
        }
LABEL_244:
        v109 = *v95;
        if (*v95)
        {
          if (a5)
          {
            v110 = CFRetain(v151);
            v94 = v179;
            *(_QWORD *)(a5 + 8 * v179) = v110;
          }
          if (v178)
          {
            v111 = CFRetain(v109);
            v94 = v179;
            *(_QWORD *)(v178 + 8 * v179) = v111;
          }
          v179 = v94 + 1;
        }
      }
LABEL_257:
      v19 = a2;
      goto LABEL_258;
    }
    if (v23 <= 1635017575)
    {
      if (v23 != 1634495855)
      {
        if (v23 != 1634563685)
          goto LABEL_174;
        v31 = a1;
        v10 = v178;
        v32 = a5;
        v33 = v178;
        v34 = (UInt8 *)(v20 + 8);
        v35 = (v21 - 8);
        v36 = CFSTR("AmbientViewingEnvironment");
        goto LABEL_120;
      }
      if (v21 != 12)
        goto LABEL_131;
      if (v178)
      {
        v61 = bswap32(*v24);
        if (v61 != 256)
        {
          if (v61 == 258)
          {
            v62 = (CFTypeRef *)&kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;
            goto LABEL_222;
          }
LABEL_131:
          FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
          if (v14)
            goto LABEL_175;
          goto LABEL_177;
        }
        v62 = (CFTypeRef *)&kCMFormatDescriptionAlphaChannelMode_StraightAlpha;
LABEL_222:
        v104 = CFRetain(*v62);
        *(_QWORD *)(v178 + 8 * v179) = v104;
      }
      if (a5)
      {
        v105 = CFRetain(CFSTR("AlphaChannelMode"));
        v106 = v179;
        *(_QWORD *)(a5 + 8 * v179) = v105;
      }
      else
      {
        v106 = v179;
      }
      v179 = v106 + 1;
      if (v14)
        goto LABEL_175;
      goto LABEL_177;
    }
    if (v23 == 1635017576)
    {
      if (v21 != 9)
        goto LABEL_129;
      v72 = *(unsigned __int8 *)v24;
      v10 = v178;
      if (*(_BYTE *)v24)
      {
        if (a5)
        {
          v73 = CFRetain(CFSTR("AlternativeTransferCharacteristics"));
          *(_QWORD *)(a5 + 8 * v179) = v73;
        }
        if (v178)
        {
          v74 = CVTransferFunctionGetStringForIntegerCodePoint(v72);
          if (v74)
            goto LABEL_216;
          goto LABEL_217;
        }
        goto LABEL_219;
      }
    }
    else
    {
      if (v23 != 1667460214)
        goto LABEL_174;
      v10 = v178;
      figBridge_WrapPayloadAsCFData(a1, a5, v178, &v179, (UInt8 *)(v20 + 8), v22, CFSTR("ContentColorVolume"));
    }
LABEL_259:
    if (v18 + 8 > a3)
      goto LABEL_260;
  }
  if (v23 <= 1835295605)
  {
    if (v23 > 1751543669)
    {
      if (v23 != 1751543670)
      {
        if (v23 == 1785751363)
        {
          if (v21 != 8)
          {
            v17 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
            strcpy((char *)valuePtr, "Image description - unsupported extension 'jpgC'");
            FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
            figSoundBridge_ReportParsingFailureMessage((uint64_t)a9, (uint64_t)valuePtr);
            v10 = v178;
            goto LABEL_258;
          }
          goto LABEL_178;
        }
        if (v23 == 1819240307)
        {
          if (v21 != 8)
          {
            v10 = v178;
            if (a5)
            {
              v25 = CFRetain(CFSTR("LogTransferFunction"));
              *(_QWORD *)(a5 + 8 * v179) = v25;
            }
            if (v178)
            {
              v26 = CFStringCreateWithBytes(alloc, (const UInt8 *)(v20 + 8), v22, 0x600u, 0);
              v17 = 0;
              *(_QWORD *)(v178 + 8 * v179) = v26;
              if (!v26)
                goto LABEL_156;
LABEL_181:
              ++v179;
              goto LABEL_258;
            }
LABEL_94:
            v17 = 0;
            goto LABEL_181;
          }
LABEL_129:
          FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
LABEL_178:
          v10 = v178;
          goto LABEL_259;
        }
LABEL_174:
        if (v14)
        {
LABEL_175:
          if (v16 >= v171)
          {
            strcpy((char *)valuePtr, "Image description data could have changed");
            v17 = 4294954584;
            FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
            figSoundBridge_ReportParsingFailureMessage((uint64_t)a9, (uint64_t)valuePtr);
            if (v16)
              goto LABEL_320;
            goto LABEL_324;
          }
          v93 = &v14[3 * v16];
          *(_DWORD *)v93 = v23;
          v93[1] = CFDataCreate(a1, (const UInt8 *)(v20 + 8), v22);
          *((_DWORD *)v93 + 4) = 0;
          v19 = a2;
        }
LABEL_177:
        ++v16;
        goto LABEL_178;
      }
      if (v21 != 12)
        goto LABEL_129;
      LODWORD(valuePtr[0]) = bswap32(*v24);
      v10 = v178;
      if (a5)
      {
        v53 = CFRetain(CFSTR("HorizontalFieldOfView"));
        *(_QWORD *)(a5 + 8 * v179) = v53;
      }
      if (!v178)
        goto LABEL_94;
      v54 = alloc;
LABEL_93:
      v57 = CFNumberCreate(v54, kCFNumberSInt32Type, valuePtr);
      *(_QWORD *)(v10 + 8 * v179) = v57;
      if (!v57)
      {
LABEL_156:
        v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        goto LABEL_181;
      }
      goto LABEL_94;
    }
    if (v23 == 1718773093)
      goto LABEL_178;
    if (v23 != 1734438241)
      goto LABEL_174;
    if (v21 != 12)
      goto LABEL_129;
    *(double *)valuePtr = (double)(int)bswap32(*v24) * 0.0000152587891;
    v10 = v178;
    if (a5)
    {
      v37 = CFRetain(v163);
      *(_QWORD *)(a5 + 8 * v179) = v37;
    }
    if (v178 && (v38 = CFNumberCreate(0, kCFNumberDoubleType, valuePtr), (*(_QWORD *)(v178 + 8 * v179) = v38) == 0))
      v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    else
      v17 = 0;
    ++v179;
    LODWORD(v170) = 1;
LABEL_258:
    if ((_DWORD)v17)
      goto LABEL_318;
    goto LABEL_259;
  }
  if (v23 <= 1919907681)
  {
    if (v23 != 1835295606)
    {
      if (v23 != 1885434736)
        goto LABEL_174;
      if (v21 != 16)
        goto LABEL_129;
      v50 = bswap32(*(_DWORD *)(v20 + 8));
      v10 = v178;
      if ((int)v50 >= 1 && (int)bswap32(*(_DWORD *)(v20 + 12)) > 0)
      {
        if (a5)
        {
          v51 = CFRetain(v153);
          *(_QWORD *)(a5 + 8 * v179) = v51;
        }
        if (!v178)
          goto LABEL_152;
        v52 = figBridge_CFDictionaryCreateWithNumbers(a1, a2, v152, a4, a5, a6, (uint64_t)a7, count, v50);
LABEL_151:
        *(_QWORD *)(v10 + 8 * v179) = v52;
        if (!v52)
        {
          v17 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          goto LABEL_180;
        }
LABEL_152:
        v17 = 0;
LABEL_180:
        v19 = a2;
        goto LABEL_181;
      }
LABEL_155:
      FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
      goto LABEL_218;
    }
    v31 = a1;
    v10 = v178;
    v32 = a5;
    v33 = v178;
    v34 = (UInt8 *)(v20 + 8);
    v35 = (v21 - 8);
    v36 = CFSTR("MasteringDisplayColorVolume");
LABEL_120:
    v30 = figBridge_WrapPayloadAsCFData(v31, v32, v33, &v179, v34, v35, v36);
    goto LABEL_121;
  }
  if (v23 == 1919907682)
  {
    if (v21 != 12)
      goto LABEL_129;
    LODWORD(valuePtr[0]) = bswap32(*v24);
    v10 = v178;
    if (a5)
    {
      v56 = CFRetain(CFSTR("CVBytesPerRow"));
      *(_QWORD *)(a5 + 8 * v179) = v56;
    }
    if (!v178)
      goto LABEL_94;
    v54 = 0;
    goto LABEL_93;
  }
  if (v23 != 1936289382)
  {
    if (v23 != 1986361461)
      goto LABEL_174;
    v10 = v178;
    v30 = VEXUBridge_ConvertVideoExtendedUsageDescriptionExtensions((uint64_t)a1, a5, v178, &v179, v20 + 8, v22, a9);
LABEL_121:
    v17 = v30;
    goto LABEL_258;
  }
  if (!FigBridgeGetCommonEncryptionScheme(v20 + 8, v22))
    goto LABEL_174;
  LODWORD(valuePtr[0]) = 0;
  if (a5)
  {
    v58 = CFRetain(CFSTR("CommonEncryptionProtected"));
    *(_QWORD *)(a5 + 8 * v179) = v58;
  }
  if (v178)
  {
    v59 = CFRetain(v165);
    v60 = v179;
    *(_QWORD *)(v178 + 8 * v179) = v59;
  }
  else
  {
    v60 = v179;
  }
  v179 = v60 + 1;
  LODWORD(valuePtr[0]) = FigBridgeGetOriginalFormatFromSinf(v20 + 8, v22);
  v19 = a2;
  if (LODWORD(valuePtr[0]))
  {
    if (a5)
    {
      v89 = CFRetain(CFSTR("CommonEncryptionOriginalFormat"));
      *(_QWORD *)(a5 + 8 * v179) = v89;
    }
    if (v178)
    {
      v90 = CFNumberCreate(alloc, kCFNumberSInt32Type, valuePtr);
      v91 = v179;
      *(_QWORD *)(v178 + 8 * v179) = v90;
    }
    else
    {
      v91 = v179;
    }
    v19 = a2;
    v179 = v91 + 1;
  }
  v92 = FigBridgeExtractCommonEncryptionTrackEncryptionExtension(a1, a5, v178, &v179, v20 + 8, v22);
  if (!(_DWORD)v92)
    goto LABEL_174;
  v17 = v92;
  if (v14)
    goto LABEL_319;
  return v17;
}

void *figBridge_ConvertMPEG2ProfileCodecTypesToProfileExtensions(void *result, _DWORD *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  int valuePtr;

  v9 = 0;
  valuePtr = (int)result;
  while (figBridge_ConvertMPEG2ProfileCodecTypesToProfileExtensions_mpeg2ConformingVideoCodecTypes[v9] != (_DWORD)result)
  {
    if (++v9 == 39)
      return result;
  }
  if (a4)
  {
    result = (void *)CFRetain(CFSTR("ConformsToMPEG2VideoProfile"));
    *(_QWORD *)(a4 + 8 * *a3) = result;
  }
  if (a5)
  {
    result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
    v10 = *a3;
    *(_QWORD *)(a5 + 8 * *a3) = result;
  }
  else
  {
    v10 = *a3;
  }
  *a3 = v10 + 1;
  if (a2)
    *a2 = 1836069494;
  return result;
}

uint64_t FigH264Bridge_GetSPSFromAVCC(uint64_t a1, unint64_t a2, int a3, _QWORD *a4, _QWORD *a5)
{
  int v5;
  unsigned int v6;
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  BOOL v12;
  uint64_t v14;

  if (a2 >= 7)
  {
    v5 = *(_BYTE *)(a1 + 5) & 0x1F;
    if ((*(_BYTE *)(a1 + 5) & 0x1F) == 0)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    v6 = 6;
    while (1)
    {
      v7 = v6 + 2;
      if (v7 > a2)
        break;
      v8 = *(unsigned __int16 *)(a1 + v6);
      v9 = __rev16(v8);
      v10 = v7 + (bswap32(v8) >> 16);
      if (v9 >= 2)
      {
        v11 = v10 >= a2;
        v12 = v10 == a2;
      }
      else
      {
        v11 = 1;
        v12 = 0;
      }
      if (!v12 && v11)
        break;
      if (!a3)
      {
        v14 = 0;
        *a4 = a1 + v6 + 2;
        *a5 = v9;
        return v14;
      }
      --a3;
      v6 = v10;
      if (!--v5)
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    }
  }
  return 4294954582;
}

uint64_t FigH264Bridge_GetSPS_VUI_ChromaLocation(const UInt8 *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v8;
  const __CFData *v9;
  unsigned int v10;
  uint64_t v11;
  CFDataRef theData;
  const UInt8 *v14;
  uint64_t v15;
  const UInt8 *v16;
  uint64_t v17;
  _OWORD v18[22];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  Length = a2;
  BytePtr = a1;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  memset(v18, 0, sizeof(v18));
  v15 = 0;
  v16 = 0;
  v17 = 0;
  theData = 0;
  v8 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v8)
    return v8;
  v9 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v9);
  }
  v14 = BytePtr;
  LODWORD(v15) = Length;
  v16 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v17) = 0;
      __memcpy_chk();
      v10 = v17;
    }
    else
    {
      v10 = 0;
    }
  }
  else
  {
    v10 = *(_DWORD *)BytePtr;
  }
  LODWORD(v17) = bswap32(v10);
  BYTE4(v17) = 0;
  v11 = PullParamSetSPS((uint64_t)&v14, (char *)v18);
  if (v9)
    CFRelease(v9);
  if (!(_DWORD)v11)
  {
    v11 = 4294954584;
    if (HIDWORD(v19))
    {
      if (DWORD1(v23))
      {
        v11 = 0;
        *a3 = DWORD2(v23);
        *a4 = HIDWORD(v23);
      }
    }
  }
  return v11;
}

uint64_t RemoveEmulation3Byte(const UInt8 *a1, unint64_t a2, __CFData **a3)
{
  unint64_t v6;
  unint64_t v7;
  __CFData *v8;
  int v9;
  unint64_t i;
  CFIndex v11;
  const UInt8 *v12;
  __CFData *Mutable;
  uint64_t result;

  if (a2 < 3)
  {
    v8 = 0;
LABEL_15:
    if ((((_WORD)a2 + (_WORD)a1 + 3) & 0xFFC) == 0)
    {
      Mutable = CFDataCreateMutable(0, a2 + 4);
      v8 = Mutable;
      v12 = a1;
      v11 = a2;
LABEL_17:
      CFDataAppendBytes(Mutable, v12, v11);
    }
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    for (i = 2; i < a2; i += 3)
    {
      if (a1[v7] || *(_WORD *)&a1[v7 + 1] != 768)
      {
        i = v7;
      }
      else
      {
        if (!v9)
        {
          v8 = CFDataCreateMutable(0, a2 + 3);
          if (!v8)
          {
            result = FigSignalErrorAt(12, 0, 0, 0, 0, 0, 0);
            goto LABEL_19;
          }
          v9 = 1;
        }
        CFDataAppendBytes(v8, &a1[v6], i - v6);
        v6 = v7 + 3;
      }
      v7 = i + 1;
    }
    if (!v9)
      goto LABEL_15;
    v11 = a2 - v6;
    if (a2 != v6)
    {
      v12 = &a1[v6];
      Mutable = v8;
      goto LABEL_17;
    }
  }
  result = 0;
LABEL_19:
  *a3 = v8;
  return result;
}

uint64_t PullParamSetSPS(uint64_t a1, char *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  unsigned int *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  unsigned int v65;
  uint64_t v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int32x4_t v71;
  int16x8_t v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  uint64_t v82;
  int v83;
  int v84;
  int v85;
  int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  unsigned int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  unsigned int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  unsigned int v114;
  uint64_t v115;
  int v116;
  int v117;
  int v118;
  int v119;
  unsigned int v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  unsigned int v139;
  unsigned int v140;
  int v141;
  unsigned int v142;
  int v143;
  int v144;
  uint64_t v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  unsigned int v151;
  unsigned int v152;
  unsigned int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  unsigned int v159;
  unsigned int v160;
  unsigned int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  unsigned int v166;
  unsigned int v167;
  int v168;
  unsigned int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  unsigned int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  unsigned int v179;
  unsigned int v180;
  unsigned int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  uint64_t v186;
  int v187;
  int v188;
  int v189;
  int v190;
  unsigned int v191;
  unsigned int v192;
  unsigned int v193;
  int v194;
  int v195;
  int v196;
  int v197;
  unsigned int v198;
  unsigned int v199;
  unsigned int v200;
  int v201;
  int v202;
  int v203;
  int v204;
  unsigned int v205;
  uint64_t v206;
  int v207;
  int v208;
  int v209;
  int v210;
  unsigned int v211;
  uint64_t v212;
  int v213;
  int v214;
  int v215;
  int v216;
  uint64_t v217;
  int v218;
  int v219;
  int v220;
  int v221;
  unsigned int v222;
  uint64_t v223;
  int v224;
  int v225;
  int v226;
  int v227;
  unsigned int v228;
  unsigned int v229;
  unsigned int v230;
  int v231;
  int v232;
  int v233;
  int v234;
  unsigned int v235;
  unsigned int v236;
  unsigned int v237;
  int v238;
  int v239;
  int v240;
  int v241;
  unsigned int v242;
  unsigned int v243;
  unsigned int v244;
  int v245;
  int v246;
  int v247;
  int v248;
  unsigned int v249;
  unsigned int v250;
  unsigned int v251;
  int v252;
  int v253;
  int v254;
  int v255;
  unsigned int v256;
  int v257;
  int v258;
  int v259;
  int v260;
  unsigned int v261;
  unsigned int v263;

  v263 = 0;
  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 24);
  v6 = *(unsigned __int8 *)(a1 + 28);
  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(_QWORD *)a1;
  bzero(a2, 0x218uLL);
  LODWORD(v9) = v8;
  v10 = v7;
  v11 = (v6 + 1) & 7;
  v12 = (unsigned int *)(v4 + ((unint64_t)(v6 + 1) >> 3));
  v13 = v8 + v7;
  v14 = v8 + v7 - (_DWORD)v12;
  if (v14 < 4)
  {
    if (v14 < 1)
    {
      v15 = v11 | v14;
      if (v15)
      {
        LOBYTE(v17) = v11;
        goto LABEL_476;
      }
    }
    else
    {
      v16 = *(unsigned __int8 *)v12;
      if (v14 == 1)
      {
        v15 = v16 << 24;
      }
      else
      {
        v18 = (v16 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v14 != 2)
          v18 |= *((unsigned __int8 *)v12 + 2);
        v15 = v18 << 8;
      }
    }
  }
  else
  {
    v15 = bswap32(*v12);
  }
  v19 = (v11 + 2) & 7;
  v12 = (unsigned int *)((char *)v12 + ((v11 + 2) >> 3));
  v20 = v13 - (_DWORD)v12;
  if (v13 - (int)v12 < 4)
  {
    if (v20 < 1)
    {
      v21 = v19 | v20;
      if (v21)
      {
        LOBYTE(v17) = (v11 + 2) & 7;
        goto LABEL_476;
      }
    }
    else
    {
      v22 = *(unsigned __int8 *)v12;
      if (v20 == 1)
      {
        v21 = v22 << 24;
      }
      else
      {
        v23 = (v22 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v20 != 2)
          v23 |= *((unsigned __int8 *)v12 + 2);
        v21 = v23 << 8;
      }
    }
  }
  else
  {
    v21 = bswap32(*v12);
  }
  v17 = (v19 + 5) & 7;
  v12 = (unsigned int *)((char *)v12 + ((v19 + 5) >> 3));
  v24 = v13 - (_DWORD)v12;
  if (v13 - (int)v12 < 4)
  {
    if (v24 < 1)
    {
      v25 = v17 | v24;
      if (v25)
        goto LABEL_476;
      if (v5 < 0)
        goto LABEL_487;
    }
    else
    {
      v26 = *(unsigned __int8 *)v12;
      if (v24 == 1)
      {
        v25 = v26 << 24;
        if (v5 < 0)
          goto LABEL_487;
      }
      else
      {
        v33 = (v26 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v24 != 2)
          v33 |= *((unsigned __int8 *)v12 + 2);
        v25 = v33 << 8;
        if (v5 < 0)
          goto LABEL_487;
      }
    }
  }
  else
  {
    v25 = bswap32(*v12);
    if (v5 < 0)
      goto LABEL_487;
  }
  if (!((v15 << v11) >> 30) || (v21 << v19) >> 27 != 7)
    goto LABEL_487;
  v27 = v25 << v17;
  v28 = (v25 << v17) >> 24;
  *(_DWORD *)a2 = v28;
  v29 = (unsigned int *)((char *)v12 + 1);
  v30 = v13 - ((_DWORD)v12 + 1);
  if (v30 < 4)
  {
    if (v30 < 1)
    {
      v31 = v17 | v30;
      if (v31)
        goto LABEL_94;
    }
    else
    {
      v32 = *(unsigned __int8 *)v29;
      if (v30 == 1)
      {
        v31 = v32 << 24;
      }
      else
      {
        v34 = (v32 << 16) | (*((unsigned __int8 *)v12 + 2) << 8);
        if (v30 != 2)
          v34 |= *((unsigned __int8 *)v12 + 3);
        v31 = v34 << 8;
      }
    }
  }
  else
  {
    v31 = bswap32(*v29);
  }
  *((_DWORD *)a2 + 2) = (v31 << v17) >> 31;
  v35 = (v17 + 1) >> 3;
  v17 = (v17 + 1) & 7;
  v12 = (unsigned int *)((char *)v29 + v35);
  v36 = v13 - ((_DWORD)v29 + v35);
  if (v36 < 4)
  {
    if (v36 < 1)
    {
      v37 = v17 | v36;
      if (v37)
        goto LABEL_476;
    }
    else
    {
      v38 = *(unsigned __int8 *)v12;
      if (v36 == 1)
      {
        v37 = v38 << 24;
      }
      else
      {
        v39 = (v38 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v36 != 2)
          v39 |= *((unsigned __int8 *)v12 + 2);
        v37 = v39 << 8;
      }
    }
  }
  else
  {
    v37 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 3) = (v37 << v17) >> 31;
  v40 = (v17 + 1) >> 3;
  v17 = (v17 + 1) & 7;
  v12 = (unsigned int *)((char *)v12 + v40);
  v41 = v13 - (_DWORD)v12;
  if (v13 - (int)v12 < 4)
  {
    if (v41 < 1)
    {
      v42 = v17 | v41;
      if (v42)
        goto LABEL_476;
    }
    else
    {
      v43 = *(unsigned __int8 *)v12;
      if (v41 == 1)
      {
        v42 = v43 << 24;
      }
      else
      {
        v44 = (v43 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v41 != 2)
          v44 |= *((unsigned __int8 *)v12 + 2);
        v42 = v44 << 8;
      }
    }
  }
  else
  {
    v42 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 4) = (v42 << v17) >> 31;
  v45 = (v17 + 1) >> 3;
  v17 = (v17 + 1) & 7;
  v12 = (unsigned int *)((char *)v12 + v45);
  v46 = v13 - (_DWORD)v12;
  if (v13 - (int)v12 < 4)
  {
    if (v46 < 1)
    {
      v47 = v17 | v46;
      if (v47)
        goto LABEL_476;
    }
    else
    {
      v48 = *(unsigned __int8 *)v12;
      if (v46 == 1)
      {
        v47 = v48 << 24;
      }
      else
      {
        v49 = (v48 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v46 != 2)
          v49 |= *((unsigned __int8 *)v12 + 2);
        v47 = v49 << 8;
      }
    }
  }
  else
  {
    v47 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 5) = (v47 << v17) >> 31;
  v50 = (v17 + 1) >> 3;
  v17 = (v17 + 1) & 7;
  v12 = (unsigned int *)((char *)v12 + v50);
  if (v13 - (int)v12 <= 0 && v17 | (v13 - (_DWORD)v12))
    goto LABEL_476;
  v51 = (v17 + 4) >> 3;
  v17 = (v17 + 4) & 7;
  v12 = (unsigned int *)((char *)v12 + v51);
  v52 = v13 - (_DWORD)v12;
  if (v13 - (int)v12 < 4)
  {
    if (v52 < 1)
    {
      v53 = v17 | v52;
      if (v53)
        goto LABEL_476;
    }
    else
    {
      v54 = *(unsigned __int8 *)v12;
      if (v52 == 1)
      {
        v53 = v54 << 24;
      }
      else
      {
        v55 = (v54 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v52 != 2)
          v55 |= *((unsigned __int8 *)v12 + 2);
        v53 = v55 << 8;
      }
    }
  }
  else
  {
    v53 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 1) = (v53 << v17) >> 24;
  v29 = (unsigned int *)((char *)v12 + 1);
  v56 = v13 - ((_DWORD)v12 + 1);
  if (v56 >= 4)
  {
    v57 = bswap32(*v29);
    goto LABEL_98;
  }
  if (v56 < 1)
  {
    v57 = v17 | v56;
    if (!v57)
      goto LABEL_98;
LABEL_94:
    v59 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    v60 = 0;
LABEL_489:
    v12 = v29;
LABEL_484:
    v261 = v60;
    if ((_DWORD)v59)
      return v59;
    goto LABEL_481;
  }
  v58 = *(unsigned __int8 *)v29;
  if (v56 == 1)
  {
    v57 = v58 << 24;
  }
  else
  {
    v61 = (v58 << 16) | (*((unsigned __int8 *)v12 + 2) << 8);
    if (v56 != 2)
      v61 |= *((unsigned __int8 *)v12 + 3);
    v57 = v61 << 8;
  }
LABEL_98:
  v60 = v57 << v17;
  if (!((v57 << v17) >> 19))
  {
    v59 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_489;
  }
  v62 = __clz(v60);
  v63 = v60 << (v62 + 1) >> -(char)v62;
  if (!v62)
    v63 = 0;
  v64 = v63 + ~(-1 << v62);
  *((_DWORD *)a2 + 9) = v64;
  v65 = v62 + v17 + v62 + 1;
  v66 = v65 >> 3;
  v17 = v65 & 7;
  v12 = (unsigned int *)((char *)v29 + v66);
  v67 = v13 - ((_DWORD)v29 + v66);
  if (v67 < 4)
  {
    if (v67 < 1)
    {
      v68 = v17 | v67;
      if (v68)
        goto LABEL_476;
    }
    else
    {
      v69 = *(unsigned __int8 *)v12;
      if (v67 == 1)
      {
        v68 = v69 << 24;
      }
      else
      {
        v70 = (v69 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v67 != 2)
          v70 |= *((unsigned __int8 *)v12 + 2);
        v68 = v70 << 8;
      }
    }
  }
  else
  {
    v68 = bswap32(*v12);
  }
  v60 = v68 << v17;
  v71 = vdupq_n_s32(v28);
  v72 = (int16x8_t)vceqq_s32(v71, (int32x4_t)xmmword_18EDDD980);
  v71.i32[2] = v27 & 0xDF000000;
  if ((vmaxv_u8((uint8x8_t)vmovn_s16(vuzp1q_s16(v72, (int16x8_t)vceqq_s32(v71, (int32x4_t)xmmword_18EDDD970)))) & 1) != 0
    || (v80 = v28 & 0xFE, v80 == 138)
    || v80 == 134)
  {
    if (!(v60 >> 19))
      goto LABEL_486;
    v73 = __clz(v60);
    v74 = v60 << (v73 + 1) >> -(char)v73;
    if (!v73)
      v74 = 0;
    v75 = v74 + ~(-1 << v73);
    a2[40] = v75;
    v76 = v73 + v17 + v73 + 1;
    v17 = v76 & 7;
    v12 = (unsigned int *)((char *)v12 + (v76 >> 3));
    v77 = v13 - (_DWORD)v12;
    if (v13 - (int)v12 < 4)
    {
      if (v77 < 1)
      {
        v78 = v17 | v77;
        if (v78)
          goto LABEL_476;
      }
      else
      {
        v79 = *(unsigned __int8 *)v12;
        if (v77 == 1)
        {
          v78 = v79 << 24;
        }
        else
        {
          v81 = (v79 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v77 != 2)
            v81 |= *((unsigned __int8 *)v12 + 2);
          v78 = v81 << 8;
        }
      }
    }
    else
    {
      v78 = bswap32(*v12);
    }
    if (v75 >= 4u)
      goto LABEL_487;
    v60 = v78 << v17;
    if (v75 == 3)
    {
      a2[41] = (v60 & 0x80000000) != 0;
      v82 = (v17 + 1) >> 3;
      v17 = (v17 + 1) & 7;
      v12 = (unsigned int *)((char *)v12 + v82);
      v83 = v13 - (_DWORD)v12;
      if (v13 - (int)v12 < 4)
      {
        if (v83 < 1)
        {
          v84 = v17 | v83;
          if (v84)
            goto LABEL_476;
        }
        else
        {
          v85 = *(unsigned __int8 *)v12;
          if (v83 == 1)
          {
            v84 = v85 << 24;
          }
          else
          {
            v86 = (v85 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
            if (v83 != 2)
              v86 |= *((unsigned __int8 *)v12 + 2);
            v84 = v86 << 8;
          }
        }
      }
      else
      {
        v84 = bswap32(*v12);
      }
      v60 = v84 << v17;
    }
    if (!(v60 >> 19))
      goto LABEL_486;
    v87 = __clz(v60);
    v88 = v60 << (v87 + 1) >> -(char)v87;
    if (!v87)
      v88 = 0;
    v89 = v88 + ~(-1 << v87);
    a2[42] = v89;
    v90 = v87 + v17 + v87 + 1;
    v17 = v90 & 7;
    v12 = (unsigned int *)((char *)v12 + (v90 >> 3));
    v91 = v13 - (_DWORD)v12;
    if (v13 - (int)v12 < 4)
    {
      if (v91 < 1)
      {
        v92 = v17 | v91;
        if (v92)
          goto LABEL_476;
      }
      else
      {
        v93 = *(unsigned __int8 *)v12;
        if (v91 == 1)
        {
          v92 = v93 << 24;
        }
        else
        {
          v94 = (v93 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v91 != 2)
            v94 |= *((unsigned __int8 *)v12 + 2);
          v92 = v94 << 8;
        }
      }
    }
    else
    {
      v92 = bswap32(*v12);
    }
    if (v89 >= 7u)
      goto LABEL_487;
    v60 = v92 << v17;
    if (!((v92 << v17) >> 19))
      goto LABEL_486;
    v95 = __clz(v60);
    v96 = v60 << (v95 + 1) >> -(char)v95;
    if (!v95)
      v96 = 0;
    v97 = v96 + ~(-1 << v95);
    a2[43] = v97;
    v98 = v95 + v17 + v95 + 1;
    v17 = v98 & 7;
    v12 = (unsigned int *)((char *)v12 + (v98 >> 3));
    v99 = v13 - (_DWORD)v12;
    if (v13 - (int)v12 < 4)
    {
      if (v99 < 1)
      {
        v100 = v17 | v99;
        if (v100)
          goto LABEL_476;
      }
      else
      {
        v101 = *(unsigned __int8 *)v12;
        if (v99 == 1)
        {
          v100 = v101 << 24;
        }
        else
        {
          v102 = (v101 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v99 != 2)
            v102 |= *((unsigned __int8 *)v12 + 2);
          v100 = v102 << 8;
        }
      }
    }
    else
    {
      v100 = bswap32(*v12);
    }
    if (v97 >= 7u)
      goto LABEL_487;
    v59 = v263;
    if (v263)
      return v59;
    a2[44] = v100 << v17 < 0;
    v103 = (v17 + 1) >> 3;
    v17 = (v17 + 1) & 7;
    v12 = (unsigned int *)((char *)v12 + v103);
    v104 = v13 - (_DWORD)v12;
    if (v13 - (int)v12 < 4)
    {
      if (v104 < 1)
      {
        v105 = v17 | v104;
        if (v105)
          goto LABEL_476;
      }
      else
      {
        v106 = *(unsigned __int8 *)v12;
        if (v104 == 1)
        {
          v105 = v106 << 24;
        }
        else
        {
          v107 = (v106 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v104 != 2)
            v107 |= *((unsigned __int8 *)v12 + 2);
          v105 = v107 << 8;
        }
      }
    }
    else
    {
      v105 = bswap32(*v12);
    }
    v108 = v105 << v17;
    a2[45] = v108 < 0;
    v109 = v17 + 1;
    v17 = (v17 + 1) & 7;
    v12 = (unsigned int *)((char *)v12 + (v109 >> 3));
    v110 = v13 - (_DWORD)v12;
    if (v110 < 4)
    {
      if (v110 < 1)
      {
        v111 = v17 | v110;
        if (v111)
          goto LABEL_476;
      }
      else
      {
        v112 = *(unsigned __int8 *)v12;
        if (v110 == 1)
        {
          v111 = v112 << 24;
        }
        else
        {
          v113 = (v112 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v110 != 2)
            v113 |= *((unsigned __int8 *)v12 + 2);
          v111 = v113 << 8;
        }
      }
    }
    else
    {
      v111 = bswap32(*v12);
    }
    v60 = v111 << v17;
    if (v108 < 0)
    {
      v114 = 0;
      while (1)
      {
        v59 = v263;
        if (v263)
          return v59;
        v115 = (v17 + 1) >> 3;
        v17 = (v17 + 1) & 7;
        v12 = (unsigned int *)((char *)v12 + v115);
        v116 = v9 + v10 - (_DWORD)v12;
        if (v116 < 4)
        {
          if (v116 < 1)
          {
            v117 = v17 | v116;
            if (v117)
              goto LABEL_476;
          }
          else
          {
            v118 = *(unsigned __int8 *)v12;
            if (v116 == 1)
            {
              v117 = v118 << 24;
            }
            else
            {
              v119 = (v118 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
              if (v116 != 2)
                v119 |= *((unsigned __int8 *)v12 + 2);
              v117 = v119 << 8;
            }
          }
        }
        else
        {
          v117 = bswap32(*v12);
        }
        v120 = v117 << v17;
        if ((v60 & 0x80000000) != 0)
        {
          *(_QWORD *)(a1 + 16) = v12;
          *(_DWORD *)(a1 + 24) = v120;
          *(_BYTE *)(a1 + 28) = v17;
          if (v114 >= 6)
            v121 = 64;
          else
            v121 = 16;
          scaling_list(a1, v121, &v263);
          v12 = *(unsigned int **)(a1 + 16);
          v60 = *(_DWORD *)(a1 + 24);
          v17 = *(unsigned __int8 *)(a1 + 28);
          v10 = *(_DWORD *)(a1 + 8);
          v9 = *(_QWORD *)a1;
        }
        else
        {
          v60 = v120;
        }
        ++v114;
        if (a2[40] == 3)
          v122 = 12;
        else
          v122 = 8;
        if (v114 >= v122)
        {
          v64 = *((_DWORD *)a2 + 9);
          break;
        }
      }
    }
  }
  else
  {
    a2[40] = 1;
  }
  if (v64 >= 32)
    goto LABEL_487;
  v59 = v263;
  if (v263)
    return v59;
  if (!(v60 >> 19))
    goto LABEL_486;
  v123 = __clz(v60);
  v124 = v60 << (v123 + 1) >> -(char)v123;
  if (!v123)
    v124 = 0;
  *((_DWORD *)a2 + 72) = v124 + ~(-1 << v123);
  v125 = v123 + v17 + v123 + 1;
  v17 = v125 & 7;
  v12 = (unsigned int *)((char *)v12 + (v125 >> 3));
  v126 = v9 + v10;
  v127 = v9 + v10 - (_DWORD)v12;
  if (v127 < 4)
  {
    if (v127 < 1)
    {
      v128 = v17 | v127;
      if (v128)
        goto LABEL_476;
    }
    else
    {
      v129 = *(unsigned __int8 *)v12;
      if (v127 == 1)
      {
        v128 = v129 << 24;
      }
      else
      {
        v130 = (v129 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v127 != 2)
          v130 |= *((unsigned __int8 *)v12 + 2);
        v128 = v130 << 8;
      }
    }
  }
  else
  {
    v128 = bswap32(*v12);
  }
  v60 = v128 << v17;
  if (!((v128 << v17) >> 19))
    goto LABEL_486;
  v131 = __clz(v60);
  v132 = v60 << (v131 + 1) >> -(char)v131;
  if (!v131)
    v132 = 0;
  v133 = v132 + ~(-1 << v131);
  *((_DWORD *)a2 + 73) = v133;
  v134 = v131 + v17 + v131 + 1;
  v17 = v134 & 7;
  v12 = (unsigned int *)((char *)v12 + (v134 >> 3));
  v135 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v135 < 1)
    {
      v136 = v17 | v135;
      if (v136)
        goto LABEL_476;
    }
    else
    {
      v137 = *(unsigned __int8 *)v12;
      if (v135 == 1)
      {
        v136 = v137 << 24;
      }
      else
      {
        v138 = (v137 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v135 != 2)
          v138 |= *((unsigned __int8 *)v12 + 2);
        v136 = v138 << 8;
      }
    }
  }
  else
  {
    v136 = bswap32(*v12);
  }
  v60 = v136 << v17;
  if (v133 != 1)
  {
    if (v133)
      goto LABEL_322;
    if (v60 >> 19)
    {
      v139 = __clz(v60);
      v140 = v60 << (v139 + 1) >> -(char)v139;
      if (!v139)
        v140 = 0;
      v141 = v140 + ~(-1 << v139);
      *((_DWORD *)a2 + 74) = v141;
      v142 = v139 + v17 + v139 + 1;
      v17 = v142 & 7;
      v12 = (unsigned int *)((char *)v12 + (v142 >> 3));
      v143 = v126 - (_DWORD)v12;
      if (v126 - (int)v12 < 4)
      {
        if (v143 < 1)
        {
          v144 = v17 | v143;
          if (v144)
            goto LABEL_476;
        }
        else
        {
          v149 = *(unsigned __int8 *)v12;
          if (v143 == 1)
          {
            v144 = v149 << 24;
          }
          else
          {
            v157 = (v149 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
            if (v143 != 2)
              v157 |= *((unsigned __int8 *)v12 + 2);
            v144 = v157 << 8;
          }
        }
      }
      else
      {
        v144 = bswap32(*v12);
      }
      if (v141 >= 13)
        goto LABEL_487;
      v60 = v144 << v17;
      *((_DWORD *)a2 + 132) = 1 << (v141 + 4);
      *(_QWORD *)(a2 + 308) = 0;
      *(_QWORD *)(a2 + 300) = 0;
      goto LABEL_322;
    }
LABEL_486:
    v59 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_484;
  }
  *((_DWORD *)a2 + 75) = v60 >> 31;
  v145 = (v17 + 1) >> 3;
  v17 = (v17 + 1) & 7;
  v12 = (unsigned int *)((char *)v12 + v145);
  v146 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v146 < 1)
    {
      v147 = v17 | v146;
      if (v147)
        goto LABEL_476;
    }
    else
    {
      v148 = *(unsigned __int8 *)v12;
      if (v146 == 1)
      {
        v147 = v148 << 24;
      }
      else
      {
        v150 = (v148 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v146 != 2)
          v150 |= *((unsigned __int8 *)v12 + 2);
        v147 = v150 << 8;
      }
    }
  }
  else
  {
    v147 = bswap32(*v12);
  }
  v60 = v147 << v17;
  if (!((v147 << v17) >> 19))
    goto LABEL_486;
  v151 = __clz(v60);
  v152 = v60 << (v151 + 1) >> -(char)v151;
  if (!v151)
    v152 = 0;
  v153 = v151 + v17 + v151 + 1;
  v17 = v153 & 7;
  v12 = (unsigned int *)((char *)v12 + (v153 >> 3));
  v154 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v154 < 1)
    {
      v155 = v17 | v154;
      if (v155)
        goto LABEL_476;
    }
    else
    {
      v156 = *(unsigned __int8 *)v12;
      if (v154 == 1)
      {
        v155 = v156 << 24;
      }
      else
      {
        v158 = (v156 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v154 != 2)
          v158 |= *((unsigned __int8 *)v12 + 2);
        v155 = v158 << 8;
      }
    }
  }
  else
  {
    v155 = bswap32(*v12);
  }
  v60 = v155 << v17;
  *((_DWORD *)a2 + 76) = ((v152 + (1 << v151)) >> 1) - ((v152 + (1 << v151)) >> 1) * 2 * ((v152 + (1 << v151)) & 1);
  if (!((v155 << v17) >> 19))
    goto LABEL_486;
  v159 = __clz(v60);
  v160 = v60 << (v159 + 1) >> -(char)v159;
  if (!v159)
    v160 = 0;
  v161 = v159 + v17 + v159 + 1;
  v17 = v161 & 7;
  v12 = (unsigned int *)((char *)v12 + (v161 >> 3));
  v162 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v162 < 1)
    {
      v163 = v17 | v162;
      if (v163)
        goto LABEL_476;
    }
    else
    {
      v164 = *(unsigned __int8 *)v12;
      if (v162 == 1)
      {
        v163 = v164 << 24;
      }
      else
      {
        v165 = (v164 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v162 != 2)
          v165 |= *((unsigned __int8 *)v12 + 2);
        v163 = v165 << 8;
      }
    }
  }
  else
  {
    v163 = bswap32(*v12);
  }
  v60 = v163 << v17;
  *((_DWORD *)a2 + 77) = ((v160 + (1 << v159)) >> 1) - ((v160 + (1 << v159)) >> 1) * 2 * ((v160 + (1 << v159)) & 1);
  if (!((v163 << v17) >> 19))
    goto LABEL_486;
  v166 = __clz(v60);
  v167 = v60 << (v166 + 1) >> -(char)v166;
  if (!v166)
    v167 = 0;
  v168 = v167 + ~(-1 << v166);
  *((_DWORD *)a2 + 78) = v168;
  v169 = v166 + v17 + v166 + 1;
  v17 = v169 & 7;
  v12 = (unsigned int *)((char *)v12 + (v169 >> 3));
  v170 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v170 < 1)
    {
      v171 = v17 | v170;
      if (v171)
        goto LABEL_476;
    }
    else
    {
      v172 = *(unsigned __int8 *)v12;
      if (v170 == 1)
      {
        v171 = v172 << 24;
      }
      else
      {
        v173 = (v172 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v170 != 2)
          v173 |= *((unsigned __int8 *)v12 + 2);
        v171 = v173 << 8;
      }
    }
  }
  else
  {
    v171 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 132) = 0;
  if (v168 > 255)
    goto LABEL_487;
  v60 = v171 << v17;
  if (v168 >= 1)
  {
    while (v60 >> 19)
    {
      v174 = v17 + 2 * __clz(v60) + 1;
      v17 = v174 & 7;
      v12 = (unsigned int *)((char *)v12 + (v174 >> 3));
      v175 = v126 - (_DWORD)v12;
      if (v126 - (int)v12 < 4)
      {
        if (v175 < 1)
        {
          v176 = v17 | v175;
          if (v176)
            goto LABEL_476;
        }
        else
        {
          v177 = *(unsigned __int8 *)v12;
          if (v175 == 1)
          {
            v176 = v177 << 24;
          }
          else
          {
            v178 = (v177 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
            if (v175 != 2)
              v178 |= *((unsigned __int8 *)v12 + 2);
            v176 = v178 << 8;
          }
        }
      }
      else
      {
        v176 = bswap32(*v12);
      }
      v60 = v176 << v17;
      if (!--v168)
        goto LABEL_322;
    }
    goto LABEL_486;
  }
LABEL_322:
  if (!(v60 >> 19))
    goto LABEL_486;
  v179 = __clz(v60);
  v180 = v60 << (v179 + 1) >> -(char)v179;
  if (!v179)
    v180 = 0;
  *((_DWORD *)a2 + 79) = v180 + ~(-1 << v179);
  v181 = v179 + v17 + v179 + 1;
  v17 = v181 & 7;
  v12 = (unsigned int *)((char *)v12 + (v181 >> 3));
  v182 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v182 < 1)
    {
      v183 = v17 | v182;
      if (v183)
        goto LABEL_476;
    }
    else
    {
      v184 = *(unsigned __int8 *)v12;
      if (v182 == 1)
      {
        v183 = v184 << 24;
      }
      else
      {
        v185 = (v184 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v182 != 2)
          v185 |= *((unsigned __int8 *)v12 + 2);
        v183 = v185 << 8;
      }
    }
  }
  else
  {
    v183 = bswap32(*v12);
  }
  *((_DWORD *)a2 + 80) = (v183 << v17) >> 31;
  v186 = (v17 + 1) >> 3;
  v17 = (v17 + 1) & 7;
  v12 = (unsigned int *)((char *)v12 + v186);
  v187 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v187 < 1)
    {
      v188 = v17 | v187;
      if (v188)
        goto LABEL_476;
    }
    else
    {
      v189 = *(unsigned __int8 *)v12;
      if (v187 == 1)
      {
        v188 = v189 << 24;
      }
      else
      {
        v190 = (v189 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v187 != 2)
          v190 |= *((unsigned __int8 *)v12 + 2);
        v188 = v190 << 8;
      }
    }
  }
  else
  {
    v188 = bswap32(*v12);
  }
  v60 = v188 << v17;
  if (!((v188 << v17) >> 19))
    goto LABEL_486;
  v191 = __clz(v60);
  v192 = v60 << (v191 + 1) >> -(char)v191;
  if (!v191)
    v192 = 0;
  *((_DWORD *)a2 + 81) = v192 + ~(-1 << v191);
  v193 = v191 + v17 + v191 + 1;
  v17 = v193 & 7;
  v12 = (unsigned int *)((char *)v12 + (v193 >> 3));
  v194 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v194 < 1)
    {
      v195 = v17 | v194;
      if (v195)
        goto LABEL_476;
    }
    else
    {
      v196 = *(unsigned __int8 *)v12;
      if (v194 == 1)
      {
        v195 = v196 << 24;
      }
      else
      {
        v197 = (v196 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v194 != 2)
          v197 |= *((unsigned __int8 *)v12 + 2);
        v195 = v197 << 8;
      }
    }
  }
  else
  {
    v195 = bswap32(*v12);
  }
  v60 = v195 << v17;
  if (!((v195 << v17) >> 19))
    goto LABEL_486;
  v198 = __clz(v60);
  v199 = v60 << (v198 + 1) >> -(char)v198;
  if (!v198)
    v199 = 0;
  *((_DWORD *)a2 + 82) = v199 + ~(-1 << v198);
  v200 = v198 + v17 + v198 + 1;
  v17 = v200 & 7;
  v12 = (unsigned int *)((char *)v12 + (v200 >> 3));
  v201 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v201 < 1)
    {
      v202 = v17 | v201;
      if (v202)
        goto LABEL_476;
    }
    else
    {
      v203 = *(unsigned __int8 *)v12;
      if (v201 == 1)
      {
        v202 = v203 << 24;
      }
      else
      {
        v204 = (v203 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v201 != 2)
          v204 |= *((unsigned __int8 *)v12 + 2);
        v202 = v204 << 8;
      }
    }
  }
  else
  {
    v202 = bswap32(*v12);
  }
  v205 = v202 << v17;
  *((_DWORD *)a2 + 83) = v205 >> 31;
  v206 = (v17 + 1) >> 3;
  v17 = (v17 + 1) & 7;
  v12 = (unsigned int *)((char *)v12 + v206);
  v207 = v126 - (_DWORD)v12;
  if (v126 - (int)v12 < 4)
  {
    if (v207 < 1)
    {
      v208 = v17 | v207;
      if (v208)
        goto LABEL_476;
    }
    else
    {
      v209 = *(unsigned __int8 *)v12;
      if (v207 == 1)
      {
        v208 = v209 << 24;
      }
      else
      {
        v210 = (v209 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
        if (v207 != 2)
          v210 |= *((unsigned __int8 *)v12 + 2);
        v208 = v210 << 8;
      }
    }
  }
  else
  {
    v208 = bswap32(*v12);
  }
  v211 = v208 << v17;
  if ((v205 & 0x80000000) != 0)
  {
    *((_DWORD *)a2 + 84) = 0;
  }
  else
  {
    v59 = v263;
    if (v263)
      return v59;
    *((_DWORD *)a2 + 84) = v211 >> 31;
    v212 = (v17 + 1) >> 3;
    v17 = (v17 + 1) & 7;
    v12 = (unsigned int *)((char *)v12 + v212);
    v213 = v126 - (_DWORD)v12;
    if (v126 - (int)v12 < 4)
    {
      if (v213 < 1)
      {
        v214 = v17 | v213;
        if (v214)
          goto LABEL_476;
      }
      else
      {
        v215 = *(unsigned __int8 *)v12;
        if (v213 == 1)
        {
          v214 = v215 << 24;
        }
        else
        {
          v216 = (v215 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v213 != 2)
            v216 |= *((unsigned __int8 *)v12 + 2);
          v214 = v216 << 8;
        }
      }
    }
    else
    {
      v214 = bswap32(*v12);
    }
    v211 = v214 << v17;
  }
  v59 = v263;
  if (!v263)
  {
    *((_DWORD *)a2 + 85) = v211 >> 31;
    v217 = (v17 + 1) >> 3;
    v17 = (v17 + 1) & 7;
    v12 = (unsigned int *)((char *)v12 + v217);
    v218 = v126 - (_DWORD)v12;
    if (v126 - (int)v12 < 4)
    {
      if (v218 < 1)
      {
        v219 = v17 | v218;
        if (v219)
          goto LABEL_476;
      }
      else
      {
        v220 = *(unsigned __int8 *)v12;
        if (v218 == 1)
        {
          v219 = v220 << 24;
        }
        else
        {
          v221 = (v220 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v218 != 2)
            v221 |= *((unsigned __int8 *)v12 + 2);
          v219 = v221 << 8;
        }
      }
    }
    else
    {
      v219 = bswap32(*v12);
    }
    v222 = v219 << v17;
    *((_DWORD *)a2 + 86) = v222 >> 31;
    v223 = (v17 + 1) >> 3;
    v17 = (v17 + 1) & 7;
    v12 = (unsigned int *)((char *)v12 + v223);
    v224 = v126 - (_DWORD)v12;
    if (v126 - (int)v12 < 4)
    {
      if (v224 < 1)
      {
        v225 = v17 | v224;
        if (v225)
          goto LABEL_476;
      }
      else
      {
        v226 = *(unsigned __int8 *)v12;
        if (v224 == 1)
        {
          v225 = v226 << 24;
        }
        else
        {
          v227 = (v226 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
          if (v224 != 2)
            v227 |= *((unsigned __int8 *)v12 + 2);
          v225 = v227 << 8;
        }
      }
    }
    else
    {
      v225 = bswap32(*v12);
    }
    v60 = v225 << v17;
    if ((v222 & 0x80000000) == 0)
      goto LABEL_470;
    if (v60 >> 19)
    {
      v228 = __clz(v60);
      v229 = v60 << (v228 + 1) >> -(char)v228;
      if (!v228)
        v229 = 0;
      *((_DWORD *)a2 + 87) = v229 + ~(-1 << v228);
      v230 = v228 + v17 + v228 + 1;
      v17 = v230 & 7;
      v12 = (unsigned int *)((char *)v12 + (v230 >> 3));
      v231 = v126 - (_DWORD)v12;
      if (v126 - (int)v12 < 4)
      {
        if (v231 < 1)
        {
          v232 = v17 | v231;
          if (v232)
            goto LABEL_476;
        }
        else
        {
          v233 = *(unsigned __int8 *)v12;
          if (v231 == 1)
          {
            v232 = v233 << 24;
          }
          else
          {
            v234 = (v233 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
            if (v231 != 2)
              v234 |= *((unsigned __int8 *)v12 + 2);
            v232 = v234 << 8;
          }
        }
      }
      else
      {
        v232 = bswap32(*v12);
      }
      v60 = v232 << v17;
      if ((v232 << v17) >> 19)
      {
        v235 = __clz(v60);
        v236 = v60 << (v235 + 1) >> -(char)v235;
        if (!v235)
          v236 = 0;
        *((_DWORD *)a2 + 88) = v236 + ~(-1 << v235);
        v237 = v235 + v17 + v235 + 1;
        v17 = v237 & 7;
        v12 = (unsigned int *)((char *)v12 + (v237 >> 3));
        v238 = v126 - (_DWORD)v12;
        if (v126 - (int)v12 < 4)
        {
          if (v238 < 1)
          {
            v239 = v17 | v238;
            if (v239)
              goto LABEL_476;
          }
          else
          {
            v240 = *(unsigned __int8 *)v12;
            if (v238 == 1)
            {
              v239 = v240 << 24;
            }
            else
            {
              v241 = (v240 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
              if (v238 != 2)
                v241 |= *((unsigned __int8 *)v12 + 2);
              v239 = v241 << 8;
            }
          }
        }
        else
        {
          v239 = bswap32(*v12);
        }
        v60 = v239 << v17;
        if ((v239 << v17) >> 19)
        {
          v242 = __clz(v60);
          v243 = v60 << (v242 + 1) >> -(char)v242;
          if (!v242)
            v243 = 0;
          *((_DWORD *)a2 + 89) = v243 + ~(-1 << v242);
          v244 = v242 + v17 + v242 + 1;
          v17 = v244 & 7;
          v12 = (unsigned int *)((char *)v12 + (v244 >> 3));
          v245 = v126 - (_DWORD)v12;
          if (v126 - (int)v12 < 4)
          {
            if (v245 < 1)
            {
              v246 = v17 | v245;
              if (v246)
                goto LABEL_476;
            }
            else
            {
              v247 = *(unsigned __int8 *)v12;
              if (v245 == 1)
              {
                v246 = v247 << 24;
              }
              else
              {
                v248 = (v247 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
                if (v245 != 2)
                  v248 |= *((unsigned __int8 *)v12 + 2);
                v246 = v248 << 8;
              }
            }
          }
          else
          {
            v246 = bswap32(*v12);
          }
          v60 = v246 << v17;
          if ((v246 << v17) >> 19)
          {
            v249 = __clz(v60);
            v250 = v60 << (v249 + 1) >> -(char)v249;
            if (!v249)
              v250 = 0;
            *((_DWORD *)a2 + 90) = v250 + ~(-1 << v249);
            v251 = v249 + v17 + v249 + 1;
            v17 = v251 & 7;
            v12 = (unsigned int *)((char *)v12 + (v251 >> 3));
            v252 = v126 - (_DWORD)v12;
            if (v126 - (int)v12 < 4)
            {
              if (v252 < 1)
              {
                v253 = v17 | v252;
                if (v253)
                  goto LABEL_476;
              }
              else
              {
                v254 = *(unsigned __int8 *)v12;
                if (v252 == 1)
                {
                  v253 = v254 << 24;
                }
                else
                {
                  v255 = (v254 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
                  if (v252 != 2)
                    v255 |= *((unsigned __int8 *)v12 + 2);
                  v253 = v255 << 8;
                }
              }
            }
            else
            {
              v253 = bswap32(*v12);
            }
            v60 = v253 << v17;
LABEL_470:
            *((_DWORD *)a2 + 91) = v60 >> 31;
            v256 = v17 + 1;
            v17 = (v17 + 1) & 7;
            v12 = (unsigned int *)((char *)v12 + (v256 >> 3));
            v257 = v126 - (_DWORD)v12;
            if (v257 >= 4)
            {
              v258 = bswap32(*v12);
              goto LABEL_480;
            }
            if (v257 >= 1)
            {
              v259 = *(unsigned __int8 *)v12;
              if (v257 == 1)
              {
                v258 = v259 << 24;
              }
              else
              {
                v260 = (v259 << 16) | (*((unsigned __int8 *)v12 + 1) << 8);
                if (v257 != 2)
                  v260 |= *((unsigned __int8 *)v12 + 2);
                v258 = v260 << 8;
              }
LABEL_480:
              v261 = v258 << v17;
              if ((v60 & 0x80000000) == 0)
              {
LABEL_481:
                v59 = 0;
                *(_QWORD *)(a1 + 16) = v12;
                *(_DWORD *)(a1 + 24) = v261;
                *(_BYTE *)(a1 + 28) = v17;
                return v59;
              }
              *(_QWORD *)(a1 + 16) = v12;
              *(_DWORD *)(a1 + 24) = v261;
              *(_BYTE *)(a1 + 28) = v17;
              if (*(_DWORD *)(a1 + 8) >= (int)v12 - *(_DWORD *)a1)
              {
                v59 = PullVUIParamSet((uint64_t *)a1, (unsigned int *)a2 + 92);
                v12 = *(unsigned int **)(a1 + 16);
                v60 = *(_DWORD *)(a1 + 24);
                LOBYTE(v17) = *(_BYTE *)(a1 + 28);
                goto LABEL_484;
              }
LABEL_487:
              v59 = 4294954582;
              FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
              return v59;
            }
            v258 = v17 | v257;
            if (!v258)
              goto LABEL_480;
LABEL_476:
            v59 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            v60 = 0;
            goto LABEL_484;
          }
        }
      }
    }
    goto LABEL_486;
  }
  return v59;
}

uint64_t FigH264Bridge_GetSPS_VUI_NCLC(const UInt8 *a1, unint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v10;
  const __CFData *v11;
  unsigned int v12;
  uint64_t v13;
  CFDataRef theData;
  const UInt8 *v16;
  uint64_t v17;
  const UInt8 *v18;
  uint64_t v19;
  _OWORD v20[22];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  Length = a2;
  BytePtr = a1;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  memset(v20, 0, sizeof(v20));
  v17 = 0;
  v18 = 0;
  v19 = 0;
  theData = 0;
  v10 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v10)
    return v10;
  v11 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v11);
  }
  v16 = BytePtr;
  LODWORD(v17) = Length;
  v18 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v19) = 0;
      __memcpy_chk();
      v12 = v19;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v12 = *(_DWORD *)BytePtr;
  }
  LODWORD(v19) = bswap32(v12);
  BYTE4(v19) = 0;
  v13 = PullParamSetSPS((uint64_t)&v16, (char *)v20);
  if (v11)
    CFRelease(v11);
  if (!(_DWORD)v13)
  {
    v13 = 4294954584;
    if (HIDWORD(v21))
    {
      if (DWORD1(v24))
      {
        v13 = 0;
        *a3 = DWORD2(v24);
        *a4 = HIDWORD(v24);
        *a5 = v25;
      }
    }
  }
  return v13;
}

uint64_t FigH264Bridge_GetSPS_VUI_AspectRatio(const UInt8 *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v8;
  const __CFData *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  unsigned __int8 *v13;
  CFDataRef theData;
  const UInt8 *v16;
  uint64_t v17;
  const UInt8 *v18;
  uint64_t v19;
  _OWORD v20[22];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  Length = a2;
  BytePtr = a1;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  memset(v20, 0, sizeof(v20));
  v17 = 0;
  v18 = 0;
  v19 = 0;
  theData = 0;
  v8 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v8)
    return v8;
  v9 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v9);
  }
  v16 = BytePtr;
  LODWORD(v17) = Length;
  v18 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v19) = 0;
      __memcpy_chk();
      v10 = v19;
    }
    else
    {
      v10 = 0;
    }
  }
  else
  {
    v10 = *(_DWORD *)BytePtr;
  }
  LODWORD(v19) = bswap32(v10);
  BYTE4(v19) = 0;
  v11 = PullParamSetSPS((uint64_t)&v16, (char *)v20);
  if (v9)
    CFRelease(v9);
  if (!(_DWORD)v11)
  {
    v11 = 4294954584;
    if (HIDWORD(v21))
    {
      if ((_DWORD)v22)
      {
        if (DWORD1(v22) == 255)
        {
          *a3 = DWORD2(v22);
          v12 = HIDWORD(v22);
        }
        else
        {
          if ((DWORD1(v22) - 1) > 0xF)
            return 0;
          v13 = (unsigned __int8 *)&kH264SampleAspectRatioIndicators + 2 * DWORD1(v22);
          *a3 = *v13;
          v12 = v13[1];
        }
        v11 = 0;
        *a4 = v12;
      }
    }
  }
  return v11;
}

uint64_t FigCFCreateExtendedDictionary(const __CFAllocator *a1, CFDictionaryRef theDict, const void *a3, const void *a4, uint64_t a5, CFDictionaryRef *a6)
{
  BOOL v11;
  uint64_t v12;
  CFIndex Count;
  const void **v15;
  CFIndex v16;
  const void **v17;

  if (!a6 || (a4 ? (v11 = a3 == 0) : (v11 = 1), v11 && a5 > 0))
  {
    v12 = 4294954306;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  *a6 = 0;
  if (theDict)
    Count = CFDictionaryGetCount(theDict);
  else
    Count = 0;
  v15 = 0;
  v16 = Count + a5;
  if ((unint64_t)(Count + a5) >> 61)
  {
    v17 = 0;
  }
  else
  {
    v17 = 0;
    if (8 * v16)
    {
      v15 = (const void **)malloc_type_malloc(8 * v16, 0xF2A4A571uLL);
      if (v15)
      {
        v17 = (const void **)malloc_type_malloc(8 * v16, 0x3EC50319uLL);
        if (v17)
        {
          if (theDict)
            CFDictionaryGetKeysAndValues(theDict, v15, v17);
          memcpy(&v15[Count], a3, 8 * a5);
          memcpy(&v17[Count], a4, 8 * a5);
          *a6 = CFDictionaryCreate(a1, v15, v17, Count + a5, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        }
      }
      else
      {
        v17 = 0;
      }
    }
  }
  free(v15);
  free(v17);
  if (!*a6)
  {
    v12 = 4294954305;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigVideoFormatDescriptionRegisterOnce()
{
  int v1;
  uint64_t v2;
  BOOL (*v3)(const opaqueCMFormatDescription *, const opaqueCMFormatDescription *, unint64_t, unint64_t);
  __CFString *(*v4)(const void *);
  uint64_t (*v5)();

  v1 = 0;
  v2 = 12;
  v4 = figVideoFormatDescriptionCopyDebugDesc;
  v5 = figVideoFormatDescriptionFinalize;
  v3 = figVideoFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x76696465u, (__int128 *)&v1);
}

uint64_t FigSignalErrorAt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7)
{
  FigAtomicIncrement32((unsigned int *)&gErrorCount);
  figRecordLastSignaledErrorInfo(a1, a2, a3, a4, a5, a6, a7);
  return a1;
}

uint64_t FigFileWrapDarwinFileDesc(int a1, _QWORD *a2)
{
  _DWORD *v4;

  v4 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  if (!v4)
    return FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
  *v4 = a1;
  *a2 = v4;
  return 0;
}

uint64_t FigAtomicBitAnd32Orig(int a1, unsigned int *a2)
{
  uint64_t v2;

  do
    v2 = __ldxr(a2);
  while (__stxr(v2 & a1, a2));
  return v2;
}

uint64_t FigCFCreateCombinedDictionary(const __CFAllocator *a1, CFDictionaryRef *a2, uint64_t a3, CFDictionaryRef *a4)
{
  uint64_t v5;
  CFDictionaryRef *v6;
  uint64_t v8;
  unint64_t v10;
  const __CFDictionary **v11;
  uint64_t v12;
  const __CFDictionary *v13;
  size_t v14;
  const void **v16;
  const void **v17;
  CFIndex v18;
  CFIndex Count;
  const __CFDictionary *v20;

  if (!a4 || (v5 = a3, (v6 = a2) == 0) && a3 > 0)
  {
    v8 = 4294954306;
    return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  *a4 = 0;
  if (a3 < 1)
    goto LABEL_19;
  v10 = 0;
  v11 = a2;
  v12 = a3;
  do
  {
    v13 = *v11++;
    v10 += CFDictionaryGetCount(v13);
    --v12;
  }
  while (v12);
  v14 = 8 * v10;
  if (v10 >> 61 || v14 == 0)
  {
LABEL_19:
    v16 = 0;
    goto LABEL_20;
  }
  v16 = (const void **)malloc_type_malloc(8 * v10, 0xA0DD3C2FuLL);
  if (!v16)
  {
LABEL_20:
    v17 = 0;
    goto LABEL_23;
  }
  v17 = (const void **)malloc_type_malloc(v14, 0x649C7E52uLL);
  if (v17)
  {
    if (v5 < 1)
    {
      v18 = 0;
    }
    else
    {
      v18 = 0;
      do
      {
        Count = CFDictionaryGetCount(*v6);
        v20 = *v6++;
        CFDictionaryGetKeysAndValues(v20, &v16[v18], &v17[v18]);
        v18 += Count;
        --v5;
      }
      while (v5);
    }
    *a4 = CFDictionaryCreate(a1, v16, v17, v18, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
LABEL_23:
  free(v16);
  free(v17);
  if (!*a4)
  {
    v8 = 4294954305;
    return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigScheduledIOCreateForReadingByteStream(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  uint64_t CMBaseObject;
  uint64_t (*v7)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  uint64_t v8;
  CFTypeRef cf;

  cf = 0;
  CMBaseObject = CMByteStreamGetCMBaseObject(a2);
  v7 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                               + 8)
                                                                                   + 48);
  if (!v7)
    return 4294954514;
  v8 = v7(CMBaseObject, CFSTR("FBS_ScheduledIO"), a1, a3);
  if ((_DWORD)v8 == -12784)
  {
    v8 = FigScheduledIOFRSCreateForByteStream(a1, a2, &cf);
    if ((_DWORD)v8)
    {
      if (cf)
        CFRelease(cf);
    }
    else
    {
      *a3 = cf;
    }
  }
  return v8;
}

uint64_t FigScheduledIOGetClassID()
{
  FigThreadRunOnce(&FigScheduledIOGetClassID_sRegisterFigScheduledIOBaseTypeOnce, (void (*)(void))RegisterFigScheduledIOBaseType);
  return sFigScheduledIOClassID;
}

uint64_t RegisterFigScheduledIOBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigScheduledIOClassDesc, ClassID, 1, &sFigScheduledIOClassID);
}

uint64_t bufQDataBecameReady(uint64_t a1, uint64_t a2)
{
  const __CFSet *v3;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 16));
  v3 = *(const __CFSet **)(a2 + 160);
  if (v3)
    CFSetApplyFunction(v3, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, (void *)a2);
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 16));
}

uint64_t PeekBits(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  if (v4 >= v3)
    v5 = 0;
  else
    v5 = *(_DWORD *)(a1 + 36) & 7 | (8
                                     * (v3
                                      - (*(_QWORD *)(a1 + 40)
                                       + v4)
                                      + ((unint64_t)*(unsigned int *)(a1 + 36) >> 3)));
  if (v5 < a2)
    return 0;
  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(_QWORD *)(a1 + 32);
  result = GetBits(a1, a2);
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 32) = v7;
  *(_QWORD *)(a1 + 40) = v6;
  return result;
}

uint64_t GetBits(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  uint64_t result;

  v3 = *(_DWORD *)(a1 + 36);
  v4 = a2 - v3;
  if (a2 <= v3)
  {
    v6 = 0;
    v4 = 0;
  }
  else
  {
    if (v3)
      v5 = 0xFFFFFFFF >> -(char)v3;
    else
      v5 = 0;
    v6 = *(_DWORD *)(a1 + 32) & v5;
    *(_QWORD *)(a1 + 16) += 4;
    CopyNextWord(a1);
    v3 = *(_DWORD *)(a1 + 36);
    a2 = v4;
  }
  v7 = v3 - a2;
  if (v3 < a2)
  {
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else
  {
    if (v7 == 32)
    {
      v8 = 0;
    }
    else
    {
      v9 = -1 << -(char)a2;
      if (!a2)
        v9 = 0;
      v10 = v9 >> -(char)v3;
      if (v3)
        v11 = v10;
      else
        v11 = 0;
      v8 = (*(_DWORD *)(a1 + 32) & v11) >> v7;
    }
    v12 = v6 << v4;
    if (v4 == 32)
      v12 = 0;
    result = v8 | v12;
    *(_DWORD *)(a1 + 36) = v7;
  }
  return result;
}

uint64_t FigHALAudioBrokeredPluginCreateDeviceBroker(const void *a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  CFTypeRef v5;

  brokeredPlugin_CreateDeviceBroker(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a2)
  {
    v5 = *(CFTypeRef *)(DerivedStorage + 24);
    if (v5)
      v5 = CFRetain(v5);
    *a2 = v5;
  }
  return 0;
}

uint64_t brokeredPlugin_CreateDeviceBroker(const void *a1)
{
  uint64_t DerivedStorage;
  CFAllocatorRef v3;
  _QWORD *ClassID;
  uint64_t v5;
  uint64_t v7;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v7 = 0;
  v3 = CFGetAllocator(a1);
  ClassID = (_QWORD *)FigHALAudioDeviceBrokerGetClassID();
  v5 = CMDerivedObjectCreate((uint64_t)v3, (uint64_t)&kFigHALAudioBasicBrokerVTable, ClassID, &v7);
  if (!(_DWORD)v5)
  {
    *(_QWORD *)CMBaseObjectGetDerivedStorage(v7) = a1;
    *(_QWORD *)(DerivedStorage + 24) = v7;
  }
  return v5;
}

uint64_t FigHALAudioCreateBrokeredPluginObject(const __CFAllocator *a1, const void *a2, uint64_t *a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  return brokeredPlugin_CreateBrokeredPluginObjectInternal(a1, a2, a3, a4, a5, 0, a6);
}

uint64_t brokeredPlugin_CreateBrokeredPluginObjectInternal(const __CFAllocator *a1, const void *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, CFTypeRef *a7)
{
  _QWORD *ClassID;
  uint64_t v15;
  _QWORD *DerivedStorage;
  dispatch_queue_t v17;
  BOOL v18;
  uint64_t v19;
  CFTypeRef cf;

  cf = 0;
  ClassID = (_QWORD *)FigHALAudioPluginGetClassID();
  v15 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigHALAudioBrokeredPluginVTable, ClassID, &cf);
  if ((_DWORD)v15)
    goto LABEL_10;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
  DerivedStorage[1] = a3;
  DerivedStorage[2] = CFRetain(a2);
  DerivedStorage[6] = a5;
  DerivedStorage[7] = a6;
  DerivedStorage[5] = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  v17 = dispatch_queue_create("FigHALBrokeredPluginDeviceManagementQueue", 0);
  DerivedStorage[4] = v17;
  DerivedStorage[8] = a4;
  if (DerivedStorage[5])
    v18 = v17 == 0;
  else
    v18 = 1;
  if (v18)
  {
    v15 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
LABEL_10:
    v19 = v15;
    goto LABEL_11;
  }
  v19 = FigHALAudioObjectMapperAddPluginObjectMapping(a3, (uint64_t)cf);
  if (!(_DWORD)v19)
  {
    *a7 = cf;
    return v19;
  }
LABEL_11:
  if (cf)
    CFRelease(cf);
  return v19;
}

_QWORD *basicBroker_Finalize(uint64_t a1)
{
  _QWORD *result;

  result = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  *result = 0;
  return result;
}

CFStringRef basicBroker_CopyDebugDescription(uint64_t a1)
{
  _QWORD *DerivedStorage;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("FigHALAudioDeviceBroker-BasicBroker pluginObject %@"), *DerivedStorage);
}

uint64_t basicBroker_CreateDevice(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t (***DerivedStorage)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v10;
  NSObject *v11;
  _QWORD v13[7];
  uint64_t v14;

  v8 = *(_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  DerivedStorage = (uint64_t (***)(_QWORD, uint64_t, uint64_t, uint64_t))CMBaseObjectGetDerivedStorage(v8);
  v14 = 0;
  v10 = ((uint64_t (*)(_QWORD, uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t), _QWORD, uint64_t, uint64_t, uint64_t, uint64_t *))DerivedStorage[6])(*MEMORY[0x1E0C9AE00], DerivedStorage[1], *DerivedStorage, a3, a4, a5, &v14);
  if (!(_DWORD)v10)
  {
    v11 = DerivedStorage[4];
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 0x40000000;
    v13[2] = __brokeredPlugin_CreateDeviceForEndpointStream_block_invoke;
    v13[3] = &__block_descriptor_tmp;
    v13[4] = DerivedStorage;
    v13[5] = v14;
    v13[6] = v8;
    dispatch_sync(v11, v13);
    FigHALAudioPropertySendChanges(*DerivedStorage, 1, 2, (uint64_t)"#vedbolg");
  }
  return v10;
}

void brokeredPlugin_DeviceUnpluggedNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  NSObject *v7;
  _QWORD block[7];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a2);
  v7 = *(NSObject **)(DerivedStorage + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __brokeredPlugin_DeviceUnpluggedNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_2;
  block[4] = a2;
  block[5] = a4;
  block[6] = DerivedStorage;
  dispatch_sync(v7, block);
  FigHALAudioPropertySendChanges(*(uint64_t (***)(_QWORD, uint64_t, uint64_t, uint64_t))DerivedStorage, 1, 2, (uint64_t)"#vedbolg");
}

void brokeredPlugin_Finalize(uint64_t a1)
{
  _QWORD *DerivedStorage;
  const void *v2;
  const void *v3;
  NSObject *v4;
  const void *v5;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  v2 = (const void *)DerivedStorage[2];
  if (v2)
  {
    CFRelease(v2);
    DerivedStorage[2] = 0;
  }
  v3 = (const void *)DerivedStorage[5];
  if (v3)
  {
    CFRelease(v3);
    DerivedStorage[5] = 0;
  }
  v4 = DerivedStorage[4];
  if (v4)
  {
    dispatch_release(v4);
    DerivedStorage[4] = 0;
  }
  v5 = (const void *)DerivedStorage[9];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[9] = 0;
  }
}

CFStringRef brokeredPlugin_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v2;
  CFStringRef v3;
  _QWORD block[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v2 = *(NSObject **)(DerivedStorage + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __brokeredPlugin_CopyDebugDescription_block_invoke;
  block[3] = &unk_1E28D7650;
  block[4] = &v6;
  block[5] = DerivedStorage;
  dispatch_sync(v2, block);
  v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("FigHALBrokeredPlugin: brokerType: %@ %ld devices"), *(_QWORD *)(DerivedStorage + 16), v7[3]);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t brokeredPlugin_GetObjectID()
{
  return 1;
}

uint64_t brokeredPlugin_HasProperty(uint64_t a1, int *a2)
{
  int v2;
  uint64_t result;
  BOOL v4;
  int v5;

  v2 = *a2;
  result = 1;
  if (*a2 <= 1819107690)
  {
    v4 = v2 == 1668047219;
    v5 = 1684370979;
  }
  else
  {
    v4 = v2 == 1819107691 || v2 == 1870098020;
    v5 = 1969841252;
  }
  if (!v4 && v2 != v5)
    return 0;
  return result;
}

uint64_t brokeredPlugin_IsPropertySettable()
{
  return 0;
}

uint64_t brokeredPlugin_GetPropertyDataSize(uint64_t a1, int *a2)
{
  uint64_t DerivedStorage;
  int v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v4 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v4 == 1668047219)
      return 4;
    if (v4 != 1684370979)
      return 0;
LABEL_9:
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = 0;
    v6 = *(NSObject **)(DerivedStorage + 32);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __brokeredPlugin_GetPropertyDataSize_block_invoke;
    v8[3] = &unk_1E28D7678;
    v8[4] = &v9;
    v8[5] = DerivedStorage;
    dispatch_sync(v6, v8);
    v5 = (4 * *((_DWORD *)v10 + 6));
    _Block_object_dispose(&v9, 8);
    return v5;
  }
  switch(v4)
  {
    case 1819107691:
      return 8;
    case 1870098020:
      goto LABEL_9;
    case 1969841252:
      return 4;
    default:
      return 0;
  }
}

uint64_t brokeredPlugin_GetPropertyData(uint64_t a1, int *a2, int a3, uint64_t a4, unsigned int a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t DerivedStorage;
  uint64_t v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  _QWORD block[7];
  _QWORD v20[7];
  unsigned int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v14 = 0;
  v15 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v15 != 1668047219)
    {
      if (v15 != 1684370979)
        return v14;
LABEL_11:
      v22 = 0;
      v23 = &v22;
      v24 = 0x2000000000;
      v25 = 0;
      v17 = *(NSObject **)(DerivedStorage + 32);
      v20[0] = MEMORY[0x1E0C809B0];
      v20[1] = 0x40000000;
      v20[2] = __brokeredPlugin_GetPropertyData_block_invoke;
      v20[3] = &unk_1E28D76A0;
      v21 = a5;
      v20[4] = &v22;
      v20[5] = DerivedStorage;
      v20[6] = a7;
      dispatch_sync(v17, v20);
      *a6 = 4 * *((_DWORD *)v23 + 6);
      _Block_object_dispose(&v22, 8);
      return 0;
    }
    *a6 = 4;
    if (a5 >= 4)
    {
      v14 = 0;
      *a7 = 1634757735;
      return v14;
    }
    return 561211770;
  }
  if (v15 == 1819107691)
  {
    *a6 = 8;
    if (a5 >= 8)
    {
      v14 = 0;
      *(_QWORD *)a7 = CFSTR("Apple Inc.");
      return v14;
    }
    return 561211770;
  }
  if (v15 == 1870098020)
    goto LABEL_11;
  if (v15 != 1969841252)
    return v14;
  if (a5 > 3 && a3 == 8 && a4)
  {
    v16 = *(NSObject **)(DerivedStorage + 32);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __brokeredPlugin_GetPropertyData_block_invoke_2;
    block[3] = &__block_descriptor_tmp_11;
    block[4] = DerivedStorage;
    block[5] = a4;
    block[6] = a7;
    dispatch_sync(v16, block);
    v14 = 0;
    *a6 = 4;
    return v14;
  }
  return FigSignalErrorAt(561211770, 0, 0, 0, 0, 0, 0);
}

uint64_t brokeredPlugin_SetPropertyData()
{
  return 2003332927;
}

uint64_t brokeredPlugin_Initialize(const void *a1, uint64_t a2)
{
  _QWORD *DerivedStorage;
  void (*v5)(_QWORD, _QWORD, uint64_t, CFTypeRef *);
  _QWORD *v6;
  NSObject *v7;
  uint64_t result;
  uint64_t v9;
  uint64_t (*v10)(CFAllocatorRef, uint64_t);
  CFAllocatorRef v11;
  _QWORD block[6];
  CFTypeRef v13;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  *DerivedStorage = a2;
  v5 = (void (*)(_QWORD, _QWORD, uint64_t, CFTypeRef *))DerivedStorage[7];
  if (v5)
  {
    v6 = DerivedStorage;
    v13 = 0;
    v5(*MEMORY[0x1E0C9AE00], DerivedStorage[1], a2, &v13);
    if (v13)
    {
      v7 = v6[4];
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __brokeredPlugin_Initialize_block_invoke;
      block[3] = &__block_descriptor_tmp_12;
      block[4] = v6;
      block[5] = v13;
      dispatch_sync(v7, block);
      CFRelease(v13);
    }
  }
  result = brokeredPlugin_CreateDeviceBroker(a1);
  if (!(_DWORD)result)
  {
    v9 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    v10 = *(uint64_t (**)(CFAllocatorRef, uint64_t))(v9 + 64);
    if (!v10)
      return FigHALAudioDeviceBrokerRegister(*(const void **)(v9 + 16), *(const void **)(v9 + 24));
    v11 = CFGetAllocator(a1);
    result = v10(v11, v9 + 72);
    if (!(_DWORD)result)
      return FigHALAudioDeviceBrokerRegister(*(const void **)(v9 + 16), *(const void **)(v9 + 24));
  }
  return result;
}

void FigKTraceInit()
{
  if (initializeOnceToken != -1)
    dispatch_once_f(&initializeOnceToken, 0, (dispatch_function_t)fig_ktrace_initialize);
}

uint64_t fig_ktrace_initialize()
{
  uint64_t result;

  gGMFigKTraceEnabled = FigGetCFPreferenceNumberWithDefault(CFSTR("gm_ktrace"), CFSTR("com.apple.coremedia"), 1);
  result = FigGetCFPreferenceNumberWithDefault(CFSTR("gm_signpost"), CFSTR("com.apple.coremedia"), 0);
  gFigUseSignposts = result;
  return result;
}

const char *fig_gm_ktrace_wrapper(uint64_t a1, int a2, const char *a3, const char *a4, const char *a5, const char *a6, uint64_t a7, uint64_t a8, const char *a9)
{
  const char *result;

  if ((_DWORD)a3 != 3)
  {
    result = fig_trace_point_arg_to_ktrace_arg(a3, &a9);
    if ((_DWORD)a4 != 3)
    {
      result = fig_trace_point_arg_to_ktrace_arg(a4, &a9);
      if ((_DWORD)a5 != 3)
      {
        result = fig_trace_point_arg_to_ktrace_arg(a5, &a9);
        if ((_DWORD)a6 != 3)
          result = fig_trace_point_arg_to_ktrace_arg(a6, &a9);
      }
    }
  }
  if (a2 == 2)
  {
    if (gGMFigKTraceEnabled == 1)
      return (const char *)kdebug_trace();
  }
  else
  {
    if (a2 == 1)
    {
      if (gGMFigKTraceEnabled != 1)
        return result;
      return (const char *)kdebug_trace();
    }
    if (!a2 && gGMFigKTraceEnabled == 1)
      return (const char *)kdebug_trace();
  }
  return result;
}

const char *fig_trace_point_arg_to_ktrace_arg(const char *result, const char **a2)
{
  char __dst[8];

  if ((_DWORD)result == 2)
  {
    strncpy(__dst, *a2, 8uLL);
    return *(const char **)__dst;
  }
  else if (result <= 1)
  {
    return *a2;
  }
  return result;
}

uint64_t FigEndpointManagerRemoteCreateWithType(const void *a1, CFTypeRef *a2)
{
  uint64_t v2;
  const __CFAllocator *v5;
  _QWORD *ClassID;
  uint64_t v7;
  _QWORD *DerivedStorage;
  dispatch_queue_t v9;
  CFMutableDictionaryRef Mutable;
  dispatch_queue_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int IsAppleTV;
  NSObject *v16;
  uint64_t v18;
  uint64_t v19;
  CFTypeRef cf;
  uint64_t block;
  uint64_t v22;
  void (*v23)(_QWORD *);
  void *v24;
  uint64_t v25;
  _QWORD *v26;
  const __CFString *v27;

  v19 = 0;
  cf = 0;
  v2 = 4294950586;
  v18 = 0;
  if (a1 && a2)
  {
    if (remoteXPCFigEndpointManager_initializeLogging_initLoggingOnce != -1)
      dispatch_once(&remoteXPCFigEndpointManager_initializeLogging_initLoggingOnce, &__block_literal_global_11);
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    ClassID = (_QWORD *)FigEndpointManagerGetClassID();
    v7 = CMDerivedObjectCreate((uint64_t)v5, (uint64_t)&kFigEndpointManagerRemoteXPC_EndpointVTable, ClassID, &cf);
    if (!(_DWORD)v7)
    {
      DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      v9 = dispatch_queue_create("com.apple.coremedia.remoteendpointmgr.state", 0);
      DerivedStorage[2] = v9;
      if (v9
        && (Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
            (DerivedStorage[3] = Mutable) != 0)
        && (v11 = dispatch_queue_create("com.apple.coremedia.remoteendpointmgr.notification", 0),
            (DerivedStorage[8] = v11) != 0))
      {
        v7 = FigEndpointRPCCacheCreate(DerivedStorage + 4, 1);
        if (!(_DWORD)v7)
        {
          v7 = remoteXPCEndpointManager_ResetCachedAvailableEndpoints((uint64_t)DerivedStorage);
          if (!(_DWORD)v7)
          {
            v12 = *MEMORY[0x1E0C9AE40];
            v13 = DerivedStorage[2];
            v14 = MEMORY[0x1E0C809B0];
            block = MEMORY[0x1E0C809B0];
            v22 = 0x40000000;
            v23 = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
            v24 = &__block_descriptor_tmp_18;
            v25 = v12;
            v26 = DerivedStorage;
            v27 = CFSTR("EndpointPresent");
            dispatch_sync(v13, &block);
            DerivedStorage[5] = 0;
            *DerivedStorage = CFRetain(a1);
            IsAppleTV = CelestialIsAppleTV();
            if (!FigEndpointManagerGetSupportedFeatures(a1, IsAppleTV, &v19))
              remoteXPCEndpointManager_SetCachedPropertyInt64((uint64_t)DerivedStorage, (uint64_t)CFSTR("SupportedFeatures"), v19);
            if (!FigEndpointManagerGetSupportedDiscoveryFeatures(a1, &v18))
              remoteXPCEndpointManager_SetCachedPropertyInt64((uint64_t)DerivedStorage, (uint64_t)CFSTR("SupportedDiscoveryFeatures"), v18);
            v16 = DerivedStorage[2];
            block = v14;
            v22 = 0x40000000;
            v23 = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
            v24 = &__block_descriptor_tmp_18;
            v25 = v12;
            v26 = DerivedStorage;
            v27 = CFSTR("EndpointPresent");
            dispatch_sync(v16, &block);
            v2 = 0;
            *a2 = cf;
            return v2;
          }
        }
      }
      else
      {
        v7 = FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
      }
    }
    v2 = v7;
  }
  if (cf)
    CFRelease(cf);
  return v2;
}

uint64_t remoteXPCEndpointManager_ResetCachedAvailableEndpoints(uint64_t a1)
{
  CFArrayRef v2;
  CFArrayRef v3;
  NSObject *v4;
  _QWORD block[7];

  v2 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  if (!v2)
    return FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
  v3 = v2;
  v4 = *(NSObject **)(a1 + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
  block[3] = &__block_descriptor_tmp_18;
  block[4] = v3;
  block[5] = a1;
  block[6] = CFSTR("AvailableEndpoints");
  dispatch_sync(v4, block);
  CFRelease(v3);
  return 0;
}

void remoteXPCEndpointManager_SetCachedPropertyInt64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFNumberRef SInt64;
  NSObject *v6;
  _QWORD block[7];

  SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3);
  v6 = *(NSObject **)(a1 + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
  block[3] = &__block_descriptor_tmp_18;
  block[4] = SInt64;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync(v6, block);
  if (SInt64)
    CFRelease(SInt64);
}

uint64_t FigEndpointManagerRemoteCopyAirPlayManager(CFTypeRef *a1)
{
  uint64_t v2;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  int v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (FigEndpointManagerRemoteCopyAirPlayManager_sCreateOnce != -1)
      dispatch_once(&FigEndpointManagerRemoteCopyAirPlayManager_sCreateOnce, &__block_literal_global);
    v2 = FigEndpointManagerRemoteCopyAirPlayManager_sCreationResult;
    if (!FigEndpointManagerRemoteCopyAirPlayManager_sCreationResult)
    {
      *a1 = CFRetain((CFTypeRef)FigEndpointManagerRemoteCopyAirPlayManager_sAirPlayManager);
      return v2;
    }
  }
  else
  {
    v2 = FigSignalErrorAt(4294950586, 0, 0, 0, 0, 0, 0);
    if (!(_DWORD)v2)
      return v2;
  }
  v10[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v7 = v5;
  else
    v7 = v5 & 0xFFFFFFFE;
  if (v7)
  {
    v10[1] = 136315394;
    v11 = "FigEndpointManagerRemoteCopyAirPlayManager";
    v12 = 1024;
    v13 = v2;
    v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
  return v2;
}

uint64_t FigEndpointManagerRemoteCopyCarPlayManager(CFTypeRef *a1)
{
  uint64_t v2;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  int v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (FigEndpointManagerRemoteCopyCarPlayManager_sCreateOnce != -1)
      dispatch_once(&FigEndpointManagerRemoteCopyCarPlayManager_sCreateOnce, &__block_literal_global_5);
    v2 = FigEndpointManagerRemoteCopyCarPlayManager_sCreationResult;
    if (!FigEndpointManagerRemoteCopyCarPlayManager_sCreationResult)
    {
      *a1 = CFRetain((CFTypeRef)FigEndpointManagerRemoteCopyCarPlayManager_sCarPlayManager);
      return v2;
    }
  }
  else
  {
    v2 = 4294950586;
  }
  v10[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v7 = v5;
  else
    v7 = v5 & 0xFFFFFFFE;
  if (v7)
  {
    v10[1] = 136315394;
    v11 = "FigEndpointManagerRemoteCopyCarPlayManager";
    v12 = 1024;
    v13 = v2;
    v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
  return v2;
}

uint64_t FigEndpointManagerRemoteCopyNeroManager(CFTypeRef *a1)
{
  uint64_t v2;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  int v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (FigEndpointManagerRemoteCopyNeroManager_sCreateOnce != -1)
      dispatch_once(&FigEndpointManagerRemoteCopyNeroManager_sCreateOnce, &__block_literal_global_7);
    v2 = FigEndpointManagerRemoteCopyNeroManager_sCreationResult;
    if (!FigEndpointManagerRemoteCopyNeroManager_sCreationResult)
    {
      *a1 = CFRetain((CFTypeRef)FigEndpointManagerRemoteCopyNeroManager_sNeroManager);
      return v2;
    }
  }
  else
  {
    v2 = 4294950586;
  }
  v10[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v7 = v5;
  else
    v7 = v5 & 0xFFFFFFFE;
  if (v7)
  {
    v10[1] = 136315394;
    v11 = "FigEndpointManagerRemoteCopyNeroManager";
    v12 = 1024;
    v13 = v2;
    v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
  return v2;
}

uint64_t FigEndpointManagerRemoteCopySidePlayManager(CFTypeRef *a1)
{
  uint64_t v2;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  int v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (FigEndpointManagerRemoteCopySidePlayManager_sCreateOnce != -1)
      dispatch_once(&FigEndpointManagerRemoteCopySidePlayManager_sCreateOnce, &__block_literal_global_9);
    v2 = FigEndpointManagerRemoteCopySidePlayManager_sCreationResult;
    if (!FigEndpointManagerRemoteCopySidePlayManager_sCreationResult)
    {
      *a1 = CFRetain((CFTypeRef)FigEndpointManagerRemoteCopySidePlayManager_sSidePlayManager);
      return v2;
    }
  }
  else
  {
    v2 = 4294950586;
  }
  v10[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v7 = v5;
  else
    v7 = v5 & 0xFFFFFFFE;
  if (v7)
  {
    v10[1] = 136315394;
    v11 = "FigEndpointManagerRemoteCopySidePlayManager";
    v12 = 1024;
    v13 = v2;
    v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
  return v2;
}

void FigEndpointManagerRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  NSObject *v17;
  NSObject *v18;
  os_log_type_t type;
  int v20;
  uint64_t v21[3];
  uint64_t v22[17];

  v22[16] = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v20 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v20, &type);
  v4 = v20;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v6 = v4;
  else
    v6 = v4 & 0xFFFFFFFE;
  if (v6)
  {
    LODWORD(v21[0]) = 136315138;
    *(uint64_t *)((char *)v21 + 4) = (uint64_t)"FigEndpointManagerRemoteXPC_Finalize";
    v7 = (uint64_t *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v20;
  }
  else
  {
    v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != v22, v4, 0, v5);
  v8 = CMBaseObjectGetDerivedStorage(a1);
  v22[0] = 0;
  v21[0] = 0;
  v9 = *(const void **)(v8 + 40);
  if (!v9 || (v10 = v8, remoteXPCEndpointManager_getSharedXPCClient(v21)))
  {
    v13 = 0;
  }
  else
  {
    FigEndpointRPCCacheRemoveAllEndpoints(*(_QWORD *)(v10 + 32));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v10 + 24));
    v11 = v21[0];
    FigXPCRemoteClientDisassociateObject(v21[0], v9);
    v12 = FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v9, v22);
    v13 = (void *)v22[0];
    if (!v12)
    {
      FigXPCRemoteClientSendSyncMessage(v11, v22[0]);
      v13 = (void *)v22[0];
    }
  }
  FigXPCRelease(v13);
  NeroValeriaListenerDestroy(*(CFTypeRef **)(DerivedStorage + 8));
  FigEndpointRPCCacheDispose(*(_QWORD **)(DerivedStorage + 32));
  v14 = *(const void **)(DerivedStorage + 24);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(DerivedStorage + 24) = 0;
  }
  v15 = *(const void **)(DerivedStorage + 48);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(DerivedStorage + 48) = 0;
  }
  v16 = *(const void **)(DerivedStorage + 56);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(DerivedStorage + 56) = 0;
  }
  if (*(_QWORD *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(_QWORD *)DerivedStorage = 0;
  }
  v17 = *(NSObject **)(DerivedStorage + 16);
  if (v17)
  {
    dispatch_release(v17);
    *(_QWORD *)(DerivedStorage + 16) = 0;
  }
  v18 = *(NSObject **)(DerivedStorage + 64);
  if (v18)
  {
    dispatch_release(v18);
    *(_QWORD *)(DerivedStorage + 64) = 0;
  }
}

uint64_t FigEndpointManagerRemoteXPC_CopyProperty(uint64_t a1, const __CFString *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t DerivedStorage;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  const void *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  xpc_object_t value;
  xpc_object_t v18;
  char v19;
  NSObject *v20;
  NSObject *v21;
  void *v22;
  const void *v23;
  NSObject *v24;
  uint64_t v26;
  CFTypeRef cf;
  uint64_t v28;
  uint64_t block;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t *v33;
  uint64_t *v34;
  const __CFString *v35;
  xpc_object_t v36;
  xpc_object_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  xpc_object_t xdict;
  xpc_object_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;

  v28 = 0;
  v26 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(CFSTR("Name"), a2))
  {
    v8 = 0;
    cf = CFRetain(*(CFTypeRef *)DerivedStorage);
    goto LABEL_23;
  }
  v46 = 0;
  v47 = &v46;
  v48 = 0x2000000000;
  v49 = 0;
  v9 = *(NSObject **)(DerivedStorage + 16);
  v10 = MEMORY[0x1E0C809B0];
  block = MEMORY[0x1E0C809B0];
  v30 = 0x40000000;
  v31 = __remoteXPCEndpointManager_CopyCachedProperty_block_invoke;
  v32 = &unk_1E28D7958;
  v33 = &v46;
  v34 = (uint64_t *)DerivedStorage;
  v35 = a2;
  dispatch_sync(v9, &block);
  v11 = (const void *)v47[3];
  _Block_object_dispose(&v46, 8);
  cf = v11;
  if (v11)
    goto LABEL_4;
  v12 = remoteXPCEndpointManager_ensureConnected(a1, &v26, &v28);
  if ((_DWORD)v12)
    goto LABEL_29;
  if (!CFEqual(CFSTR("AvailableEndpoints"), a2))
  {
    v12 = FigXPCSendStdCopyPropertyMessage(v26, v28, a2, &cf);
    if (!(_DWORD)v12)
    {
      if (CFEqual(CFSTR("EndpointPresent"), a2))
      {
        v20 = *(NSObject **)(DerivedStorage + 16);
        block = v10;
        v30 = 0x40000000;
        v31 = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
        v32 = &__block_descriptor_tmp_18;
        v33 = (uint64_t *)cf;
        v34 = (uint64_t *)DerivedStorage;
        v35 = a2;
        dispatch_sync(v20, &block);
      }
LABEL_4:
      v8 = 0;
      goto LABEL_23;
    }
    goto LABEL_29;
  }
  v12 = FigEndpointXPCRemotePing();
  if ((_DWORD)v12)
  {
LABEL_29:
    v8 = v12;
    goto LABEL_23;
  }
  v46 = 0;
  v47 = &v46;
  v48 = 0x2000000000;
  LODWORD(v49) = 0;
  v44 = 0;
  v45 = 0;
  v42 = 0;
  xdict = 0;
  v39 = 0;
  v40 = &v39;
  v41 = 0x2000000000;
  v38 = 0;
  v13 = remoteXPCEndpointManager_ensureConnected(a1, &v38, &v45);
  *((_DWORD *)v47 + 6) = v13;
  if (v13
    || (v14 = CMBaseObjectGetDerivedStorage(a1),
        v15 = FigXPCCreateBasicMessage(0x6176616Cu, v45, &v44),
        (*((_DWORD *)v47 + 6) = v15) != 0)
    || (v16 = FigXPCRemoteClientSendSyncMessageCreatingReply(v38, (uint64_t)v44, &xdict),
        (*((_DWORD *)v47 + 6) = v16) != 0))
  {
    v22 = 0;
    goto LABEL_20;
  }
  value = xpc_dictionary_get_value(xdict, "AddedEndpoints");
  v18 = xpc_dictionary_get_value(xdict, "SubtractedEndpoints");
  if (v18)
  {
    v19 = 1;
LABEL_18:
    NeroValeriaListenerSetActiveStatus(*(_QWORD *)(v14 + 8), v19);
    goto LABEL_19;
  }
  if (value)
  {
    v19 = 0;
    goto LABEL_18;
  }
LABEL_19:
  v21 = *(NSObject **)(v14 + 16);
  block = v10;
  v30 = 0x40000000;
  v31 = __remoteXPCEndpointManager_CopyAvailableEndpoints_block_invoke;
  v32 = &unk_1E28D79A8;
  v35 = (const __CFString *)v14;
  v36 = value;
  v37 = v18;
  v33 = &v46;
  v34 = &v39;
  dispatch_sync(v21, &block);
  v22 = (void *)v40[3];
  cf = v22;
  v40[3] = 0;
LABEL_20:
  v23 = (const void *)v40[3];
  if (v23)
    CFRelease(v23);
  FigXPCRelease(v44);
  FigXPCRelease(xdict);
  v8 = *((unsigned int *)v47 + 6);
  _Block_object_dispose(&v39, 8);
  _Block_object_dispose(&v46, 8);
  v24 = *(NSObject **)(DerivedStorage + 16);
  block = v10;
  v30 = 0x40000000;
  v31 = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
  v32 = &__block_descriptor_tmp_18;
  v33 = (uint64_t *)v22;
  v34 = (uint64_t *)DerivedStorage;
  v35 = CFSTR("AvailableEndpoints");
  dispatch_sync(v24, &block);
LABEL_23:
  if (a4)
  {
    *a4 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v8;
}

uint64_t FigEndpointManagerRemoteXPC_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = 0;
  result = remoteXPCEndpointManager_ensureConnected(a1, &v6, &v7);
  if (!(_DWORD)result)
    return FigXPCSendStdSetPropertyMessage(v6, v7, a2, a3);
  return result;
}

uint64_t remoteXPCEndpointManager_getSharedXPCClient(uint64_t *a1)
{
  uint64_t v2;
  BOOL v3;
  __CFDictionary *Mutable;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v6;
  uint64_t v7;
  _BYTE *v9;
  NSObject *v10;
  unsigned int v11;
  uint64_t v12;
  _BYTE *v14;
  os_log_type_t type;
  unsigned int v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  _BYTE v22[128];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock(&remoteXPCEndpointManager_getSharedXPCClient_lock);
  v2 = remoteXPCEndpointManager_getSharedXPCClient_sSharedClient;
  if (remoteXPCEndpointManager_getSharedXPCClient_err)
    v3 = 1;
  else
    v3 = remoteXPCEndpointManager_getSharedXPCClient_sSharedClient == 0;
  if (!v3)
    goto LABEL_21;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_DeathNoticeName"), CFSTR("EndpointManager_ServerConnectionDied"));
  CFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_PrivilegedConnection"), (const void *)*MEMORY[0x1E0C9AE50]);
  v17 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v17, &type);
  v6 = v17;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type) ? v6 : v6 & 0xFFFFFFFE)
  {
    v18 = 136315138;
    v19 = "remoteXPCEndpointManager_getSharedXPCClient";
    v9 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v6) = v17;
  }
  else
  {
    v9 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v9, v9 != v22, v6, 0, v7);
  remoteXPCEndpointManager_getSharedXPCClient_err = FigXPCRemoteClientCreate((uint64_t)"com.apple.coremedia.endpointmanager.xpc", (uint64_t)&remoteXPCEndpointManager_getSharedXPCClient_clientCallbacks, Mutable, &remoteXPCEndpointManager_getSharedXPCClient_sSharedClient);
  v17 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v17, &type);
  v11 = v17;
  if (os_log_type_enabled(v10, type) ? v11 : v11 & 0xFFFFFFFE)
  {
    v18 = 136315394;
    v19 = "remoteXPCEndpointManager_getSharedXPCClient";
    v20 = 1024;
    v21 = remoteXPCEndpointManager_getSharedXPCClient_err;
    v14 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v11) = v17;
  }
  else
  {
    v14 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v14, v14 != v22, v11, 0, v12);
  if (Mutable)
    CFRelease(Mutable);
  v2 = remoteXPCEndpointManager_getSharedXPCClient_sSharedClient;
  if (!remoteXPCEndpointManager_getSharedXPCClient_sSharedClient)
    FigSignalErrorAt(remoteXPCEndpointManager_getSharedXPCClient_err, 0, 0, 0, 0, 0, 0);
  else
LABEL_21:
    *a1 = v2;
  os_unfair_lock_unlock(&remoteXPCEndpointManager_getSharedXPCClient_lock);
  return remoteXPCEndpointManager_getSharedXPCClient_err;
}

void remoteXPCEndpointManagerClient_DeadConnectionCallback(const void *a1)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  _QWORD *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  CFNotificationCenterRef DefaultLocalCenter;
  NSObject *v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD block[6];
  os_log_type_t type;
  int v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  _QWORD v32[17];

  v32[16] = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v26 = 0;
  v27 = 0;
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v22 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v22, &type);
  v4 = v22;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v6 = v4;
  else
    v6 = v4 & 0xFFFFFFFE;
  if (v6)
  {
    v28 = 136315138;
    v29 = "remoteXPCEndpointManagerClient_DeadConnectionCallback";
    v7 = (_QWORD *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v22;
  }
  else
  {
    v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != v32, v4, 0, v5);
  v8 = *(NSObject **)(DerivedStorage + 16);
  v9 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointManagerClient_DeadConnectionCallback_block_invoke;
  block[3] = &unk_1E28D7930;
  block[4] = &v23;
  block[5] = DerivedStorage;
  dispatch_sync(v8, block);
  remoteXPCEndpointManager_ResetCachedAvailableEndpoints(DerivedStorage);
  v10 = *MEMORY[0x1E0C9AE40];
  v11 = *(NSObject **)(DerivedStorage + 16);
  v32[0] = v9;
  v32[1] = 0x40000000;
  v32[2] = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
  v32[3] = &__block_descriptor_tmp_18;
  v32[4] = v10;
  v32[5] = DerivedStorage;
  v32[6] = CFSTR("EndpointPresent");
  dispatch_sync(v11, v32);
  v12 = *(NSObject **)(DerivedStorage + 64);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification(v12, DefaultLocalCenter, CFSTR("EndpointManager_AvailableEndpointsChanged"), a1, 0, 0);
  if (!remoteXPCEndpointManager_getSharedXPCClient(&v27))
  {
    FigXPCRemoteClientDisassociateObject(v27, (const void *)v24[3]);
    v22 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v22, &type);
    v15 = v22;
    if (os_log_type_enabled(v14, type))
      v17 = v15;
    else
      v17 = v15 & 0xFFFFFFFE;
    if (v17)
    {
      v18 = v24[3];
      v28 = 136315394;
      v29 = "remoteXPCEndpointManagerClient_DeadConnectionCallback";
      v30 = 2048;
      v31 = v18;
      v19 = (_QWORD *)_os_log_send_and_compose_impl();
      LOBYTE(v15) = v22;
    }
    else
    {
      v19 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v19, v19 != v32, v15, 0, v16);
  }
  _Block_object_dispose(&v23, 8);
}

uint64_t remoteXPCEndpointManagerClient_NotificationFilter(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage;
  __CFString **v4;
  __CFString *v5;
  NSObject *v6;
  _QWORD block[7];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, CFSTR("EndpointManager_AvailableEndpointsChanged")))
  {
    v4 = kFigEndpointManagerProperty_AvailableEndpoints;
LABEL_5:
    v5 = *v4;
    v6 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __remoteXPCEndpointManager_SetCachedProperty_block_invoke;
    block[3] = &__block_descriptor_tmp_18;
    block[4] = 0;
    block[5] = DerivedStorage;
    block[6] = v5;
    dispatch_sync(v6, block);
    return 0;
  }
  if (CFEqual(a2, CFSTR("EndpointManager_EndpointPresentChanged")))
  {
    v4 = kFigEndpointManagerProperty_EndpointPresent;
    goto LABEL_5;
  }
  return 0;
}

uint64_t remoteXPCEndpointManager_ensureConnected(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[9];
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;

  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  v13 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  SharedXPCClient = remoteXPCEndpointManager_getSharedXPCClient(&v13);
  *((_DWORD *)v19 + 6) = SharedXPCClient;
  if ((_DWORD)SharedXPCClient)
  {
    v10 = SharedXPCClient;
  }
  else
  {
    v8 = *(NSObject **)(DerivedStorage + 16);
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = __remoteXPCEndpointManager_ensureConnected_block_invoke;
    v12[3] = &unk_1E28D7980;
    v9 = v13;
    v12[6] = DerivedStorage;
    v12[7] = v13;
    v12[4] = &v18;
    v12[5] = &v14;
    v12[8] = a1;
    dispatch_sync(v8, v12);
    v10 = *((unsigned int *)v19 + 6);
    if (!(_DWORD)v10)
    {
      if (a3)
        *a3 = v15[3];
      v10 = 0;
      if (a2)
        *a2 = v9;
    }
  }
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  return v10;
}

void __remoteXPCEndpointManager_ensureConnected_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  _BYTE *v14;
  uint64_t v15;
  const void *v16;
  os_log_type_t type;
  int v18;
  xpc_object_t xdict;
  int v20[2];
  int v21;
  const char *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  _BYTE v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  xdict = 0;
  *(_QWORD *)v20 = 0;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 40);
  if (v2)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v2;
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = FigXPCCreateBasicMessage(0x6765706Du, 0, v20);
    if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = FigXPCMessageSetCFString(*(void **)v20, "EndpointManagerType", **(CFTypeRef **)(a1 + 48));
      if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      {
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = FigXPCRemoteClientSendSyncMessageCreatingReply(*(_QWORD *)(a1 + 56), *(uint64_t *)v20, &xdict);
        if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
        {
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = xpc_dictionary_get_uint64(xdict, ".objectID");
          if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
          {
            v18 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v18, &type);
            v4 = v18;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
              v6 = v4;
            else
              v6 = v4 & 0xFFFFFFFE;
            if (v6)
            {
              v7 = **(_QWORD **)(a1 + 48);
              v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
              v21 = 136315650;
              v22 = "remoteXPCEndpointManager_ensureConnected_block_invoke";
              v23 = 2112;
              v24 = v7;
              v25 = 2048;
              v26 = v8;
              v9 = (_BYTE *)_os_log_send_and_compose_impl();
              LOBYTE(v4) = v18;
            }
            else
            {
              v9 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v9, v9 != v27, v4, 0, v5);
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = FigXPCRemoteClientAssociateObject(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24));
            if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
            {
              v15 = *(_QWORD *)(a1 + 48);
              *(_QWORD *)(v15 + 40) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
              v16 = *(const void **)(v15 + 48);
              if (v16)
                remoteXPCFigEndpointManager_sendSetDiscoveryMode(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), *(_QWORD *)(a1 + 56), v16, *(const void **)(v15 + 56));
            }
          }
          else
          {
            v18 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v18, &type);
            v11 = v18;
            if (os_log_type_enabled(v10, type))
              v13 = v11;
            else
              v13 = v11 & 0xFFFFFFFE;
            if (v13)
            {
              v21 = 136315138;
              v22 = "remoteXPCEndpointManager_ensureConnected_block_invoke";
              v14 = (_BYTE *)_os_log_send_and_compose_impl();
              LOBYTE(v11) = v18;
            }
            else
            {
              v14 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v14, v14 != v27, v11, 0, v12);
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
          }
        }
      }
    }
  }
  FigXPCRelease(xdict);
  FigXPCRelease(*(xpc_object_t *)v20);
}

uint64_t remoteXPCFigEndpointManager_sendSetDiscoveryMode(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t v7;
  uint64_t v8;
  int v10[2];

  *(_QWORD *)v10 = 0;
  v7 = FigXPCCreateBasicMessage(0x73646D20u, a1, v10);
  if (!(_DWORD)v7)
  {
    FigXPCMessageSetCFString(*(void **)v10, "DiscoveryMode", a3);
    FigXPCMessageSetCFDictionary(*(void **)v10, "DiscoveryOptions", a4);
    v7 = FigXPCRemoteClientSendSyncMessage(a2, *(uint64_t *)v10);
  }
  v8 = v7;
  FigXPCRelease(*(xpc_object_t *)v10);
  return v8;
}

uint64_t FigEndpointManagerRemoteXPC_SetDiscoveryMode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  _QWORD v11[10];
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  v12 = 0;
  v13 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v7 = remoteXPCEndpointManager_ensureConnected(a1, &v12, &v13);
  *((_DWORD *)v15 + 6) = v7;
  if ((_DWORD)v7)
  {
    v9 = v7;
  }
  else
  {
    v8 = *(NSObject **)(DerivedStorage + 16);
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 0x40000000;
    v11[2] = __FigEndpointManagerRemoteXPC_SetDiscoveryMode_block_invoke;
    v11[3] = &unk_1E28D79D0;
    v11[4] = &v14;
    v11[5] = v13;
    v11[6] = v12;
    v11[7] = a2;
    v11[8] = a3;
    v11[9] = DerivedStorage;
    dispatch_sync(v8, v11);
    v9 = *((unsigned int *)v15 + 6);
  }
  _Block_object_dispose(&v14, 8);
  return v9;
}

uint64_t FigEndpointManagerRemoteXPC_CreateEndpointAggregate(uint64_t a1, unsigned int a2, CFTypeRef *a3)
{
  uint64_t v5;
  uint64_t v6;
  CFTypeRef cf;
  uint64_t v9;
  xpc_object_t v10;
  xpc_object_t xdict;
  uint64_t v12;

  xdict = 0;
  v12 = 0;
  v9 = 0;
  v10 = 0;
  cf = 0;
  v5 = remoteXPCEndpointManager_ensureConnected(a1, &v9, &v12);
  if ((_DWORD)v5
    || (v5 = FigXPCCreateBasicMessage(0x63726561u, v12, &xdict), (_DWORD)v5)
    || (xpc_dictionary_set_uint64(xdict, "EndpointAggregateType", a2),
        v5 = FigXPCRemoteClientSendSyncMessageCreatingReply(v9, (uint64_t)xdict, &v10),
        (_DWORD)v5))
  {
    v6 = v5;
  }
  else
  {
    v6 = (uint64_t)FigEndpointXPCRemoteRetainCopiedEndpointFromReply(v10, 0, &cf);
    if (!(_DWORD)v6)
    {
      *a3 = cf;
      cf = 0;
    }
  }
  FigXPCRelease(xdict);
  FigXPCRelease(v10);
  if (cf)
    CFRelease(cf);
  return v6;
}

uint64_t FigEndpointManagerRemoteXPC_CopyEndpointRemoteControlDepot(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  CFTypeRef cf;
  uint64_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  uint64_t v10;

  v10 = 0;
  v8 = 0;
  v9 = 0;
  cf = 0;
  v7 = 0;
  if (a2)
  {
    v3 = remoteXPCEndpointManager_ensureConnected(a1, &v7, &v10);
    if ((_DWORD)v3
      || (v3 = FigXPCCreateBasicMessage(0x65726364u, v10, &v9), (_DWORD)v3)
      || (v3 = FigXPCRemoteClientSendSyncMessageCreatingReply(v7, (uint64_t)v9, &v8), (_DWORD)v3))
    {
      v4 = v3;
    }
    else
    {
      v4 = (uint64_t)FigEndpointXPCRemoteRetainCopiedEndpointFromReply(v8, 0, &cf);
      if (!(_DWORD)v4)
      {
        *a2 = cf;
        cf = 0;
      }
    }
  }
  else
  {
    v4 = 4294950586;
  }
  FigXPCRelease(v9);
  FigXPCRelease(v8);
  if (cf)
    CFRelease(cf);
  return v4;
}

void __remoteXPCEndpointManager_startListeningForValeriaConnections_block_invoke(uint64_t a1)
{
  uint64_t CMBaseObject;
  uint64_t (*v2)(uint64_t, const __CFString *, _QWORD);
  int v3;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  int v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  CMBaseObject = FigEndpointManagerGetCMBaseObject(*(_QWORD *)(a1 + 32));
  v2 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                 + 8)
                                                                     + 56);
  if (v2)
  {
    v3 = v2(CMBaseObject, CFSTR("ValeriaConnected"), *MEMORY[0x1E0C9AE50]);
    if (!v3)
      return;
  }
  else
  {
    v3 = -12782;
  }
  v10[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
  v5 = v10[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v7 = v5;
  else
    v7 = v5 & 0xFFFFFFFE;
  if (v7)
  {
    v10[1] = 136315394;
    v11 = "remoteXPCEndpointManager_startListeningForValeriaConnections_block_invoke";
    v12 = 1024;
    v13 = v3;
    v8 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v5) = v10[0];
  }
  else
  {
    v8 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v14, v5, 0, v6);
}

uint64_t FigWatchdogMonitorDispatchQueue(uint64_t a1)
{
  uint64_t v2;

  if (a1)
  {
    if ((sDidRegisterWatchdogClient & 1) != 0)
    {
      wd_endpoint_add_queue();
      return 0;
    }
    v2 = 4294949365;
  }
  else
  {
    v2 = 4294949366;
  }
  return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
}

uint64_t FigWatchdogBeginVitalWork(const char *a1, uint64_t *a2)
{
  uint64_t v4;
  const __CFAllocator *v5;
  CFNumberRef SInt64;
  CFStringRef v7;
  uint64_t v9;

  if (!a1 || !a2)
  {
    v9 = 4294949366;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  if ((sDidRegisterWatchdogClient & 1) == 0)
  {
    v9 = 4294949365;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexLock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
  v4 = sNextVitalWorkID++;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v4);
  v7 = CFStringCreateWithCString(v5, a1, 0x8000100u);
  CFDictionarySetValue((CFMutableDictionaryRef)sVitalWorkDescriptions, SInt64, v7);
  ++sVitalWorkSectionsInProgress;
  FigSimpleMutexUnlock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
  *a2 = v4;
  if (SInt64)
    CFRelease(SInt64);
  if (v7)
    CFRelease(v7);
  return 0;
}

uint64_t FigWatchdogCompleteVitalWork(uint64_t a1)
{
  CFNumberRef SInt64;
  uint64_t v4;

  if (a1 <= 0)
  {
    v4 = 4294949366;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if ((sDidRegisterWatchdogClient & 1) == 0)
  {
    v4 = 4294949365;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexLock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
  SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1);
  CFDictionaryRemoveValue((CFMutableDictionaryRef)sVitalWorkDescriptions, SInt64);
  --sVitalWorkSectionsInProgress;
  FigSimpleMutexUnlock((pthread_mutex_t *)sVitalWorkDescriptionMutex);
  if (SInt64)
    CFRelease(SInt64);
  return 0;
}

uint64_t FigWatchdogStart(uint64_t a1)
{
  if (!a1)
    return FigSignalErrorAt(4294949366, 0, 0, 0, 0, 0, 0);
  if ((sDidRegisterWatchdogClient & 1) == 0)
  {
    sVitalWorkDescriptionMutex = (uint64_t)FigSimpleMutexCreate();
    sVitalWorkDescriptions = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    wd_endpoint_register();
    wd_endpoint_set_alive_func();
    wd_endpoint_activate();
    sDidRegisterWatchdogClient = 1;
  }
  return 0;
}

CFStringRef FigBaseObjectCopyDebugDescription(_QWORD *cf)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD *);
  CFStringRef result;
  const __CFAllocator *v5;
  CFAllocatorRef v6;

  v2 = cf[3];
  v3 = *(uint64_t (**)(_QWORD *))(*(_QWORD *)(v2 + 8) + 40);
  if (v3)
  {
    result = (CFStringRef)v3(cf);
    if (result)
      return result;
    v2 = cf[3];
  }
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = CFGetAllocator(cf);
  return CFStringCreateWithFormat(v5, 0, CFSTR("<CMBaseObject: instance<%p> storage<%p> class<%p> allocator<%p>>"), cf, cf + 4, v2, v6);
}

uint64_t FigBaseProtocolRegisterProtocol(__int128 *a1, uint64_t a2, _QWORD *a3)
{
  malloc_zone_t *MallocZoneForPermanentAllocations;
  char *v6;
  __int128 v7;
  uint64_t v9;

  if (a1 && a3)
  {
    MallocZoneForPermanentAllocations = (malloc_zone_t *)FigGetMallocZoneForPermanentAllocations();
    v6 = (char *)malloc_type_zone_calloc(MallocZoneForPermanentAllocations, 1uLL, 0x28uLL, 0x1070040C4A17F08uLL);
    if (v6)
    {
      *(_QWORD *)v6 = 0;
      v7 = *a1;
      *(_OWORD *)(v6 + 24) = a1[1];
      *(_OWORD *)(v6 + 8) = v7;
      *a3 = v6;
      return 0;
    }
    v9 = 4294954510;
  }
  else
  {
    v9 = 4294954516;
  }
  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t CMDerivedObjectCreate(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  unint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *Instance;
  const void *v12;
  uint64_t v13;
  CFNotificationCenterRef DefaultLocalCenter;
  uint64_t v15;
  uint64_t v16;

  if (!a2 || !a4)
    goto LABEL_10;
  v6 = **(_QWORD **)(a2 + 8);
  if (!v6 || v6 >= 6)
  {
    v9 = 4294954515;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  if (*(_QWORD *)a2 || !a3)
  {
LABEL_10:
    v9 = 4294954516;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  v8 = a3;
  while (!v8[14])
  {
    v8 = (_QWORD *)*v8;
    if (!v8)
      goto LABEL_10;
  }
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (!Instance)
  {
    v9 = 4294954510;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  v12 = Instance;
  Instance[2] = a3;
  Instance[3] = a2;
  bzero(Instance + 4, *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8));
  v13 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)v13 >= 2uLL
    && *(uint64_t (**)(uint64_t))(v13 + 64) == FigBaseObjectStandardNotificationBarrier
    && (DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter(),
        v15 = CMNotificationCenterRegisterForBarrierSupport((uint64_t)DefaultLocalCenter, (uint64_t)v12),
        (_DWORD)v15))
  {
    v16 = v15;
    CFRelease(v12);
  }
  else
  {
    v16 = 0;
    *a4 = v12;
  }
  return v16;
}

uint64_t FigBaseObjectStandardNotificationBarrier(uint64_t a1)
{
  CFNotificationCenterRef DefaultLocalCenter;

  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return CMNotificationCenterBarrier((uint64_t)DefaultLocalCenter, a1);
}

uint64_t CMBaseObjectGetVTable(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t CMBaseObjectGetProtocolVTable(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t i;
  uint64_t (*v11)(uint64_t);

  result = 0;
  if (a1 && a2)
  {
    v5 = *(_QWORD *)(a1 + 24);
    if (v5)
    {
      v6 = *(_QWORD **)(v5 + 8);
      if (*v6 >= 3uLL)
      {
        v7 = v6[9];
        if (v7)
        {
          v8 = *(unsigned int *)(v7 + 4);
          if ((_DWORD)v8)
          {
            v9 = 0;
            for (i = 0; i < v8; ++i)
            {
              v11 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v7 + 8) + v9);
              if (v11)
              {
                result = v11(result);
                if (result == a2)
                  return *(_QWORD *)(*(_QWORD *)(v7 + 8) + v9 + 8);
                v8 = *(unsigned int *)(v7 + 4);
              }
              v9 += 16;
            }
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t CMBaseObjectGetDerivedStorage(uint64_t a1)
{
  if (a1)
    return a1 + 32;
  else
    return 0;
}

uint64_t CMBaseObjectGetClassID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t CMBaseClassGetCFTypeID(_QWORD *a1)
{
  uint64_t v1;

  if (!a1)
    return 0;
  while (1)
  {
    v1 = a1[14];
    if (v1)
      break;
    a1 = (_QWORD *)*a1;
    if (!a1)
      return 0;
  }
  return v1;
}

uint64_t CMBaseObjectIsMemberOfClass(char *cf, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;

  if (!a2)
    goto LABEL_7;
  v4 = a2;
  while (1)
  {
    v5 = v4[14];
    if (v5)
      break;
    v4 = (_QWORD *)*v4;
    if (!v4)
      goto LABEL_7;
  }
  if (v5 == CFGetTypeID(cf))
  {
LABEL_7:
    v6 = cf + 16;
    while (1)
    {
      v6 = (_QWORD *)*v6;
      if (!v6)
        break;
      if (v6 == a2)
        return 1;
    }
  }
  return 0;
}

BOOL CFTypeIsCMBaseObject(const void *a1)
{
  CFGetTypeID(a1);
  return *(_QWORD *)(_CFRuntimeGetClassWithTypeID() + 16) == (_QWORD)FigBaseObjectInit;
}

void *CMBaseGetClassID()
{
  return &kFigBaseClassID;
}

BOOL CMBaseObjectImplementsProtocol(uint64_t a1, uint64_t a2)
{
  return CMBaseObjectGetProtocolVTable(a1, a2) != 0;
}

__CFString *CMBaseProtocolCopyDebugDescription(const void *a1, uint64_t a2)
{
  uint64_t ProtocolVTable;
  __CFString *Mutable;
  CFAllocatorRef v6;
  uint64_t v7;
  uint64_t (*v8)(const void *);
  uint64_t v9;
  const void *v10;

  ProtocolVTable = CMBaseObjectGetProtocolVTable((uint64_t)a1, a2);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v6 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CMBaseProtocol on CMBaseObject: protocol<%p> instance<%p> allocator<%p>>{"), a2, a1, v6);
  if (ProtocolVTable
    && (v7 = *(_QWORD *)(ProtocolVTable + 8)) != 0
    && (v8 = *(uint64_t (**)(const void *))(v7 + 8)) != 0
    && (v9 = v8(a1)) != 0)
  {
    v10 = (const void *)v9;
    CFStringAppendFormat(Mutable, 0, CFSTR("\n%@\n"), v9);
    CFRelease(v10);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("UNIMPLEMENTED"));
  }
  CFStringAppend(Mutable, CFSTR("}"));
  return Mutable;
}

uint64_t FigBaseObjectGetClassID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t FigBaseClassGetCFTypeID(_QWORD *a1)
{
  uint64_t v1;

  if (!a1)
    return 0;
  while (1)
  {
    v1 = a1[14];
    if (v1)
      break;
    a1 = (_QWORD *)*a1;
    if (!a1)
      return 0;
  }
  return v1;
}

uint64_t _FigEnsureReadyToCollectIncrementalCoverageData(uint64_t a1)
{
  uint64_t v2;
  const __CFString *v3;
  CFMutableStringRef MutableCopy;
  uint64_t v6;
  CFIndex Length;
  CFIndex v8;
  uint64_t v9;
  __int128 v10;
  CFRange result;
  CFStringRef theString;
  CFRange v13;
  CFRange v14;

  if (!a1)
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
  theString = 0;
  v10 = xmmword_18EDDC880;
  result = (CFRange)xmmword_18EDDC880;
  v2 = FigCopyCoverageFilePathPattern(&theString);
  v3 = theString;
  if (!(_DWORD)v2)
  {
    if (theString)
    {
      if (CFStringFind(theString, CFSTR("%m"), 4uLL).location != -1)
      {
        MutableCopy = 0;
        goto LABEL_18;
      }
    }
    else
    {
      FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
    }
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v3);
    v13.length = CFStringGetLength(MutableCopy);
    v13.location = 0;
    if (!CFStringFindWithOptions(MutableCopy, CFSTR("/"), v13, 4uLL, &result))
    {
      v9 = FigSignalErrorAt(4294949394, 0, 0, 0, 0, 0, 0);
LABEL_19:
      v6 = v9;
      if (MutableCopy)
      {
        CFRelease(MutableCopy);
        v3 = theString;
      }
      goto LABEL_21;
    }
    Length = CFStringGetLength(MutableCopy);
    v14.location = result.location;
    v14.length = Length - result.location;
    result.length = Length - result.location;
    if (CFStringFindWithOptions(MutableCopy, CFSTR("."), v14, 4uLL, (CFRange *)&v10))
      v8 = v10;
    else
      v8 = CFStringGetLength(MutableCopy);
    CFStringInsert(MutableCopy, v8, CFSTR("-%m"));
    theString = MutableCopy;
    if (MutableCopy)
      CFRetain(MutableCopy);
    if (v3)
      CFRelease(v3);
    v3 = MutableCopy;
LABEL_18:
    v9 = _FigSetCoverageFilePathPattern(a1, v3);
    goto LABEL_19;
  }
  v6 = v2;
LABEL_21:
  if (v3)
    CFRelease(v3);
  return v6;
}

uint64_t FigCopyCoverageFilePathPattern(_QWORD *a1)
{
  void *v2;
  char *v3;
  uint64_t result;

  if (getCodeCoverageGlobals_onceToken != -1)
    dispatch_once(&getCodeCoverageGlobals_onceToken, &__block_literal_global_1);
  FigSimpleMutexLock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
  if (getCodeCoverageGlobals_sFigCodeCoverageGlobals_0)
  {
    v2 = (void *)CFRetain((CFTypeRef)getCodeCoverageGlobals_sFigCodeCoverageGlobals_0);
    FigSimpleMutexUnlock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
    if (v2)
    {
LABEL_9:
      result = 0;
      *a1 = v2;
      return result;
    }
  }
  else
  {
    FigSimpleMutexUnlock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
  }
  v3 = getenv("LLVM_PROFILE_FILE");
  if (v3)
  {
    v2 = (void *)CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v3, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    goto LABEL_9;
  }
  return 4294949395;
}

uint64_t _FigCopyResolvedCoverageFilePath(uint64_t a1, CFStringRef *a2)
{
  uint64_t (*v2)(void);
  const char *v4;

  if (!a1)
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
  v2 = *(uint64_t (**)(void))(a1 + 24);
  if (!v2)
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
  v4 = (const char *)v2();
  if (v4)
    *a2 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  return 0;
}

uint64_t _FigSetCoverageFilePathPattern(uint64_t a1, CFStringRef theString)
{
  uint64_t (**v2)(_QWORD);
  uint64_t (*v3)(char *);
  char *CStringPtrAndBufferToFree;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  uint64_t v10;
  void *v11;

  v2 = (uint64_t (**)(_QWORD))a1;
  v11 = 0;
  if (!a1)
  {
    v10 = 4294949396;
LABEL_16:
    v8 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  v3 = *(uint64_t (**)(char *))(a1 + 16);
  if (!v3 || !*(_QWORD *)(a1 + 24))
  {
    v8 = FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
    v2 = 0;
    goto LABEL_12;
  }
  CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(theString, 0x8000100u, (char **)&v11);
  v6 = v3(CStringPtrAndBufferToFree);
  v2 = (uint64_t (**)(_QWORD))v2[3](v6);
  if (!v2)
  {
    v10 = 4294949395;
    goto LABEL_16;
  }
  if (getCodeCoverageGlobals_onceToken != -1)
    dispatch_once(&getCodeCoverageGlobals_onceToken, &__block_literal_global_1);
  FigSimpleMutexLock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
  v7 = (const void *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_0;
  getCodeCoverageGlobals_sFigCodeCoverageGlobals_0 = (uint64_t)theString;
  if (theString)
    CFRetain(theString);
  if (v7)
    CFRelease(v7);
  FigSimpleMutexUnlock((pthread_mutex_t *)getCodeCoverageGlobals_sFigCodeCoverageGlobals_1);
  v8 = 0;
LABEL_12:
  free(v2);
  free(v11);
  return v8;
}

uint64_t _FigFinishUpdatingIncrementalCodeCoverageData(uint64_t (**a1)(void))
{
  uint64_t (*v1)(void);

  if (a1 && (v1 = *a1) != 0)
    return v1();
  else
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
}

uint64_t _FigBeginUpdatingIncrementalCodeCoverageData(uint64_t a1)
{
  void (*v1)(void);

  if (!a1)
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
  v1 = *(void (**)(void))(a1 + 8);
  if (!v1)
    return FigSignalErrorAt(4294949396, 0, 0, 0, 0, 0, 0);
  v1();
  return 0;
}

uint64_t CMFinishUpdatingIncrementalCodeCoverageData()
{
  return 4294949395;
}

uint64_t CMBeginUpdatingIncrementalCodeCoverageData()
{
  return 4294949395;
}

uint64_t CMEnsureReadyToCollectIncrementalCoverageData()
{
  return 4294949395;
}

uint64_t CMSetCodeCoverageFilePathPattern()
{
  return 4294949395;
}

pthread_mutex_t *__getCodeCoverageGlobals_block_invoke()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  pthread_mutex_t *result;

  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  getCodeCoverageGlobals_sFigCodeCoverageGlobals_1 = (uint64_t)result;
  getCodeCoverageGlobals_sFigCodeCoverageGlobals_0 = 0;
  return result;
}

void FigCVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
  if (value)
    CVBufferSetAttachment(buffer, key, value, attachmentMode);
  else
    CVBufferRemoveAttachment(buffer, key);
}

CFDictionaryRef FigCVBufferCopyDictionaryOfAttachments(int a1, CVBufferRef buffer, CVAttachmentMode attachmentMode)
{
  return CVBufferCopyAttachments(buffer, attachmentMode);
}

uint64_t FigEndpointManagerCopyActivatedEndpoints(uint64_t a1, const __CFAllocator *a2, __CFArray **a3)
{
  uint64_t CMBaseObject;
  uint64_t (*v6)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *);
  uint64_t v7;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const void *ValueAtIndex;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, const __CFString *, const __CFAllocator *, CFBooleanRef *);
  uint64_t v15;
  uint64_t v16;
  CFBooleanRef BOOLean;
  CFArrayRef theArray;

  BOOLean = 0;
  theArray = 0;
  if (!a1 || !a3)
  {
    v7 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_27:
    v16 = v7;
    goto LABEL_16;
  }
  CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  v6 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                                  + 48);
  if (!v6)
  {
    Mutable = 0;
LABEL_18:
    v16 = 4294954514;
    goto LABEL_19;
  }
  v7 = v6(CMBaseObject, CFSTR("AvailableEndpoints"), a2, &theArray);
  if ((_DWORD)v7)
    goto LABEL_27;
  Mutable = CFArrayCreateMutable(a2, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      v10 = Count;
      v11 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v11);
        v13 = FigEndpointGetCMBaseObject(ValueAtIndex);
        v14 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFAllocator *, CFBooleanRef *))(*(_QWORD *)(CMBaseObjectGetVTable(v13) + 8) + 48);
        if (!v14)
          goto LABEL_18;
        v15 = v14(v13, CFSTR("IsActivated"), a2, &BOOLean);
        if ((_DWORD)v15)
          goto LABEL_29;
        if (CFBooleanGetValue(BOOLean))
          CFArrayAppendValue(Mutable, ValueAtIndex);
        if (BOOLean)
        {
          CFRelease(BOOLean);
          BOOLean = 0;
        }
      }
      while (v10 != ++v11);
    }
    v16 = 0;
    *a3 = Mutable;
LABEL_16:
    Mutable = 0;
    goto LABEL_19;
  }
  v15 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_29:
  v16 = v15;
LABEL_19:
  if (theArray)
    CFRelease(theArray);
  if (Mutable)
    CFRelease(Mutable);
  if (BOOLean)
    CFRelease(BOOLean);
  return v16;
}

uint64_t FigEndpointManagerCopyEndpointForID(const void *a1, uint64_t a2, CFTypeRef cf, CFTypeRef *a4)
{
  CFTypeID v8;

  if (cf && (v8 = CFGetTypeID(cf), v8 == CFStringGetTypeID()))
    return managerUtil_copyEndpointMatchingPropertyValue(a1, a2, CFSTR("ID"), cf, a4);
  else
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t managerUtil_copyEndpointMatchingPropertyValue(const void *a1, uint64_t a2, const void *a3, const void *a4, CFTypeRef *a5)
{
  CFTypeID v10;
  CFTypeID v11;
  uint64_t CMBaseObject;
  uint64_t (*v13)(uint64_t, const __CFString *, uint64_t, CFArrayRef *);
  uint64_t v14;
  CFIndex Count;
  CFIndex v16;
  const void *ValueAtIndex;
  CFAllocatorRef v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t, const void *, CFAllocatorRef, CFTypeRef *);
  uint64_t v21;
  CFTypeRef cf;
  CFArrayRef theArray;

  cf = 0;
  theArray = 0;
  if (!a1
    || (v10 = CFGetTypeID(a1), v10 != FigEndpointManagerGetTypeID())
    || !a3
    || (v11 = CFGetTypeID(a3), v11 != CFStringGetTypeID())
    || !a4
    || !a5)
  {
    v14 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_30:
    v21 = v14;
    goto LABEL_24;
  }
  CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  v13 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                                 + 8)
                                                                                     + 48);
  if (!v13)
  {
LABEL_18:
    v21 = 4294954514;
    goto LABEL_24;
  }
  v14 = v13(CMBaseObject, CFSTR("AvailableEndpoints"), a2, &theArray);
  if ((_DWORD)v14)
    goto LABEL_30;
  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v16 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v16);
      v18 = CFGetAllocator(ValueAtIndex);
      v19 = FigEndpointGetCMBaseObject(ValueAtIndex);
      v20 = *(uint64_t (**)(uint64_t, const void *, CFAllocatorRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(v19) + 8)
                                                                                         + 48);
      if (!v20)
        goto LABEL_18;
      v14 = v20(v19, a3, v18, &cf);
      if ((_DWORD)v14)
        goto LABEL_30;
      if (FigCFEqual(cf, a4))
      {
        *a5 = CFRetain(ValueAtIndex);
        goto LABEL_21;
      }
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      if (Count == ++v16)
      {
        v16 = Count;
        goto LABEL_21;
      }
    }
  }
  v16 = 0;
LABEL_21:
  if (v16 == Count)
    v21 = 4294950583;
  else
    v21 = 0;
LABEL_24:
  if (theArray)
    CFRelease(theArray);
  if (cf)
    CFRelease(cf);
  return v21;
}

uint64_t FigEndpointManagerCopyEndpointForName(const void *a1, uint64_t a2, CFTypeRef cf, CFTypeRef *a4)
{
  CFTypeID v8;

  if (cf && (v8 = CFGetTypeID(cf), v8 == CFStringGetTypeID()))
    return managerUtil_copyEndpointMatchingPropertyValue(a1, a2, CFSTR("Name"), cf, a4);
  else
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointManagerCopyEndpointsForType(const void *a1, const __CFAllocator *a2, const void *a3, __CFArray **a4)
{
  CFTypeID v8;
  CFTypeID v9;
  __CFArray *Mutable;
  uint64_t CMBaseObject;
  uint64_t (*v12)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *);
  uint64_t v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex v16;
  const void *ValueAtIndex;
  CFAllocatorRef v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t, const __CFString *, CFAllocatorRef, CFTypeRef *);
  uint64_t v21;
  uint64_t v22;
  CFTypeRef cf;
  CFArrayRef theArray;

  cf = 0;
  theArray = 0;
  if (!a1
    || (v8 = CFGetTypeID(a1), v8 != FigEndpointManagerGetTypeID())
    || !a3
    || (v9 = CFGetTypeID(a3), v9 != CFStringGetTypeID())
    || !a4)
  {
    v22 = FigSignalErrorAt(4294950586, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  Mutable = CFArrayCreateMutable(a2, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v13 = FigSignalErrorAt(4294950585, 0, 0, 0, 0, 0, 0);
LABEL_31:
    v22 = v13;
    goto LABEL_24;
  }
  CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  v12 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8) + 48);
  if (!v12)
  {
    v22 = 4294954514;
    goto LABEL_24;
  }
  v13 = v12(CMBaseObject, CFSTR("AvailableEndpoints"), a2, &theArray);
  if ((_DWORD)v13)
    goto LABEL_31;
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
LABEL_18:
    v22 = 0;
    *a4 = Mutable;
LABEL_19:
    Mutable = 0;
    goto LABEL_24;
  }
  v15 = Count;
  v16 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v16);
    v18 = CFGetAllocator(ValueAtIndex);
    v19 = FigEndpointGetCMBaseObject(ValueAtIndex);
    v20 = *(uint64_t (**)(uint64_t, const __CFString *, CFAllocatorRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(v19) + 8)
                                                                                             + 48);
    if (!v20)
    {
      v22 = 4294954514;
      goto LABEL_22;
    }
    v21 = v20(v19, CFSTR("Type"), v18, &cf);
    if ((_DWORD)v21)
      break;
    if (FigCFEqual(cf, a3))
      CFArrayAppendValue(Mutable, ValueAtIndex);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    if (v15 == ++v16)
      goto LABEL_18;
  }
  v22 = v21;
LABEL_22:
  if (cf)
    CFRelease(cf);
LABEL_24:
  if (theArray)
    CFRelease(theArray);
  if (Mutable)
    CFRelease(Mutable);
  return v22;
}

__CFArray *FigEndpointManagerCopyMatchingEndpoints(uint64_t a1, unsigned int (*a2)(const void *, uint64_t), uint64_t a3)
{
  const __CFAllocator *v5;
  uint64_t CMBaseObject;
  void (*v7)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *);
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v10;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v13;
  CFArrayRef theArray;

  theArray = 0;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  v7 = *(void (**)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                               + 48);
  if (v7)
    v7(CMBaseObject, CFSTR("AvailableEndpoints"), v5, &theArray);
  Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E0C9B378]);
  if (theArray)
  {
    Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      v10 = Count;
      for (i = 0; i != v10; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        v13 = ValueAtIndex;
        if (!a2 || a2(ValueAtIndex, a3))
          CFArrayAppendValue(Mutable, v13);
      }
    }
  }
  if (Mutable && !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    Mutable = 0;
  }
  if (theArray)
    CFRelease(theArray);
  return Mutable;
}

uint64_t FigEndpointUtility_CopyMatchingEndpointEntities(const __CFArray *a1, unsigned int (*a2)(const void *, uint64_t), uint64_t a3, unsigned int (*a4)(const void *, uint64_t), uint64_t a5, unsigned int (*a6)(const void *, uint64_t, uint64_t), uint64_t a7, uint64_t a8, __CFArray **a9, __CFArray **a10, _QWORD *a11)
{
  _QWORD *v11;
  __CFArray **v12;
  __CFArray **v13;
  BOOL v14;
  BOOL v15;
  CFIndex Count;
  CFAllocatorRef *v23;
  __CFArray *v24;
  __CFArray *v25;
  CFIndex v27;
  unsigned int v28;
  const void *v29;
  const void *ValueAtIndex;
  __CFArray *v31;
  const __CFArray *v32;
  CFIndex v33;
  CFIndex v34;
  CFIndex i;
  const void *v36;
  __CFArray *v37;
  const __CFArray *v38;
  const void *v39;
  uint64_t v40;
  unsigned int (*v41)(const void *, uint64_t);
  uint64_t v42;
  __CFArray *v43;
  uint64_t v44;
  __CFArray *Mutable;
  unsigned int v48;
  CFRange v49;
  CFRange v50;

  v12 = a10;
  v11 = a11;
  v13 = a9;
  v48 = 0;
  if (!a1 || (!a9 ? (v14 = a10 == 0) : (v14 = 0), v14 ? (v15 = a11 == 0) : (v15 = 0), v15))
  {
    v24 = 0;
    v25 = 0;
    Mutable = 0;
    v48 = -16720;
    if (!a9)
      goto LABEL_15;
    goto LABEL_14;
  }
  Count = CFArrayGetCount(a1);
  v23 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  v44 = Count;
  if (a9)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
    if (a10)
      goto LABEL_11;
LABEL_21:
    v43 = 0;
    if (a11)
      goto LABEL_12;
LABEL_22:
    v24 = 0;
    goto LABEL_23;
  }
  Mutable = 0;
  if (!a10)
    goto LABEL_21;
LABEL_11:
  v43 = CFArrayCreateMutable(*v23, 0, MEMORY[0x1E0C9B378]);
  if (!a11)
    goto LABEL_22;
LABEL_12:
  v24 = CFArrayCreateMutable(*v23, 0, MEMORY[0x1E0C9B378]);
LABEL_23:
  v13 = a9;
  if (v44 < 1)
    goto LABEL_42;
  v27 = 0;
  v28 = 0;
  v41 = a4;
  v42 = a5;
  v40 = a3;
  do
  {
    if (!a2 || (v29 = CFArrayGetValueAtIndex(a1, v27), a2(v29, a3)))
    {
      if ((unint64_t)v43 | (unint64_t)v24)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v27);
        v31 = FigEndpointManagerCopyMatchingEndpoints((uint64_t)ValueAtIndex, a4, a5);
        if (!v31)
          goto LABEL_40;
        v32 = v31;
        v33 = CFArrayGetCount(v31);
        if (v33 >= 1)
        {
          v34 = v33;
          for (i = 0; i != v34; ++i)
          {
            v36 = CFArrayGetValueAtIndex(v32, i);
            if (v24)
            {
              v37 = FigEndpointUtility_CopyMatchingStreamsFromEndpoint((uint64_t)v36, a6, a7, a8);
              if (v37)
              {
                v38 = v37;
                v49.length = CFArrayGetCount(v37);
                v49.location = 0;
                CFArrayAppendArray(v24, v38, v49);
                CFRelease(v38);
              }
            }
          }
        }
        if (v43)
        {
          v50.length = CFArrayGetCount(v32);
          v50.location = 0;
          CFArrayAppendArray(v43, v32, v50);
        }
        CFRelease(v32);
        a4 = v41;
        a5 = v42;
        a3 = v40;
      }
      if (Mutable)
      {
        v39 = CFArrayGetValueAtIndex(a1, v27);
        CFArrayAppendValue(Mutable, v39);
      }
    }
LABEL_40:
    v27 = ++v28;
  }
  while (v44 > v28);
  v12 = a10;
  v11 = a11;
  v13 = a9;
LABEL_42:
  v25 = v43;
  if (v13)
LABEL_14:
    *v13 = Mutable;
LABEL_15:
  if (v12)
    *v12 = v25;
  if (v11)
    *v11 = v24;
  return v48;
}

uint64_t FigEndpointUtility_EndpointManagerPredicate_IsEndpointManagerOfType(uint64_t a1, const void *a2)
{
  uint64_t CMBaseObject;
  void (*v4)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  CFTypeRef v5;
  uint64_t v6;
  CFTypeRef cf;

  if (!a1)
    return 0;
  cf = 0;
  CMBaseObject = FigEndpointManagerGetCMBaseObject(a1);
  v4 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                           + 8)
                                                                               + 48);
  if (v4)
  {
    v4(CMBaseObject, CFSTR("Name"), *MEMORY[0x1E0C9AE00], &cf);
    v5 = cf;
  }
  else
  {
    v5 = 0;
  }
  v6 = FigCFEqual(v5, a2);
  if (cf)
    CFRelease(cf);
  return v6;
}

uint64_t FigRuntimeUnregisterAttachmentBearerWithTypeID()
{
  return FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
}

void CMSetAttachment(CMAttachmentBearerRef target, CFStringRef key, CFTypeRef value, CMAttachmentMode attachmentMode)
{
  uint64_t v4;
  CMAttachmentBearerRef v7;
  const void *v8;

  v4 = *(_QWORD *)&attachmentMode;
  v7 = target;
  if (target)
  {
    v8 = (const void *)CFGetTypeID(target);
    target = FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v8);
  }
  if (key && v4 < 2)
  {
    if (target)
      (*((void (**)(CMAttachmentBearerRef, CFStringRef, CFTypeRef, uint64_t))target + 1))(v7, key, value, v4);
  }
  else
  {
    FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
  }
}

CFTypeRef CMGetAttachment(CMAttachmentBearerRef target, CFStringRef key, CMAttachmentMode *attachmentModeOut)
{
  const void *v6;
  uint64_t (**AttachmentBearerCallbacksWithTypeID)(CMAttachmentBearerRef, CFStringRef, CMAttachmentMode *);

  if (!target)
  {
    if (key)
      return 0;
LABEL_6:
    FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v6 = (const void *)CFGetTypeID(target);
  AttachmentBearerCallbacksWithTypeID = (uint64_t (**)(CMAttachmentBearerRef, CFStringRef, CMAttachmentMode *))FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v6);
  if (!key)
    goto LABEL_6;
  if (AttachmentBearerCallbacksWithTypeID)
    return (CFTypeRef)AttachmentBearerCallbacksWithTypeID[2](target, key, attachmentModeOut);
  return 0;
}

void CMRemoveAttachment(CMAttachmentBearerRef target, CFStringRef key)
{
  const void *v4;
  void (**AttachmentBearerCallbacksWithTypeID)(CMAttachmentBearerRef, CFStringRef);

  if (!target)
  {
    if (key)
      return;
LABEL_7:
    FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
    return;
  }
  v4 = (const void *)CFGetTypeID(target);
  AttachmentBearerCallbacksWithTypeID = (void (**)(CMAttachmentBearerRef, CFStringRef))FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v4);
  if (!key)
    goto LABEL_7;
  if (AttachmentBearerCallbacksWithTypeID)
    AttachmentBearerCallbacksWithTypeID[3](target, key);
}

void CMRemoveAllAttachments(CMAttachmentBearerRef target)
{
  const void *v2;
  void (**AttachmentBearerCallbacksWithTypeID)(CMAttachmentBearerRef);

  if (target)
  {
    v2 = (const void *)CFGetTypeID(target);
    AttachmentBearerCallbacksWithTypeID = (void (**)(CMAttachmentBearerRef))FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v2);
    if (AttachmentBearerCallbacksWithTypeID)
      AttachmentBearerCallbacksWithTypeID[4](target);
  }
}

CFDictionaryRef CMCopyDictionaryOfAttachments(CFAllocatorRef allocator, CMAttachmentBearerRef target, CMAttachmentMode attachmentMode)
{
  uint64_t v3;
  const void *v6;
  uint64_t (**AttachmentBearerCallbacksWithTypeID)(CFAllocatorRef, CMAttachmentBearerRef, _QWORD);

  v3 = *(_QWORD *)&attachmentMode;
  if (!target)
  {
    if (attachmentMode < 2)
      return 0;
LABEL_6:
    FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v6 = (const void *)CFGetTypeID(target);
  AttachmentBearerCallbacksWithTypeID = (uint64_t (**)(CFAllocatorRef, CMAttachmentBearerRef, _QWORD))FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v6);
  if (v3 > 1)
    goto LABEL_6;
  if (AttachmentBearerCallbacksWithTypeID)
    return (CFDictionaryRef)AttachmentBearerCallbacksWithTypeID[5](allocator, target, v3);
  return 0;
}

void CMSetAttachments(CMAttachmentBearerRef target, CFDictionaryRef theAttachments, CMAttachmentMode attachmentMode)
{
  const void *v6;
  const void *AttachmentBearerCallbacksWithTypeID;
  _QWORD context[3];

  if (target)
  {
    v6 = (const void *)CFGetTypeID(target);
    AttachmentBearerCallbacksWithTypeID = FigRuntimeGetAttachmentBearerCallbacksWithTypeID(v6);
    if (AttachmentBearerCallbacksWithTypeID)
    {
      context[1] = AttachmentBearerCallbacksWithTypeID;
      context[0] = target;
      context[2] = attachmentMode;
      CFDictionaryApplyFunction(theAttachments, (CFDictionaryApplierFunction)figSetOneAttachment, context);
    }
  }
}

uint64_t figSetOneAttachment(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a3 + 8) + 8))(*(_QWORD *)a3, a1, a2, *(unsigned int *)(a3 + 16));
}

void CMPropagateAttachments(CMAttachmentBearerRef source, CMAttachmentBearerRef destination)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;

  v3 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], source, 1u);
  if (v3)
  {
    v4 = v3;
    CMSetAttachments(destination, v3, 1u);
    CFRelease(v4);
  }
}

CFMutableDictionaryRef figAttachmentsMakeAttachmentBearerRegistrationDictionary()
{
  CFMutableDictionaryRef result;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
  sFigAttachmentBearerCallbacksPerTypeID = (uint64_t)result;
  if (!result)
    return (CFMutableDictionaryRef)FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
  return result;
}

void figAttachmentsRegisterInternalBearers()
{
  FigThreadRunOnce(&sFigAttachmentsEnsureAttachmentBearerRegistrationDictionaryOnce, (void (*)(void))figAttachmentsMakeAttachmentBearerRegistrationDictionary);
  FigAttachmentsRegisterBlockBuffer();
  FigAttachmentsRegisterSampleBuffer();
  FigAttachmentsRegisterCVBuffer();
}

CFTypeID CMBlockBufferGetTypeID(void)
{
  FigThreadRunOnce(&sRegisterFigBlockBufferTypeOnce, (void (*)(void))RegisterFigBlockBufferType);
  return sFigBlockBufferID;
}

void FigAttachmentsRegisterBlockBuffer()
{
  FigThreadRunOnce(&sRegisterFigBlockBufferTypeOnce, (void (*)(void))RegisterFigBlockBufferType);
  FigRuntimeRegisterAttachmentBearerWithTypeID(sFigBlockBufferAttachmentBearerCallbacks, (const void *)sFigBlockBufferID);
}

OSStatus CMBlockBufferCreateEmpty(CFAllocatorRef structureAllocator, uint32_t subBlockCapacity, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  uint32_t v5;
  uint64_t Instance;
  OpaqueCMBlockBuffer *v7;
  OSStatus result;

  if (!blockBufferOut)
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  if (subBlockCapacity + 1 > 2)
    v5 = subBlockCapacity + 1;
  else
    v5 = 2;
  FigThreadRunOnce(&sRegisterFigBlockBufferTypeOnce, (void (*)(void))RegisterFigBlockBufferType);
  Instance = _CFRuntimeCreateInstance();
  v7 = (OpaqueCMBlockBuffer *)Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 36) = v5;
    bzero((void *)(Instance + 48), 48 * v5);
    result = 0;
  }
  else
  {
    result = FigSignalErrorAt(4294954596, 0, 0, 0, 0, 0, 0);
  }
  *blockBufferOut = v7;
  return result;
}

OSStatus CMBlockBufferAppendMemoryBlock(CMBlockBufferRef theBuffer, void *memoryBlock, size_t blockLength, CFAllocatorRef blockAllocator, const CMBlockBufferCustomBlockSource *customBlockSource, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags)
{
  uint64_t v12;
  char v14;
  const __CFAllocator *Default;
  uint64_t v17;
  _OWORD *v18;
  const __CFAllocator *v19;
  _OWORD *v20;
  __int128 v21;
  void *v22;
  uint64_t v23;
  OSStatus v24;
  OSStatus v25;
  uint64_t v26;
  BOOL v27;
  int v28;
  const __CFAllocator *v29;
  uint64_t v30;
  void *v31;
  const __CFAllocator *v32;
  uint64_t v33;

  if (!theBuffer)
  {
    v12 = 4294954591;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (!blockLength || !dataLength)
    goto LABEL_8;
  if (offsetToData >= blockLength)
  {
    v12 = 4294954593;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (dataLength + offsetToData > blockLength || __CFADD__(*((_QWORD *)theBuffer + 5), blockLength))
  {
LABEL_8:
    v12 = 4294954592;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v14 = flags;
  Default = blockAllocator;
  v17 = (uint64_t)memoryBlock;
  if (customBlockSource)
  {
    if (customBlockSource->version)
    {
LABEL_14:
      v12 = 4294954594;
      return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    }
    if (memoryBlock)
    {
      if (!customBlockSource->FreeBlock)
        goto LABEL_14;
    }
    else if (!customBlockSource->AllocateBlock)
    {
      goto LABEL_14;
    }
    v19 = CFGetAllocator(theBuffer);
    v20 = CFAllocatorAllocate(v19, 28, 0);
    if (!v20)
    {
      v12 = 4294954596;
      return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    }
    v18 = v20;
    v21 = *(_OWORD *)&customBlockSource->version;
    *(_OWORD *)((char *)v20 + 12) = *(_OWORD *)&customBlockSource->FreeBlock;
    *v20 = v21;
  }
  else if (blockAllocator)
  {
    v18 = 0;
    if (!memoryBlock && (CFAllocatorRef)*MEMORY[0x1E0C9AE20] == blockAllocator)
      goto LABEL_18;
  }
  else
  {
    Default = CFAllocatorGetDefault();
    v18 = 0;
  }
  if (!v17)
  {
    if ((v14 & 1) == 0)
    {
      v17 = 0;
      goto LABEL_29;
    }
    if (v18)
    {
      v30 = (*(uint64_t (**)(_QWORD, size_t))((char *)v18 + 4))(*(_QWORD *)((char *)v18 + 20), blockLength);
      if (v30)
      {
        v17 = v30;
        v22 = 0;
        v23 = v30;
        goto LABEL_30;
      }
      v32 = CFGetAllocator(theBuffer);
      CFAllocatorDeallocate(v32, v18);
    }
    else
    {
      v31 = CFAllocatorAllocate(Default, blockLength, 0);
      if (v31)
      {
        v17 = (uint64_t)v31;
        v23 = 0;
        v22 = v31;
        goto LABEL_30;
      }
    }
LABEL_18:
    v12 = 4294954595;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
LABEL_29:
  v22 = 0;
  v23 = 0;
LABEL_30:
  v33 = 0;
  v24 = NewBufferSubBlock((uint64_t)theBuffer, dataLength, &v33);
  if (v24)
  {
    v25 = v24;
    if (v22)
    {
      CFAllocatorDeallocate(Default, v22);
    }
    else if (v23)
    {
      ((void (*)(void *, uint64_t, size_t))customBlockSource->FreeBlock)(customBlockSource->refCon, v23, blockLength);
    }
    if (v18)
    {
      v29 = CFGetAllocator(theBuffer);
      CFAllocatorDeallocate(v29, v18);
    }
  }
  else
  {
    v26 = v33;
    *(_QWORD *)(v33 + 8) = offsetToData;
    *(_QWORD *)(v26 + 24) = v17;
    *(_QWORD *)(v26 + 32) = blockLength;
    if (v18)
    {
      v25 = 0;
      *(_QWORD *)(v26 + 40) = v18;
      v27 = v17 == 0;
      v28 = 4;
    }
    else
    {
      *(_QWORD *)(v26 + 40) = Default;
      CFRetain(Default);
      v25 = 0;
      v27 = v17 == 0;
      v28 = 2;
    }
    if (!v27)
      ++v28;
    *(_DWORD *)v26 = v28;
  }
  return v25;
}

size_t CMBlockBufferGetDataLength(size_t theBuffer)
{
  if (theBuffer)
    return *(_QWORD *)(theBuffer + 40);
  return theBuffer;
}

OSStatus CMBlockBufferCreateWithMemoryBlock(CFAllocatorRef structureAllocator, void *memoryBlock, size_t blockLength, CFAllocatorRef blockAllocator, const CMBlockBufferCustomBlockSource *customBlockSource, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  OSStatus appended;
  OpaqueCMBlockBuffer *v17;
  CMBlockBufferRef theBuffer;

  if (!blockBufferOut)
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  theBuffer = 0;
  appended = CMBlockBufferCreateEmpty(structureAllocator, 0, blockLength, &theBuffer);
  v17 = theBuffer;
  if (!appended)
  {
    appended = CMBlockBufferAppendMemoryBlock(theBuffer, memoryBlock, blockLength, blockAllocator, customBlockSource, offsetToData, dataLength, flags);
    v17 = theBuffer;
    if (appended)
    {
      CFRelease(theBuffer);
      v17 = 0;
    }
  }
  *blockBufferOut = v17;
  return appended;
}

OSStatus CMBlockBufferAppendBufferReference(CMBlockBufferRef theBuffer, CMBlockBufferRef targetBBuf, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags)
{
  size_t v5;
  uint64_t v6;
  uint64_t v8;
  _QWORD v9[3];

  if (!theBuffer || !targetBBuf)
  {
    v6 = 4294954591;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  v5 = *((_QWORD *)targetBBuf + 5);
  if (!v5)
  {
    if ((flags & 8) != 0)
    {
LABEL_12:
      if (!dataLength)
      {
        v6 = 4294954592;
        return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
      }
      goto LABEL_13;
    }
    v6 = 4294954590;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (v5 <= offsetToData)
  {
    v6 = 4294954593;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (dataLength + offsetToData > v5)
  {
LABEL_15:
    v6 = 4294954592;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (!dataLength)
  {
    dataLength = v5 - offsetToData;
    goto LABEL_12;
  }
LABEL_13:
  v8 = 0;
  if (__CFADD__(*((_QWORD *)theBuffer + 5), dataLength))
    goto LABEL_15;
  v9[1] = theBuffer;
  v9[2] = dataLength;
  v9[0] = targetBBuf;
  if (v5 < dataLength + offsetToData)
  {
    if ((flags & 8) != 0)
      return AppendBufferReferenceSubBlock((uint64_t)theBuffer, targetBBuf, offsetToData, dataLength);
    return 0;
  }
  if ((flags & 4) == 0)
  {
    FindDataReference((uint64_t)v9, (uint64_t)targetBBuf, offsetToData, dataLength, &v8);
    return 0;
  }
  return AppendBufferReferenceSubBlock((uint64_t)theBuffer, targetBBuf, offsetToData, dataLength);
}

OSStatus CMBlockBufferCreateWithBufferReference(CFAllocatorRef structureAllocator, CMBlockBufferRef bufferReference, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  OSStatus appended;
  OpaqueCMBlockBuffer *v12;
  CMBlockBufferRef blockBufferOuta;

  if (!blockBufferOut)
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  blockBufferOuta = 0;
  appended = CMBlockBufferCreateEmpty(structureAllocator, 0, offsetToData, &blockBufferOuta);
  v12 = blockBufferOuta;
  if (!appended)
  {
    appended = CMBlockBufferAppendBufferReference(blockBufferOuta, bufferReference, offsetToData, dataLength, flags);
    v12 = blockBufferOuta;
    if (appended)
    {
      CFRelease(blockBufferOuta);
      v12 = 0;
    }
  }
  *blockBufferOut = v12;
  return appended;
}

Boolean CMBlockBufferIsEmpty(CMBlockBufferRef theBuffer)
{
  return !theBuffer || *((_DWORD *)theBuffer + 8) == 0;
}

OSStatus CMBlockBufferGetDataPointer(CMBlockBufferRef theBuffer, size_t offset, size_t *lengthAtOffsetOut, size_t *totalLengthOut, char **dataPointerOut)
{
  uint64_t v9;
  size_t v11;
  CMBlockBufferRef *v12;
  size_t v13;
  OSStatus result;
  char *v15;
  BOOL v16;
  size_t v17;
  char *v18;
  size_t lengthAtOffsetOuta;

  v18 = 0;
  lengthAtOffsetOuta = 0;
  if (!theBuffer)
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  v9 = *((unsigned int *)theBuffer + 8);
  if ((int)v9 < 1)
  {
LABEL_6:
    result = 0;
  }
  else
  {
    v11 = 0;
    v12 = (CMBlockBufferRef *)((char *)theBuffer + 72);
    while (1)
    {
      v13 = (size_t)*(v12 - 1) + v11;
      if (v13 > offset)
        break;
      v12 += 6;
      v11 = v13;
      if (!--v9)
        goto LABEL_6;
    }
    switch(*((_DWORD *)v12 - 6))
    {
      case 1:
        result = CMBlockBufferGetDataPointer(*v12, (size_t)*(v12 - 2) + offset - v11, &lengthAtOffsetOuta, 0, &v18);
        if (!result)
        {
          v17 = (size_t)*(v12 - 1) + v11 - offset;
          if (lengthAtOffsetOuta < v17)
            v17 = lengthAtOffsetOuta;
          lengthAtOffsetOuta = v17;
        }
        break;
      case 2:
      case 4:
        result = -12707;
        break;
      case 3:
      case 5:
        result = 0;
        lengthAtOffsetOuta = v13 - offset;
        v18 = (char *)*(v12 - 2) + (_QWORD)*v12 + offset - v11;
        break;
      default:
        goto LABEL_6;
    }
  }
  v15 = v18;
  if (v18)
    v16 = 0;
  else
    v16 = result == 0;
  if (v16)
    result = -12703;
  if (lengthAtOffsetOut)
    *lengthAtOffsetOut = lengthAtOffsetOuta;
  if (totalLengthOut)
    *totalLengthOut = *((_QWORD *)theBuffer + 5);
  if (dataPointerOut)
    *dataPointerOut = v15;
  return result;
}

uint64_t FigBlockBufferGetDataPointerAndOrigin(uint64_t a1, unint64_t a2, unint64_t *a3, _QWORD *a4, unint64_t *a5, _QWORD *a6, unint64_t *a7)
{
  uint64_t v11;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t result;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;

  v22 = 0;
  v23 = 0;
  if (!a1 || !a6 || !a7)
    return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
  v11 = *(unsigned int *)(a1 + 32);
  if ((int)v11 < 1)
  {
LABEL_8:
    LODWORD(result) = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = 48 * v11;
    while (1)
    {
      v16 = a1 + v13;
      v17 = *(_QWORD *)(a1 + v13 + 64) + v14;
      if (v17 > a2)
        break;
      v13 += 48;
      v14 = v17;
      if (v15 == v13)
        goto LABEL_8;
    }
    switch(*(_DWORD *)(v16 + 48))
    {
      case 1:
        LODWORD(result) = FigBlockBufferGetDataPointerAndOrigin(*(_QWORD *)(a1 + v13 + 72), a2 - v14 + *(_QWORD *)(a1 + v13 + 56), &v23, 0, &v22);
        if (!(_DWORD)result)
        {
          v21 = v14 - a2 + *(_QWORD *)(v16 + 64);
          if (v23 < v21)
            v21 = v23;
          v23 = v21;
        }
        break;
      case 2:
      case 4:
        LODWORD(result) = -12707;
        break;
      case 3:
      case 5:
        LODWORD(result) = 0;
        *a6 = a1;
        *a7 = a2;
        v22 = *(_QWORD *)(a1 + v13 + 72) + *(_QWORD *)(a1 + v13 + 56) + a2 - v14;
        v23 = v17 - a2;
        break;
      default:
        goto LABEL_8;
    }
  }
  v19 = v22;
  if (v22)
    v20 = 0;
  else
    v20 = (_DWORD)result == 0;
  if (v20)
    result = 4294954593;
  else
    result = result;
  if (a3)
    *a3 = v23;
  if (a4)
    *a4 = *(_QWORD *)(a1 + 40);
  if (a5)
    *a5 = v19;
  return result;
}

OSStatus CMBlockBufferCopyDataBytes(CMBlockBufferRef theSourceBuffer, size_t offsetToData, size_t dataLength, void *destination)
{
  uint64_t v5;
  char *v6;
  size_t v7;
  size_t v8;
  size_t v9;
  BOOL v10;
  OSStatus result;
  size_t v12;
  char *v13;
  size_t lengthAtOffsetOut;

  v5 = 4294954591;
  if (!theSourceBuffer)
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  v6 = (char *)destination;
  if (!destination)
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  v7 = dataLength;
  if (!dataLength)
  {
    v5 = 4294954592;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v8 = *((_QWORD *)theSourceBuffer + 5);
  if (!v8)
  {
    v5 = 4294954590;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v9 = offsetToData;
  if (v8 <= offsetToData)
  {
    v5 = 4294954593;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v10 = __CFADD__(dataLength, offsetToData);
  v5 = 4294954592;
  if (dataLength + offsetToData > v8 || v10)
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  v13 = 0;
  lengthAtOffsetOut = 0;
  while (1)
  {
    result = CMBlockBufferGetDataPointer(theSourceBuffer, v9, &lengthAtOffsetOut, 0, &v13);
    if (result)
      break;
    if (v7 >= lengthAtOffsetOut)
      v12 = lengthAtOffsetOut;
    else
      v12 = v7;
    memcpy(v6, v13, v12);
    v9 += v12;
    v6 += v12;
    v7 -= v12;
    if (!v7)
      return 0;
  }
  return result;
}

OSStatus CMBlockBufferReplaceDataBytes(const void *sourceBytes, CMBlockBufferRef destinationBuffer, size_t offsetIntoDestination, size_t dataLength)
{
  uint64_t v5;
  size_t v7;
  size_t v8;
  size_t v9;
  OSStatus result;
  size_t v11;
  char *v12;
  size_t lengthAtOffsetOut;

  v5 = 4294954591;
  if (!sourceBytes || !destinationBuffer)
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  v7 = dataLength;
  if (!dataLength)
    goto LABEL_7;
  v8 = *((_QWORD *)destinationBuffer + 5);
  if (!v8)
  {
    v5 = 4294954590;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v9 = offsetIntoDestination;
  if (v8 <= offsetIntoDestination)
  {
    v5 = 4294954593;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (dataLength + offsetIntoDestination > v8)
  {
LABEL_7:
    v5 = 4294954592;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v12 = 0;
  lengthAtOffsetOut = 0;
  while (1)
  {
    result = CMBlockBufferGetDataPointer(destinationBuffer, v9, &lengthAtOffsetOut, 0, &v12);
    if (result == -12707)
    {
      result = CMBlockBufferAssureBlockMemory(destinationBuffer);
      if (result)
        return result;
      result = CMBlockBufferGetDataPointer(destinationBuffer, v9, &lengthAtOffsetOut, 0, &v12);
    }
    if (result)
      break;
    if (v7 >= lengthAtOffsetOut)
      v11 = lengthAtOffsetOut;
    else
      v11 = v7;
    memcpy(v12, sourceBytes, v11);
    v9 += v11;
    sourceBytes = (char *)sourceBytes + v11;
    v7 -= v11;
    if (!v7)
      return 0;
  }
  return result;
}

OSStatus CMBlockBufferAssureBlockMemory(CMBlockBufferRef theBuffer)
{
  int v2;
  CFAllocatorRef *v3;
  uint64_t v4;
  int v5;
  OSStatus result;
  uint64_t v7;
  const __CFAllocator *v8;
  uint64_t v11;

  if (!theBuffer)
  {
    v11 = 4294954591;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  v2 = *((_DWORD *)theBuffer + 8);
  if (!v2)
  {
    v11 = 4294954590;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  if (v2 >= 1)
  {
    v3 = (CFAllocatorRef *)((char *)theBuffer + 88);
    v4 = 1;
    while (1)
    {
      v5 = *((_DWORD *)v3 - 10);
      switch(v5)
      {
        case 4:
          v7 = (*(uint64_t (**)(_QWORD, _QWORD))((char *)*v3 + 4))(*(_QWORD *)((char *)*v3 + 20), *(v3 - 1));
          *(v3 - 2) = (CFAllocatorRef)v7;
          if (!v7)
            goto LABEL_14;
          result = 0;
          *((_DWORD *)v3 - 10) = 5;
          break;
        case 2:
          v8 = (const __CFAllocator *)CFAllocatorAllocate(*v3, (CFIndex)*(v3 - 1), 0);
          *(v3 - 2) = v8;
          if (!v8)
          {
LABEL_14:
            result = FigSignalErrorAt(4294954595, 0, 0, 0, 0, 0, 0);
            break;
          }
          result = 0;
          *((_DWORD *)v3 - 10) = 3;
          break;
        case 1:
          result = CMBlockBufferAssureBlockMemory(*(v3 - 2));
          break;
        default:
          result = 0;
          break;
      }
      v3 += 6;
      if (v4++ >= *((int *)theBuffer + 8) || result != 0)
        return result;
    }
  }
  return 0;
}

OSStatus CMBlockBufferFillDataBytes(char fillByte, CMBlockBufferRef destinationBuffer, size_t offsetIntoDestination, size_t dataLength)
{
  size_t v5;
  size_t v6;
  uint64_t v7;
  OSStatus result;
  int v9;
  size_t v10;
  size_t v11;
  char *v12;
  size_t lengthAtOffsetOut;

  if (!destinationBuffer)
  {
    v7 = 4294954591;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if ((dataLength & 0x8000000000000000) != 0)
    goto LABEL_6;
  v5 = *((_QWORD *)destinationBuffer + 5);
  if (!v5)
  {
    v7 = 4294954590;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  v6 = offsetIntoDestination;
  if (v5 <= offsetIntoDestination)
  {
    v7 = 4294954593;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (dataLength + offsetIntoDestination > v5)
  {
LABEL_6:
    v7 = 4294954592;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  v9 = fillByte;
  v12 = 0;
  lengthAtOffsetOut = 0;
  if (dataLength)
    v10 = dataLength;
  else
    v10 = v5 - offsetIntoDestination;
  while (1)
  {
    result = CMBlockBufferGetDataPointer(destinationBuffer, v6, &lengthAtOffsetOut, 0, &v12);
    if (result == -12707)
    {
      result = CMBlockBufferAssureBlockMemory(destinationBuffer);
      if (result)
        return result;
      result = CMBlockBufferGetDataPointer(destinationBuffer, v6, &lengthAtOffsetOut, 0, &v12);
    }
    if (result)
      break;
    if (v10 >= lengthAtOffsetOut)
      v11 = lengthAtOffsetOut;
    else
      v11 = v10;
    memset(v12, v9, v11);
    v6 += v11;
    v10 -= v11;
    if (!v10)
      return 0;
  }
  return result;
}

OSStatus CMBlockBufferAccessDataBytes(CMBlockBufferRef theBuffer, size_t offset, size_t length, void *temporaryBlock, char **returnedPointerOut)
{
  OSStatus result;
  char *v11;
  uint64_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  char *v16;
  OSStatus DataPointer;
  size_t v18;
  char *v19;
  size_t lengthAtOffsetOut;

  if (!theBuffer || !temporaryBlock || !returnedPointerOut)
  {
    v12 = 4294954591;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (!length)
  {
    v12 = 4294954592;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v19 = 0;
  lengthAtOffsetOut = 0;
  result = CMBlockBufferGetDataPointer(theBuffer, offset, &lengthAtOffsetOut, 0, &v19);
  if (result)
  {
    v11 = 0;
  }
  else
  {
    v11 = v19;
    v13 = lengthAtOffsetOut;
    v14 = length - lengthAtOffsetOut;
    if (length <= lengthAtOffsetOut)
    {
      result = 0;
    }
    else
    {
      memcpy(temporaryBlock, v19, lengthAtOffsetOut);
      v15 = v13 + offset;
      v16 = (char *)temporaryBlock + v13;
      do
      {
        DataPointer = CMBlockBufferGetDataPointer(theBuffer, v15, &lengthAtOffsetOut, 0, &v19);
        if (DataPointer)
          break;
        v18 = v14 >= lengthAtOffsetOut ? lengthAtOffsetOut : v14;
        memcpy(v16, v19, v18);
        v15 += v18;
        v16 += v18;
        v14 -= v18;
      }
      while (v14);
      if (v14)
        result = -12704;
      else
        result = DataPointer;
      if (v14)
        v11 = 0;
      else
        v11 = (char *)temporaryBlock;
    }
  }
  *returnedPointerOut = v11;
  return result;
}

OSStatus CMBlockBufferCreateContiguous(CFAllocatorRef structureAllocator, CMBlockBufferRef sourceBuffer, CFAllocatorRef blockAllocator, const CMBlockBufferCustomBlockSource *customBlockSource, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *blockBufferOut)
{
  size_t v11;
  uint64_t v12;
  size_t v18;
  OSStatus v19;
  OpaqueCMBlockBuffer *v20;
  size_t lengthAtOffsetOut;
  CMBlockBufferRef theBuffer;

  if (!sourceBuffer || !blockBufferOut)
  {
    v12 = 4294954591;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (!*((_DWORD *)sourceBuffer + 8))
  {
    v12 = 4294954590;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v11 = *((_QWORD *)sourceBuffer + 5);
  if (v11 <= offsetToData)
  {
    v12 = 4294954593;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (dataLength + offsetToData > v11)
  {
    v12 = 4294954592;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  theBuffer = 0;
  if (dataLength)
    v18 = dataLength;
  else
    v18 = v11 - offsetToData;
  if ((flags & 2) == 0)
  {
    lengthAtOffsetOut = 0;
    if (!CMBlockBufferGetDataPointer(sourceBuffer, offsetToData, &lengthAtOffsetOut, 0, 0)
      && lengthAtOffsetOut >= v18)
    {
      return CMBlockBufferCreateWithBufferReference(structureAllocator, sourceBuffer, offsetToData, v18, flags, blockBufferOut);
    }
  }
  v19 = CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, v18, blockAllocator, customBlockSource, 0, v18, flags | 1, &theBuffer);
  v20 = theBuffer;
  if (!v19)
  {
    lengthAtOffsetOut = 0;
    CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, (char **)&lengthAtOffsetOut);
    v19 = CMBlockBufferCopyDataBytes(sourceBuffer, offsetToData, v18, (void *)lengthAtOffsetOut);
    v20 = theBuffer;
    if (v19)
    {
      CFRelease(theBuffer);
      v20 = 0;
    }
  }
  *blockBufferOut = v20;
  return v19;
}

Boolean CMBlockBufferIsRangeContiguous(CMBlockBufferRef theBuffer, size_t offset, size_t length)
{
  size_t v4;
  size_t v5;
  size_t v7;
  size_t lengthAtOffsetOut;

  if (!theBuffer)
  {
    FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v4 = *((_QWORD *)theBuffer + 5);
  v5 = v4 - offset;
  if (v4 <= offset || length + offset > v4)
    return 0;
  lengthAtOffsetOut = 0;
  if (CMBlockBufferGetDataPointer(theBuffer, offset, &lengthAtOffsetOut, 0, 0))
    return 0;
  if (length)
    v7 = length;
  else
    v7 = v5;
  return lengthAtOffsetOut >= v7;
}

CFStringRef BBufCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[CMBlockBuffer %p]"), a1);
}

__CFString *BBufCopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable(0, 0);
  AppendBBufDescription(Mutable, a1, 0, 0);
  return Mutable;
}

void AppendBBufDescription(__CFString *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  CFIndex v10;
  CFAllocatorRef v11;
  uint64_t v12;
  char v13;
  char v14;
  const __CFDictionary *v15;
  uint64_t v16;
  unsigned int **v17;
  uint64_t v18;
  uint64_t v19;
  __CFString *v20;
  uint64_t v21;
  uint64_t v22;
  __CFString *v23;
  const __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __CFString *context;
  int v30;
  int v31;

  v8 = (4 * a3);
  if (!a4)
  {
    v9 = *(_QWORD *)(a2 + 40);
    v10 = CFGetRetainCount((CFTypeRef)a2);
    v11 = CFGetAllocator((CFTypeRef)a2);
    CFStringAppendFormat(a1, 0, CFSTR("%*sCMBlockBuffer %p totalDataLength: %ld retainCount: %ld allocator: %p subBlockCapacity: %d\n"), v8, "", a2, v9, v10, v11, *(unsigned int *)(a2 + 36));
    v12 = 0;
    v13 = 1;
    do
    {
      v14 = v13;
      v15 = *(const __CFDictionary **)(a2 + 8 * v12 + 16);
      if (v15)
      {
        context = a1;
        v30 = a3;
        v31 = v12;
        CFDictionaryApplyFunction(v15, (CFDictionaryApplierFunction)DescribeBBufAnnotation, &context);
      }
      v13 = 0;
      v12 = 1;
    }
    while ((v14 & 1) != 0);
  }
  if (*(int *)(a2 + 32) >= 1)
  {
    v16 = 0;
    v17 = (unsigned int **)(a2 + 88);
    do
    {
      v18 = (*(_DWORD *)(a2 + 36) - 1);
      if (v16 == v18)
      {
        v19 = (uint64_t)*(v17 - 2);
        v20 = a1;
        v21 = a3;
        v22 = (a4 + 1);
LABEL_10:
        AppendBBufDescription(v20, v19, v21, v22);
      }
      else
      {
        CFStringAppendFormat(a1, 0, CFSTR("%*s [%d] "), v8, "", v16 + (v18 * a4));
        CFStringAppendFormat(a1, 0, CFSTR("%ld bytes @ offset %ld "), *(v17 - 3), *(v17 - 4));
        switch(*((_DWORD *)v17 - 10))
        {
          case 0:
            v23 = a1;
            v24 = CFSTR("UNUSED!!!\n");
            goto LABEL_14;
          case 1:
            CFStringAppend(a1, CFSTR("Buffer Reference:\n"));
            v19 = (uint64_t)*(v17 - 2);
            v20 = a1;
            v21 = (a3 + 1);
            v22 = 0;
            goto LABEL_10;
          case 2:
            CFStringAppendFormat(a1, 0, CFSTR("Memory UNALLOCATED, %ld bytes (allocator %p)\n"), *(v17 - 1), *v17, v25, v26, v27, v28);
            break;
          case 3:
            CFStringAppendFormat(a1, 0, CFSTR("Memory Block %p, %ld bytes (allocator %p)\n"), *(v17 - 2), *(v17 - 1), *v17, v26, v27, v28);
            break;
          case 4:
            CFStringAppendFormat(a1, 0, CFSTR("Memory UNALLOCATED, %ld bytes (custom V=%d A=%p F=%p R=%p)\n"), *(v17 - 1), **v17, *(_QWORD *)(*v17 + 1), *(_QWORD *)(*v17 + 3), *(_QWORD *)(*v17 + 5), v28);
            break;
          case 5:
            CFStringAppendFormat(a1, 0, CFSTR("Memory Block %p, %ld bytes (custom V=%d A=%p F=%p R=%p)\n"), *(v17 - 2), *(v17 - 1), **v17, *(_QWORD *)(*v17 + 1), *(_QWORD *)(*v17 + 3), *(_QWORD *)(*v17 + 5));
            break;
          default:
            v23 = a1;
            v24 = CFSTR("UNKNOWN STATE!!!\n");
LABEL_14:
            CFStringAppend(v23, v24);
            break;
        }
      }
      ++v16;
      v17 += 6;
    }
    while (v16 < *(int *)(a2 + 32));
  }
}

void DescribeBBufAnnotation(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  const char *v5;
  char buffer[4];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v8 = 0u;
  v7 = 0u;
  *(_DWORD *)buffer = 1061109567;
  CFStringGetCString(a1, buffer, 200, 0x8000100u);
  if (*(_DWORD *)(a3 + 12) == 1)
    v5 = "(P)";
  else
    v5 = "   ";
  CFStringAppendFormat(*(CFMutableStringRef *)a3, 0, CFSTR("%*s %-10s%s = %@\n"), (4 * *(_DWORD *)(a3 + 8)), "", buffer, v5, a2);
}

void BBufSetAttachment(char *cf, void *key, void *value, int a4)
{
  int v7;
  char *v8;
  __CFDictionary *Mutable;
  __CFDictionary **v10;
  __CFDictionary *v11;
  const __CFAllocator *v12;
  __CFDictionary *v13;

  v7 = 1 - a4;
  v8 = &cf[8 * a4];
  v11 = (__CFDictionary *)*((_QWORD *)v8 + 2);
  v10 = (__CFDictionary **)(v8 + 16);
  Mutable = v11;
  if (v11
    || (v12 = CFGetAllocator(cf),
        Mutable = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]),
        (*v10 = Mutable) != 0))
  {
    if (value)
      CFDictionarySetValue(Mutable, key, value);
    else
      CFDictionaryRemoveValue(Mutable, key);
  }
  v13 = *(__CFDictionary **)&cf[8 * v7 + 16];
  if (v13)
    CFDictionaryRemoveValue(v13, key);
}

const void *BBufGetAttachment(uint64_t a1, void *key, _DWORD *a3)
{
  uint64_t v6;
  char i;
  char v8;
  const __CFDictionary *v9;
  const void *result;

  v6 = 0;
  for (i = 1; ; i = 0)
  {
    v8 = i;
    v9 = *(const __CFDictionary **)(a1 + 8 * v6 + 16);
    if (v9)
    {
      result = CFDictionaryGetValue(v9, key);
      if (result)
        break;
    }
    v6 = 1;
    if ((v8 & 1) == 0)
      return 0;
  }
  if (a3)
    *a3 = v6;
  return result;
}

void BBufRemoveAttachment(uint64_t a1, void *key)
{
  uint64_t v4;
  char v5;
  char v6;
  __CFDictionary *v7;

  v4 = 0;
  v5 = 1;
  do
  {
    v6 = v5;
    v7 = *(__CFDictionary **)(a1 + 8 * v4 + 16);
    if (v7)
      CFDictionaryRemoveValue(v7, key);
    v5 = 0;
    v4 = 1;
  }
  while ((v6 & 1) != 0);
}

void BBufRemoveAllAttachments(uint64_t a1)
{
  uint64_t v2;
  char v3;
  char v4;
  uint64_t v5;
  const void *v6;
  _QWORD *v7;
  const void *v8;

  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    v5 = a1 + 8 * v2;
    v8 = *(const void **)(v5 + 16);
    v7 = (_QWORD *)(v5 + 16);
    v6 = v8;
    if (v8)
    {
      CFRelease(v6);
      *v7 = 0;
    }
    v3 = 0;
    v2 = 1;
  }
  while ((v4 & 1) != 0);
}

CFDictionaryRef BBufCopyDictionaryOfAttachments(const __CFAllocator *a1, uint64_t a2, unsigned int a3)
{
  const __CFDictionary *v3;

  v3 = *(const __CFDictionary **)(a2 + 8 * a3 + 16);
  if (v3)
    return CFDictionaryCreateCopy(a1, v3);
  else
    return 0;
}

uint64_t FigCaptionTextOutlineGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
  return sFigCaptionTextOutlineID;
}

uint64_t RegisterFigCaptionTextOutlineType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionTextOutlineID = result;
  return result;
}

uint64_t FigCaptionTextOutlineGetColor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t FigCaptionTextOutlineGetThickness(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t FigCaptionTextOutlineCreate(uint64_t a1, uint64_t a2, uint64_t a3, CGColor *a4, _QWORD *a5)
{
  uint64_t Instance;
  _QWORD *v10;
  CGColorRef v11;

  if (!a5)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v10 = (_QWORD *)Instance;
    v11 = CGColorRetain(a4);
    v10[3] = a3;
    v10[4] = v11;
    v10[2] = a2;
    *a5 = v10;
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigCaptionTextOutlineCreateNone(uint64_t a1, uint64_t *a2)
{
  uint64_t Instance;

  if (!a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_QWORD *)(Instance + 32) = 0;
    *(_OWORD *)(Instance + 16) = kFigGeometryDimensionZero;
    *a2 = Instance;
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

_QWORD *fcto_Init(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void fcto_Finalize(uint64_t a1)
{
  CGColorRelease(*(CGColorRef *)(a1 + 32));
}

BOOL fcto_Equal(_BOOL8 result, uint64_t a2)
{
  uint64_t v3;
  CFTypeID v4;
  CFTypeID v5;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
    result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionTextOutlineID)
      {
        v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType);
        if (v5 == sFigCaptionTextOutlineID)
        {
          result = CGColorEqualToColor(*(CGColorRef *)(v3 + 32), *(CGColorRef *)(a2 + 32));
          if (result)
            return FigGeometryDimensionEqualToDimension(*(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 24), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFHashCode fcto_Hash(CFTypeRef *a1)
{
  CFTypeID v2;

  if (a1
    && (v2 = CFGetTypeID(a1),
        FigThreadRunOnce(&sRegisterFigCaptionTextOutlineTypeOnce, (void (*)(void))RegisterFigCaptionTextOutlineType),
        v2 == sFigCaptionTextOutlineID))
  {
    return CFHash(a1[4]);
  }
  else
  {
    return 0;
  }
}

CFStringRef fcto_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionTextOutline %p]"), a1);
}

CFStringRef fcto_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionTextOutline %p]"), a1);
}

uint64_t FigVirtualCaptureCardCreate(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  CFTypeRef v4;
  uint64_t v5;
  _QWORD block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigVirtualCaptureCardCreate_block_invoke;
  block[3] = &unk_1E28D7C10;
  block[4] = &v8;
  block[5] = a1;
  block[6] = a2;
  if (FigVirtualCaptureCardCreate_sFigEndpointVirtualCaptureCardRemoteClientSetupOnce != -1)
    dispatch_once(&FigVirtualCaptureCardCreate_sFigEndpointVirtualCaptureCardRemoteClientSetupOnce, block);
  v4 = (CFTypeRef)FigVirtualCaptureCardCreate_sVirtualCaptureCardSingleton;
  if (FigVirtualCaptureCardCreate_sVirtualCaptureCardSingleton)
    v4 = CFRetain((CFTypeRef)FigVirtualCaptureCardCreate_sVirtualCaptureCardSingleton);
  *a3 = v4;
  v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t FigVirtualCaptureCardCreateInternal(uint64_t a1, _QWORD *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  uint64_t DerivedStorage;
  _QWORD *v7;
  pthread_mutex_t *v8;
  const __CFURL *v9;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;
  const __CFURL *v13;
  uint64_t FileInfo;
  CFTypeRef v15;
  ssize_t v17;
  CFIndex v18;
  uint64_t v19;
  CFStringRef v20;
  CFTypeRef cf;
  stat v22;
  stat v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  cf = 0;
  sVCCEnableCrashRecovery = 1;
  if (!a2)
    goto LABEL_27;
  ClassID = (_QWORD *)FigVirtualCaptureCardGetClassID();
  v5 = CMDerivedObjectCreate(a1, (uint64_t)&kFigVirtualCaptureCardVTable, ClassID, &cf);
  if ((_DWORD)v5)
  {
LABEL_28:
    FileInfo = v5;
    goto LABEL_13;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  if (!DerivedStorage)
  {
LABEL_27:
    v5 = FigSignalErrorAt(4294950086, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  v7 = (_QWORD *)DerivedStorage;
  v8 = FigSimpleMutexCreate();
  *v7 = v8;
  if (!v8)
  {
    FileInfo = 0;
    v15 = cf;
LABEL_17:
    *a2 = v15;
    return FileInfo;
  }
  v9 = (const __CFURL *)sVCCPreallocationFile;
  v7[2] = sVCCPreallocationFile;
  v7[3] = 0;
  v7[1] = vcc_StatFileCapacity(v9);
  v10 = cf;
  v11 = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  if (*(_QWORD *)(v11 + 24))
  {
    v13 = 0;
    FileInfo = 4294950080;
    goto LABEL_9;
  }
  v12 = v11;
  memset(&v23, 0, sizeof(v23));
  if (lstat(sVCCPreallocationSaveToSymlinkCString, &v23))
    goto LABEL_7;
  v17 = readlink(sVCCPreallocationSaveToSymlinkCString, (char *)&v23, 0x400uLL);
  if ((unint64_t)(v17 - 1024) < 0xFFFFFFFFFFFFFC01)
  {
    v13 = 0;
    FileInfo = 4294950078;
    goto LABEL_9;
  }
  v18 = v17;
  *((_BYTE *)&v23.st_dev + v17) = 0;
  if (!FigFileDoesFileExist(*(const __CFURL **)(v12 + 16)))
    goto LABEL_7;
  *(_QWORD *)(v12 + 8) = vcc_StatFileCapacity(*(const __CFURL **)(v12 + 16));
  memset(&v22, 0, 40);
  FileInfo = FigFileGetFileInfo(*(const __CFURL **)(v12 + 16), (uint64_t)&v22);
  if ((_DWORD)FileInfo)
  {
    v13 = 0;
    goto LABEL_9;
  }
  if (*(uint64_t *)&v22.st_dev <= 0)
  {
LABEL_7:
    v13 = 0;
  }
  else
  {
    v13 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)&v23, v18, 0);
    if (FigFileDoesFileExist(v13))
      goto LABEL_9;
    if (v13)
    {
      *(_QWORD *)(v12 + 24) = v13;
      CFRetain(v13);
      v19 = FigVirtualCaptureCard_SaveCapture((uint64_t)v10);
      if ((_DWORD)v19)
      {
        v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Unable to recover preallocated file data %@ due to FigVirtualCaptureCard_SaveCapture err: %d"), v10, v19);
        FileInfo = FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
        CFRelease(v20);
        goto LABEL_9;
      }
    }
  }
  FileInfo = 0;
LABEL_9:
  memset(&v22, 0, sizeof(v22));
  if (!lstat(sVCCPreallocationSaveToSymlinkCString, &v22))
    FileInfo = FigFileDeleteFile((const __CFURL *)sVCCPreallocationSaveToSymlink);
  if (v13)
    CFRelease(v13);
LABEL_13:
  v15 = cf;
  if ((_DWORD)FileInfo && cf)
  {
    CFRelease(cf);
    v15 = 0;
  }
  if (a2)
    goto LABEL_17;
  return FileInfo;
}

uint64_t FigVirtualCaptureCardGetSingleton(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __FigVirtualCaptureCardGetSingleton_block_invoke;
  v5[3] = &unk_1E28D7C38;
  v5[4] = &v6;
  v5[5] = a1;
  if (FigVirtualCaptureCardGetSingleton_sFigEndpointVirtualCaptureCardRemoteClientSetupOnce != -1)
    dispatch_once(&FigVirtualCaptureCardGetSingleton_sFigEndpointVirtualCaptureCardRemoteClientSetupOnce, v5);
  *a2 = FigVirtualCaptureCardGetSingleton_sVirtualCaptureCardSingleton;
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

CFTypeRef FigVirtualCaptureCardInitializeFilesystemPaths()
{
  uid_t v0;
  const __CFAllocator *v1;
  const __CFString *v2;
  const __CFString *v3;
  CFURLRef v4;
  const __CFURL *v5;
  CFStringRef v6;
  CFStringRef v7;
  int v8;
  CFStringRef v9;
  CFStringRef v10;
  CFTypeRef result;
  uint64_t v12;
  passwd *v13;
  passwd v14;
  char v15[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  memset(&v14, 0, sizeof(v14));
  v13 = 0;
  v0 = getuid();
  if (getpwuid_r(v0, &v14, v15, 0x400uLL, &v13) || !v13)
  {
    v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Failed to get user home dir with getpwuid_r()"));
    goto LABEL_8;
  }
  if (!v14.pw_dir)
  {
LABEL_10:
    v5 = CFURLCreateWithString(0, CFSTR("/var/mobile/Library/VirtualCaptureCard"), 0);
    goto LABEL_11;
  }
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v14.pw_dir, 0x600u);
  if (!v2)
  {
    v6 = CFStringCreateWithFormat(v1, 0, CFSTR("Failed to create user homedir from string %s"), v14.pw_dir);
LABEL_8:
    v7 = v6;
    v8 = FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
    CFRelease(v7);
    if (v8)
    {
      v9 = CFStringCreateWithFormat(v1, 0, CFSTR("Unable to get storage directory"), v12);
LABEL_13:
      v10 = v9;
      FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
      CFRelease(v10);
      goto LABEL_14;
    }
    goto LABEL_10;
  }
  v3 = v2;
  v4 = CFURLCreateWithString(0, v2, 0);
  CFRelease(v3);
  v5 = CFURLCreateWithString(0, CFSTR("/var/mobile/Library/VirtualCaptureCard"), 0);
  if (v4)
    CFRelease(v4);
LABEL_11:
  if (FigCFURLCreateDirectory(v5))
  {
    v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Unable to create preallocation directory at path %@"), v5);
    goto LABEL_13;
  }
  sVCCPreallocationFile = (uint64_t)CFURLCreateWithString(0, CFSTR("/var/mobile/Library/VirtualCaptureCard/43D8CBBD-2797-497D-8CAC-93D1952C83AE.virtual_capture_card"), 0);
  sVCCPreallocationSaveToSymlink = (uint64_t)CFURLCreateWithString(0, CFSTR("/var/mobile/Library/VirtualCaptureCard/43D8CBBD-2797-497D-8CAC-93D1952C83AE.virtual_capture_card_target"), 0);
  if (v5)
    CFRelease(v5);
  if (!CFURLGetFileSystemRepresentation((CFURLRef)sVCCPreallocationFile, 1u, sVCCPreallocationFileCString, 1024))
  {
    v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Preallocation file path %@ is invalid"), sVCCPreallocationFile);
    goto LABEL_13;
  }
  if (!CFURLGetFileSystemRepresentation((CFURLRef)sVCCPreallocationSaveToSymlink, 1u, (UInt8 *)sVCCPreallocationSaveToSymlinkCString, 1024))
  {
    v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Preallocation target file path %@ is invalid"), sVCCPreallocationSaveToSymlink);
    goto LABEL_13;
  }
LABEL_14:
  if (sVCCPreallocationFile)
    CFRetain((CFTypeRef)sVCCPreallocationFile);
  result = (CFTypeRef)sVCCPreallocationSaveToSymlink;
  if (sVCCPreallocationSaveToSymlink)
    return CFRetain((CFTypeRef)sVCCPreallocationSaveToSymlink);
  return result;
}

blkcnt_t vcc_StatFileCapacity(const __CFURL *a1)
{
  stat v2;
  UInt8 buffer[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    return 0;
  memset(&v2, 0, sizeof(v2));
  if (stat((const char *)buffer, &v2) == -1)
    return 0;
  else
    return v2.st_blocks << 9;
}

const __CFAllocator *FigVirtualCaptureCard_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;
  const void *v3;
  const __CFAllocator *result;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(DerivedStorage + 16) = 0;
  }
  v3 = *(const void **)(DerivedStorage + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(DerivedStorage + 24) = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  result = FigSimpleMutexDestroy(*(_QWORD *)DerivedStorage);
  *(_QWORD *)DerivedStorage = 0;
  return result;
}

__CFString *FigVirtualCaptureCard_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage;
  __CFString *Mutable;
  UInt8 buffer[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!CFURLGetFileSystemRepresentation(*(CFURLRef *)(DerivedStorage + 24), 1u, buffer, 1024))
    strcpy((char *)buffer, "N/A");
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigFigVirtualCaptureCard %p> capacity: %lld, preallocatedFileURLh %@, saveToFileURL: %s"), a1, *(_QWORD *)(DerivedStorage + 8), *(_QWORD *)(DerivedStorage + 16), buffer);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return Mutable;
}

uint64_t FigVirtualCaptureCard_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  const __CFURL *v7;
  uint64_t v8;
  int FileInfo;
  uint64_t v10;
  const void *v11;
  uint64_t v12;
  uint64_t v14;
  _OWORD v15[2];
  uint64_t v16;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!a2)
  {
LABEL_18:
    v14 = 4294950085;
LABEL_19:
    v12 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }
  if (!a4)
  {
    v14 = 4294950086;
    goto LABEL_19;
  }
  *a4 = 0;
  if (!CFEqual(a2, CFSTR("FigVirtualCaptureCardProperty_Capacity")))
  {
    if (CFEqual(a2, CFSTR("FigVirtualCaptureCardProperty_FreeSpace")))
    {
      v8 = *(_QWORD *)(DerivedStorage + 8);
      v7 = *(const __CFURL **)(DerivedStorage + 16);
      if (FigFileDoesFileExist(v7))
      {
        v16 = 0;
        memset(v15, 0, sizeof(v15));
        FileInfo = FigFileGetFileInfo(v7, (uint64_t)v15);
        v10 = 0;
        if (v8 >= 1 && !FileInfo)
          v10 = (v8 - *(_QWORD *)&v15[0]) & ~((v8 - *(_QWORD *)&v15[0]) >> 63);
      }
      else
      {
        v10 = 0;
      }
      *(_QWORD *)&v15[0] = v10;
      goto LABEL_15;
    }
    if (CFEqual(a2, CFSTR("FigVirtualCaptureCardProperty_PreallocatedStorageFileURL")))
    {
      v11 = *(const void **)(DerivedStorage + 16);
      if (v11)
        v11 = CFRetain(v11);
      goto LABEL_16;
    }
    goto LABEL_18;
  }
  *(_QWORD *)&v15[0] = vcc_StatFileCapacity(*(const __CFURL **)(DerivedStorage + 16));
LABEL_15:
  v11 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, v15);
LABEL_16:
  v12 = 0;
  *a4 = v11;
LABEL_17:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v12;
}

uint64_t FigVirtualCaptureCard_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage;
  CFTypeID v7;
  const __CFNumber *SInt64;
  uint64_t v9;
  uint64_t v10;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!a2 || !a3)
    goto LABEL_10;
  if (!CFEqual(a2, CFSTR("FigVirtualCaptureCardProperty_Capacity")))
  {
    v10 = 4294950085;
LABEL_8:
    v9 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v7 = CFGetTypeID(a3);
  if (v7 != CFNumberGetTypeID())
  {
LABEL_10:
    v10 = 4294950086;
    goto LABEL_8;
  }
  SInt64 = FigCFNumberGetSInt64((const __CFNumber *)a3);
  if (vcc_FigVirtualCaptureCardPreallocateCapacity(a1, (uint64_t)SInt64))
  {
    v10 = 4294950082;
    goto LABEL_8;
  }
  v9 = 0;
  *(_QWORD *)(DerivedStorage + 8) = SInt64;
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v9;
}

uint64_t vcc_FigVirtualCaptureCardPreallocateCapacity(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  const __CFURL *v4;
  uint64_t v5;
  blkcnt_t v6;
  blkcnt_t v7;
  uint64_t v8;
  CFStringRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t PreallocFile;
  CFStringRef v13;
  blkcnt_t v14;
  uint64_t v16;
  _OWORD v17[2];
  uint64_t v18;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v4 = *(const __CFURL **)(DerivedStorage + 16);
  if (!v4)
  {
    v16 = 4294950082;
LABEL_24:
    v5 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  if (*(_QWORD *)(DerivedStorage + 24))
  {
    v16 = 4294950080;
    goto LABEL_24;
  }
  if (!a2)
  {
    v10 = APFSCaptureDeletePreallocFile();
    if (!(_DWORD)v10)
    {
      v14 = 0;
      v5 = 0;
      goto LABEL_20;
    }
    v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("APFSCaptureDeletePreallocFile failed for : path %@, err %d"), *(_QWORD *)(DerivedStorage + 16), v10);
    goto LABEL_17;
  }
  if (!FigFileDoesFileExist(v4))
  {
LABEL_15:
    PreallocFile = APFSCaptureCreatePreallocFile();
    if ((_DWORD)PreallocFile)
    {
      v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("APFSCaptureCreatePreallocFile failed: path %@, err %d, capacity %lld"), *(_QWORD *)(DerivedStorage + 16), PreallocFile, a2);
      goto LABEL_17;
    }
LABEL_18:
    v5 = 0;
    goto LABEL_19;
  }
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  v5 = 4294950082;
  if (FigFileGetFileInfo(*(const __CFURL **)(DerivedStorage + 16), (uint64_t)v17) || *(_QWORD *)&v17[0])
    goto LABEL_19;
  v6 = vcc_StatFileCapacity(*(const __CFURL **)(DerivedStorage + 16));
  v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 >= v6)
      goto LABEL_18;
    v11 = APFSCaptureDeletePreallocFile();
    if ((_DWORD)v11)
    {
      v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("FigFileDeleteFile failed for path %@, err %d"), *(_QWORD *)(DerivedStorage + 16), v11);
      goto LABEL_17;
    }
    goto LABEL_15;
  }
  v8 = APFSCaptureExtendPreallocSizeForFile();
  if (!(_DWORD)v8)
    goto LABEL_18;
  v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("APFSCaptureExtendPreallocSizeForFile failed: path %@, err %d, growBy %lld"), *(_QWORD *)(DerivedStorage + 16), v8, v7);
LABEL_17:
  v13 = v9;
  v5 = FigSignalErrorAt(4294950082, 0, 0, 0, 0, 0, 0);
  CFRelease(v13);
LABEL_19:
  v14 = vcc_StatFileCapacity(*(const __CFURL **)(DerivedStorage + 16));
LABEL_20:
  *(_QWORD *)(DerivedStorage + 8) = v14;
  return v5;
}

uint64_t FigVirtualCaptureCard_ShowSystemUserInterface(uint64_t a1)
{
  CMBaseObjectGetDerivedStorage(a1);
  return 0;
}

uint64_t FigVirtualCaptureCard_ReserveForCaptureToFile(uint64_t a1, const __CFURL *a2)
{
  uint64_t DerivedStorage;
  uint64_t started;
  CFStringRef v5;
  CFStringRef v6;
  uint64_t v7;
  const __CFAllocator *v9;
  int *v10;
  const void *v11;
  uint64_t v12;
  char *v13;
  stat v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!*(_QWORD *)(DerivedStorage + 16))
    goto LABEL_18;
  if (*(_QWORD *)(DerivedStorage + 24))
  {
    v12 = 4294950080;
    goto LABEL_21;
  }
  if (!a2)
  {
    v12 = 4294950086;
    goto LABEL_21;
  }
  if (sVCCEnableCrashRecovery == 1)
  {
    memset(&v14, 0, sizeof(v14));
    if (!lstat(sVCCPreallocationSaveToSymlinkCString, &v14))
    {
LABEL_18:
      v12 = 4294950082;
LABEL_21:
      v7 = FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
      goto LABEL_11;
    }
  }
  if (!CFURLGetFileSystemRepresentation(a2, 1u, (UInt8 *)&v14, 1024))
  {
    v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Save to file path %@ is invalid"), a2);
    goto LABEL_10;
  }
  started = APFSCaptureStartCaptureInFile();
  if ((_DWORD)started)
  {
    v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("APFSCaptureStartCaptureInFile err %d"), started);
LABEL_10:
    v6 = v5;
    v7 = FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
    CFRelease(v6);
    goto LABEL_11;
  }
  if (sVCCEnableCrashRecovery == 1 && symlink((const char *)&v14, sVCCPreallocationSaveToSymlinkCString))
  {
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v10 = __error();
    v13 = strerror(*v10);
    v5 = CFStringCreateWithFormat(v9, 0, CFSTR("symlink failed for: %s -> %s, err: %s"), sVCCPreallocationSaveToSymlinkCString, &v14, v13);
    goto LABEL_10;
  }
  v11 = *(const void **)(DerivedStorage + 24);
  *(_QWORD *)(DerivedStorage + 24) = a2;
  CFRetain(a2);
  if (v11)
    CFRelease(v11);
  v7 = 0;
LABEL_11:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v7;
}

uint64_t FigVirtualCaptureCard_SaveCapture(uint64_t a1)
{
  uint64_t DerivedStorage;
  const __CFURL *v3;
  uint64_t v4;
  uint64_t v5;
  const __CFAllocator *v6;
  uint64_t v7;
  int *v8;
  char *v9;
  CFStringRef v10;
  uint64_t v11;
  CFStringRef v12;
  uint64_t v13;
  const void *v14;
  const __CFAllocator *v16;
  uint64_t v17;
  int *v18;
  const void *v19;
  uint64_t v20;
  char *v21;
  stat v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!*(_QWORD *)(DerivedStorage + 16))
  {
LABEL_21:
    v20 = 4294950082;
LABEL_23:
    v13 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  v3 = *(const __CFURL **)(DerivedStorage + 24);
  if (!v3)
  {
    v20 = 4294950079;
    goto LABEL_23;
  }
  if (sVCCEnableCrashRecovery == 1)
  {
    memset(&v22, 0, sizeof(v22));
    if (!lstat(sVCCPreallocationSaveToSymlinkCString, &v22))
    {
      v3 = *(const __CFURL **)(DerivedStorage + 24);
      goto LABEL_6;
    }
    goto LABEL_21;
  }
LABEL_6:
  if (!CFURLGetFileSystemRepresentation(v3, 1u, (UInt8 *)&v22, 1024))
  {
    v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Save to file path %@ is invalid"), *(_QWORD *)(DerivedStorage + 24));
LABEL_10:
    v10 = v12;
    v11 = 4294950078;
    goto LABEL_11;
  }
  v4 = APFSCaptureFinishCaptureForFile();
  if ((_DWORD)v4)
  {
    v5 = v4;
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v7 = *__error();
    v8 = __error();
    v9 = strerror(*v8);
    v10 = CFStringCreateWithFormat(v6, 0, CFSTR("APFSCaptureFinishCaptureForFile failed with err = 0x%08x, errno = 0x%08x, strerror = %s"), v5, v7, v9);
    v11 = 4294950077;
LABEL_11:
    v13 = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
    CFRelease(v10);
    goto LABEL_12;
  }
  if (sVCCEnableCrashRecovery == 1 && FigFileDeleteFile((const __CFURL *)sVCCPreallocationSaveToSymlink))
  {
    v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v17 = *__error();
    v18 = __error();
    v21 = strerror(*v18);
    v12 = CFStringCreateWithFormat(v16, 0, CFSTR("FigFileDeleteFile failed for %s, errno 0x%08x, strerror = %s"), &sVCCPreallocationFileCString, v17, v21);
    goto LABEL_10;
  }
  v19 = *(const void **)(DerivedStorage + 24);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(DerivedStorage + 24) = 0;
  }
  vcc_FigVirtualCaptureCardPreallocateCapacity(a1, *(_QWORD *)(DerivedStorage + 8));
  v13 = 0;
LABEL_12:
  v14 = *(const void **)(DerivedStorage + 24);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(DerivedStorage + 24) = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v13;
}

uint64_t FigFoundationCreateHardLink(uint64_t a1, const __CFURL *a2)
{
  id v4;
  uint64_t v5;
  uint64_t v7;

  v7 = 0;
  v4 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  if (FigFileDoesFileExist(a2)
    || (objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager"), "linkItemAtURL:toURL:error:", a1, a2, &v7) & 1) == 0)
  {
    v5 = FigSignalErrorAt(4294950434, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v5 = 0;
  }

  return v5;
}

CFTypeRef FigCFStringCreateWithBytesWithUnknownEncoding(const __CFAllocator *a1, const UInt8 *a2, CFIndex a3, void *a4, uint64_t *a5, uint64_t a6)
{
  void *v12;
  CFTypeID v13;
  const UInt8 *v14;
  CFDataRef v15;
  uint64_t v16;
  CFDataRef v17;
  void *v18;
  void *v19;
  unint64_t v20;
  uint64_t v22;
  CFTypeRef cf;

  cf = 0;
  v12 = (void *)MEMORY[0x193FFC34C]();
  if (!a2 && a3 || a3 < 0 || a4 && (v13 = CFGetTypeID(a4), v13 != CFDictionaryGetTypeID()))
  {
    v22 = 4294950436;
LABEL_38:
    FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
    goto LABEL_36;
  }
  if (!a3)
  {
LABEL_10:
    v15 = 0;
    goto LABEL_11;
  }
  v14 = a2;
  while ((*(char *)v14 & 0x80000000) == 0)
  {
    if (++v14 >= &a2[a3])
      goto LABEL_10;
  }
  v17 = CFDataCreate(a1, a2, a3);
  if (!v17)
  {
    v22 = 4294950435;
    goto LABEL_38;
  }
  v15 = v17;
  if (a4)
  {
    if (objc_msgSend(a4, "objectForKey:", *MEMORY[0x1E0CB31D8]))
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_39;
    }
    if (objc_msgSend(a4, "objectForKey:", *MEMORY[0x1E0CB31B8]))
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_39;
    }
    if ((v18 = (void *)objc_msgSend(a4, "objectForKey:", *MEMORY[0x1E0CB31E0])) != 0
      && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
      || (v19 = (void *)objc_msgSend(a4, "objectForKey:", *MEMORY[0x1E0CB31E8])) != 0
      && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
      || (!objc_msgSend(v19, "BOOLValue") || (unint64_t)objc_msgSend(v18, "count") >= 2)
      && (objc_msgSend(a4, "objectForKey:", *MEMORY[0x1E0CB31C8])
       && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
       || objc_msgSend(a4, "objectForKey:", *MEMORY[0x1E0CB31D0])
       && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
       || objc_msgSend(a4, "objectForKey:", *MEMORY[0x1E0CB31C0])
       && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)))
    {
LABEL_39:
      FigSignalErrorAt(4294950436, 0, 0, 0, 0, 0, 0);
      goto LABEL_35;
    }
  }
  v20 = objc_msgSend(MEMORY[0x1E0CB3940], "stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:", v15, a4, &cf, a6);
  if (cf)
  {
    cf = CFRetain(cf);
    *a5 = CFStringConvertNSStringEncodingToEncoding(v20);
LABEL_35:
    CFRelease(v15);
    goto LABEL_36;
  }
LABEL_11:
  cf = CFStringCreateWithBytes(a1, a2, a3, 0x8000100u, 1u);
  v16 = 0xFFFFFFFFLL;
  if (cf)
    v16 = 134217984;
  *a5 = v16;
  if (v15)
    goto LABEL_35;
LABEL_36:
  objc_autoreleasePoolPop(v12);
  return cf;
}

CFTypeRef FigCFStringCreateWithJSONDictionary(int a1, CFTypeRef cf)
{
  CFTypeID v3;

  if (cf && (v3 = CFGetTypeID(cf), v3 == CFDictionaryGetTypeID()))
    return figCFStringCreateWithCFDictionaryOrCFArray(cf);
  else
    return 0;
}

CFTypeRef figCFStringCreateWithCFDictionaryOrCFArray(CFTypeRef cf)
{
  CFTypeRef v1;
  CFTypeID v2;
  CFTypeID TypeID;
  CFTypeID v4;
  CFTypeID v5;
  void *v6;
  uint64_t v7;
  id v8;

  v1 = cf;
  if (cf)
  {
    v2 = CFGetTypeID(cf);
    TypeID = CFDictionaryGetTypeID();
    v4 = CFGetTypeID(v1);
    v5 = CFArrayGetTypeID();
    if (v2 == TypeID || v4 == v5)
    {
      v6 = (void *)MEMORY[0x193FFC34C](v5);
      if (objc_msgSend(MEMORY[0x1E0CB36D8], "isValidJSONObject:", v1)
        && (v7 = objc_msgSend(MEMORY[0x1E0CB36D8], "dataWithJSONObject:options:error:", v1, 1, 0),
            (v8 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithData:encoding:", v7, 4)) != 0))
      {
        v1 = CFRetain(v8);
      }
      else
      {
        v1 = 0;
      }
      objc_autoreleasePoolPop(v6);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

CFTypeRef FigCFStringCreateWithJSONArray(int a1, CFTypeRef cf)
{
  CFTypeID v3;

  if (cf && (v3 = CFGetTypeID(cf), v3 == CFArrayGetTypeID()))
    return figCFStringCreateWithCFDictionaryOrCFArray(cf);
  else
    return 0;
}

uint64_t FigCreateSerializedDictionaryFromNSErrorUserInfo(const __CFDictionary *a1, __CFDictionary **a2)
{
  uint64_t result;
  __CFDictionary *Mutable;
  void *value;

  value = 0;
  result = 4294950436;
  if (a1 && a2)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (CFDictionaryGetValueIfPresent(a1, (const void *)*MEMORY[0x1E0CB3310], (const void **)&value))
      CFDictionarySetValue(Mutable, CFSTR("CFError_NetworkUnavailableReason"), value);
    result = 0;
    *a2 = Mutable;
  }
  return result;
}

uint64_t FigCreateNSErrorUserInfoFromSerializedDictionary(const __CFDictionary *a1, __CFDictionary **a2)
{
  uint64_t result;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  void *value;

  value = 0;
  result = 4294950436;
  if (a1 && a2)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v6 = Mutable;
      if (CFDictionaryGetValueIfPresent(a1, CFSTR("CFError_NetworkUnavailableReason"), (const void **)&value))
        CFDictionarySetValue(v6, (const void *)*MEMORY[0x1E0CB3310], value);
      result = 0;
      *a2 = v6;
    }
    else
    {
      return 4294950435;
    }
  }
  return result;
}

uint64_t FigCreateCFDataFromBase64EncodedString(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  result = 4294950436;
  if (a1 && a2)
  {
    v5 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", a1, 0);
    if (v5)
    {
      v6 = v5;
      result = 0;
      *a2 = v6;
    }
    else
    {
      return 4294950436;
    }
  }
  return result;
}

const CMBufferCallbacks *CMBufferQueueGetCallbacksForUnsortedSampleBuffers(void)
{
  const CMBufferCallbacks *result;

  result = (const CMBufferCallbacks *)&gFigBufferQueueCallbacksForUnsortedSampleBuffers;
  unk_1EE13F874 = sbufGetDecodeTimeStamp;
  unk_1EE13F87C = sbufGetPresentationTimeStamp;
  unk_1EE13F884 = sbufGetDuration;
  unk_1EE13F88C = sbufDataIsReady;
  unk_1EE13F89C = CFSTR("FigSampleBufferDataBecameReady");
  unk_1EE13F8A4 = sbufGetTotalSampleSize;
  return result;
}

const CMBufferCallbacks *CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(void)
{
  const CMBufferCallbacks *result;

  result = (const CMBufferCallbacks *)&gCMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS;
  unk_1EE13F8B8 = sbufGetDecodeTimeStamp;
  unk_1EE13F8C0 = sbufGetPresentationTimeStamp;
  unk_1EE13F8C8 = sbufGetDuration;
  unk_1EE13F8D0 = sbufDataIsReady;
  unk_1EE13F8D8 = sbufCompareOutputPTS;
  unk_1EE13F8E0 = CFSTR("FigSampleBufferDataBecameReady");
  unk_1EE13F8E8 = sbufGetTotalSampleSize;
  return result;
}

uint64_t sbufCompareOutputPTS(opaqueCMSampleBuffer *a1, opaqueCMSampleBuffer *a2)
{
  CMTime v4;
  CMTime time1;
  CMTime v6;
  CMTime v7;

  CMSampleBufferGetOutputPresentationTimeStamp(&v7, a1);
  CMSampleBufferGetOutputPresentationTimeStamp(&v6, a2);
  time1 = v7;
  v4 = v6;
  return CMTimeCompare(&time1, &v4);
}

CFTypeID CMBufferQueueGetTypeID(void)
{
  FigThreadRunOnce(&sRegisterFigBufferQueueTypeOnce, (void (*)(void))registerFigBufferQueueType);
  return sFigBufferQueueID;
}

OSStatus CMBufferQueueCreate(CFAllocatorRef allocator, CMItemCount capacity, const CMBufferCallbacks *callbacks, CMBufferQueueRef *queueOut)
{
  return figBufferQueueCreateWithCallbacksOrHandlers((uint64_t)allocator, capacity, (uint64_t)callbacks, 0, (uint64_t *)queueOut);
}

uint64_t figBufferQueueCreateWithCallbacksOrHandlers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t Instance;
  CFNotificationCenterRef DefaultLocalCenter;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFTypeRef v14;
  CFTypeRef v15;
  pthread_mutex_t *v16;
  const __CFAllocator *v17;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v19;
  CFMutableDictionaryRef v20;
  CMTime v22;

  if (a5 && a3 | a4)
  {
    FigThreadRunOnce(&sRegisterFigBufferQueueTypeOnce, (void (*)(void))registerFigBufferQueueType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      if (a3 && (*(_DWORD *)a3 > 1u || !*(_QWORD *)(a3 + 28)) || a4 && (*(_QWORD *)a4 != 1 || !*(_QWORD *)(a4 + 24)))
      {
        v13 = 4294954534;
        goto LABEL_31;
      }
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      v11 = CMNotificationCenterRegisterForBarrierSupport((uint64_t)DefaultLocalCenter, Instance);
      if ((_DWORD)v11)
      {
        v12 = v11;
LABEL_33:
        CFRelease((CFTypeRef)Instance);
        Instance = 0;
        goto LABEL_34;
      }
      if (a3)
      {
        *(_DWORD *)(Instance + 48) = *(_DWORD *)a3;
        *(_QWORD *)(Instance + 52) = *(_QWORD *)(a3 + 4);
        *(_QWORD *)(Instance + 60) = *(_QWORD *)(a3 + 12);
        *(_QWORD *)(Instance + 68) = *(_QWORD *)(a3 + 20);
        *(_QWORD *)(Instance + 76) = *(_QWORD *)(a3 + 28);
        *(_QWORD *)(Instance + 84) = *(_QWORD *)(a3 + 36);
        *(_QWORD *)(Instance + 92) = *(_QWORD *)(a3 + 44);
        v14 = *(CFTypeRef *)(a3 + 52);
        if (v14)
          v14 = CFRetain(v14);
        *(_QWORD *)(Instance + 100) = v14;
        if (*(_DWORD *)a3)
          *(_QWORD *)(Instance + 108) = *(_QWORD *)(a3 + 60);
        *(_BYTE *)(Instance + 120) = 1;
      }
      if (a4)
      {
        *(_QWORD *)(Instance + 48) = *(_QWORD *)a4;
        *(_QWORD *)(Instance + 56) = _Block_copy(*(const void **)(a4 + 8));
        *(_QWORD *)(Instance + 64) = _Block_copy(*(const void **)(a4 + 16));
        *(_QWORD *)(Instance + 72) = _Block_copy(*(const void **)(a4 + 24));
        *(_QWORD *)(Instance + 80) = _Block_copy(*(const void **)(a4 + 32));
        *(_QWORD *)(Instance + 88) = _Block_copy(*(const void **)(a4 + 40));
        v15 = *(CFTypeRef *)(a4 + 48);
        if (v15)
          v15 = CFRetain(v15);
        *(_QWORD *)(Instance + 96) = v15;
        *(_QWORD *)(Instance + 104) = _Block_copy(*(const void **)(a4 + 56));
      }
      v16 = FigReentrantMutexCreate();
      *(_QWORD *)(Instance + 16) = v16;
      if (v16)
      {
        CMTimeMake(&v22, 0, 1);
        *(CMTime *)(Instance + 124) = v22;
        *(_QWORD *)(Instance + 152) = 0;
        *(_QWORD *)(Instance + 40) = a2;
        if (!a2
          || (v17 = CFGetAllocator((CFTypeRef)Instance),
              Mutable = CFArrayCreateMutable(v17, *(_QWORD *)(Instance + 40), MEMORY[0x1E0C9B378]),
              (*(_QWORD *)(Instance + 24) = Mutable) != 0)
          && (v19 = CFGetAllocator((CFTypeRef)Instance),
              v20 = CFDictionaryCreateMutable(v19, *(_QWORD *)(Instance + 40), 0, MEMORY[0x1E0C9B3A0]),
              (*(_QWORD *)(Instance + 32) = v20) != 0))
        {
          v12 = 0;
          *(_OWORD *)(Instance + 216) = *(_OWORD *)&kCMTimeInvalid.value;
          *(_QWORD *)(Instance + 232) = 0;
          *(_OWORD *)(Instance + 240) = *(_OWORD *)&kCMTimeZero.value;
          *(_QWORD *)(Instance + 256) = 0;
LABEL_35:
          *a5 = Instance;
          return v12;
        }
      }
    }
    v13 = 4294954536;
LABEL_31:
    v12 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
    if (!(_DWORD)v12)
      goto LABEL_34;
LABEL_32:
    if (!Instance)
      goto LABEL_34;
    goto LABEL_33;
  }
  v12 = FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  Instance = 0;
  if ((_DWORD)v12)
    goto LABEL_32;
LABEL_34:
  if (a5)
    goto LABEL_35;
  return v12;
}

OSStatus CMBufferQueueCreateWithHandlers(CFAllocatorRef allocator, CMItemCount capacity, const CMBufferHandlers *handlers, CMBufferQueueRef *queueOut)
{
  return figBufferQueueCreateWithCallbacksOrHandlers((uint64_t)allocator, capacity, 0, (uint64_t)handlers, (uint64_t *)queueOut);
}

OSStatus CMBufferQueueEnqueue(CMBufferQueueRef queue, CMBufferRef buf)
{
  uint64_t v4;
  OSStatus v6;
  uint64_t (*v7)(CMBufferQueueRef, CMBufferRef, _QWORD);
  uint64_t v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  uint64_t v12;
  CFComparisonResult (__cdecl *v13)(const void *, const void *, void *);
  const __CFArray *v14;
  void *v15;
  const __CFAllocator *v16;
  CFMutableArrayRef Mutable;
  const __CFAllocator *v18;
  CFMutableDictionaryRef v19;
  CFIndex v20;
  CFIndex v21;
  CMBufferQueueRef v22;
  CFRange v23;

  if (!queue || !buf)
    return FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (!*((_BYTE *)queue + 168))
  {
    if (*((_BYTE *)queue + 121))
    {
      v4 = 4294954533;
      goto LABEL_8;
    }
    v7 = (uint64_t (*)(CMBufferQueueRef, CMBufferRef, _QWORD))*((_QWORD *)queue + 25);
    if (v7)
    {
      v6 = v7(queue, buf, *((_QWORD *)queue + 26));
      if (v6)
        goto LABEL_9;
    }
    v8 = *((_QWORD *)queue + 24);
    if (v8)
    {
      v6 = (*(uint64_t (**)(uint64_t, CMBufferQueueRef, CMBufferRef))(v8 + 16))(v8, queue, buf);
      if (v6)
        goto LABEL_9;
    }
    v9 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (!v9)
    {
      v16 = CFGetAllocator(queue);
      Mutable = CFArrayCreateMutable(v16, *((_QWORD *)queue + 5), MEMORY[0x1E0C9B378]);
      *((_QWORD *)queue + 3) = Mutable;
      if (!Mutable
        || (v18 = CFGetAllocator(queue),
            v19 = CFDictionaryCreateMutable(v18, *((_QWORD *)queue + 5), 0, MEMORY[0x1E0C9B3A0]),
            (*((_QWORD *)queue + 4) = v19) == 0))
      {
        v4 = 4294954536;
        goto LABEL_8;
      }
      v9 = (const __CFArray *)*((_QWORD *)queue + 3);
    }
    Count = CFArrayGetCount(v9);
    v11 = Count;
    v12 = *((_QWORD *)queue + 5);
    if (v12 && Count == v12)
    {
      v4 = 4294954532;
      goto LABEL_8;
    }
    if (*((_BYTE *)queue + 120))
    {
      v13 = *(CFComparisonResult (__cdecl **)(const void *, const void *, void *))((char *)queue + 92);
      if (v13)
      {
        v14 = (const __CFArray *)*((_QWORD *)queue + 3);
        v15 = *(void **)((char *)queue + 52);
LABEL_27:
        v23.location = 0;
        v23.length = v11;
        v20 = CFArrayBSearchValues(v14, v23, buf, v13, v15);
        if (v20 >= v11)
          v21 = v11;
        else
          v21 = v20;
        v22 = queue;
        goto LABEL_32;
      }
    }
    else
    {
      v15 = (void *)*((_QWORD *)queue + 11);
      if (v15)
      {
        v14 = (const __CFArray *)*((_QWORD *)queue + 3);
        v13 = (CFComparisonResult (__cdecl *)(const void *, const void *, void *))figBufferQueueCallCompareHandler;
        goto LABEL_27;
      }
    }
    v22 = queue;
    v21 = v11;
LABEL_32:
    bufQInsertElementAtIndex((uint64_t)v22, v21, buf);
    v6 = 0;
    goto LABEL_9;
  }
  v4 = 4294954530;
LABEL_8:
  v6 = FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
LABEL_9:
  FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  return v6;
}

uint64_t figBufferQueueCallCompareHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

OSStatus CMBufferQueueSetValidationCallback(CMBufferQueueRef queue, CMBufferValidationCallback callback, void *refcon)
{
  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    *((_QWORD *)queue + 25) = callback;
    *((_QWORD *)queue + 26) = refcon;
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

OSStatus CMBufferQueueSetValidationHandler(CMBufferQueueRef queue, CMBufferValidationHandler handler)
{
  const void *v4;

  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v4 = (const void *)*((_QWORD *)queue + 24);
    *((_QWORD *)queue + 24) = _Block_copy(handler);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    v4 = 0;
  }
  _Block_release(v4);
  return 0;
}

CMBufferRef CMBufferQueueDequeueAndRetain(CMBufferQueueRef queue)
{
  const void *v2;
  const __CFArray *v4;
  const void *ValueAtIndex;

  if (!queue)
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((_BYTE *)queue + 168))
  {
    FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v4 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v4 && CFArrayGetCount(v4))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
      v2 = ValueAtIndex;
      if (ValueAtIndex)
      {
        CFRetain(ValueAtIndex);
        bufQRemoveElementAtIndex((uint64_t)queue);
      }
      goto LABEL_5;
    }
  }
  v2 = 0;
LABEL_5:
  FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  return v2;
}

CMBufferRef CMBufferQueueDequeueIfDataReadyAndRetain(CMBufferQueueRef queue)
{
  const void *ValueAtIndex;
  const __CFArray *v4;
  unsigned int (*v5)(void);
  uint64_t v6;

  if (!queue)
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (!*((_BYTE *)queue + 168))
  {
    v4 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (!v4 || !CFArrayGetCount(v4))
      goto LABEL_4;
    ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
    if (!ValueAtIndex)
      goto LABEL_5;
    if (*((_BYTE *)queue + 120))
    {
      v5 = *(unsigned int (**)(void))((char *)queue + 84);
      if (!v5)
        goto LABEL_17;
    }
    else
    {
      v6 = *((_QWORD *)queue + 10);
      if (!v6)
        goto LABEL_17;
      v5 = *(unsigned int (**)(void))(v6 + 16);
    }
    if (!v5())
      goto LABEL_4;
LABEL_17:
    CFRetain(ValueAtIndex);
    bufQRemoveElementAtIndex((uint64_t)queue);
    goto LABEL_5;
  }
  FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
LABEL_4:
  ValueAtIndex = 0;
LABEL_5:
  FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  return ValueAtIndex;
}

const void *FigBufferQueueDequeueIfMatchingAndRetain(uint64_t a1, const void *a2)
{
  const void *v4;
  const __CFArray *v6;

  if (!a1 || !a2)
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(_BYTE *)(a1 + 168))
  {
    FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v6 = *(const __CFArray **)(a1 + 24);
    if (v6 && CFArrayGetCount(v6))
    {
      v4 = 0;
      if (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0) == a2)
      {
        CFRetain(a2);
        bufQRemoveElementAtIndex(a1);
        v4 = a2;
      }
      goto LABEL_6;
    }
  }
  v4 = 0;
LABEL_6:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v4;
}

CMBufferRef CMBufferQueueGetHead(CMBufferQueueRef queue)
{
  const __CFArray *v2;
  const void *ValueAtIndex;

  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v2 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v2 && CFArrayGetCount(v2))
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
    else
      ValueAtIndex = 0;
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return ValueAtIndex;
}

CMBufferRef CMBufferQueueCopyHead(CMBufferQueueRef queue)
{
  const __CFArray *v2;
  const void *ValueAtIndex;
  const void *v4;

  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v2 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v2 && CFArrayGetCount(v2))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
      v4 = ValueAtIndex;
      if (ValueAtIndex)
        CFRetain(ValueAtIndex);
    }
    else
    {
      v4 = 0;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v4;
}

Boolean CMBufferQueueIsEmpty(CMBufferQueueRef queue)
{
  const __CFArray *v2;
  Boolean v3;

  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v2 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v2)
      v3 = CFArrayGetCount(v2) == 0;
    else
      v3 = 1;
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 1;
  }
  return v3;
}

OSStatus CMBufferQueueMarkEndOfData(CMBufferQueueRef queue)
{
  OSStatus v2;
  const __CFSet *v4;

  if (!queue)
    return FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((_BYTE *)queue + 168))
  {
    v2 = FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *((_BYTE *)queue + 121) = 1;
    *((_BYTE *)queue + 184) = 0;
    v4 = (const __CFSet *)*((_QWORD *)queue + 20);
    if (v4)
      CFSetApplyFunction(v4, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, queue);
    v2 = 0;
  }
  FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  return v2;
}

Boolean CMBufferQueueContainsEndOfData(CMBufferQueueRef queue)
{
  Boolean v2;

  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v2 = *((_BYTE *)queue + 121);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 1;
  }
  return v2;
}

Boolean CMBufferQueueIsAtEndOfData(CMBufferQueueRef queue)
{
  int v2;

  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v2 = *((unsigned __int8 *)queue + 121);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    if (v2)
      LOBYTE(v2) = CMBufferQueueIsEmpty(queue) != 0;
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    LOBYTE(v2) = 1;
  }
  return v2;
}

uint64_t resetWithCallback(uint64_t a1, void (*a2)(CFTypeRef, uint64_t), uint64_t a3)
{
  uint64_t v6;
  __CFArray *Mutable;
  const __CFArray *v9;
  const __CFAllocator *v10;
  CFIndex Count;
  const __CFSet *v12;
  const void *v13;
  CFTypeRef v14;
  const void *ValueAtIndex;

  if (a1)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    if (*(_BYTE *)(a1 + 168))
    {
      v6 = FigSignalErrorAt(4294954530, 0, 0, 0, 0, 0, 0);
      Mutable = 0;
    }
    else
    {
      *(_BYTE *)(a1 + 121) = 0;
      v9 = *(const __CFArray **)(a1 + 24);
      if (v9)
      {
        if (!a2)
        {
          Mutable = 0;
          goto LABEL_22;
        }
        v10 = CFGetAllocator((CFTypeRef)a1);
        Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
        Mutable = CFArrayCreateMutable(v10, Count, MEMORY[0x1E0C9B378]);
        while (1)
        {
          v9 = *(const __CFArray **)(a1 + 24);
LABEL_22:
          if (!CFArrayGetCount(v9))
            break;
          if (Mutable)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), 0);
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
          bufQRemoveElementAtIndex(a1);
        }
      }
      else
      {
        Mutable = 0;
      }
      *(_BYTE *)(a1 + 184) = 1;
      v12 = *(const __CFSet **)(a1 + 160);
      if (v12)
        CFSetApplyFunction(v12, (CFSetApplierFunction)evaluateAndMaybeFireTrigger, (void *)a1);
      v6 = 0;
      if (a2 && Mutable)
      {
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
        if (CFArrayGetCount(Mutable))
        {
          do
          {
            v13 = CFArrayGetValueAtIndex(Mutable, 0);
            v14 = CFRetain(v13);
            CFArrayRemoveValueAtIndex(Mutable, 0);
            a2(v14, a3);
            CFRelease(v14);
          }
          while (CFArrayGetCount(Mutable));
          v6 = 0;
        }
        else
        {
          v6 = 0;
        }
        goto LABEL_5;
      }
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    if (!Mutable)
      return v6;
LABEL_5:
    CFRelease(Mutable);
    return v6;
  }
  return FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
}

OSStatus CMBufferQueueReset(CMBufferQueueRef queue)
{
  return resetWithCallback((uint64_t)queue, 0, 0);
}

CMTime *__cdecl CMBufferQueueGetMinDecodeTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  const __CFArray *v5;
  uint64_t (*v6)(uint64_t, uint64_t);
  char *v7;
  uint64_t v8;
  const __CFArray *v9;
  _QWORD v10[4];
  CFRange v11;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!queue)
    return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((_BYTE *)queue + 120))
  {
    if (!*(_QWORD *)((char *)queue + 60))
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
LABEL_7:
    v5 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v5 && CFArrayGetCount(v5) >= 1)
    {
      v10[3] = 0;
      v10[0] = retstr;
      if (*((_BYTE *)queue + 120))
      {
        v6 = *(uint64_t (**)(uint64_t, uint64_t))((char *)queue + 60);
        v7 = (char *)queue + 52;
      }
      else
      {
        v7 = (char *)queue + 56;
        v6 = figBufferQueueCallGetTimeHandler;
      }
      v8 = *(_QWORD *)v7;
      v10[1] = v6;
      v10[2] = v8;
      v9 = (const __CFArray *)*((_QWORD *)queue + 3);
      v11.length = CFArrayGetCount(v9);
      v11.location = 0;
      CFArrayApplyFunction(v9, v11, (CFArrayApplierFunction)findBestTimeStamp, v10);
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  if (*((_QWORD *)queue + 7))
    goto LABEL_7;
  return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
}

uint64_t figBufferQueueCallGetTimeHandler(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CMTime *__cdecl CMBufferQueueGetFirstDecodeTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  const __CFArray *v4;
  void (*v5)(const void *, _QWORD);
  const void *ValueAtIndex;
  uint64_t v7;
  const void *v8;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!queue)
    return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((_BYTE *)queue + 120))
  {
    if (!*(_QWORD *)((char *)queue + 60))
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
LABEL_7:
    v4 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v4 && CFArrayGetCount(v4))
    {
      if (*((_BYTE *)queue + 120))
      {
        v5 = *(void (**)(const void *, _QWORD))((char *)queue + 60);
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
        v5(ValueAtIndex, *(_QWORD *)((char *)queue + 52));
      }
      else
      {
        v7 = *((_QWORD *)queue + 7);
        v8 = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
        (*(void (**)(uint64_t, const void *))(v7 + 16))(v7, v8);
      }
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  if (*((_QWORD *)queue + 7))
    goto LABEL_7;
  return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
}

CMTime *__cdecl CMBufferQueueGetMinPresentationTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  const __CFArray *v5;
  CFIndex Count;
  uint64_t v7;
  CFIndex v8;
  void (*v9)(CMTime *__return_ptr, const void *, _QWORD);
  const void *ValueAtIndex;
  uint64_t v11;
  const void *v12;
  CMTime v13;
  CMTime time2;
  CMTime time1;
  CMTime v16;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!queue)
    return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((_BYTE *)queue + 120))
  {
    if (!*(_QWORD *)((char *)queue + 68))
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
LABEL_7:
    v5 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v5)
    {
      Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        v7 = Count;
        v8 = 0;
        while (1)
        {
          memset(&v16, 0, sizeof(v16));
          if (*((_BYTE *)queue + 120))
          {
            v9 = *(void (**)(CMTime *__return_ptr, const void *, _QWORD))((char *)queue + 68);
            ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), v8);
            v9(&v16, ValueAtIndex, *(_QWORD *)((char *)queue + 52));
          }
          else
          {
            v11 = *((_QWORD *)queue + 8);
            v12 = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), v8);
            (*(void (**)(CMTime *__return_ptr, uint64_t, const void *))(v11 + 16))(&v16, v11, v12);
          }
          if ((v16.flags & 1) != 0)
          {
            if ((retstr->flags & 1) == 0 || (time1 = v16, time2 = *retstr, CMTimeCompare(&time1, &time2) < 0))
              *retstr = v16;
            if ((*((_BYTE *)queue + 252) & 1) != 0)
            {
              memset(&time1, 0, sizeof(time1));
              time2 = v16;
              v13 = *retstr;
              CMTimeSubtract(&time1, &time2, &v13);
              time2 = time1;
              v13 = *(CMTime *)((_BYTE *)queue + 10);
              if ((CMTimeCompare(&time2, &v13) & 0x80000000) == 0)
                break;
            }
          }
          if (v7 == ++v8)
          {
            v8 = v7;
            break;
          }
        }
        if (v7 >= 10 && v8 == v7)
          bufQReconstructBounds((uint64_t)queue);
      }
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  if (*((_QWORD *)queue + 8))
    goto LABEL_7;
  return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
}

double bufQReconstructBounds(uint64_t a1)
{
  CMTimeFlags v2;
  CMTimeEpoch epoch;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  void (*v7)(CMTime *__return_ptr, const void *, _QWORD);
  const void *ValueAtIndex;
  uint64_t v9;
  const void *v10;
  CMTimeFlags flags;
  double result;
  CMTime v13;
  CMTime time2;
  CMTime time1;
  CMTime v16;
  CMTime v17;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  value = 0;
  v2 = 0;
  timescale = 0;
  epoch = 0;
  *(_OWORD *)&v17.value = *(_OWORD *)&kCMTimeZero.value;
  v17.epoch = 0;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    v5 = Count;
    for (i = 0; v5 != i; ++i)
    {
      memset(&v16, 0, sizeof(v16));
      if (*(_BYTE *)(a1 + 120))
      {
        v7 = *(void (**)(CMTime *__return_ptr, const void *, _QWORD))(a1 + 68);
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
        v7(&v16, ValueAtIndex, *(_QWORD *)(a1 + 52));
      }
      else
      {
        v9 = *(_QWORD *)(a1 + 64);
        v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), i);
        (*(void (**)(CMTime *__return_ptr, uint64_t, const void *))(v9 + 16))(&v16, v9, v10);
      }
      flags = v16.flags;
      if ((v16.flags & 1) != 0 && (v2 & 1) != 0)
      {
        time1 = v16;
        time2.value = value;
        time2.timescale = timescale;
        time2.flags = v2;
        time2.epoch = epoch;
        if (CMTimeCompare(&time1, &time2) < 0)
        {
          memset(&time1, 0, sizeof(time1));
          time2.value = value;
          time2.timescale = timescale;
          time2.flags = v2;
          time2.epoch = epoch;
          v13 = v16;
          CMTimeSubtract(&time1, &time2, &v13);
          time2 = v17;
          v13 = time1;
          CMTimeMaximum(&v17, &time2, &v13);
        }
      }
      else if ((v2 & 1) == 0)
      {
        goto LABEL_14;
      }
      if ((v16.flags & 1) == 0)
        continue;
      time1 = v16;
      time2.value = value;
      time2.timescale = timescale;
      time2.flags = v2;
      time2.epoch = epoch;
      if (CMTimeCompare(&time1, &time2) < 1)
        continue;
      flags = v16.flags;
LABEL_14:
      value = v16.value;
      timescale = v16.timescale;
      epoch = v16.epoch;
      v2 = flags;
    }
  }
  *(_QWORD *)(a1 + 216) = value;
  *(_DWORD *)(a1 + 224) = timescale;
  *(_DWORD *)(a1 + 228) = v2;
  *(_QWORD *)(a1 + 232) = epoch;
  result = *(double *)&v17.value;
  *(CMTime *)(a1 + 240) = v17;
  return result;
}

CMTime *__cdecl CMBufferQueueGetMaxPresentationTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  const __CFArray *v5;
  CFIndex Count;
  uint64_t v7;
  CFIndex v8;
  CFIndex v9;
  void (*v10)(CMTime *__return_ptr, const void *, _QWORD);
  const void *ValueAtIndex;
  uint64_t v12;
  const void *v13;
  CMTime v14;
  CMTime time2;
  CMTime time1;
  CMTime v17;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!queue)
    return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((_BYTE *)queue + 120))
  {
    if (!*(_QWORD *)((char *)queue + 68))
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
LABEL_7:
    v5 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v5)
    {
      Count = CFArrayGetCount(v5);
      if (Count >= 1)
      {
        v7 = Count;
        v8 = Count + 1;
        while (1)
        {
          v9 = v8 - 2;
          memset(&v17, 0, sizeof(v17));
          if (*((_BYTE *)queue + 120))
          {
            v10 = *(void (**)(CMTime *__return_ptr, const void *, _QWORD))((char *)queue + 68);
            ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), v9);
            v10(&v17, ValueAtIndex, *(_QWORD *)((char *)queue + 52));
          }
          else
          {
            v12 = *((_QWORD *)queue + 8);
            v13 = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), v9);
            (*(void (**)(CMTime *__return_ptr, uint64_t, const void *))(v12 + 16))(&v17, v12, v13);
          }
          if ((v17.flags & 1) != 0)
          {
            if ((retstr->flags & 1) == 0 || (time1 = v17, time2 = *retstr, CMTimeCompare(&time1, &time2) >= 1))
              *retstr = v17;
            if ((*((_BYTE *)queue + 252) & 1) != 0)
            {
              memset(&time1, 0, sizeof(time1));
              time2 = *retstr;
              v14 = v17;
              CMTimeSubtract(&time1, &time2, &v14);
              time2 = time1;
              v14 = *(CMTime *)((_BYTE *)queue + 10);
              if ((CMTimeCompare(&time2, &v14) & 0x80000000) == 0)
                break;
            }
          }
          if ((unint64_t)--v8 < 2)
          {
            if (v7 >= 10)
              bufQReconstructBounds((uint64_t)queue);
            return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
          }
        }
      }
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  if (*((_QWORD *)queue + 8))
    goto LABEL_7;
  return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
}

CMTime *__cdecl CMBufferQueueGetEndPresentationTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  const __CFArray *v5;
  void *v6;
  const __CFArray *v7;
  _QWORD v8[4];
  CFRange v9;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!queue)
    return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (!*((_BYTE *)queue + 120))
  {
    if (!*((_QWORD *)queue + 8) || !*((_QWORD *)queue + 9))
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
LABEL_9:
    v5 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v5 && CFArrayGetCount(v5) >= 1)
    {
      v8[2] = (char *)queue + 48;
      v8[3] = 1;
      if (*((_BYTE *)queue + 120))
        v6 = bufQGetEndPTS;
      else
        v6 = bufQGetEndPTSUsingHandlers;
      v8[0] = retstr;
      v8[1] = v6;
      v7 = (const __CFArray *)*((_QWORD *)queue + 3);
      v9.length = CFArrayGetCount(v7);
      v9.location = 0;
      CFArrayApplyFunction(v7, v9, (CFArrayApplierFunction)findBestTimeStamp, v8);
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  if (*(_QWORD *)((char *)queue + 68) && *(_QWORD *)((char *)queue + 76))
    goto LABEL_9;
  return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
}

CMTime *bufQGetEndPTSUsingHandlers@<X0>(uint64_t a1@<X1>, CMTime *a2@<X8>)
{
  CMTime v5;
  CMTime lhs;

  (*(void (**)(CMTime *__return_ptr))(*(_QWORD *)(a1 + 16) + 16))(&lhs);
  (*(void (**)(CMTime *__return_ptr))(*(_QWORD *)(a1 + 24) + 16))(&v5);
  return CMTimeAdd(a2, &lhs, &v5);
}

CMTime *__cdecl CMBufferQueueGetFirstPresentationTimeStamp(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  const __CFArray *v4;
  void (*v5)(const void *, _QWORD);
  const void *ValueAtIndex;
  uint64_t v7;
  const void *v8;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!queue)
    return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((_BYTE *)queue + 120))
  {
    if (!*(_QWORD *)((char *)queue + 68))
      return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
LABEL_7:
    v4 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v4 && CFArrayGetCount(v4))
    {
      if (*((_BYTE *)queue + 120))
      {
        v5 = *(void (**)(const void *, _QWORD))((char *)queue + 68);
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
        v5(ValueAtIndex, *(_QWORD *)((char *)queue + 52));
      }
      else
      {
        v7 = *((_QWORD *)queue + 8);
        v8 = CFArrayGetValueAtIndex(*((CFArrayRef *)queue + 3), 0);
        (*(void (**)(uint64_t, const void *))(v7 + 16))(v7, v8);
      }
    }
    return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  if (*((_QWORD *)queue + 8))
    goto LABEL_7;
  return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
}

CMItemCount CMBufferQueueGetBufferCount(CMBufferQueueRef queue)
{
  const __CFArray *v2;
  CMItemCount Count;

  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v2 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v2)
      Count = CFArrayGetCount(v2);
    else
      Count = 0;
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return Count;
}

CMTime *__cdecl CMBufferQueueGetDuration(CMTime *__return_ptr retstr, CMBufferQueueRef queue)
{
  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!queue)
    return (CMTime *)FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  *(_OWORD *)&retstr->value = *(_OWORD *)((char *)queue + 124);
  retstr->epoch = *(_QWORD *)((char *)queue + 140);
  return (CMTime *)FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
}

size_t CMBufferQueueGetTotalSize(CMBufferQueueRef queue)
{
  size_t v2;

  if (queue)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v2 = *((_QWORD *)queue + 19);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v2;
}

uint64_t FigBufferQueueInstallTriggerWithTimeAndIntegerThresholds(uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int128 *a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v7;
  __int128 v9;
  uint64_t v10;

  if (!a1 || !a4 || !(a2 | (unint64_t)a7))
  {
    v7 = 4294954535;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if ((*((_DWORD *)a5 + 3) & 0x1D) != 1 || *((_QWORD *)a5 + 2))
  {
    v7 = 4294954531;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (a4 != 12)
  {
    v7 = 4294954529;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  v9 = *a5;
  v10 = *((_QWORD *)a5 + 2);
  return bufQInstallTrigger(a1, a2, a3, 0, 12, (uint64_t)&v9, a6, a7);
}

OSStatus CMBufferQueueInstallTrigger(CMBufferQueueRef queue, CMBufferQueueTriggerCallback callback, void *refcon, CMBufferQueueTriggerCondition condition, CMTime *time, CMBufferQueueTriggerToken *triggerTokenOut)
{
  CMTime v7;

  v7 = *time;
  return figBufferQueueInstallTriggerCallbackOrHandler((char *)queue, (uint64_t)callback, (uint64_t)refcon, 0, condition, (uint64_t)&v7, (uint64_t *)triggerTokenOut);
}

uint64_t figBufferQueueInstallTriggerCallbackOrHandler(char *queue, uint64_t a2, uint64_t a3, const void *a4, unsigned int a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v14;
  CMTime v16;

  if (!queue || !a5 || !a2 && !a4 && !a7)
  {
    v14 = 4294954535;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  if (a5 == 6)
  {
    CMBufferQueueGetMaxPresentationTimeStamp(&v16, (CMBufferQueueRef)queue);
  }
  else
  {
    if (a5 != 5)
    {
      if (a5 - 7 > 2)
      {
        if ((*(_DWORD *)(a6 + 12) & 0x1D) != 1 || *(_QWORD *)(a6 + 16))
        {
          v14 = 4294954531;
          return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        *(_OWORD *)a6 = *(_OWORD *)&kCMTimeInvalid.value;
        *(_QWORD *)(a6 + 16) = 0;
      }
      if (a5 > 9 || ((1 << a5) & 0x39E) == 0)
        goto LABEL_21;
      goto LABEL_19;
    }
    CMBufferQueueGetMinPresentationTimeStamp(&v16, (CMBufferQueueRef)queue);
  }
  *(CMTime *)a6 = v16;
  if (queue[120])
  {
    if (!*(_QWORD *)(queue + 68))
      goto LABEL_21;
  }
  else if (!*((_QWORD *)queue + 8))
  {
LABEL_21:
    v14 = 4294954529;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
LABEL_19:
  v16 = *(CMTime *)a6;
  return bufQInstallTrigger((uint64_t)queue, a2, a3, a4, a5, (uint64_t)&v16, 0, a7);
}

OSStatus CMBufferQueueInstallTriggerWithIntegerThreshold(CMBufferQueueRef queue, CMBufferQueueTriggerCallback callback, void *refcon, CMBufferQueueTriggerCondition condition, CMItemCount threshold, CMBufferQueueTriggerToken *triggerTokenOut)
{
  return figBufferQueueInstallTriggerWithIntegerThresholdCallbackOrHandler((uint64_t)queue, (uint64_t)callback, (uint64_t)refcon, 0, condition, threshold, (uint64_t *)triggerTokenOut);
}

uint64_t figBufferQueueInstallTriggerWithIntegerThresholdCallbackOrHandler(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, int a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v7;

  if (!a1 || !a5 || !a2 && !a4 && !a7)
  {
    v7 = 4294954535;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if ((a5 & 0xFFFFFFFE) != 0xA)
  {
    v7 = 4294954529;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return bufQInstallTrigger(a1, a2, a3, a4, a5, (uint64_t)&kCMTimeInvalid, a6, a7);
}

OSStatus CMBufferQueueInstallTriggerHandler(CMBufferQueueRef queue, CMBufferQueueTriggerCondition condition, CMTime *time, CMBufferQueueTriggerToken *triggerTokenOut, CMBufferQueueTriggerHandler handler)
{
  CMTime v6;

  v6 = *time;
  return figBufferQueueInstallTriggerCallbackOrHandler((char *)queue, 0, 0, handler, condition, (uint64_t)&v6, (uint64_t *)triggerTokenOut);
}

OSStatus CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(CMBufferQueueRef queue, CMBufferQueueTriggerCondition condition, CMItemCount threshold, CMBufferQueueTriggerToken *triggerTokenOut, CMBufferQueueTriggerHandler handler)
{
  return figBufferQueueInstallTriggerWithIntegerThresholdCallbackOrHandler((uint64_t)queue, 0, 0, handler, condition, threshold, (uint64_t *)triggerTokenOut);
}

OSStatus CMBufferQueueRemoveTrigger(CMBufferQueueRef queue, CMBufferQueueTriggerToken triggerToken)
{
  uint64_t v4;
  const __CFSet *v6;
  OSStatus v7;

  if (!queue || !triggerToken)
    return FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
  if (*((_BYTE *)queue + 168))
  {
    v4 = 4294954530;
  }
  else
  {
    v6 = (const __CFSet *)*((_QWORD *)queue + 20);
    if (v6 && CFSetGetValue(v6, triggerToken))
    {
      CFSetRemoveValue(*((CFMutableSetRef *)queue + 20), triggerToken);
      *((_BYTE *)queue + 169) = 0;
      CFSetApplyFunction(*((CFSetRef *)queue + 20), (CFSetApplierFunction)bufQCheckForDataBecomesReadyTrigger, queue);
      v7 = 0;
      if (!*((_BYTE *)queue + 169))
      {
        bufQStopListeningForHeadBufferBecomingReady((uint64_t)queue);
        v7 = 0;
      }
      goto LABEL_12;
    }
    v4 = 4294954528;
  }
  v7 = FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
LABEL_12:
  FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  return v7;
}

Boolean CMBufferQueueTestTrigger(CMBufferQueueRef queue, CMBufferQueueTriggerToken triggerToken)
{
  const __CFSet *v4;
  Boolean v5;

  if (queue && triggerToken)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v4 = (const __CFSet *)*((_QWORD *)queue + 20);
    if (v4 && CFSetGetValue(v4, triggerToken))
    {
      v5 = *((_BYTE *)triggerToken + 64);
    }
    else
    {
      FigSignalErrorAt(4294954528, 0, 0, 0, 0, 0, 0);
      v5 = 0;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v5;
}

OSStatus CMBufferQueueCallForEachBuffer(CMBufferQueueRef queue, OSStatus (__cdecl *callback)(CMBufferRef, void *), void *refcon)
{
  const __CFArray *v6;
  const __CFArray *v7;
  _QWORD v9[3];
  OSStatus v10;
  CFRange v11;

  v10 = 0;
  if (queue && callback)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)queue + 2));
    v6 = (const __CFArray *)*((_QWORD *)queue + 3);
    if (v6)
    {
      if (CFArrayGetCount(v6) >= 1)
      {
        v9[0] = &v10;
        v9[1] = callback;
        v9[2] = refcon;
        v7 = (const __CFArray *)*((_QWORD *)queue + 3);
        v11.length = CFArrayGetCount(v7);
        v11.location = 0;
        CFArrayApplyFunction(v7, v11, (CFArrayApplierFunction)bufqCallForOneBuffer, v9);
      }
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)queue + 2));
    return v10;
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t bufqCallForOneBuffer(uint64_t result, uint64_t a2)
{
  if (!**(_DWORD **)a2)
  {
    result = (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 8))(result, *(_QWORD *)(a2 + 16));
    **(_DWORD **)a2 = result;
  }
  return result;
}

uint64_t FigBufferQueueCallForEachBufferLastToFirst(uint64_t a1, uint64_t (*a2)(const void *, uint64_t), uint64_t a3)
{
  const __CFArray *v6;
  CFIndex Count;
  uint64_t v8;
  const void *ValueAtIndex;
  uint64_t v11;

  if (a1 && a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v6 = *(const __CFArray **)(a1 + 24);
    if (v6)
      Count = CFArrayGetCount(v6);
    else
      Count = 0;
    while (Count-- >= 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), Count);
      v11 = a2(ValueAtIndex, a3);
      if ((_DWORD)v11)
      {
        v8 = v11;
        goto LABEL_11;
      }
    }
    v8 = 0;
LABEL_11:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  }
  else
  {
    FigSignalErrorAt(4294954535, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v8;
}

__CFString *bufQCopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  uint64_t v3;
  const char *v4;
  CFIndex v5;
  CFAllocatorRef v6;
  const __CFAllocator *v7;
  CFStringRef v8;
  const __CFAllocator *v9;
  CFStringRef v10;
  const __CFAllocator *v11;
  CFStringRef v12;
  const __CFArray *Count;
  const char *v14;
  const char *v15;
  const __CFSet *v16;
  CFIndex v17;
  const __CFArray *v18;
  const __CFArray *v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CMTime v25;
  CMTime time;
  CFRange v27;

  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<"));
  v3 = 92;
  if (!*(_BYTE *)(a1 + 120))
    v3 = 88;
  if (*(_QWORD *)(a1 + v3))
    v4 = "sorted";
  else
    v4 = "unsorted";
  v5 = CFGetRetainCount((CFTypeRef)a1);
  v6 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("CMBufferQueue(%s) %p retainCount: %ld allocator: %p\n"), v4, a1, v5, v6);
  if (*(_BYTE *)(a1 + 120))
  {
    unk_1EE13F874 = sbufGetDecodeTimeStamp;
    unk_1EE13F87C = sbufGetPresentationTimeStamp;
    unk_1EE13F884 = sbufGetDuration;
    unk_1EE13F88C = sbufDataIsReady;
    unk_1EE13F89C = CFSTR("FigSampleBufferDataBecameReady");
    unk_1EE13F8A4 = sbufGetTotalSampleSize;
    if (!memcmp((const void *)(a1 + 48), &gFigBufferQueueCallbacksForUnsortedSampleBuffers, 0x44uLL))
      CFStringAppendFormat(Mutable, 0, CFSTR("\tcallbacks: kCMBufferQueueCallbacksForUnsortedSampleBuffers\n"), v21, v22, v23, v24);
    else
      CFStringAppendFormat(Mutable, 0, CFSTR("\tcallbacks:\n\t\tversion = %d\n\t\trefcon = %p\n\t\tgetDTS = %p\n\t\tgetPTS = %p\n\t\tgetDuration = %p\n\t\tisDataReady = %p\n\t\tcompare = %p\n"), *(unsigned int *)(a1 + 48), *(_QWORD *)(a1 + 52), *(_QWORD *)(a1 + 60), *(_QWORD *)(a1 + 68), *(_QWORD *)(a1 + 76), *(_QWORD *)(a1 + 84), *(_QWORD *)(a1 + 92));
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\thandlers:\n\t\tversion = %d\n\t\tgetDTS = %p\n\t\tgetPTS = %p\n\t\tgetDuration = %p\n\t\tisDataReady = %p\n\t\tcompare = %p\n"), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88));
  }
  v7 = CFGetAllocator((CFTypeRef)a1);
  time = *(CMTime *)(a1 + 124);
  v8 = CMTimeCopyDescription(v7, &time);
  v9 = CFGetAllocator((CFTypeRef)a1);
  CMBufferQueueGetMinPresentationTimeStamp(&time, (CMBufferQueueRef)a1);
  v10 = CMTimeCopyDescription(v9, &time);
  v11 = CFGetAllocator((CFTypeRef)a1);
  CMBufferQueueGetMinDecodeTimeStamp(&v25, (CMBufferQueueRef)a1);
  v12 = CMTimeCopyDescription(v11, &v25);
  Count = *(const __CFArray **)(a1 + 24);
  if (Count)
    Count = (const __CFArray *)CFArrayGetCount(Count);
  v14 = "YES";
  if (*(_BYTE *)(a1 + 168))
    v15 = "YES";
  else
    v15 = "NO";
  if (!*(_BYTE *)(a1 + 121))
    v14 = "NO";
  CFStringAppendFormat(Mutable, 0, CFSTR("\telement count: %ld\n\tfiringTrigger: %s\n\tcontainsEOD: %s\n\ttotalDuration: %@\n\tminPTS: %@\n\tminDTS: %@\n"), Count, v15, v14, v8, v10, v12);
  if (v8)
    CFRelease(v8);
  if (v10)
    CFRelease(v10);
  if (v12)
    CFRelease(v12);
  v16 = *(const __CFSet **)(a1 + 160);
  if (v16 && CFSetGetCount(v16))
  {
    v17 = CFSetGetCount(*(CFSetRef *)(a1 + 160));
    CFStringAppendFormat(Mutable, 0, CFSTR("\tTriggers (%ld):"), v17);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 160), (CFSetApplierFunction)appendTriggerDescription, Mutable);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\tNO triggers\n"));
  }
  v18 = *(const __CFArray **)(a1 + 24);
  if (v18 && CFArrayGetCount(v18))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\tElements:"));
    v19 = *(const __CFArray **)(a1 + 24);
    v27.length = CFArrayGetCount(v19);
    v27.location = 0;
    CFArrayApplyFunction(v19, v27, (CFArrayApplierFunction)appendBufQElementDescription, Mutable);
    CFStringAppendFormat(Mutable, 0, CFSTR(">\n"));
  }
  return Mutable;
}

void appendBufQElementDescription(uint64_t a1, CFMutableStringRef theString)
{
  CFStringAppendFormat(theString, 0, CFSTR("\n\telement = %p"), a1);
}

void appendTriggerDescription(uint64_t a1, __CFString *cf)
{
  const __CFAllocator *v4;
  CFStringRef v5;
  int v6;
  const char *v7;
  CMTime time;
  char v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v4 = CFGetAllocator(cf);
  time = *(CMTime *)(a1 + 28);
  v5 = CMTimeCopyDescription(v4, &time);
  v6 = *(_DWORD *)(a1 + 24);
  if ((v6 - 1) > 0xB)
  {
    v9 = 0;
    snprintf((char *)&time, 0xFFuLL, "%d", v6);
  }
  else
  {
    strncpy((char *)&time, off_1E28D7D80[v6 - 1], 0xFFuLL);
    v9 = 0;
  }
  if (*(_BYTE *)(a1 + 64))
    v7 = "true";
  else
    v7 = "false";
  CFStringAppendFormat(cf, 0, CFSTR("\n\t\tcondition: %s\n\t\tduration: %@\n\t\tcurrentValue: %s\n\t\tcallback: %p\n\t\trefCon: %p\n"), &time, v5, v7, *(_QWORD *)a1, *(_QWORD *)(a1 + 8));
  CFStringAppendFormat(cf, 0, CFSTR("\t\thandler: %p\n"), *(_QWORD *)(a1 + 16));
  if (v5)
    CFRelease(v5);
}

const __CFString *FigTapToRadarComponentNameFromComponentIdentifier(int a1)
{
  if (a1 > 1019129)
  {
    if (a1 > 1507077)
    {
      if (a1 == 1507078)
        return CFSTR("CoreMedia (New Bugs)");
      if (a1 == 1507080)
        return CFSTR("CoreMedia Formats");
    }
    else
    {
      if (a1 == 1019130)
        return CFSTR("MediaExperience (New Bugs)");
      if (a1 == 1326216)
        return CFSTR("CoreMedia Streaming (New Bugs)");
    }
    return 0;
  }
  if (a1 == 629193)
    return CFSTR("AirPlay (New Bugs)");
  if (a1 != 629219)
  {
    if (a1 == 629221)
      return CFSTR("CoreMedia Video Toolbox");
    return 0;
  }
  return CFSTR("CoreMedia Playback");
}

const __CFString *FigTapToRadarComponentVersionFromComponentIdentifier(int a1)
{
  const __CFString *result;
  int v3;
  unsigned int v4;

  result = CFSTR("All");
  if (a1 <= 1019129)
  {
    v4 = a1 - 629193;
    if (v4 > 0x1C || ((1 << v4) & 0x14000001) == 0)
      return 0;
  }
  else
  {
    if (a1 > 1507077)
    {
      if (a1 == 1507078)
        return result;
      v3 = 1507080;
    }
    else
    {
      if (a1 == 1019130)
        return result;
      v3 = 1326216;
    }
    if (a1 != v3)
      return 0;
  }
  return result;
}

uint64_t FigIsAllowedToTriggerTapToRadar()
{
  if (FigServer_IsMediaplaybackd()
    || FigServer_IsMediaparserd()
    || FigServer_IsAirplayd()
    || FigServer_IsVideocodecd()
    || FigServer_IsMediaserverd())
  {
    return 1;
  }
  else
  {
    return in_audio_mx_server_process();
  }
}

CFStringRef FigTapToRadarCreateRadarDescriptionString(const __CFAllocator *a1, CFStringRef format, ...)
{
  CFStringRef v3;
  CFArrayRef v4;
  CFStringRef v5;
  va_list va;

  va_start(va, format);
  v3 = CFStringCreateWithFormatAndArguments(a1, 0, format, va);
  v4 = FigCopyProcessNamesForGatheringDiagnosticsWithCoreMediaDiagnosticExtension();
  v5 = CFStringCreateWithFormat(a1, 0, CFSTR("[If you did anything related to media playback recently, please add details here]\n%@\n\nDiagnostics collected beyond a typical radar.\n -memory, thread and sandbox state of media-related daemons [%@]"), v3, -[__CFArray componentsJoinedByString:](v4, "componentsJoinedByString:", CFSTR(", ")));
  if (v5)
  {
    if (!v3)
      goto LABEL_4;
    goto LABEL_3;
  }
  FigSignalErrorAt(4294947922, 0, 0, 0, 0, 0, 0);
  if (v3)
LABEL_3:
    CFRelease(v3);
LABEL_4:
  if (v4)
    CFRelease(v4);
  return v5;
}

uint64_t FigCanTriggerTapToRadar()
{
  uint64_t result;

  result = FigDebugIsInternalBuild();
  if ((_DWORD)result)
  {
    result = FigIsAllowedToTriggerTapToRadar();
    if ((_DWORD)result)
      return (Class)getTapToRadarServiceClass[0]() != 0;
  }
  return result;
}

uint64_t FigTriggerTapToRadar(uint64_t a1, const __CFString *a2, uint64_t a3, unsigned int a4)
{
  const __CFString *v8;
  const __CFString *v9;
  void *v10;
  id v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;

  v15 = 0;
  v8 = FigTapToRadarComponentNameFromComponentIdentifier(a4);
  v9 = FigTapToRadarComponentVersionFromComponentIdentifier(a4);
  if (!FigDebugIsInternalBuild())
    return 4294947925;
  if (!FigIsAllowedToTriggerTapToRadar())
    return 4294947926;
  if (v8 && v9)
  {
    if (a2 && a3 && CFStringGetLength(a2) < 206)
    {
      v10 = (void *)MEMORY[0x193FFC34C]();
      v11 = objc_alloc_init((Class)getRadarDraftClass[0]());
      objc_msgSend(v11, "setTitle:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("[Automatic CoreMedia Diagnostics] %@"), a2, v15));
      objc_msgSend(v11, "setProblemDescription:", a3);
      objc_msgSend(v11, "setComponent:", objc_msgSend(objc_alloc(getRadarComponentClass()), "initWithName:version:identifier:", v8, v9, a4));
      objc_msgSend(v11, "setClassification:", 0);
      objc_msgSend(v11, "setReproducibility:", 0);
      objc_msgSend(v11, "setIsUserInitiated:", 0);
      objc_msgSend(v11, "setDiagnosticExtensionIDs:", objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithObjects:", CFSTR("com.apple.coremedia.CoreMediaDiagnostics.CoreMediaDiagnosticExtension"), 0));
      objc_msgSend((id)objc_msgSend((Class)getTapToRadarServiceClass[0](), "shared"), "createDraft:forProcessNamed:withDisplayReason:error:", v11, CFSTR("CoreMedia"), a1, &v15);
      v12 = 0;
      if (NSErrorToOSStatus())
        v12 = NSErrorToOSStatus();
      objc_autoreleasePoolPop(v10);
      return v12;
    }
    v14 = 4294947923;
  }
  else
  {
    v14 = 4294947924;
  }
  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

Class initTapToRadarService()
{
  Class result;

  if (TapToRadarKitLibrary_sOnce != -1)
    dispatch_once(&TapToRadarKitLibrary_sOnce, &__block_literal_global_2);
  result = objc_getClass("TapToRadarService");
  classTapToRadarService = (uint64_t)result;
  getTapToRadarServiceClass[0] = TapToRadarServiceFunction;
  return result;
}

uint64_t TapToRadarServiceFunction()
{
  return classTapToRadarService;
}

Class initRadarDraft()
{
  Class result;

  if (TapToRadarKitLibrary_sOnce != -1)
    dispatch_once(&TapToRadarKitLibrary_sOnce, &__block_literal_global_2);
  result = objc_getClass("RadarDraft");
  classRadarDraft = (uint64_t)result;
  getRadarDraftClass[0] = RadarDraftFunction;
  return result;
}

uint64_t RadarDraftFunction()
{
  return classRadarDraft;
}

Class initRadarComponent()
{
  Class result;

  if (TapToRadarKitLibrary_sOnce != -1)
    dispatch_once(&TapToRadarKitLibrary_sOnce, &__block_literal_global_2);
  result = objc_getClass("RadarComponent");
  classRadarComponent = (uint64_t)result;
  getRadarComponentClass = RadarComponentFunction;
  return result;
}

uint64_t RadarComponentFunction()
{
  return classRadarComponent;
}

OSStatus CMTextFormatDescriptionGetDisplayFlags(CMFormatDescriptionRef desc, CMTextDisplayFlags *displayFlagsOut)
{
  CMMediaType MediaType;
  const __CFNumber *Extension;
  const __CFNumber *v7;
  CFTypeID v8;

  if (desc)
  {
    MediaType = CMFormatDescriptionGetMediaType(desc);
    if (MediaType == 1668310898 || MediaType == 1935832172 || MediaType == 1952807028)
    {
      if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
        || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
        || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
        || CMFormatDescriptionGetMediaType(desc) == 1668310898
        || CMFormatDescriptionGetMediaType(desc) == 1952807028 && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
      {
        return -12718;
      }
      if (!displayFlagsOut)
        return 0;
      Extension = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, CFSTR("DisplayFlags"));
      if (Extension)
      {
        v7 = Extension;
        v8 = CFGetTypeID(Extension);
        if (v8 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v7, kCFNumberSInt32Type, displayFlagsOut);
          return 0;
        }
      }
    }
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTextFormatDescriptionGetJustification(CMFormatDescriptionRef desc, CMTextJustificationValue *horizontaJustificationlOut, CMTextJustificationValue *verticalJustificationOut)
{
  CMMediaType MediaType;
  OSStatus result;
  const __CFNumber *Extension;
  const __CFNumber *v9;
  CFTypeID v10;
  const __CFNumber *v11;
  const __CFNumber *v12;
  CFTypeID v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  CFTypeID v16;
  int valuePtr;

  if (!desc)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  MediaType = CMFormatDescriptionGetMediaType(desc);
  if (MediaType != 1668310898 && MediaType != 1935832172 && MediaType != 1952807028)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
    || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
    || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
    || CMFormatDescriptionGetMediaType(desc) == 1668310898
    || CMFormatDescriptionGetMediaType(desc) == 1952807028 && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
  {
    return -12718;
  }
  if (horizontaJustificationlOut)
  {
    if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
    {
      valuePtr = 0;
      Extension = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, CFSTR("TextJustification"));
      if (Extension)
      {
        v9 = Extension;
        v10 = CFGetTypeID(Extension);
        if (v10 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
          *horizontaJustificationlOut = valuePtr;
          goto LABEL_20;
        }
      }
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
    v11 = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, CFSTR("HorizontalJustification"));
    if (!v11)
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    v12 = v11;
    v13 = CFGetTypeID(v11);
    if (v13 != CFNumberGetTypeID())
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    CFNumberGetValue(v12, kCFNumberSInt8Type, horizontaJustificationlOut);
  }
LABEL_20:
  if (!verticalJustificationOut)
    return 0;
  if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
  {
    result = 0;
    *verticalJustificationOut = 0;
    return result;
  }
  v14 = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, CFSTR("VerticalJustification"));
  if (v14)
  {
    v15 = v14;
    v16 = CFGetTypeID(v14);
    if (v16 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v15, kCFNumberSInt8Type, verticalJustificationOut);
      return 0;
    }
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTextFormatDescriptionGetDefaultTextBox(CMFormatDescriptionRef desc, Boolean originIsAtTopLeft, CGFloat heightOfTextTrack, CGRect *defaultTextBoxOut)
{
  int v6;
  CMMediaType MediaType;
  OSStatus result;
  const __CFDictionary *Extension;
  const __CFDictionary *v11;
  CFTypeID v12;
  const __CFNumber *Value;
  const __CFNumber *v14;
  CFTypeID v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  CFTypeID v18;
  const __CFNumber *v19;
  const __CFNumber *v20;
  CFTypeID v21;
  const __CFNumber *v22;
  const __CFNumber *v23;
  CFTypeID v24;
  int v25;
  int v26;
  CGFloat v27;
  double v28;
  int v29;
  int valuePtr;

  if (!desc)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v6 = originIsAtTopLeft;
  MediaType = CMFormatDescriptionGetMediaType(desc);
  if (MediaType != 1668310898 && MediaType != 1935832172 && MediaType != 1952807028)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
    || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
    || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
    || CMFormatDescriptionGetMediaType(desc) == 1668310898
    || CMFormatDescriptionGetMediaType(desc) == 1952807028 && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
  {
    return -12718;
  }
  if (!defaultTextBoxOut)
    return 0;
  Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(desc, CFSTR("DefaultTextBox"));
  if (!Extension)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v11 = Extension;
  v12 = CFGetTypeID(Extension);
  if (v12 != CFDictionaryGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  Value = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("Top"));
  if (!Value)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v14 = Value;
  v15 = CFGetTypeID(Value);
  if (v15 != CFNumberGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v29 = 0;
  valuePtr = 0;
  CFNumberGetValue(v14, kCFNumberSInt16Type, (char *)&valuePtr + 2);
  v16 = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("Left"));
  if (!v16)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v17 = v16;
  v18 = CFGetTypeID(v16);
  if (v18 != CFNumberGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  CFNumberGetValue(v17, kCFNumberSInt16Type, &valuePtr);
  v19 = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("Bottom"));
  if (!v19)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v20 = v19;
  v21 = CFGetTypeID(v19);
  if (v21 != CFNumberGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  CFNumberGetValue(v20, kCFNumberSInt16Type, (char *)&v29 + 2);
  v22 = (const __CFNumber *)CFDictionaryGetValue(v11, CFSTR("Right"));
  if (!v22)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v23 = v22;
  v24 = CFGetTypeID(v22);
  if (v24 != CFNumberGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  CFNumberGetValue(v23, kCFNumberSInt16Type, &v29);
  v25 = (__int16)valuePtr;
  v26 = SHIWORD(valuePtr);
  v27 = (double)(SHIWORD(v29) - SHIWORD(valuePtr));
  defaultTextBoxOut->size.width = (double)((__int16)v29 - (__int16)valuePtr);
  defaultTextBoxOut->size.height = v27;
  defaultTextBoxOut->origin.x = (double)v25;
  v28 = (double)v26;
  result = 0;
  if (!v6)
    v28 = heightOfTextTrack - v28;
  defaultTextBoxOut->origin.y = v28;
  return result;
}

OSStatus CMTextFormatDescriptionGetDefaultStyle(CMFormatDescriptionRef desc, uint16_t *localFontIDOut, Boolean *boldOut, Boolean *italicOut, Boolean *underlineOut, CGFloat *fontSizeOut, CGFloat *colorComponentsOut)
{
  CMMediaType MediaType;
  OSStatus result;
  const __CFDictionary *Extension;
  const __CFDictionary *v17;
  CFTypeID v18;
  const __CFNumber *Value;
  const __CFNumber *v20;
  CFTypeID v21;
  const __CFNumber *v22;
  const __CFNumber *v23;
  CFTypeID v24;
  const __CFNumber *v25;
  const __CFNumber *v26;
  CFTypeID v27;
  int v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  CFTypeID v31;
  const __CFNumber *v32;
  const __CFNumber *v33;
  CFTypeID v34;
  unint64_t v35;
  const __CFNumber *v36;
  const __CFNumber *v37;
  CFTypeID v38;
  unint64_t v39;
  const __CFNumber *v40;
  const __CFNumber *v41;
  CFTypeID v42;
  unint64_t v43;
  const __CFNumber *v44;
  const __CFNumber *v45;
  CFTypeID v46;
  unint64_t v47;
  const __CFNumber *v48;
  const __CFNumber *v49;
  CFTypeID v50;
  unint64_t v51;
  const __CFNumber *v52;
  const __CFNumber *v53;
  CFTypeID v54;
  unint64_t v55;
  const __CFNumber *v56;
  const __CFNumber *v57;
  CFTypeID v58;
  unint64_t v59;
  char v60;
  __int16 v61;
  char v62;
  __int16 v63;
  char valuePtr;

  if (!desc)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  MediaType = CMFormatDescriptionGetMediaType(desc);
  if (MediaType != 1668310898 && MediaType != 1935832172 && MediaType != 1952807028)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
    || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
    || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
    || CMFormatDescriptionGetMediaType(desc) == 1668310898
    || CMFormatDescriptionGetMediaType(desc) == 1952807028 && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
  {
    return -12718;
  }
  Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(desc, CFSTR("DefaultStyle"));
  if (!Extension)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v17 = Extension;
  v18 = CFGetTypeID(Extension);
  if (v18 != CFDictionaryGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  if (localFontIDOut)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(v17, CFSTR("Font"));
    if (!Value)
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    v20 = Value;
    v21 = CFGetTypeID(Value);
    if (v21 != CFNumberGetTypeID())
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    CFNumberGetValue(v20, kCFNumberSInt16Type, localFontIDOut);
  }
  if (!boldOut && !italicOut && !underlineOut)
    goto LABEL_29;
  valuePtr = 0;
  v22 = (const __CFNumber *)CFDictionaryGetValue(v17, CFSTR("FontFace"));
  if (!v22)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v23 = v22;
  v24 = CFGetTypeID(v22);
  if (v24 != CFNumberGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  CFNumberGetValue(v23, kCFNumberSInt8Type, &valuePtr);
  if (boldOut)
    *boldOut = valuePtr & 1;
  if (italicOut)
    *italicOut = (valuePtr & 2) != 0;
  if (underlineOut)
    *underlineOut = (valuePtr & 4) != 0;
LABEL_29:
  if (fontSizeOut)
  {
    v25 = (const __CFNumber *)CFDictionaryGetValue(v17, CFSTR("FontSize"));
    if (!v25)
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    v26 = v25;
    v27 = CFGetTypeID(v25);
    if (v27 != CFNumberGetTypeID())
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
    {
      v63 = 0;
      CFNumberGetValue(v26, kCFNumberSInt16Type, &v63);
      v28 = v63;
    }
    else
    {
      v62 = 0;
      CFNumberGetValue(v26, kCFNumberSInt8Type, &v62);
      v28 = v62;
    }
    *fontSizeOut = (double)v28;
  }
  if (!colorComponentsOut)
    return 0;
  v29 = (const __CFDictionary *)CFDictionaryGetValue(v17, CFSTR("ForegroundColor"));
  if (v29)
  {
    v30 = v29;
    v31 = CFGetTypeID(v29);
    if (v31 == CFDictionaryGetTypeID())
    {
      if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
      {
        v61 = 0;
        v32 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("Red"));
        if (v32)
        {
          v33 = v32;
          v34 = CFGetTypeID(v32);
          if (v34 == CFNumberGetTypeID())
          {
            CFNumberGetValue(v33, kCFNumberSInt16Type, &v61);
            LOWORD(v35) = v61;
            *colorComponentsOut = (double)v35 / 65535.0;
            v36 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("Green"));
            if (v36)
            {
              v37 = v36;
              v38 = CFGetTypeID(v36);
              if (v38 == CFNumberGetTypeID())
              {
                CFNumberGetValue(v37, kCFNumberSInt16Type, &v61);
                LOWORD(v39) = v61;
                colorComponentsOut[1] = (double)v39 / 65535.0;
                v40 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("Blue"));
                if (v40)
                {
                  v41 = v40;
                  v42 = CFGetTypeID(v40);
                  if (v42 == CFNumberGetTypeID())
                  {
                    CFNumberGetValue(v41, kCFNumberSInt16Type, &v61);
                    result = 0;
                    LOWORD(v43) = v61;
                    colorComponentsOut[2] = (double)v43 / 65535.0;
                    colorComponentsOut[3] = 1.0;
                    return result;
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        v60 = 0;
        v44 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("Red"));
        if (v44)
        {
          v45 = v44;
          v46 = CFGetTypeID(v44);
          if (v46 == CFNumberGetTypeID())
          {
            CFNumberGetValue(v45, kCFNumberSInt8Type, &v60);
            LOBYTE(v47) = v60;
            *colorComponentsOut = (double)v47 / 255.0;
            v48 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("Green"));
            if (v48)
            {
              v49 = v48;
              v50 = CFGetTypeID(v48);
              if (v50 == CFNumberGetTypeID())
              {
                CFNumberGetValue(v49, kCFNumberSInt8Type, &v60);
                LOBYTE(v51) = v60;
                colorComponentsOut[1] = (double)v51 / 255.0;
                v52 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("Blue"));
                if (v52)
                {
                  v53 = v52;
                  v54 = CFGetTypeID(v52);
                  if (v54 == CFNumberGetTypeID())
                  {
                    CFNumberGetValue(v53, kCFNumberSInt8Type, &v60);
                    LOBYTE(v55) = v60;
                    colorComponentsOut[2] = (double)v55 / 255.0;
                    v56 = (const __CFNumber *)CFDictionaryGetValue(v30, CFSTR("Alpha"));
                    if (v56)
                    {
                      v57 = v56;
                      v58 = CFGetTypeID(v56);
                      if (v58 == CFNumberGetTypeID())
                      {
                        CFNumberGetValue(v57, kCFNumberSInt8Type, &v60);
                        result = 0;
                        LOBYTE(v59) = v60;
                        colorComponentsOut[3] = (double)v59 / 255.0;
                        return result;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTextFormatDescriptionGetFontName(CMFormatDescriptionRef desc, uint16_t localFontID, CFStringRef *fontNameOut)
{
  unsigned int v4;
  CMMediaType MediaType;
  OSStatus v7;
  const __CFString *Extension;
  const __CFString *v10;
  CFTypeID v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  CFTypeID v14;
  CFStringRef v15;
  CFStringRef v16;
  const __CFString *Value;
  const __CFString *v18;
  CFTypeID v19;

  if (desc)
  {
    if (fontNameOut)
    {
      v4 = localFontID;
      MediaType = CMFormatDescriptionGetMediaType(desc);
      if (MediaType == 1668310898 || MediaType == 1935832172 || MediaType == 1952807028)
      {
        if (CMFormatDescriptionGetMediaSubType(desc) == 2004251764
          || CMFormatDescriptionGetMediaSubType(desc) == 2021028980
          || CMFormatDescriptionGetMediaSubType(desc) == 1937142900
          || CMFormatDescriptionGetMediaType(desc) == 1668310898
          || CMFormatDescriptionGetMediaType(desc) == 1952807028
          && CMFormatDescriptionGetMediaSubType(desc) == 1634301044)
        {
          return -12718;
        }
        *fontNameOut = 0;
        if (CMFormatDescriptionGetMediaSubType(desc) == 1952807028)
        {
          Extension = (const __CFString *)CMFormatDescriptionGetExtension(desc, CFSTR("DefaultFontName"));
          if (Extension)
          {
            v10 = Extension;
            v11 = CFGetTypeID(Extension);
            if (v11 == CFStringGetTypeID())
            {
              v7 = 0;
              *fontNameOut = v10;
              return v7;
            }
          }
        }
        else
        {
          v12 = (const __CFDictionary *)CMFormatDescriptionGetExtension(desc, CFSTR("FontTable"));
          if (v12)
          {
            v13 = v12;
            v14 = CFGetTypeID(v12);
            if (v14 == CFDictionaryGetTypeID())
            {
              v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d"), v4);
              if (v15)
              {
                v16 = v15;
                Value = (const __CFString *)CFDictionaryGetValue(v13, v15);
                if (Value && (v18 = Value, v19 = CFGetTypeID(Value), v19 == CFStringGetTypeID()))
                {
                  v7 = 0;
                  *fontNameOut = v18;
                }
                else
                {
                  v7 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
                }
                CFRelease(v16);
                return v7;
              }
            }
          }
        }
      }
    }
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

void sub_18ECA83EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18ECA86F8(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

uint64_t FigPurgeAndRenewProcessStateTrackerGetPurgeEligibilityForPID(uint64_t a1, char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;

  v3 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a1);
  if (a2)
  {
    v4 = v3;
    if (_os_feature_enabled_impl())
    {
      v5 = objc_msgSend((id)sProcessStateTrackingContexts, "objectForKey:", v4);
      if (v5)
      {
        v6 = objc_msgSend(*(id *)(v5 + 8), "purgeSuspended");
        v7 = 0;
LABEL_5:
        *a2 = v6;
        return v7;
      }
      v7 = FigSignalErrorAt(4294947824, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      v7 = 0;
    }
    v6 = 1;
    goto LABEL_5;
  }
  return FigSignalErrorAt(4294947826, 0, 0, 0, 0, 0, 0);
}

uint64_t FigPurgeAndRenewProcessStateTrackerModifyPurgeEligibilityForPID(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v3 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a1);
  if (!_os_feature_enabled_impl())
    return 0;
  v4 = objc_msgSend((id)sProcessStateTrackingContexts, "objectForKey:", v3);
  if (v4)
  {
    if ((objc_msgSend(*(id *)(v4 + 8), "setPurgeSuspended:", a2) & 1) != 0)
      return 0;
    v6 = 4294947823;
  }
  else
  {
    v6 = 4294947824;
  }
  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

void FigPurgeAndRenewProcessStateTrackerStartTrackingPIDWithBlock(int a1, uint64_t a2)
{
  void *v4;
  unsigned int v5;
  _QWORD block[6];
  int v7;
  _QWORD v8[3];
  int v9;

  v4 = (void *)MEMORY[0x193FFC34C]();
  v5 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigPurgeAndRenewProcessStateTracker[1], CFSTR("processtatetracker_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v5, 0, gFigPurgeAndRenewProcessStateTracker);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EE141E08, CFSTR("processtatetracker_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EE141E00);
  if (_os_feature_enabled_impl()
    && FigGetCFPreferenceNumberWithDefault(CFSTR("purge_timeout_seconds"), CFSTR("com.apple.coremedia"), 600))
  {
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2020000000;
    v9 = 0;
    if (ensureProcessStateTrackerDispatchQExists_sProcessStateTrackerDispatchQueueInitializer != -1)
      dispatch_once(&ensureProcessStateTrackerDispatchQExists_sProcessStateTrackerDispatchQueueInitializer, &__block_literal_global_3);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __startProcessStateTracking_block_invoke;
    block[3] = &unk_1E28D7F38;
    v7 = a1;
    block[4] = a2;
    block[5] = v8;
    dispatch_sync((dispatch_queue_t)sProcessStateTrackerDispatchQueue, block);
    _Block_object_dispose(v8, 8);
  }
  objc_autoreleasePoolPop(v4);
}

void FigPurgeAndRenewProcessStateTrackerStartTrackingPID(int a1)
{
  FigPurgeAndRenewProcessStateTrackerStartTrackingPIDWithBlock(a1, (uint64_t)&__block_literal_global_88);
}

uint64_t FigPurgeAndRenewProcessStateTrackerGetTrackedState(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (void *)MEMORY[0x193FFC34C]();
  v3 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a1);
  v4 = objc_msgSend((id)sProcessStateTrackingContexts, "objectForKey:", v3);
  if (v4)
  {
    if (objc_msgSend(*(id *)(v4 + 8), "isProcessStateSuspended"))
      v5 = 2;
    else
      v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  objc_autoreleasePoolPop(v2);
  return v5;
}

uint64_t __startProcessStateTracking_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  id v6;
  id v7;
  void *v8;
  ProcessStateTrackingContext *v9;
  ProcessStateTrackingContext *v10;
  void *v11;
  uint64_t result;
  _QWORD v13[5];

  v2 = *(unsigned int *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 32);
  v4 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v2);
  if (objc_msgSend((id)sProcessStateTrackingContexts, "objectForKey:", v4))
    objc_msgSend((id)sProcessStateTrackingContexts, "removeObjectForKey:", v4);
  v5 = +[FigPurgeAndRenewPurgeOperator operatorForClientPID:notificationQueue:withPurgeBlock:](FigPurgeAndRenewPurgeOperator, "operatorForClientPID:notificationQueue:withPurgeBlock:", v2, sProcessStateTrackerDispatchQueue, v3);
  if (!v5)
    goto LABEL_9;
  v6 = v5;
  v7 = -[ProcessStateTracker initForClientPID:withOperator:]([ProcessStateTracker alloc], "initForClientPID:withOperator:", v2, v5);
  if (!v7)
    goto LABEL_9;
  v8 = v7;
  v9 = objc_alloc_init(ProcessStateTrackingContext);
  if (!v9)
    goto LABEL_9;
  v10 = v9;
  v11 = (void *)objc_msgSend(MEMORY[0x1E0CB37D0], "defaultCenter");
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __startProcessTrackerOnQueue_block_invoke;
  v13[3] = &unk_1E28D7F80;
  v13[4] = v4;
  v10->token = objc_msgSend(v11, "addObserverForName:object:queue:usingBlock:", CFSTR("FigProcessStateTrackerClientProcessIsTerminated"), v6, 0, v13);
  if (!objc_msgSend(v8, "isProcessTerminated"))
  {
    v10->tracker = (ProcessStateTracker *)v8;
    objc_msgSend((id)sProcessStateTrackingContexts, "setObject:forKey:", v10, v4);
    result = 0;
  }
  else
  {
LABEL_9:
    result = FigSignalErrorAt(4294947825, 0, 0, 0, 0, 0, 0);
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t __ensureProcessStateTrackerDispatchQExists_block_invoke()
{
  NSObject *v0;
  uint64_t result;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  sProcessStateTrackerDispatchQueue = (uint64_t)dispatch_queue_create("com.apple.coremedia.pnrq", v0);
  result = objc_opt_new();
  sProcessStateTrackingContexts = result;
  return result;
}

void __startProcessTrackerOnQueue_block_invoke(uint64_t a1)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __startProcessTrackerOnQueue_block_invoke_2;
  block[3] = &unk_1E28D7E98;
  block[4] = *(_QWORD *)(a1 + 32);
  dispatch_async((dispatch_queue_t)sProcessStateTrackerDispatchQueue, block);
}

void __startProcessTrackerOnQueue_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  id v2;
  id v3;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = (id)objc_msgSend((id)sProcessStateTrackingContexts, "objectForKey:", v1);
  if (v2)
  {
    v3 = v2;
    objc_msgSend((id)sProcessStateTrackingContexts, "removeObjectForKey:", v1);

  }
}

uint64_t defaultBlock_block_invoke(uint64_t a1, int a2)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  int v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (dword_1EE141E08)
  {
    v10[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E00, 1, v10, &type);
    v4 = v10[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v6 = v4;
    else
      v6 = v4 & 0xFFFFFFFE;
    if (v6)
    {
      v10[1] = 136315394;
      v11 = "defaultBlock_block_invoke";
      v12 = 1024;
      v13 = a2;
      v7 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v4) = v10[0];
    }
    else
    {
      v7 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E00, 1u, 1, v7, v7 != &v14, v4, 0, v5);
  }
  return FigXPCPurgeObjectsForPIDWithReportingBlock(a2, (uint64_t)&__block_literal_global_90);
}

uint64_t FigCAStatsReportingSubmitData(const void *a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v8;
  void *v9;
  void *v10;
  const void **v11;
  const __CFString **v12;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef v15;
  _QWORD v17[7];
  const __CFString *v18;
  const void *v19;
  _QWORD v20[2];
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  if (frcs_initOnce_onceToken != -1)
    dispatch_once(&frcs_initOnce_onceToken, &__block_literal_global_4);
  v8 = 0;
  if (a1 && gFigCAStatsDispatchQueue)
  {
    v9 = (void *)MEMORY[0x193FFC34C]();
    if (a3)
    {
      v20[1] = a3;
      v21[0] = a1;
      v20[0] = CFSTR("appName");
      v21[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", a4);
      v10 = (void *)MEMORY[0x1E0C99D80];
      v11 = (const void **)v21;
      v12 = (const __CFString **)v20;
      v13 = 2;
    }
    else
    {
      v18 = CFSTR("appName");
      v19 = a1;
      v10 = (void *)MEMORY[0x1E0C99D80];
      v11 = &v19;
      v12 = &v18;
      v13 = 1;
    }
    v14 = objc_msgSend(v10, "dictionaryWithObjects:forKeys:count:", v11, v12, v13);
    if (v14)
    {
      v15 = CFRetain(a1);
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 3221225472;
      v17[2] = __FigCAStatsReportingSubmitData_block_invoke;
      v17[3] = &unk_1E28D8090;
      v17[4] = v14;
      v17[5] = a2;
      v17[6] = v15;
      dispatch_async((dispatch_queue_t)gFigCAStatsDispatchQueue, v17);
      v8 = 0;
    }
    else
    {
      v8 = 4294954510;
    }
    objc_autoreleasePoolPop(v9);
  }
  return v8;
}

dispatch_queue_t __frcs_initOnce_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("com.apple.coremedia.FigReportingCAStats", 0);
  gFigCAStatsDispatchQueue = (uint64_t)result;
  return result;
}

uint64_t FigAudioDeviceSupportsPresentationTime(AudioObjectID inObjectID)
{
  AudioObjectPropertyAddress v3;

  v3.mElement = 0;
  *(_QWORD *)&v3.mSelector = *(_QWORD *)"tptbbolg";
  if (sCheckTraceOnceToken != -1)
  {
    dispatch_once(&sCheckTraceOnceToken, &__block_literal_global_5);
    if (inObjectID)
      return AudioObjectHasProperty(inObjectID, &v3);
LABEL_6:
    FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (!inObjectID)
    goto LABEL_6;
  return AudioObjectHasProperty(inObjectID, &v3);
}

uint64_t FigAudioDeviceGetCurrentPresentationTime(AudioObjectID inObjectID, uint64_t a2)
{
  uint64_t result;
  _BYTE v5[40];
  UInt32 outDataSize;

  outDataSize = 0;
  memset(v5, 0, sizeof(v5));
  if (sCheckTraceOnceToken == -1)
  {
    if (!a2)
      return FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    dispatch_once(&sCheckTraceOnceToken, &__block_literal_global_2);
    if (!a2)
      return FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
  }
  if (!inObjectID)
    return FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
  result = AudioObjectGetPropertyDataSize(inObjectID, (const AudioObjectPropertyAddress *)"tptbbolg", 0, 0, &outDataSize);
  if (!(_DWORD)result)
  {
    if (outDataSize == 40)
    {
      result = AudioObjectGetPropertyData(inObjectID, (const AudioObjectPropertyAddress *)"tptbbolg", 0, 0, &outDataSize, v5);
      if (!(_DWORD)result)
      {
        *(_QWORD *)a2 = *(_QWORD *)v5;
        *(_OWORD *)(a2 + 8) = *(_OWORD *)&v5[8];
        *(_OWORD *)(a2 + 24) = *(_OWORD *)&v5[24];
      }
    }
    else
    {
      return FigSignalErrorAt(4294949374, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t FigAudioDeviceGetCurrentDynamicLatency(AudioObjectID inObjectID, CMTime *a2)
{
  uint64_t result;
  double v5;
  double v6;
  double v7;
  CMTime v8;
  AudioObjectPropertyAddress inAddress;
  UInt32 ioDataSize;
  double outData;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = 0;
  v12 = 0u;
  v13 = 0u;
  outData = NAN;
  *(_QWORD *)&inAddress.mSelector = *(_QWORD *)"trsnptuo";
  inAddress.mElement = 0;
  if (sCheckTraceOnceToken != -1)
  {
    dispatch_once(&sCheckTraceOnceToken, &__block_literal_global_4);
    if (a2)
      goto LABEL_3;
    return FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
  }
  if (!a2)
    return FigSignalErrorAt(4294949376, 0, 0, 0, 0, 0, 0);
LABEL_3:
  result = FigAudioDeviceGetCurrentPresentationTime(inObjectID, (uint64_t)&v12);
  if (!(_DWORD)result)
  {
    v5 = *((double *)&v12 + 1);
    v6 = *(double *)&v13;
    ioDataSize = 8;
    result = AudioObjectGetPropertyData(inObjectID, &inAddress, 0, 0, &ioDataSize, &outData);
    if (!(_DWORD)result)
    {
      v7 = v5 - v6;
      if (v5 - v6 < 0.0)
        v7 = -(v5 - v6);
      CMTimeMake(&v8, (uint64_t)v7, (int)outData);
      result = 0;
      *a2 = v8;
    }
  }
  return result;
}

uint64_t FigCaptionDataGetClassID()
{
  FigThreadRunOnce(&FigCaptionDataGetClassID_sRegisterFigCaptionDataBaseTypeOnce, (void (*)(void))RegisterFigCaptionDataBaseType);
  return sFigCaptionDataClassID;
}

uint64_t RegisterFigCaptionDataBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigCaptionDataClassDesc, ClassID, 1, &sFigCaptionDataClassID);
}

uint64_t FigCaptionDataGetTypeID()
{
  FigThreadRunOnce(&FigCaptionDataGetClassID_sRegisterFigCaptionDataBaseTypeOnce, (void (*)(void))RegisterFigCaptionDataBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigCaptionDataClassID);
}

uint64_t FigCaptionDataCreate(const __CFAllocator *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5;
  CFTypeRef v6;
  uint64_t (*v7)(CFTypeRef, uint64_t);
  uint64_t v8;
  CFTypeRef cf;

  cf = 0;
  if (a2 && a3)
  {
    v5 = FigCaptionDataCreateMutable(a1, &cf);
    v6 = cf;
    if ((_DWORD)v5)
    {
      v8 = v5;
      if (!cf)
        return v8;
    }
    else
    {
      v7 = *(uint64_t (**)(CFTypeRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf) + 16) + 16);
      if (v7)
      {
        v8 = v7(v6, a2);
        v6 = cf;
        if (!(_DWORD)v8)
        {
          *a3 = cf;
          return v8;
        }
      }
      else
      {
        v8 = 4294954514;
        v6 = cf;
      }
      if (!v6)
        return v8;
    }
    CFRelease(v6);
    return v8;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionDataCopySubrange(const __CFAllocator *a1, uint64_t a2, CFIndex a3, CFIndex a4, CFTypeRef *a5)
{
  CFTypeRef *v5;
  uint64_t (*v10)(uint64_t);
  const __CFString *v11;
  CFIndex Length;
  uint64_t v13;
  uint64_t v14;
  CFStringRef v15;
  CFTypeRef v16;
  uint64_t (*v17)(CFTypeRef, CFStringRef);
  uint64_t v18;
  uint64_t (*v19)(uint64_t, const __CFString *, uint64_t, CFArrayRef *);
  uint64_t v20;
  CFIndex v21;
  const void *ValueAtIndex;
  const void *v23;
  CFIndex v24;
  uint64_t (*v25)(uint64_t, CFIndex, const void *, uint64_t, CFTypeRef *, uint64_t *);
  CFTypeRef v26;
  uint64_t v27;
  uint64_t v28;
  CFTypeRef v29;
  uint64_t (*v30)(CFTypeRef, const void *, CFTypeRef, uint64_t, CFIndex);
  uint64_t v31;
  CFIndex v32;
  uint64_t v33;
  CFTypeRef *v35;
  CFIndex Count;
  CFIndex v37;
  const __CFString *v38;
  uint64_t v39;
  uint64_t v40;
  CFTypeRef cf;
  CFArrayRef theArray;
  CFTypeRef v43;
  CFRange v44;

  theArray = 0;
  v43 = 0;
  cf = 0;
  if (!a2)
  {
    v33 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v15 = 0;
    goto LABEL_37;
  }
  v5 = a5;
  if (!a5
    || ((v10 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(a2) + 16) + 8)) == 0
      ? (v11 = &stru_1E28E82E0)
      : (v11 = (const __CFString *)v10(a2)),
        (Length = CFStringGetLength(v11), a3 < 0) || a3 + a4 > Length))
  {
    v13 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_45;
  }
  v13 = FigCaptionDataCreateMutable(a1, &v43);
  if ((_DWORD)v13)
  {
LABEL_45:
    v33 = v13;
    v15 = 0;
    goto LABEL_35;
  }
  v14 = *MEMORY[0x1E0C9AE00];
  v44.location = a3;
  v44.length = a4;
  v15 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v11, v44);
  v16 = v43;
  v17 = *(uint64_t (**)(CFTypeRef, CFStringRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v43) + 16) + 16);
  if (!v17)
  {
LABEL_31:
    v33 = 4294954514;
    goto LABEL_35;
  }
  v18 = v17(v16, v15);
  if (!(_DWORD)v18)
  {
    v19 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a2) + 8)
                                                                                       + 48);
    if (v19)
    {
      v38 = v15;
      v20 = v19(a2, CFSTR("StylePropertyKeysInUse"), v14, &theArray);
      if ((_DWORD)v20)
      {
LABEL_33:
        v33 = v20;
      }
      else if (theArray && (Count = CFArrayGetCount(theArray)) != 0)
      {
        v21 = 0;
        v35 = v5;
        while (1)
        {
          v37 = v21;
          ValueAtIndex = CFArrayGetValueAtIndex(theArray, v21);
          if (a4 >= 1)
            break;
LABEL_29:
          v21 = v37 + 1;
          v5 = v35;
          if (v37 + 1 == Count)
            goto LABEL_30;
        }
        v23 = ValueAtIndex;
        v24 = a3;
        while (1)
        {
          v39 = 0;
          v40 = 0;
          if (cf)
          {
            CFRelease(cf);
            cf = 0;
          }
          v25 = *(uint64_t (**)(uint64_t, CFIndex, const void *, uint64_t, CFTypeRef *, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(a2) + 16) + 24);
          if (!v25)
            break;
          v20 = v25(a2, v24, v23, v14, &cf, &v39);
          if ((_DWORD)v20)
            goto LABEL_33;
          v26 = cf;
          if (cf)
          {
            v28 = v39;
            v27 = v40;
            v29 = v43;
            v30 = *(uint64_t (**)(CFTypeRef, const void *, CFTypeRef, uint64_t, CFIndex))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v43) + 16)
                                                                                                 + 32);
            if (!v30)
              break;
            v31 = (v28 - a3) & ~((v28 - a3) >> 63);
            if (((v28 - a3) & ((v28 - a3) >> 63)) + v27 + v31 <= a4)
              v32 = ((v28 - a3) & ((v28 - a3) >> 63)) + v27;
            else
              v32 = a4 - v31;
            v20 = v30(v29, v23, v26, v31, v32);
            if ((_DWORD)v20)
              goto LABEL_33;
          }
          v24 = v40 + v39;
          if (v40 + v39 >= a3 + a4)
            goto LABEL_29;
        }
        v33 = 4294954514;
      }
      else
      {
LABEL_30:
        v33 = 0;
        *v5 = v43;
        v43 = 0;
      }
      v15 = v38;
      goto LABEL_35;
    }
    goto LABEL_31;
  }
  v33 = v18;
LABEL_35:
  if (cf)
    CFRelease(cf);
LABEL_37:
  if (theArray)
    CFRelease(theArray);
  if (v43)
    CFRelease(v43);
  if (v15)
    CFRelease(v15);
  return v33;
}

CFStringRef FigCaptionDataCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionData %p]"), a1);
}

uint64_t FigProcessStateMonitorServerEnsureStartedAndCopyEndpoint(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  void *v5;

  v5 = 0;
  if (!a1)
  {
    v2 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  if (FigProcessStateMonitorEnsureServerStarted_sStartStateMonitorServerOnce != -1)
    dispatch_once(&FigProcessStateMonitorEnsureServerStarted_sStartStateMonitorServerOnce, &__block_literal_global_6);
  v2 = FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult;
  if (FigProcessStateMonitorEnsureServerStarted_sStateMonitorServerStartResult)
    goto LABEL_7;
  v2 = FigXPCServerCopyXPCEndpoint(gFigProcessMonitorServer, &v5);
  v3 = v5;
  if (!(_DWORD)v2)
  {
    *a1 = v5;
    v5 = 0;
LABEL_7:
    v3 = 0;
  }
  FigXPCRelease(v3);
  return v2;
}

uint64_t FigProcessStateMonitorInformRemotesOfIndirectDependencyDeath(uint64_t a1)
{
  return FigCFWeakReferenceTableApplyFunction(gServedObjects, (void (*)(_QWORD, CFTypeRef, uint64_t))figProcessStateMonitorInformRemoteOfIndirectDependencyDeathApply, a1);
}

uint64_t figProcessStateMonitorInformRemoteOfIndirectDependencyDeathApply(uint64_t a1, const void *a2, const void *a3)
{
  __CFNotificationCenter *DefaultLocalCenter;

  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("MediaServicesProcessDeath"), a2, a3);
}

uint64_t FigProcessStateMonitorPurgePreventionAssertionGetTypeID()
{
  if (FigProcessStateMonitorPurgePreventionAssertionGetTypeID_sRegisterFigProcessStateMonitorPurgePreventionAssertionTypeOnce != -1)
    dispatch_once_f(&FigProcessStateMonitorPurgePreventionAssertionGetTypeID_sRegisterFigProcessStateMonitorPurgePreventionAssertionTypeOnce, 0, (dispatch_function_t)registerFigProcessStateMonitorPurgePreventionAssertionType);
  return sFigProcessStateMonitorPurgePreventionAssertionID;
}

uint64_t registerFigProcessStateMonitorPurgePreventionAssertionType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigProcessStateMonitorPurgePreventionAssertionID = result;
  return result;
}

uint64_t FigProcessStateMonitorCreateExpiringAssertionOnBehalfOfProcessWithPID(int a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;
  dispatch_queue_t *v8;
  _QWORD *Instance;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v11;
  uint64_t v12;
  unsigned int v13;
  char *v14;
  NSObject *v15;
  dispatch_time_t v16;
  void *v17;
  CFTypeRef v18;
  _QWORD handler[5];
  os_log_type_t type;
  int v21;
  uint64_t v22;
  int v23;
  const char *v24;
  __int16 v25;
  _QWORD *v26;
  __int16 v27;
  uint64_t v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  result = fpsmServer_copyCompanionForPID(a1, &v22);
  if (!(_DWORD)result)
  {
    v8 = (dispatch_queue_t *)v22;
    if (*(_BYTE *)(v22 + 80))
    {
      result = figProcessStateMonitorMustNotPurgeClientObjects(v22, a2);
      if (!(_DWORD)result)
      {
        if (FigProcessStateMonitorPurgePreventionAssertionGetTypeID_sRegisterFigProcessStateMonitorPurgePreventionAssertionTypeOnce != -1)
          dispatch_once_f(&FigProcessStateMonitorPurgePreventionAssertionGetTypeID_sRegisterFigProcessStateMonitorPurgePreventionAssertionTypeOnce, 0, (dispatch_function_t)registerFigProcessStateMonitorPurgePreventionAssertionType);
        Instance = (_QWORD *)_CFRuntimeCreateInstance();
        if (Instance || (result = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0), !(_DWORD)result))
        {
          if (dword_1EE141E28)
          {
            v21 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, &v21, &type);
            v11 = v21;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
              v13 = v11;
            else
              v13 = v11 & 0xFFFFFFFE;
            if (v13)
            {
              v23 = 136315650;
              v24 = "FigProcessStateMonitorCreateExpiringAssertionOnBehalfOfProcessWithPID";
              v25 = 2112;
              v26 = Instance;
              v27 = 2048;
              v28 = a3;
              v14 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v11) = v21;
            }
            else
            {
              v14 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v14, v14 != &v29, v11, 0, v12);
          }
          v15 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v8[3]);
          v16 = dispatch_time(0, 1000000000 * a3);
          dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
          v17 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)Instance);
          dispatch_set_context(v15, v17);
          dispatch_set_finalizer_f(v15, (dispatch_function_t)figProcessStateMonitorPurgePreventionAssertionTimeoutFinalizer);
          handler[0] = MEMORY[0x1E0C809B0];
          handler[1] = 3221225472;
          handler[2] = __FigProcessStateMonitorCreateExpiringAssertionOnBehalfOfProcessWithPID_block_invoke;
          handler[3] = &unk_1E28D7E98;
          handler[4] = v15;
          dispatch_source_set_event_handler(v15, handler);
          Instance[5] = v15;
          if (a2)
            v18 = CFRetain(a2);
          else
            v18 = 0;
          Instance[3] = v18;
          Instance[4] = CFRetain(v8);
          dispatch_activate(v15);
          result = 0;
          *a4 = Instance;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t fpsmServer_copyCompanionForPID(int a1, _QWORD *a2)
{
  uint64_t v4;
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex v7;
  const __CFDictionary *v8;
  const void *ValueAtIndex;
  _DWORD *Value;
  uint64_t v11;
  CFTypeRef cf;

  cf = 0;
  v4 = FigCFWeakReferenceTableCopyValues(gServedObjects, (CFMutableDictionaryRef *)&cf);
  if ((_DWORD)v4)
    goto LABEL_16;
  v5 = FigCFDictionaryCopyArrayOfKeys(cf);
  if (!v5)
  {
    v4 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
LABEL_16:
    v11 = v4;
    goto LABEL_12;
  }
  v6 = v5;
  if (CFArrayGetCount(v5) < 1)
  {
LABEL_9:
    v11 = FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v7 = 0;
    while (1)
    {
      v8 = (const __CFDictionary *)cf;
      ValueAtIndex = CFArrayGetValueAtIndex(v6, v7);
      Value = FigCFDictionaryGetValue(v8, ValueAtIndex);
      if (Value)
        Value = CFRetain(Value);
      if (Value[4] == a1)
        break;
      CFRelease(Value);
      if (++v7 >= CFArrayGetCount(v6))
        goto LABEL_9;
    }
    v11 = 0;
    *a2 = Value;
  }
  CFRelease(v6);
LABEL_12:
  if (cf)
    CFRelease(cf);
  return v11;
}

uint64_t figProcessStateMonitorMustNotPurgeClientObjects(uint64_t a1, const void *a2)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  uint64_t v9;
  os_log_type_t type;
  int v12[2];
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  const void *v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  if (dword_1EE141E28)
  {
    v12[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, v12, &type);
    v5 = v12[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v7 = v5;
    else
      v7 = v5 & 0xFFFFFFFE;
    if (v7)
    {
      v12[1] = 136315650;
      v13 = "figProcessStateMonitorMustNotPurgeClientObjects";
      v14 = 2114;
      v15 = a1;
      v16 = 2114;
      v17 = a2;
      v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v12[0];
    }
    else
    {
      v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v8, v8 != &v18, v5, 0, v6);
  }
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 64));
  v9 = FigPurgeAndRenewProcessStateTrackerModifyPurgeEligibilityForPID(*(unsigned int *)(a1 + 16), 1);
  if (!(_DWORD)v9)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), a2);
    *(_BYTE *)(a1 + 56) = 0;
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v9;
}

void figProcessStateMonitorPurgePreventionAssertionTimeoutFinalizer(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t figProcessStateMonitorMayPurgeClientObjects(uint64_t a1, const void *a2)
{
  CFIndex FirstIndexOfValue;
  CFIndex v5;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v7;
  uint64_t v8;
  unsigned int v9;
  _BYTE *v10;
  const __CFArray *v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  _BYTE *v16;
  os_log_type_t type;
  int v19;
  int v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  const void *v25;
  _BYTE v26[128];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 64));
  FirstIndexOfValue = FigCFArrayGetFirstIndexOfValue(*(const __CFArray **)(a1 + 48), a2);
  if (FirstIndexOfValue == -1)
  {
    FigSignalErrorAt(4294947863, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v5 = FirstIndexOfValue;
    if (dword_1EE141E28)
    {
      v19 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, &v19, &type);
      v7 = v19;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v9 = v7;
      else
        v9 = v7 & 0xFFFFFFFE;
      if (v9)
      {
        v20 = 136315650;
        v21 = "figProcessStateMonitorMayPurgeClientObjects";
        v22 = 2114;
        v23 = a1;
        v24 = 2114;
        v25 = a2;
        v10 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v7) = v19;
      }
      else
      {
        v10 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v10, v10 != v26, v7, 0, v8);
    }
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 48), v5);
    v11 = *(const __CFArray **)(a1 + 48);
    if ((!v11 || !CFArrayGetCount(v11))
      && !FigPurgeAndRenewProcessStateTrackerModifyPurgeEligibilityForPID(*(unsigned int *)(a1 + 16), 0))
    {
      *(_BYTE *)(a1 + 56) = 1;
      if (dword_1EE141E28)
      {
        v19 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, &v19, &type);
        v13 = v19;
        if (os_log_type_enabled(v12, type))
          v15 = v13;
        else
          v15 = v13 & 0xFFFFFFFE;
        if (v15)
        {
          v20 = 136315394;
          v21 = "figProcessStateMonitorMayPurgeClientObjects";
          v22 = 2114;
          v23 = a1;
          v16 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v13) = v19;
        }
        else
        {
          v16 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v16, v16 != v26, v13, 0, v14);
      }
    }
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
}

uint64_t FigProcessStateMonitor_handleMessage(_xpc_connection_s *a1, xpc_object_t xdict, void *a3)
{
  void *uint64;
  uint64_t OpCode;
  pid_t pid;
  const __CFAllocator *v9;
  uint64_t Instance;
  uint64_t v11;
  dispatch_queue_t v12;
  CFMutableArrayRef Mutable;
  pthread_mutex_t *v14;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v16;
  uint64_t v17;
  unsigned int v18;
  _BYTE *v19;
  NSObject **v20;
  NSObject **v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  _BYTE *v27;
  _QWORD block[8];
  int v30;
  int v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  int v35;
  uint64_t value;
  os_log_type_t type;
  int v38;
  int v39;
  const char *v40;
  __int16 v41;
  _BYTE v42[14];
  __int16 v43;
  int v44;
  _BYTE v45[128];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v33 = &v32;
  v34 = 0x2020000000;
  v35 = 0;
  v31 = 0;
  uint64 = (void *)xpc_dictionary_get_uint64(xdict, ".objectID");
  OpCode = FigXPCMessageGetOpCode(xdict, &v31);
  *((_DWORD *)v33 + 6) = OpCode;
  if (!(_DWORD)OpCode)
  {
    if (v31 == 1668441460)
    {
      value = 0;
      pid = xpc_connection_get_pid(a1);
      FigThreadRunOnce(&sRegisterFigProcessStateMonitorCompanionClassOnce, (void (*)(void))RegisterFigProcessStateMonitorCompanionClass);
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Instance = _CFRuntimeCreateInstance();
      v11 = Instance;
      if (Instance)
      {
        *(_DWORD *)(Instance + 16) = pid;
        v12 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.figprocessstatemonitor.server", 0, 0);
        *(_QWORD *)(v11 + 24) = v12;
        if (v12)
        {
          Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]);
          *(_QWORD *)(v11 + 48) = Mutable;
          if (Mutable)
          {
            *(_QWORD *)(v11 + 32) = 0;
            *(_QWORD *)(v11 + 40) = 0;
            *(_BYTE *)(v11 + 56) = 1;
            v14 = FigReentrantMutexCreate();
            *(_QWORD *)(v11 + 64) = v14;
            if (v14)
            {
              if (dword_1EE141E28)
              {
                v38 = 0;
                type = OS_LOG_TYPE_DEFAULT;
                os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, &v38, &type);
                v16 = v38;
                if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
                  v18 = v16;
                else
                  v18 = v16 & 0xFFFFFFFE;
                if (v18)
                {
                  v39 = 136315394;
                  v40 = "fpsmServer_createCompanion";
                  v41 = 2114;
                  *(_QWORD *)v42 = v11;
                  v19 = (_BYTE *)_os_log_send_and_compose_impl();
                  LOBYTE(v16) = v38;
                }
                else
                {
                  v19 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v19, v19 != v45, v16, 0, v17);
              }
              goto LABEL_17;
            }
          }
        }
        OpCode = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
        CFRelease((CFTypeRef)v11);
      }
      else
      {
        OpCode = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
      }
      v11 = 0;
      if ((_DWORD)OpCode)
      {
LABEL_20:
        if (dword_1EE141E28)
        {
          v38 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          v23 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, &v38, &type);
          v24 = v38;
          if (os_log_type_enabled(v23, type))
            v26 = v24;
          else
            v26 = v24 & 0xFFFFFFFE;
          if (v26)
          {
            v39 = 136315906;
            v40 = "figProcessStateMonitorHandleCreate";
            v41 = 1024;
            *(_DWORD *)v42 = pid;
            *(_WORD *)&v42[4] = 2114;
            *(_QWORD *)&v42[6] = v11;
            v43 = 1024;
            v44 = OpCode;
            v27 = (_BYTE *)_os_log_send_and_compose_impl();
            LOBYTE(v24) = v38;
          }
          else
          {
            v27 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v27, v27 != v45, v24, 0, v25);
        }
        if (v11)
          CFRelease((CFTypeRef)v11);
        goto LABEL_30;
      }
LABEL_17:
      OpCode = FigXPCServerAssociateObjectWithConnection(a1, (const void *)v11, 0, 0, 0, &value);
      if (!(_DWORD)OpCode)
      {
        OpCode = FigCFWeakReferenceTableAddValueAssociatedWithKey(gServedObjects, v11, value);
        if (!(_DWORD)OpCode)
        {
          xpc_dictionary_set_uint64(a3, ".objectID", value);
          OpCode = 0;
        }
      }
      goto LABEL_20;
    }
    v20 = (NSObject **)FigCFWeakReferenceTableCopyValue(gServedObjects, uint64);
    v21 = v20;
    if (!v20)
    {
      OpCode = FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
LABEL_30:
      *((_DWORD *)v33 + 6) = OpCode;
      goto LABEL_31;
    }
    v22 = v20[3];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __FigProcessStateMonitor_handleMessage_block_invoke;
    block[3] = &unk_1E28D8480;
    v30 = v31;
    block[4] = a1;
    block[5] = xdict;
    block[6] = a3;
    block[7] = &v32;
    dispatch_sync(v22, block);
    CFRelease(v21);
    OpCode = *((unsigned int *)v33 + 6);
  }
LABEL_31:
  _Block_object_dispose(&v32, 8);
  return OpCode;
}

void sub_18ECAAE10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t FigProcessStateMonitor_noReplyHandleMessage(uint64_t a1, xpc_object_t xdict)
{
  void *uint64;
  uint64_t OpCode;
  NSObject **v6;
  NSObject **v7;
  NSObject *v8;
  _QWORD v10[7];
  int v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  v12 = 0;
  uint64 = (void *)xpc_dictionary_get_uint64(xdict, ".objectID");
  OpCode = FigXPCMessageGetOpCode(xdict, &v12);
  *((_DWORD *)v14 + 6) = OpCode;
  if (!(_DWORD)OpCode)
  {
    v6 = (NSObject **)FigCFWeakReferenceTableCopyValue(gServedObjects, uint64);
    v7 = v6;
    if (v6)
    {
      v8 = v6[3];
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 3221225472;
      v10[2] = __FigProcessStateMonitor_noReplyHandleMessage_block_invoke;
      v10[3] = &unk_1E28D8568;
      v11 = v12;
      v10[4] = a1;
      v10[5] = xdict;
      v10[6] = &v13;
      dispatch_sync(v8, v10);
      CFRelease(v7);
      OpCode = *((unsigned int *)v14 + 6);
    }
    else
    {
      OpCode = FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
      *((_DWORD *)v14 + 6) = OpCode;
    }
  }
  _Block_object_dispose(&v13, 8);
  return OpCode;
}

void sub_18ECAAF60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t RegisterFigProcessStateMonitorCompanionClass()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigProcessStateMonitorServerCompanionID = result;
  return result;
}

double fpsmServerCompanion_init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void fpsmServerCompanion_finalize(_QWORD *a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  NSObject *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  os_log_type_t type;
  int v15[2];
  const char *v16;
  __int16 v17;
  _QWORD *v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (dword_1EE141E28)
  {
    v15[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, v15, &type);
    v3 = v15[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v5 = v3;
    else
      v5 = v3 & 0xFFFFFFFE;
    if (v5)
    {
      v15[1] = 136315394;
      v16 = "fpsmServerCompanion_finalize";
      v17 = 2048;
      v18 = a1;
      v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v15[0];
    }
    else
    {
      v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v6, v6 != &v19, v3, 0, v4);
  }
  v7 = a1[3];
  if (v7)
    dispatch_release(v7);
  v8 = (const void *)a1[4];
  if (v8)
    CFRelease(v8);
  v9 = (const void *)a1[6];
  if (v9)
    CFRelease(v9);
  v10 = (const void *)a1[5];
  if (v10)
    CFRelease(v10);
  FigReentrantMutexDestroy(a1[8]);
  v11 = (const void *)a1[11];
  if (v11)
    CFRelease(v11);
  v12 = (const void *)a1[12];
  if (v12)
    CFRelease(v12);
  v13 = (const void *)a1[14];
  if (v13)
    CFRelease(v13);
}

__CFString *figProcessStateMonitorServer_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  __CFString *v3;
  CFTimeZoneRef v4;
  const __CFAllocator *v5;
  __CFDateFormatter *v6;
  __CFDateFormatter *v7;
  const void *v8;
  const void *v9;
  const __CFDate *v10;
  const void *StringWithDate;
  const __CFDate *v12;
  const __CFDate *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  int v17;
  unsigned int TrackedState;
  const char *v19;
  CFIndex Count;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = Mutable;
  if (!Mutable)
    return v3;
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigProcessStateMonitorServerCompanion (%p, %d)> {\n"), a1, *(unsigned int *)(a1 + 16));
  CFStringAppendFormat(v3, 0, CFSTR("\tMEMRC=\"%@\",\n"), *(_QWORD *)(a1 + 32));
  v4 = CFTimeZoneCopySystem();
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = CFDateFormatterCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, kCFDateFormatterShortStyle, kCFDateFormatterLongStyle);
  v7 = v6;
  v8 = 0;
  v9 = 0;
  if (v4
    && v6
    && ((CFDateFormatterSetProperty(v6, (CFStringRef)*MEMORY[0x1E0C9AF68], v4),
         (v10 = *(const __CFDate **)(a1 + 88)) == 0)
      ? (StringWithDate = 0)
      : (StringWithDate = CFDateFormatterCreateStringWithDate(v5, v7, v10)),
        (v12 = *(const __CFDate **)(a1 + 96)) == 0
      ? (v9 = 0)
      : (v9 = CFDateFormatterCreateStringWithDate(v5, v7, v12)),
        (v13 = *(const __CFDate **)(a1 + 112)) == 0
      ? (v8 = 0)
      : (v8 = CFDateFormatterCreateStringWithDate(v5, v7, v13)),
        !*(_QWORD *)(a1 + 88) || StringWithDate))
  {
    if ((!*(_QWORD *)(a1 + 96) || v9) && (!*(_QWORD *)(a1 + 112) || v8))
      goto LABEL_29;
    CFStringAppendFormat(v3, 0, CFSTR("\t // Note: Fallback to GMT\n"));
    if (StringWithDate)
      CFRelease(StringWithDate);
  }
  else
  {
    CFStringAppendFormat(v3, 0, CFSTR("\t // Note: Fallback to GMT\n"));
  }
  v14 = *(const void **)(a1 + 88);
  if (v14)
  {
    StringWithDate = CFRetain(v14);
    if (!v9)
      goto LABEL_19;
    goto LABEL_18;
  }
  StringWithDate = 0;
  if (v9)
LABEL_18:
    CFRelease(v9);
LABEL_19:
  v15 = *(const void **)(a1 + 96);
  if (v15)
  {
    v9 = CFRetain(v15);
    if (!v8)
      goto LABEL_22;
    goto LABEL_21;
  }
  v9 = 0;
  if (v8)
LABEL_21:
    CFRelease(v8);
LABEL_22:
  v16 = *(const void **)(a1 + 112);
  if (v16)
    v8 = CFRetain(v16);
  else
    v8 = 0;
LABEL_29:
  v17 = *(unsigned __int8 *)(a1 + 80);
  if (*(_BYTE *)(a1 + 80))
  {
    TrackedState = FigPurgeAndRenewProcessStateTrackerGetTrackedState(*(unsigned int *)(a1 + 16));
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 64));
    if (TrackedState > 2)
      v19 = "??";
    else
      v19 = off_1E28D85E8[TrackedState];
  }
  else
  {
    v19 = "NT";
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  CFStringAppendFormat(v3, 0, CFSTR("\tENRD=\"%@\", AC=\"%ld\", PS=\"%s\", MRP=\"%lld@%@\",\n"), StringWithDate, Count, v19, *(_QWORD *)(a1 + 72), v9);
  if (*(_BYTE *)(a1 + 120))
    CFStringAppendFormat(v3, 0, CFSTR("\t!!!! SPE=\"%lld\" SPD=\"%@\"\n"), *(_QWORD *)(a1 + 104), v8);
  CFStringAppendFormat(v3, 0, CFSTR("}"));
  if (v17)
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  if (v4)
    CFRelease(v4);
  if (v7)
    CFRelease(v7);
  if (StringWithDate)
    CFRelease(StringWithDate);
  if (v9)
    CFRelease(v9);
  if (v8)
    CFRelease(v8);
  return v3;
}

void __figProcessStateMonitorHandleEnrollInPurge_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  _BYTE *v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  _BYTE *v16;
  NSObject *v17;
  CFStringRef v18;
  CFStringRef v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  _BYTE *v24;
  _QWORD block[6];
  int v26;
  os_log_type_t type;
  int v28;
  uint64_t v29;
  char *dataPointerOut;
  int v31;
  const char *v32;
  __int16 v33;
  uint64_t v34;
  _BYTE v35[128];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v29 = 0;
  dataPointerOut = 0;
  if (dword_1EE141E28)
  {
    v28 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, &v28, &type);
    v5 = v28;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v7 = v5;
    else
      v7 = v5 & 0xFFFFFFFE;
    if (v7)
    {
      v8 = *(_QWORD *)(a1 + 32);
      v31 = 136315394;
      v32 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
      v33 = 2048;
      v34 = v8;
      v9 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v28;
    }
    else
    {
      v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v9, v9 != v35, v5, 0, v6);
  }
  v10 = fpsmServer_copyCompanionForPID(a2, &v29);
  v11 = v29;
  if (v10)
  {
    if (v29)
LABEL_31:
      CFRelease((CFTypeRef)v11);
  }
  else
  {
    if (v29)
    {
      if (dword_1EE141E28)
      {
        v28 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, &v28, &type);
        v13 = v28;
        if (os_log_type_enabled(v12, type))
          v15 = v13;
        else
          v15 = v13 & 0xFFFFFFFE;
        if (v15)
        {
          v31 = 136315394;
          v32 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
          v33 = 2114;
          v34 = v11;
          v16 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v13) = v28;
        }
        else
        {
          v16 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v16, v16 != v35, v13, 0, v14);
      }
      FigReentrantMutexLock(*(pthread_mutex_t **)(v11 + 64));
      if (*(_BYTE *)(v11 + 56))
      {
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(v11 + 64));
        if (!CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(v11 + 40), 0, 0, 0, &dataPointerOut))
        {
          if ((dataPointerOut & 0xF) != 0)
          {
            FigSignalErrorAt(4294947862, 0, 0, 0, 0, 0, 0);
          }
          else
          {
            v17 = *(NSObject **)(v11 + 24);
            block[0] = MEMORY[0x1E0C809B0];
            block[1] = 3221225472;
            block[2] = __figProcessStateMonitorHandleEnrollInPurge_block_invoke_29;
            block[3] = &__block_descriptor_52_e5_v8__0l;
            v26 = a2;
            block[4] = v11;
            block[5] = dataPointerOut;
            dispatch_sync(v17, block);
            v18 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("event=%lld, stickyCouldNotPurgeAllObjects=%d"), *(_QWORD *)(v11 + 72), *(unsigned __int8 *)(v11 + 120));
            if (v18)
            {
              v19 = v18;
              FigPerformanceMonitorAddToReclamationEventLog(a2, v18);
              CFRelease(v19);
            }
            else
            {
              v28 = 0;
              type = OS_LOG_TYPE_DEFAULT;
              v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 0, &v28, &type);
              v21 = v28;
              if (os_log_type_enabled(v20, type))
                v23 = v21;
              else
                v23 = v21 & 0xFFFFFFFE;
              if (v23)
              {
                v31 = 136315138;
                v32 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
                v24 = (_BYTE *)_os_log_send_and_compose_impl();
                LOBYTE(v21) = v28;
              }
              else
              {
                v24 = 0;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 0, 1, v24, v24 != v35, v21, 0, v22);
            }
          }
        }
      }
      else
      {
        FigSignalErrorAt(4294947861, 0, 0, 0, 0, 0, 0);
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(v11 + 64));
      }
      goto LABEL_31;
    }
    FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t __figProcessStateMonitorHandleEnrollInPurge_block_invoke_29(uint64_t a1)
{
  uint64_t v2;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  _BYTE *v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  _BYTE *v13;
  int v14;
  _QWORD v16[6];
  os_log_type_t type;
  int v18;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  _BYTE v23[128];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  FigReentrantMutexLock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 32) + 64));
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 56))
  {
    if (dword_1EE141E28)
    {
      v18 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, &v18, &type);
      v4 = v18;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v6 = v4;
      else
        v6 = v4 & 0xFFFFFFFE;
      if (v6)
      {
        v7 = *(_QWORD *)(a1 + 32);
        v19 = 136315394;
        v20 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
        v21 = 2114;
        v22 = v7;
        v8 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v4) = v18;
      }
      else
      {
        v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v8, v8 != v23, v4, 0, v5);
      v2 = *(_QWORD *)(a1 + 32);
    }
    v14 = *(_DWORD *)(a1 + 48);
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v16[2] = __figProcessStateMonitorHandleEnrollInPurge_block_invoke_30;
    v16[3] = &__block_descriptor_48_e43_v36__0r_8__NSObject_OS_xpc_object__16q24C32l;
    v16[4] = *(_QWORD *)(a1 + 40);
    v16[5] = v2;
    FigXPCPurgeObjectsForPIDWithReportingBlock(v14, (uint64_t)v16);
  }
  else
  {
    v18 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v9 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 0, &v18, &type);
    v10 = v18;
    if (os_log_type_enabled(v9, type))
      v12 = v10;
    else
      v12 = v10 & 0xFFFFFFFE;
    if (v12)
    {
      v19 = 136315138;
      v20 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
      v13 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v10) = v18;
    }
    else
    {
      v13 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 0, 1, v13, v13 != v23, v10, 0, v11);
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 32) + 64));
}

void __figProcessStateMonitorHandleEnrollInPurge_block_invoke_30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  _QWORD *v8;
  const __CFAllocator *v9;
  CFAbsoluteTime Current;
  uint64_t v11;
  const __CFAllocator *v12;
  CFAbsoluteTime v13;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  const char *v19;
  char *v20;
  os_log_type_t type;
  int v22[2];
  const char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  const char *v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD **)(a1 + 32);
  if (*v8 != a4)
  {
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Current = CFAbsoluteTimeGetCurrent();
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 96) = CFDateCreate(v9, Current);
    v8 = *(_QWORD **)(a1 + 32);
  }
  *v8 = a4;
  v11 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v11 + 72) = a4;
  if (a5 && !*(_BYTE *)(v11 + 120))
  {
    *(_QWORD *)(v11 + 104) = a4;
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v13 = CFAbsoluteTimeGetCurrent();
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 112) = CFDateCreate(v12, v13);
    *(_BYTE *)(*(_QWORD *)(a1 + 40) + 120) = 1;
  }
  if (dword_1EE141E28)
  {
    v22[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E20, 1, v22, &type);
    v15 = v22[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v17 = v15;
    else
      v17 = v15 & 0xFFFFFFFE;
    if (v17)
    {
      v18 = *(_QWORD *)(a1 + 40);
      v19 = "could not";
      v23 = "figProcessStateMonitorHandleEnrollInPurge_block_invoke";
      v22[1] = 136315906;
      v24 = 2114;
      if (!a5)
        v19 = "did";
      v25 = v18;
      v26 = 2048;
      v27 = a4;
      v28 = 2080;
      v29 = v19;
      v20 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v15) = v22[0];
    }
    else
    {
      v20 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E20, 1u, 1, v20, v20 != &v30, v15, 0, v16);
  }
  FigMemoryBarrier();
}

double FigProcessStateMonitorPurgePreventionAssertion_Init(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void FigProcessStateMonitorPurgePreventionAssertion_Finalize(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  const void *v4;
  const void *v5;

  if (!*(_BYTE *)(a1 + 16))
  {
    figProcessStateMonitorMayPurgeClientObjects(*(_QWORD *)(a1 + 32), *(const void **)(a1 + 24));
    *(_BYTE *)(a1 + 16) = 1;
  }
  v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *(NSObject **)(a1 + 40);
    if (v3)
      dispatch_release(v3);
  }
  v4 = *(const void **)(a1 + 24);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 32);
  if (v5)
    CFRelease(v5);
}

__CFString *FigProcessStateMonitorPurgePreventionAssertion_CopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  __CFString *v4;
  const char *v5;
  const char *v6;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = Mutable;
  v5 = "Yes";
  if (*(_QWORD *)(a1 + 40))
    v6 = "Yes";
  else
    v6 = "No";
  if (!*(_BYTE *)(a1 + 16))
    v5 = "No";
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigProcessStateMonitorPurgePreventionAssertion %p hasTimeout:%s didPurge:%s>"), a1, v6, v5);
  return v4;
}

CFTypeID CMFormatDescriptionGetTypeID(void)
{
  FigThreadRunOnce(&CMFormatDescriptionGetTypeID_sRegisterFigFormatDescriptionOnce, (void (*)(void))registerFigFormatDescription);
  return sFigFormatDescriptionID;
}

Boolean CMFormatDescriptionEqual(CMFormatDescriptionRef formatDescription, CMFormatDescriptionRef otherFormatDescription)
{
  if (formatDescription && otherFormatDescription)
    return CFEqual(formatDescription, otherFormatDescription);
  else
    return formatDescription == otherFormatDescription;
}

Boolean CMFormatDescriptionEqualIgnoringExtensionKeys(CMFormatDescriptionRef formatDescription, CMFormatDescriptionRef otherFormatDescription, CFTypeRef formatDescriptionExtensionKeysToIgnore, CFTypeRef sampleDescriptionExtensionAtomKeysToIgnore)
{
  if (formatDescription && otherFormatDescription)
    return figFormatDescriptionEqualIgnoringExtensionsKeys((uint64_t)formatDescription, (uint64_t)otherFormatDescription, (uint64_t)formatDescriptionExtensionKeysToIgnore, (uint64_t)sampleDescriptionExtensionAtomKeysToIgnore);
  else
    return formatDescription == otherFormatDescription;
}

uint64_t figFormatDescriptionEqualIgnoringExtensionsKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const void *v5;
  char *Value;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t);

  v5 = (const void *)*(unsigned int *)(a1 + 16);
  if ((_DWORD)v5 != *(_DWORD *)(a2 + 16) || *(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20))
    return 0;
  if ((_DWORD)v5)
  {
    Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, v5);
    if (Value
      || (Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)0x67656E72)) != 0)
    {
      v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(Value + 12);
      if (v10)
        return v10(a1, a2, a3, a4);
      return 0;
    }
  }
  return 1;
}

uint64_t FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(CFDictionaryRef theDict, const __CFDictionary *a2, unint64_t a3, unint64_t a4)
{
  const __CFAllocator *v8;
  __CFDictionary *MutableCopy;
  __CFDictionary *v10;
  CFTypeID TypeID;
  CFTypeID v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFDictionary *Value;
  __CFDictionary *v19;
  const __CFDictionary *v20;
  __CFDictionary *v21;
  CFTypeID v22;
  CFTypeID v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex j;
  const void *v27;
  uint64_t v28;

  if (a3 | a4)
  {
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], theDict);
    v10 = FigCFDictionaryCreateMutableCopy(v8, a2);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("VerbatimSampleDescription"));
    CFDictionaryRemoveValue(MutableCopy, CFSTR("VerbatimISOSampleEntry"));
    CFDictionaryRemoveValue(v10, CFSTR("VerbatimSampleDescription"));
    CFDictionaryRemoveValue(v10, CFSTR("VerbatimISOSampleEntry"));
    if (a3)
    {
      TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID((CFTypeRef)a3))
      {
        CFDictionaryRemoveValue(MutableCopy, (const void *)a3);
        CFDictionaryRemoveValue(v10, (const void *)a3);
      }
      else
      {
        v13 = CFArrayGetTypeID();
        if (v13 == CFGetTypeID((CFTypeRef)a3))
        {
          Count = CFArrayGetCount((CFArrayRef)a3);
          if (Count >= 1)
          {
            v15 = Count;
            for (i = 0; i != v15; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, i);
              CFDictionaryRemoveValue(MutableCopy, ValueAtIndex);
              CFDictionaryRemoveValue(v10, ValueAtIndex);
            }
          }
        }
      }
    }
    if (!a4)
      goto LABEL_24;
    Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("SampleDescriptionExtensionAtoms"));
    v19 = FigCFDictionaryCreateMutableCopy(v8, Value);
    v20 = (const __CFDictionary *)CFDictionaryGetValue(v10, CFSTR("SampleDescriptionExtensionAtoms"));
    v21 = FigCFDictionaryCreateMutableCopy(v8, v20);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("SampleDescriptionExtensionAtoms"));
    CFDictionaryRemoveValue(v10, CFSTR("SampleDescriptionExtensionAtoms"));
    v22 = CFStringGetTypeID();
    if (v22 == CFGetTypeID((CFTypeRef)a4))
    {
      CFDictionaryRemoveValue(v19, (const void *)a4);
      CFDictionaryRemoveValue(v21, (const void *)a4);
    }
    else
    {
      v23 = CFArrayGetTypeID();
      if (v23 == CFGetTypeID((CFTypeRef)a4))
      {
        v24 = CFArrayGetCount((CFArrayRef)a4);
        if (v24 >= 1)
        {
          v25 = v24;
          for (j = 0; j != v25; ++j)
          {
            v27 = CFArrayGetValueAtIndex((CFArrayRef)a4, j);
            CFDictionaryRemoveValue(v19, v27);
            CFDictionaryRemoveValue(v21, v27);
          }
        }
      }
    }
    v28 = FigCFEqual(v19, v21);
    if (v19)
      CFRelease(v19);
    if (v21)
      CFRelease(v21);
    if ((_DWORD)v28)
LABEL_24:
      v28 = FigCFEqual(MutableCopy, v10) != 0;
    if (MutableCopy)
      CFRelease(MutableCopy);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    if (FigCFDictionaryGetCount(theDict) || FigCFDictionaryGetCount(a2))
      return FigCFEqual(theDict, a2);
    return 1;
  }
  return v28;
}

CMMediaType CMFormatDescriptionGetMediaType(CMFormatDescriptionRef desc)
{
  if (desc)
    LODWORD(desc) = *((_DWORD *)desc + 4);
  return desc;
}

FourCharCode CMFormatDescriptionGetMediaSubType(CMFormatDescriptionRef desc)
{
  if (desc)
    LODWORD(desc) = *((_DWORD *)desc + 5);
  return desc;
}

CFDictionaryRef CMFormatDescriptionGetExtensions(CFDictionaryRef desc)
{
  if (desc)
    return (CFDictionaryRef)*((_QWORD *)desc + 3);
  return desc;
}

CFPropertyListRef CMFormatDescriptionGetExtension(CMFormatDescriptionRef desc, CFStringRef extensionKey)
{
  const __CFDictionary *v2;

  if (desc && (v2 = (const __CFDictionary *)*((_QWORD *)desc + 3)) != 0)
    return CFDictionaryGetValue(v2, extensionKey);
  else
    return 0;
}

OSStatus CMFormatDescriptionCreate(CFAllocatorRef allocator, CMMediaType mediaType, FourCharCode mediaSubType, CFDictionaryRef extensions, CMFormatDescriptionRef *formatDescriptionOut)
{
  void *v8;

  if (!formatDescriptionOut)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v8 = *(void **)&mediaType;
  FigThreadRunOnce(&sFigGenericFormatDescriptionRegisterOnce, (void (*)(void))FigGenericFormatDescriptionRegisterOnce);
  return FigDerivedFormatDescriptionCreate(allocator, v8, mediaSubType, extensions, (uint64_t *)formatDescriptionOut);
}

uint64_t figFormatDescriptionEqual(uint64_t a1, uint64_t a2)
{
  return figFormatDescriptionEqualIgnoringExtensionsKeys(a1, a2, 0, 0);
}

__CFString *figFormatDescriptionCopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  int v4;
  unsigned int v5;
  char *Value;
  uint64_t (*v7)(uint64_t);
  const void *v8;
  const void *v9;
  CFStringRef v10;
  const __CFString *v11;
  CFAllocatorRef v12;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 20);
  if (v4
    && ((Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)*(unsigned int *)(a1 + 16))) != 0|| (Value = (char *)CFDictionaryGetValue((CFDictionaryRef)sFigFormatDescriptionRegistry, (const void *)0x67656E72)) != 0)&& (v7 = *(uint64_t (**)(uint64_t))(Value + 20)) != 0)
  {
    v8 = (const void *)v7(a1);
  }
  else
  {
    v8 = 0;
  }
  v9 = *(const void **)(a1 + 24);
  if (v9)
    v10 = CFCopyDescription(v9);
  else
    v10 = 0;
  if (v4 <= 1885564003)
  {
    if (v4 <= 1668310897)
    {
      if (v4 == 1635088502)
      {
        v11 = CFSTR("AuxiliaryPicture");
        goto LABEL_38;
      }
      if (v4 == 1668047728)
      {
        v11 = CFSTR("ClosedCaption");
        goto LABEL_38;
      }
    }
    else
    {
      switch(v4)
      {
        case 1668310898:
          v11 = CFSTR("CaptionGroup");
          goto LABEL_38;
        case 1835365473:
          v11 = CFSTR("Metadata");
          goto LABEL_38;
        case 1836415096:
          v11 = CFSTR("Muxed");
          goto LABEL_38;
      }
    }
  }
  else if (v4 > 1936684397)
  {
    switch(v4)
    {
      case 1936684398:
        v11 = CFSTR("Audio");
        goto LABEL_38;
      case 1952807028:
        v11 = CFSTR("Text");
        goto LABEL_38;
      case 1986618469:
        v11 = CFSTR("Video");
        goto LABEL_38;
    }
  }
  else
  {
    switch(v4)
    {
      case 1885564004:
        v11 = CFSTR("PointCloud");
        goto LABEL_38;
      case 1935832172:
        v11 = CFSTR("Subtitle");
        goto LABEL_38;
      case 1935893870:
        v11 = CFSTR("Scene");
        goto LABEL_38;
    }
  }
  if (v4 == 1952606066)
    v11 = CFSTR("TaggedBufferGroup");
  else
    v11 = &stru_1E28E82E0;
LABEL_38:
  v12 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CM%@FormatDescription %p [%p]> {\n\tmediaType:'%c%c%c%c' \n\tmediaSubType:'%c%c%c%c' \n\tmediaSpecific: {\n%@ \n\t} \n\textensions: {%@}\n}"), v11, a1, v12, HIBYTE(v4), BYTE2(v4), BYTE1(v4), v4, HIBYTE(v5), BYTE2(v5), BYTE1(v5), v5, v8, v10);
  if (v8)
    CFRelease(v8);
  if (v10)
    CFRelease(v10);
  return Mutable;
}

void myCFDictionaryReleaseCallBack(uint64_t a1, void *a2)
{
  CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
}

uint64_t FigGenericFormatDescriptionRegisterOnce()
{
  __int128 v1[2];
  int v2;

  memset(v1, 0, sizeof(v1));
  v2 = 0;
  *(_QWORD *)((char *)v1 + 12) = figGenericFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x67656E72u, v1);
}

uint64_t figGenericFormatDescriptionEqual(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  return FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(*(CFDictionaryRef *)(a1 + 24), *(const __CFDictionary **)(a2 + 24), a3, a4);
}

uint64_t FigMuxedFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigMuxedFormatDescriptionRegisterOnce, (void (*)(void))FigMuxedFormatDescriptionRegisterOnce);
}

uint64_t FigMuxedFormatDescriptionRegisterOnce()
{
  int v1;
  uint64_t v2;
  BOOL (*v3)(uint64_t, uint64_t);
  __CFString *(*v4)(const void *);
  uint64_t (*v5)();

  v1 = 0;
  v2 = 4;
  v4 = figMuxedFormatDescriptionCopyDebugDesc;
  v5 = figMuxedFormatDescriptionFinalize;
  v3 = figMuxedFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x6D757878u, (__int128 *)&v1);
}

OSStatus CMMuxedFormatDescriptionCreate(CFAllocatorRef allocator, CMMuxedStreamType muxType, CFDictionaryRef extensions, CMMuxedFormatDescriptionRef *formatDescriptionOut)
{
  OSStatus v8;
  const opaqueCMFormatDescription *v9;
  CFTypeRef cf;

  cf = 0;
  if (muxType && formatDescriptionOut)
  {
    FigThreadRunOnce(&sFigMuxedFormatDescriptionRegisterOnce, (void (*)(void))FigMuxedFormatDescriptionRegisterOnce);
    v8 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x6D757878, muxType, extensions, (uint64_t *)&cf);
    v9 = (const opaqueCMFormatDescription *)cf;
    if (v8)
    {
      if (cf)
      {
        CFRelease(cf);
        v9 = 0;
      }
    }
    else
    {
      *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf) = muxType;
      v9 = (const opaqueCMFormatDescription *)cf;
    }
  }
  else
  {
    v8 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    v9 = 0;
    if (!formatDescriptionOut)
      return v8;
  }
  *formatDescriptionOut = v9;
  return v8;
}

__CFString *figMuxedFormatDescriptionCopyDebugDesc(const void *a1)
{
  _DWORD *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;

  DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("\t\tmuxType: '%c%c%c%c'"), HIBYTE(*DerivedStorage), BYTE2(*DerivedStorage), BYTE1(*DerivedStorage), *DerivedStorage);
  return Mutable;
}

BOOL figMuxedFormatDescriptionEqual(uint64_t a1, uint64_t a2)
{
  _DWORD *DerivedStorage;

  DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage(a1);
  return *DerivedStorage == *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage(a2);
}

uint64_t FigVideoFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigVideoFormatDescriptionRegisterOnce, (void (*)(void))FigVideoFormatDescriptionRegisterOnce);
}

OSStatus CMVideoFormatDescriptionCreate(CFAllocatorRef allocator, CMVideoCodecType codecType, int32_t width, int32_t height, CFDictionaryRef extensions, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  OSStatus v12;
  const opaqueCMFormatDescription *v13;
  _DWORD *DerivedStorage;
  CFTypeRef cf;

  cf = 0;
  if (!formatDescriptionOut)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  if (!codecType)
  {
    v12 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  FigThreadRunOnce(&sFigVideoFormatDescriptionRegisterOnce, (void (*)(void))FigVideoFormatDescriptionRegisterOnce);
  v12 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x76696465, codecType, extensions, (uint64_t *)&cf);
  v13 = (const opaqueCMFormatDescription *)cf;
  if (!v12)
  {
    DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
    *DerivedStorage = codecType;
    DerivedStorage[1] = width;
    DerivedStorage[2] = height;
    v13 = (const opaqueCMFormatDescription *)cf;
    goto LABEL_10;
  }
  if (cf)
  {
    CFRelease(cf);
LABEL_8:
    v13 = 0;
  }
LABEL_10:
  *formatDescriptionOut = v13;
  return v12;
}

OSStatus CMVideoFormatDescriptionCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  CFIndex Count;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v8;
  CFTypeID v9;
  CFAllocatorRef *v10;
  OSType PixelFormatType;
  int32_t Width;
  int32_t Height;
  CFNumberRef v14;
  CFNumberRef v15;
  uint64_t v17;
  OSStatus v18;
  CGSize EncodedSize;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFTypeRef v22;
  const void *v23;
  CFNumberRef v24;
  int32_t v25;
  int32_t v26;
  CMVideoCodecType codecType;
  int valuePtr;
  CMVideoFormatDescriptionRef formatDescriptionOuta;

  formatDescriptionOuta = 0;
  if (!formatDescriptionOut)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  if (imageBuffer)
  {
    FigThreadRunOnce(&sFigVideoFormatDescriptionRegisterOnce, (void (*)(void))FigVideoFormatDescriptionRegisterOnce);
    FigThreadRunOnce(&sFigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce, (void (*)(void))FigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce);
    Count = CFArrayGetCount((CFArrayRef)sExtensionKeysCommonWithImageBuffers);
    Mutable = CFDictionaryCreateMutable(allocator, Count + 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v8 = Mutable;
      v9 = CFGetTypeID(imageBuffer);
      if (CVPixelBufferGetTypeID() == v9)
      {
        v10 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
        PixelFormatType = CVPixelBufferGetPixelFormatType(imageBuffer);
        Width = CVPixelBufferGetWidth(imageBuffer);
        Height = CVPixelBufferGetHeight(imageBuffer);
        valuePtr = CVPixelBufferGetBytesPerRow(imageBuffer);
        v14 = CFNumberCreate(*v10, kCFNumberSInt32Type, &valuePtr);
        if (!v14)
        {
          v18 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_27:
          CFRelease(v8);
          goto LABEL_28;
        }
        v15 = v14;
        v25 = Height;
        v26 = Width;
        codecType = PixelFormatType;
        CFDictionarySetValue(v8, CFSTR("CVBytesPerRow"), v14);
      }
      else
      {
        EncodedSize = CVImageBufferGetEncodedSize(imageBuffer);
        codecType = 0;
        v15 = 0;
        v26 = (int)(EncodedSize.width + 0.5);
        v25 = (int)(EncodedSize.height + 0.5);
      }
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)sExtensionKeysCommonWithImageBuffers, i);
          v22 = CVBufferCopyAttachment(imageBuffer, ValueAtIndex, 0);
          if (v22)
          {
            v23 = v22;
            CFDictionarySetValue(v8, ValueAtIndex, v22);
            CFRelease(v23);
          }
        }
      }
      valuePtr = 2;
      v24 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
      if (v24)
      {
        CFDictionarySetValue(v8, CFSTR("Version"), v24);
        v18 = CMVideoFormatDescriptionCreate(allocator, codecType, v26, v25, v8, &formatDescriptionOuta);
        if (v18 && formatDescriptionOuta)
        {
          CFRelease(formatDescriptionOuta);
          formatDescriptionOuta = 0;
        }
      }
      else
      {
        v18 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      }
      if (v15)
        CFRelease(v15);
      if (v24)
        CFRelease(v24);
      goto LABEL_27;
    }
    v17 = 4294954585;
  }
  else
  {
    v17 = 4294954586;
  }
  v18 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
LABEL_28:
  *formatDescriptionOut = formatDescriptionOuta;
  return v18;
}

CMVideoDimensions CMVideoFormatDescriptionGetDimensions(CMVideoFormatDescriptionRef videoDesc)
{
  uint64_t DerivedStorage;
  uint64_t v3;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)videoDesc);
  if (DerivedStorage && (v3 = DerivedStorage, CMFormatDescriptionGetMediaType(videoDesc) == 1986618469))
  {
    return *(CMVideoDimensions *)(v3 + 4);
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return (CMVideoDimensions)0;
  }
}

uint64_t CMPointCloudFormatDescriptionGetNumberOfPoints(const opaqueCMFormatDescription *a1)
{
  CFDictionaryRef Extensions;
  unsigned int v3;

  v3 = 0;
  Extensions = CMFormatDescriptionGetExtensions(a1);
  FigCFDictionaryGetInt32IfPresent((uint64_t)Extensions, CFSTR("NumberOfPointsPerSample"), &v3);
  return v3;
}

CGRect CMVideoFormatDescriptionGetCleanAperture(CMVideoFormatDescriptionRef videoDesc, Boolean originIsAtTopLeft)
{
  int v2;
  CMVideoDimensions Dimensions;
  double width;
  double height;
  CFPropertyListRef Extension;
  double v8;
  const void *v9;
  CFTypeID TypeID;
  const __CFNumber *Value;
  const __CFNumber *v12;
  CFTypeID v13;
  const __CFNumber *v14;
  const __CFNumber *v15;
  CFTypeID v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  CFTypeID v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  CFTypeID v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double valuePtr;
  CGRect result;

  v2 = originIsAtTopLeft;
  Dimensions = CMVideoFormatDescriptionGetDimensions(videoDesc);
  width = (double)Dimensions.width;
  height = (double)Dimensions.height;
  Extension = CMFormatDescriptionGetExtension(videoDesc, (CFStringRef)*MEMORY[0x1E0CA8D50]);
  v8 = 0.0;
  if (!Extension)
    goto LABEL_20;
  v9 = Extension;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v9))
    goto LABEL_20;
  v32 = 0.0;
  valuePtr = 0.0;
  v30 = 0.0;
  v31 = 0.0;
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v9, (const void *)*MEMORY[0x1E0CA8D60]);
  if (Value)
  {
    v12 = Value;
    v13 = CFNumberGetTypeID();
    if (v13 == CFGetTypeID(v12))
      CFNumberGetValue(v12, kCFNumberCGFloatType, &valuePtr);
  }
  v14 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v9, (const void *)*MEMORY[0x1E0CA8D40]);
  if (v14)
  {
    v15 = v14;
    v16 = CFNumberGetTypeID();
    if (v16 == CFGetTypeID(v15))
      CFNumberGetValue(v15, kCFNumberCGFloatType, &v32);
  }
  v17 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v9, (const void *)*MEMORY[0x1E0CA8D48]);
  if (v17)
  {
    v18 = v17;
    v19 = CFNumberGetTypeID();
    if (v19 == CFGetTypeID(v18))
      CFNumberGetValue(v18, kCFNumberCGFloatType, &v31);
  }
  v20 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v9, (const void *)*MEMORY[0x1E0CA8D58]);
  if (v20)
  {
    v21 = v20;
    v22 = CFNumberGetTypeID();
    if (v22 == CFGetTypeID(v21))
      CFNumberGetValue(v21, kCFNumberCGFloatType, &v30);
  }
  if (valuePtr <= width
    && valuePtr > 0.0
    && v32 > 0.0
    && v32 <= height
    && (v23 = (width - valuePtr) * 0.5, fabs(v31) <= v23))
  {
    v28 = (height - v32) * 0.5;
    v24 = 0.0;
    if (fabs(v30) <= v28)
    {
      v24 = v23 + v31;
      v29 = -v30;
      if (v2)
        v29 = v30;
      v8 = v28 + v29;
      width = valuePtr;
      height = v32;
    }
  }
  else
  {
LABEL_20:
    v24 = 0.0;
  }
  v25 = v8;
  v26 = width;
  v27 = height;
  result.size.height = v27;
  result.size.width = v26;
  result.origin.y = v25;
  result.origin.x = v24;
  return result;
}

CGSize CMVideoFormatDescriptionGetPresentationDimensions(CMVideoFormatDescriptionRef videoDesc, Boolean usePixelAspectRatio, Boolean useCleanAperture)
{
  int v3;
  int v4;
  CMVideoDimensions Dimensions;
  double width;
  double height;
  const __CFDictionary *Extension;
  const __CFDictionary *v10;
  CFTypeID TypeID;
  const __CFNumber *Value;
  const __CFNumber *v13;
  CFTypeID v14;
  const __CFNumber *v15;
  double v16;
  const __CFNumber *v17;
  CFTypeID v18;
  _BOOL4 v19;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  CFTypeID v22;
  const __CFNumber *v23;
  const __CFNumber *v24;
  CFTypeID v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  CFTypeID v28;
  double v29;
  double v30;
  double v31;
  double valuePtr;
  CGSize result;

  v3 = useCleanAperture;
  v4 = usePixelAspectRatio;
  Dimensions = CMVideoFormatDescriptionGetDimensions(videoDesc);
  width = (double)Dimensions.width;
  height = (double)Dimensions.height;
  if (v3)
  {
    Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, (CFStringRef)*MEMORY[0x1E0CA8D50]);
    if (Extension)
    {
      v10 = Extension;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v10))
      {
        v31 = 0.0;
        valuePtr = 0.0;
        Value = (const __CFNumber *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x1E0CA8D60]);
        if (Value)
        {
          v13 = Value;
          v14 = CFNumberGetTypeID();
          if (v14 == CFGetTypeID(v13))
            CFNumberGetValue(v13, kCFNumberCGFloatType, &valuePtr);
        }
        v15 = (const __CFNumber *)CFDictionaryGetValue(v10, (const void *)*MEMORY[0x1E0CA8D40]);
        v16 = 0.0;
        if (v15)
        {
          v17 = v15;
          v18 = CFNumberGetTypeID();
          if (v18 == CFGetTypeID(v17))
          {
            CFNumberGetValue(v17, kCFNumberCGFloatType, &v31);
            v16 = v31;
          }
        }
        v19 = valuePtr <= 0.0;
        if (v16 <= 0.0)
          v19 = 1;
        if (valuePtr > width)
          v19 = 1;
        if (v16 > height)
          v19 = 1;
        if (!v19)
        {
          height = v16;
          width = valuePtr;
        }
      }
    }
  }
  if (v4)
  {
    v20 = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, (CFStringRef)*MEMORY[0x1E0CA8E68]);
    if (v20)
    {
      v21 = v20;
      v22 = CFDictionaryGetTypeID();
      if (v22 == CFGetTypeID(v21))
      {
        v31 = 0.0;
        valuePtr = 0.0;
        v23 = (const __CFNumber *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x1E0CA8E60]);
        if (v23)
        {
          v24 = v23;
          v25 = CFNumberGetTypeID();
          if (v25 == CFGetTypeID(v24))
            CFNumberGetValue(v24, kCFNumberDoubleType, &valuePtr);
        }
        v26 = (const __CFNumber *)CFDictionaryGetValue(v21, (const void *)*MEMORY[0x1E0CA8E70]);
        if (v26)
        {
          v27 = v26;
          v28 = CFNumberGetTypeID();
          if (v28 == CFGetTypeID(v27))
          {
            CFNumberGetValue(v27, kCFNumberDoubleType, &v31);
            if (valuePtr > 0.0 && v31 > 0.0)
              width = width * (valuePtr / v31);
          }
        }
      }
    }
  }
  v29 = width;
  v30 = height;
  result.height = v30;
  result.width = v29;
  return result;
}

CFArrayRef CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers(void)
{
  FigThreadRunOnce(&sFigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce, (void (*)(void))FigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce);
  return (CFArrayRef)sExtensionKeysCommonWithImageBuffers;
}

Boolean CMVideoFormatDescriptionMatchesImageBuffer(CMVideoFormatDescriptionRef desc, CVImageBufferRef imageBuffer)
{
  CFTypeID v4;
  OSType PixelFormatType;
  int Width;
  int Height;
  const __CFNumber *Extension;
  const __CFNumber *v9;
  CFTypeID v10;
  int BytesPerRow;
  uint64_t v12;
  Boolean result;
  CGSize EncodedSize;
  CMVideoDimensions Dimensions;
  FourCharCode MediaSubType;
  const __CFArray *v18;
  CFIndex Count;
  uint64_t v20;
  CFDictionaryRef Extensions;
  const __CFDictionary *v22;
  CFIndex v23;
  const __CFString *ValueAtIndex;
  unint64_t Value;
  unint64_t v26;
  const void *v27;
  CFIndex i;
  const __CFString *v29;
  CFTypeRef v30;
  int valuePtr;

  if (!desc || !imageBuffer)
  {
    v12 = 4294954586;
    goto LABEL_9;
  }
  v4 = CFGetTypeID(imageBuffer);
  if (CVPixelBufferGetTypeID() == v4)
  {
    valuePtr = 0;
    PixelFormatType = CVPixelBufferGetPixelFormatType(imageBuffer);
    Width = CVPixelBufferGetWidth(imageBuffer);
    Height = CVPixelBufferGetHeight(imageBuffer);
    Extension = (const __CFNumber *)CMFormatDescriptionGetExtension(desc, CFSTR("CVBytesPerRow"));
    if (Extension)
    {
      v9 = Extension;
      v10 = CFGetTypeID(Extension);
      if (v10 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
        BytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);
        if (valuePtr != BytesPerRow)
          return 0;
      }
    }
  }
  else
  {
    EncodedSize = CVImageBufferGetEncodedSize(imageBuffer);
    PixelFormatType = 0;
    Width = (int)(EncodedSize.width + 0.5);
    Height = (int)(EncodedSize.height + 0.5);
  }
  Dimensions = CMVideoFormatDescriptionGetDimensions(desc);
  MediaSubType = CMFormatDescriptionGetMediaSubType(desc);
  result = 0;
  if (MediaSubType == PixelFormatType && Width == Dimensions.width && Height == Dimensions.height)
  {
    FigThreadRunOnce(&sFigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce, (void (*)(void))FigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce);
    v18 = (const __CFArray *)sExtensionKeysCommonWithImageBuffers;
    Count = CFArrayGetCount((CFArrayRef)sExtensionKeysCommonWithImageBuffers);
    if (v18)
    {
      v20 = Count;
      Extensions = CMFormatDescriptionGetExtensions(desc);
      if (Extensions)
      {
        if (v20 >= 1)
        {
          v22 = Extensions;
          v23 = 0;
          while (1)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, v23);
            Value = (unint64_t)CFDictionaryGetValue(v22, ValueAtIndex);
            v26 = (unint64_t)CVBufferCopyAttachment(imageBuffer, ValueAtIndex, 0);
            if (Value | v26)
            {
              v27 = (const void *)v26;
              if (!Value || !v26)
              {
                if (!v26)
                  return 0;
LABEL_38:
                v30 = v27;
LABEL_39:
                CFRelease(v30);
                return 0;
              }
              if (!CFEqual((CFTypeRef)Value, (CFTypeRef)v26))
                goto LABEL_38;
              CFRelease(v27);
            }
            ++v23;
            result = 1;
            if (v20 == v23)
              return result;
          }
        }
      }
      else if (v20 >= 1)
      {
        for (i = 0; i != v20; ++i)
        {
          v29 = (const __CFString *)CFArrayGetValueAtIndex(v18, i);
          v30 = CVBufferCopyAttachment(imageBuffer, v29, 0);
          if (v30)
            goto LABEL_39;
          result = 1;
        }
        return result;
      }
      return 1;
    }
    v12 = 4294954585;
LABEL_9:
    FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

BOOL FigVideoFormatDescriptionContainsWideColor(const opaqueCMFormatDescription *a1)
{
  CFPropertyListRef Extension;
  CFPropertyListRef v3;
  CFPropertyListRef v5;

  if (CMFormatDescriptionGetMediaType(a1) != 1986618469)
    return 0;
  Extension = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E0CA8D68]);
  if (FigCFEqual(Extension, CFSTR("DCI_P3")))
    return 1;
  if (FigCFEqual(Extension, CFSTR("P3_D65")))
    return 1;
  if (FigCFEqual(Extension, CFSTR("ITU_R_2020")))
    return 1;
  v3 = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E0CA8E98]);
  if (FigCFEqual(v3, CFSTR("aYCC")) || FigCFEqual(v3, CFSTR("ITU_R_2020")))
    return 1;
  v5 = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E0CA8EE8]);
  return FigCFEqual(v5, CFSTR("ITU_R_2020")) != 0;
}

BOOL FigVideoFormatDescriptionContainsHDR(const opaqueCMFormatDescription *a1)
{
  signed int MediaSubType;
  CFPropertyListRef Extension;
  _BOOL8 result;
  unsigned __int16 v5;
  int v6;

  if (!a1 || CMFormatDescriptionGetMediaType(a1) != 1986618469)
    return 0;
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  Extension = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E0CA8E98]);
  result = 1;
  if (MediaSubType <= 1685481520)
  {
    if (MediaSubType <= 1667524656)
    {
      if (MediaSubType == 1634759272)
        return result;
      v6 = 1634759278;
LABEL_18:
      if (MediaSubType == v6)
        return result;
      return FigCFEqual(Extension, CFSTR("ITU_R_2100_HLG"))
          || FigCFEqual(Extension, CFSTR("SMPTE_ST_2084_PQ"));
    }
    if (MediaSubType != 1667524657 && MediaSubType != 1684108849)
    {
      v6 = 1684895096;
      goto LABEL_18;
    }
  }
  else if (MediaSubType > 1902405680)
  {
    if (MediaSubType != 1902405681 && MediaSubType != 1902405733)
    {
      v5 = 28024;
      goto LABEL_15;
    }
  }
  else if (MediaSubType != 1685481521 && MediaSubType != 1685481573)
  {
    v5 = 24950;
LABEL_15:
    v6 = v5 | 0x71640000;
    goto LABEL_18;
  }
  return result;
}

uint64_t CMFormatDescriptionGetWidestGamutAndLargestDynamicRangeColorPropertiesFromFormatDescriptions(const __CFArray *a1, int a2, int a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  const __CFArray *v11;
  CFTypeID v12;
  CFIndex v13;
  unsigned int v14;
  unsigned int v15;
  const __CFString *v16;
  const __CFString *v17;
  const opaqueCMFormatDescription *ValueAtIndex;
  const opaqueCMFormatDescription *v19;
  CFTypeID v20;
  CFPropertyListRef Extension;
  unsigned int v22;
  CFPropertyListRef v23;
  CFPropertyListRef v24;
  CFPropertyListRef v25;
  unsigned int v26;
  const void *v28;
  const void *v29;
  const void *v30;
  CFTypeID v31;
  CFTypeID v32;
  CFTypeID v33;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  int v38;
  int v39;
  CFPropertyListRef v40;
  CFPropertyListRef v41;
  CFPropertyListRef v42;
  const __CFArray *v43;
  CFIndex Count;
  const __CFString *v45;

  if (a1)
  {
    v11 = a1;
    v12 = CFGetTypeID(a1);
    if (v12 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount(v11);
      if (Count > 0 && a4 && a5 && a6)
      {
        v38 = a3;
        v39 = a2;
        v35 = a4;
        v36 = a5;
        v37 = a6;
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v40 = 0;
        v41 = 0;
        v42 = 0;
        v16 = (const __CFString *)*MEMORY[0x1E0CA8E98];
        v45 = (const __CFString *)*MEMORY[0x1E0CA8D68];
        v17 = (const __CFString *)*MEMORY[0x1E0CA8EE8];
        v43 = v11;
        while (1)
        {
          ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(v11, v13);
          if (!ValueAtIndex)
            break;
          v19 = ValueAtIndex;
          v20 = CFGetTypeID(ValueAtIndex);
          if (v20 != CMFormatDescriptionGetTypeID())
            break;
          Extension = CMFormatDescriptionGetExtension(v19, v16);
          if (FigCFEqual(Extension, CFSTR("SMPTE_ST_2084_PQ")))
          {
            v22 = 2;
          }
          else if (FigCFEqual(Extension, CFSTR("ITU_R_2100_HLG")))
          {
            v22 = 3;
          }
          else
          {
            v22 = 1;
          }
          v23 = CMFormatDescriptionGetExtension(v19, v45);
          v24 = CMFormatDescriptionGetExtension(v19, v16);
          v25 = CMFormatDescriptionGetExtension(v19, v17);
          if (FigCFEqual(v23, CFSTR("DCI_P3")) || FigCFEqual(v23, CFSTR("P3_D65")))
          {
            v26 = 2;
          }
          else if (FigCFEqual(v23, CFSTR("ITU_R_2020"))
                 || !v23
                 && (FigCFEqual(v24, CFSTR("ITU_R_2100_HLG"))
                  || FigCFEqual(v24, CFSTR("SMPTE_ST_2084_PQ"))
                  || FigCFEqual(v24, CFSTR("aYCC"))
                  || FigCFEqual(v25, CFSTR("ITU_R_2020"))))
          {
            v26 = 3;
          }
          else
          {
            v26 = 1;
          }
          v11 = v43;
          if (v22 > v15)
          {
            v40 = CMFormatDescriptionGetExtension(v19, v16);
            v15 = v22;
          }
          if (v26 > v14)
          {
            v42 = CMFormatDescriptionGetExtension(v19, v45);
            v41 = CMFormatDescriptionGetExtension(v19, v17);
            v14 = v26;
          }
          if (Count == ++v13)
          {
            if (v15 > 1 && v38 == 0)
              v28 = (const void *)*MEMORY[0x1E0CA8EB0];
            else
              v28 = v40;
            if (v39 == 0 && v14 > 1)
              v29 = (const void *)*MEMORY[0x1E0CA8D88];
            else
              v29 = v42;
            if (v39 == 0 && v14 > 1)
              v30 = (const void *)*MEMORY[0x1E0CA8F18];
            else
              v30 = v41;
            if (v29)
            {
              v31 = CFGetTypeID(v29);
              if (v31 == CFStringGetTypeID())
              {
                if (v28)
                {
                  v32 = CFGetTypeID(v28);
                  if (v32 == CFStringGetTypeID())
                  {
                    if (v30)
                    {
                      v33 = CFGetTypeID(v30);
                      if (v33 == CFStringGetTypeID())
                      {
                        *v35 = v29;
                        *v36 = v28;
                        *v37 = v30;
                      }
                    }
                  }
                }
              }
            }
            return 0;
          }
        }
      }
    }
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

uint64_t CMFormatDescriptionGetWidestColorPropertiesFromFormatDescriptions(const void *a1, int a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  CFTypeID v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  CFPropertyListRef v14;
  CFPropertyListRef v15;
  CFPropertyListRef v16;
  const __CFString *v17;
  const void *v18;
  const opaqueCMFormatDescription *ValueAtIndex;
  const opaqueCMFormatDescription *v20;
  CFTypeID v21;
  CFPropertyListRef Extension;
  CFTypeID v23;
  CFTypeID v24;
  CFTypeID v25;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  int v30;
  const __CFString *extensionKey;
  const __CFString *v32;

  if (a1)
  {
    v10 = CFGetTypeID(a1);
    if (v10 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount((CFArrayRef)a1);
      if (Count > 0 && a3 && a4 && a5)
      {
        v12 = Count;
        v30 = a2;
        v27 = a3;
        v28 = a4;
        v29 = a5;
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v17 = (const __CFString *)*MEMORY[0x1E0CA8D68];
        v18 = (const void *)*MEMORY[0x1E0CA8D88];
        extensionKey = (const __CFString *)*MEMORY[0x1E0CA8E98];
        v32 = (const __CFString *)*MEMORY[0x1E0CA8EE8];
        while (1)
        {
          ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex((CFArrayRef)a1, v13);
          if (!ValueAtIndex)
            return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
          v20 = ValueAtIndex;
          v21 = CFGetTypeID(ValueAtIndex);
          if (v21 != CMFormatDescriptionGetTypeID())
            return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
          Extension = CMFormatDescriptionGetExtension(v20, v17);
          if (FigVideoFormatDescriptionContainsWideColor(v20))
            break;
          if (FigCFEqual(Extension, v18) || !v16 && !v15 && !v14)
          {
            v15 = CMFormatDescriptionGetExtension(v20, extensionKey);
            v14 = CMFormatDescriptionGetExtension(v20, v32);
            v16 = Extension;
          }
          if (v12 == ++v13)
            goto LABEL_20;
        }
        if (v30)
        {
          v16 = CMFormatDescriptionGetExtension(v20, v17);
          v15 = CMFormatDescriptionGetExtension(v20, extensionKey);
          v14 = CMFormatDescriptionGetExtension(v20, v32);
LABEL_20:
          if (v16)
            goto LABEL_21;
        }
        else
        {
          v15 = (CFPropertyListRef)*MEMORY[0x1E0CA8EB0];
          v14 = (CFPropertyListRef)*MEMORY[0x1E0CA8F18];
          v16 = v18;
          if (v18)
          {
LABEL_21:
            v23 = CFGetTypeID(v16);
            if (v23 == CFStringGetTypeID())
            {
              if (v15)
              {
                v24 = CFGetTypeID(v15);
                if (v24 == CFStringGetTypeID())
                {
                  if (v14)
                  {
                    v25 = CFGetTypeID(v14);
                    if (v25 == CFStringGetTypeID())
                    {
                      *v27 = v16;
                      *v28 = v15;
                      *v29 = v14;
                    }
                  }
                }
              }
            }
          }
        }
        return 0;
      }
    }
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

BOOL FigVideoFormatDescriptionContainsAlphaChannel(const opaqueCMFormatDescription *a1)
{
  return CMFormatDescriptionGetMediaType(a1) == 1986618469
      && CMFormatDescriptionGetExtension(a1, CFSTR("ContainsAlphaChannel")) == (CFPropertyListRef)*MEMORY[0x1E0C9AE50];
}

BOOL FigVideoFormatDescriptionContainsStereoMultiviewVideo(const opaqueCMFormatDescription *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  CFIndex v5;
  const void *ValueAtIndex;
  int v7;
  BOOL v8;
  int v9;
  CFIndex v10;
  const void *v11;
  int v12;
  int v13;
  BOOL v15;
  CFArrayRef tagCollectionsOut;

  tagCollectionsOut = 0;
  if (CMFormatDescriptionGetMediaType(a1) != 1986618469 && CMFormatDescriptionGetMediaType(a1) != 1635088502)
    return 0;
  CMVideoFormatDescriptionCopyTagCollectionArray(a1, &tagCollectionsOut);
  if (tagCollectionsOut)
  {
    Count = CFArrayGetCount(tagCollectionsOut);
    v3 = Count - 1;
    if (Count < 1)
    {
      v9 = 0;
LABEL_16:
      v13 = 0;
    }
    else
    {
      v4 = Count;
      v5 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(tagCollectionsOut, v5);
        v7 = FigTagCollectionContainsTag(ValueAtIndex, *(_QWORD *)"seye\a", 1);
        if (v7)
          v8 = 1;
        else
          v8 = v3 == v5;
        ++v5;
      }
      while (!v8);
      v9 = v7;
      v10 = 0;
      while (1)
      {
        v11 = CFArrayGetValueAtIndex(tagCollectionsOut, v10);
        v12 = FigTagCollectionContainsTag(v11, *(_QWORD *)"seye\a", 2);
        if (v12)
          break;
        if (v4 == ++v10)
          goto LABEL_16;
      }
      v13 = v12;
    }
    if (tagCollectionsOut)
      CFRelease(tagCollectionsOut);
  }
  else
  {
    v13 = 0;
    v9 = 0;
  }
  if (v13)
    v15 = v9 == 0;
  else
    v15 = 1;
  return !v15;
}

BOOL FigVideoFormatDescriptionGetMVHEVCVideoLayerIDs(const opaqueCMFormatDescription *a1, uint64_t *a2, uint64_t *a3)
{
  signed int MediaSubType;
  int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  const OpaqueCMTagCollection *ValueAtIndex;
  BOOL v15;
  CFIndex v16;
  const OpaqueCMTagCollection *v17;
  BOOL v18;
  BOOL v19;
  CMItemCount v21;
  CMTag tagBuffer;
  CFArrayRef tagCollectionsOut;

  tagCollectionsOut = 0;
  if (CMFormatDescriptionGetMediaType(a1) != 1986618469 && CMFormatDescriptionGetMediaType(a1) != 1635088502)
    goto LABEL_44;
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  v7 = 0;
  if (MediaSubType > 1836415072)
  {
    if (MediaSubType > 1902407031)
    {
      if (MediaSubType > 1902671458)
      {
        if (MediaSubType == 1902998904)
          goto LABEL_28;
        v9 = 30307;
      }
      else
      {
        if (MediaSubType == 1902407032)
          goto LABEL_28;
        v9 = 25974;
      }
      v8 = v9 | 0x71680000;
    }
    else if (MediaSubType > 1902405680)
    {
      if (MediaSubType == 1902405681)
        goto LABEL_28;
      v8 = 1902405733;
    }
    else
    {
      if (MediaSubType == 1836415073)
        goto LABEL_28;
      v8 = 1869117027;
    }
  }
  else if (MediaSubType > 1685481572)
  {
    if (MediaSubType > 1751479856)
    {
      if (MediaSubType == 1751479857)
        goto LABEL_28;
      v8 = 1752589105;
    }
    else
    {
      if (MediaSubType == 1685481573)
        goto LABEL_28;
      v8 = 1718908520;
    }
  }
  else if (MediaSubType > 1684895095)
  {
    if (MediaSubType == 1684895096)
      goto LABEL_28;
    v8 = 1685481521;
  }
  else
  {
    if (MediaSubType == 1667524657)
      goto LABEL_28;
    v8 = 1667790435;
  }
  v10 = 0;
  if (MediaSubType != v8)
    goto LABEL_52;
LABEL_28:
  CMVideoFormatDescriptionCopyTagCollectionArray(a1, &tagCollectionsOut);
  if (!tagCollectionsOut)
  {
    v10 = 0;
    v7 = 0;
    goto LABEL_54;
  }
  Count = CFArrayGetCount(tagCollectionsOut);
  if (Count >= 1)
  {
    v12 = Count;
    v13 = 0;
    while (1)
    {
      ValueAtIndex = (const OpaqueCMTagCollection *)CFArrayGetValueAtIndex(tagCollectionsOut, v13);
      if (FigTagCollectionContainsTag(ValueAtIndex, *(_QWORD *)"seye\a", 1))
        break;
      if (v12 == ++v13)
      {
        v7 = 0;
        goto LABEL_40;
      }
    }
    *(_QWORD *)&tagBuffer.category = 0;
    tagBuffer.value = 0;
    v21 = 0;
    if (FigTagCollectionGetTagsWithCategory(ValueAtIndex, 1986814329, &tagBuffer, 1, &v21))
      v15 = 0;
    else
      v15 = v21 == 1;
    if (!v15)
      goto LABEL_44;
    *a2 = FigTagGetSInt64Value(*(uint64_t *)&tagBuffer.category, tagBuffer.value);
    v7 = 1;
LABEL_40:
    v16 = 0;
    while (1)
    {
      v17 = (const OpaqueCMTagCollection *)CFArrayGetValueAtIndex(tagCollectionsOut, v16);
      if (FigTagCollectionContainsTag(v17, *(_QWORD *)"seye\a", 2))
        break;
      if (v12 == ++v16)
        goto LABEL_45;
    }
    *(_QWORD *)&tagBuffer.category = 0;
    tagBuffer.value = 0;
    v21 = 0;
    if (FigTagCollectionGetTagsWithCategory(v17, 1986814329, &tagBuffer, 1, &v21))
      v18 = 0;
    else
      v18 = v21 == 1;
    if (v18)
    {
      *a3 = FigTagGetSInt64Value(*(uint64_t *)&tagBuffer.category, tagBuffer.value);
      v10 = 1;
      goto LABEL_52;
    }
    goto LABEL_45;
  }
LABEL_44:
  v7 = 0;
LABEL_45:
  v10 = 0;
LABEL_52:
  if (tagCollectionsOut)
    CFRelease(tagCollectionsOut);
LABEL_54:
  if (v10)
    v19 = v7 == 0;
  else
    v19 = 1;
  return !v19;
}

uint64_t FigVideoCreateBlockBufferAndFormatDescriptionForHoistingInStreamParameterSets(const opaqueCMFormatDescription *a1, OpaqueCMBlockBuffer *a2, unint64_t a3, _QWORD *a4)
{
  signed int MediaSubType;
  signed int v9;
  int v10;
  int v11;
  CMVideoDimensions Dimensions;
  size_t DataLength;
  unint64_t v14;
  size_t v15;
  const __CFAllocator *v16;
  uint64_t appended;
  uint64_t v18;
  int v19;
  int v20;
  size_t v21;
  size_t v22;
  size_t v25;
  size_t v26;
  uint8_t *v27;
  _BYTE *v28;
  uint64_t v29;
  char v30;
  CMVideoCodecType v31;
  const __CFAllocator *v32;
  const __CFDictionary *Extensions;
  const __CFDictionary *MutableCopy;
  const __CFDictionary *Value;
  uint64_t v36;
  uint64_t v37;
  CFNumberRef v38;
  const __CFDictionary *v39;
  const __CFDictionary *v40;
  const __CFDictionary *v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  uint8_t **v45;
  void *v46;
  _QWORD *v48;
  int32_t width[2];
  _QWORD *v50;
  int v51;
  const __CFAllocator *v52;
  const opaqueCMFormatDescription *desc;
  const __CFAllocator *blockAllocator;
  unsigned __int8 v55;
  unsigned __int8 v56;
  unsigned int destination;
  signed int valuePtr;
  CMFormatDescriptionRef formatDescriptionOut;
  CMBlockBufferRef blockBufferOut;
  size_t parameterSetSizes[2];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint8_t *parameterSetPointers[2];
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  formatDescriptionOut = 0;
  blockBufferOut = 0;
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  *(_OWORD *)parameterSetPointers = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v68 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  *(_OWORD *)parameterSetSizes = 0u;
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  v9 = MediaSubType;
  valuePtr = MediaSubType;
  v10 = 1;
  if (MediaSubType > 1836415072)
  {
    if (MediaSubType > 1902407031)
    {
      if (MediaSubType > 1902671458)
      {
        if (MediaSubType == 1902671459)
          goto LABEL_26;
        v11 = 1902998904;
      }
      else
      {
        if (MediaSubType == 1902407032)
          goto LABEL_26;
        v11 = 1902667126;
      }
    }
    else if (MediaSubType > 1902405680)
    {
      if (MediaSubType == 1902405681)
        goto LABEL_26;
      v11 = 1902405733;
    }
    else
    {
      if (MediaSubType == 1836415073)
        goto LABEL_26;
      v11 = 1869117027;
    }
LABEL_24:
    if (MediaSubType != v11)
      v10 = 0;
    goto LABEL_26;
  }
  if (MediaSubType > 1685481572)
  {
    if (MediaSubType > 1751479856)
    {
      if (MediaSubType == 1751479857)
        goto LABEL_26;
      v11 = 1752589105;
    }
    else
    {
      if (MediaSubType == 1685481573)
        goto LABEL_26;
      v11 = 1718908520;
    }
    goto LABEL_24;
  }
  if (MediaSubType > 1684895095)
  {
    if (MediaSubType == 1684895096)
      goto LABEL_26;
    v11 = 1685481521;
    goto LABEL_24;
  }
  if (MediaSubType != 1667524657)
  {
    v11 = 1667790435;
    goto LABEL_24;
  }
LABEL_26:
  Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  if (!a1)
    goto LABEL_128;
  if (!a3)
  {
    v37 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    MutableCopy = 0;
    a2 = 0;
    goto LABEL_130;
  }
  if (!a2)
  {
    v37 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    MutableCopy = 0;
    goto LABEL_132;
  }
  if (!a4)
  {
LABEL_128:
    v37 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    MutableCopy = 0;
    a2 = 0;
LABEL_132:
    v38 = 0;
    a3 = 0;
    goto LABEL_105;
  }
  v51 = v9;
  v48 = (_QWORD *)a3;
  *(CMVideoDimensions *)width = Dimensions;
  desc = a1;
  *(_QWORD *)a3 = 0;
  v50 = a4;
  *a4 = 0;
  DataLength = CMBlockBufferGetDataLength(a2);
  if (!DataLength)
  {
    a3 = 0;
LABEL_74:
    if (v51 <= 1751479856)
    {
      if (v51 == 1635148595)
      {
        v31 = 1635148593;
        goto LABEL_86;
      }
      if (v51 == 1685481573)
      {
        v31 = 1685481521;
        goto LABEL_86;
      }
    }
    else
    {
      switch(v51)
      {
        case 1751479857:
          v31 = 1752589105;
          goto LABEL_86;
        case 1902405733:
          v31 = 1902405681;
          goto LABEL_86;
        case 1902667126:
          v31 = 1902671459;
          goto LABEL_86;
      }
    }
    v31 = v51;
LABEL_86:
    if (a3)
    {
      v32 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Extensions = CMFormatDescriptionGetExtensions(a1);
      MutableCopy = FigCFDictionaryCreateMutableCopy(v32, Extensions);
      Value = (const __CFDictionary *)CFDictionaryGetValue(MutableCopy, CFSTR("SampleDescriptionExtensionAtoms"));
      a2 = FigCFDictionaryCreateMutableCopy(v32, Value);
      if (v10)
      {
        v36 = FigVideoFormatDescriptionCreateUpdatedFromHEVCParameterSets(v32, a1, a3, (uint64_t)parameterSetPointers, (uint64_t)parameterSetSizes, 4u, &formatDescriptionOut);
        if ((_DWORD)v36)
        {
LABEL_89:
          v37 = v36;
LABEL_130:
          v38 = 0;
          goto LABEL_105;
        }
      }
      else
      {
        v36 = CMVideoFormatDescriptionCreateFromH264ParameterSets(v32, a3, (const uint8_t *const *)parameterSetPointers, parameterSetSizes, 4, &formatDescriptionOut);
        if ((_DWORD)v36)
          goto LABEL_89;
      }
      v39 = CMFormatDescriptionGetExtensions(formatDescriptionOut);
      v40 = (const __CFDictionary *)CFDictionaryGetValue(v39, CFSTR("SampleDescriptionExtensionAtoms"));
      CFDictionaryApplyFunction(v39, (CFDictionaryApplierFunction)sFigTransferDictionaryValues, MutableCopy);
      CFDictionaryApplyFunction(v40, (CFDictionaryApplierFunction)sFigTransferDictionaryValues, a2);
      CFDictionarySetValue(MutableCopy, CFSTR("SampleDescriptionExtensionAtoms"), a2);
      CFDictionaryRemoveValue(MutableCopy, CFSTR("VerbatimISOSampleEntry"));
      CFDictionaryRemoveValue(MutableCopy, CFSTR("VerbatimSampleDescription"));
      if (v31 == valuePtr)
      {
        v38 = 0;
      }
      else
      {
        v38 = CFNumberCreate(v32, kCFNumberSInt32Type, &valuePtr);
        CFDictionarySetValue(MutableCopy, CFSTR("OriginalCodec"), v38);
      }
      if (formatDescriptionOut)
      {
        CFRelease(formatDescriptionOut);
        formatDescriptionOut = 0;
      }
    }
    else
    {
      if (v31 == v51)
      {
        v38 = 0;
        a2 = 0;
        MutableCopy = 0;
LABEL_100:
        v43 = blockBufferOut;
        if (blockBufferOut)
          v43 = (void *)CFRetain(blockBufferOut);
        *v50 = v43;
        if (formatDescriptionOut && !CMFormatDescriptionEqual(desc, formatDescriptionOut))
        {
          v37 = 0;
          v28 = 0;
          *v48 = FigFormatDescriptionRetain(formatDescriptionOut);
          goto LABEL_111;
        }
        v37 = 0;
LABEL_105:
        v28 = 0;
        goto LABEL_111;
      }
      v32 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v41 = CMFormatDescriptionGetExtensions(a1);
      MutableCopy = FigCFDictionaryCreateMutableCopy(v32, v41);
      v38 = CFNumberCreate(v32, kCFNumberSInt32Type, &valuePtr);
      CFDictionarySetValue(MutableCopy, CFSTR("OriginalCodec"), v38);
      a2 = 0;
    }
    v42 = CMVideoFormatDescriptionCreate(v32, v31, width[0], width[1], MutableCopy, &formatDescriptionOut);
    if ((_DWORD)v42)
    {
      v37 = v42;
      goto LABEL_105;
    }
    goto LABEL_100;
  }
  v14 = DataLength;
  a3 = 0;
  v15 = 0;
  v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  blockAllocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE10];
  v52 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    destination = 0;
    v56 = 0;
    if (v15 + 5 > v14)
      goto LABEL_107;
    appended = CMBlockBufferCopyDataBytes(a2, v15, 4uLL, &destination);
    if ((_DWORD)appended)
      goto LABEL_109;
    v18 = bswap32(destination);
    destination = v18;
    if (v15 + 4 + v18 > v14)
    {
LABEL_107:
      v44 = 4294954554;
      goto LABEL_108;
    }
    appended = CMBlockBufferCopyDataBytes(a2, v15 + 4, 1uLL, &v56);
    if ((_DWORD)appended)
      goto LABEL_109;
    if (v10)
    {
      v19 = (v56 >> 1) & 0x3F;
      v56 = (v56 >> 1) & 0x3F;
      if ((v19 - 32) >= 3)
      {
        if (v19 == 39)
        {
          v20 = 0;
          v21 = v15 + 4 + destination;
          v55 = 0;
          v22 = v15 + 7;
          while (1)
          {
            appended = CMBlockBufferCopyDataBytes(a2, v22 - 1, 1uLL, &v55);
            if ((_DWORD)appended)
              goto LABEL_109;
            v20 += v55;
            if (v55 != 255 || v22++ >= v21)
            {
              if ((v20 - 137) <= 0xA && ((1 << (v20 + 119)) & 0x481) != 0)
              {
                v16 = v52;
                goto LABEL_52;
              }
              v16 = v52;
              break;
            }
          }
        }
LABEL_69:
        if (blockBufferOut)
        {
          appended = CMBlockBufferAppendBufferReference(blockBufferOut, a2, v15, destination + 4, 0);
          if ((_DWORD)appended)
            goto LABEL_109;
        }
        goto LABEL_71;
      }
    }
    else
    {
      v56 &= 0x1Fu;
      if (v56 - 7 >= 2)
        goto LABEL_69;
    }
LABEL_52:
    v25 = destination + 4;
    if (v25 <= 6)
      goto LABEL_107;
    if (!blockBufferOut)
    {
      if (v15)
      {
        appended = CMBlockBufferCreateWithBufferReference(v16, a2, 0, v15, 0, &blockBufferOut);
        if ((_DWORD)appended)
          goto LABEL_109;
      }
      else
      {
        appended = CMBlockBufferCreateEmpty(v16, 0, 0, &blockBufferOut);
        if ((_DWORD)appended)
          goto LABEL_109;
      }
    }
    if (a3 >= 0x14)
      goto LABEL_107;
    v26 = destination;
    parameterSetSizes[a3] = destination;
    v27 = (uint8_t *)malloc_type_malloc(v26, 0x1F49BFCEuLL);
    parameterSetPointers[a3] = v27;
    if (!v27)
    {
      v44 = 4294954510;
LABEL_108:
      appended = FigSignalErrorAt(v44, 0, 0, 0, 0, 0, 0);
LABEL_109:
      v37 = appended;
      v28 = 0;
      goto LABEL_110;
    }
    appended = CMBlockBufferCopyDataBytes(a2, v15 + 4, destination, v27);
    if ((_DWORD)appended)
      goto LABEL_109;
    v28 = malloc_type_malloc(v25, 0x700140E0uLL);
    if (!v28)
      break;
    v29 = CMBlockBufferCopyDataBytes(a2, v15, 4uLL, v28);
    if ((_DWORD)v29)
      goto LABEL_127;
    memset(v28 + 5, 255, v25 - 6);
    if (v10)
    {
      v28[5] = 1;
      v30 = 76;
    }
    else
    {
      v30 = 12;
    }
    v28[4] = v30;
    v28[v25 - 1] = 0x80;
    appended = CMBlockBufferAppendMemoryBlock(blockBufferOut, v28, v25, blockAllocator, 0, 0, v25, 0);
    if ((_DWORD)appended)
      goto LABEL_109;
    ++a3;
LABEL_71:
    v15 += destination + 4;
    if (v15 >= v14)
      goto LABEL_74;
  }
  v29 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_127:
  v37 = v29;
LABEL_110:
  MutableCopy = 0;
  a2 = 0;
  v38 = 0;
LABEL_111:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (formatDescriptionOut)
    CFRelease(formatDescriptionOut);
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (a2)
    CFRelease(a2);
  if (v38)
    CFRelease(v38);
  if (a3)
  {
    v45 = parameterSetPointers;
    do
    {
      v46 = *v45++;
      free(v46);
      --a3;
    }
    while (a3);
  }
  free(v28);
  return v37;
}

void sFigTransferDictionaryValues(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile84(const opaqueCMFormatDescription *a1)
{
  int DolbyVisionProfileAndCompatibilityIDIfGiven;
  _BOOL8 result;
  __int16 v3;

  v3 = 0;
  DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (_BYTE *)&v3 + 1, &v3);
  result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 8)
      return v3 == 4;
  }
  return result;
}

uint64_t sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(const opaqueCMFormatDescription *a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t result;
  const __CFDictionary *v6;
  CFTypeID v7;
  const __CFData *Value;
  const __CFData *v9;
  const UInt8 *BytePtr;
  int v11;
  int v12;
  const __CFData *v13;

  result = (uint64_t)CMFormatDescriptionGetExtension(a1, CFSTR("SampleDescriptionExtensionAtoms"));
  if (result)
  {
    v6 = (const __CFDictionary *)result;
    v7 = CFGetTypeID((CFTypeRef)result);
    if (v7 != CFDictionaryGetTypeID())
      return 0;
    Value = (const __CFData *)CFDictionaryGetValue(v6, CFSTR("dvvC"));
    if (Value)
    {
      v9 = Value;
      BytePtr = CFDataGetBytePtr(Value);
      if (CFDataGetLength(v9) <= 8)
      {
LABEL_13:
        FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
        return 0;
      }
      v11 = *BytePtr;
      v12 = BytePtr[1];
    }
    else
    {
      result = (uint64_t)CFDictionaryGetValue(v6, CFSTR("dvcC"));
      if (!result)
        return result;
      v13 = (const __CFData *)result;
      BytePtr = CFDataGetBytePtr((CFDataRef)result);
      if (CFDataGetLength(v13) <= 8)
        goto LABEL_13;
      v12 = BytePtr[1];
      v11 = *BytePtr & 0xFD;
    }
    if (v11 != 1 || v12 != 0)
      goto LABEL_13;
    if (a2)
      *a2 = BytePtr[2] >> 1;
    if (a3)
      *a3 = BytePtr[4] >> 4;
    return 1;
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile81(const opaqueCMFormatDescription *a1)
{
  int DolbyVisionProfileAndCompatibilityIDIfGiven;
  _BOOL8 result;
  __int16 v3;

  v3 = 0;
  DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (_BYTE *)&v3 + 1, &v3);
  result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 8)
      return v3 == 1;
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile10p0(const opaqueCMFormatDescription *a1)
{
  int DolbyVisionProfileAndCompatibilityIDIfGiven;
  _BOOL8 result;
  __int16 v3;

  v3 = 0;
  DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (_BYTE *)&v3 + 1, &v3);
  result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 10)
      return (_BYTE)v3 == 0;
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile10p1(const opaqueCMFormatDescription *a1)
{
  int DolbyVisionProfileAndCompatibilityIDIfGiven;
  _BOOL8 result;
  __int16 v3;

  v3 = 0;
  DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (_BYTE *)&v3 + 1, &v3);
  result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 10)
      return v3 == 1;
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile10p4(const opaqueCMFormatDescription *a1)
{
  int DolbyVisionProfileAndCompatibilityIDIfGiven;
  _BOOL8 result;
  __int16 v3;

  v3 = 0;
  DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (_BYTE *)&v3 + 1, &v3);
  result = 0;
  if (DolbyVisionProfileAndCompatibilityIDIfGiven)
  {
    if (HIBYTE(v3) == 10)
      return v3 == 4;
  }
  return result;
}

BOOL FigVideoFormatDescriptionConformsToDolbyVisionProfile10(const opaqueCMFormatDescription *a1)
{
  return FigVideoFormatDescriptionConformsToDolbyVisionProfile10p0(a1)
      || FigVideoFormatDescriptionConformsToDolbyVisionProfile10p1(a1)
      || FigVideoFormatDescriptionConformsToDolbyVisionProfile10p4(a1);
}

uint64_t CMVideoFormatDescriptionGetVideoDynamicRange(const opaqueCMFormatDescription *a1)
{
  FourCharCode MediaSubType;
  int v3;
  uint64_t result;
  int v5;
  int v6;
  int DolbyVisionProfileAndCompatibilityIDIfGiven;
  CFPropertyListRef Extension;
  int v10;
  int v11;
  int v12;
  BOOL v13;
  unsigned int v14;
  __int16 v15;

  v15 = 0;
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  if (!a1)
    return 0;
  v3 = MediaSubType;
  result = 6;
  if (v3 > 1685481572)
  {
    if (v3 > 1902405680)
    {
      if (v3 != 1902405681 && v3 != 1902407032)
      {
        v5 = 1902405733;
        goto LABEL_16;
      }
LABEL_17:
      DolbyVisionProfileAndCompatibilityIDIfGiven = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (_BYTE *)&v15 + 1, &v15);
      if (HIBYTE(v15) != 20 || DolbyVisionProfileAndCompatibilityIDIfGiven == 0)
        return 5;
      else
        return 10;
    }
    if (v3 == 1685481573)
      goto LABEL_17;
    v6 = 1902403958;
LABEL_12:
    if (v3 == v6)
      return result;
    goto LABEL_24;
  }
  if (v3 <= 1684895095)
  {
    if (v3 == 1667524657)
      goto LABEL_17;
    v6 = 1684108849;
    goto LABEL_12;
  }
  if (v3 == 1684895096)
    goto LABEL_17;
  v5 = 1685481521;
LABEL_16:
  if (v3 == v5)
    goto LABEL_17;
LABEL_24:
  Extension = CMFormatDescriptionGetExtension(a1, (CFStringRef)*MEMORY[0x1E0CA8E98]);
  if (FigCFEqual(Extension, CFSTR("SMPTE_ST_2084_PQ")))
  {
    v10 = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (_BYTE *)&v15 + 1, &v15);
    result = 4;
    if (!v10 || v15 != 1)
      return result;
    if (HIBYTE(v15) != 10)
    {
      if (HIBYTE(v15) != 8)
        return result;
      if (v3 <= 1836415072)
      {
        if (v3 > 1751479856)
        {
          if (v3 == 1751479857)
            return 8;
          v11 = 1752589105;
        }
        else
        {
          if (v3 == 1667790435)
            return 8;
          v11 = 1718908520;
        }
      }
      else if (v3 <= 1902667125)
      {
        if (v3 == 1836415073)
          return 8;
        v11 = 1869117027;
      }
      else
      {
        if (v3 == 1902667126 || v3 == 1902998904)
          return 8;
        v11 = 1902671459;
      }
      if (v3 != v11)
        return result;
      return 8;
    }
    v13 = v3 == 1902212657 || v3 == 1635135537;
    v14 = 9;
LABEL_60:
    if (v13)
      return v14;
    else
      return result;
  }
  if (FigCFEqual(Extension, CFSTR("ITU_R_2100_HLG")))
  {
    v12 = sFigGetDolbyVisionProfileAndCompatibilityIDIfGiven(a1, (_BYTE *)&v15 + 1, &v15);
    result = 2;
    if (!v12 || v15 != 4)
      return result;
    if (HIBYTE(v15) == 10)
    {
      v13 = v3 == 1902212657 || v3 == 1635135537;
      v14 = 7;
      goto LABEL_60;
    }
    if (HIBYTE(v15) == 8)
    {
      if (FigVideoCodecTypeIsHEVCFlavor(v3))
        return 3;
      else
        return 2;
    }
  }
  else
  {
    return !Extension
        || FigCFEqual(Extension, CFSTR("ITU_R_2020"))
        || FigCFEqual(Extension, CFSTR("SMPTE_ST_428_1"))
        || FigCFEqual(Extension, (CFTypeRef)*MEMORY[0x1E0CA8EB0])
        || FigCFEqual(Extension, (CFTypeRef)*MEMORY[0x1E0CA8EC0])
        || FigCFEqual(Extension, (CFTypeRef)*MEMORY[0x1E0CA8ED8])
        || FigCFEqual(Extension, CFSTR("IEC_sRGB")) != 0;
  }
  return result;
}

uint64_t FigVideoCodecTypeIsHEVCFlavor(int a1)
{
  uint64_t result;
  int v3;

  result = 1;
  if (a1 <= 1836415072)
  {
    if (a1 > 1751479856)
    {
      if (a1 == 1751479857)
        return result;
      v3 = 1752589105;
    }
    else
    {
      if (a1 == 1667790435)
        return result;
      v3 = 1718908520;
    }
    goto LABEL_13;
  }
  if (a1 <= 1902667125)
  {
    if (a1 == 1836415073)
      return result;
    v3 = 1869117027;
    goto LABEL_13;
  }
  if (a1 != 1902667126 && a1 != 1902671459)
  {
    v3 = 1902998904;
LABEL_13:
    if (a1 != v3)
      return 0;
  }
  return result;
}

uint64_t CMVideoFormatDescriptionGetPlaintextMediaSubTypeAndEncryptionScheme(const opaqueCMFormatDescription *a1, _DWORD *a2, int *a3)
{
  int v3;
  signed int MediaSubType;
  unsigned __int16 v8;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  uint64_t result;
  int v13;
  int v14;

  v3 = 1852796517;
  v13 = 1852796517;
  if (!a1 || CMFormatDescriptionGetMediaType(a1) != 1986618469)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  v14 = MediaSubType;
  if (MediaSubType <= 1902207794)
  {
    if (MediaSubType <= 1685220712)
    {
      if (MediaSubType > 1667524656)
      {
        if (MediaSubType <= 1667656802)
        {
          if (MediaSubType == 1667524657 || MediaSubType == 1667574579)
            goto LABEL_84;
          v10 = 1667575091;
        }
        else
        {
          if (MediaSubType <= 1668047202)
          {
            if (MediaSubType != 1667656803)
            {
              v10 = 1667790435;
              goto LABEL_83;
            }
            goto LABEL_84;
          }
          if (MediaSubType == 1668047203)
            goto LABEL_84;
          v10 = 1668641633;
        }
      }
      else
      {
        if (MediaSubType <= 1667326823)
        {
          if (MediaSubType == 1633771875 || MediaSubType == 1667312947)
            goto LABEL_84;
          v8 = 24931;
        }
        else if (MediaSubType > 1667330146)
        {
          if (MediaSubType == 1667330147)
            goto LABEL_84;
          v8 = 30307;
        }
        else
        {
          if (MediaSubType == 1667326824)
            goto LABEL_84;
          v8 = 25456;
        }
        v10 = v8 | 0x63610000;
      }
LABEL_83:
      if (MediaSubType != v10)
        goto LABEL_88;
      goto LABEL_84;
    }
    if (MediaSubType <= 1885430578)
    {
      if (MediaSubType <= 1701733237)
      {
        if (MediaSubType == 1685220713 || MediaSubType == 1700886115)
          goto LABEL_84;
        v10 = 1701733217;
      }
      else
      {
        if (MediaSubType <= 1882599479)
        {
          if (MediaSubType != 1701733238)
          {
            v10 = 1869117027;
            goto LABEL_83;
          }
          goto LABEL_84;
        }
        if (MediaSubType == 1882599480)
          goto LABEL_84;
        v10 = 1885430115;
      }
      goto LABEL_83;
    }
    if (MediaSubType <= 1885547314)
    {
      if ((MediaSubType - 1885430579) > 0x3D
        || ((1 << (MediaSubType - 51)) & 0x2020000000000001) == 0)
      {
        goto LABEL_88;
      }
      goto LABEL_84;
    }
    if (MediaSubType <= 1886745440)
    {
      if (MediaSubType != 1885547315)
      {
        v10 = 1885692723;
        goto LABEL_83;
      }
      goto LABEL_84;
    }
    if (MediaSubType == 1886745441)
      goto LABEL_84;
    v9 = 24931;
LABEL_80:
    v10 = v9 | 0x71610000;
    goto LABEL_83;
  }
  if (MediaSubType <= 1902667125)
  {
    if (MediaSubType > 1902324530)
    {
      if (MediaSubType <= 1902405732)
      {
        if (MediaSubType == 1902324531 || MediaSubType == 1902403958)
          goto LABEL_84;
        v11 = 26673;
      }
      else
      {
        if (MediaSubType > 1902469938)
        {
          if (MediaSubType == 1902469939)
            goto LABEL_84;
          v10 = 1902537827;
          goto LABEL_83;
        }
        if (MediaSubType == 1902405733)
          goto LABEL_84;
        v11 = 28024;
      }
      v10 = v11 | 0x71640000;
      goto LABEL_83;
    }
    if ((MediaSubType - 1902207795) <= 0x3D
      && ((1 << (MediaSubType - 51)) & 0x2020000000000001) != 0
      || (MediaSubType - 1902212657) <= 0x34
      && ((1 << (MediaSubType - 49)) & 0x14000000000001) != 0)
    {
      goto LABEL_84;
    }
    v9 = 28771;
    goto LABEL_80;
  }
  if (MediaSubType <= 2053202738)
  {
    if (MediaSubType <= 1902998903)
    {
      if (MediaSubType == 1902667126 || MediaSubType == 1902671459)
        goto LABEL_84;
      v10 = 1902928227;
    }
    else
    {
      if (MediaSubType <= 1903587384)
      {
        if (MediaSubType != 1902998904)
        {
          v10 = 1903522657;
          goto LABEL_83;
        }
        goto LABEL_84;
      }
      if (MediaSubType == 1903587385)
        goto LABEL_84;
      v10 = 2053202275;
    }
    goto LABEL_83;
  }
  if (MediaSubType <= 2053319474)
  {
    if ((MediaSubType - 2053202739) > 0x3D
      || ((1 << (MediaSubType - 51)) & 0x2020000000000001) == 0)
    {
      if (MediaSubType == 2053207651)
      {
        v14 = 1635148593;
        v3 = 2053467747;
      }
      goto LABEL_88;
    }
    goto LABEL_84;
  }
  if (MediaSubType > 2053923170)
  {
    if (MediaSubType == 2053923171)
      goto LABEL_84;
    v10 = 2054517601;
    goto LABEL_83;
  }
  if (MediaSubType != 2053319475)
  {
    v10 = 2053464883;
    goto LABEL_83;
  }
LABEL_84:
  result = FigBridge_GetPlaintextMediaSubTypeAndEncryptionSchemeFromProtectedCodecType(MediaSubType, &v14, &v13);
  if ((_DWORD)result)
    return result;
  if (v13 == 1667392306)
    v3 = 1667392371;
  else
    v3 = v13;
LABEL_88:
  if (a2)
    *a2 = v14;
  result = 0;
  if (a3)
    *a3 = v3;
  return result;
}

__CFString *figVideoFormatDescriptionCopyDebugDesc(const void *a1)
{
  unsigned int *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;
  __CFString *v5;

  DerivedStorage = (unsigned int *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = Mutable;
  if (*DerivedStorage > 0xFF)
    CFStringAppendFormat(Mutable, 0, CFSTR("\t\tcodecType: '%c%c%c%c'"), HIBYTE(*DerivedStorage), BYTE2(*DerivedStorage), BYTE1(*DerivedStorage), *DerivedStorage);
  else
    CFStringAppendFormat(Mutable, 0, CFSTR("\t\tcodecType: %d"), *DerivedStorage);
  CFStringAppendFormat(v5, 0, CFSTR("\t\tdimensions: %d x %d"), DerivedStorage[1], DerivedStorage[2]);
  return v5;
}

BOOL figVideoFormatDescriptionEqual(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, unint64_t a3, unint64_t a4)
{
  _DWORD *DerivedStorage;
  const __CFDictionary *Extensions;
  _DWORD *v10;
  const __CFDictionary *v11;

  DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  Extensions = CMFormatDescriptionGetExtensions(a1);
  v10 = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a2);
  v11 = CMFormatDescriptionGetExtensions(a2);
  return *DerivedStorage == *v10
      && DerivedStorage[1] == v10[1]
      && DerivedStorage[2] == v10[2]
      && FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v11, a3, a4) != 0;
}

CFArrayRef FigVideoFormatDescriptionCreateKeysCommonWithImageBuffersOnce()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  CFArrayRef result;
  void *values[17];

  values[16] = *(void **)MEMORY[0x1E0C80C00];
  v0 = (void *)*MEMORY[0x1E0CA8DC8];
  values[0] = *(void **)MEMORY[0x1E0CA8D50];
  values[1] = v0;
  v1 = (void *)*MEMORY[0x1E0CA8E68];
  values[2] = *(void **)MEMORY[0x1E0CA8DD0];
  values[3] = v1;
  v2 = (void *)*MEMORY[0x1E0CA8E98];
  values[4] = *(void **)MEMORY[0x1E0CA8D68];
  values[5] = v2;
  v3 = (void *)*MEMORY[0x1E0CA8EE8];
  values[6] = *(void **)MEMORY[0x1E0CA8DF8];
  values[7] = v3;
  v4 = (void *)*MEMORY[0x1E0CA8CE8];
  values[8] = CFSTR("CVImageBufferICCProfile");
  values[9] = v4;
  values[10] = *(void **)MEMORY[0x1E0CA8CE0];
  values[11] = CFSTR("MasteringDisplayColorVolume");
  values[12] = CFSTR("ContentLightLevelInfo");
  values[13] = CFSTR("ContentColorVolume");
  values[14] = CFSTR("AmbientViewingEnvironment");
  values[15] = CFSTR("LogTransferFunction");
  result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)values, 16, MEMORY[0x1E0C9B378]);
  sExtensionKeysCommonWithImageBuffers = (uint64_t)result;
  return result;
}

void FigMobileAsset_RegisterForAssetUpdates(const void *a1, int a2, const __CFDictionary *a3, const void *a4, int a5, uint64_t a6, uint64_t a7)
{
  __CFArray *Mutable;
  _QWORD block[10];
  int v16;
  int v17;
  _QWORD value[2];

  if (figMobileAsset_Initialize_onceToken == -1)
  {
    if (!a6)
      return;
  }
  else
  {
    dispatch_once(&figMobileAsset_Initialize_onceToken, &__block_literal_global_7);
    if (!a6)
      return;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &FigMobileAssetCallbackCFArrayCallbacks);
  value[0] = a6;
  value[1] = a7;
  CFArrayAppendValue(Mutable, value);
  figMobileAsset_QueryMostRecentAsset(a1, 0, a2, 1, a3, a4, Mutable);
  if (a1)
    CFRetain(a1);
  if (a3)
    CFRetain(a3);
  if (a4)
    CFRetain(a4);
  if (Mutable)
    CFRetain(Mutable);
  if (figMobileAsset_GetNotificationQueue_onceToken != -1)
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_34);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __FigMobileAsset_RegisterForAssetUpdates_block_invoke;
  block[3] = &__block_descriptor_88_e5_v8__0l;
  block[4] = a1;
  block[5] = a3;
  block[6] = a4;
  block[7] = Mutable;
  v16 = a2;
  v17 = a5;
  block[8] = a6;
  block[9] = a7;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, block);
  if (Mutable)
    CFRelease(Mutable);
}

void figMobileAsset_QueryMostRecentAsset(const void *a1, int a2, int a3, int a4, const __CFDictionary *a5, const void *a6, const void *a7)
{
  uint64_t v7;
  uint64_t v8;
  void *v16;
  void *v17;
  uint64_t v18;
  _QWORD v19[9];
  int v20;
  int v21;
  char v22;
  uint64_t v23;
  uint64_t v24;

  if (a2 <= 1)
  {
    v23 = v7;
    v24 = v8;
    v16 = (void *)MEMORY[0x193FFC34C]();
    v17 = (void *)objc_msgSend(objc_alloc((Class)sMAAssetQueryClass), "initWithType:", a1);
    if (a5)
      CFDictionaryApplyFunction(a5, (CFDictionaryApplierFunction)figMobileAsset_AddFilterToQuery, v17);
    objc_msgSend(v17, "setDoNotBlockBeforeFirstUnlock:", 1);
    if (a4)
      v18 = 1;
    else
      v18 = 2;
    objc_msgSend(v17, "returnTypes:", v18);
    if (a1)
      CFRetain(a1);
    if (a5)
      CFRetain(a5);
    if (a6)
      CFRetain(a6);
    if (a7)
      CFRetain(a7);
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v19[2] = __figMobileAsset_QueryMostRecentAsset_block_invoke;
    v19[3] = &unk_1E28D8B70;
    v22 = a4;
    v19[4] = v17;
    v19[5] = a1;
    v19[6] = a5;
    v19[7] = a6;
    v19[8] = a7;
    v20 = a3;
    v21 = a2;
    objc_msgSend(v17, "queryMetaData:", v19);
    objc_autoreleasePoolPop(v16);
  }
}

BOOL figMobileAsset_IsAssetTypeRegistered(void *key)
{
  _BOOL8 result;

  if (figMobileAsset_Initialize_onceToken != -1)
    dispatch_once(&figMobileAsset_Initialize_onceToken, &__block_literal_global_7);
  result = 0;
  if (key)
  {
    if (gRegisteredAssetTypes)
      return CFDictionaryContainsKey((CFDictionaryRef)gRegisteredAssetTypes, key) != 0;
  }
  return result;
}

void figMobileAsset_DownloadCatalogAndRequery(CFTypeRef cf, int a2)
{
  _QWORD v4[5];
  int v5;

  if (cf)
    CFRetain(cf);
  if (figMobileAsset_GetNotificationQueue_onceToken != -1)
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_34);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __figMobileAsset_DownloadCatalogAndRequery_block_invoke;
  v4[3] = &__block_descriptor_44_e5_v8__0l;
  v4[4] = cf;
  v5 = a2;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, v4);
}

void FigMobileAsset_UnregisterFromAssetUpdates(CFTypeRef cf)
{
  _QWORD block[5];

  if (cf)
    CFRetain(cf);
  if (figMobileAsset_GetNotificationQueue_onceToken != -1)
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_34);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __FigMobileAsset_UnregisterFromAssetUpdates_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = cf;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, block);
}

void FigMobileAsset_UnregisterCallbackFromAssetUpdates(CFTypeRef cf, uint64_t a2, uint64_t a3)
{
  _QWORD block[7];

  if (cf)
    CFRetain(cf);
  if (figMobileAsset_GetNotificationQueue_onceToken != -1)
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_34);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __FigMobileAsset_UnregisterCallbackFromAssetUpdates_block_invoke;
  block[3] = &__block_descriptor_56_e5_v8__0l;
  block[4] = cf;
  block[5] = a2;
  block[6] = a3;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, block);
}

void FigMobileAsset_UpdateCatalogIfTimeIntervalElapsed(const void *a1)
{
  figMobileAsset_DownloadCatalogAndRequery(a1, 0);
}

__n128 figMobileAsset_CallbackArrayRetain(const __CFAllocator *a1, __n128 *a2)
{
  _OWORD *v3;
  __n128 result;

  v3 = CFAllocatorAllocate(a1, 16, 0);
  if (v3)
  {
    result = *a2;
    *v3 = *a2;
  }
  return result;
}

void figMobileAsset_CallbackArrayRelease(CFAllocatorRef allocator, void *ptr)
{
  if (ptr)
    CFAllocatorDeallocate(allocator, ptr);
}

CFTypeID figMobileAsset_AddFilterToQuery(CFTypeID result, CFTypeRef cf, void *a3)
{
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;

  if (result && cf && a3)
  {
    v5 = result;
    v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      return objc_msgSend(a3, "addKeyValuePair:with:", v5, cf);
    }
    else
    {
      v7 = CFGetTypeID(cf);
      result = CFArrayGetTypeID();
      if (v7 == result)
        return objc_msgSend(a3, "addKeyValueArray:with:", v5, cf);
    }
  }
  return result;
}

void figMobileAsset_UpdateLastUpdatedTime(CFTypeRef cf)
{
  _QWORD block[5];

  if (cf)
    CFRetain(cf);
  if (figMobileAsset_GetNotificationQueue_onceToken != -1)
    dispatch_once(&figMobileAsset_GetNotificationQueue_onceToken, &__block_literal_global_34);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __figMobileAsset_UpdateLastUpdatedTime_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = cf;
  dispatch_async((dispatch_queue_t)figMobileAsset_GetNotificationQueue_mobileAssetNotificationQueue, block);
}

void figMobileAsset_ExtractPlistFromAssetForCallback(void *a1, uint64_t a2, const __CFArray *a3)
{
  void *v5;
  void *v6;
  const void *v7;
  CFIndex v8;
  _QWORD *ValueAtIndex;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v11;
  uint64_t v12;
  unsigned int v13;
  char *v14;
  os_log_type_t type;
  int v16[2];
  const char *v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = (void *)objc_msgSend(a1, "getLocalFileUrl");
  if (v5)
  {
    v6 = v5;
    v7 = (const void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D20]), "initWithContentsOfURL:", objc_msgSend(v5, "URLByAppendingPathComponent:", a2));
    if (!v7)
      v7 = (const void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D80]), "initWithContentsOfURL:", objc_msgSend(v6, "URLByAppendingPathComponent:", a2));
    if (a3 && CFArrayGetCount(a3) >= 1)
    {
      v8 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a3, v8);
        if (*ValueAtIndex)
        {
          ((void (*)(const void *, _QWORD))*ValueAtIndex)(v7, ValueAtIndex[1]);
        }
        else
        {
          v16[0] = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141E60, 0, v16, &type);
          v11 = v16[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v13 = v11;
          else
            v13 = v11 & 0xFFFFFFFE;
          if (v13)
          {
            v16[1] = 136315138;
            v17 = "figMobileAsset_ExtractPlistFromAssetForCallback";
            v14 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v11) = v16[0];
          }
          else
          {
            v14 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141E60, 0, 1, v14, v14 != &v18, v11, 0, v12);
        }
        ++v8;
      }
      while (CFArrayGetCount(a3) > v8);
    }
    if (v7)
      CFRelease(v7);
  }
}

uint64_t FigNotificationCenterAddWeakListener(CFNotificationCenterRef center, void *observer, CFNotificationCallback callBack, CFStringRef name, unint64_t object, int a6, NSObject *a7)
{
  uint64_t v14;
  uint64_t v16;
  CFStringRef v17;
  CFStringRef v18;
  uint64_t Instance;
  uint64_t v20;
  CFTypeRef v21;
  uint64_t Key;
  int v23;
  void *observera;

  observera = 0;
  if ((a6 & 1) != 0 && !a7)
  {
    v14 = 4294954569;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  if (a7 || (a6 & 2) != 0)
  {
    v17 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("weak--%p--%p--%@--%p--listener"), observer, callBack, name, object);
    if (!v17)
    {
      v14 = 4294954570;
      return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    }
    v18 = v17;
    FigThreadRunOnce(&sFigNotificationCenterWeakListenerLinks, (void (*)(void))FigNotificationCenterWeakListenerLinksInitOnce);
    Instance = _CFRuntimeCreateInstance();
    if (!Instance)
    {
      v16 = FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
      goto LABEL_21;
    }
    v20 = Instance;
    v21 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)observer);
    *(_QWORD *)(v20 + 16) = v21;
    if (v21)
    {
      *(_QWORD *)(v20 + 24) = callBack;
      *(_DWORD *)(v20 + 48) = a6;
      if (a7)
      {
        dispatch_retain(a7);
        *(_QWORD *)(v20 + 40) = a7;
      }
      Key = FigCFWeakReferenceTableAddValueAndGetKey(qword_1ECDA81E0, v20, &observera);
      if (!(_DWORD)Key)
      {
        *(_QWORD *)(v20 + 32) = observera;
        FigSimpleMutexLock((pthread_mutex_t *)qword_1ECDA81E8);
        v23 = CFDictionaryContainsKey((CFDictionaryRef)qword_1ECDA81D8, v18);
        if (v23)
        {
          v16 = FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
          FigSimpleMutexUnlock((pthread_mutex_t *)qword_1ECDA81E8);
          if ((_DWORD)v16)
          {
LABEL_33:
            FigCFWeakReferenceTableRemoveValue(qword_1ECDA81E0, (uint64_t)observera);
            goto LABEL_20;
          }
          if (center)
            goto LABEL_17;
        }
        else
        {
          CFDictionarySetValue((CFMutableDictionaryRef)qword_1ECDA81D8, v18, (const void *)v20);
          FigSimpleMutexUnlock((pthread_mutex_t *)qword_1ECDA81E8);
          if (center)
          {
LABEL_17:
            if (observera)
            {
              if ((unint64_t)name | object)
              {
                CFNotificationCenterAddObserver(center, observera, (CFNotificationCallback)fncHandleWeakNotification, name, (const void *)object, (CFNotificationSuspensionBehavior)0);
                v16 = 0;
LABEL_20:
                CFRelease((CFTypeRef)v20);
LABEL_21:
                CFRelease(v18);
                return v16;
              }
              v16 = 4294954571;
            }
            else
            {
              v16 = 4294954573;
            }
            goto LABEL_31;
          }
        }
        v16 = 4294954575;
LABEL_31:
        if (!v23)
        {
          FigSimpleMutexLock((pthread_mutex_t *)qword_1ECDA81E8);
          CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_1ECDA81D8, v18);
          FigSimpleMutexUnlock((pthread_mutex_t *)qword_1ECDA81E8);
        }
        goto LABEL_33;
      }
    }
    else
    {
      Key = FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
    }
    v16 = Key;
    goto LABEL_20;
  }
  CFNotificationCenterAddObserver(center, observer, callBack, name, (const void *)object, (CFNotificationSuspensionBehavior)1024);
  return 0;
}

uint64_t CMNotificationCenterAddListener(__CFNotificationCenter *a1, const void *a2, void (__cdecl *a3)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef), const __CFString *a4, unint64_t a5)
{
  if (!a1)
    return 4294954575;
  if (!a3)
    return 4294954576;
  if (!a2)
    return 4294954573;
  if (!((unint64_t)a4 | a5))
    return 4294954571;
  CFNotificationCenterAddObserver(a1, a2, a3, a4, (const void *)a5, (CFNotificationSuspensionBehavior)0);
  return 0;
}

void fncHandleWeakNotification(const void *a1, void *a2, const void *a3, const void *a4, uint64_t a5)
{
  id **v9;
  uint64_t v10;
  NSObject *v11;

  v9 = (id **)FigCFWeakReferenceTableCopyValue(qword_1ECDA81E0, a2);
  if (!v9)
    return;
  v10 = (uint64_t)v9;
  if (!FigCFWeakReferenceHolderCopyReferencedObject(v9[2]))
  {
LABEL_9:
    CFRelease((CFTypeRef)v10);
    return;
  }
  v11 = *(NSObject **)(v10 + 40);
  if (!v11)
  {
    fncCallOriginalCallbackAndReleaseWeakListener(v10, (uint64_t)a1, (uint64_t)a3, (uint64_t)a4, a5);
    goto LABEL_9;
  }
  if ((*(_BYTE *)(v10 + 48) & 1) != 0)
  {
    CFRetain(a4);
    v11 = *(NSObject **)(v10 + 40);
  }
  FigDeferNotificationToDispatchQueue((uint64_t)fncHandleDeferredNotification, a1, v10, a3, (uint64_t)a4, a5, v11, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
}

uint64_t FigNotificationCenterRemoveWeakListener(__CFNotificationCenter *a1, const void *a2, uint64_t a3, const __CFString *a4, const void *a5)
{
  CFStringRef v9;
  CFStringRef v10;
  uint64_t v11;
  uint64_t v12;
  void *value;

  value = 0;
  v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("weak--%p--%p--%@--%p--listener"), a2, a3, a4, a5);
  if (!v9)
    return FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
  v10 = v9;
  FigThreadRunOnce(&sFigNotificationCenterWeakListenerLinks, (void (*)(void))FigNotificationCenterWeakListenerLinksInitOnce);
  FigSimpleMutexLock((pthread_mutex_t *)qword_1ECDA81E8);
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)qword_1ECDA81D8, v10, (const void **)&value))
  {
    CFRetain(value);
    CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_1ECDA81D8, v10);
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1ECDA81E8);
  if (value)
  {
    v11 = *((_QWORD *)value + 4);
    if (a1)
    {
      if (v11)
      {
        CFNotificationCenterRemoveObserver(a1, *((const void **)value + 4), a4, a5);
        v12 = 0;
      }
      else
      {
        v12 = 4294954573;
      }
    }
    else
    {
      v12 = 4294954575;
    }
    FigCFWeakReferenceTableRemoveValue(qword_1ECDA81E0, v11);
    CFRelease(value);
  }
  else
  {
    CFNotificationCenterRemoveObserver(a1, a2, a4, a5);
    v12 = 0;
  }
  CFRelease(v10);
  return v12;
}

uint64_t FigNotificationCenterWeakListenerLinksInitOnce()
{
  const __CFAllocator *v0;
  uint64_t result;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  qword_1ECDA81D8 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  qword_1ECDA81E8 = (uint64_t)FigSimpleMutexCreate();
  FigCFWeakReferenceTableCreate(v0, 0, &qword_1ECDA81E0);
  result = _CFRuntimeRegisterClass();
  sfncWeakListenerLinkID = result;
  return result;
}

uint64_t CMNotificationCenterRemoveListener(__CFNotificationCenter *a1, const void *a2, int a3, CFNotificationName name, void *object)
{
  if (!a1)
    return 4294954575;
  if (!a2)
    return 4294954573;
  CFNotificationCenterRemoveObserver(a1, a2, name, object);
  return 0;
}

CFNotificationCenterRef CMNotificationCenterGetDefaultLocalCenter()
{
  FigThreadRunOnce(&CMNotificationCenterGetDefaultLocalCenter_initOnce, (void (*)(void))FigNotificationCenterSupportInitOnce);
  return CFNotificationCenterGetLocalCenter();
}

CFNotificationCenterRef CMNotificationCenterCreate()
{
  CFNotificationCenterRef LocalCenter;

  FigThreadRunOnce(&CMNotificationCenterGetDefaultLocalCenter_initOnce, (void (*)(void))FigNotificationCenterSupportInitOnce);
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFRetain(LocalCenter);
  return LocalCenter;
}

uint64_t CMNotificationCenterPostNotification(__CFNotificationCenter *a1, const __CFString *a2, const void *a3, CFTypeRef cf)
{
  CFTypeID v8;

  if (!a1)
    return 4294954575;
  if (!a2)
    return 4294954574;
  if (!a3)
    return 4294954572;
  if (cf)
  {
    v8 = CFGetTypeID(cf);
    if (v8 != CFDictionaryGetTypeID())
      return FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
  }
  FigNotificationCenterSupportWillPostNotification((uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  CFNotificationCenterPostNotification(a1, a2, a3, (CFDictionaryRef)cf, 1u);
  FigNotificationCenterSupportDidPostNotification((uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  return 0;
}

uint64_t FigNotificationCenterAddWeakListeners(CFNotificationCenterRef center, void *observer, uint64_t a3, uint64_t a4, void *object, int a6, NSObject *a7)
{
  uint64_t v14;
  CFStringRef **i;
  uint64_t v16;
  uint64_t v17;

  if (!a4)
    return 0;
  v14 = 0;
  for (i = (CFStringRef **)(a3 + 8); ; i += 2)
  {
    v16 = FigNotificationCenterAddWeakListener(center, observer, (CFNotificationCallback)*(i - 1), **i, (unint64_t)object, a6, a7);
    if ((_DWORD)v16)
      break;
    if (a4 == ++v14)
      return 0;
  }
  v17 = v16;
  FigNotificationCenterRemoveWeakListeners(center, observer, a3, v14, object);
  return v17;
}

uint64_t FigNotificationCenterRemoveWeakListeners(__CFNotificationCenter *a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5)
{
  uint64_t v6;
  uint64_t v9;
  const __CFString ***v10;
  unsigned int v11;
  BOOL v12;

  if (!a4)
    return 0;
  v6 = a4;
  LODWORD(v9) = 0;
  v10 = (const __CFString ***)(a3 + 8);
  do
  {
    v11 = FigNotificationCenterRemoveWeakListener(a1, a2, (uint64_t)*(v10 - 1), **v10, a5);
    if ((_DWORD)v9)
      v12 = 1;
    else
      v12 = v11 == 0;
    if (v12)
      v9 = v9;
    else
      v9 = v11;
    v10 += 2;
    --v6;
  }
  while (v6);
  return v9;
}

void fncHandleDeferredNotification(uint64_t a1, _BYTE *a2, uint64_t a3, const void *a4, uint64_t a5)
{
  fncCallOriginalCallbackAndReleaseWeakListener((uint64_t)a2, a1, a3, (uint64_t)a4, a5);
  if ((a2[48] & 1) != 0)
    CFRelease(a4);
  CFRelease(a2);
}

void fncCallOriginalCallbackAndReleaseWeakListener(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id *v10;

  v10 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 16));
  (*(void (**)(uint64_t, id *, uint64_t, uint64_t, uint64_t))(a1 + 24))(a2, v10, a3, a4, a5);
  if (v10)
  {
    CFRelease(v10);
    if ((*(_BYTE *)(a1 + 48) & 2) != 0)
    {
      if (fncDeferReleaseWeakListenerToQueue_deferredReleaseQueueOnce != -1)
        dispatch_once_f(&fncDeferReleaseWeakListenerToQueue_deferredReleaseQueueOnce, &fncDeferReleaseWeakListenerToQueue_deferredReleaseQueue, (dispatch_function_t)fncInitDeferredReleaseQueue);
      dispatch_async_f((dispatch_queue_t)fncDeferReleaseWeakListenerToQueue_deferredReleaseQueue, v10, (dispatch_function_t)fncReleaseCFType);
    }
    else
    {
      CFRelease(v10);
    }
  }
}

dispatch_queue_t fncInitDeferredReleaseQueue(dispatch_queue_t *a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("com.apple.coremedia.notificationcenter.deferredRelease", 0);
  *a1 = result;
  return result;
}

double fncWeakListenerLinkInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void fncWeakListenerLinkFinalize(uint64_t a1)
{
  const void *v2;
  NSObject *v3;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_release(v3);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

uint64_t FigDeferNotificationToDispatchQueue(uint64_t a1, const void *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, NSObject *a7, CFAllocatorRef allocator)
{
  _QWORD *v16;
  _QWORD *v17;
  const void *v18;
  const void *v19;

  v16 = CFAllocatorAllocate(allocator, 64, 0);
  if (!v16)
    return FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
  v17 = v16;
  *v16 = a2;
  v16[1] = a1;
  v16[2] = a3;
  v16[3] = a4;
  v16[4] = a5;
  v16[5] = a6;
  v16[6] = allocator;
  if (a2)
  {
    CFRetain(a2);
    a4 = (const void *)v17[3];
  }
  if (a4)
    CFRetain(a4);
  v18 = (const void *)v17[5];
  if (v18)
    CFRetain(v18);
  v19 = (const void *)v17[6];
  if (v19)
    CFRetain(v19);
  dispatch_async_f(a7, v17, (dispatch_function_t)figDeferredNotificationDispatchFunction);
  return 0;
}

void figDeferredNotificationDispatchFunction(const void **ptr)
{
  void (*v2)(const void *, const void *, const void *, const void *, const void *);

  v2 = (void (*)(const void *, const void *, const void *, const void *, const void *))ptr[1];
  if (v2)
    v2(*ptr, ptr[2], ptr[3], ptr[4], ptr[5]);
  figDeferredNotificationRelease(ptr);
}

uint64_t FigDispatchAsyncPostNotification(NSObject *a1, const void *a2, const void *a3, const void *a4, const void *a5, int a6)
{
  const void *v12;
  _QWORD *v13;
  _QWORD *v14;
  CFTypeRef v15;
  CFTypeRef v16;
  uint64_t v18;

  if (!a1 || !a2)
  {
    v18 = 4294954575;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  if (!a3 || !a4)
  {
    v18 = 4294954571;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  v12 = (const void *)*MEMORY[0x1E0C9AE00];
  v13 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 64, 0);
  if (!v13)
  {
    v18 = 4294954570;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  v14 = v13;
  *v13 = CFRetain(a2);
  v14[1] = 0;
  *((_DWORD *)v14 + 14) = a6;
  v14[3] = CFRetain(a3);
  v14[4] = CFRetain(a4);
  if (a5)
    v15 = CFRetain(a5);
  else
    v15 = 0;
  v14[5] = v15;
  if (v12)
    v16 = CFRetain(v12);
  else
    v16 = 0;
  v14[6] = v16;
  dispatch_async_f(a1, v14, (dispatch_function_t)figDeferredPostNotification);
  return 0;
}

void figDeferredPostNotification(uint64_t a1)
{
  void *v2;

  CMNotificationCenterPostNotification(*(__CFNotificationCenter **)a1, *(const __CFString **)(a1 + 24), *(const void **)(a1 + 32), *(CFTypeRef *)(a1 + 40));
  v2 = *(void **)(a1 + 32);
  if ((*(_BYTE *)(a1 + 56) & 1) != 0)
  {
    if (v2)
    {
      if (fdpnDeferReleaseOfObjectToQueue_deferredReleaseQueueOnce != -1)
        dispatch_once_f(&fdpnDeferReleaseOfObjectToQueue_deferredReleaseQueueOnce, &fdpnDeferReleaseOfObjectToQueue_deferredReleaseQueue, (dispatch_function_t)fdpnInitDeferredReleaseQueue);
      dispatch_async_f((dispatch_queue_t)fdpnDeferReleaseOfObjectToQueue_deferredReleaseQueue, v2, (dispatch_function_t)fdpnReleaseCFType);
    }
  }
  else if (v2)
  {
    CFRelease(*(CFTypeRef *)(a1 + 32));
  }
  figDeferredNotificationRelease((const void **)a1);
}

dispatch_queue_t fdpnInitDeferredReleaseQueue(dispatch_queue_t *a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("com.apple.coremedia.deferredpostnotification.deferredRelease", 0);
  *a1 = result;
  return result;
}

CFTypeID CMSampleBufferGetTypeID(void)
{
  FigThreadRunOnce(&sRegisterFigSampleBufferTypeOnce, (void (*)(void))registerFigSampleBufferType);
  return sFigSampleBufferID;
}

void FigAttachmentsRegisterSampleBuffer()
{
  FigThreadRunOnce(&sRegisterFigSampleBufferTypeOnce, (void (*)(void))registerFigSampleBufferType);
  FigRuntimeRegisterAttachmentBearerWithTypeID(sFigSampleBufferAttachmentBearerCallbacks, (const void *)sFigSampleBufferID);
}

CFTypeRef FigSampleBufferRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

OSStatus CMSampleBufferCreate(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, Boolean dataReady, CMSampleBufferMakeDataReadyCallback makeDataReadyCallback, void *makeDataReadyRefcon, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMItemCount numSampleSizeEntries, const size_t *sampleSizeArray, CMSampleBufferRef *sampleBufferOut)
{
  return figSampleBufferCreateCallbackOrHandler((uint64_t)allocator, dataBuffer, dataReady, (uint64_t)makeDataReadyCallback, (uint64_t)makeDataReadyRefcon, 0, formatDescription, numSamples, numSampleTimingEntries, (void *)sampleTimingArray, numSampleSizeEntries, (void *)sampleSizeArray, sampleBufferOut);
}

uint64_t figSampleBufferCreateCallbackOrHandler(uint64_t a1, const void *a2, char a3, uint64_t a4, uint64_t a5, const void *a6, CMFormatDescriptionRef desc, unint64_t a8, unint64_t a9, void *__src, unint64_t a11, void *a12, _QWORD *a13)
{
  BOOL v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  CFTypeRef v24;
  const AudioStreamBasicDescription *StreamBasicDescription;
  unint64_t v27;
  uint64_t v28;
  CFTypeRef v29;
  _BYTE *v30;
  void *v31;
  CFTypeRef v32;
  CFTypeRef v33;
  uint64_t v34;
  __n128 v35;
  uint64_t v36;
  CFTypeRef cf;

  cf = 0;
  if (!a13)
  {
    v22 = 4294954565;
    goto LABEL_14;
  }
  if (a8)
  {
    v20 = a9 < 2 || a9 == a8;
    if (!v20 || (a11 >= 2 ? (v21 = a11 == a8) : (v21 = 1), !v21))
    {
LABEL_12:
      v22 = 4294954558;
LABEL_14:
      v23 = FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
      goto LABEL_15;
    }
  }
  else if (a9 > 1 || a11 != 0)
  {
    goto LABEL_12;
  }
  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398)
    goto LABEL_27;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
  if (!StreamBasicDescription)
  {
    v22 = 4294954586;
    goto LABEL_14;
  }
  if (!StreamBasicDescription->mFramesPerPacket || !StreamBasicDescription->mBytesPerPacket)
    v27 = a8;
  else
LABEL_27:
    v27 = 0;
  v28 = sBufCreate(a1, a9, a11, v27, &cf);
  if (!(_DWORD)v28)
  {
    if (a2)
    {
      v29 = CFRetain(a2);
      v30 = cf;
      *((_QWORD *)cf + 2) = v29;
    }
    else
    {
      v30 = cf;
    }
    v30[25] = a3;
    if (a6)
    {
      v30[27] = 1;
      v31 = _Block_copy(a6);
      *((_QWORD *)cf + 6) = v31;
    }
    else
    {
      *((_QWORD *)v30 + 6) = a4;
      *((_QWORD *)v30 + 7) = a5;
    }
    v32 = FigFormatDescriptionRetain(desc);
    v33 = cf;
    *((_QWORD *)cf + 9) = v32;
    *((_QWORD *)v33 + 10) = a8;
    v34 = *((_QWORD *)v33 + 11);
    if (v34)
    {
      memcpy(*((void **)v33 + 12), __src, 72 * v34);
      sbufUpdateCachedTimestamps((uint64_t)cf, v35);
      v33 = cf;
    }
    v36 = *((_QWORD *)v33 + 13);
    if (v36)
    {
      memcpy(*((void **)v33 + 14), a12, 8 * v36);
      v33 = cf;
    }
    figSampleBufferCheckDataSize((size_t)v33);
    v23 = 0;
    v24 = cf;
    goto LABEL_40;
  }
  v23 = v28;
  if (cf)
    CFRelease(cf);
LABEL_15:
  if (a13)
  {
    v24 = 0;
LABEL_40:
    *a13 = v24;
  }
  return v23;
}

OSStatus CMSampleBufferCreateWithMakeDataReadyHandler(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, Boolean dataReady, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMItemCount numSampleSizeEntries, const size_t *sampleSizeArray, CMSampleBufferRef *sampleBufferOut, CMSampleBufferMakeDataReadyHandler makeDataReadyHandler)
{
  return figSampleBufferCreateCallbackOrHandler((uint64_t)allocator, dataBuffer, dataReady, 0, 0, makeDataReadyHandler, formatDescription, numSamples, numSampleTimingEntries, (void *)sampleTimingArray, numSampleSizeEntries, (void *)sampleSizeArray, sampleBufferOut);
}

OSStatus CMSampleBufferCreateReady(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMItemCount numSampleSizeEntries, const size_t *sampleSizeArray, CMSampleBufferRef *sampleBufferOut)
{
  return figSampleBufferCreateCallbackOrHandler((uint64_t)allocator, dataBuffer, 1, 0, 0, 0, formatDescription, numSamples, numSampleTimingEntries, (void *)sampleTimingArray, numSampleSizeEntries, (void *)sampleSizeArray, sampleBufferOut);
}

OSStatus CMAudioSampleBufferCreateWithPacketDescriptions(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, Boolean dataReady, CMSampleBufferMakeDataReadyCallback makeDataReadyCallback, void *makeDataReadyRefcon, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMTime *presentationTimeStamp, const AudioStreamPacketDescription *packetDescriptions, CMSampleBufferRef *sampleBufferOut)
{
  CMTime v11;

  v11 = *presentationTimeStamp;
  return figAudioSampleBufferCreateWithPacketDescriptionsCallbackOrHandler((uint64_t)allocator, dataBuffer, dataReady, (uint64_t)makeDataReadyCallback, (uint64_t)makeDataReadyRefcon, 0, formatDescription, numSamples, (__int128 *)&v11.value, packetDescriptions, sampleBufferOut);
}

uint64_t figAudioSampleBufferCreateWithPacketDescriptionsCallbackOrHandler(uint64_t a1, const void *a2, int a3, uint64_t a4, uint64_t a5, const void *a6, CMFormatDescriptionRef desc, int64_t a8, __int128 *a9, _QWORD *a10, _QWORD *a11)
{
  _QWORD *v11;
  const AudioStreamBasicDescription *StreamBasicDescription;
  const AudioStreamBasicDescription *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  CFTypeRef v30;
  char *v31;
  void *v32;
  CFTypeRef v33;
  char *v34;
  __int128 *v35;
  __int128 v36;
  int64_t mFramesPerPacket;
  __int128 v38;
  __int128 v39;
  char *v40;
  int32_t v41;
  __int128 v42;
  unsigned int *v43;
  int64_t v44;
  unsigned int v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  void **v51;
  _QWORD *v52;
  uint64_t mBytesPerPacket;
  unsigned int *v54;
  int64_t v55;
  unsigned int v56;
  uint64_t v58;
  CMTime rhs;
  CMTime lhs;
  CMTime time;
  CMTime v62;
  CFTypeRef v63[2];

  v11 = a11;
  v63[0] = 0;
  if (!a11)
    goto LABEL_57;
  if (a8 <= 0)
  {
    v24 = 4294954558;
    goto LABEL_17;
  }
  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398)
    goto LABEL_57;
  if ((*((_DWORD *)a9 + 3) & 0x1D) != 1)
  {
    v24 = 4294954556;
LABEL_17:
    v25 = FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
    if (!(_DWORD)v25)
      goto LABEL_54;
    goto LABEL_18;
  }
  if (!a2 && a3)
  {
LABEL_57:
    v24 = 4294954565;
    goto LABEL_17;
  }
  v58 = a4;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
  if (!StreamBasicDescription)
  {
    v24 = 4294954586;
    goto LABEL_17;
  }
  v21 = StreamBasicDescription;
  if (StreamBasicDescription->mFramesPerPacket)
    v22 = 1;
  else
    v22 = a8;
  if (!StreamBasicDescription->mBytesPerPacket)
  {
    if (a10)
    {
      v26 = 0;
      v27 = 0;
      v28 = a10;
      do
      {
        if (v27)
        {
          if (*v28 != v26)
            goto LABEL_29;
        }
        else
        {
          v26 = *a10;
        }
        v26 += *((unsigned int *)v28 + 3);
        ++v27;
        v28 += 2;
      }
      while (a8 != v27);
      v23 = a8;
      goto LABEL_30;
    }
    goto LABEL_57;
  }
  if (StreamBasicDescription->mFormatID == 1819304813 && (StreamBasicDescription->mFormatFlags & 0x20) != 0)
LABEL_29:
    v23 = 0;
  else
    v23 = 1;
LABEL_30:
  v29 = sBufCreate(a1, v22, v23, a8, v63);
  if (!(_DWORD)v29)
  {
    if (a2)
    {
      v30 = CFRetain(a2);
      v31 = (char *)v63[0];
      *((_QWORD *)v63[0] + 2) = v30;
      *((_DWORD *)v31 + 7) = 0;
    }
    else
    {
      v31 = (char *)v63[0];
    }
    v31[25] = a3;
    if (a6)
    {
      v31[27] = 1;
      v32 = _Block_copy(a6);
      *((_QWORD *)v63[0] + 6) = v32;
    }
    else
    {
      *((_QWORD *)v31 + 6) = v58;
      *((_QWORD *)v31 + 7) = a5;
    }
    v33 = FigFormatDescriptionRetain(desc);
    v34 = (char *)v63[0];
    *((_QWORD *)v63[0] + 9) = v33;
    *((_QWORD *)v34 + 10) = a8;
    v35 = (__int128 *)*((_QWORD *)v34 + 12);
    *((_OWORD *)v34 + 10) = *(_OWORD *)&kCMTimeInvalid.value;
    *((_QWORD *)v34 + 22) = 0;
    v36 = *a9;
    *((_QWORD *)v34 + 25) = *((_QWORD *)a9 + 2);
    *(_OWORD *)(v34 + 184) = v36;
    *((_QWORD *)v34 + 28) = 0;
    *((_OWORD *)v34 + 13) = *(_OWORD *)&kCMTimeZero.value;
    mFramesPerPacket = v21->mFramesPerPacket;
    if ((_DWORD)mFramesPerPacket)
    {
      CMTimeMake(&v62, mFramesPerPacket, (int)v21->mSampleRate);
      v38 = *(_OWORD *)&v62.value;
      *((_QWORD *)v35 + 2) = v62.epoch;
      *v35 = v38;
      v39 = *a9;
      *((_QWORD *)v35 + 5) = *((_QWORD *)a9 + 2);
      *(__int128 *)((char *)v35 + 24) = v39;
      v35[3] = *(_OWORD *)&kCMTimeInvalid.value;
      *((_QWORD *)v35 + 8) = 0;
      v40 = (char *)v63[0];
      v41 = *((_DWORD *)v63[0] + 20);
      v42 = *v35;
      time.epoch = *((_QWORD *)v35 + 2);
      *(_OWORD *)&time.value = v42;
      CMTimeMultiply(&v62, &time, v41);
      *(CMTime *)(v40 + 208) = v62;
    }
    else
    {
      *(_OWORD *)&v62.value = *a9;
      v62.epoch = *((_QWORD *)a9 + 2);
      if (!a10)
        goto LABEL_61;
      v43 = (unsigned int *)(a10 + 1);
      v44 = a8;
      do
      {
        v45 = *v43;
        v43 += 4;
        CMTimeMake(&time, v45, (int)v21->mSampleRate);
        v46 = *(_OWORD *)&time.value;
        *((_QWORD *)v35 + 2) = time.epoch;
        *v35 = v46;
        v47 = *(_OWORD *)&v62.value;
        *((_QWORD *)v35 + 5) = v62.epoch;
        *(__int128 *)((char *)v35 + 24) = v47;
        v35[3] = *(_OWORD *)&kCMTimeInvalid.value;
        *((_QWORD *)v35 + 8) = 0;
        v48 = (char *)v63[0];
        lhs = *(CMTime *)((char *)v63[0] + 208);
        v49 = *v35;
        rhs.epoch = *((_QWORD *)v35 + 2);
        *(_OWORD *)&rhs.value = v49;
        CMTimeAdd(&time, &lhs, &rhs);
        *(CMTime *)(v48 + 208) = time;
        time = v62;
        v50 = *v35;
        lhs.epoch = *((_QWORD *)v35 + 2);
        *(_OWORD *)&lhs.value = v50;
        CMTimeAdd(&v62, &time, &lhs);
        v35 = (__int128 *)((char *)v35 + 72);
        --v44;
      }
      while (v44);
    }
    if (!v23)
    {
LABEL_47:
      if (!a10)
      {
        v25 = 0;
        v11 = a11;
        goto LABEL_54;
      }
      v51 = (void **)v63[0];
      v11 = a11;
      goto LABEL_53;
    }
    v51 = (void **)v63[0];
    v52 = (_QWORD *)*((_QWORD *)v63[0] + 14);
    mBytesPerPacket = v21->mBytesPerPacket;
    if ((_DWORD)mBytesPerPacket)
    {
      if (v21->mFormatID != 1819304813 || (v21->mFormatFlags & 0x20) == 0)
        *v52 = mBytesPerPacket;
      goto LABEL_47;
    }
    if (a10)
    {
      v54 = (unsigned int *)a10 + 3;
      v55 = a8;
      v11 = a11;
      do
      {
        v56 = *v54;
        v54 += 4;
        *v52++ = v56;
        --v55;
      }
      while (v55);
LABEL_53:
      memcpy(v51[41], a10, 16 * a8);
      v25 = 0;
      *((_BYTE *)v63[0] + 344) = 1;
      goto LABEL_54;
    }
LABEL_61:
    v25 = FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
    v11 = a11;
    if (!(_DWORD)v25)
      goto LABEL_54;
    goto LABEL_18;
  }
  v25 = v29;
  v11 = a11;
LABEL_18:
  if (v63[0])
    CFRelease(v63[0]);
  v63[0] = 0;
LABEL_54:
  if (v11)
    *v11 = v63[0];
  return v25;
}

OSStatus CMAudioSampleBufferCreateWithPacketDescriptionsAndMakeDataReadyHandler(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, Boolean dataReady, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMTime *presentationTimeStamp, const AudioStreamPacketDescription *packetDescriptions, CMSampleBufferRef *sampleBufferOut, CMSampleBufferMakeDataReadyHandler makeDataReadyHandler)
{
  CMTime v10;

  v10 = *presentationTimeStamp;
  return figAudioSampleBufferCreateWithPacketDescriptionsCallbackOrHandler((uint64_t)allocator, dataBuffer, dataReady, 0, 0, makeDataReadyHandler, formatDescription, numSamples, (__int128 *)&v10.value, packetDescriptions, sampleBufferOut);
}

OSStatus CMAudioSampleBufferCreateReadyWithPacketDescriptions(CFAllocatorRef allocator, CMBlockBufferRef dataBuffer, CMFormatDescriptionRef formatDescription, CMItemCount numSamples, CMTime *presentationTimeStamp, const AudioStreamPacketDescription *packetDescriptions, CMSampleBufferRef *sampleBufferOut)
{
  CMTime v8;

  v8 = *presentationTimeStamp;
  return figAudioSampleBufferCreateWithPacketDescriptionsCallbackOrHandler((uint64_t)allocator, dataBuffer, 1, 0, 0, 0, formatDescription, numSamples, (__int128 *)&v8.value, packetDescriptions, sampleBufferOut);
}

OSStatus CMSampleBufferCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, Boolean dataReady, CMSampleBufferMakeDataReadyCallback makeDataReadyCallback, void *makeDataReadyRefcon, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut)
{
  return figSampleBufferCreateForImageBufferCallbackOrHandler((uint64_t)allocator, imageBuffer, dataReady, (uint64_t)makeDataReadyCallback, (uint64_t)makeDataReadyRefcon, 0, formatDescription, (uint64_t)sampleTiming, sampleBufferOut);
}

uint64_t figSampleBufferCreateForImageBufferCallbackOrHandler(uint64_t a1, void *a2, char a3, uint64_t a4, uint64_t a5, const void *a6, CMFormatDescriptionRef desc, uint64_t a8, _QWORD *a9)
{
  uint64_t v10;
  uint64_t v18;
  CFTypeRef v19;
  _BYTE *v20;
  void *v21;
  char *v22;
  CFTypeRef v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  CFTypeRef cf;

  cf = 0;
  v10 = 4294954565;
  if (!a2 || !desc || !a9)
    goto LABEL_23;
  if (CMFormatDescriptionGetMediaType(desc) != 1986618469
    && CMFormatDescriptionGetMediaType(desc) != 1635088502
    && CMFormatDescriptionGetMediaType(desc) != 1885954932)
  {
    v10 = 4294954555;
    goto LABEL_23;
  }
  if (!a8)
  {
    v10 = 4294954565;
LABEL_23:
    v18 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  if (CMVideoFormatDescriptionMatchesImageBuffer(desc, (CVImageBufferRef)a2))
  {
    v18 = sBufCreate(a1, 1uLL, 0, 0, &cf);
    if (!(_DWORD)v18)
    {
      *((_DWORD *)cf + 7) = 1;
      v19 = CFRetain(a2);
      v20 = cf;
      *((_QWORD *)cf + 2) = v19;
      v20[25] = a3;
      if (a6)
      {
        v20[27] = 1;
        v21 = _Block_copy(a6);
        *((_QWORD *)cf + 6) = v21;
      }
      else
      {
        *((_QWORD *)v20 + 6) = a4;
        *((_QWORD *)v20 + 7) = a5;
      }
      v23 = FigFormatDescriptionRetain(desc);
      v18 = 0;
      v22 = (char *)cf;
      *((_QWORD *)cf + 9) = v23;
      *((_QWORD *)v22 + 10) = 1;
      v24 = *((_QWORD *)v22 + 12);
      v25 = *(_OWORD *)(a8 + 16);
      v26 = *(_OWORD *)(a8 + 32);
      v27 = *(_OWORD *)(a8 + 48);
      *(_QWORD *)(v24 + 64) = *(_QWORD *)(a8 + 64);
      *(_OWORD *)(v24 + 32) = v26;
      *(_OWORD *)(v24 + 48) = v27;
      *(_OWORD *)(v24 + 16) = v25;
      *(_OWORD *)v24 = *(_OWORD *)a8;
      v28 = *(_QWORD *)(a8 + 64);
      *((_OWORD *)v22 + 10) = *(_OWORD *)(a8 + 48);
      *((_QWORD *)v22 + 22) = v28;
      v29 = *(_QWORD *)(a8 + 40);
      *(_OWORD *)(v22 + 184) = *(_OWORD *)(a8 + 24);
      *((_QWORD *)v22 + 25) = v29;
      v30 = *(_QWORD *)(a8 + 16);
      *((_OWORD *)v22 + 13) = *(_OWORD *)a8;
      *((_QWORD *)v22 + 28) = v30;
      goto LABEL_17;
    }
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v18 = 4294954553;
  }
LABEL_13:
  if (a9)
  {
    v22 = 0;
LABEL_17:
    *a9 = v22;
  }
  return v18;
}

OSStatus CMSampleBufferCreateForImageBufferWithMakeDataReadyHandler(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, Boolean dataReady, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut, CMSampleBufferMakeDataReadyHandler makeDataReadyHandler)
{
  return figSampleBufferCreateForImageBufferCallbackOrHandler((uint64_t)allocator, imageBuffer, dataReady, 0, 0, makeDataReadyHandler, formatDescription, (uint64_t)sampleTiming, sampleBufferOut);
}

OSStatus CMSampleBufferCreateReadyWithImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut)
{
  return figSampleBufferCreateForImageBufferCallbackOrHandler((uint64_t)allocator, imageBuffer, 1, 0, 0, 0, formatDescription, (uint64_t)sampleTiming, sampleBufferOut);
}

uint64_t FigSampleBufferCreateForCaptionGroup(const __CFAllocator *a1, const void *a2, __int128 *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v10;
  char *v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeRef cf;

  cf = 0;
  if (!a2 || (*((_DWORD *)a3 + 3) & 0x1D) != 1 || (*(_DWORD *)(a4 + 12) & 0x1D) != 1 || !a5)
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  v10 = sBufCreate((uint64_t)a1, 1uLL, 0, 0, &cf);
  v11 = (char *)cf;
  if ((_DWORD)v10)
    goto LABEL_10;
  *((_DWORD *)cf + 7) = 2;
  v12 = CFRetain(a2);
  v13 = cf;
  *((_QWORD *)cf + 2) = v12;
  *((_BYTE *)v13 + 25) = 1;
  *((_QWORD *)v13 + 10) = 1;
  v10 = FigCaptionGroupFormatDescriptionCreate(a1, 1668310898, (CFTypeRef *)v13 + 9);
  v11 = (char *)cf;
  if ((_DWORD)v10)
  {
LABEL_10:
    if (v11)
      CFRelease(v11);
  }
  else
  {
    v14 = *((_QWORD *)cf + 12);
    v15 = *a3;
    *(_QWORD *)(v14 + 40) = *((_QWORD *)a3 + 2);
    *(_OWORD *)(v14 + 24) = v15;
    *(_OWORD *)(v14 + 48) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(v14 + 64) = 0;
    v16 = *(_QWORD *)(a4 + 16);
    *(_OWORD *)v14 = *(_OWORD *)a4;
    *(_QWORD *)(v14 + 16) = v16;
    *((_QWORD *)v11 + 22) = 0;
    *((_OWORD *)v11 + 10) = *(_OWORD *)&kCMTimeInvalid.value;
    v17 = *(_QWORD *)(v14 + 40);
    *(_OWORD *)(v11 + 184) = *(_OWORD *)(v14 + 24);
    *((_QWORD *)v11 + 25) = v17;
    v18 = *(_QWORD *)(v14 + 16);
    *((_OWORD *)v11 + 13) = *(_OWORD *)v14;
    *((_QWORD *)v11 + 28) = v18;
    *a5 = v11;
  }
  return v10;
}

uint64_t FigSampleBufferCreateForTaggedBufferGroup(const __CFAllocator *a1, const void *a2, __int128 *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v10;
  char *v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeRef cf;

  cf = 0;
  if (!a2 || (*((_DWORD *)a3 + 3) & 0x1D) != 1 || !a5)
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  v10 = sBufCreate((uint64_t)a1, 1uLL, 0, 0, &cf);
  v11 = (char *)cf;
  if ((_DWORD)v10)
    goto LABEL_9;
  *((_DWORD *)cf + 7) = 3;
  v12 = CFRetain(a2);
  v13 = cf;
  *((_QWORD *)cf + 2) = v12;
  *((_BYTE *)v13 + 25) = 1;
  *((_QWORD *)v13 + 10) = 1;
  v10 = FigTaggedBufferGroupFormatDescriptionCreate(a1, 1952606066, (CFTypeRef *)v13 + 9);
  v11 = (char *)cf;
  if ((_DWORD)v10)
  {
LABEL_9:
    if (v11)
      CFRelease(v11);
  }
  else
  {
    v14 = *((_QWORD *)cf + 12);
    v15 = *a3;
    *(_QWORD *)(v14 + 40) = *((_QWORD *)a3 + 2);
    *(_OWORD *)(v14 + 24) = v15;
    *(_OWORD *)(v14 + 48) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(v14 + 64) = 0;
    v16 = *(_QWORD *)(a4 + 16);
    *(_OWORD *)v14 = *(_OWORD *)a4;
    *(_QWORD *)(v14 + 16) = v16;
    *((_QWORD *)v11 + 22) = 0;
    *((_OWORD *)v11 + 10) = *(_OWORD *)&kCMTimeInvalid.value;
    v17 = *(_QWORD *)(v14 + 40);
    *(_OWORD *)(v11 + 184) = *(_OWORD *)(v14 + 24);
    *((_QWORD *)v11 + 25) = v17;
    v18 = *(_QWORD *)(v14 + 16);
    *((_OWORD *)v11 + 13) = *(_OWORD *)v14;
    *((_QWORD *)v11 + 28) = v18;
    *a5 = v11;
  }
  return v10;
}

OSStatus CMSampleBufferCreateForTaggedBufferGroup(CFAllocatorRef allocator, CMTaggedBufferGroupRef taggedBufferGroup, CMTime *sbufPTS, CMTime *sbufDuration, CMTaggedBufferGroupFormatDescriptionRef formatDescription, CMSampleBufferRef *sBufOut)
{
  OSStatus v12;
  CFTypeRef v13;
  _BYTE *v14;
  CFTypeRef v15;
  char *v16;
  __int128 *v17;
  CMTimeEpoch epoch;
  CMTimeEpoch v19;
  __int128 v20;
  __int128 v21;
  uint64_t v23;
  CFTypeRef cf;

  cf = 0;
  if (!taggedBufferGroup)
  {
    v23 = 4294954565;
    return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
  }
  if ((sbufPTS->flags & 0x1D) != 1 || !formatDescription)
    goto LABEL_9;
  if (CMFormatDescriptionGetMediaType(formatDescription) != 1952606066)
  {
    v23 = 4294954555;
    return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
  }
  if (!sBufOut)
  {
LABEL_9:
    v23 = 4294954565;
    return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
  }
  v12 = sBufCreate((uint64_t)allocator, 1uLL, 0, 0, &cf);
  if (v12)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *((_DWORD *)cf + 7) = 3;
    v13 = CFRetain(taggedBufferGroup);
    v14 = cf;
    *((_QWORD *)cf + 2) = v13;
    v14[25] = 1;
    *((_QWORD *)v14 + 10) = 1;
    v15 = FigFormatDescriptionRetain(formatDescription);
    v16 = (char *)cf;
    *((_QWORD *)cf + 9) = v15;
    v17 = (__int128 *)*((_QWORD *)v16 + 12);
    epoch = sbufPTS->epoch;
    *(__int128 *)((char *)v17 + 24) = *(_OWORD *)&sbufPTS->value;
    *((_QWORD *)v17 + 5) = epoch;
    *((_QWORD *)v17 + 8) = 0;
    v17[3] = *(_OWORD *)&kCMTimeInvalid.value;
    v19 = sbufDuration->epoch;
    *v17 = *(_OWORD *)&sbufDuration->value;
    *((_QWORD *)v17 + 2) = v19;
    *((_OWORD *)v16 + 10) = *(_OWORD *)&kCMTimeInvalid.value;
    *((_QWORD *)v16 + 22) = 0;
    v20 = *(__int128 *)((char *)v17 + 24);
    *((_QWORD *)v16 + 25) = *((_QWORD *)v17 + 5);
    *(_OWORD *)(v16 + 184) = v20;
    v21 = *v17;
    *((_QWORD *)v16 + 28) = *((_QWORD *)v17 + 2);
    *((_OWORD *)v16 + 13) = v21;
    *sBufOut = (CMSampleBufferRef)v16;
  }
  return v12;
}

OSStatus CMSampleBufferCreateCopy(CFAllocatorRef allocator, CMSampleBufferRef sbuf, CMSampleBufferRef *sampleBufferOut)
{
  if (sbuf && sampleBufferOut)
    return CMSampleBufferCreateCopyWithNewTiming(allocator, sbuf, *((_QWORD *)sbuf + 11), *((const CMSampleTimingInfo **)sbuf + 12), sampleBufferOut);
  else
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
}

OSStatus CMSampleBufferCreateCopyWithNewTiming(CFAllocatorRef allocator, CMSampleBufferRef originalSBuf, CMItemCount numSampleTimingEntries, const CMSampleTimingInfo *sampleTimingArray, CMSampleBufferRef *sampleBufferOut)
{
  uint64_t v10;
  OSStatus result;
  char *v12;
  const opaqueCMFormatDescription *v13;
  CMMediaType MediaType;
  unint64_t v15;
  unint64_t v16;
  __n128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  OSStatus v23;
  CFTypeRef cf;

  cf = 0;
  if (originalSBuf && sampleBufferOut)
  {
    if (!numSampleTimingEntries || sampleTimingArray)
    {
      if ((unint64_t)numSampleTimingEntries < 2 || *((_QWORD *)originalSBuf + 10) == numSampleTimingEntries)
      {
        v13 = (const opaqueCMFormatDescription *)*((_QWORD *)originalSBuf + 9);
        if (v13)
        {
          MediaType = CMFormatDescriptionGetMediaType(v13);
          v15 = *((_QWORD *)originalSBuf + 13);
          if (MediaType == 1936684398)
            v16 = *((_QWORD *)originalSBuf + 42);
          else
            v16 = 0;
        }
        else
        {
          v16 = 0;
          v15 = *((_QWORD *)originalSBuf + 13);
        }
        result = sBufCreate((uint64_t)allocator, numSampleTimingEntries, v15, v16, &cf);
        v12 = (char *)cf;
        if (!result)
        {
          result = sBufCopyInternals((unsigned __int8 *)originalSBuf, (uint64_t)cf, 0, 1);
          v12 = (char *)cf;
          if (!result)
          {
            v18 = *((_QWORD *)cf + 11);
            if (v18)
              memcpy(*((void **)cf + 12), sampleTimingArray, 72 * v18);
            v12 = (char *)cf;
            if (*((const CMSampleTimingInfo **)originalSBuf + 12) == sampleTimingArray)
            {
              result = 0;
              v19 = *(_OWORD *)((char *)originalSBuf + 124);
              *(_QWORD *)((char *)cf + 140) = *(_QWORD *)((char *)originalSBuf + 140);
              *(_OWORD *)(v12 + 124) = v19;
              v20 = *((_OWORD *)originalSBuf + 10);
              *((_QWORD *)v12 + 22) = *((_QWORD *)originalSBuf + 22);
              *((_OWORD *)v12 + 10) = v20;
              v21 = *(_OWORD *)((char *)originalSBuf + 184);
              *((_QWORD *)v12 + 25) = *((_QWORD *)originalSBuf + 25);
              *(_OWORD *)(v12 + 184) = v21;
              v22 = *((_OWORD *)originalSBuf + 13);
              *((_QWORD *)v12 + 28) = *((_QWORD *)originalSBuf + 28);
              *((_OWORD *)v12 + 13) = v22;
            }
            else
            {
              sbufUpdateCachedTimestamps((uint64_t)cf, v17);
              result = 0;
              v12 = (char *)cf;
            }
            goto LABEL_24;
          }
        }
        if (!v12)
        {
LABEL_24:
          *sampleBufferOut = (CMSampleBufferRef)v12;
          return result;
        }
        v23 = result;
        CFRelease(v12);
        result = v23;
LABEL_7:
        v12 = 0;
        goto LABEL_24;
      }
      v10 = 4294954558;
    }
    else
    {
      v10 = 4294954565;
    }
    result = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  result = FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  v12 = 0;
  if (sampleBufferOut)
    goto LABEL_24;
  return result;
}

uint64_t FigSampleBufferCreateCopyWithNoData(const __CFAllocator *a1, opaqueCMSampleBuffer *a2, CMSampleBufferRef *a3)
{
  uint64_t v4;
  uint64_t v5;
  CMSampleBufferRef v6;
  CMSampleBufferRef sampleBufferOut;

  sampleBufferOut = 0;
  v4 = CMSampleBufferCreateCopy(a1, a2, &sampleBufferOut);
  if ((_DWORD)v4)
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  v6 = sampleBufferOut;
  switch(*((_DWORD *)sampleBufferOut + 7))
  {
    case 0:
      if (*((_QWORD *)sampleBufferOut + 2))
      {
        CFRelease(*((CFTypeRef *)sampleBufferOut + 2));
        v6 = sampleBufferOut;
        *((_QWORD *)sampleBufferOut + 2) = 0;
      }
      break;
    case 1:
    case 2:
    case 3:
      if (*((_QWORD *)sampleBufferOut + 2))
      {
        CFRelease(*((CFTypeRef *)sampleBufferOut + 2));
        v6 = sampleBufferOut;
        *((_QWORD *)sampleBufferOut + 2) = 0;
      }
      *((_DWORD *)v6 + 7) = 0;
      break;
    default:
      break;
  }
  if (a3)
  {
    v5 = 0;
    *a3 = v6;
  }
  else
  {
    CFRelease(v6);
    return 0;
  }
  return v5;
}

uint64_t sBufCopyInternals(unsigned __int8 *cf, uint64_t a2, int a3, int a4)
{
  int v8;
  CFTypeRef v9;
  int v10;
  CFTypeRef v11;
  uint64_t v12;
  CFTypeRef v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  const opaqueCMFormatDescription *v20;
  uint64_t v21;
  uint64_t v22;
  const void **v23;
  const void **v24;
  CFIndex v25;
  const __CFAllocator *v26;
  const __CFDictionary *ValueAtIndex;
  CFMutableDictionaryRef MutableCopy;
  const __CFAllocator *v29;
  CFArrayRef v30;
  uint64_t result;
  const __CFAllocator *v32;
  CFMutableDictionaryRef v33;
  CFTypeRef *v34;

  if (!a2)
    return FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
  v8 = *((_DWORD *)cf + 7);
  *(_DWORD *)(a2 + 28) = v8;
  switch(v8)
  {
    case 0:
    case 1:
    case 2:
    case 3:
      v9 = (CFTypeRef)*((_QWORD *)cf + 2);
      if (v9)
        v9 = CFRetain(v9);
      *(_QWORD *)(a2 + 16) = v9;
      break;
    default:
      break;
  }
  v10 = cf[25];
  *(_BYTE *)(a2 + 25) = v10;
  if (!v10)
  {
    CFRetain(cf);
    *(_QWORD *)(a2 + 64) = cf;
  }
  v11 = FigFormatDescriptionRetain(*((CFTypeRef *)cf + 9));
  v12 = *((_QWORD *)cf + 10);
  *(_QWORD *)(a2 + 72) = v11;
  *(_QWORD *)(a2 + 80) = v12;
  v13 = (CFTypeRef)*((_QWORD *)cf + 19);
  if (v13)
    v13 = CFRetain(v13);
  *(_QWORD *)(a2 + 152) = v13;
  if (a3)
  {
    v14 = *(_QWORD *)(a2 + 88);
    if (v14)
      memcpy(*(void **)(a2 + 96), *((const void **)cf + 12), 72 * v14);
    v15 = *(_OWORD *)(cf + 124);
    *(_QWORD *)(a2 + 140) = *(_QWORD *)(cf + 140);
    *(_OWORD *)(a2 + 124) = v15;
    v16 = *((_OWORD *)cf + 10);
    *(_QWORD *)(a2 + 176) = *((_QWORD *)cf + 22);
    *(_OWORD *)(a2 + 160) = v16;
    v17 = *(_OWORD *)(cf + 184);
    *(_QWORD *)(a2 + 200) = *((_QWORD *)cf + 25);
    *(_OWORD *)(a2 + 184) = v17;
    v18 = *((_OWORD *)cf + 13);
    *(_QWORD *)(a2 + 224) = *((_QWORD *)cf + 28);
    *(_OWORD *)(a2 + 208) = v18;
  }
  if (a4)
  {
    v19 = *(_QWORD *)(a2 + 104);
    if (v19)
      memcpy(*(void **)(a2 + 112), *((const void **)cf + 14), 8 * v19);
  }
  v20 = (const opaqueCMFormatDescription *)*((_QWORD *)cf + 9);
  if (v20)
  {
    if (CMFormatDescriptionGetMediaType(v20) == 1936684398)
    {
      v21 = *((_QWORD *)cf + 42);
      if (v21)
      {
        if (cf[344])
        {
          memcpy(*(void **)(a2 + 328), *((const void **)cf + 41), 16 * v21);
          *(_BYTE *)(a2 + 344) = 1;
        }
      }
    }
  }
  if (!*((_QWORD *)cf + 38))
  {
    v24 = 0;
    v22 = 0;
    goto LABEL_32;
  }
  v22 = *(_QWORD *)(a2 + 80);
  v23 = (const void **)malloc_type_calloc(v22, 8uLL, 0x2004093837F09uLL);
  if (v23)
  {
    v24 = v23;
    if (v22 >= 1)
    {
      v25 = 0;
      do
      {
        v26 = CFGetAllocator((CFTypeRef)a2);
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 38), v25);
        MutableCopy = CFDictionaryCreateMutableCopy(v26, 0, ValueAtIndex);
        v24[v25] = MutableCopy;
        if (!MutableCopy)
          goto LABEL_29;
      }
      while (v22 != ++v25);
    }
    v29 = CFGetAllocator(cf);
    v30 = CFArrayCreate(v29, v24, v22, MEMORY[0x1E0C9B378]);
    *(_QWORD *)(a2 + 304) = v30;
    if (!v30)
    {
LABEL_29:
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
LABEL_36:
      if (v22 >= 1)
      {
        v34 = v24;
        do
        {
          if (*v34)
            CFRelease(*v34);
          ++v34;
          --v22;
        }
        while (v22);
      }
      free(v24);
      return 0;
    }
LABEL_32:
    if (*((_QWORD *)cf + 39))
    {
      v32 = CFGetAllocator((CFTypeRef)a2);
      v33 = CFDictionaryCreateMutableCopy(v32, 0, *((CFDictionaryRef *)cf + 39));
      *(_QWORD *)(a2 + 312) = v33;
      if (!v33)
        FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    }
    if (!v24)
      return 0;
    goto LABEL_36;
  }
  result = FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)result)
  {
    *(_BYTE *)(a2 + 25) = 0;
    *(_QWORD *)(a2 + 80) = 0;
  }
  return result;
}

uint64_t FigSampleBufferCreateCopyWithNewSizesAndDataBuffer(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, const void *a5, CFTypeRef *a6)
{
  const opaqueCMFormatDescription *v12;
  CMMediaType MediaType;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  const void *v21;
  CFTypeRef cf;

  cf = 0;
  if (!a2 || !a5 || !a6)
  {
    v16 = FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
    if (!a6)
      return v16;
    goto LABEL_25;
  }
  if (a3 && a4)
  {
    if (*(_DWORD *)(a2 + 28))
    {
      v17 = 4294954553;
    }
    else
    {
      if (a3 == 1 || *(_QWORD *)(a2 + 80) == a3)
      {
        v12 = *(const opaqueCMFormatDescription **)(a2 + 72);
        if (v12)
        {
          MediaType = CMFormatDescriptionGetMediaType(v12);
          v14 = *(_QWORD *)(a2 + 88);
          if (MediaType == 1936684398)
            v15 = *(_QWORD *)(a2 + 336);
          else
            v15 = 0;
        }
        else
        {
          v15 = 0;
          v14 = *(_QWORD *)(a2 + 88);
        }
        v18 = sBufCreate(a1, v14, a3, v15, &cf);
        v19 = cf;
        if ((_DWORD)v18 || (v18 = sBufCopyInternals((unsigned __int8 *)a2, (uint64_t)cf, 1, 0), v19 = cf, (_DWORD)v18))
        {
          v16 = v18;
          if (v19)
          {
            CFRelease(v19);
            cf = 0;
          }
        }
        else
        {
          v20 = *((_QWORD *)cf + 13);
          if (v20)
          {
            memcpy(*((void **)cf + 14), a4, 8 * v20);
            v19 = cf;
          }
          v21 = (const void *)v19[2];
          v19[2] = a5;
          CFRetain(a5);
          if (v21)
            CFRelease(v21);
          v16 = 0;
        }
        goto LABEL_25;
      }
      v17 = 4294954558;
    }
  }
  else
  {
    v17 = 4294954565;
  }
  v16 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
LABEL_25:
  *a6 = cf;
  return v16;
}

const void **FigSampleBufferCreateCopyWithNewFormatDescription(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  const opaqueCMFormatDescription *v8;
  CMMediaType MediaType;
  unint64_t v10;
  unint64_t v11;
  char v12;
  unint64_t v13;
  const void **v14;
  CFTypeRef v15;
  int v16;
  CFTypeRef v17;
  int v18;
  CFTypeRef v19;
  char *v20;
  uint64_t v21;
  CFTypeRef v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  const void **v31;
  CFIndex v32;
  const __CFAllocator *v33;
  const __CFDictionary *ValueAtIndex;
  CFMutableDictionaryRef MutableCopy;
  const __CFAllocator *v36;
  CFArrayRef v37;
  const __CFAllocator *v38;
  CFMutableDictionaryRef v39;
  CFTypeRef *v40;
  CFTypeRef cf;

  cf = 0;
  if (!a2 || !a3 || !a4)
  {
    v14 = (const void **)FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
    goto LABEL_47;
  }
  v8 = *(const opaqueCMFormatDescription **)(a2 + 72);
  if (v8)
  {
    MediaType = CMFormatDescriptionGetMediaType(v8);
    v10 = *(_QWORD *)(a2 + 88);
    v11 = *(_QWORD *)(a2 + 104);
    if (MediaType == 1936684398)
    {
      v12 = 0;
      v13 = *(_QWORD *)(a2 + 336);
      goto LABEL_11;
    }
    v13 = 0;
  }
  else
  {
    v13 = 0;
    v10 = *(_QWORD *)(a2 + 88);
    v11 = *(_QWORD *)(a2 + 104);
  }
  v12 = 1;
LABEL_11:
  v14 = (const void **)sBufCreate(a1, v10, v11, v13, &cf);
  v15 = cf;
  if ((_DWORD)v14)
  {
LABEL_51:
    if ((_DWORD)v14 && v15)
    {
      CFRelease(v15);
      cf = 0;
    }
    goto LABEL_48;
  }
  v16 = *(_DWORD *)(a2 + 28);
  *((_DWORD *)cf + 7) = v16;
  switch(v16)
  {
    case 0:
    case 1:
    case 2:
    case 3:
      v17 = *(CFTypeRef *)(a2 + 16);
      if (v17)
      {
        v17 = CFRetain(*(CFTypeRef *)(a2 + 16));
        v15 = cf;
      }
      *((_QWORD *)v15 + 2) = v17;
      break;
    default:
      break;
  }
  v18 = *(unsigned __int8 *)(a2 + 25);
  *((_BYTE *)v15 + 25) = v18;
  if (!v18)
  {
    CFRetain((CFTypeRef)a2);
    *((_QWORD *)cf + 8) = a2;
  }
  v19 = FigFormatDescriptionRetain(a3);
  v20 = (char *)cf;
  v21 = *(_QWORD *)(a2 + 80);
  *((_QWORD *)cf + 9) = v19;
  *((_QWORD *)v20 + 10) = v21;
  v22 = *(CFTypeRef *)(a2 + 152);
  if (v22)
  {
    v22 = CFRetain(*(CFTypeRef *)(a2 + 152));
    v20 = (char *)cf;
  }
  *((_QWORD *)v20 + 19) = v22;
  v23 = *((_QWORD *)v20 + 11);
  if (v23)
  {
    memcpy(*((void **)v20 + 12), *(const void **)(a2 + 96), 72 * v23);
    v20 = (char *)cf;
  }
  v24 = *((_QWORD *)v20 + 13);
  if (v24)
  {
    memcpy(*((void **)v20 + 14), *(const void **)(a2 + 112), 8 * v24);
    v20 = (char *)cf;
  }
  v25 = *(_OWORD *)(a2 + 124);
  *(_QWORD *)(v20 + 140) = *(_QWORD *)(a2 + 140);
  *(_OWORD *)(v20 + 124) = v25;
  v26 = *(_OWORD *)(a2 + 160);
  *((_QWORD *)v20 + 22) = *(_QWORD *)(a2 + 176);
  *((_OWORD *)v20 + 10) = v26;
  v27 = *(_OWORD *)(a2 + 184);
  *((_QWORD *)v20 + 25) = *(_QWORD *)(a2 + 200);
  *(_OWORD *)(v20 + 184) = v27;
  v28 = *(_OWORD *)(a2 + 208);
  *((_QWORD *)v20 + 28) = *(_QWORD *)(a2 + 224);
  *((_OWORD *)v20 + 13) = v28;
  if ((v12 & 1) == 0)
  {
    v29 = *(_QWORD *)(a2 + 336);
    if (v29)
    {
      if (*(_BYTE *)(a2 + 344))
      {
        memcpy(*((void **)v20 + 41), *(const void **)(a2 + 328), 16 * v29);
        v20 = (char *)cf;
        *((_BYTE *)cf + 344) = 1;
      }
    }
  }
  if (!*(_QWORD *)(a2 + 304))
  {
    v14 = 0;
    v30 = 0;
    goto LABEL_37;
  }
  v30 = *((_QWORD *)v20 + 10);
  v31 = (const void **)malloc_type_calloc(v30, 8uLL, 0x2004093837F09uLL);
  if (!v31)
  {
    v14 = (const void **)FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    v15 = cf;
    goto LABEL_51;
  }
  v14 = v31;
  if (v30 >= 1)
  {
    v32 = 0;
    do
    {
      v33 = CFGetAllocator(cf);
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 304), v32);
      MutableCopy = CFDictionaryCreateMutableCopy(v33, 0, ValueAtIndex);
      v14[v32] = MutableCopy;
      if (!MutableCopy)
        goto LABEL_35;
    }
    while (v30 != ++v32);
  }
  v36 = CFGetAllocator((CFTypeRef)a2);
  v37 = CFArrayCreate(v36, v14, v30, MEMORY[0x1E0C9B378]);
  v20 = (char *)cf;
  *((_QWORD *)cf + 38) = v37;
  if (!v37)
  {
LABEL_35:
    FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
LABEL_41:
    if (v30 >= 1)
    {
      v40 = v14;
      do
      {
        if (*v40)
          CFRelease(*v40);
        ++v40;
        --v30;
      }
      while (v30);
    }
    free(v14);
    v14 = 0;
    goto LABEL_47;
  }
LABEL_37:
  if (*(_QWORD *)(a2 + 312))
  {
    v38 = CFGetAllocator(v20);
    v39 = CFDictionaryCreateMutableCopy(v38, 0, *(CFDictionaryRef *)(a2 + 312));
    *((_QWORD *)cf + 39) = v39;
    if (!v39)
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
  }
  if (v14)
    goto LABEL_41;
LABEL_47:
  if (a4)
LABEL_48:
    *a4 = cf;
  return v14;
}

OSStatus CMSampleBufferCopySampleBufferForRange(CFAllocatorRef allocator, CMSampleBufferRef sbuf, CFRange sampleRange, CMSampleBufferRef *sampleBufferOut)
{
  CFIndex length;
  CFIndex location;
  const opaqueCMFormatDescription *v9;
  CMMediaType MediaType;
  _BOOL4 v11;
  uint64_t **v12;
  uint64_t v13;
  CFIndex v14;
  OSStatus v15;
  const void **v16;
  CMSampleTimingInfo *v17;
  uint64_t v18;
  CFTypeRef *v19;
  _BOOL4 v21;
  BOOL v22;
  unint64_t v23;
  unint64_t v24;
  OSStatus OutputSampleTimingInfoArray;
  OSStatus v26;
  unint64_t v27;
  CMBlockBufferRef *v28;
  CFTypeRef v29;
  size_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  uint64_t *v34;
  CFIndex v35;
  uint64_t v36;
  uint64_t *v37;
  CFIndex v38;
  uint64_t v39;
  OpaqueCMBlockBuffer *v40;
  BOOL v41;
  OSStatus v42;
  int v43;
  CFTypeRef v44;
  __n128 v45;
  uint64_t v46;
  CFTypeRef v47;
  uint64_t v48;
  size_t v49;
  CFIndex v50;
  CMTime *v51;
  __int128 *v52;
  __int128 v53;
  __int128 *v54;
  CMTime *v55;
  __int128 v56;
  uint64_t v57;
  size_t v58;
  CFIndex v59;
  uint64_t p_presentationTimeStamp;
  CFIndex v61;
  __int128 v62;
  __int128 v63;
  char *v64;
  __int128 v65;
  char *v66;
  uint64_t v67;
  const void **v68;
  CFMutableDictionaryRef *v69;
  uint64_t v70;
  const __CFAllocator *v71;
  const __CFDictionary *ValueAtIndex;
  CFMutableDictionaryRef v73;
  const __CFAllocator *v74;
  CFArrayRef v75;
  const __CFAllocator *v76;
  CFMutableDictionaryRef MutableCopy;
  const __CFDictionary *v78;
  CMTimeFlags flags;
  CMTimeEpoch epoch;
  CFDictionaryRef v81;
  CFDictionaryRef v82;
  const __CFDictionary *v83;
  CMTimeFlags v84;
  CMTimeEpoch v85;
  CFDictionaryRef v86;
  CFDictionaryRef v87;
  CFDictionaryRef v88;
  CFDictionaryRef v89;
  const __CFNumber *v90;
  CFNumberRef SInt64;
  CFNumberRef v92;
  char v93;
  const __CFAllocator *structureAllocator;
  BOOL v95;
  CMTime v96;
  CMTime v97;
  CMTime v98;
  CMTime v99;
  CMTime v100;
  CMTime time2;
  CMTime v102;
  CMTime lhs;
  CMTime rhs;
  CMTime time;
  CMItemCount timingArrayEntriesNeededOut;
  CMAttachmentMode attachmentModeOut;
  char *v108;
  CMTimeValue v109;
  CMTimeScale v110;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  v108 = 0;
  value = 0;
  timescale = 0;
  v109 = 0;
  v110 = 0;
  attachmentModeOut = 0;
  timingArrayEntriesNeededOut = 0;
  if (!sbuf || !sampleBufferOut)
  {
    v13 = 4294954565;
LABEL_18:
    v15 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
    v16 = 0;
    v17 = 0;
LABEL_19:
    v18 = 0;
    goto LABEL_20;
  }
  length = sampleRange.length;
  location = sampleRange.location;
  v9 = (const opaqueCMFormatDescription *)*((_QWORD *)sbuf + 9);
  if (!v9)
  {
    v12 = (uint64_t **)((char *)sbuf + 112);
    if (*((_QWORD *)sbuf + 14))
    {
      v11 = 0;
      goto LABEL_12;
    }
    goto LABEL_17;
  }
  MediaType = CMFormatDescriptionGetMediaType(v9);
  v11 = MediaType == 1936684398;
  v12 = (uint64_t **)((char *)sbuf + 112);
  if (!*((_QWORD *)sbuf + 14))
  {
    if (MediaType == 1936684398 && *((_QWORD *)sbuf + 41) && *((_BYTE *)sbuf + 344))
    {
      v11 = 1;
      goto LABEL_12;
    }
LABEL_17:
    v13 = 4294954561;
    goto LABEL_18;
  }
LABEL_12:
  if (location < 0 || (v14 = *((_QWORD *)sbuf + 10), location >= v14) || length < 0 || location + length > v14)
  {
    v13 = 4294954562;
    goto LABEL_18;
  }
  if (v11)
  {
    v21 = *((_QWORD *)sbuf + 42) != 0;
    v22 = *((_BYTE *)sbuf + 344) == 0;
  }
  else
  {
    v21 = 0;
    v22 = 1;
  }
  v95 = v22;
  if (length)
  {
    if (*((uint64_t *)sbuf + 11) <= 1)
      v23 = *((_QWORD *)sbuf + 11);
    else
      v23 = length;
    if (*((uint64_t *)sbuf + 13) <= 1)
      v24 = *((_QWORD *)sbuf + 13);
    else
      v24 = length;
  }
  else
  {
    v24 = 0;
    v23 = 0;
  }
  if (CMGetAttachment(sbuf, CFSTR("TrimDurationAtStart"), 0)
    || CMGetAttachment(sbuf, CFSTR("TrimDurationAtEnd"), 0)
    || CMGetAttachment(sbuf, CFSTR("SpeedMultiplier"), 0)
    || CMGetAttachment(sbuf, CFSTR("Reverse"), 0)
    || (*((_DWORD *)sbuf + 34) & 0x1D) == 1)
  {
    OutputSampleTimingInfoArray = CMSampleBufferGetOutputSampleTimingInfoArray(sbuf, 0, 0, &timingArrayEntriesNeededOut);
    if (OutputSampleTimingInfoArray)
    {
      v15 = OutputSampleTimingInfoArray;
      v18 = 0;
      v17 = 0;
LABEL_52:
      v16 = 0;
LABEL_21:
      if (v108)
        CFRelease(v108);
      v108 = 0;
LABEL_24:
      free(v17);
      if (!v16)
        goto LABEL_31;
      goto LABEL_25;
    }
    structureAllocator = allocator;
    v17 = (CMSampleTimingInfo *)malloc_type_malloc(72 * timingArrayEntriesNeededOut, 0x1000040FF89C88EuLL);
    if (!v17)
    {
      v15 = FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
      v16 = 0;
      goto LABEL_19;
    }
    v26 = CMSampleBufferGetOutputSampleTimingInfoArray(sbuf, timingArrayEntriesNeededOut, v17, 0);
    if (v26)
    {
LABEL_55:
      v15 = v26;
      v18 = 0;
      goto LABEL_52;
    }
    v93 = 0;
  }
  else
  {
    structureAllocator = allocator;
    v17 = 0;
    v93 = 1;
  }
  if (v21)
    v27 = length;
  else
    v27 = 0;
  v26 = sBufCreate((uint64_t)structureAllocator, v23, v24, v27, &v108);
  if (v26)
    goto LABEL_55;
  v28 = (CMBlockBufferRef *)v108;
  *((_DWORD *)v108 + 7) = *((_DWORD *)sbuf + 7);
  switch(*((_DWORD *)sbuf + 7))
  {
    case 0:
      v31 = *((_QWORD *)sbuf + 13);
      if (v31 < 1)
        goto LABEL_63;
      if (v31 == 1)
      {
        v32 = **v12;
        v30 = v32 * location;
        v33 = v32 * length;
      }
      else
      {
        v30 = 0;
        if (location)
        {
          v34 = *v12;
          v35 = location;
          do
          {
            v36 = *v34++;
            v30 += v36;
            --v35;
          }
          while (v35);
        }
        if (length < 1)
          break;
        v33 = 0;
        v37 = &(*v12)[location];
        v38 = length;
        do
        {
          v39 = *v37++;
          v33 += v39;
          --v38;
        }
        while (v38);
      }
      v40 = (OpaqueCMBlockBuffer *)*((_QWORD *)sbuf + 2);
      if (v40)
        v41 = v33 == 0;
      else
        v41 = 1;
      if (v41)
        break;
      if (length >= *((_QWORD *)sbuf + 10))
      {
        v29 = CFRetain(*((CFTypeRef *)sbuf + 2));
        v28 = (CMBlockBufferRef *)v108;
        goto LABEL_66;
      }
      v42 = CMBlockBufferCreateWithBufferReference(structureAllocator, v40, v30, v33, 0, v28 + 2);
      if (!v42)
      {
        v28 = (CMBlockBufferRef *)v108;
        break;
      }
      v18 = 0;
      v16 = 0;
      v15 = v42;
      goto LABEL_21;
    case 1:
    case 2:
    case 3:
LABEL_63:
      v29 = (CFTypeRef)*((_QWORD *)sbuf + 2);
      if (v29)
      {
        v29 = CFRetain(v29);
        v28 = (CMBlockBufferRef *)v108;
      }
      v30 = 0;
LABEL_66:
      v28[2] = (CMBlockBufferRef)v29;
      break;
    default:
      v30 = 0;
      break;
  }
  v43 = *((unsigned __int8 *)sbuf + 25);
  *((_BYTE *)v28 + 25) = v43;
  if (!v43)
  {
    CFRetain(sbuf);
    *((_QWORD *)v108 + 8) = sbuf;
  }
  v44 = FigFormatDescriptionRetain(*((CFTypeRef *)sbuf + 9));
  v46 = (uint64_t)v108;
  *((_QWORD *)v108 + 9) = v44;
  *(_QWORD *)(v46 + 80) = length;
  v47 = (CFTypeRef)*((_QWORD *)sbuf + 19);
  if (v47)
  {
    v47 = CFRetain(*((CFTypeRef *)sbuf + 19));
    v46 = (uint64_t)v108;
  }
  *(_QWORD *)(v46 + 152) = v47;
  v48 = *(_QWORD *)(v46 + 88);
  if (v48)
  {
    v49 = 72 * v48;
    v50 = *((_QWORD *)sbuf + 11) == 1 ? 0 : location;
    memcpy(*(void **)(v46 + 96), (const void *)(*((_QWORD *)sbuf + 12) + 72 * v50), v49);
    v46 = (uint64_t)v108;
    if (*((_QWORD *)sbuf + 11) == 1)
    {
      v51 = (CMTime *)*((_QWORD *)v108 + 12);
      v52 = (__int128 *)*((_QWORD *)sbuf + 12);
      v53 = *v52;
      time.epoch = *((_QWORD *)v52 + 2);
      *(_OWORD *)&time.value = v53;
      CMTimeMultiply(&rhs, &time, location);
      lhs = *(CMTime *)((_BYTE *)v52 + 1);
      CMTimeAdd(&time, &lhs, &rhs);
      v45 = *(__n128 *)&time.value;
      v51[1] = time;
      v54 = (__int128 *)*((_QWORD *)sbuf + 12);
      v46 = (uint64_t)v108;
      if ((*((_BYTE *)v54 + 60) & 1) != 0)
      {
        v55 = (CMTime *)*((_QWORD *)v108 + 12);
        v56 = *v54;
        time.epoch = *((_QWORD *)v54 + 2);
        *(_OWORD *)&time.value = v56;
        CMTimeMultiply(&v102, &time, location);
        lhs = *(CMTime *)((_BYTE *)v54 + 2);
        CMTimeAdd(&time, &lhs, &v102);
        v45 = *(__n128 *)&time.value;
        v55[2] = time;
        v46 = (uint64_t)v108;
      }
    }
  }
  v57 = *(_QWORD *)(v46 + 104);
  if (v57)
  {
    v58 = 8 * v57;
    if (*((_QWORD *)sbuf + 13) == 1)
      v59 = 0;
    else
      v59 = location;
    memcpy(*(void **)(v46 + 112), (const void *)(*((_QWORD *)sbuf + 14) + 8 * v59), v58);
    v46 = (uint64_t)v108;
  }
  sbufUpdateCachedTimestamps(v46, v45);
  if ((v93 & 1) == 0)
  {
    if (timingArrayEntriesNeededOut == *((_QWORD *)sbuf + 10))
    {
      memset(&time, 0, sizeof(time));
      if (length >= 1)
      {
        p_presentationTimeStamp = (uint64_t)&v17[location].presentationTimeStamp;
        v61 = location;
        do
        {
          v62 = *(_OWORD *)p_presentationTimeStamp;
          lhs.epoch = *(_QWORD *)(p_presentationTimeStamp + 16);
          *(_OWORD *)&lhs.value = v62;
          time2 = time;
          if (CMTimeCompare(&lhs, &time2) < 0)
          {
            v63 = *(_OWORD *)p_presentationTimeStamp;
            time.epoch = *(_QWORD *)(p_presentationTimeStamp + 16);
            *(_OWORD *)&time.value = v63;
          }
          ++v61;
          p_presentationTimeStamp += 72;
        }
        while (v61 < location + length);
      }
      *(CMTime *)(v108 + 124) = time;
    }
    else
    {
      v64 = v108;
      v65 = *(_OWORD *)&v17->duration.value;
      time.epoch = v17->duration.epoch;
      *(_OWORD *)&time.value = v65;
      CMTimeMultiply(&v100, &time, location);
      lhs = v17->presentationTimeStamp;
      CMTimeAdd(&time, &lhs, &v100);
      *(CMTime *)(v64 + 124) = time;
    }
  }
  if (!v95)
  {
    v66 = v108;
    if (*((_QWORD *)sbuf + 42))
    {
      memcpy(*((void **)v108 + 41), (const void *)(*((_QWORD *)sbuf + 41) + 16 * location), 16 * length);
      v66 = v108;
      if (*((uint64_t *)v108 + 13) >= 1 && length >= 1)
      {
        v67 = 0;
        do
        {
          *(_QWORD *)(*((_QWORD *)v66 + 41) + v67) -= v30;
          v67 += 16;
          --length;
        }
        while (length);
      }
    }
    v66[344] = 1;
  }
  if (!*((_QWORD *)sbuf + 38))
  {
    v16 = 0;
    v18 = 0;
LABEL_126:
    if (*((_QWORD *)sbuf + 39)
      && (v76 = CFGetAllocator(v108),
          MutableCopy = CFDictionaryCreateMutableCopy(v76, 0, *((CFDictionaryRef *)sbuf + 39)),
          (*((_QWORD *)v108 + 39) = MutableCopy) == 0))
    {
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      v78 = (const __CFDictionary *)CMGetAttachment(sbuf, CFSTR("TrimDurationAtStart"), &attachmentModeOut);
      CMTimeMakeFromDictionary(&time, v78);
      value = time.value;
      flags = time.flags;
      timescale = time.timescale;
      epoch = time.epoch;
      *(_OWORD *)&v99.value = *(_OWORD *)&kCMTimeZero.value;
      v99.epoch = 0;
      if ((time.flags & 1) != 0)
      {
        memset(&time, 0, sizeof(time));
        lhs = *(CMTime *)(v108 + 184);
        time2 = *(CMTime *)((char *)sbuf + 184);
        CMTimeSubtract(&time, &lhs, &time2);
        CMRemoveAttachment(v108, CFSTR("TrimDurationAtStart"));
        if ((time.flags & 1) != 0)
        {
          memset(&lhs, 0, sizeof(lhs));
          time2.value = value;
          time2.timescale = timescale;
          time2.flags = flags;
          time2.epoch = epoch;
          v98 = time;
          CMTimeSubtract(&lhs, &time2, &v98);
          *(_OWORD *)&time2.value = *(_OWORD *)&kCMTimeZero.value;
          time2.epoch = 0;
          v98 = lhs;
          if (CMTimeCompare(&time2, &v98) < 0)
          {
            time2 = lhs;
            v81 = CMTimeCopyAsDictionary(&time2, structureAllocator);
            if (!v81)
              goto LABEL_144;
            v82 = v81;
            CMSetAttachment(v108, CFSTR("TrimDurationAtStart"), v81, attachmentModeOut);
            CFRelease(v82);
            v99 = lhs;
          }
        }
      }
      v83 = (const __CFDictionary *)CMGetAttachment(sbuf, CFSTR("TrimDurationAtEnd"), &attachmentModeOut);
      CMTimeMakeFromDictionary(&time, v83);
      v109 = time.value;
      v84 = time.flags;
      v110 = time.timescale;
      if ((time.flags & 1) != 0)
      {
        v85 = time.epoch;
        memset(&time, 0, sizeof(time));
        lhs = *(CMTime *)(v108 + 184);
        time2 = *(CMTime *)(v108 + 208);
        CMTimeAdd(&v97, &lhs, &time2);
        lhs = *(CMTime *)((char *)sbuf + 184);
        time2 = *(CMTime *)((char *)sbuf + 208);
        CMTimeAdd(&v96, &lhs, &time2);
        CMTimeSubtract(&time, &v97, &v96);
        CMRemoveAttachment(v108, CFSTR("TrimDurationAtEnd"));
        if ((time.flags & 1) != 0)
        {
          memset(&lhs, 0, sizeof(lhs));
          time2.value = v109;
          time2.timescale = v110;
          time2.flags = v84;
          time2.epoch = v85;
          v98 = time;
          CMTimeAdd(&lhs, &time2, &v98);
          *(_OWORD *)&time2.value = *(_OWORD *)&kCMTimeZero.value;
          time2.epoch = 0;
          v98 = lhs;
          if (CMTimeCompare(&time2, &v98) < 0)
          {
            time2 = lhs;
            v86 = CMTimeCopyAsDictionary(&time2, structureAllocator);
            if (!v86)
              goto LABEL_144;
            v87 = v86;
            CMSetAttachment(v108, CFSTR("TrimDurationAtEnd"), v86, attachmentModeOut);
            CFRelease(v87);
            time2 = v99;
            v98 = lhs;
            CMTimeAdd(&v99, &time2, &v98);
          }
        }
      }
      time = v99;
      lhs = *(CMTime *)(v108 + 208);
      if ((CMTimeCompare(&time, &lhs) & 0x80000000) == 0)
      {
        CMRemoveAttachment(v108, CFSTR("TrimDurationAtStart"));
        CMRemoveAttachment(v108, CFSTR("TrimDurationAtEnd"));
        time = *(CMTime *)(v108 + 208);
        v88 = CMTimeCopyAsDictionary(&time, structureAllocator);
        if (!v88)
          goto LABEL_144;
        v89 = v88;
        CMSetAttachment(v108, CFSTR("TrimDurationAtStart"), v88, attachmentModeOut);
        CFRelease(v89);
      }
      v90 = (const __CFNumber *)CMGetAttachment(sbuf, CFSTR("SampleReferenceByteOffset"), &attachmentModeOut);
      if (v90)
      {
        time.value = 0;
        CFNumberGetValue(v90, kCFNumberSInt64Type, &time);
        time.value += v30;
        SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], time.value);
        if (SInt64)
        {
          v92 = SInt64;
          CMSetAttachment(v108, CFSTR("SampleReferenceByteOffset"), SInt64, attachmentModeOut);
          CFRelease(v92);
          v15 = 0;
          goto LABEL_20;
        }
LABEL_144:
        v15 = FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
LABEL_20:
        if (!v15)
          goto LABEL_24;
        goto LABEL_21;
      }
    }
    v15 = 0;
    goto LABEL_24;
  }
  v18 = *((_QWORD *)v108 + 10);
  v68 = (const void **)malloc_type_calloc(v18, 8uLL, 0x2004093837F09uLL);
  v16 = v68;
  if (!v68)
    goto LABEL_144;
  if (v18 >= 1)
  {
    v69 = (CFMutableDictionaryRef *)v68;
    v70 = v18;
    do
    {
      v71 = CFGetAllocator(v108);
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*((CFArrayRef *)sbuf + 38), location);
      v73 = CFDictionaryCreateMutableCopy(v71, 0, ValueAtIndex);
      *v69 = v73;
      if (!v73)
        goto LABEL_124;
      ++v69;
      ++location;
    }
    while (--v70);
  }
  v74 = CFGetAllocator(sbuf);
  v75 = CFArrayCreate(v74, v16, v18, MEMORY[0x1E0C9B378]);
  *((_QWORD *)v108 + 38) = v75;
  if (v75)
    goto LABEL_126;
LABEL_124:
  FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
  free(v17);
  v15 = 0;
LABEL_25:
  if (v18 >= 1)
  {
    v19 = v16;
    do
    {
      if (*v19)
        CFRelease(*v19);
      ++v19;
      --v18;
    }
    while (v18);
  }
  free(v16);
LABEL_31:
  if (sampleBufferOut)
    *sampleBufferOut = (CMSampleBufferRef)v108;
  return v15;
}

OSStatus CMSampleBufferGetOutputSampleTimingInfoArray(CMSampleBufferRef sbuf, CMItemCount timingArrayEntries, CMSampleTimingInfo *timingArrayOut, CMItemCount *timingArrayEntriesNeededOut)
{
  OSStatus result;
  uint64_t v7;
  CMTimeFlags v10;
  CMTimeEpoch epoch;
  const __CFDictionary *v12;
  CMTimeFlags flags;
  const __CFDictionary *v14;
  unint64_t v16;
  CMSampleTimingInfo *v17;
  CMSampleTimingInfo *v18;
  __int128 *v19;
  __int128 v20;
  __int128 *v21;
  __int128 v22;
  CMSampleTimingInfo *v23;
  CMTime *p_duration;
  CMTimeEpoch v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  CFTypeID TypeID;
  CMSampleTimingInfo *v29;
  double v30;
  const __CFBoolean *v31;
  const __CFBoolean *v32;
  CFTypeID v33;
  int v34;
  CMSampleTimingInfo *v35;
  CMTime *v36;
  CMTimeEpoch v37;
  uint64_t v38;
  CMTimeEpoch v39;
  CMTime v40;
  CMTime v41;
  CMTime time;
  CMTime v43;
  CMTime lhs;
  CMTime time2;
  CMTime time1;
  CMTime rhs;
  CMTimeValue v48;
  CMTimeScale v49;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  value = 0;
  timescale = 0;
  v48 = 0;
  v49 = 0;
  if (*((_BYTE *)sbuf + 24))
    return FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
  v7 = *((_QWORD *)sbuf + 11);
  if (v7 && *((_QWORD *)sbuf + 12))
  {
    v10 = 0;
    epoch = 0;
    v12 = (const __CFDictionary *)CMGetAttachment(sbuf, CFSTR("TrimDurationAtStart"), 0);
    flags = 0;
    v39 = 0;
    if (v12)
    {
      CMTimeMakeFromDictionary(&time1, v12);
      value = time1.value;
      flags = time1.flags;
      timescale = time1.timescale;
      epoch = time1.epoch;
    }
    v14 = (const __CFDictionary *)CMGetAttachment(sbuf, CFSTR("TrimDurationAtEnd"), 0);
    if (v14)
    {
      CMTimeMakeFromDictionary(&time1, v14);
      v48 = time1.value;
      v10 = time1.flags;
      v49 = time1.timescale;
      v39 = time1.epoch;
    }
    if (*((_QWORD *)sbuf + 10) > v7 && ((v10 & 0x1D) == 1 || (flags & 0x1D) == 1))
      v7 = *((_QWORD *)sbuf + 10);
    if (timingArrayEntriesNeededOut)
      *timingArrayEntriesNeededOut = v7;
    if (!timingArrayOut)
      return 0;
    if (v7 > timingArrayEntries)
      return FigSignalErrorAt(4294954559, 0, 0, 0, 0, 0, 0);
    v16 = *((_QWORD *)sbuf + 10);
    if (v16 <= 1)
    {
      CMSampleBufferGetOutputDuration(&time1, sbuf);
      timingArrayOut->duration = time1;
      CMSampleBufferGetOutputPresentationTimeStamp(&time1, sbuf);
      timingArrayOut->presentationTimeStamp = time1;
      CMSampleBufferGetOutputDecodeTimeStamp(&time1, sbuf);
      result = 0;
      timingArrayOut->decodeTimeStamp = time1;
      return result;
    }
    v17 = &timingArrayOut[v7];
    v38 = v7;
    if (*((_QWORD *)sbuf + 11) == v16)
    {
      memcpy(timingArrayOut, *((const void **)sbuf + 12), 72 * v16);
    }
    else
    {
      *(_OWORD *)&time1.value = *(_OWORD *)&kCMTimeZero.value;
      time1.epoch = 0;
      if (v7 >= 1)
      {
        v18 = timingArrayOut;
        do
        {
          v19 = (__int128 *)*((_QWORD *)sbuf + 12);
          v20 = *v19;
          v18->duration.epoch = *((_QWORD *)v19 + 2);
          *(_OWORD *)&v18->duration.value = v20;
          lhs = *(CMTime *)(*((_QWORD *)sbuf + 12) + 24);
          rhs = time1;
          CMTimeAdd(&time2, &lhs, &rhs);
          v18->presentationTimeStamp = time2;
          *(_OWORD *)&v18->decodeTimeStamp.value = *(_OWORD *)&kCMTimeInvalid.value;
          v18->decodeTimeStamp.epoch = 0;
          v21 = (__int128 *)*((_QWORD *)sbuf + 12);
          time2 = time1;
          v22 = *v21;
          lhs.epoch = *((_QWORD *)v21 + 2);
          *(_OWORD *)&lhs.value = v22;
          CMTimeAdd(&time1, &time2, &lhs);
          ++v18;
        }
        while (v18 < v17);
      }
    }
    if ((flags & 0x1D) == 1)
    {
      rhs.value = value;
      rhs.timescale = timescale;
      if (v7 >= 1)
      {
        v23 = timingArrayOut;
        while (1)
        {
          time1 = v23->duration;
          time2.value = rhs.value;
          time2.timescale = rhs.timescale;
          time2.flags = flags;
          time2.epoch = epoch;
          if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
            break;
          time2 = v23->presentationTimeStamp;
          lhs.value = rhs.value;
          lhs.timescale = rhs.timescale;
          lhs.flags = flags;
          lhs.epoch = epoch;
          CMTimeAdd(&time1, &time2, &lhs);
          v23->presentationTimeStamp = time1;
          time2 = v23->decodeTimeStamp;
          lhs.value = rhs.value;
          lhs.timescale = rhs.timescale;
          lhs.flags = flags;
          lhs.epoch = epoch;
          CMTimeAdd(&time1, &time2, &lhs);
          v23->decodeTimeStamp = time1;
          time2.value = rhs.value;
          time2.timescale = rhs.timescale;
          time2.flags = flags;
          time2.epoch = epoch;
          lhs = v23->duration;
          CMTimeSubtract(&time1, &time2, &lhs);
          rhs.value = time1.value;
          flags = time1.flags;
          rhs.timescale = time1.timescale;
          epoch = time1.epoch;
          *(_OWORD *)&v23->duration.value = *(_OWORD *)&kCMTimeZero.value;
          v23->duration.epoch = 0;
          if (++v23 >= v17)
            goto LABEL_37;
        }
        time2 = v23->presentationTimeStamp;
        lhs.value = rhs.value;
        lhs.timescale = rhs.timescale;
        lhs.flags = flags;
        lhs.epoch = epoch;
        CMTimeAdd(&time1, &time2, &lhs);
        v23->presentationTimeStamp = time1;
        time2 = v23->decodeTimeStamp;
        lhs.value = rhs.value;
        lhs.timescale = rhs.timescale;
        lhs.flags = flags;
        lhs.epoch = epoch;
        CMTimeAdd(&time1, &time2, &lhs);
        v23->decodeTimeStamp = time1;
        time2 = v23->duration;
        lhs.value = rhs.value;
        lhs.timescale = rhs.timescale;
        lhs.flags = flags;
        lhs.epoch = epoch;
        CMTimeSubtract(&time1, &time2, &lhs);
        v23->duration = time1;
      }
    }
LABEL_37:
    if ((v10 & 0x1D) == 1)
    {
      rhs.value = v48;
      rhs.timescale = v49;
      p_duration = &v17[-1].duration;
      v25 = v39;
      if (&v17[-1] >= timingArrayOut)
      {
        while (1)
        {
          time1 = *p_duration;
          time2.value = rhs.value;
          time2.timescale = rhs.timescale;
          time2.flags = v10;
          time2.epoch = v25;
          if ((CMTimeCompare(&time1, &time2) & 0x80000000) == 0)
            break;
          time2.value = rhs.value;
          time2.timescale = rhs.timescale;
          time2.flags = v10;
          time2.epoch = v25;
          lhs = *p_duration;
          CMTimeSubtract(&time1, &time2, &lhs);
          rhs.value = time1.value;
          v10 = time1.flags;
          rhs.timescale = time1.timescale;
          v25 = time1.epoch;
          *(_OWORD *)&p_duration->value = *(_OWORD *)&kCMTimeZero.value;
          p_duration->epoch = 0;
          p_duration -= 3;
          if (p_duration < (CMTime *)timingArrayOut)
            goto LABEL_43;
        }
        time2 = *p_duration;
        lhs.value = rhs.value;
        lhs.timescale = rhs.timescale;
        lhs.flags = v10;
        lhs.epoch = v25;
        CMTimeSubtract(&time1, &time2, &lhs);
        *p_duration = time1;
      }
    }
LABEL_43:
    v26 = (const __CFNumber *)CMGetAttachment(sbuf, CFSTR("SpeedMultiplier"), 0);
    if (v26)
    {
      v27 = v26;
      TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v27))
      {
        time1 = timingArrayOut->presentationTimeStamp;
        rhs.value = 0x3FF0000000000000;
        CFNumberGetValue(v27, kCFNumberDoubleType, &rhs);
        if (v38 >= 1)
        {
          v29 = timingArrayOut;
          v30 = 1.0 / *(double *)&rhs.value;
          do
          {
            lhs = v29->duration;
            CMTimeMultiplyByFloat64(&time2, &lhs, v30);
            v29->duration = time2;
            time2 = v29->presentationTimeStamp;
            lhs = time1;
            CMTimeSubtract(&time, &time2, &lhs);
            CMTimeMultiplyByFloat64(&v43, &time, v30);
            lhs = time1;
            CMTimeAdd(&time2, &v43, &lhs);
            v29->presentationTimeStamp = time2;
            time2 = v29->decodeTimeStamp;
            lhs = time1;
            CMTimeSubtract(&v40, &time2, &lhs);
            CMTimeMultiplyByFloat64(&v41, &v40, v30);
            lhs = time1;
            CMTimeAdd(&time2, &v41, &lhs);
            v29->decodeTimeStamp = time2;
            ++v29;
          }
          while (v29 < v17);
        }
      }
    }
    v31 = (const __CFBoolean *)CMGetAttachment(sbuf, CFSTR("Reverse"), 0);
    if (v31 && (v32 = v31, v33 = CFBooleanGetTypeID(), v33 == CFGetTypeID(v32)))
    {
      v34 = CFBooleanGetValue(v32);
      if (v34 && v38 >= 1)
      {
        v35 = timingArrayOut;
        do
        {
          time2 = v35->presentationTimeStamp;
          lhs = v35->duration;
          CMTimeAdd(&time1, &time2, &lhs);
          v35->presentationTimeStamp = time1;
          ++v35;
        }
        while (v35 < v17);
      }
      if ((*((_DWORD *)sbuf + 34) & 0x1D) != 1)
        return 0;
      v36 = (CMTime *)((char *)sbuf + 124);
      memset(&time1, 0, sizeof(time1));
      if (v34)
      {
        *(_OWORD *)&time2.value = *(_OWORD *)&v36->value;
        time2.epoch = *(_QWORD *)((char *)sbuf + 140);
        *(_OWORD *)&lhs.value = *(_OWORD *)&v17[-1].presentationTimeStamp.value;
        v37 = v17[-1].presentationTimeStamp.epoch;
        goto LABEL_60;
      }
    }
    else
    {
      if ((*((_DWORD *)sbuf + 34) & 0x1D) != 1)
        return 0;
      v36 = (CMTime *)((char *)sbuf + 124);
      memset(&time1, 0, sizeof(time1));
    }
    time2 = *v36;
    *(_OWORD *)&lhs.value = *(_OWORD *)&timingArrayOut->presentationTimeStamp.value;
    v37 = timingArrayOut->presentationTimeStamp.epoch;
LABEL_60:
    lhs.epoch = v37;
    CMTimeSubtract(&time1, &time2, &lhs);
    if (v38 >= 1)
    {
      do
      {
        lhs = timingArrayOut->presentationTimeStamp;
        rhs = time1;
        CMTimeAdd(&time2, &lhs, &rhs);
        timingArrayOut->presentationTimeStamp = time2;
        lhs = timingArrayOut->decodeTimeStamp;
        rhs = time1;
        CMTimeAdd(&time2, &lhs, &rhs);
        timingArrayOut->decodeTimeStamp = time2;
        ++timingArrayOut;
      }
      while (timingArrayOut < v17);
    }
    return 0;
  }
  if (timingArrayEntriesNeededOut)
    *timingArrayEntriesNeededOut = 0;
  return -12736;
}

OSStatus CMSampleBufferSetDataBuffer(CMSampleBufferRef sbuf, CMBlockBufferRef dataBuffer)
{
  uint64_t v2;

  if (!sbuf || !dataBuffer)
  {
    v2 = 4294954565;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((_DWORD *)sbuf + 7) || *((_QWORD *)sbuf + 2))
  {
    v2 = 4294954564;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  *((_QWORD *)sbuf + 2) = CFRetain(dataBuffer);
  return 0;
}

CMBlockBufferRef CMSampleBufferGetDataBuffer(CMSampleBufferRef sbuf)
{
  uint64_t v1;

  if (!sbuf)
  {
    v1 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v1 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v1, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (!*((_DWORD *)sbuf + 7))
    return (CMBlockBufferRef)*((_QWORD *)sbuf + 2);
  return 0;
}

CVImageBufferRef CMSampleBufferGetImageBuffer(CMSampleBufferRef sbuf)
{
  uint64_t v1;

  if (!sbuf)
  {
    v1 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v1 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v1, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*((_DWORD *)sbuf + 7) == 1)
    return (CVImageBufferRef)*((_QWORD *)sbuf + 2);
  return 0;
}

uint64_t FigSampleBufferGetCaptionGroup(uint64_t a1)
{
  uint64_t v2;

  if (!a1)
  {
    v2 = 4294954565;
LABEL_7:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*(_BYTE *)(a1 + 24))
  {
    v2 = 4294954552;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 28) == 2)
    return *(_QWORD *)(a1 + 16);
  return 0;
}

uint64_t FigSampleBufferGetTaggedBufferGroup(uint64_t a1)
{
  uint64_t v2;

  if (!a1)
  {
    v2 = 4294954565;
LABEL_7:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*(_BYTE *)(a1 + 24))
  {
    v2 = 4294954552;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 28) == 3)
    return *(_QWORD *)(a1 + 16);
  return 0;
}

CMTaggedBufferGroupRef CMSampleBufferGetTaggedBufferGroup(CMSampleBufferRef sbuf)
{
  uint64_t v2;

  if (!sbuf)
  {
    v2 = 4294954565;
LABEL_7:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
    goto LABEL_7;
  }
  if (*((_DWORD *)sbuf + 7) == 3)
    return (CMTaggedBufferGroupRef)*((_QWORD *)sbuf + 2);
  return 0;
}

OSStatus CMSampleBufferSetDataReady(CMSampleBufferRef sbuf)
{
  uint64_t v2;
  int v4;
  __CFNotificationCenter *DefaultLocalCenter;

  if (!sbuf)
  {
    v2 = 4294954565;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 26))
  {
    v2 = *((unsigned int *)sbuf + 12);
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  v4 = *((unsigned __int8 *)sbuf + 25);
  *((_BYTE *)sbuf + 25) = 1;
  figSampleBufferCheckDataSize((size_t)sbuf);
  if (!v4)
  {
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("FigSampleBufferDataBecameReady"), sbuf, 0);
  }
  return 0;
}

uint64_t CMSampleBufferSetDataReadyWithNewSize(uint64_t a1, uint64_t a2, const void *a3)
{
  void *v6;
  uint64_t v8;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 104) || *(_QWORD *)(a1 + 112))
    {
      v8 = 4294954556;
      return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
    }
    if (a2 > 0 && a3)
    {
      v6 = malloc_type_malloc(8 * a2, 0x1DDE389AuLL);
      *(_QWORD *)(a1 + 112) = v6;
      *(_BYTE *)(a1 + 120) = 1;
      memcpy(v6, a3, 8 * a2);
      *(_QWORD *)(a1 + 104) = a2;
      return CMSampleBufferSetDataReady((CMSampleBufferRef)a1);
    }
  }
  v8 = 4294954565;
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

Boolean CMSampleBufferDataIsReady(CMSampleBufferRef sbuf)
{
  uint64_t v2;
  int IsReady;
  opaqueCMSampleBuffer *v5;
  const void *v6;

  if (!sbuf)
  {
    v2 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
LABEL_6:
    LOBYTE(IsReady) = 0;
    return IsReady;
  }
  if (*((_BYTE *)sbuf + 26))
    goto LABEL_6;
  v5 = (opaqueCMSampleBuffer *)*((_QWORD *)sbuf + 8);
  if (v5)
  {
    IsReady = CMSampleBufferDataIsReady(v5);
    if (IsReady)
    {
      CMSampleBufferSetDataReady(sbuf);
      v6 = (const void *)*((_QWORD *)sbuf + 8);
      if (v6)
        CFRelease(v6);
      *((_QWORD *)sbuf + 8) = 0;
    }
  }
  else
  {
    LOBYTE(IsReady) = *((_BYTE *)sbuf + 25);
  }
  return IsReady;
}

OSStatus CMSampleBufferSetDataFailed(CMSampleBufferRef sbuf, OSStatus status)
{
  uint64_t v3;
  OSStatus v6;
  CFMutableDictionaryRef Mutable;
  __CFNotificationCenter *DefaultLocalCenter;

  if (!sbuf)
  {
    v3 = 4294954565;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v3 = 4294954552;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 25))
  {
    v3 = 4294954564;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 26))
  {
    v3 = 4294950546;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 27))
  {
    _Block_release(*((const void **)sbuf + 6));
    *((_QWORD *)sbuf + 6) = 0;
    *((_BYTE *)sbuf + 27) = 0;
  }
  *((_BYTE *)sbuf + 26) = 1;
  if (status)
    v6 = status;
  else
    v6 = -16750;
  *((_DWORD *)sbuf + 12) = v6;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32(Mutable, CFSTR("OSStatus"), v6);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("CMSampleBufferDataFailed"), sbuf, Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return 0;
}

Boolean CMSampleBufferHasDataFailed(CMSampleBufferRef sbuf, OSStatus *statusOut)
{
  uint64_t v3;
  int HasDataFailed;
  opaqueCMSampleBuffer *v7;
  const void *v8;
  OSStatus statusOuta;

  if (!sbuf)
  {
    v3 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v3 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
LABEL_6:
    LOBYTE(HasDataFailed) = 0;
    return HasDataFailed;
  }
  if (*((_BYTE *)sbuf + 25))
    goto LABEL_6;
  v7 = (opaqueCMSampleBuffer *)*((_QWORD *)sbuf + 8);
  if (v7)
  {
    statusOuta = 0;
    HasDataFailed = CMSampleBufferHasDataFailed(v7, &statusOuta);
    if (HasDataFailed)
    {
      CMSampleBufferSetDataFailed(sbuf, statusOuta);
      v8 = (const void *)*((_QWORD *)sbuf + 8);
      if (v8)
      {
        CFRelease(v8);
        *((_QWORD *)sbuf + 8) = 0;
      }
    }
  }
  else
  {
    HasDataFailed = *((unsigned __int8 *)sbuf + 26);
  }
  if (statusOut && HasDataFailed)
    *statusOut = *((_DWORD *)sbuf + 12);
  return HasDataFailed;
}

OSStatus CMSampleBufferMakeDataReady(CMSampleBufferRef sbuf)
{
  uint64_t v2;
  opaqueCMSampleBuffer *v4;
  uint64_t v5;
  const void *v6;
  uint64_t (**v7)(_QWORD, _QWORD);

  if (!sbuf)
  {
    v2 = 4294954565;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  v4 = (opaqueCMSampleBuffer *)*((_QWORD *)sbuf + 8);
  if (v4)
  {
    LODWORD(v5) = CMSampleBufferMakeDataReady(v4);
    if (!(_DWORD)v5)
    {
      v6 = (const void *)*((_QWORD *)sbuf + 8);
      if (v6)
        CFRelease(v6);
      LODWORD(v5) = 0;
      *((_QWORD *)sbuf + 8) = 0;
      *((_BYTE *)sbuf + 25) = 1;
    }
    return v5;
  }
  if (!*((_BYTE *)sbuf + 25))
  {
    if (*((_BYTE *)sbuf + 26))
    {
      LODWORD(v5) = *((_DWORD *)sbuf + 12);
      return v5;
    }
    v7 = (uint64_t (**)(_QWORD, _QWORD))*((_QWORD *)sbuf + 6);
    if (*((_BYTE *)sbuf + 27))
    {
      if (v7)
      {
        *((_QWORD *)sbuf + 6) = 0;
        *((_BYTE *)sbuf + 27) = 0;
        v5 = ((uint64_t (**)(_QWORD, CMSampleBufferRef))v7)[2](v7, sbuf);
        _Block_release(v7);
        goto LABEL_21;
      }
    }
    else if (v7)
    {
      v5 = ((uint64_t (*)(CMSampleBufferRef, _QWORD))v7)(sbuf, *((_QWORD *)sbuf + 7));
LABEL_21:
      if ((_DWORD)v5)
      {
        FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        *((_BYTE *)sbuf + 25) = 1;
        figSampleBufferCheckDataSize((size_t)sbuf);
      }
      return v5;
    }
    v2 = 4294954563;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  LODWORD(v5) = 0;
  return v5;
}

OSStatus CMSampleBufferTrackDataReadiness(CMSampleBufferRef sbuf, CMSampleBufferRef sampleBufferToTrack)
{
  uint64_t v3;
  CMSampleBufferRef v5;
  const void *v6;

  if (!sbuf)
  {
    v3 = 4294954565;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24) || sampleBufferToTrack && *((_BYTE *)sampleBufferToTrack + 24))
  {
    v3 = 4294954552;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 25))
  {
    v3 = 4294954564;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 26))
  {
    v3 = *((unsigned int *)sbuf + 12);
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  if (sbuf == sampleBufferToTrack)
    v5 = 0;
  else
    v5 = sampleBufferToTrack;
  v6 = (const void *)*((_QWORD *)sbuf + 8);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)sbuf + 8) = 0;
  if (!v5)
    goto LABEL_21;
  if (!CMSampleBufferDataIsReady(v5))
  {
    CFRetain(v5);
LABEL_21:
    *((_QWORD *)sbuf + 8) = v5;
    return 0;
  }
  *((_BYTE *)sbuf + 25) = 1;
  figSampleBufferCheckDataSize((size_t)sbuf);
  return 0;
}

OSStatus CMSampleBufferInvalidate(CMSampleBufferRef sbuf)
{
  uint64_t v2;
  void (*v4)(CMSampleBufferRef, _QWORD);

  if (!sbuf)
  {
    v2 = 4294954565;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  v4 = (void (*)(CMSampleBufferRef, _QWORD))*((_QWORD *)sbuf + 4);
  if (v4)
  {
    if (v4 == (void (*)(CMSampleBufferRef, _QWORD))1)
      (*(void (**)(_QWORD, CMSampleBufferRef))(*((_QWORD *)sbuf + 5) + 16))(*((_QWORD *)sbuf + 5), sbuf);
    else
      v4(sbuf, *((_QWORD *)sbuf + 5));
  }
  *((_BYTE *)sbuf + 24) = 1;
  return 0;
}

Boolean CMSampleBufferIsValid(CMSampleBufferRef sbuf)
{
  if (sbuf)
    LOBYTE(sbuf) = *((_BYTE *)sbuf + 24) == 0;
  return sbuf;
}

OSStatus CMSampleBufferSetInvalidateCallback(CMSampleBufferRef sbuf, CMSampleBufferInvalidateCallback invalidateCallback, uint64_t invalidateRefCon)
{
  uint64_t v4;
  uint64_t v7;

  if (!sbuf)
    goto LABEL_6;
  if (*((_BYTE *)sbuf + 24))
  {
    v4 = 4294954552;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  v7 = *((_QWORD *)sbuf + 4);
  if (invalidateCallback)
  {
    if (v7)
    {
LABEL_6:
      v4 = 4294954565;
      return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
    }
  }
  else if (v7 == 1)
  {
    _Block_release(*((const void **)sbuf + 5));
  }
  *((_QWORD *)sbuf + 4) = invalidateCallback;
  *((_QWORD *)sbuf + 5) = invalidateRefCon;
  return 0;
}

OSStatus CMSampleBufferSetInvalidateHandler(CMSampleBufferRef sbuf, CMSampleBufferInvalidateHandler invalidateHandler)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v7;
  void *v8;

  if (!sbuf)
    goto LABEL_6;
  if (*((_BYTE *)sbuf + 24))
  {
    v3 = 4294954552;
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  }
  v5 = *((_QWORD *)sbuf + 4);
  if (invalidateHandler)
  {
    if (v5)
    {
LABEL_6:
      v3 = 4294954565;
      return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    }
    v7 = 1;
  }
  else
  {
    if (v5 == 1)
      _Block_release(*((const void **)sbuf + 5));
    v7 = 0;
  }
  v8 = _Block_copy(invalidateHandler);
  *((_QWORD *)sbuf + 4) = v7;
  *((_QWORD *)sbuf + 5) = v8;
  return 0;
}

CMItemCount CMSampleBufferGetNumSamples(CMSampleBufferRef sbuf)
{
  uint64_t v1;

  if (!sbuf)
  {
    v1 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v1 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v1, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return *((_QWORD *)sbuf + 10);
}

CMTime *__cdecl CMSampleBufferGetDuration(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  uint64_t v2;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!sbuf)
  {
    v2 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (LOBYTE(sbuf[1].value))
  {
    v2 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (!sbuf[4].value)
    return CMTimeMake(retstr, 0, 1);
  *retstr = *(CMTime *)((char *)sbuf + 208);
  return sbuf;
}

CMTime *__cdecl CMSampleBufferGetPresentationTimeStamp(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  uint64_t v2;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!sbuf)
  {
    v2 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (LOBYTE(sbuf[1].value))
  {
    v2 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (sbuf[4].value)
    *retstr = *(CMTime *)((char *)sbuf + 184);
  return sbuf;
}

CMTime *__cdecl CMSampleBufferGetDecodeTimeStamp(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  uint64_t v2;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!sbuf)
  {
    v2 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (LOBYTE(sbuf[1].value))
  {
    v2 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (sbuf[4].value)
    *retstr = *(CMTime *)((char *)sbuf + 160);
  return sbuf;
}

CMTime *__cdecl CMSampleBufferGetOutputDuration(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  CMTime *v3;
  uint64_t v4;
  CMTimeEpoch *p_epoch;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  CMTime *v8;
  CMTime *TypeID;
  CMTime v10;
  CMTime lhs;
  CMTime time;
  CMTime v13;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!sbuf)
  {
    v4 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  v3 = sbuf;
  if (LOBYTE(sbuf[1].value))
  {
    v4 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  p_epoch = &sbuf[11].epoch;
  if ((HIDWORD(sbuf[12].value) & 0x1D) == 1)
  {
    *(_OWORD *)&retstr->value = *(_OWORD *)p_epoch;
    retstr->epoch = *(_QWORD *)&sbuf[12].timescale;
  }
  else
  {
    sbuf = CMSampleBufferGetDuration(retstr, (CMSampleBufferRef)sbuf);
    if ((retstr->flags & 0x1D) == 1)
    {
      v6 = (const __CFDictionary *)CMGetAttachment(v3, CFSTR("TrimDurationAtStart"), 0);
      v7 = (const __CFDictionary *)CMGetAttachment(v3, CFSTR("TrimDurationAtEnd"), 0);
      sbuf = (CMTime *)CMGetAttachment(v3, CFSTR("SpeedMultiplier"), 0);
      v8 = sbuf;
      if (v6)
      {
        memset(&v13, 0, sizeof(v13));
        CMTimeMakeFromDictionary(&v13, v6);
        lhs = *retstr;
        v10 = v13;
        sbuf = CMTimeSubtract(&time, &lhs, &v10);
        *retstr = time;
      }
      if (v7)
      {
        memset(&v13, 0, sizeof(v13));
        CMTimeMakeFromDictionary(&v13, v7);
        lhs = *retstr;
        v10 = v13;
        sbuf = CMTimeSubtract(&time, &lhs, &v10);
        *retstr = time;
      }
      if (v8)
      {
        TypeID = (CMTime *)CFNumberGetTypeID();
        sbuf = (CMTime *)CFGetTypeID(v8);
        if (TypeID == sbuf)
        {
          lhs.value = 0x3FF0000000000000;
          CFNumberGetValue((CFNumberRef)v8, kCFNumberDoubleType, &lhs);
          time = *retstr;
          sbuf = CMTimeMultiplyByFloat64(&v13, &time, 1.0 / *(double *)&lhs.value);
          *retstr = v13;
        }
      }
    }
    *(_OWORD *)p_epoch = *(_OWORD *)&retstr->value;
    p_epoch[2] = retstr->epoch;
  }
  return sbuf;
}

CMTime *__cdecl CMSampleBufferGetOutputPresentationTimeStamp(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  CMTime *v3;
  uint64_t v4;
  CMTimeEpoch epoch;
  CFTypeRef v6;
  CFTypeID TypeID;
  const __CFDictionary *v8;
  CMTime v9;
  CMTime v10;
  CMTime rhs;
  CMTime lhs;
  CMTime v13;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!sbuf)
  {
    v4 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  v3 = sbuf;
  if (LOBYTE(sbuf[1].value))
  {
    v4 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if ((sbuf[5].epoch & 0x1D) == 1)
  {
    *(_OWORD *)&retstr->value = *(_OWORD *)((char *)&sbuf[5].value + 4);
    epoch = *(CMTimeEpoch *)((char *)&sbuf[5].epoch + 4);
    goto LABEL_8;
  }
  if ((HIDWORD(sbuf[11].value) & 0x1D) != 1)
  {
    v6 = CMGetAttachment(sbuf, CFSTR("Reverse"), 0);
    CMSampleBufferGetPresentationTimeStamp(retstr, (CMSampleBufferRef)v3);
    if (!v6 || (TypeID = CFBooleanGetTypeID(), TypeID != CFGetTypeID(v6)) || !CFBooleanGetValue((CFBooleanRef)v6))
    {
      sbuf = (CMTime *)CMGetAttachment(v3, CFSTR("TrimDurationAtStart"), 0);
      if (sbuf)
      {
        memset(&v13, 0, sizeof(v13));
        CMTimeMakeFromDictionary(&v13, (CFDictionaryRef)sbuf);
        lhs = *retstr;
        rhs = v13;
        sbuf = CMTimeAdd(retstr, &lhs, &rhs);
      }
      goto LABEL_9;
    }
    memset(&v13, 0, sizeof(v13));
    CMSampleBufferGetDuration(&v13, (CMSampleBufferRef)v3);
    v8 = (const __CFDictionary *)CMGetAttachment(v3, CFSTR("TrimDurationAtEnd"), 0);
    lhs = *retstr;
    rhs = v13;
    sbuf = CMTimeAdd(retstr, &lhs, &rhs);
    if (!v8)
    {
LABEL_9:
      *(_OWORD *)&v3[10].epoch = *(_OWORD *)&retstr->value;
      *(_QWORD *)&v3[11].timescale = retstr->epoch;
      return sbuf;
    }
    memset(&lhs, 0, sizeof(lhs));
    CMTimeMakeFromDictionary(&lhs, v8);
    v10 = *retstr;
    v9 = lhs;
    sbuf = CMTimeSubtract(&rhs, &v10, &v9);
    *(_OWORD *)&retstr->value = *(_OWORD *)&rhs.value;
    epoch = rhs.epoch;
LABEL_8:
    retstr->epoch = epoch;
    goto LABEL_9;
  }
  *retstr = *(CMTime *)((char *)sbuf + 256);
  return sbuf;
}

OSStatus CMSampleBufferSetOutputPresentationTimeStamp(CMSampleBufferRef sbuf, CMTime *outputPresentationTimeStamp)
{
  uint64_t v2;
  __int128 v4;

  if (!sbuf)
  {
    v2 = 4294954565;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
    return FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  }
  v4 = *(_OWORD *)&outputPresentationTimeStamp->value;
  *(_QWORD *)((char *)sbuf + 140) = outputPresentationTimeStamp->epoch;
  *(_OWORD *)((char *)sbuf + 124) = v4;
  return 0;
}

CMTime *__cdecl CMSampleBufferGetOutputDecodeTimeStamp(CMTime *__return_ptr retstr, CMTime *sbuf)
{
  CMTime *v3;
  uint64_t v4;
  CMTimeEpoch *p_epoch;
  const __CFNumber *v6;
  const __CFNumber *v7;
  CFTypeID TypeID;
  CMTimeEpoch epoch;
  CMTime v10;
  CMTime time;
  CMTime v12;
  CMTime rhs;
  CMTime lhs;
  CMTime v15;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  memset(&v15, 0, sizeof(v15));
  if (!sbuf)
  {
    v4 = 4294954565;
    return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  v3 = sbuf;
  if (LOBYTE(sbuf[1].value))
  {
    v4 = 4294954552;
    return (CMTime *)FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  p_epoch = &sbuf[9].epoch;
  if ((HIDWORD(sbuf[10].value) & 0x1D) == 1)
  {
    *(_OWORD *)&retstr->value = *(_OWORD *)p_epoch;
    retstr->epoch = *(_QWORD *)&sbuf[10].timescale;
  }
  else
  {
    CMSampleBufferGetOutputPresentationTimeStamp(retstr, (CMSampleBufferRef)sbuf);
    CMSampleBufferGetDecodeTimeStamp(&lhs, (CMSampleBufferRef)v3);
    CMSampleBufferGetPresentationTimeStamp(&rhs, (CMSampleBufferRef)v3);
    CMTimeSubtract(&v15, &lhs, &rhs);
    v6 = (const __CFNumber *)CMGetAttachment(v3, CFSTR("SpeedMultiplier"), 0);
    if (v6)
    {
      v7 = v6;
      TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v7))
      {
        v10.value = 0x3FF0000000000000;
        CFNumberGetValue(v7, kCFNumberDoubleType, &v10);
        time = v15;
        CMTimeMultiplyByFloat64(&v12, &time, 1.0 / *(double *)&v10.value);
        v15 = v12;
      }
    }
    time = *retstr;
    v10 = v15;
    sbuf = CMTimeAdd(&v12, &time, &v10);
    *(_OWORD *)&retstr->value = *(_OWORD *)&v12.value;
    epoch = v12.epoch;
    retstr->epoch = v12.epoch;
    *(_OWORD *)p_epoch = *(_OWORD *)&retstr->value;
    p_epoch[2] = epoch;
  }
  return sbuf;
}

OSStatus CMSampleBufferGetSampleTimingInfoArray(CMSampleBufferRef sbuf, CMItemCount numSampleTimingEntries, CMSampleTimingInfo *timingArrayOut, CMItemCount *timingArrayEntriesNeededOut)
{
  uint64_t v5;
  OSStatus result;
  CMItemCount v8;

  if (!sbuf)
  {
    v5 = 4294954565;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v5 = 4294954552;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v8 = *((_QWORD *)sbuf + 11);
  if (v8 && *((_QWORD *)sbuf + 12))
  {
    if (timingArrayOut && v8 > numSampleTimingEntries)
    {
      result = FigSignalErrorAt(4294954559, 0, 0, 0, 0, 0, 0);
      if (!timingArrayEntriesNeededOut)
        return result;
LABEL_18:
      *timingArrayEntriesNeededOut = *((_QWORD *)sbuf + 11);
      return result;
    }
    if (timingArrayOut)
      memcpy(timingArrayOut, *((const void **)sbuf + 12), 72 * v8);
    result = 0;
    if (timingArrayEntriesNeededOut)
      goto LABEL_18;
  }
  else
  {
    if (timingArrayEntriesNeededOut)
      *timingArrayEntriesNeededOut = 0;
    return -12736;
  }
  return result;
}

OSStatus CMSampleBufferGetSampleTimingInfo(CMSampleBufferRef sbuf, CMItemIndex sampleIndex, CMSampleTimingInfo *timingInfoOut)
{
  uint64_t v4;
  uint64_t v6;
  CMItemIndex v7;
  CMItemIndex v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 *v12;
  CMTimeEpoch v13;
  __int128 v14;
  CMTime v15;
  CMTime rhs;
  __int128 v17;
  _OWORD v18[4];

  if (!sbuf || !timingInfoOut)
  {
    v4 = 4294954565;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v4 = 4294954552;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  v6 = *((_QWORD *)sbuf + 11);
  if (!v6)
  {
    v4 = 4294954560;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (sampleIndex < 0 || (v7 = *((_QWORD *)sbuf + 10), v7 <= sampleIndex))
  {
    v4 = 4294954562;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (v6 == v7)
  {
    v8 = *((_QWORD *)sbuf + 12) + 72 * sampleIndex;
    *(_OWORD *)&timingInfoOut->duration.value = *(_OWORD *)v8;
    v9 = *(_OWORD *)(v8 + 16);
    v10 = *(_OWORD *)(v8 + 32);
    v11 = *(_OWORD *)(v8 + 48);
    timingInfoOut->decodeTimeStamp.epoch = *(_QWORD *)(v8 + 64);
    *(_OWORD *)&timingInfoOut->presentationTimeStamp.timescale = v10;
    *(_OWORD *)&timingInfoOut->decodeTimeStamp.value = v11;
    *(_OWORD *)&timingInfoOut->duration.epoch = v9;
  }
  else
  {
    v12 = (__int128 *)*((_QWORD *)sbuf + 12);
    v13 = *((_QWORD *)v12 + 2);
    v17 = *v12;
    *(_QWORD *)&v18[0] = v13;
    *(_OWORD *)&v15.value = v17;
    v15.epoch = v13;
    CMTimeMultiply(&rhs, &v15, sampleIndex);
    v15 = *(CMTime *)((_BYTE *)v12 + 1);
    CMTimeAdd((CMTime *)((char *)v18 + 8), &v15, &rhs);
    *(_OWORD *)&timingInfoOut->presentationTimeStamp.timescale = v18[1];
    *(_OWORD *)&timingInfoOut->decodeTimeStamp.value = *(_OWORD *)&kCMTimeInvalid.value;
    timingInfoOut->decodeTimeStamp.epoch = 0;
    v14 = v18[0];
    *(_OWORD *)&timingInfoOut->duration.value = v17;
    *(_OWORD *)&timingInfoOut->duration.epoch = v14;
  }
  return 0;
}

OSStatus CMSampleBufferGetSampleSizeArray(CMSampleBufferRef sbuf, CMItemCount sizeArrayEntries, size_t *sizeArrayOut, CMItemCount *sizeArrayEntriesNeededOut)
{
  uint64_t v5;
  OSStatus result;
  CMItemCount v8;

  if (!sbuf)
  {
    v5 = 4294954565;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v5 = 4294954552;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v8 = *((_QWORD *)sbuf + 13);
  if (v8 && *((_QWORD *)sbuf + 14))
  {
    if (sizeArrayOut && v8 > sizeArrayEntries)
    {
      result = FigSignalErrorAt(4294954559, 0, 0, 0, 0, 0, 0);
      if (!sizeArrayEntriesNeededOut)
        return result;
LABEL_18:
      *sizeArrayEntriesNeededOut = *((_QWORD *)sbuf + 13);
      return result;
    }
    if (sizeArrayOut)
      memcpy(sizeArrayOut, *((const void **)sbuf + 14), 8 * v8);
    result = 0;
    if (sizeArrayEntriesNeededOut)
      goto LABEL_18;
  }
  else
  {
    if (sizeArrayEntriesNeededOut)
      *sizeArrayEntriesNeededOut = 0;
    return -12735;
  }
  return result;
}

size_t CMSampleBufferGetSampleSize(CMSampleBufferRef sbuf, CMItemIndex sampleIndex)
{
  uint64_t v2;
  uint64_t v3;
  size_t *v4;

  if (!sbuf)
  {
    v2 = 4294954565;
    goto LABEL_12;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
LABEL_12:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v3 = *((_QWORD *)sbuf + 13);
  if (!v3)
  {
    v2 = 4294954561;
    goto LABEL_12;
  }
  if (sampleIndex < 0 || *((_QWORD *)sbuf + 10) <= sampleIndex)
  {
    v2 = 4294954562;
    goto LABEL_12;
  }
  v4 = (size_t *)*((_QWORD *)sbuf + 14);
  if (v3 == 1)
    return *v4;
  else
    return v4[sampleIndex];
}

size_t CMSampleBufferGetTotalSampleSize(CMSampleBufferRef sbuf)
{
  uint64_t v2;
  size_t result;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;

  if (!sbuf)
  {
    v2 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v2 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v4 = *((_QWORD *)sbuf + 13);
  if (v4)
  {
    if (v4 == 1)
      return **((_QWORD **)sbuf + 14) * *((_QWORD *)sbuf + 10);
    if (v4 < 1)
      return 0;
    result = 0;
    v8 = (uint64_t *)*((_QWORD *)sbuf + 14);
    do
    {
      v9 = *v8++;
      result += v9;
      --v4;
    }
    while (v4);
  }
  else
  {
    result = *((_QWORD *)sbuf + 9);
    if (result)
    {
      if (CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)result) != 1936684398)
        return 0;
      if (!*((_BYTE *)sbuf + 344))
        return 0;
      v5 = *((_QWORD *)sbuf + 42);
      if (!v5)
        return 0;
      result = 0;
      v6 = (unsigned int *)(*((_QWORD *)sbuf + 41) + 12);
      do
      {
        v7 = *v6;
        v6 += 4;
        result += v7;
        --v5;
      }
      while (v5);
    }
  }
  return result;
}

CMFormatDescriptionRef CMSampleBufferGetFormatDescription(CMSampleBufferRef sbuf)
{
  uint64_t v1;

  if (!sbuf)
  {
    v1 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v1 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v1, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return (CMFormatDescriptionRef)*((_QWORD *)sbuf + 9);
}

CFArrayRef CMSampleBufferGetSampleAttachmentsArray(CMSampleBufferRef sbuf, Boolean createIfNecessary)
{
  uint64_t v3;
  const __CFArray *v4;
  CFIndex v6;
  const void **v7;
  const void **v8;
  const CFDictionaryKeyCallBacks *v9;
  const CFDictionaryValueCallBacks *v10;
  CFMutableDictionaryRef *v11;
  CFIndex v12;
  const __CFAllocator *v13;
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v15;
  CFTypeRef *v16;

  if (!sbuf)
  {
    v3 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v3 = 4294954552;
LABEL_5:
    FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v4 = (const __CFArray *)*((_QWORD *)sbuf + 38);
  if (createIfNecessary && !v4)
  {
    v6 = *((_QWORD *)sbuf + 10);
    if (!v6)
      return 0;
    v7 = (const void **)malloc_type_calloc(*((_QWORD *)sbuf + 10), 8uLL, 0x2004093837F09uLL);
    v8 = v7;
    if (v6 >= 1)
    {
      v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9AEB8];
      v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      v11 = (CFMutableDictionaryRef *)v7;
      v12 = v6;
      while (1)
      {
        v13 = CFGetAllocator(sbuf);
        Mutable = CFDictionaryCreateMutable(v13, 0, v9, v10);
        *v11 = Mutable;
        if (!Mutable)
          break;
        ++v11;
        if (!--v12)
          goto LABEL_15;
      }
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
      v4 = 0;
      goto LABEL_20;
    }
LABEL_15:
    v15 = CFGetAllocator(sbuf);
    v4 = CFArrayCreate(v15, v8, v6, MEMORY[0x1E0C9B378]);
    *((_QWORD *)sbuf + 38) = v4;
    if (!v4)
      FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    if (v8)
    {
LABEL_20:
      if (v6 >= 1)
      {
        v16 = v8;
        do
        {
          if (*v16)
            CFRelease(*v16);
          ++v16;
          --v6;
        }
        while (v6);
      }
      free(v8);
    }
  }
  return v4;
}

OSStatus CMSampleBufferCallForEachSample(CMSampleBufferRef sbuf, OSStatus (__cdecl *callback)(CMSampleBufferRef, CMItemCount, void *), void *refcon)
{
  uint64_t v4;
  OSStatus OutputSampleTimingInfoArray;
  OSStatus v6;
  CMSampleTimingInfo *v7;
  CMItemCount NumSamples;
  CMFormatDescriptionRef FormatDescription;
  CMBlockBufferRef DataBuffer;
  CFArrayRef SampleAttachmentsArray;
  const __CFArray *v15;
  OSStatus SampleTimingInfo;
  size_t v17;
  CMItemIndex v18;
  CMTime *p_presentationTimeStamp;
  size_t SampleSize;
  size_t v21;
  const __CFAllocator *v22;
  CFAllocatorRef v23;
  CFTypeRef v24;
  opaqueCMSampleBuffer *v25;
  const __CFDictionary *ValueAtIndex;
  const __CFArray *v27;
  void *v28;
  char *v29;
  _OWORD *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  const __CFArray *theArray;
  const opaqueCMFormatDescription *desc;
  size_t v41;
  CMTime lhs;
  CMTime rhs;
  CMTime time;
  CMSampleTimingInfo timingInfoOut;
  size_t v46;
  CMItemCount timingArrayEntriesNeededOut;
  char *v48;
  CMBlockBufferRef blockBufferOut;

  v48 = 0;
  blockBufferOut = 0;
  timingArrayEntriesNeededOut = 0;
  if (!sbuf)
  {
    v4 = 4294954565;
    goto LABEL_5;
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v4 = 4294954552;
LABEL_5:
    OutputSampleTimingInfoArray = FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
LABEL_6:
    v6 = OutputSampleTimingInfoArray;
    v7 = 0;
    goto LABEL_7;
  }
  NumSamples = CMSampleBufferGetNumSamples(sbuf);
  FormatDescription = CMSampleBufferGetFormatDescription(sbuf);
  DataBuffer = CMSampleBufferGetDataBuffer(sbuf);
  SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sbuf, 0);
  if (NumSamples == 1)
  {
    OutputSampleTimingInfoArray = ((uint64_t (*)(CMSampleBufferRef, _QWORD, void *))callback)(sbuf, 0, refcon);
    goto LABEL_6;
  }
  if (NumSamples < 2)
  {
    v7 = 0;
LABEL_45:
    v6 = 0;
    goto LABEL_7;
  }
  v15 = SampleAttachmentsArray;
  if (CMGetAttachment(sbuf, CFSTR("TrimDurationAtStart"), 0)
    || CMGetAttachment(sbuf, CFSTR("TrimDurationAtEnd"), 0)
    || CMGetAttachment(sbuf, CFSTR("SpeedMultiplier"), 0)
    || CMGetAttachment(sbuf, CFSTR("Reverse"), 0)
    || (*((_DWORD *)sbuf + 34) & 0x1D) == 1)
  {
    OutputSampleTimingInfoArray = CMSampleBufferGetOutputSampleTimingInfoArray(sbuf, 0, 0, &timingArrayEntriesNeededOut);
    if (OutputSampleTimingInfoArray)
      goto LABEL_6;
    v7 = (CMSampleTimingInfo *)malloc_type_malloc(72 * timingArrayEntriesNeededOut, 0x1000040FF89C88EuLL);
    if (v7)
    {
      SampleTimingInfo = CMSampleBufferGetOutputSampleTimingInfoArray(sbuf, timingArrayEntriesNeededOut, v7, 0);
      if (!SampleTimingInfo)
      {
        theArray = v15;
        desc = FormatDescription;
        v38 = 0;
        goto LABEL_26;
      }
    }
    else
    {
      v37 = 4294954566;
LABEL_47:
      SampleTimingInfo = FigSignalErrorAt(v37, 0, 0, 0, 0, 0, 0);
    }
LABEL_48:
    v6 = SampleTimingInfo;
    goto LABEL_7;
  }
  theArray = v15;
  desc = FormatDescription;
  v7 = 0;
  v38 = 1;
LABEL_26:
  v17 = 0;
  v18 = 0;
  p_presentationTimeStamp = &v7->presentationTimeStamp;
  while (1)
  {
    memset(&timingInfoOut, 0, sizeof(timingInfoOut));
    SampleSize = CMSampleBufferGetSampleSize(sbuf, v18);
    v46 = SampleSize;
    if (!SampleSize)
    {
      v37 = 4294954557;
      goto LABEL_47;
    }
    v21 = SampleSize;
    v22 = CFGetAllocator(DataBuffer);
    v41 = v17;
    SampleTimingInfo = CMBlockBufferCreateWithBufferReference(v22, DataBuffer, v17, v21, 0, &blockBufferOut);
    if (SampleTimingInfo)
      goto LABEL_48;
    SampleTimingInfo = CMSampleBufferGetSampleTimingInfo(sbuf, v18, &timingInfoOut);
    if (SampleTimingInfo)
      goto LABEL_48;
    v23 = CFGetAllocator(sbuf);
    SampleTimingInfo = figSampleBufferCreateCallbackOrHandler((uint64_t)v23, blockBufferOut, 0, 0, 0, 0, desc, 1uLL, 1uLL, &timingInfoOut, 1uLL, &v46, &v48);
    if (SampleTimingInfo)
      goto LABEL_48;
    CFRelease(blockBufferOut);
    blockBufferOut = 0;
    v24 = (CFTypeRef)*((_QWORD *)sbuf + 19);
    if (v24)
      v24 = CFRetain(v24);
    v25 = (opaqueCMSampleBuffer *)v48;
    *((_QWORD *)v48 + 19) = v24;
    SampleTimingInfo = CMSampleBufferTrackDataReadiness(v25, sbuf);
    if (SampleTimingInfo)
      goto LABEL_48;
    if (theArray)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v18);
      v27 = CMSampleBufferGetSampleAttachmentsArray((CMSampleBufferRef)v48, 1u);
      v28 = (void *)CFArrayGetValueAtIndex(v27, 0);
      CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)sBufDictionarySetValue, v28);
    }
    if (v38)
    {
      v29 = v48;
    }
    else
    {
      v29 = v48;
      v30 = v48 + 280;
      if (timingArrayEntriesNeededOut == NumSamples)
      {
        v31 = *(_OWORD *)&p_presentationTimeStamp[-1].value;
        *((_QWORD *)v48 + 37) = p_presentationTimeStamp[-1].epoch;
        *v30 = v31;
        v32 = *(_OWORD *)&p_presentationTimeStamp->value;
        *(_QWORD *)(v29 + 140) = p_presentationTimeStamp->epoch;
        *(_OWORD *)(v29 + 124) = v32;
        v33 = *(_OWORD *)&p_presentationTimeStamp[1].value;
        *((_QWORD *)v29 + 31) = p_presentationTimeStamp[1].epoch;
        *(_OWORD *)(v29 + 232) = v33;
      }
      else
      {
        v34 = *(_OWORD *)&v7->duration.value;
        *((_QWORD *)v48 + 37) = v7->duration.epoch;
        *v30 = v34;
        v35 = *(_OWORD *)&v7->duration.value;
        time.epoch = v7->duration.epoch;
        *(_OWORD *)&time.value = v35;
        CMTimeMultiply(&rhs, &time, v18);
        lhs = v7->presentationTimeStamp;
        CMTimeAdd(&time, &lhs, &rhs);
        *(CMTime *)(v29 + 124) = time;
        v29 = v48;
        *(_OWORD *)(v48 + 232) = *(_OWORD *)&kCMTimeInvalid.value;
        *((_QWORD *)v29 + 31) = 0;
      }
    }
    v36 = ((uint64_t (*)(char *, CMItemIndex, void *))callback)(v29, v18, refcon);
    if ((_DWORD)v36)
      break;
    CFRelease(v48);
    v48 = 0;
    v17 = v21 + v41;
    ++v18;
    p_presentationTimeStamp += 3;
    if (NumSamples == v18)
      goto LABEL_45;
  }
  v6 = v36;
  FigSignalErrorAt(v36, 0, 0, 0, 0, 0, 0);
LABEL_7:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (v48)
    CFRelease(v48);
  if (v7)
    free(v7);
  return v6;
}

void sBufDictionarySetValue(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

OSStatus CMSampleBufferCallBlockForEachSample(CMSampleBufferRef sbuf, void *handler)
{
  return CMSampleBufferCallForEachSample(sbuf, (OSStatus (__cdecl *)(CMSampleBufferRef, CMItemCount, void *))figSampleBufferCallForEachSampleBlockFunctionCallback, handler);
}

uint64_t figSampleBufferCallForEachSampleBlockFunctionCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

OSStatus CMSampleBufferSetDataBufferFromAudioBufferList(CMSampleBufferRef sbuf, CFAllocatorRef blockBufferStructureAllocator, CFAllocatorRef blockBufferBlockAllocator, uint32_t flags, const AudioBufferList *bufferList)
{
  uint64_t v7;
  char v8;
  const AudioStreamBasicDescription *StreamBasicDescription;
  const AudioStreamBasicDescription *v12;
  UInt32 mNumberChannels;
  const AudioFormatListItem *FormatList;
  uint64_t v15;
  unsigned int v16;
  UInt32 mChannelsPerFrame;
  uint64_t mNumberBuffers;
  size_t v20;
  size_t v21;
  void **p_mData;
  uint64_t v23;
  __int128 *v24;
  __int128 v25;
  unint64_t v26;
  CFIndex v27;
  char *v28;
  char *v29;
  OSStatus v30;
  OSStatus v31;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  char *v36;
  size_t v37;
  unint64_t v38;
  size_t v39;
  void **v40;
  const __CFAllocator *v41;
  void *v42;
  const AudioStreamBasicDescription *v43;
  const __CFAllocator *v44;
  CMTime time1;
  CMTime time2;
  size_t sizeOut;
  char *dataPointerOut;
  CMBlockBufferRef blockBufferOut;

  blockBufferOut = 0;
  sizeOut = 0;
  dataPointerOut = 0;
  if (!sbuf || !bufferList)
    goto LABEL_47;
  if (*((_BYTE *)sbuf + 24))
  {
    v7 = 4294954552;
LABEL_48:
    v31 = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    goto LABEL_49;
  }
  if (*((_DWORD *)sbuf + 7) || *((_QWORD *)sbuf + 2))
  {
    v7 = 4294954564;
    goto LABEL_48;
  }
  v8 = flags;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*((CMAudioFormatDescriptionRef *)sbuf + 9));
  if (!StreamBasicDescription)
  {
    v7 = 4294954586;
    goto LABEL_48;
  }
  v12 = StreamBasicDescription;
  if (StreamBasicDescription->mFormatID == 1819304813 && (StreamBasicDescription->mFormatFlags & 0x20) != 0)
  {
    mChannelsPerFrame = StreamBasicDescription->mChannelsPerFrame;
    if (bufferList->mNumberBuffers == mChannelsPerFrame)
    {
      mNumberChannels = 1;
      if (mChannelsPerFrame != 1)
        goto LABEL_25;
      goto LABEL_13;
    }
LABEL_47:
    v7 = 4294954565;
    goto LABEL_48;
  }
  if (bufferList->mNumberBuffers != 1)
    goto LABEL_47;
  mNumberChannels = StreamBasicDescription->mChannelsPerFrame;
LABEL_13:
  if (mNumberChannels != bufferList->mBuffers[0].mNumberChannels)
  {
    FormatList = CMAudioFormatDescriptionGetFormatList(*((CMAudioFormatDescriptionRef *)sbuf + 9), &sizeOut);
    if (FormatList)
    {
      if (sizeOut >= 0x31)
      {
        v15 = 0;
        v16 = 1;
        while (FormatList[v15].mASBD.mChannelsPerFrame != bufferList->mBuffers[0].mNumberChannels)
        {
          v15 = v16;
          if (sizeOut / 0x30 <= v16++)
            goto LABEL_25;
        }
        mNumberChannels = bufferList->mBuffers[0].mNumberChannels;
      }
    }
  }
LABEL_25:
  mNumberBuffers = bufferList->mNumberBuffers;
  if ((_DWORD)mNumberBuffers)
  {
    v20 = 0;
    v21 = 0;
    p_mData = &bufferList->mBuffers[0].mData;
    while (*((_DWORD *)p_mData - 2) == mNumberChannels)
    {
      v23 = *((unsigned int *)p_mData - 1);
      if (!(_DWORD)v23 || !*p_mData)
        break;
      if (v21)
      {
        if (v21 != v23)
          goto LABEL_47;
      }
      else
      {
        v21 = *((unsigned int *)p_mData - 1);
      }
      p_mData += 2;
      v20 += v21;
      if (!--mNumberBuffers)
        goto LABEL_37;
    }
    goto LABEL_47;
  }
  v21 = 0;
  v20 = 0;
LABEL_37:
  if (v12->mFormatID == 1819304813)
  {
    v24 = (__int128 *)*((_QWORD *)sbuf + 12);
    if (!v24)
      goto LABEL_47;
    if (*((_QWORD *)sbuf + 11) != 1)
      goto LABEL_47;
    CMTimeMake(&time2, 1, (int)v12->mSampleRate);
    v25 = *v24;
    time1.epoch = *((_QWORD *)v24 + 2);
    *(_OWORD *)&time1.value = v25;
    if (CMTimeCompare(&time1, &time2) || *((_QWORD *)sbuf + 10) != v21 / v12->mBytesPerFrame)
      goto LABEL_47;
  }
  if ((v8 & 1) != 0 && (v21 & 0xF) != 0)
  {
    v26 = (v21 + 15) & 0xFFFFFFFFFFFFFFF0;
    v27 = v26 * bufferList->mNumberBuffers;
    v28 = (char *)CFAllocatorAllocate(blockBufferBlockAllocator, v27, 0);
    if (!v28)
    {
      v31 = -12730;
      goto LABEL_49;
    }
    v29 = v28;
    v30 = CMBlockBufferCreateEmpty(blockBufferStructureAllocator, bufferList->mNumberBuffers, 0, &blockBufferOut);
    if (v30)
    {
      v31 = v30;
      CFAllocatorDeallocate(blockBufferBlockAllocator, v29);
LABEL_49:
      if (v31 && blockBufferOut)
        CFRelease(blockBufferOut);
      return v31;
    }
    v43 = v12;
    if (bufferList->mNumberBuffers)
    {
      v36 = v29;
      v37 = v27;
      v38 = 0;
      v39 = 0;
      v44 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
      v40 = &bufferList->mBuffers[0].mData;
      do
      {
        if (v38)
          v41 = v44;
        else
          v41 = blockBufferBlockAllocator;
        CMBlockBufferAppendMemoryBlock(blockBufferOut, v36, v37, v41, 0, v39, v21, 0);
        v42 = *v40;
        v40 += 2;
        memcpy(&v36[v39], v42, v21);
        v39 += v26;
        ++v38;
      }
      while (v38 < bufferList->mNumberBuffers);
    }
  }
  else
  {
    v31 = CMBlockBufferCreateWithMemoryBlock(blockBufferStructureAllocator, 0, v20, blockBufferBlockAllocator, 0, 0, v20, 1u, &blockBufferOut);
    if (v31)
      goto LABEL_49;
    v43 = v12;
    CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &dataPointerOut);
    if (bufferList->mNumberBuffers)
    {
      v33 = 0;
      v34 = dataPointerOut;
      v35 = 16;
      do
      {
        memcpy(v34, *(const void **)((char *)&bufferList->mNumberBuffers + v35), v21);
        v34 = &dataPointerOut[v21];
        dataPointerOut += v21;
        ++v33;
        v35 += 16;
      }
      while (v33 < bufferList->mNumberBuffers);
    }
  }
  *((_QWORD *)sbuf + 2) = blockBufferOut;
  *((_BYTE *)sbuf + 25) = 1;
  blockBufferOut = 0;
  if (v43->mFormatID == 1819304813 && (v43->mFormatFlags & 0x20) != 0)
  {
    *((_QWORD *)sbuf + 13) = 0;
    *((_QWORD *)sbuf + 14) = 0;
  }
  figSampleBufferCheckDataSize((size_t)sbuf);
  return 0;
}

OSStatus CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer(CMSampleBufferRef sbuf, size_t *bufferListSizeNeededOut, AudioBufferList *bufferListOut, size_t bufferListSize, CFAllocatorRef blockBufferStructureAllocator, CFAllocatorRef blockBufferBlockAllocator, uint32_t flags, CMBlockBufferRef *blockBufferOut)
{
  uint64_t v9;
  char v11;
  const AudioStreamBasicDescription *StreamBasicDescription;
  int v18;
  signed int mChannelsPerFrame;
  size_t v20;
  OpaqueCMBlockBuffer *v21;

  if (!sbuf)
  {
LABEL_16:
    v9 = 4294954565;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 24))
  {
    v9 = 4294954552;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  v11 = flags;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*((CMAudioFormatDescriptionRef *)sbuf + 9));
  if (!StreamBasicDescription)
  {
    v9 = 4294954586;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  if (StreamBasicDescription->mFormatID == 1819304813 && (StreamBasicDescription->mFormatFlags & 0x20) != 0)
  {
    mChannelsPerFrame = StreamBasicDescription->mChannelsPerFrame;
    if (!mChannelsPerFrame)
    {
      v9 = 4294954553;
      return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    }
    v18 = 1;
  }
  else
  {
    v18 = StreamBasicDescription->mChannelsPerFrame;
    mChannelsPerFrame = 1;
  }
  v20 = 16 * (mChannelsPerFrame - 1) + 24;
  if (bufferListSizeNeededOut)
    *bufferListSizeNeededOut = v20;
  if (bufferListOut)
  {
    if (v20 != bufferListSize)
    {
      v9 = 4294954559;
      return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    }
    if (blockBufferOut)
    {
      v21 = (OpaqueCMBlockBuffer *)*((_QWORD *)sbuf + 2);
      if (v21 && *((_BYTE *)sbuf + 25))
        return DataBufferToAudioListWorker(v21, blockBufferStructureAllocator, blockBufferBlockAllocator, mChannelsPerFrame, v18, v11 & 1, (signed int *)bufferListOut, blockBufferOut);
      v9 = 4294954563;
      return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    }
    goto LABEL_16;
  }
  return 0;
}

uint64_t DataBufferToAudioListWorker(OpaqueCMBlockBuffer *a1, const __CFAllocator *a2, const __CFAllocator *a3, signed int a4, int a5, int a6, signed int *a7, CMBlockBufferRef *a8)
{
  uint64_t v13;
  size_t v14;
  BOOL v15;
  size_t v16;
  unint64_t v17;
  uint64_t v18;
  OpaqueCMBlockBuffer *v19;
  size_t v20;
  char **v21;
  uint64_t appended;
  CMBlockBufferRef v23;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  CMBlockBufferRef blockBufferOut;

  lengthAtOffsetOut = 0;
  blockBufferOut = 0;
  dataPointerOut = 0;
  *a7 = a4;
  v13 = a4;
  v14 = CMBlockBufferGetDataLength(a1) / a4;
  if (a4)
  {
    CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (lengthAtOffsetOut >= v14)
    {
      v16 = 0;
      v17 = 1;
      v15 = 1;
      do
      {
        if (a6 && (dataPointerOut & 0xF) != 0)
          break;
        if (a4 == v17)
          goto LABEL_11;
        v16 += v14;
        v15 = v17 < a4;
        CMBlockBufferGetDataPointer(a1, v16, &lengthAtOffsetOut, 0, &dataPointerOut);
        ++v17;
      }
      while (lengthAtOffsetOut >= v14);
    }
    else
    {
      v15 = 1;
    }
    v18 = CMBlockBufferCreateEmpty(a2, a4, 0, &blockBufferOut);
    if ((_DWORD)v18)
      goto LABEL_26;
  }
  else
  {
LABEL_11:
    if (a1)
      v19 = (OpaqueCMBlockBuffer *)CFRetain(a1);
    else
      v19 = 0;
    v15 = 0;
    blockBufferOut = v19;
    if (!a4)
    {
LABEL_24:
      v18 = 0;
      v23 = blockBufferOut;
      goto LABEL_28;
    }
  }
  v20 = 0;
  v21 = (char **)(a7 + 4);
  while (1)
  {
    CMBlockBufferGetDataPointer(a1, v20, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (v15)
      break;
LABEL_23:
    *v21 = dataPointerOut;
    *((_DWORD *)v21 - 2) = a5;
    *((_DWORD *)v21 - 1) = v14;
    v20 += v14;
    v21 += 2;
    if (!--v13)
      goto LABEL_24;
  }
  if (lengthAtOffsetOut >= v14 && (!a6 || (dataPointerOut & 0xF) == 0))
  {
    CMBlockBufferAppendBufferReference(blockBufferOut, a1, v20, v14, 0);
    goto LABEL_23;
  }
  appended = CMBlockBufferAppendMemoryBlock(blockBufferOut, 0, v14, a3, 0, 0, v14, 1u);
  if (!(_DWORD)appended)
  {
    CMBlockBufferGetDataPointer(blockBufferOut, v20, 0, 0, &dataPointerOut);
    CMBlockBufferCopyDataBytes(a1, v20, v14, dataPointerOut);
    goto LABEL_23;
  }
  v18 = appended;
LABEL_26:
  if (blockBufferOut)
  {
    CFRelease(blockBufferOut);
    v23 = 0;
LABEL_28:
    *a8 = v23;
  }
  return v18;
}

OSStatus CMSampleBufferCopyPCMDataIntoAudioBufferList(CMSampleBufferRef sbuf, int32_t frameOffset, int32_t numFrames, AudioBufferList *bufferList)
{
  const AudioStreamBasicDescription *StreamBasicDescription;
  const AudioStreamBasicDescription *v9;
  uint64_t v10;
  OpaqueCMBlockBuffer *v11;
  uint64_t mBytesPerFrame;
  int mChannelsPerFrame;
  size_t v14;
  uint64_t v15;
  void **p_mData;
  size_t v17;
  OSStatus result;
  unint64_t v19;
  uint64_t v20;
  void **i;
  uint64_t v22;

  if (!sbuf || !bufferList)
    goto LABEL_30;
  if (CMFormatDescriptionGetMediaType(*((CMFormatDescriptionRef *)sbuf + 9)) != 1936684398)
  {
    v22 = 4294954555;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*((CMAudioFormatDescriptionRef *)sbuf + 9));
  if (!StreamBasicDescription)
  {
    v22 = 4294954586;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  v9 = StreamBasicDescription;
  if (StreamBasicDescription->mFormatID != 1819304813)
  {
    v22 = 4294954554;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  v10 = *((_QWORD *)sbuf + 10);
  if (v10 <= frameOffset)
    goto LABEL_32;
  if (!numFrames)
  {
LABEL_30:
    v22 = 4294954565;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  if (v10 < numFrames + frameOffset)
  {
LABEL_32:
    v22 = 4294954562;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  v11 = (OpaqueCMBlockBuffer *)*((_QWORD *)sbuf + 2);
  if (!v11 || !*((_BYTE *)sbuf + 25))
  {
    v22 = 4294954563;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  mBytesPerFrame = v9->mBytesPerFrame;
  mChannelsPerFrame = v9->mChannelsPerFrame;
  v14 = (mBytesPerFrame * numFrames);
  LODWORD(v15) = bufferList->mNumberBuffers;
  if ((v9->mFormatFlags & 0x20) == 0)
  {
    if ((_DWORD)v15 != 1)
      goto LABEL_37;
    goto LABEL_17;
  }
  if ((_DWORD)v15 != mChannelsPerFrame)
  {
LABEL_37:
    FigSignalErrorAt(4294954565, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (mChannelsPerFrame)
  {
    LODWORD(v15) = v9->mChannelsPerFrame;
    mChannelsPerFrame = 1;
LABEL_17:
    v15 = v15;
    p_mData = &bufferList->mBuffers[0].mData;
    while (*((_DWORD *)p_mData - 2) == mChannelsPerFrame && *((_DWORD *)p_mData - 1) == (_DWORD)v14 && *p_mData)
    {
      p_mData += 2;
      if (!--v15)
        goto LABEL_22;
    }
    goto LABEL_30;
  }
LABEL_22:
  v17 = (mBytesPerFrame * frameOffset);
  if ((v9->mFormatFlags & 0x20) == 0)
    return CMBlockBufferCopyDataBytes(v11, v17, v14, bufferList->mBuffers[0].mData);
  if (!v9->mChannelsPerFrame)
    return 0;
  v19 = 0;
  v20 = v10 * mBytesPerFrame;
  for (i = &bufferList->mBuffers[0].mData; ; i += 2)
  {
    result = CMBlockBufferCopyDataBytes(*((CMBlockBufferRef *)sbuf + 2), v17, v14, *i);
    if (result)
      break;
    ++v19;
    v17 += v20;
    if (v19 >= v9->mChannelsPerFrame)
      return 0;
  }
  return result;
}

OSStatus CMSampleBufferGetAudioStreamPacketDescriptionsPtr(CMSampleBufferRef sbuf, const AudioStreamPacketDescription **packetDescriptionsPointerOut, size_t *packetDescriptionsSizeOut)
{
  uint64_t v4;
  const opaqueCMFormatDescription *v7;
  const AudioStreamPacketDescription *v8;
  OSStatus result;

  if (!sbuf)
    goto LABEL_14;
  if (*((_BYTE *)sbuf + 24))
  {
    v4 = 4294954552;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (!((unint64_t)packetDescriptionsPointerOut | (unint64_t)packetDescriptionsSizeOut))
  {
LABEL_14:
    v4 = 4294954565;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  v7 = (const opaqueCMFormatDescription *)*((_QWORD *)sbuf + 9);
  if (!v7 || CMFormatDescriptionGetMediaType(v7) != 1936684398)
  {
    v4 = 4294954555;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (*((_BYTE *)sbuf + 344) || (result = sBufComputeAudioStreamPacketDescriptions((uint64_t)sbuf)) == 0)
  {
    if (packetDescriptionsPointerOut)
    {
      v8 = (const AudioStreamPacketDescription *)*((_QWORD *)sbuf + 42);
      if (v8)
        v8 = (const AudioStreamPacketDescription *)*((_QWORD *)sbuf + 41);
      *packetDescriptionsPointerOut = v8;
    }
    result = 0;
    if (packetDescriptionsSizeOut)
      *packetDescriptionsSizeOut = 16 * *((_QWORD *)sbuf + 42);
  }
  return result;
}

uint64_t sBufComputeAudioStreamPacketDescriptions(uint64_t a1)
{
  const AudioStreamBasicDescription *StreamBasicDescription;
  const AudioStreamBasicDescription *v3;
  CMItemCount NumSamples;
  UInt32 *p_mBytesPerPacket;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  int value;
  UInt32 v11;
  unint64_t v12;
  size_t SampleSize;
  UInt32 mFramesPerPacket;
  int32_t mSampleRate;
  int v16;
  CMTime duration;
  CMTime v18;
  CMSampleTimingInfo timingInfoOut;

  memset(&timingInfoOut, 0, sizeof(timingInfoOut));
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(*(CMAudioFormatDescriptionRef *)(a1 + 72));
  if (!StreamBasicDescription)
  {
    v6 = 4294954586;
    goto LABEL_7;
  }
  if (*(_BYTE *)(a1 + 344))
    goto LABEL_8;
  v3 = StreamBasicDescription;
  NumSamples = CMSampleBufferGetNumSamples((CMSampleBufferRef)a1);
  if (v3->mFramesPerPacket)
  {
    p_mBytesPerPacket = &v3->mBytesPerPacket;
    if (v3->mBytesPerPacket)
    {
      *(_QWORD *)(a1 + 336) = 0;
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (!*(_QWORD *)(a1 + 96))
  {
    v6 = 4294954560;
    goto LABEL_7;
  }
  p_mBytesPerPacket = &v3->mBytesPerPacket;
  if (!v3->mBytesPerPacket)
  {
LABEL_12:
    if (!*(_QWORD *)(a1 + 112))
    {
      v6 = 4294954561;
      goto LABEL_7;
    }
  }
  *(_QWORD *)(a1 + 336) = NumSamples;
  if (!NumSamples)
    goto LABEL_8;
  v8 = 0;
  v9 = 0;
  value = 0;
  v11 = *p_mBytesPerPacket;
  v12 = 1;
  SampleSize = *p_mBytesPerPacket;
  while (1)
  {
    if (!v11)
      SampleSize = CMSampleBufferGetSampleSize((CMSampleBufferRef)a1, v12 - 1);
    mFramesPerPacket = v3->mFramesPerPacket;
    if (!mFramesPerPacket)
      break;
LABEL_21:
    *(_QWORD *)(*(_QWORD *)(a1 + 328) + v8) = v9;
    if (mFramesPerPacket)
      v16 = 0;
    else
      v16 = value;
    *(_DWORD *)(*(_QWORD *)(a1 + 328) + v8 + 8) = v16;
    *(_DWORD *)(*(_QWORD *)(a1 + 328) + v8 + 12) = SampleSize;
    if (v12 >= *(_QWORD *)(a1 + 336))
      goto LABEL_8;
    v9 += SampleSize;
    v11 = *p_mBytesPerPacket;
    ++v12;
    v8 += 16;
  }
  result = CMSampleBufferGetSampleTimingInfo((CMSampleBufferRef)a1, v12 - 1, &timingInfoOut);
  if ((_DWORD)result)
    return result;
  mSampleRate = (int)v3->mSampleRate;
  duration = timingInfoOut.duration;
  CMTimeConvertScale(&v18, &duration, mSampleRate, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
  if ((v18.flags & 0x1D) == 1)
  {
    value = v18.value;
    mFramesPerPacket = v3->mFramesPerPacket;
    goto LABEL_21;
  }
  v6 = 4294954556;
LABEL_7:
  result = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  if (!(_DWORD)result)
  {
LABEL_8:
    result = 0;
    *(_BYTE *)(a1 + 344) = 1;
  }
  return result;
}

OSStatus CMSampleBufferGetAudioStreamPacketDescriptions(CMSampleBufferRef sbuf, size_t packetDescriptionsSize, AudioStreamPacketDescription *packetDescriptionsOut, size_t *packetDescriptionsSizeNeededOut)
{
  OSStatus result;
  size_t __n;
  AudioStreamPacketDescription *packetDescriptionsPointerOut;

  __n = 0;
  packetDescriptionsPointerOut = 0;
  result = CMSampleBufferGetAudioStreamPacketDescriptionsPtr(sbuf, (const AudioStreamPacketDescription **)&packetDescriptionsPointerOut, &__n);
  if (!result)
  {
    if (packetDescriptionsSizeNeededOut)
      *packetDescriptionsSizeNeededOut = __n;
    if (!packetDescriptionsOut)
      return 0;
    if (__n > packetDescriptionsSize)
      return FigSignalErrorAt(4294954559, 0, 0, 0, 0, 0, 0);
    result = 0;
    if (__n && packetDescriptionsPointerOut)
    {
      memcpy(packetDescriptionsOut, packetDescriptionsPointerOut, __n);
      return 0;
    }
  }
  return result;
}

uint64_t FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary(const __CFAllocator *a1, unint64_t a2, _QWORD *a3)
{
  const void *v6;
  void *SampleDependencyAttributeDictionaryForAudioRefreshCount;

  if (FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_onceToken != -1)
    dispatch_once_f(&FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_onceToken, &FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_context, (dispatch_function_t)InitializePacketAttributes);
  if ((_BYTE)a2)
  {
    if ((a2 & 0x8000000000000000) != 0 || SHIDWORD(a2) > 3)
    {
      SampleDependencyAttributeDictionaryForAudioRefreshCount = createSampleDependencyAttributeDictionaryForAudioRefreshCount(a1, SHIDWORD(a2));
      if (SampleDependencyAttributeDictionaryForAudioRefreshCount)
        goto LABEL_10;
      return FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
    }
    v6 = (const void *)FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_sIndependentPacketAttributes[HIDWORD(a2)];
    if (!v6)
      return FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v6 = (const void *)FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_sDependentPacketAttributes;
    if (!FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary_sDependentPacketAttributes)
      return FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
  }
  SampleDependencyAttributeDictionaryForAudioRefreshCount = (void *)CFRetain(v6);
  if (SampleDependencyAttributeDictionaryForAudioRefreshCount)
  {
LABEL_10:
    *a3 = SampleDependencyAttributeDictionaryForAudioRefreshCount;
    return 0;
  }
  return FigSignalErrorAt(4294954566, 0, 0, 0, 0, 0, 0);
}

CFDictionaryRef InitializePacketAttributes(uint64_t a1)
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  uint64_t v3;
  const __CFAllocator *v4;
  CFDictionaryRef result;

  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  v3 = 0;
  **(_QWORD **)a1 = CFDictionaryCreate(AllocatorForPermanentAllocations, (const void **)&kCMSampleAttachmentKey_NotSync, MEMORY[0x1E0C9AE50], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  do
  {
    v4 = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
    result = createSampleDependencyAttributeDictionaryForAudioRefreshCount(v4, v3);
    *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v3++) = result;
  }
  while (v3 != 4);
  return result;
}

CFDictionaryRef createSampleDependencyAttributeDictionaryForAudioRefreshCount(const __CFAllocator *a1, int a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  const CFDictionaryKeyCallBacks *v5;
  const CFDictionaryValueCallBacks *v6;
  const void **v7;
  const void **v8;
  const __CFAllocator *v9;
  CFIndex v10;
  CFDictionaryRef v11;
  int valuePtr;
  uint64_t v14;
  CFNumberRef v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  valuePtr = a2;
  v16 = xmmword_1E28D90E0;
  v14 = *MEMORY[0x1E0C9AE50];
  v3 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (!v3)
    return 0;
  v4 = v3;
  v15 = v3;
  if (valuePtr)
  {
    v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    v7 = (const void **)&v16;
    v8 = (const void **)&v14;
    v9 = a1;
    v10 = 2;
  }
  else
  {
    v8 = (const void **)&v15;
    v7 = (const void **)&v16 + 1;
    v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    v9 = a1;
    v10 = 1;
  }
  v11 = CFDictionaryCreate(v9, v7, v8, v10, v5, v6);
  CFRelease(v4);
  return v11;
}

uint64_t FigAudioStreamPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary(const __CFAllocator *a1, _DWORD *a2, _QWORD *a3)
{
  unint64_t v3;

  if (*a2)
    v3 = 0;
  else
    v3 = (unint64_t)a2[1] << 32;
  return FigPacketDependencyInfoCopyAsSampleDependencyAttributeDictionary(a1, v3 | (*a2 == 0), a3);
}

uint64_t FigSampleBufferGetDecryptor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 152);
}

void FigSampleBufferSetDecryptor(uint64_t a1, CFTypeRef cf)
{
  const void *v2;

  v2 = *(const void **)(a1 + 152);
  *(_QWORD *)(a1 + 152) = cf;
  if (cf)
    CFRetain(cf);
  if (v2)
    CFRelease(v2);
}

uint64_t CMSampleBufferCreateReadyForCVDataBuffer(const __CFAllocator *a1, void *cf, const opaqueCMFormatDescription *a3, uint64_t a4, _QWORD *a5)
{
  CFTypeID v10;
  uint64_t IOSurface;
  __IOSurface *v12;
  int PixelFormatType;
  uint64_t v14;
  void *BaseAddress;
  size_t AllocSize;
  uint64_t v17;
  _QWORD *v18;
  CMBlockBufferRef v19;
  CFTypeRef v20;
  char *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  CMBlockBufferCustomBlockSource customBlockSource;
  CFTypeRef cfa;
  CMBlockBufferRef blockBufferOut;

  cfa = 0;
  blockBufferOut = 0;
  memset(&customBlockSource, 0, sizeof(customBlockSource));
  if (!a5)
  {
    v30 = 4294954565;
    goto LABEL_15;
  }
  if (!cf
    || (v10 = CFGetTypeID(cf), v10 != CVDataBufferGetTypeID())
    || !a3
    || !a4
    || (IOSurface = CVDataBufferGetIOSurface()) == 0)
  {
    v30 = 4294954565;
LABEL_15:
    v14 = FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  v12 = (__IOSurface *)IOSurface;
  PixelFormatType = CVDataBufferGetPixelFormatType();
  if (CMFormatDescriptionGetMediaSubType(a3) != PixelFormatType)
  {
    v30 = 4294954553;
    goto LABEL_15;
  }
  CVDataBufferGetDataSize();
  v14 = sBufCreate((uint64_t)a1, 1uLL, 1uLL, 0, &cfa);
  if ((_DWORD)v14)
  {
LABEL_16:
    v17 = v14;
    goto LABEL_17;
  }
  IOSurfaceLock(v12, 1u, 0);
  BaseAddress = IOSurfaceGetBaseAddress(v12);
  AllocSize = IOSurfaceGetAllocSize(v12);
  CFRetain(cf);
  customBlockSource.version = 0;
  customBlockSource.refCon = cf;
  customBlockSource.AllocateBlock = 0;
  customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))sbufReleaseCVDataBufferAfterUnlockingIOSurface;
  v17 = CMBlockBufferCreateWithMemoryBlock(a1, BaseAddress, AllocSize, 0, &customBlockSource, 0, AllocSize, 0, &blockBufferOut);
  if (!(_DWORD)v17)
  {
    CMSetAttachment(blockBufferOut, CFSTR("CVDataBuffer"), cf, 0);
    v18 = cfa;
    v19 = blockBufferOut;
    *((_DWORD *)cfa + 7) = 0;
    v18[2] = v19;
    blockBufferOut = 0;
    *((_BYTE *)v18 + 25) = 1;
    v20 = FigFormatDescriptionRetain(a3);
    v21 = (char *)cfa;
    *((_QWORD *)cfa + 9) = v20;
    *((_QWORD *)v21 + 10) = 1;
    **((_QWORD **)v21 + 14) = AllocSize;
    v22 = *((_QWORD *)v21 + 12);
    v24 = *(_OWORD *)(a4 + 32);
    v23 = *(_OWORD *)(a4 + 48);
    v25 = *(_OWORD *)(a4 + 16);
    *(_QWORD *)(v22 + 64) = *(_QWORD *)(a4 + 64);
    *(_OWORD *)(v22 + 32) = v24;
    *(_OWORD *)(v22 + 48) = v23;
    *(_OWORD *)(v22 + 16) = v25;
    *(_OWORD *)v22 = *(_OWORD *)a4;
    v26 = *(_QWORD *)(a4 + 64);
    *((_OWORD *)v21 + 10) = *(_OWORD *)(a4 + 48);
    *((_QWORD *)v21 + 22) = v26;
    v27 = *(_QWORD *)(a4 + 40);
    *(_OWORD *)(v21 + 184) = *(_OWORD *)(a4 + 24);
    *((_QWORD *)v21 + 25) = v27;
    v28 = *(_QWORD *)(a4 + 16);
    *((_OWORD *)v21 + 13) = *(_OWORD *)a4;
    *((_QWORD *)v21 + 28) = v28;
    *a5 = v21;
    cfa = 0;
    goto LABEL_11;
  }
  IOSurfaceUnlock(v12, 1u, 0);
  CFRelease(cf);
LABEL_17:
  if (cfa)
    CFRelease(cfa);
LABEL_11:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v17;
}

void sbufReleaseCVDataBufferAfterUnlockingIOSurface(const void *a1)
{
  __IOSurface *IOSurface;

  IOSurface = (__IOSurface *)CVDataBufferGetIOSurface();
  IOSurfaceUnlock(IOSurface, 1u, 0);
  CFRelease(a1);
}

__CFString *sBufCopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  CFIndex v3;
  CFAllocatorRef v4;
  const char *v5;
  const char *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const void *v9;
  CFStringRef v10;
  const __CFAllocator *v11;
  CFStringRef v12;
  uint64_t v13;
  uint64_t v14;
  const __CFAllocator *v15;
  __int128 *v16;
  __int128 v17;
  CFStringRef v18;
  const __CFAllocator *v19;
  uint64_t v20;
  __int128 v21;
  CFStringRef v22;
  const __CFAllocator *v23;
  uint64_t v24;
  __int128 v25;
  CFStringRef v26;
  uint64_t v27;
  CFIndex v28;
  const __CFDictionary *ValueAtIndex;
  const void *v30;
  CFStringRef v31;
  CFStringRef v32;
  uint64_t v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  CMTime time;
  CMTime context;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = CFGetRetainCount((CFTypeRef)a1);
  v4 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("CMSampleBuffer %p retainCount: %d allocator: %p\n"), a1, v3, v4);
  if (*(_BYTE *)(a1 + 24))
    v5 = "YES";
  else
    v5 = "NO";
  CFStringAppendFormat(Mutable, 0, CFSTR("\tinvalid = %s\n"), v5);
  if (*(_BYTE *)(a1 + 26))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\tdataFailed = YES\n"), v35, v36, v37);
  }
  else
  {
    if (*(_BYTE *)(a1 + 25))
      v6 = "YES";
    else
      v6 = "NO";
    if (*(_BYTE *)(a1 + 27))
      CFStringAppendFormat(Mutable, 0, CFSTR("\tdataReady = %s\n\tmakeDataReadyHandler = %p\n"), v6, *(_QWORD *)(a1 + 48), v37);
    else
      CFStringAppendFormat(Mutable, 0, CFSTR("\tdataReady = %s\n\tmakeDataReadyCallback = %p\n\tmakeDataReadyRefcon = %p\n"), v6, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  }
  if (*(_QWORD *)(a1 + 312) || *(_QWORD *)(a1 + 320))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\tbuffer-level attachments:\n"));
    v7 = *(const __CFDictionary **)(a1 + 312);
    if (v7)
    {
      context.value = (CMTimeValue)Mutable;
      *(_QWORD *)&context.timescale = 1;
      CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)describeSBufAnnotation, &context);
    }
  }
  v8 = *(const __CFDictionary **)(a1 + 320);
  if (v8)
  {
    context.value = (CMTimeValue)Mutable;
    *(_QWORD *)&context.timescale = 0;
    CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)describeSBufAnnotation, &context);
  }
  v9 = *(const void **)(a1 + 72);
  if (v9)
  {
    v10 = CFCopyDescription(v9);
    CFStringAppendFormat(Mutable, 0, CFSTR("\tformatDescription = %@\n"), v10);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\tformatDescription = %@\n"), 0);
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("\tsbufToTrackReadiness = %p\n\tnumSamples = %ld\n"), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 80));
  v11 = CFGetAllocator((CFTypeRef)a1);
  CMSampleBufferGetOutputPresentationTimeStamp(&context, (CMSampleBufferRef)a1);
  v12 = CMTimeCopyDescription(v11, &context);
  CFStringAppendFormat(Mutable, 0, CFSTR("\toutputPTS = %@"), v12);
  if (v12)
    CFRelease(v12);
  if ((*(_DWORD *)(a1 + 136) & 0x1D) == 1)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("(based on outputPresentationTimeStamp)\n"));
  }
  else if ((*(_DWORD *)(a1 + 268) & 0x1D) == 1)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("(based on cachedOutputPresentationTimeStamp)\n"));
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("(computed from PTS, duration and attachments)\n"));
  }
  if (*(_QWORD *)(a1 + 88))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\tsampleTimingArray[%d] = {\n"), *(_QWORD *)(a1 + 88));
    if (*(uint64_t *)(a1 + 88) >= 1)
    {
      v13 = 0;
      v14 = 0;
      do
      {
        v15 = CFGetAllocator((CFTypeRef)a1);
        v16 = (__int128 *)(*(_QWORD *)(a1 + 96) + v13);
        v17 = *v16;
        time.epoch = *((_QWORD *)v16 + 2);
        *(_OWORD *)&time.value = v17;
        v18 = CMTimeCopyDescription(v15, &time);
        v19 = CFGetAllocator((CFTypeRef)a1);
        v20 = *(_QWORD *)(a1 + 96) + v13;
        v21 = *(_OWORD *)(v20 + 24);
        time.epoch = *(_QWORD *)(v20 + 40);
        *(_OWORD *)&time.value = v21;
        v22 = CMTimeCopyDescription(v19, &time);
        v23 = CFGetAllocator((CFTypeRef)a1);
        v24 = *(_QWORD *)(a1 + 96) + v13;
        v25 = *(_OWORD *)(v24 + 48);
        time.epoch = *(_QWORD *)(v24 + 64);
        *(_OWORD *)&time.value = v25;
        v26 = CMTimeCopyDescription(v23, &time);
        CFStringAppendFormat(Mutable, 0, CFSTR("\t\t{PTS = %@, DTS = %@, duration = %@},\n"), v22, v26, v18);
        CFRelease(v18);
        CFRelease(v22);
        CFRelease(v26);
        ++v14;
        v13 += 72;
      }
      while (v14 < *(_QWORD *)(a1 + 88));
    }
    CFStringAppendFormat(Mutable, 0, CFSTR("\t}\n"));
  }
  if (*(_QWORD *)(a1 + 104))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\tsampleSizeArray[%d] = {\n"), *(_QWORD *)(a1 + 104));
    if (*(uint64_t *)(a1 + 104) >= 1)
    {
      v27 = 0;
      do
        CFStringAppendFormat(Mutable, 0, CFSTR("\t\tsampleSize = %zu,\n"), *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * v27++));
      while (v27 < *(_QWORD *)(a1 + 104));
    }
    CFStringAppendFormat(Mutable, 0, CFSTR("\t}\n"));
  }
  if (*(_QWORD *)(a1 + 304))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\tsampleAttachmentsArray[%d] = {\n"), *(_QWORD *)(a1 + 104));
    if (*(uint64_t *)(a1 + 80) >= 1)
    {
      v28 = 0;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 304), v28);
        CFStringAppendFormat(Mutable, 0, CFSTR("\t\tsample %d:\n"), v28);
        CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)appendSampleAnnotation, Mutable);
        ++v28;
      }
      while (v28 < *(_QWORD *)(a1 + 80));
    }
    CFStringAppendFormat(Mutable, 0, CFSTR("\t}\n"));
  }
  switch(*(_DWORD *)(a1 + 28))
  {
    case 0:
      v30 = *(const void **)(a1 + 16);
      if (v30)
      {
        v31 = CFCopyDescription(v30);
        if (v31)
        {
          v32 = v31;
          CFStringAppendFormat(Mutable, 0, CFSTR("\tdataBuffer = {\n%@}\n"), v31);
          CFRelease(v32);
          return Mutable;
        }
        v33 = *(_QWORD *)(a1 + 16);
      }
      else
      {
        v33 = 0;
      }
      CFStringAppendFormat(Mutable, 0, CFSTR("\tdataBuffer = %p\n"), v33);
      return Mutable;
    case 1:
      CFStringAppendFormat(Mutable, 0, CFSTR("\timageBuffer = %p\n"), *(_QWORD *)(a1 + 16));
      return Mutable;
    case 2:
      CFStringAppendFormat(Mutable, 0, CFSTR("\tcaptionGroup = %p\n"), *(_QWORD *)(a1 + 16));
      return Mutable;
    case 3:
      CFStringAppendFormat(Mutable, 0, CFSTR("\ttaggedBufferGroup = %p\n"), *(_QWORD *)(a1 + 16));
      return Mutable;
    default:
      return Mutable;
  }
}

void describeSBufAnnotation(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  const char *v5;
  char buffer[4];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v8 = 0u;
  v7 = 0u;
  *(_DWORD *)buffer = 1061109567;
  CFStringGetCString(a1, buffer, 200, 0x8000100u);
  if (*(_DWORD *)(a3 + 8) == 1)
    v5 = "(P)";
  else
    v5 = "   ";
  CFStringAppendFormat(*(CFMutableStringRef *)a3, 0, CFSTR("\t\t%-10s%s = %@\n"), buffer, v5, a2);
}

void appendSampleAnnotation(const __CFString *a1, uint64_t a2, __CFString *a3)
{
  char buffer[4];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v8 = 0u;
  v7 = 0u;
  v6 = 0u;
  *(_DWORD *)buffer = 1061109567;
  CFStringGetCString(a1, buffer, 200, 0x8000100u);
  CFStringAppendFormat(a3, 0, CFSTR("\t\t\t%-10s = %@\n"), buffer, a2);
}

double sBufRemoveAttachment(uint64_t a1, CFTypeRef cf1)
{
  double result;
  __CFDictionary *v5;
  __CFDictionary *v6;

  if (*(_BYTE *)(a1 + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v5 = *(__CFDictionary **)(a1 + 312);
    if (v5)
      CFDictionaryRemoveValue(v5, cf1);
    v6 = *(__CFDictionary **)(a1 + 320);
    if (v6)
      CFDictionaryRemoveValue(v6, cf1);
    return checkCacheKeys(a1, cf1);
  }
  return result;
}

double sBufRemoveAllAttachments(uint64_t a1)
{
  double result;
  const void *v3;
  const void *v4;

  if (*(_BYTE *)(a1 + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v3 = *(const void **)(a1 + 312);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 312) = 0;
    }
    v4 = *(const void **)(a1 + 320);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(a1 + 320) = 0;
    }
    return checkCacheKeys(a1, CFSTR("TrimDurationAtStart"));
  }
  return result;
}

CFDictionaryRef sBufCopyDictionaryOfAttachments(const __CFAllocator *a1, uint64_t a2, int a3)
{
  uint64_t v4;
  const __CFDictionary *v5;

  if (*(_BYTE *)(a2 + 24))
  {
    FigSignalErrorAt(4294954552, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v4 = 320;
  if (a3 == 1)
    v4 = 312;
  v5 = *(const __CFDictionary **)(a2 + v4);
  if (!v5)
    return 0;
  return CFDictionaryCreateCopy(a1, v5);
}

CFTypeID CMSimpleQueueGetTypeID(void)
{
  FigThreadRunOnce(&sRegisterFigSimpleQueueTypeOnce, (void (*)(void))registerFigSimpleQueueType);
  return sFigSimpleQueueID;
}

uint64_t registerFigSimpleQueueType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigSimpleQueueID = result;
  return result;
}

CFTypeRef FigSimpleQueueRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void FigSimpleQueueRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

OSStatus CMSimpleQueueCreate(CFAllocatorRef allocator, int32_t capacity, CMSimpleQueueRef *queueOut)
{
  size_t v5;
  uint64_t Instance;
  opaqueCMSimpleQueue *v7;
  OSStatus result;

  if (capacity && queueOut)
  {
    if (capacity < 0)
    {
      result = FigSignalErrorAt(4294954524, 0, 0, 0, 0, 0, 0);
      v7 = 0;
    }
    else
    {
      v5 = 8 * capacity + 24;
      FigThreadRunOnce(&sRegisterFigSimpleQueueTypeOnce, (void (*)(void))registerFigSimpleQueueType);
      Instance = _CFRuntimeCreateInstance();
      v7 = (opaqueCMSimpleQueue *)Instance;
      if (Instance)
      {
        bzero((void *)(Instance + 16), v5);
        result = 0;
        *((_DWORD *)v7 + 4) = capacity;
      }
      else
      {
        result = FigSignalErrorAt(4294954526, 0, 0, 0, 0, 0, 0);
      }
    }
    goto LABEL_10;
  }
  result = FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  v7 = 0;
  if (queueOut)
LABEL_10:
    *queueOut = v7;
  return result;
}

OSStatus CMSimpleQueueEnqueue(CMSimpleQueueRef queue, const void *element)
{
  uint64_t v3;
  int v4;

  if (!queue || !element)
    return FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  v3 = *((int *)queue + 6);
  v4 = ((int)v3 + 1) % (*((_DWORD *)queue + 4) + 1);
  if (v4 == *((_DWORD *)queue + 5))
    return -12773;
  *((_QWORD *)queue + v3 + 4) = element;
  FigMemoryBarrier();
  *((_DWORD *)queue + 6) = v4;
  FigMemoryBarrier();
  return 0;
}

const void *__cdecl CMSimpleQueueDequeue(CMSimpleQueueRef queue)
{
  uint64_t v2;
  const void *v3;
  int v4;

  if (!queue)
  {
    FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v2 = *((int *)queue + 5);
  if ((_DWORD)v2 == *((_DWORD *)queue + 6))
    return 0;
  v3 = (const void *)*((_QWORD *)queue + v2 + 4);
  v4 = ((int)v2 + 1) % (*((_DWORD *)queue + 4) + 1);
  FigMemoryBarrier();
  *((_DWORD *)queue + 5) = v4;
  FigMemoryBarrier();
  return v3;
}

const void *__cdecl CMSimpleQueueGetHead(CMSimpleQueueRef queue)
{
  uint64_t v1;

  if (queue)
  {
    v1 = *((int *)queue + 5);
    if ((_DWORD)v1 != *((_DWORD *)queue + 6))
      return (const void *)*((_QWORD *)queue + v1 + 4);
  }
  else
  {
    FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

OSStatus CMSimpleQueueReset(CMSimpleQueueRef queue)
{
  if (!queue)
    return FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
  *((_DWORD *)queue + 5) = 0;
  *((_DWORD *)queue + 6) = 0;
  return 0;
}

int32_t CMSimpleQueueGetCapacity(CMSimpleQueueRef queue)
{
  if (queue)
    LODWORD(queue) = *((_DWORD *)queue + 4);
  return (int)queue;
}

int32_t CMSimpleQueueGetCount(CMSimpleQueueRef queue)
{
  CMSimpleQueueRef v1;
  int v2;
  int v3;

  if (queue)
  {
    v1 = queue;
    v2 = *((_DWORD *)queue + 5);
    v3 = *((_DWORD *)queue + 6);
    LODWORD(queue) = v3 - v2;
    if (v3 != v2 && v3 <= v2)
      LODWORD(queue) = (_DWORD)queue + *((_DWORD *)v1 + 4) + 1;
  }
  return (int)queue;
}

uint64_t FigSimpleQueueSetQueueIsFullErrorLoggingEnabled(uint64_t a1)
{
  if (a1)
    return 0;
  else
    return FigSignalErrorAt(4294954525, 0, 0, 0, 0, 0, 0);
}

__CFString *simpQCopyDebugDesc(unsigned int *a1)
{
  __CFString *Mutable;
  CFIndex v3;
  CFAllocatorRef v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int i;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = CFGetRetainCount(a1);
  v4 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CMSimpleQueue %p retainCount: %ld allocator: %p\n"), a1, v3, v4);
  v5 = a1[4];
  v6 = a1[5];
  v7 = a1[6];
  if ((int)v7 <= v6)
    LODWORD(v8) = v5 - v6 + v7 + 1;
  else
    LODWORD(v8) = v7 - v6;
  if ((_DWORD)v7 == v6)
    v8 = 0;
  else
    v8 = v8;
  CFStringAppendFormat(Mutable, 0, CFSTR("\tcapacity = %d\n\tcount = %d\n\treadIndex = %d\n\twriteIndex = %d\n"), v5, v8, a1[5], v7);
  CFStringAppend(Mutable, CFSTR("\telements[readIndex..(writeIndex-1) %% (capacity+1)] = {\n"));
  v9 = (int)a1[5];
  if ((_DWORD)v9 != a1[6])
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\t\t%p"), *(_QWORD *)&a1[2 * v9 + 8]);
    for (i = (int)(a1[5] + 1) % (int)(a1[4] + 1); i != a1[6]; i = (i + 1) % (int)(a1[4] + 1))
      CFStringAppendFormat(Mutable, 0, CFSTR(",\n\t\t%p"), *(_QWORD *)&a1[2 * i + 8]);
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("}\n>\n"));
  return Mutable;
}

uint64_t FigEndpointStreamStartServer()
{
  CFMutableDictionaryRef Mutable;
  uint64_t v1;
  _OWORD v3[3];

  v3[0] = xmmword_1E28D91A8;
  memset(&v3[1], 0, 32);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32(Mutable, CFSTR("xpcServerOption_SelfTerminationTimeout"), 30);
  v1 = FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointstream.xpc", (uint64_t)v3, (uint64_t)Mutable, &gEndpointStreamServer);
  if (Mutable)
    CFRelease(Mutable);
  return v1;
}

uint64_t HandleEndpointStreamRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  uint64_t uint64;
  uint64_t v8;
  CFTypeID v9;
  const void *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  _QWORD *CompletionCallbackParametersFromMessageAndConnection;
  uint64_t v15;
  uint64_t (*v16)(const void *, uint64_t, void (*)(uint64_t, int, uint64_t), _QWORD *);
  void (*v17)(uint64_t, int, uint64_t);
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(const void *, uint64_t, uint64_t);
  uint64_t v21;
  uint64_t (*v22)(uint64_t, const __CFString *, _QWORD, __int128 *);
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t CMTime;
  uint64_t CMBaseObject;
  uint64_t (*v28)(uint64_t, const __CFString *, _QWORD, __int128 *);
  const void *v29;
  _BYTE *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t (*v33)(const void *, uint64_t, void (*)(uint64_t, int, uint64_t), _QWORD *);
  void (*v34)(uint64_t, int, uint64_t);
  uint64_t v35;
  uint64_t v36;
  uint64_t (*v37)(const void *, uint64_t, __int128 *);
  uint64_t v38;
  uint64_t (*v39)(const void *, uint64_t, __int128 *);
  _BYTE *v40;
  double v41;
  _QWORD *v42;
  void (*v43)(double, uint64_t, int, __int128 *, __int128 *, uint64_t);
  uint64_t v44;
  uint64_t (*v45)(const void *, __int128 *, __int128 *, void (*)(double, uint64_t, int, __int128 *, __int128 *, uint64_t), _QWORD *, double);
  _BYTE *v47;
  int v48;
  __int128 v49;
  uint64_t v50;
  __int128 v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  __int128 v55;
  uint64_t v56;
  __int128 v57;
  uint64_t v58;
  __int128 v59;
  uint64_t v60;

  v48 = 0;
  v47 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v48);
  if ((_DWORD)OpCode)
    return OpCode;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  *(_QWORD *)&v59 = 0;
  v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &v59, &v47);
  if (!(_DWORD)v8)
  {
    if ((_QWORD)v59)
    {
      v9 = CFGetTypeID((CFTypeRef)v59);
      if (v9 == FigEndpointStreamGetTypeID())
      {
        v10 = (const void *)v59;
        goto LABEL_6;
      }
    }
    v8 = FigSignalErrorAt(4294950536, 0, 0, 0, 0, 0, 0);
  }
  v11 = v8;
  if ((_QWORD)v59)
    CFRelease((CFTypeRef)v59);
  if (!(_DWORD)v11)
  {
    v10 = 0;
LABEL_6:
    v11 = 4294950536;
    if (v48 > 1886611043)
    {
      if (v48 <= 1936875891)
      {
        if (v48 == 1886611044)
        {
          LOBYTE(v57) = 0;
          *(_QWORD *)&v59 = 0;
          v13 = (uint64_t)FigXPCMessageCopyFigEndpointStreamAudioFormatDescription(*MEMORY[0x1E0C9AE00], a2, "FormatDescription", (uint64_t *)&v59);
          if (!(_DWORD)v13)
          {
            v38 = v59;
            v39 = *(uint64_t (**)(const void *, uint64_t, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                          + 24)
                                                                              + 32);
            if (v39)
            {
              v11 = v39(v10, v38, &v57);
              if (!(_DWORD)v11)
                xpc_dictionary_set_BOOL(a3, "IsPassthroughSupported", (_BYTE)v57 != 0);
LABEL_58:
              v29 = (const void *)v59;
              if (!(_QWORD)v59)
                goto LABEL_74;
              goto LABEL_59;
            }
LABEL_57:
            v11 = 4294954514;
            goto LABEL_58;
          }
LABEL_47:
          v11 = v13;
          goto LABEL_58;
        }
        if (v48 != 1918985828)
        {
          if (v48 != 1920169325)
            goto LABEL_74;
          v12 = v47;
          *(_QWORD *)&v59 = 0;
          v13 = FigXPCMessageCopyCFDictionary(a2, "Options", &v59);
          if (!(_DWORD)v13)
          {
            CompletionCallbackParametersFromMessageAndConnection = CreateCompletionCallbackParametersFromMessageAndConnection(a2, a1);
            v15 = v59;
            v16 = *(uint64_t (**)(const void *, uint64_t, void (*)(uint64_t, int, uint64_t), _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16) + 16);
            if (v16)
            {
              if (CompletionCallbackParametersFromMessageAndConnection)
                v17 = SuspendResumeCompletionCallback;
              else
                v17 = 0;
              v11 = v16(v10, v15, v17, CompletionCallbackParametersFromMessageAndConnection);
              if (!(_DWORD)v11)
                *v12 = 1;
              goto LABEL_58;
            }
            goto LABEL_57;
          }
          goto LABEL_47;
        }
        *(_QWORD *)&v59 = 0;
        CMBaseObject = FigEndpointStreamGetCMBaseObject(v10);
        v28 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                        + 48);
        if (v28)
        {
          v23 = v28(CMBaseObject, CFSTR("RichestAudioFormatDescription"), *MEMORY[0x1E0C9AE00], &v59);
          v24 = (const void *)v59;
          if (!(_DWORD)v23)
          {
            v25 = FigXPCMessageSetFigEndpointStreamAudioFormatDescription(a3, "RichestFormatDescription", (xpc_object_t)v59);
LABEL_39:
            v11 = v25;
            v24 = (const void *)v59;
            if (!(_QWORD)v59)
              goto LABEL_74;
            goto LABEL_40;
          }
LABEL_83:
          v11 = v23;
          if (v24)
          {
LABEL_40:
            v29 = v24;
LABEL_59:
            CFRelease(v29);
          }
LABEL_74:
          if (v10)
            CFRelease(v10);
          return v11;
        }
        goto LABEL_69;
      }
      if (v48 != 1936875892)
      {
        if (v48 == 1936945252)
        {
          v30 = v47;
          *(_QWORD *)&v59 = 0;
          v13 = FigXPCMessageCopyCFDictionary(a2, "Options", &v59);
          if (!(_DWORD)v13)
          {
            v31 = CreateCompletionCallbackParametersFromMessageAndConnection(a2, a1);
            *v30 = 0;
            v32 = v59;
            v33 = *(uint64_t (**)(const void *, uint64_t, void (*)(uint64_t, int, uint64_t), _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16) + 8);
            if (!v33)
              goto LABEL_57;
            if (v31)
              v34 = SuspendResumeCompletionCallback;
            else
              v34 = 0;
            v13 = v33(v10, v32, v34, v31);
          }
          goto LABEL_47;
        }
        if (v48 != 1937072484)
          goto LABEL_74;
        *(_QWORD *)&v59 = 0;
        v21 = FigEndpointStreamGetCMBaseObject(v10);
        v22 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable(v21) + 8)
                                                                                        + 48);
        if (v22)
        {
          v23 = v22(v21, CFSTR("SupportedAudioFormatDescriptions"), *MEMORY[0x1E0C9AE00], &v59);
          v24 = (const void *)v59;
          if (!(_DWORD)v23)
          {
            v25 = FigXPCMessageSetFigEndpointStreamAudioFormatDescriptionArray(a3, "FormatDescriptionArray", (const __CFArray *)v59);
            goto LABEL_39;
          }
          goto LABEL_83;
        }
LABEL_69:
        v11 = 4294954514;
        goto LABEL_74;
      }
      v40 = v47;
      v55 = *(_OWORD *)&kCMTimeInvalid.value;
      v56 = 0;
      v53 = *(_OWORD *)&kCMTimeInvalid.value;
      v54 = 0;
      v41 = xpc_dictionary_get_double(a2, "Rate");
      CMTime = FigXPCMessageGetCMTime(a2, "SampleTime", (uint64_t)&v55);
      if (!(_DWORD)CMTime)
      {
        CMTime = FigXPCMessageGetCMTime(a2, "HostTime", (uint64_t)&v53);
        if (!(_DWORD)CMTime)
        {
          v42 = CreateCompletionCallbackParametersFromMessageAndConnection(a2, a1);
          *v40 = 0;
          if (v42)
            v43 = SetRateAndAnchorTimeCallback;
          else
            v43 = 0;
          v51 = v55;
          v52 = v56;
          v49 = v53;
          v50 = v54;
          v44 = *(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 24);
          if (!v44)
            goto LABEL_69;
          v45 = *(uint64_t (**)(const void *, __int128 *, __int128 *, void (*)(double, uint64_t, int, __int128 *, __int128 *, uint64_t), _QWORD *, double))(v44 + 16);
          if (!v45)
            goto LABEL_69;
          v59 = v51;
          v60 = v52;
          v57 = v49;
          v58 = v50;
          CMTime = v45(v10, &v59, &v57, v43, v42, v41);
        }
      }
LABEL_68:
      v11 = CMTime;
      goto LABEL_74;
    }
    if (v48 <= 1668572771)
    {
      if (v48 == 778268793)
      {
        CMTime = FigXPCHandleStdCopyPropertyMessage((uint64_t)v10, a2, a3);
      }
      else
      {
        if (v48 != 779314548)
          goto LABEL_74;
        CMTime = FigXPCHandleStdSetPropertyMessage((uint64_t)v10, a2);
      }
      goto LABEL_68;
    }
    if (v48 != 1668572772)
    {
      if (v48 != 1685024621)
      {
        if (v48 != 1718383987)
          goto LABEL_74;
        *(_QWORD *)&v59 = 0;
        v13 = FigXPCMessageCopyCFDictionary(a2, "Options", &v59);
        if (!(_DWORD)v13)
        {
          v18 = xpc_dictionary_get_uint64(a2, "FlushFlags");
          v19 = v59;
          v20 = *(uint64_t (**)(const void *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                      + 16)
                                                                          + 24);
          if (!v20)
            goto LABEL_57;
          v13 = v20(v10, v18, v19);
        }
        goto LABEL_47;
      }
      CMTime = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
      goto LABEL_68;
    }
    *(_QWORD *)&v59 = 0;
    *(_QWORD *)&v57 = 0;
    v35 = (uint64_t)FigXPCMessageCopyFigEndpointStreamAudioFormatDescription(*MEMORY[0x1E0C9AE00], a2, "FormatDescription", (uint64_t *)&v59);
    if (!(_DWORD)v35)
    {
      v36 = v59;
      v37 = *(uint64_t (**)(const void *, uint64_t, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                    + 24)
                                                                        + 24);
      if (!v37)
      {
        v11 = 4294954514;
LABEL_71:
        if ((_QWORD)v59)
          CFRelease((CFTypeRef)v59);
        v29 = (const void *)v57;
        if (!(_QWORD)v57)
          goto LABEL_74;
        goto LABEL_59;
      }
      v35 = v37(v10, v36, &v57);
      if (!(_DWORD)v35)
        v35 = FigXPCMessageSetFigEndpointStreamAudioFormatDescription(a3, "FormatDescription", (xpc_object_t)v57);
    }
    v11 = v35;
    goto LABEL_71;
  }
  return v11;
}

uint64_t FigXPCEndpointStreamServerAssociateNeighborFigEndpointStream(_xpc_connection_s *a1, CFTypeRef cf, _QWORD *a3)
{
  CFTypeID v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v11;

  v11 = 0;
  v6 = CFGetTypeID(cf);
  if (v6 != FigEndpointStreamGetTypeID())
  {
    v9 = FigSignalErrorAt(4294950536, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    if (!(_DWORD)v9)
      return v9;
    goto LABEL_4;
  }
  v7 = CreateEndpointStreamServerState(cf, &v11);
  v8 = v11;
  if ((_DWORD)v7)
  {
    v9 = v7;
    goto LABEL_4;
  }
  v9 = FigXPCServerAssociateObjectWithNeighborProcess(gEndpointStreamServer, a1, cf, (uint64_t)v11, (uint64_t)DisposeEndpointStreamServerState, 0, a3);
  if ((_DWORD)v9)
LABEL_4:
    DisposeEndpointStreamServerState(v8);
  return v9;
}

uint64_t CreateEndpointStreamServerState(const void *a1, _QWORD *a2)
{
  _QWORD *v4;
  CFTypeRef v5;
  uint64_t result;

  v4 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040984C81BBuLL);
  if (v4)
  {
    if (a1)
      v5 = CFRetain(a1);
    else
      v5 = 0;
    result = 0;
    v4[2] = v5;
  }
  else
  {
    result = FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0);
  }
  *a2 = v4;
  return result;
}

void DisposeEndpointStreamServerState(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  if (a1)
  {
    v2 = (const void *)a1[1];
    if (v2)
    {
      CFRelease(v2);
      a1[1] = 0;
    }
    v3 = (const void *)a1[2];
    if (v3)
      CFRelease(v3);
    free(a1);
  }
}

uint64_t FigXPCEndpointStreamServerAssociateCopiedNeighborFigEndpointStream(_xpc_connection_s *a1, CFTypeRef cf, _QWORD *a3)
{
  CFTypeID v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v11;

  v11 = 0;
  v6 = CFGetTypeID(cf);
  if (v6 != FigEndpointStreamGetTypeID())
  {
    v9 = FigSignalErrorAt(4294950536, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    if (!(_DWORD)v9)
      return v9;
    goto LABEL_4;
  }
  v7 = CreateEndpointStreamServerState(cf, &v11);
  v8 = v11;
  if ((_DWORD)v7)
  {
    v9 = v7;
    goto LABEL_4;
  }
  v9 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointStreamServer, a1, cf, (uint64_t)v11, (uint64_t)DisposeEndpointStreamServerState, 0, a3);
  if ((_DWORD)v9)
LABEL_4:
    DisposeEndpointStreamServerState(v8);
  return v9;
}

uint64_t FigXPCEndpointStreamServerAssociateCopiedEndpointStreamWithNeighborProcessByPID(int a1, CFTypeRef cf, _QWORD *a3)
{
  CFTypeID v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v11;

  v11 = 0;
  v6 = CFGetTypeID(cf);
  if (v6 != FigEndpointStreamGetTypeID())
  {
    v9 = FigSignalErrorAt(4294950536, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    if (!(_DWORD)v9)
      return v9;
    goto LABEL_4;
  }
  v7 = CreateEndpointStreamServerState(cf, &v11);
  v8 = v11;
  if ((_DWORD)v7)
  {
    v9 = v7;
    goto LABEL_4;
  }
  v9 = FigXPCServerAssociateCopiedObjectWithNeighborProcessByPID(gEndpointStreamServer, a1, cf, (uint64_t)v11, (uint64_t)DisposeEndpointStreamServerState, 0, a3);
  if ((_DWORD)v9)
LABEL_4:
    DisposeEndpointStreamServerState(v8);
  return v9;
}

uint64_t FigXPCEndpointStreamServerRetainEndpointStreamForID(void *a1, _QWORD *a2)
{
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gEndpointStreamServer, a1, a2);
}

_QWORD *CreateCompletionCallbackParametersFromMessageAndConnection(void *a1, void *a2)
{
  uint64_t uint64;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;

  uint64 = xpc_dictionary_get_uint64(a1, "CompletionID");
  if (!uint64)
    return 0;
  v5 = uint64;
  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
  v7 = v6;
  if (v6)
  {
    *v6 = v5;
    v6[1] = xpc_dictionary_get_uint64(a1, ".objectID");
    v7[2] = FigXPCRetain(a2);
  }
  else
  {
    FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0);
  }
  return v7;
}

void SuspendResumeCompletionCallback(uint64_t a1, int a2, uint64_t a3)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a3);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void DestroyCompletionCallbackParameters(xpc_object_t *a1)
{
  if (a1)
  {
    FigXPCRelease(a1[2]);
    free(a1);
  }
}

void SetRateAndAnchorTimeCallback(double a1, uint64_t a2, int a3, __int128 *a4, __int128 *a5, uint64_t a6)
{
  __int128 v11;
  uint64_t v12;
  xpc_object_t xdict;

  xdict = 0;
  if (a6 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a6 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a6);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a3);
    xpc_dictionary_set_double(xdict, "Rate", a1);
    v11 = *a4;
    v12 = *((_QWORD *)a4 + 2);
    FigXPCMessageSetCMTime(xdict, "SampleTime", &v11);
    v11 = *a5;
    v12 = *((_QWORD *)a5 + 2);
    FigXPCMessageSetCMTime(xdict, "HostTime", &v11);
    xpc_connection_send_message(*(xpc_connection_t *)(a6 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a6);
  FigXPCRelease(xdict);
}

uint64_t FigEndpointPlaybackSessionGetClassID()
{
  if (FigEndpointPlaybackSessionGetClassID_sRegisterFigEndpointPlaybackSessionBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointPlaybackSessionGetClassID_sRegisterFigEndpointPlaybackSessionBaseTypeOnce, &FigEndpointPlaybackSessionGetClassID_sFigEndpointPlaybackSessionClassID, (dispatch_function_t)playbackSession_getClassID);
  return FigEndpointPlaybackSessionGetClassID_sFigEndpointPlaybackSessionClassID;
}

uint64_t playbackSession_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&playbackSession_getClassID_sFigEndpointPlaybackSessionClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointPlaybackSessionGetTypeID()
{
  if (FigEndpointPlaybackSessionGetClassID_sRegisterFigEndpointPlaybackSessionBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointPlaybackSessionGetClassID_sRegisterFigEndpointPlaybackSessionBaseTypeOnce, &FigEndpointPlaybackSessionGetClassID_sFigEndpointPlaybackSessionClassID, (dispatch_function_t)playbackSession_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigEndpointPlaybackSessionGetClassID_sFigEndpointPlaybackSessionClassID);
}

CFStringRef playbackSession_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointPlaybackSession %p]"), a1);
}

uint64_t FigCreatePathForPersistentURL(void *a1, uint64_t a2)
{
  void *v4;
  const void *v5;
  const void *v6;

  if (sPUTFunctionsLoadedOnce != -1)
    dispatch_once_f(&sPUTFunctionsLoadedOnce, 0, (dispatch_function_t)LoadPUTFunctions);
  if (!figPersistentURLIsMediaLibraryURL(a1))
    return sPUTCreatePathForPersistentURL(a1, a2);
  if (!figPersistentURLCanTranslateUsingMPMediaLibrary())
    return 0;
  v4 = (void *)MEMORY[0x193FFC34C]();
  v5 = (const void *)objc_msgSend((id)objc_msgSend((id)getMPMediaLibraryClass(), "defaultMediaLibrary"), "pathForAssetURL:", a1);
  v6 = v5;
  if (v5)
    CFRetain(v5);
  objc_autoreleasePoolPop(v4);
  return (uint64_t)v6;
}

void *LoadPUTFunctions()
{
  void *v0;
  void *v1;
  void *result;

  v0 = dlopen("/System/Library/PrivateFrameworks/PhotoLibraryServicesCore.framework/PhotoLibraryServicesCore", 4);
  if (!v0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  v1 = v0;
  sPUTCreatePathForPersistentURL = dlsym(v0, "PUTCreatePathForPersistentURL");
  sPUTCreateSandboxExtensionURLForPersistentURL = dlsym(v1, "PUTCreateSandboxExtensionURLForPersistentURL");
  sPUTIsPersistentURL = dlsym(v1, "PUTIsPersistentURL");
  result = dlsym(v1, "PUTGetCurrentAccessForURLAndToken");
  sPUTGetCurrentAccessForURLAndToken = result;
  return result;
}

uint64_t figPersistentURLIsMediaLibraryURL(void *a1)
{
  void *v2;
  uint64_t v3;

  v2 = (void *)MEMORY[0x193FFC34C]();
  if (objc_msgSend(MEMORY[0x1E0C99E98], "instancesRespondToSelector:", sel_msv_isValidMediaAssetURL))
    v3 = objc_msgSend(a1, "msv_isValidMediaAssetURL");
  else
    v3 = 0;
  objc_autoreleasePoolPop(v2);
  return v3;
}

uint64_t FigCreateSecurityScopedFileURLForPersistentURL(void *a1)
{
  void *v2;
  const void *v3;
  const void *v4;

  if (sPUTFunctionsLoadedOnce != -1)
    dispatch_once_f(&sPUTFunctionsLoadedOnce, 0, (dispatch_function_t)LoadPUTFunctions);
  if (!figPersistentURLIsMediaLibraryURL(a1))
    return sPUTCreateSandboxExtensionURLForPersistentURL(a1);
  if (!figPersistentURLCanTranslateUsingMPMediaLibrary())
    return 0;
  v2 = (void *)MEMORY[0x193FFC34C]();
  v3 = (const void *)objc_msgSend((id)objc_msgSend((id)getMPMediaLibraryClass(), "defaultMediaLibrary"), "securityScopedFileURLForAssetURL:", a1);
  v4 = v3;
  if (v3)
    CFRetain(v3);
  objc_autoreleasePoolPop(v2);
  return (uint64_t)v4;
}

uint64_t FigIsPersistentURL(const __CFURL *a1)
{
  const __CFString *v2;
  const __CFString *v3;
  CFComparisonResult v4;
  uint64_t result;

  v2 = CFURLCopyScheme(a1);
  if (!v2)
    goto LABEL_5;
  v3 = v2;
  if (CFStringCompare(v2, CFSTR("file"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v3, CFSTR("http"), 1uLL) == kCFCompareEqualTo)
  {
    CFRelease(v3);
    return 0;
  }
  v4 = CFStringCompare(v3, CFSTR("https"), 1uLL);
  CFRelease(v3);
  if (v4 == kCFCompareEqualTo)
    return 0;
LABEL_5:
  if (sPUTFunctionsLoadedOnce != -1)
    dispatch_once_f(&sPUTFunctionsLoadedOnce, 0, (dispatch_function_t)LoadPUTFunctions);
  if ((sPUTIsPersistentURL(a1) & 1) != 0)
    return 1;
  result = figPersistentURLIsMediaLibraryURL(a1);
  if ((_DWORD)result)
    return 1;
  return result;
}

BOOL FigMayAccessPersistentURLOnBehalfOfClientWithAuditToken(void *a1, _OWORD *a2)
{
  __int128 v5;
  _OWORD v6[2];

  if (sPUTFunctionsLoadedOnce != -1)
    dispatch_once_f(&sPUTFunctionsLoadedOnce, 0, (dispatch_function_t)LoadPUTFunctions);
  if (figPersistentURLIsMediaLibraryURL(a1))
    return 1;
  v5 = a2[1];
  v6[0] = *a2;
  v6[1] = v5;
  return sPUTGetCurrentAccessForURLAndToken(a1, v6) == 2;
}

uint64_t figPersistentURLCanTranslateUsingMPMediaLibrary()
{
  uint64_t result;

  result = objc_msgSend(MEMORY[0x1E0C99E98], "instancesRespondToSelector:", sel_msv_isValidMediaAssetURL);
  if ((_DWORD)result)
  {
    if (!MediaPlayerLibraryCore_frameworkLibrary)
      MediaPlayerLibraryCore_frameworkLibrary = _sl_dlopen();
    return MediaPlayerLibraryCore_frameworkLibrary != 0;
  }
  return result;
}

uint64_t getMPMediaLibraryClass()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = __Block_byref_object_copy_;
  v7 = __Block_byref_object_dispose_;
  v0 = getMPMediaLibraryClass_softClass;
  v8 = getMPMediaLibraryClass_softClass;
  if (!getMPMediaLibraryClass_softClass)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __getMPMediaLibraryClass_block_invoke;
    v2[3] = &unk_1E28D9708;
    v2[4] = &v3;
    __getMPMediaLibraryClass_block_invoke((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18ECBB070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class __getMPMediaLibraryClass_block_invoke(uint64_t a1)
{
  Class result;

  if (!MediaPlayerLibraryCore_frameworkLibrary)
    MediaPlayerLibraryCore_frameworkLibrary = _sl_dlopen();
  result = objc_getClass("MPMediaLibrary");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  getMPMediaLibraryClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

double FigGeometryDimensionMakeMirrored(uint64_t a1, int a2)
{
  double result;

  result = -*(double *)&a1;
  if (a2 == 622862368)
    return 100.0 - *(double *)&a1;
  return result;
}

uint64_t FigGeometryPointMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

uint64_t FigGeometrySizeMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

uint64_t FigGeometryVectorMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  *a5 = result;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return result;
}

uint64_t FigGeometryRectMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _QWORD *a9@<X8>)
{
  *a9 = result;
  a9[1] = a2;
  a9[2] = a3;
  a9[3] = a4;
  a9[4] = a5;
  a9[5] = a6;
  a9[6] = a7;
  a9[7] = a8;
  return result;
}

uint64_t FigGeometryDimensionMakeZeroedDimension()
{
  return 0;
}

uint64_t FigGeometryPointMakeZeroedPoint@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(unsigned int *)(result + 8) | 0x100000000;
  *a2 = 0;
  a2[1] = v2;
  v3 = *(unsigned int *)(result + 24) | 0x100000000;
  a2[2] = 0;
  a2[3] = v3;
  return result;
}

uint64_t FigGeometrySizeMakeZeroedSize@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(unsigned int *)(result + 8) | 0x100000000;
  *a2 = 0;
  a2[1] = v2;
  v3 = *(unsigned int *)(result + 24) | 0x100000000;
  a2[2] = 0;
  a2[3] = v3;
  return result;
}

uint64_t FigGeometryVectorMakeZeroedVector@<X0>(uint64_t result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(unsigned int *)(result + 8) | 0x100000000;
  *a2 = 0;
  a2[1] = v2;
  v3 = *(unsigned int *)(result + 24) | 0x100000000;
  a2[2] = 0;
  a2[3] = v3;
  return result;
}

unsigned int *FigGeometryRectMakeZeroedRect@<X0>(unsigned int *result@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = result[2] | 0x100000000;
  v3 = result[6] | 0x100000000;
  *a2 = 0;
  a2[1] = v2;
  a2[2] = 0;
  a2[3] = v3;
  v4 = result[10] | 0x100000000;
  v5 = result[14] | 0x100000000;
  a2[4] = 0;
  a2[5] = v4;
  a2[6] = 0;
  a2[7] = v5;
  return result;
}

__n128 FigGeometryPointMakeFromPointAndReferenceUnits@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a1;
  v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

__n128 FigGeometrySizeMakeFromSizeAndReferenceUnits@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a1;
  v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

__n128 FigGeometryVectorMakeFromVectorAndReferenceUnits@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a1;
  v4 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v4;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(a2 + 24);
  return result;
}

double FigGeometryRectMakeFromRectAndReferenceUnits@<D0>(uint64_t *a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  double result;
  int v8;
  int v9;
  int v10;
  int v11;

  v3 = *a1;
  *(_QWORD *)(a3 + 12) = *(uint64_t *)((char *)a1 + 12);
  v4 = *((_DWORD *)a1 + 5);
  v5 = *((_DWORD *)a1 + 7);
  *(_DWORD *)(a3 + 8) = a2[2];
  v6 = a2[6];
  *(_QWORD *)a3 = v3;
  *(_DWORD *)(a3 + 20) = v4;
  *(_DWORD *)(a3 + 24) = v6;
  *(_DWORD *)(a3 + 28) = v5;
  result = *((double *)a1 + 4);
  v8 = *((_DWORD *)a1 + 13);
  *(_QWORD *)(a3 + 44) = *(uint64_t *)((char *)a1 + 44);
  v9 = *((_DWORD *)a1 + 15);
  v10 = a2[10];
  v11 = a2[14];
  *(double *)(a3 + 32) = result;
  *(_DWORD *)(a3 + 40) = v10;
  *(_DWORD *)(a3 + 52) = v8;
  *(_DWORD *)(a3 + 56) = v11;
  *(_DWORD *)(a3 + 60) = v9;
  return result;
}

BOOL FigGeometryDimensionEqualToDimension(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL4 v5;

  v5 = *(double *)&a1 == *(double *)&a3 && (_DWORD)a2 == (_DWORD)a4;
  return HIDWORD(a2) == HIDWORD(a4) && v5;
}

BOOL FigGeometryPointEqualToPoint(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (HIDWORD(v2) != HIDWORD(v3))
    return 0;
  if ((_DWORD)v2 != (_DWORD)v3 || *(double *)a1 != *(double *)a2)
    return 0;
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a2 + 24);
  if (HIDWORD(v5) != HIDWORD(v6))
    return 0;
  return *(double *)(a1 + 16) == *(double *)(a2 + 16) && (_DWORD)v5 == (_DWORD)v6;
}

BOOL FigGeometrySizeEqualToSize(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (HIDWORD(v2) != HIDWORD(v3))
    return 0;
  if ((_DWORD)v2 != (_DWORD)v3 || *(double *)a1 != *(double *)a2)
    return 0;
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a2 + 24);
  if (HIDWORD(v5) != HIDWORD(v6))
    return 0;
  return *(double *)(a1 + 16) == *(double *)(a2 + 16) && (_DWORD)v5 == (_DWORD)v6;
}

BOOL FigGeometryVectorEqualToVector(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (HIDWORD(v2) != HIDWORD(v3))
    return 0;
  if ((_DWORD)v2 != (_DWORD)v3 || *(double *)a1 != *(double *)a2)
    return 0;
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a2 + 24);
  if (HIDWORD(v5) != HIDWORD(v6))
    return 0;
  return *(double *)(a1 + 16) == *(double *)(a2 + 16) && (_DWORD)v5 == (_DWORD)v6;
}

BOOL FigGeometryRectEqualToRect(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (HIDWORD(v2) != HIDWORD(v3))
    return 0;
  if ((_DWORD)v2 != (_DWORD)v3 || *(double *)a1 != *(double *)a2)
    return 0;
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a2 + 24);
  if (HIDWORD(v5) != HIDWORD(v6))
    return 0;
  if ((_DWORD)v5 != (_DWORD)v6 || *(double *)(a1 + 16) != *(double *)(a2 + 16))
    return 0;
  v8 = *(_QWORD *)(a1 + 40);
  v9 = *(_QWORD *)(a2 + 40);
  if (HIDWORD(v8) != HIDWORD(v9))
    return 0;
  v10 = 0;
  if ((_DWORD)v8 != (_DWORD)v9 || *(double *)(a1 + 32) != *(double *)(a2 + 32))
    return v10;
  v11 = *(_QWORD *)(a1 + 56);
  v12 = *(_QWORD *)(a2 + 56);
  if (HIDWORD(v11) != HIDWORD(v12))
    return 0;
  return *(double *)(a1 + 48) == *(double *)(a2 + 48) && (_DWORD)v11 == (_DWORD)v12;
}

__CFString *FigGeometryDimensionCopyDescription(const __CFAllocator *a1, uint64_t a2, unint64_t a3)
{
  __CFString *Mutable;
  __CFString *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  const char *v16;

  Mutable = CFStringCreateMutable(a1, 0);
  v6 = Mutable;
  if (Mutable)
  {
    if ((a3 & 0x100000000) != 0)
    {
      if ((a3 & 0x1000000000) != 0)
      {
        v9 = 0;
        v10 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v9] != (_DWORD)a3)
        {
          v9 += 4;
          if (v9 == 52)
            goto LABEL_17;
        }
        v10 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v9 + 2];
LABEL_17:
        CFStringAppendFormat(Mutable, 0, CFSTR("{INDEFINITE}%s"), v10);
      }
      else if ((a3 & 0x400000000) != 0)
      {
        v11 = 0;
        v12 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v11] != (_DWORD)a3)
        {
          v11 += 4;
          if (v11 == 52)
            goto LABEL_23;
        }
        v12 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v11 + 2];
LABEL_23:
        CFStringAppendFormat(Mutable, 0, CFSTR("{+INFINITY}%s"), v12);
      }
      else if ((a3 & 0x800000000) != 0)
      {
        v13 = 0;
        v14 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v13] != (_DWORD)a3)
        {
          v13 += 4;
          if (v13 == 52)
            goto LABEL_29;
        }
        v14 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v13 + 2];
LABEL_29:
        CFStringAppendFormat(Mutable, 0, CFSTR("{-INFINITY}%s"), v14);
      }
      else if ((BYTE4(a3) & 0x1D) == 1)
      {
        v7 = 0;
        v8 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v7] != (_DWORD)a3)
        {
          v7 += 4;
          if (v7 == 52)
            goto LABEL_35;
        }
        v8 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v7 + 2];
LABEL_35:
        CFStringAppendFormat(Mutable, 0, CFSTR("%0.2f%s"), a2, v8);
        if ((a3 & 0x200000000) != 0)
          CFStringAppendFormat(v6, 0, CFSTR("<rounded>"));
        if ((a3 & 0x2000000000) != 0)
          CFStringAppendFormat(v6, 0, CFSTR("<reversed>"));
        if ((a3 & 0xFFFFFFDC00000000) != 0)
          CFStringAppendFormat(v6, 0, CFSTR("<flags=0x%08x>"), HIDWORD(a3));
      }
      else
      {
        v15 = 0;
        v16 = "<missing>";
        while (_fgFigGeometryUnitsTypeToString_mappings[v15] != (_DWORD)a3)
        {
          v15 += 4;
          if (v15 == 52)
            goto LABEL_42;
        }
        v16 = *(const char **)&_fgFigGeometryUnitsTypeToString_mappings[v15 + 2];
LABEL_42:
        CFStringAppendFormat(Mutable, 0, CFSTR("{UNKNOWN}%s"), v16);
      }
    }
    else
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("{INVALID}"));
    }
  }
  return v6;
}

__CFString *FigGeometryPointCopyDescription(const __CFAllocator *a1, uint64_t a2)
{
  __CFString *Mutable;
  __CFString *v5;
  __CFString *v6;
  __CFString *v7;
  BOOL v8;

  Mutable = CFStringCreateMutable(a1, 0);
  v5 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 8));
  v6 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
  v7 = v6;
  if (!Mutable || (v5 ? (v8 = v6 == 0) : (v8 = 1), v8))
  {
    if (!v5)
      goto LABEL_9;
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("(%@, %@)"), v5, v6);
  }
  CFRelease(v5);
LABEL_9:
  if (v7)
    CFRelease(v7);
  return Mutable;
}

__CFString *FigGeometrySizeCopyDescription(const __CFAllocator *a1, uint64_t a2)
{
  __CFString *Mutable;
  __CFString *v5;
  __CFString *v6;
  __CFString *v7;
  BOOL v8;

  Mutable = CFStringCreateMutable(a1, 0);
  v5 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 8));
  v6 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
  v7 = v6;
  if (!Mutable || (v5 ? (v8 = v6 == 0) : (v8 = 1), v8))
  {
    if (!v5)
      goto LABEL_9;
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("(%@, %@)"), v5, v6);
  }
  CFRelease(v5);
LABEL_9:
  if (v7)
    CFRelease(v7);
  return Mutable;
}

__CFString *FigGeometryVectorCopyDescription(const __CFAllocator *a1, uint64_t a2)
{
  __CFString *Mutable;
  __CFString *v5;
  __CFString *v6;
  __CFString *v7;
  BOOL v8;

  Mutable = CFStringCreateMutable(a1, 0);
  v5 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 8));
  v6 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
  v7 = v6;
  if (!Mutable || (v5 ? (v8 = v6 == 0) : (v8 = 1), v8))
  {
    if (!v5)
      goto LABEL_9;
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("<%@, %@>"), v5, v6);
  }
  CFRelease(v5);
LABEL_9:
  if (v7)
    CFRelease(v7);
  return Mutable;
}

__CFString *FigGeometryRectCopyDescription(const __CFAllocator *a1, __int128 *a2)
{
  __CFString *Mutable;
  __int128 v5;
  __CFString *v6;
  __int128 v7;
  __CFString *v8;
  __CFString *v9;
  __int128 v11;
  __int128 v12;

  Mutable = CFStringCreateMutable(a1, 0);
  v5 = a2[1];
  v11 = *a2;
  v12 = v5;
  v6 = FigGeometryPointCopyDescription(a1, (uint64_t)&v11);
  v7 = a2[3];
  v11 = a2[2];
  v12 = v7;
  v8 = FigGeometrySizeCopyDescription(a1, (uint64_t)&v11);
  v9 = v8;
  if (Mutable && v6 && v8)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("{origin:%@, size:%@}"), v6, v8);
  }
  else if (!v6)
  {
    goto LABEL_7;
  }
  CFRelease(v6);
LABEL_7:
  if (v9)
    CFRelease(v9);
  return Mutable;
}

double FigGeometryDimensionGetCGFloat(uint64_t a1)
{
  return *(double *)&a1;
}

double FigGeometryPointGetCGPoint(uint64_t a1)
{
  return *(double *)a1;
}

double FigGeometrySizeGetCGSize(uint64_t a1)
{
  return *(double *)a1;
}

double FigGeometryVectorGetCGVector(uint64_t a1)
{
  return *(double *)a1;
}

double FigGeometryRectGetCGRect(uint64_t a1)
{
  return *(double *)a1;
}

_OWORD *FigGeometryPointMakeFromCGPointAndReferenceUnits@<X0>(_OWORD *result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = *result;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)((char *)result + 12);
  *(double *)a2 = a3;
  *(_DWORD *)(a2 + 12) = 1;
  *(double *)(a2 + 16) = a4;
  *(_DWORD *)(a2 + 28) = 1;
  return result;
}

_OWORD *FigGeometrySizeMakeFromCGSizeAndReferenceUnits@<X0>(_OWORD *result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = *result;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)((char *)result + 12);
  *(double *)a2 = a3;
  *(_DWORD *)(a2 + 12) = 1;
  *(double *)(a2 + 16) = a4;
  *(_DWORD *)(a2 + 28) = 1;
  return result;
}

_OWORD *FigGeometryVectorMakeFromCGVectorAndReferenceUnits@<X0>(_OWORD *result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)a2 = *result;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)((char *)result + 12);
  *(double *)a2 = a3;
  *(_DWORD *)(a2 + 12) = 1;
  *(double *)(a2 + 16) = a4;
  *(_DWORD *)(a2 + 28) = 1;
  return result;
}

_DWORD *FigGeometryRectMakeFromCGRectAndReferenceUnits@<X0>(_DWORD *result@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  int v6;
  int v7;
  int v8;
  int v9;

  v6 = result[2];
  v7 = result[6];
  *(double *)a2 = a3;
  *(_DWORD *)(a2 + 8) = v6;
  *(_DWORD *)(a2 + 12) = 1;
  *(double *)(a2 + 16) = a4;
  *(_DWORD *)(a2 + 24) = v7;
  *(_DWORD *)(a2 + 28) = 1;
  v8 = result[10];
  v9 = result[14];
  *(double *)(a2 + 32) = a5;
  *(_DWORD *)(a2 + 40) = v8;
  *(_DWORD *)(a2 + 44) = 1;
  *(double *)(a2 + 48) = a6;
  *(_DWORD *)(a2 + 56) = v9;
  *(_DWORD *)(a2 + 60) = 1;
  return result;
}

CFDictionaryRef FigGeometryDimensionCopyAsDictionary(uint64_t a1, uint64_t a2, const __CFAllocator *a3)
{
  const __CFAllocator *v4;
  CFDictionaryRef v5;
  uint64_t i;
  const void *v7;
  uint64_t valuePtr;
  uint64_t v10;
  void *values[3];
  void *keys[2];
  const __CFString *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  valuePtr = a1;
  v10 = a2;
  *(_OWORD *)keys = xmmword_1E28D9780;
  v13 = CFSTR("flags");
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCGFloatType, &valuePtr);
  values[1] = CFNumberCreate(v4, kCFNumberSInt32Type, &v10);
  values[2] = CFNumberCreate(v4, kCFNumberSInt32Type, (char *)&v10 + 4);
  v5 = CFDictionaryCreate(a3, (const void **)keys, (const void **)values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  for (i = 0; i != 3; ++i)
  {
    v7 = values[i];
    if (v7)
      CFRelease(v7);
  }
  return v5;
}

const void *FigGeometryDimensionMakeFromDictionary(const void *result)
{
  uint64_t v1;
  CFTypeID v2;
  uint64_t v3;
  uint64_t v4;

  if (result)
  {
    v1 = (uint64_t)result;
    v2 = CFGetTypeID(result);
    if (v2 == CFDictionaryGetTypeID()
      && (v3 = 0, v4 = 0, FigCFDictionaryGetCGFloatIfPresent(v1, CFSTR("value"), &v4))
      && FigCFDictionaryGetInt32IfPresent(v1, CFSTR("units"), (char *)&v3 + 4)
      && FigCFDictionaryGetInt32IfPresent(v1, CFSTR("flags"), &v3))
    {
      return (const void *)v4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFDictionaryRef FigGeometryPointCopyAsDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  BOOL v7;
  CFDictionaryRef v8;
  CFDictionaryRef v10;
  const void *v11[2];
  void *keys[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = FigGeometryDimensionCopyAsDictionary(*a1, a1[1], a2);
  v5 = FigGeometryDimensionCopyAsDictionary(a1[2], a1[3], a2);
  v6 = v5;
  if (v4)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    *(_OWORD *)keys = xmmword_1E28D9798;
    v11[0] = v4;
    v11[1] = v5;
    v10 = CFDictionaryCreate(a2, (const void **)keys, v11, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_10;
  }
  v10 = 0;
  v8 = 0;
  if (v4)
  {
LABEL_10:
    CFRelease(v4);
    v8 = v10;
    if (!v6)
      return v8;
    goto LABEL_8;
  }
  if (v5)
LABEL_8:
    CFRelease(v6);
  return v8;
}

CFTypeID FigGeometryPointMakeFromDictionary@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  const __CFDictionary *v2;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef cf;
  void *value;

  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  cf = 0;
  value = 0;
  if (result)
  {
    v2 = (const __CFDictionary *)result;
    v4 = CFGetTypeID((CFTypeRef)result);
    result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      result = CFDictionaryGetValueIfPresent(v2, CFSTR("x"), (const void **)&value);
      if ((_DWORD)result)
      {
        result = CFDictionaryGetValueIfPresent(v2, CFSTR("y"), &cf);
        if ((_DWORD)result)
        {
          result = (CFTypeID)value;
          if (value)
          {
            v5 = CFGetTypeID(value);
            result = CFDictionaryGetTypeID();
            if (v5 == result)
            {
              result = (CFTypeID)cf;
              if (cf)
              {
                v6 = CFGetTypeID(cf);
                result = CFDictionaryGetTypeID();
                if (v6 == result)
                {
                  v7 = FigGeometryDimensionMakeFromDictionary(value);
                  v9 = v8;
                  result = (CFTypeID)FigGeometryDimensionMakeFromDictionary(cf);
                  *(_QWORD *)a2 = v7;
                  *(_QWORD *)(a2 + 8) = v9;
                  *(_QWORD *)(a2 + 16) = result;
                  *(_QWORD *)(a2 + 24) = v10;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDictionaryRef FigGeometrySizeCopyAsDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  BOOL v7;
  CFDictionaryRef v8;
  CFDictionaryRef v10;
  const void *v11[2];
  void *keys[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = FigGeometryDimensionCopyAsDictionary(*a1, a1[1], a2);
  v5 = FigGeometryDimensionCopyAsDictionary(a1[2], a1[3], a2);
  v6 = v5;
  if (v4)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    *(_OWORD *)keys = xmmword_1E28D97A8;
    v11[0] = v4;
    v11[1] = v5;
    v10 = CFDictionaryCreate(a2, (const void **)keys, v11, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_10;
  }
  v10 = 0;
  v8 = 0;
  if (v4)
  {
LABEL_10:
    CFRelease(v4);
    v8 = v10;
    if (!v6)
      return v8;
    goto LABEL_8;
  }
  if (v5)
LABEL_8:
    CFRelease(v6);
  return v8;
}

CFTypeID FigGeometrySizeMakeFromDictionary@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  const __CFDictionary *v2;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef cf;
  void *value;

  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  cf = 0;
  value = 0;
  if (result)
  {
    v2 = (const __CFDictionary *)result;
    v4 = CFGetTypeID((CFTypeRef)result);
    result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      result = CFDictionaryGetValueIfPresent(v2, CFSTR("width"), (const void **)&value);
      if ((_DWORD)result)
      {
        result = CFDictionaryGetValueIfPresent(v2, CFSTR("height"), &cf);
        if ((_DWORD)result)
        {
          result = (CFTypeID)value;
          if (value)
          {
            v5 = CFGetTypeID(value);
            result = CFDictionaryGetTypeID();
            if (v5 == result)
            {
              result = (CFTypeID)cf;
              if (cf)
              {
                v6 = CFGetTypeID(cf);
                result = CFDictionaryGetTypeID();
                if (v6 == result)
                {
                  v7 = FigGeometryDimensionMakeFromDictionary(value);
                  v9 = v8;
                  result = (CFTypeID)FigGeometryDimensionMakeFromDictionary(cf);
                  *(_QWORD *)a2 = v7;
                  *(_QWORD *)(a2 + 8) = v9;
                  *(_QWORD *)(a2 + 16) = result;
                  *(_QWORD *)(a2 + 24) = v10;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDictionaryRef FigGeometryVectorCopyAsDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  BOOL v7;
  CFDictionaryRef v8;
  CFDictionaryRef v10;
  const void *v11[2];
  void *keys[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = FigGeometryDimensionCopyAsDictionary(*a1, a1[1], a2);
  v5 = FigGeometryDimensionCopyAsDictionary(a1[2], a1[3], a2);
  v6 = v5;
  if (v4)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    *(_OWORD *)keys = xmmword_1E28D97B8;
    v11[0] = v4;
    v11[1] = v5;
    v10 = CFDictionaryCreate(a2, (const void **)keys, v11, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_10;
  }
  v10 = 0;
  v8 = 0;
  if (v4)
  {
LABEL_10:
    CFRelease(v4);
    v8 = v10;
    if (!v6)
      return v8;
    goto LABEL_8;
  }
  if (v5)
LABEL_8:
    CFRelease(v6);
  return v8;
}

CFTypeID FigGeometryVectorMakeFromDictionary@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  const __CFDictionary *v2;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef cf;
  void *value;

  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  cf = 0;
  value = 0;
  if (result)
  {
    v2 = (const __CFDictionary *)result;
    v4 = CFGetTypeID((CFTypeRef)result);
    result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      result = CFDictionaryGetValueIfPresent(v2, CFSTR("dx"), (const void **)&value);
      if ((_DWORD)result)
      {
        result = CFDictionaryGetValueIfPresent(v2, CFSTR("dy"), &cf);
        if ((_DWORD)result)
        {
          result = (CFTypeID)value;
          if (value)
          {
            v5 = CFGetTypeID(value);
            result = CFDictionaryGetTypeID();
            if (v5 == result)
            {
              result = (CFTypeID)cf;
              if (cf)
              {
                v6 = CFGetTypeID(cf);
                result = CFDictionaryGetTypeID();
                if (v6 == result)
                {
                  v7 = FigGeometryDimensionMakeFromDictionary(value);
                  v9 = v8;
                  result = (CFTypeID)FigGeometryDimensionMakeFromDictionary(cf);
                  *(_QWORD *)a2 = v7;
                  *(_QWORD *)(a2 + 8) = v9;
                  *(_QWORD *)(a2 + 16) = result;
                  *(_QWORD *)(a2 + 24) = v10;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDictionaryRef FigGeometryRectCopyAsDictionary(_OWORD *a1, const __CFAllocator *a2)
{
  __int128 v4;
  CFDictionaryRef v5;
  __int128 v6;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  CFDictionaryRef v10;
  const void *v12[2];
  void *keys[2];
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = a1[1];
  *(_OWORD *)keys = *a1;
  v14 = v4;
  v5 = FigGeometryPointCopyAsDictionary((uint64_t *)keys, a2);
  v6 = a1[3];
  *(_OWORD *)keys = a1[2];
  v14 = v6;
  v7 = FigGeometrySizeCopyAsDictionary((uint64_t *)keys, a2);
  v8 = v7;
  if (v5 && v7)
  {
    *(_OWORD *)keys = xmmword_1E28D97C8;
    v12[0] = v5;
    v12[1] = v7;
    v9 = CFDictionaryCreate(a2, (const void **)keys, v12, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v9 = 0;
    v10 = 0;
    if (!v5)
      goto LABEL_6;
  }
  CFRelease(v5);
  v10 = v9;
LABEL_6:
  if (v8)
    CFRelease(v8);
  return v10;
}

double FigGeometryRectMakeFromDictionary@<D0>(const void *a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  __int128 v8;
  __int128 v9;
  _OWORD v10[2];
  _OWORD v11[2];
  void *v12;
  void *value;

  result = 0.0;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  v12 = 0;
  value = 0;
  if (a1)
  {
    v5 = CFGetTypeID(a1);
    if (v5 == CFDictionaryGetTypeID())
    {
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)a1, CFSTR("origin"), (const void **)&value))
      {
        if (CFDictionaryGetValueIfPresent((CFDictionaryRef)a1, CFSTR("size"), (const void **)&v12))
        {
          if (value)
          {
            v6 = CFGetTypeID(value);
            if (v6 == CFDictionaryGetTypeID())
            {
              if (v12)
              {
                v7 = CFGetTypeID(v12);
                if (v7 == CFDictionaryGetTypeID())
                {
                  FigGeometryPointMakeFromDictionary((CFTypeID)value, (uint64_t)v11);
                  FigGeometrySizeMakeFromDictionary((CFTypeID)v12, (uint64_t)v10);
                  v8 = v11[1];
                  *a2 = v11[0];
                  a2[1] = v8;
                  result = *(double *)v10;
                  v9 = v10[1];
                  a2[2] = v10[0];
                  a2[3] = v9;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FigXPCMessageSetFigEndpointStreamAudioFormatDescription(void *a1, const char *a2, xpc_object_t a3)
{
  uint64_t v5;
  xpc_object_t value;

  value = 0;
  if (a1 && a2)
  {
    if (a3)
    {
      v5 = _FigEndpointStreamAudioFormatDescriptionCopyXPCObject((uint64_t)a3, &value);
      a3 = value;
      if (!(_DWORD)v5)
      {
        xpc_dictionary_set_value(a1, a2, value);
        a3 = value;
      }
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v5 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    a3 = 0;
  }
  FigXPCRelease(a3);
  return v5;
}

uint64_t _FigEndpointStreamAudioFormatDescriptionCopyXPCObject(uint64_t a1, _QWORD *a2)
{
  uint64_t ASBD;
  uint64_t v5;
  __int128 v6;
  xpc_object_t v7;
  _OWORD v9[2];
  uint64_t v10;
  int ChannelLayoutTag;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  ASBD = FigEndpointStreamAudioFormatDescriptionGetASBD(a1);
  v5 = *(_QWORD *)(ASBD + 32);
  v6 = *(_OWORD *)(ASBD + 16);
  v9[0] = *(_OWORD *)ASBD;
  v9[1] = v6;
  v10 = v5;
  ChannelLayoutTag = FigEndpointStreamAudioFormatDescriptionGetChannelLayoutTag(a1);
  v7 = xpc_data_create(v9, 0x2CuLL);
  *a2 = v7;
  if (v7)
    return 0;
  else
    return FigSignalErrorAt(4294950014, 0, 0, 0, 0, 0, 0);
}

xpc_object_t FigXPCMessageCopyFigEndpointStreamAudioFormatDescription(uint64_t a1, xpc_object_t xdict, char *key, uint64_t *a4)
{
  xpc_object_t result;

  if (!xdict || !key || !a4)
    return (xpc_object_t)FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  result = xpc_dictionary_get_value(xdict, key);
  if (result)
    return (xpc_object_t)_FigEndpointStreamAudioFormatDescriptionCreateWithXPCObject(a1, result, a4);
  *a4 = 0;
  return result;
}

uint64_t _FigEndpointStreamAudioFormatDescriptionCreateWithXPCObject(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v7;
  __int128 v8[3];

  memset(v8, 0, 44);
  if (!a2)
  {
    v7 = 4294950016;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (!a3)
  {
    v7 = 4294950016;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (MEMORY[0x193FFCDCC](a2) != MEMORY[0x1E0C812E8])
  {
    v7 = 4294950013;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (xpc_data_get_bytes(a2, v8, 0, 0x2CuLL) == 44)
    return FigEndpointStreamAudioFormatDescriptionCreate(a1, v8, SDWORD2(v8[2]), a3);
  else
    return FigSignalErrorAt(4294950012, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetFigEndpointStreamAudioFormatDescriptionArray(void *a1, const char *a2, const __CFArray *a3)
{
  xpc_object_t empty;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const void *ValueAtIndex;
  uint64_t v11;
  uint64_t v12;
  xpc_object_t value;

  value = 0;
  if (!a1 || !a2)
  {
    v12 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
LABEL_13:
    empty = 0;
    goto LABEL_10;
  }
  if (!a3)
  {
    v12 = 0;
    goto LABEL_13;
  }
  empty = xpc_array_create_empty();
  if (!empty)
  {
    v11 = FigSignalErrorAt(4294950014, 0, 0, 0, 0, 0, 0);
LABEL_15:
    v12 = v11;
    goto LABEL_10;
  }
  Count = CFArrayGetCount(a3);
  if (Count >= 1)
  {
    v8 = Count;
    v9 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a3, v9);
      v11 = _FigEndpointStreamAudioFormatDescriptionCopyXPCObject((uint64_t)ValueAtIndex, &value);
      if ((_DWORD)v11)
        goto LABEL_15;
      xpc_array_append_value(empty, value);
      xpc_release(value);
    }
    while (v8 != ++v9);
  }
  xpc_dictionary_set_value(a1, a2, empty);
  v12 = 0;
LABEL_10:
  FigXPCRelease(empty);
  return v12;
}

uint64_t FigXPCMessageCopyFigEndpointStreamAudioFormatDescriptionArray(const __CFAllocator *a1, xpc_object_t xdict, char *key, __CFArray **a4)
{
  xpc_object_t v6;
  void *v7;
  size_t count;
  CFMutableArrayRef Mutable;
  __CFArray *v10;
  size_t v11;
  xpc_object_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  void *value;

  value = 0;
  if (xdict)
  {
    if (key)
    {
      if (a4)
      {
        v6 = xpc_dictionary_get_value(xdict, key);
        if (!v6)
        {
          v14 = 0;
          *a4 = 0;
          return v14;
        }
        v7 = v6;
        if (MEMORY[0x193FFCDCC]() == MEMORY[0x1E0C812C8])
        {
          count = xpc_array_get_count(v7);
          Mutable = CFArrayCreateMutable(a1, count, MEMORY[0x1E0C9B378]);
          if (Mutable)
          {
            v10 = Mutable;
            if (count)
            {
              v11 = 0;
              while (1)
              {
                v12 = xpc_array_get_value(v7, v11);
                v13 = _FigEndpointStreamAudioFormatDescriptionCreateWithXPCObject((uint64_t)a1, v12, (uint64_t *)&value);
                if ((_DWORD)v13)
                  break;
                CFArrayAppendValue(v10, value);
                CFRelease(value);
                if (count == ++v11)
                  goto LABEL_11;
              }
              v14 = v13;
              CFRelease(v10);
            }
            else
            {
LABEL_11:
              v14 = 0;
              *a4 = v10;
            }
            return v14;
          }
          v16 = 4294950014;
        }
        else
        {
          v16 = 4294950013;
        }
      }
      else
      {
        v16 = 4294950016;
      }
    }
    else
    {
      v16 = 4294950016;
    }
  }
  else
  {
    v16 = 4294950016;
  }
  return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBufferedAirPlayClientRoutingRegistryGetSharedInstance()
{
  if (FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_sCreateOnce != -1)
    dispatch_once(&FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_sCreateOnce, &__block_literal_global_8);
  return FigBufferedAirPlayClientRoutingRegistryGetSharedInstance_sFigBufferedAirPlayClientRoutingRegistry;
}

uint64_t FigBufferedAirPlayClientRoutingRegistryRegisterClient(uint64_t a1, const void *a2, const void *a3)
{
  return FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID(a1, a2, a3, 0);
}

uint64_t FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t v4;
  const __CFDictionary *Value;
  const __CFDictionary *v10;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v12;
  uint64_t v13;
  unsigned int v14;
  CFDictionaryRef Count;
  _BYTE *v16;
  __CFDictionary *Mutable;
  __CFDictionary *v18;
  __CFDictionary *v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  _BYTE *v24;
  NSObject *v25;
  CFNotificationCenterRef DefaultLocalCenter;
  NSObject *v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  CFDictionaryRef v31;
  _BYTE *v32;
  os_log_type_t type;
  int v35;
  int v36;
  const char *v37;
  __int16 v38;
  const void *v39;
  __int16 v40;
  const void *v41;
  __int16 v42;
  CFDictionaryRef v43;
  __int16 v44;
  CFDictionaryRef v45;
  _BYTE v46[128];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v4 = 4294949576;
  if (a1 && a2 && a3)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a3);
    v10 = Value;
    if (Value)
      CFRetain(Value);
    if (dword_1EE141EA8)
    {
      v35 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, &v35, &type);
      v12 = v35;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v14 = v12;
      else
        v14 = v12 & 0xFFFFFFFE;
      if (v14)
      {
        Count = FigCFDictionaryGetCount(v10);
        v36 = 136316162;
        v37 = "FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID";
        v38 = 2048;
        v39 = a2;
        v40 = 2048;
        v41 = a4;
        v42 = 2112;
        v43 = (CFDictionaryRef)a3;
        v44 = 2048;
        v45 = Count;
        v16 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v12) = v35;
      }
      else
      {
        v16 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v16, v16 != v46, v12, 0, v13);
    }
    if (v10)
    {
      if (CFDictionaryContainsKey(v10, a2))
      {
        v4 = 0;
        goto LABEL_42;
      }
      CFDictionaryAddValue(v10, a2, a4);
    }
    else
    {
      Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
      if (!Mutable)
      {
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
        return 4294949575;
      }
      v10 = Mutable;
      CFDictionarySetValue(Mutable, a2, a4);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a3, v10);
    }
    v18 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v18)
    {
      v19 = v18;
      CFDictionarySetValue(v18, CFSTR("RoutingContextUUID"), a3);
      if (dword_1EE141EA8)
      {
        v35 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, &v35, &type);
        v21 = v35;
        if (os_log_type_enabled(v20, type))
          v23 = v21;
        else
          v23 = v21 & 0xFFFFFFFE;
        if (v23)
        {
          v36 = 136315650;
          v37 = "FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID";
          v38 = 2112;
          v39 = a3;
          v40 = 2048;
          v41 = a4;
          v24 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v21) = v35;
        }
        else
        {
          v24 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v24, v24 != v46, v21, 0, v22);
      }
      v25 = *(NSObject **)(a1 + 16);
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      v4 = FigDispatchAsyncPostNotification(v25, DefaultLocalCenter, CFSTR("RunningClientsChanged"), (const void *)a1, v19, 0);
      if (!(_DWORD)v4 && dword_1EE141EA8)
      {
        v35 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v27 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, &v35, &type);
        v28 = v35;
        if (os_log_type_enabled(v27, type))
          v30 = v28;
        else
          v30 = v28 & 0xFFFFFFFE;
        if (v30)
        {
          v31 = FigCFDictionaryGetCount(v10);
          v36 = 136315906;
          v37 = "FigBufferedAirPlayClientRoutingRegistryRegisterClientWithRemoteID";
          v38 = 2112;
          v39 = a3;
          v40 = 2048;
          v41 = a4;
          v42 = 2048;
          v43 = v31;
          v32 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v28) = v35;
        }
        else
        {
          v32 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v32, v32 != v46, v28, 0, v29);
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
      CFRelease(v19);
      goto LABEL_38;
    }
    v4 = 4294949575;
LABEL_42:
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
LABEL_38:
    CFRelease(v10);
  }
  return v4;
}

uint64_t FigBufferedAirPlayClientRoutingRegistryUnregisterClientWithRemoteID(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v4;
  const __CFDictionary *Value;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v9;
  uint64_t v10;
  unsigned int v11;
  CFIndex Count;
  _BYTE *v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  CFIndex v18;
  _BYTE *v19;
  __CFDictionary *Mutable;
  __CFDictionary *v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  _BYTE *v26;
  NSObject *v27;
  CFNotificationCenterRef DefaultLocalCenter;
  os_log_type_t type;
  int v31;
  int v32;
  const char *v33;
  __int16 v34;
  const void *v35;
  __int16 v36;
  CFIndex v37;
  __int16 v38;
  CFIndex v39;
  _BYTE v40[128];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 0;
  v4 = 4294949576;
  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 24), a3))
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a3);
      if (dword_1EE141EA8)
      {
        v31 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, &v31, &type);
        v9 = v31;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v11 = v9;
        else
          v11 = v9 & 0xFFFFFFFE;
        if (v11)
        {
          Count = CFDictionaryGetCount(Value);
          v32 = 136315906;
          v33 = "FigBufferedAirPlayClientRoutingRegistryUnregisterClientWithRemoteID";
          v34 = 2048;
          v35 = a2;
          v36 = 2112;
          v37 = (CFIndex)a3;
          v38 = 2048;
          v39 = Count;
          v13 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v9) = v31;
        }
        else
        {
          v13 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v13, v13 != v40, v9, 0, v10);
      }
      CFDictionaryRemoveValue(Value, a2);
      if (dword_1EE141EA8)
      {
        v31 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, &v31, &type);
        v15 = v31;
        if (os_log_type_enabled(v14, type))
          v17 = v15;
        else
          v17 = v15 & 0xFFFFFFFE;
        if (v17)
        {
          v18 = CFDictionaryGetCount(Value);
          v32 = 136315650;
          v33 = "FigBufferedAirPlayClientRoutingRegistryUnregisterClientWithRemoteID";
          v34 = 2112;
          v35 = a3;
          v36 = 2048;
          v37 = v18;
          v19 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v15) = v31;
        }
        else
        {
          v19 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v19, v19 != v40, v15, 0, v16);
      }
      if (!CFDictionaryGetCount(Value))
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), a3);
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v21 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("RoutingContextUUID"), a3);
        if (dword_1EE141EA8)
        {
          v31 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          v22 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, &v31, &type);
          v23 = v31;
          if (os_log_type_enabled(v22, type))
            v25 = v23;
          else
            v25 = v23 & 0xFFFFFFFE;
          if (v25)
          {
            v32 = 136315394;
            v33 = "FigBufferedAirPlayClientRoutingRegistryUnregisterClientWithRemoteID";
            v34 = 2112;
            v35 = a3;
            v26 = (_BYTE *)_os_log_send_and_compose_impl();
            LOBYTE(v23) = v31;
          }
          else
          {
            v26 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v26, v26 != v40, v23, 0, v24);
        }
        v27 = *(NSObject **)(a1 + 16);
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        v4 = FigDispatchAsyncPostNotification(v27, DefaultLocalCenter, CFSTR("RunningClientsChanged"), (const void *)a1, v21, 0);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
        CFRelease(v21);
        return v4;
      }
      v4 = 4294949575;
    }
    else
    {
      v4 = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  }
  return v4;
}

uint64_t FigBufferedAirPlayClientRoutingRegistryGetCountOfRunningClientsForRoutingContext(uint64_t a1, const void *a2, CFIndex *a3)
{
  CFIndex Count;
  uint64_t v6;
  CFTypeRef v7;
  void *v8;
  CFTypeRef v9;
  uint64_t v10;
  unsigned int (*v11)(CFTypeRef, uint64_t, _QWORD, CFTypeRef *);
  uint64_t v12;
  void *v13;
  CFTypeRef v14;
  uint64_t v15;
  unsigned int (*v16)(CFTypeRef, uint64_t, uint64_t, CFTypeRef *);
  NSObject *v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  _BYTE *v21;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v23;
  uint64_t v24;
  unsigned int v25;
  _BYTE *v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  _BYTE *v31;
  const __CFDictionary *Value;
  NSObject *v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  _BYTE *v37;
  CFTypeRef v39;
  CFTypeRef v40;
  CFTypeRef cf;
  CFTypeRef v42;
  os_log_type_t type;
  int v44;
  int v45;
  const char *v46;
  __int16 v47;
  CFTypeRef v48;
  __int16 v49;
  CFIndex v50;
  _BYTE v51[128];
  uint64_t v52;

  Count = 0;
  v52 = *MEMORY[0x1E0C80C00];
  cf = 0;
  v42 = 0;
  v39 = 0;
  v40 = 0;
  v6 = 4294949576;
  if (!a1)
    goto LABEL_52;
  v7 = a2;
  if (!a2)
    goto LABEL_52;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  if (FigServer_IsAirplayd() && (v8 = sFigRoutingContextRemoteCopySystemAudioContext) != 0
    || (v8 = (void *)sFigRoutingContextCopySystemAudioContext) != 0)
  {
    if (((unsigned int (*)(_QWORD, _QWORD, CFTypeRef *))v8)(0, 0, &v42))
      goto LABEL_24;
  }
  else
  {
    v44 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 0, &v44, &type);
    v23 = v44;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v25 = v23;
    else
      v25 = v23 & 0xFFFFFFFE;
    if (v25)
    {
      v45 = 136315138;
      v46 = "routingRegistry_figRoutingContextCopySystemAudioContext";
      v26 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v23) = v44;
    }
    else
    {
      v26 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 0, 1, v26, v26 != v51, v23, 0, v24);
  }
  v9 = v42;
  if (!v42)
    goto LABEL_24;
  v10 = *(_QWORD *)skFigRoutingContextProperty_ContextUUID;
  v11 = *(unsigned int (**)(CFTypeRef, uint64_t, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v42)
                                                                                           + 8)
                                                                               + 48);
  if (!v11)
    goto LABEL_24;
  v12 = *MEMORY[0x1E0C9AE00];
  if (v11(v9, v10, *MEMORY[0x1E0C9AE00], &v40))
    goto LABEL_24;
  if (FigCFEqual(v7, v40))
  {
    if (FigServer_IsAirplayd() && (v13 = sFigRoutingContextRemoteCopySystemMusicContext) != 0
      || (v13 = (void *)sFigRoutingContextCopySystemMusicContext) != 0)
    {
      if (((unsigned int (*)(_QWORD, _QWORD, CFTypeRef *))v13)(0, 0, &cf))
        goto LABEL_24;
    }
    else
    {
      v44 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v27 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 0, &v44, &type);
      v28 = v44;
      if (os_log_type_enabled(v27, type))
        v30 = v28;
      else
        v30 = v28 & 0xFFFFFFFE;
      if (v30)
      {
        v45 = 136315138;
        v46 = "routingRegistry_figRoutingContextCopySystemMusicContext";
        v31 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v28) = v44;
      }
      else
      {
        v31 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 0, 1, v31, v31 != v51, v28, 0, v29);
    }
    v14 = cf;
    if (cf)
    {
      v15 = *(_QWORD *)skFigRoutingContextProperty_ContextUUID;
      v16 = *(unsigned int (**)(CFTypeRef, uint64_t, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf)
                                                                                                + 8)
                                                                                    + 48);
      if (v16)
      {
        if (!v16(v14, v15, v12, &v39))
        {
          if (dword_1EE141EA8)
          {
            v44 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            v17 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, &v44, &type);
            v18 = v44;
            if (os_log_type_enabled(v17, type))
              v20 = v18;
            else
              v20 = v18 & 0xFFFFFFFE;
            if (v20)
            {
              v45 = 136315650;
              v46 = "FigBufferedAirPlayClientRoutingRegistryGetCountOfRunningClientsForRoutingContext";
              v47 = 2112;
              v48 = v39;
              v49 = 2112;
              v50 = (CFIndex)v7;
              v21 = (_BYTE *)_os_log_send_and_compose_impl();
              LOBYTE(v18) = v44;
            }
            else
            {
              v21 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v21, v21 != v51, v18, 0, v19);
          }
          v7 = v39;
          goto LABEL_40;
        }
      }
    }
LABEL_24:
    Count = 0;
    v6 = 4294949574;
    goto LABEL_52;
  }
LABEL_40:
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), v7);
  if (Value)
    Count = CFDictionaryGetCount(Value);
  else
    Count = 0;
  if (dword_1EE141EA8)
  {
    v44 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v33 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, &v44, &type);
    v34 = v44;
    if (os_log_type_enabled(v33, type))
      v36 = v34;
    else
      v36 = v34 & 0xFFFFFFFE;
    if (v36)
    {
      v45 = 136315650;
      v46 = "FigBufferedAirPlayClientRoutingRegistryGetCountOfRunningClientsForRoutingContext";
      v47 = 2112;
      v48 = v7;
      v49 = 2048;
      v50 = Count;
      v37 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v34) = v44;
    }
    else
    {
      v37 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v37, v37 != v51, v34, 0, v35);
  }
  v6 = 0;
LABEL_52:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  if (a3)
    *a3 = Count;
  if (cf)
    CFRelease(cf);
  if (v42)
    CFRelease(v42);
  if (v39)
    CFRelease(v39);
  if (v40)
    CFRelease(v40);
  return v6;
}

uint64_t FigBufferedAirPlayClientRoutingRegistryClearAllClientsWithRemoteID(uint64_t a1, uint64_t a2)
{
  const __CFDictionary *v4;
  uint64_t v5;
  _QWORD context[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  v4 = *(const __CFDictionary **)(a1 + 24);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __FigBufferedAirPlayClientRoutingRegistryClearAllClientsWithRemoteID_block_invoke;
  context[3] = &unk_1E28D9920;
  context[4] = &v8;
  context[5] = a2;
  context[6] = a1;
  FigCFDictionaryApplyBlock(v4, context);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  v5 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  return v5;
}

void FigBufferedAirPlayClientRoutingRegistry_Finalize(_QWORD *a1)
{
  NSObject *v2;
  const void *v3;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  FigSimpleMutexDestroy(a1[4]);
  v2 = a1[2];
  if (v2)
  {
    dispatch_release(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  if (dword_1EE141EA8)
  {
    v10[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EA0, 1, v10, &type);
    v5 = v10[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v7 = v5;
    else
      v7 = v5 & 0xFFFFFFFE;
    if (v7)
    {
      v10[1] = 136315138;
      v11 = "FigBufferedAirPlayClientRoutingRegistry_Finalize";
      v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v10[0];
    }
    else
    {
      v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EA0, 1u, 1, v8, v8 != &v12, v5, 0, v6);
  }
}

OSStatus CMAudioDeviceClockCreate(CFAllocatorRef allocator, CFStringRef deviceUID, CMClockRef *clockOut)
{
  CFStringRef v4;

  v4 = deviceUID;
  if (FigCFEqual(deviceUID, CFSTR("AQDefaultDevice")))
    v4 = CFSTR("VirtualAudioDevice_Default");
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFADCTrace[1], CFSTR("fadc_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFADCTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1EE141EC8, CFSTR("fadc_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1EE141EC0);
  if (fadcShouldCreateRemoteClock())
    return FigAudioDeviceClock_RemoteCreateCommon((uint64_t)allocator, v4, 0, clockOut);
  else
    return figAudioDeviceClockCreateCommon((uint64_t)allocator, (uint64_t)v4, 0, (CFTypeRef *)clockOut);
}

BOOL fadcShouldCreateRemoteClock()
{
  return !FigServer_IsMediaserverd() && !FigServer_IsMediaplaybackd() && !FigServer_IsCameracaptured();
}

OSStatus CMAudioDeviceClockCreateFromAudioDeviceID(CFAllocatorRef allocator, AudioDeviceID deviceID, CMClockRef *clockOut)
{
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFADCTrace[1], CFSTR("fadc_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFADCTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1EE141EC8, CFSTR("fadc_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1EE141EC0);
  if (!deviceID)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  if (fadcShouldCreateRemoteClock())
    return FigAudioDeviceClock_RemoteCreateCommon((uint64_t)allocator, 0, deviceID, clockOut);
  return figAudioDeviceClockCreateCommon((uint64_t)allocator, 0, deviceID, (CFTypeRef *)clockOut);
}

OSStatus CMAudioDeviceClockSetAudioDeviceUID(CMClockRef clock, CFStringRef deviceUID)
{
  CFStringRef v2;
  OSStatus v4;
  OSStatus v5;
  uint64_t v6;
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  v2 = deviceUID;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  if (FigCFEqual(deviceUID, CFSTR("AQDefaultDevice")))
    v2 = CFSTR("VirtualAudioDevice_Default");
  if (!clock)
  {
    v6 = 4294954551;
LABEL_9:
    v4 = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  if (!FigDerivedClockVerifyCallbacksMatch((_BOOL8)clock, (uint64_t)&gFigAudioDeviceClockCallbacks))
  {
    v6 = 4294954550;
    goto LABEL_9;
  }
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __CMAudioDeviceClockSetAudioDeviceUID_block_invoke;
  v8[3] = &unk_1E28D9A60;
  v8[4] = &v9;
  v8[5] = clock;
  v8[6] = v2;
  v4 = writeProtectedStorageSync((uint64_t)clock, (uint64_t)v8);
  v5 = *((_DWORD *)v10 + 6);
  if (!v5)
  {
    *((_DWORD *)v10 + 6) = v4;
LABEL_10:
    v5 = v4;
  }
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t writeProtectedStorageSync(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  NSObject *v4;
  _QWORD v6[6];

  if (!a1)
    return FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  FigAtomicIncrement32((unsigned int *)(DerivedStorage + 120));
  v4 = *(NSObject **)(DerivedStorage + 128);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __writeProtectedStorageSync_block_invoke;
  v6[3] = &unk_1E28D9C48;
  v6[4] = a2;
  v6[5] = DerivedStorage;
  dispatch_sync(v4, v6);
  FigAtomicDecrement32((unsigned int *)(DerivedStorage + 120));
  return 0;
}

OSStatus CMAudioDeviceClockSetAudioDeviceID(CMClockRef clock, AudioDeviceID deviceID)
{
  OSStatus v4;
  OSStatus v5;
  uint64_t v6;
  _QWORD v8[6];
  AudioDeviceID v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  if (!clock)
  {
    v6 = 4294954551;
LABEL_8:
    v4 = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  if (!FigDerivedClockVerifyCallbacksMatch((_BOOL8)clock, (uint64_t)&gFigAudioDeviceClockCallbacks))
  {
    v6 = 4294954550;
    goto LABEL_8;
  }
  if (!deviceID)
  {
    v5 = FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v11 + 6) = v5;
    goto LABEL_10;
  }
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __CMAudioDeviceClockSetAudioDeviceID_block_invoke;
  v8[3] = &unk_1E28D9A88;
  v8[4] = &v10;
  v8[5] = clock;
  v9 = deviceID;
  v4 = writeProtectedStorageSync((uint64_t)clock, (uint64_t)v8);
  v5 = *((_DWORD *)v11 + 6);
  if (!v5)
  {
    *((_DWORD *)v11 + 6) = v4;
LABEL_9:
    v5 = v4;
  }
LABEL_10:
  _Block_object_dispose(&v10, 8);
  return v5;
}

uint64_t fadcSetAudioDeviceID(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  const void *v6;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  if (!a2)
    return FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  v5 = DerivedStorage;
  v6 = *(const void **)(DerivedStorage + 80);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(v5 + 80) = 0;
  }
  if ((in_audio_mx_server_process() & 1) != 0)
    return switchToNewDeviceID(a1, a2);
  *(_BYTE *)v5 = 0;
  *(_BYTE *)(v5 + 72) = 1;
  return 0;
}

OSStatus CMAudioDeviceClockGetAudioDevice(CMClockRef clock, CFStringRef *deviceUIDOut, AudioDeviceID *deviceIDOut, Boolean *trackingDefaultDeviceOut)
{
  uint64_t DerivedStorage;
  void (*v9)(_QWORD);
  uint64_t v11;
  void (*v12[8])(_QWORD);

  DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)clock);
  if (clock)
  {
    v9 = (void (*)(_QWORD))DerivedStorage;
    if (FigDerivedClockVerifyCallbacksMatch((_BOOL8)clock, (uint64_t)gFigAudioDeviceClockCallbacks))
    {
      v12[0] = (void (*)(_QWORD))MEMORY[0x1E0C809B0];
      v12[1] = (void (*)(_QWORD))0x40000000;
      v12[2] = (void (*)(_QWORD))__CMAudioDeviceClockGetAudioDevice_block_invoke;
      v12[3] = (void (*)(_QWORD))&__block_descriptor_tmp_7_0;
      v12[4] = (void (*)(_QWORD))deviceUIDOut;
      v12[5] = v9;
      v12[6] = (void (*)(_QWORD))deviceIDOut;
      v12[7] = (void (*)(_QWORD))trackingDefaultDeviceOut;
      return readProtectedStorageSync((uint64_t)clock, v12);
    }
    v11 = 4294954550;
  }
  else
  {
    v11 = 4294954551;
  }
  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t readProtectedStorageSync(uint64_t a1, void (**a2)(_QWORD))
{
  uint64_t DerivedStorage;
  uint64_t v4;

  if (!a1)
    return FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v4 = DerivedStorage;
  if (*(_DWORD *)(DerivedStorage + 120))
  {
    dispatch_sync(*(dispatch_queue_t *)(DerivedStorage + 128), a2);
  }
  else
  {
    FigReadWriteLockLockForRead(*(_QWORD *)(DerivedStorage + 136));
    a2[2](a2);
    FigReadWriteLockUnlockForRead(*(_QWORD *)(v4 + 136));
  }
  return 0;
}

uint64_t FigAudioDeviceClockSetIgnoresBluetoothPresentationTimeSupport(uint64_t a1, char a2)
{
  uint64_t DerivedStorage;
  uint64_t v6;

  if (a1)
  {
    DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
    if (FigDerivedClockVerifyCallbacksMatch(a1, (uint64_t)&gFigAudioDeviceClockCallbacks))
    {
      *(_BYTE *)(DerivedStorage + 1) = a2;
      return 0;
    }
    v6 = 4294954550;
  }
  else
  {
    v6 = 4294954551;
  }
  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

uint64_t FigPreferAudioSessionClock()
{
  uint64_t v0;
  _QWORD block[4];
  char v3;

  v0 = FigPreferAudioSessionOverCMSession();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigPreferAudioSessionClock_block_invoke;
  block[3] = &__block_descriptor_tmp_8_0;
  v3 = v0;
  if (FigPreferAudioSessionClock_onceToken != -1)
    dispatch_once(&FigPreferAudioSessionClock_onceToken, block);
  return v0;
}

uint64_t __figAudioDeviceClockCreateCommon_block_invoke(uint64_t a1)
{
  uint64_t result;

  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 0, &gFigAudioDeviceClockRegistry);
  result = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if ((_DWORD)result)
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t __figAudioDeviceClockCreateCommon_block_invoke_2(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_QWORD *)(a1 + 40);
  if (v2)
    result = fadcSetAudioDeviceID(v3, v2);
  else
    result = fadcSetAudioDeviceUID(v3, *(const void **)(a1 + 48));
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

CFStringRef fadcCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v3;
  const char *v4;

  DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  v4 = "true";
  if (!*(_BYTE *)(DerivedStorage + 72))
    v4 = "false";
  return CFStringCreateWithFormat(v3, 0, CFSTR("AudioDeviceClock(deviceUID='%@', deviceID=%d, trackDefaultDevice=%s)"), *(_QWORD *)(DerivedStorage + 80), *(unsigned int *)(DerivedStorage + 88), v4);
}

uint64_t fadcMightDrift(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  _QWORD v11[7];
  _QWORD v12[7];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 1;
  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v4 = FigDerivedClockGetDerivedStorage(a2);
  v5 = *(NSObject **)(DerivedStorage + 128);
  v6 = *(NSObject **)(v4 + 128);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 0x40000000;
  v12[2] = __fadcMightDrift_block_invoke;
  v12[3] = &unk_1E28D9BA8;
  v12[5] = DerivedStorage;
  v12[6] = v4;
  v12[4] = &v13;
  if (v6 >= v5)
    v7 = v6;
  else
    v7 = v5;
  if (v6 >= v5)
    v8 = v5;
  else
    v8 = v6;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __fadcMightDrift_block_invoke_2;
  v11[3] = &unk_1E28D9BD0;
  v11[5] = v8;
  v11[6] = v7;
  v11[4] = v12;
  dispatch_sync(v8, v11);
  v9 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v9;
}

uint64_t fadcGetAnchorTime(void (*a1)(_QWORD), void (*a2)(_QWORD), void (*a3)(_QWORD))
{
  return fadcGetAnchorTimeInternal(a1, a2, a3, 0);
}

dispatch_queue_t fadcInitDeferredRemoveQueue(dispatch_queue_t *a1)
{
  dispatch_queue_t result;

  result = dispatch_queue_create("com.apple.coremedia.fadcdeferredremovepropertylistener", 0);
  *a1 = result;
  return result;
}

uint64_t __fadcDeferRemovePropertyListeners_block_invoke(uint64_t a1)
{
  uint64_t result;
  AudioObjectPropertyAddress v3;

  *(_QWORD *)&v3.mSelector = 0x2A2A2A2A676F696ELL;
  v3.mElement = 0;
  AudioObjectRemovePropertyListener(*(_DWORD *)(a1 + 40), &v3, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(a1 + 32));
  *(_QWORD *)&v3.mSelector = 0x2A2A2A2A6F766572;
  v3.mElement = 0;
  AudioObjectRemovePropertyListener(*(_DWORD *)(a1 + 40), &v3, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(a1 + 32));
  *(_QWORD *)&v3.mSelector = 0x2A2A2A2A6E737274;
  v3.mElement = 0;
  result = AudioObjectRemovePropertyListener(*(_DWORD *)(a1 + 40), &v3, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(a1 + 32));
  if (*(_BYTE *)(a1 + 44))
  {
    *(_QWORD *)&v3.mSelector = 0x2A2A2A2A644F7574;
    v3.mElement = 0;
    return AudioObjectRemovePropertyListener(1u, &v3, (AudioObjectPropertyListenerProc)coreAudioObjectPropertyListener, *(void **)(a1 + 32));
  }
  return result;
}

uint64_t __coreAudioObjectPropertyListener_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t DerivedStorage;
  uint64_t result;
  char v4;
  AudioObjectPropertyAddress v5;

  v1 = *(_QWORD *)(a1 + 32);
  DerivedStorage = FigDerivedClockGetDerivedStorage(v1);
  result = FigAtomicBitAnd32Orig(0, (unsigned int *)(DerivedStorage + 56));
  v4 = result;
  *(_QWORD *)&v5.mSelector = 0x676C6F6200000000;
  v5.mElement = 0;
  if ((result & 2) != 0)
  {
    v5.mSelector = 1870030194;
    result = propertyListenerDispatch(v1, &v5);
    if ((v4 & 4) == 0)
    {
LABEL_3:
      if ((v4 & 8) == 0)
        return result;
      goto LABEL_4;
    }
  }
  else if ((result & 4) == 0)
  {
    goto LABEL_3;
  }
  v5.mSelector = 1735354734;
  result = propertyListenerDispatch(v1, &v5);
  if ((v4 & 8) == 0)
    return result;
LABEL_4:
  v5.mSelector = 1853059700;
  return propertyListenerDispatch(v1, &v5);
}

void __writeProtectedStorageAsync_block_invoke(_QWORD *a1)
{
  const void *v2;

  FigReadWriteLockLockForWrite(*(_QWORD *)(a1[5] + 136));
  (*(void (**)(void))(a1[4] + 16))();
  FigReadWriteLockUnlockForWrite(*(_QWORD *)(a1[5] + 136));
  FigAtomicDecrement32((unsigned int *)(a1[5] + 120));
  v2 = (const void *)a1[6];
  if (v2)
    CFRelease(v2);
}

_QWORD *__fadcMightDrift_block_invoke(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  v1 = result[5];
  v2 = result[6];
  if (*(_DWORD *)(v1 + 88) == *(_DWORD *)(v2 + 88))
  {
    v3 = *(unsigned __int8 *)(v1 + 72);
    v4 = *(_QWORD *)(result[4] + 8);
    if (v3 == *(unsigned __int8 *)(v2 + 72))
    {
      *(_BYTE *)(v4 + 24) = 0;
      return result;
    }
  }
  else
  {
    v4 = *(_QWORD *)(result[4] + 8);
  }
  *(_BYTE *)(v4 + 24) = 1;
  return result;
}

void __fadcMightDrift_block_invoke_2(_QWORD *a1)
{
  NSObject *v2;
  void (**v3)(_QWORD);

  v2 = a1[6];
  v3 = (void (**)(_QWORD))a1[4];
  if (a1[5] == v2)
    v3[2](a1[4]);
  else
    dispatch_sync(v2, v3);
}

uint64_t __fadcGetRate_block_invoke(uint64_t result)
{
  uint64_t v1;

  if (**(_BYTE **)(result + 40))
  {
    v1 = result;
    result = fadc_getDeviceRateAndSampleTimeAndHostTime(*(_QWORD *)(result + 48), (Float64 *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24), 0, 0);
    if ((_DWORD)result)
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = 0x3FF0000000000000;
  }
  return result;
}

uint64_t fadc_getDeviceRateAndSampleTimeAndHostTime(uint64_t a1, Float64 *a2, Float64 *a3, Float64 *a4)
{
  uint64_t DerivedStorage;
  uint64_t v9;
  uint64_t result;
  Float64 v11;
  Float64 mSampleTime;
  Float64 mRateScalar;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  AudioTimeStamp v19;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  if (!*(_BYTE *)(DerivedStorage + 1))
  {
    v14 = DerivedStorage;
    v15 = FigDerivedClockGetDerivedStorage(a1);
    v16 = FigAudioDeviceSupportsPresentationTime(*(_DWORD *)(v15 + 88));
    v17 = v16;
    if (v16 != *(unsigned __int8 *)(v14 + 112))
    {
      *(_BYTE *)(v14 + 112) = v16;
      FigDerivedClockDiscontinuityOccurred(a1);
    }
    if (v17)
    {
      v18 = FigDerivedClockGetDerivedStorage(a1);
      memset(&v19, 0, 40);
      result = FigAudioDeviceGetCurrentPresentationTime(*(_DWORD *)(v18 + 88), (uint64_t)&v19);
      if ((_DWORD)result)
        return result;
      v11 = *(double *)&v19.mSMPTETime.mSubframes;
      mRateScalar = v19.mRateScalar;
      mSampleTime = v19.mSampleTime;
      if (!a2)
        goto LABEL_12;
      goto LABEL_11;
    }
  }
  v9 = FigDerivedClockGetDerivedStorage(a1);
  memset(&v19, 0, sizeof(v19));
  v19.mFlags = 7;
  result = AudioDeviceGetCurrentTime(*(_DWORD *)(v9 + 88), &v19);
  if ((_DWORD)result)
    return result;
  if ((~v19.mFlags & 7) == 0)
  {
    v11 = v19.mRateScalar;
    mSampleTime = *(double *)&v19.mHostTime;
    mRateScalar = v19.mSampleTime;
    if (!a2)
      goto LABEL_12;
    goto LABEL_11;
  }
  result = FigSignalErrorAt(4294949324, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)result)
    return result;
  mSampleTime = 0.0;
  v11 = NAN;
  mRateScalar = NAN;
  if (a2)
LABEL_11:
    *a2 = v11;
LABEL_12:
  if (a3)
    *a3 = mRateScalar;
  result = 0;
  if (a4)
    *a4 = mSampleTime;
  return result;
}

uint64_t fadcGetAnchorTimeInternal(void (*a1)(_QWORD), void (*a2)(_QWORD), void (*a3)(_QWORD), int a4)
{
  void (*DerivedStorage)(_QWORD);
  uint64_t ProtectedStorageSync;
  uint64_t AnchorTimeInternal;
  void (*v12[10])(_QWORD);
  char v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;

  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  DerivedStorage = (void (*)(_QWORD))FigDerivedClockGetDerivedStorage((uint64_t)a1);
  v12[0] = (void (*)(_QWORD))MEMORY[0x1E0C809B0];
  v12[1] = (void (*)(_QWORD))0x40000000;
  v12[2] = (void (*)(_QWORD))__fadcGetAnchorTimeInternal_block_invoke;
  v12[3] = (void (*)(_QWORD))&unk_1E28D9C20;
  v13 = a4;
  v12[4] = (void (*)(_QWORD))&v18;
  v12[5] = (void (*)(_QWORD))&v14;
  v12[6] = DerivedStorage;
  v12[7] = a1;
  v12[8] = a2;
  v12[9] = a3;
  if (a4)
    ProtectedStorageSync = writeProtectedStorageSync((uint64_t)a1, (uint64_t)v12);
  else
    ProtectedStorageSync = readProtectedStorageSync((uint64_t)a1, v12);
  AnchorTimeInternal = *((unsigned int *)v19 + 6);
  if (!(_DWORD)AnchorTimeInternal)
  {
    *((_DWORD *)v19 + 6) = ProtectedStorageSync;
    AnchorTimeInternal = ProtectedStorageSync;
  }
  if (*((_BYTE *)v15 + 24))
  {
    AnchorTimeInternal = fadcGetAnchorTimeInternal(a1, a2, a3, 1);
    *((_DWORD *)v19 + 6) = AnchorTimeInternal;
  }
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  return AnchorTimeInternal;
}

__n128 __fadcGetAnchorTimeInternal_block_invoke(uint64_t a1)
{
  CMTimeFlags flags;
  CMTimeEpoch epoch;
  __n128 result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  double v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CMTime *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  __n128 *v24;
  os_log_type_t type;
  int v26;
  uint64_t hostTime;
  double v28;
  double v29;
  CMTime v30;
  int v31;
  const char *v32;
  __int16 v33;
  double v34;
  __int16 v35;
  double v36;
  __int16 v37;
  double v38;
  __int16 v39;
  double v40;
  __int16 v41;
  double v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  double v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  CMTime v53;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  value = 0;
  flags = 0;
  timescale = 0;
  epoch = 0;
  result.n128_u64[0] = kCMTimeInvalid.value;
  memset(&v30, 0, sizeof(v30));
  v28 = 0.0;
  v29 = 0.0;
  hostTime = 0;
  v5 = *(_QWORD *)(a1 + 48);
  if (!*(_BYTE *)v5)
  {
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v22 = -17970;
    goto LABEL_21;
  }
  if (!*(_QWORD *)(v5 + 104) && !*(_BYTE *)(a1 + 80))
    goto LABEL_16;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = fadc_getDeviceRateAndSampleTimeAndHostTime(*(_QWORD *)(a1 + 56), &v29, &v28, (Float64 *)&hostTime);
  v6 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (!(_DWORD)v6)
  {
    v7 = *(_QWORD *)(a1 + 48);
    v8 = *(_QWORD *)(v7 + 104);
    result.n128_f64[0] = v28;
    if (v8)
    {
      v9 = v28 - *(double *)(v7 + 96) + -(v29 * *(double *)(v7 + 48)) * (double)(hostTime - v8);
      if (v9 < *(double *)(v7 + 32) || v9 > *(double *)(v7 + 40))
      {
        if (!*(_BYTE *)(a1 + 80))
          goto LABEL_16;
        v26 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EC0, 0, &v26, &type);
        v11 = v26;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v13 = v11;
        else
          v13 = v11 & 0xFFFFFFFE;
        if (v13)
        {
          v14 = *(_QWORD *)(a1 + 48);
          v15 = *(double *)(v14 + 96);
          v16 = *(double *)(v14 + 48);
          v17 = *(_QWORD *)(v14 + 104);
          v19 = *(_QWORD *)(v14 + 32);
          v18 = *(_QWORD *)(v14 + 40);
          v31 = 136317698;
          v32 = "fadcGetAnchorTimeInternal_block_invoke";
          v33 = 2048;
          v34 = v28;
          v35 = 2048;
          v36 = v15;
          v37 = 2048;
          v38 = v28 - v15;
          v39 = 2048;
          v40 = v29;
          v41 = 2048;
          v42 = v16;
          v43 = 2048;
          v44 = hostTime;
          v45 = 2048;
          v46 = v17;
          v47 = 2048;
          v48 = v29 * v16 * (double)(hostTime - v17);
          v49 = 2048;
          v50 = v19;
          v51 = 2048;
          v52 = v18;
          v20 = (CMTime *)_os_log_send_and_compose_impl();
          LOBYTE(v11) = v26;
        }
        else
        {
          v20 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EC0, 0, 2, v20, v20 != &v53, v11, 0, v12);
        v21 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v22 = -17971;
LABEL_21:
        *(_DWORD *)(v21 + 24) = v22;
        goto LABEL_22;
      }
    }
    else
    {
      *(double *)(v7 + 96) = v28;
      *(_QWORD *)(v7 + 104) = hostTime;
    }
    CMTimeMake(&v53, (uint64_t)result.n128_f64[0], (int)*(double *)(v7 + 8));
    value = v53.value;
    flags = v53.flags;
    timescale = v53.timescale;
    epoch = v53.epoch;
    CMClockMakeHostTimeFromSystemUnits(&v30, hostTime);
    goto LABEL_22;
  }
  if (!*(_BYTE *)(a1 + 80))
  {
LABEL_16:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
    goto LABEL_22;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
LABEL_22:
  if (*(_BYTE *)(a1 + 80) && (flags & 1) == 0)
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 104) = 0;
  v23 = *(_QWORD *)(a1 + 64);
  if (v23)
  {
    *(_QWORD *)v23 = value;
    *(_DWORD *)(v23 + 8) = timescale;
    *(_DWORD *)(v23 + 12) = flags;
    *(_QWORD *)(v23 + 16) = epoch;
  }
  v24 = *(__n128 **)(a1 + 72);
  if (v24)
  {
    result = *(__n128 *)&v30.value;
    v24[1].n128_u64[0] = v30.epoch;
    *v24 = result;
  }
  return result;
}

uint64_t __writeProtectedStorageSync_block_invoke(uint64_t a1)
{
  FigReadWriteLockLockForWrite(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 136));
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return FigReadWriteLockUnlockForWrite(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 136));
}

CFTypeID CMClockGetTypeID(void)
{
  FigThreadRunOnce(&CMClockGetTypeID_sRegisterFigClockOnce, (void (*)(void))registerFigClock);
  return sFigClockID;
}

void CMClockInvalidate(CMClockRef clock)
{
  uint64_t v2;
  void (*v3)(CMClockRef);
  const void *v4;

  if (clock)
  {
    v2 = *((_QWORD *)clock + 2);
    if (v2)
      FigReentrantMutexLock(*((pthread_mutex_t **)clock + 2));
    if (*((_BYTE *)clock + 41))
    {
      v3 = *(void (**)(CMClockRef))(*((_QWORD *)clock + 3) + 24);
      if (v3)
        v3(clock);
      *((_BYTE *)clock + 41) = 0;
      FigMemoryBarrier();
      v4 = (const void *)*((_QWORD *)clock + 4);
      if (v4)
        CFRelease(v4);
      *((_QWORD *)clock + 3) = 0;
      *((_QWORD *)clock + 4) = 0;
    }
    if (v2)
      FigReentrantMutexUnlock(*((pthread_mutex_t **)clock + 2));
  }
  else
  {
    FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
  }
}

OSStatus CMClockGetAnchorTime(CMClockRef clock, CMTime *clockTimeOut, CMTime *referenceClockTimeOut)
{
  CMTimeEpoch v6;
  int v7;
  OSStatus v8;
  OSStatus v9;
  int v10;
  int v11;
  OpaqueCMClock *v12;
  CMTimeValue value;
  CMTimeScale timescale;
  int v15;
  int v16;
  OpaqueCMClock *v17;
  CMTimeValue v18;
  int32_t v19;
  CMTimeEpoch epoch;
  CMTimeFlags v22;
  CMTimeValue *v23;
  CMTimeFlags v24;
  CMTimeScale v25;
  __int128 v26;
  CMTimeEpoch v27;
  CMTimeFlags flags;
  unsigned int v29;
  CMTimeValue *v30;
  unsigned int v31;
  _OWORD v32[2];
  __int128 v33;
  CMTimeEpoch v34;
  CMTime v35;
  CMTime v36;
  CMTime lhs;
  CMTime v38;
  CMTime rhs;
  CMTime clockTimeOuta;
  CMTime time;
  CMTime time2;
  uint64_t v43;
  CMTimeScale epoch_high;
  CMTimeValue v45;
  CMTimeScale v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v33 = *(_OWORD *)&kCMTimeInvalid.value;
  v6 = 0;
  v34 = 0;
  memset(v32, 0, 24);
  if (!clock)
  {
    v8 = FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)clock + 2));
  if (!*((_BYTE *)clock + 41))
  {
    v9 = -12746;
    goto LABEL_22;
  }
  v7 = *((_DWORD *)clock + 11);
  if (v7 == 1702392677)
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s: kFigClockClass_ExternalSyncEvents not yet implemented\n", "CMClockGetAnchorTime");
    v9 = -12756;
    goto LABEL_22;
  }
  if (v7 != 1735680866)
  {
    v9 = 0;
    goto LABEL_22;
  }
  if (*((_BYTE *)clock + 72))
  {
    v8 = (*(uint64_t (**)(CMClockRef, __int128 *, _OWORD *))(*((_QWORD *)clock + 3) + 48))(clock, &v33, v32);
LABEL_7:
    v9 = v8;
    goto LABEL_22;
  }
  if (*((_BYTE *)clock + 73))
  {
    v45 = 0;
    v46 = 0;
    memset(&v38, 0, sizeof(v38));
    memset(&lhs, 0, sizeof(lhs));
    memset(&v36, 0, sizeof(v36));
    memset(&v35, 0, sizeof(v35));
    FigMemoryBarrier();
    v11 = *((_DWORD *)clock + 50);
    v10 = *((_DWORD *)clock + 51);
    v12 = (OpaqueCMClock *)*((_QWORD *)clock + 4);
    memset(&clockTimeOuta, 0, sizeof(clockTimeOuta));
    CMClockGetAnchorTime(v12, &clockTimeOuta, 0);
    value = clockTimeOuta.value;
    v43 = *(_QWORD *)&clockTimeOuta.flags;
    timescale = clockTimeOuta.timescale;
    epoch_high = HIDWORD(clockTimeOuta.epoch);
    clockTimeOuta = *(CMTime *)((char *)clock + 128);
    rhs = *(CMTime *)((_BYTE *)clock + 2);
    CMTimeAdd(&time2, &clockTimeOuta, &rhs);
    clockTimeOuta.value = value;
    *(_QWORD *)&clockTimeOuta.flags = v43;
    clockTimeOuta.timescale = timescale;
    HIDWORD(clockTimeOuta.epoch) = epoch_high;
    if ((CMTimeCompare(&clockTimeOuta, &time2) & 0x80000000) == 0 || v10 != v11)
    {
      memset(&clockTimeOuta, 0, sizeof(clockTimeOuta));
      if (v10 != v11)
        goto LABEL_30;
      while (1)
      {
        if (!(*(unsigned int (**)(CMClockRef, CMTime *, CMTime *))(*((_QWORD *)clock + 3) + 48))(clock, &v38, &clockTimeOuta)&& (v38.flags & 0x1D) == 1)
        {
          time = v38;
          CMTimeConvertScale(&rhs, &time, timescale, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
          v38 = rhs;
          lhs = clockTimeOuta;
        }
        FigMemoryBarrier();
        if (*((_DWORD *)clock + 51) == *((_DWORD *)clock + 50))
          break;
        memset(&clockTimeOuta, 0, sizeof(clockTimeOuta));
LABEL_30:
        *((_BYTE *)clock + 124) = 0;
        FigMemoryBarrier();
        *((_DWORD *)clock + 51) = *((_DWORD *)clock + 50);
      }
      *((_QWORD *)clock + 16) = value;
      *((_DWORD *)clock + 34) = timescale;
      *(_QWORD *)((char *)clock + 140) = v43;
      *((_DWORD *)clock + 37) = epoch_high;
      if ((v38.flags & 0x1D) == 1)
      {
        *((_BYTE *)clock + 74) = 1;
        if (!*((_BYTE *)clock + 124))
        {
          *(CMTime *)((char *)clock + 100) = lhs;
          rhs = v38;
          time = *(CMTime *)((char *)clock + 152);
          CMTimeSubtract(&clockTimeOuta, &rhs, &time);
          *(CMTime *)((char *)clock + 76) = clockTimeOuta;
          *((_BYTE *)clock + 124) = 1;
        }
        clockTimeOuta = v38;
        rhs = *(CMTime *)((char *)clock + 76);
        CMTimeSubtract(&v36, &clockTimeOuta, &rhs);
        clockTimeOuta = *(CMTime *)((char *)clock + 100);
        rhs = v36;
        CMTimeAdd(&v35, &clockTimeOuta, &rhs);
        rhs = v35;
        time = lhs;
        CMTimeSubtract(&clockTimeOuta, &rhs, &time);
        *(CMTime *)((char *)clock + 152) = clockTimeOuta;
      }
      else
      {
        *((_BYTE *)clock + 74) = 0;
        *((_BYTE *)clock + 124) = 0;
      }
    }
    *(_QWORD *)&clockTimeOuta.flags = v43;
    clockTimeOuta.value = value;
    HIDWORD(clockTimeOuta.epoch) = epoch_high;
    clockTimeOuta.timescale = timescale;
    rhs = *(CMTime *)((char *)clock + 152);
    CMTimeAdd(&time, &clockTimeOuta, &rhs);
    v45 = time.value;
    v46 = time.timescale;
    epoch = time.epoch;
    v22 = time.flags & 0xFFFFFFFD;
    v23 = (CMTimeValue *)((char *)clock + 176);
    clockTimeOuta.value = time.value;
    clockTimeOuta.timescale = time.timescale;
    clockTimeOuta.flags = time.flags & 0xFFFFFFFD;
    clockTimeOuta.epoch = time.epoch;
    rhs = *(CMTime *)((char *)clock + 176);
    if (CMTimeCompare(&clockTimeOuta, &rhs) < 0 && (v24 = *((_DWORD *)clock + 47), (v24 & 0x1D) == 1))
    {
      v45 = *v23;
      v46 = *((_DWORD *)clock + 46);
      epoch = *((_QWORD *)clock + 24);
      v22 = v24;
    }
    else
    {
      *v23 = v45;
      *((_DWORD *)clock + 46) = v46;
      *((_DWORD *)clock + 47) = v22;
      *((_QWORD *)clock + 24) = epoch;
    }
    v9 = 0;
    *(_QWORD *)&v33 = v45;
    *((_QWORD *)&v33 + 1) = __PAIR64__(v22, v46);
    v34 = epoch;
    *(_QWORD *)&v32[0] = value;
    DWORD2(v32[0]) = timescale;
    *(_QWORD *)((char *)v32 + 12) = v43;
    v25 = epoch_high;
    goto LABEL_45;
  }
  time2.value = 0;
  time2.timescale = 0;
  memset(&clockTimeOuta, 0, sizeof(clockTimeOuta));
  memset(&rhs, 0, sizeof(rhs));
  memset(&v38, 0, sizeof(v38));
  FigMemoryBarrier();
  v16 = *((_DWORD *)clock + 50);
  v15 = *((_DWORD *)clock + 51);
  v17 = (OpaqueCMClock *)*((_QWORD *)clock + 4);
  memset(&lhs, 0, sizeof(lhs));
  CMClockGetAnchorTime(v17, &lhs, 0);
  v18 = lhs.value;
  time.value = *(_QWORD *)&lhs.flags;
  v19 = lhs.timescale;
  time.timescale = HIDWORD(lhs.epoch);
  v36 = *(CMTime *)((char *)clock + 128);
  CMTimeSubtract(&v38, &lhs, &v36);
  lhs = v38;
  v36 = *(CMTime *)((_BYTE *)clock + 2);
  if (CMTimeCompare(&lhs, &v36) < 0 && v15 == v16 && *((_BYTE *)clock + 124))
    goto LABEL_46;
  memset(&lhs, 0, sizeof(lhs));
  if (v15 != v16)
    goto LABEL_48;
  while (1)
  {
    if (!(*(unsigned int (**)(CMClockRef, CMTime *, CMTime *))(*((_QWORD *)clock + 3) + 48))(clock, &clockTimeOuta, &lhs)&& (clockTimeOuta.flags & 0x1D) == 1)
    {
      v35 = clockTimeOuta;
      CMTimeConvertScale(&v36, &v35, v19, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      clockTimeOuta = v36;
      rhs = lhs;
    }
    FigMemoryBarrier();
    if (*((_DWORD *)clock + 51) == *((_DWORD *)clock + 50))
      break;
    memset(&lhs, 0, sizeof(lhs));
LABEL_48:
    FigMemoryBarrier();
    *((_DWORD *)clock + 51) = *((_DWORD *)clock + 50);
  }
  *((_QWORD *)clock + 16) = v18;
  *((_DWORD *)clock + 34) = v19;
  *(_QWORD *)((char *)clock + 140) = time.value;
  *((_DWORD *)clock + 37) = time.timescale;
  if ((clockTimeOuta.flags & 0x1D) == 1)
  {
    v26 = *(_OWORD *)&rhs.value;
    *(_OWORD *)((char *)clock + 100) = *(_OWORD *)&rhs.value;
    *(_OWORD *)((char *)clock + 76) = *(_OWORD *)&clockTimeOuta.value;
    *((_BYTE *)clock + 74) = 1;
    *((_BYTE *)clock + 124) = 1;
    v27 = rhs.epoch;
    *(_QWORD *)((char *)clock + 116) = rhs.epoch;
    *(_QWORD *)((char *)clock + 92) = clockTimeOuta.epoch;
    *(_QWORD *)&v36.flags = time.value;
    HIDWORD(v36.epoch) = time.timescale;
    v36.value = v18;
    v36.timescale = v19;
    *(_OWORD *)&v35.value = v26;
    v35.epoch = v27;
    goto LABEL_55;
  }
  *((_BYTE *)clock + 74) = 0;
  if (*((_BYTE *)clock + 124))
  {
LABEL_46:
    v36.value = v18;
    v36.timescale = v19;
    *(_QWORD *)&v36.flags = time.value;
    HIDWORD(v36.epoch) = time.timescale;
    v35 = *(CMTime *)((char *)clock + 100);
LABEL_55:
    CMTimeSubtract(&lhs, &v36, &v35);
    v38 = lhs;
    v36 = lhs;
    v35 = *(CMTime *)((char *)clock + 76);
    CMTimeAdd(&lhs, &v36, &v35);
    time2.value = lhs.value;
    flags = lhs.flags;
    time2.timescale = lhs.timescale;
    v6 = lhs.epoch;
    goto LABEL_56;
  }
  time2.value = 0;
  time2.timescale = 0;
  flags = 0;
LABEL_56:
  v29 = flags & 0xFFFFFFFD;
  v30 = (CMTimeValue *)((char *)clock + 176);
  lhs.value = time2.value;
  lhs.timescale = time2.timescale;
  lhs.flags = flags & 0xFFFFFFFD;
  lhs.epoch = v6;
  v36 = *(CMTime *)((char *)clock + 176);
  if (CMTimeCompare(&lhs, &v36) < 0 && (v31 = *((_DWORD *)clock + 47), (v31 & 0x1D) == 1))
  {
    time2.value = *v30;
    time2.timescale = *((_DWORD *)clock + 46);
    v6 = *((_QWORD *)clock + 24);
    v29 = v31;
  }
  else
  {
    *v30 = time2.value;
    *((_DWORD *)clock + 46) = time2.timescale;
    *((_DWORD *)clock + 47) = v29;
    *((_QWORD *)clock + 24) = v6;
  }
  v9 = 0;
  *(_QWORD *)&v33 = time2.value;
  *((_QWORD *)&v33 + 1) = __PAIR64__(v29, time2.timescale);
  v34 = v6;
  *(_QWORD *)&v32[0] = v18;
  DWORD2(v32[0]) = v19;
  *(_QWORD *)((char *)v32 + 12) = time.value;
  v25 = time.timescale;
LABEL_45:
  DWORD1(v32[1]) = v25;
LABEL_22:
  if (clockTimeOut)
  {
    *(_OWORD *)&clockTimeOut->value = v33;
    clockTimeOut->epoch = v34;
  }
  if (referenceClockTimeOut)
  {
    *(_OWORD *)&referenceClockTimeOut->value = v32[0];
    referenceClockTimeOut->epoch = *(_QWORD *)&v32[1];
  }
  if (clock)
    FigReentrantMutexUnlock(*((pthread_mutex_t **)clock + 2));
  return v9;
}

CMTime *__cdecl CMClockGetTime(CMTime *__return_ptr retstr, CMClockRef clock)
{
  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  return (CMTime *)CMClockGetAnchorTime(clock, retstr, 0);
}

Boolean CMClockMightDrift(CMClockRef clock, CMClockRef otherClock)
{
  uint64_t v2;

  if (clock == otherClock)
    return 0;
  v2 = *((_QWORD *)clock + 3);
  if (v2 == *((_QWORD *)otherClock + 3))
    return (*(uint64_t (**)(void))(v2 + 32))();
  else
    return 1;
}

BOOL FigDerivedClockVerifyCallbacksMatch(_BOOL8 result, uint64_t a2)
{
  if (result)
    return *(_QWORD *)(result + 24) == a2;
  return result;
}

__CFString *fcCopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t (*v4)(uint64_t);
  const void *v5;
  CFIndex v6;
  CFAllocatorRef v7;
  const __CFAllocator *v8;
  CFStringRef v9;
  Float64 Seconds;
  CFIndex v11;
  CFAllocatorRef v12;
  CMTime clockTimeOut;
  CMTime v15;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigClock"));
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(_BYTE *)(a1 + 41))
  {
    v4 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 16);
    if (v4)
      v5 = (const void *)v4(a1);
    else
      v5 = 0;
    memset(&clockTimeOut, 0, sizeof(clockTimeOut));
    CMClockGetAnchorTime((CMClockRef)a1, &clockTimeOut, 0);
    v15 = clockTimeOut;
    v8 = CFGetAllocator((CFTypeRef)a1);
    clockTimeOut = v15;
    v9 = CMTimeCopyDescription(v8, &clockTimeOut);
    clockTimeOut = v15;
    Seconds = CMTimeGetSeconds(&clockTimeOut);
    if (v5)
      CFStringAppendFormat(Mutable, 0, CFSTR("[%@]: "), v5);
    else
      CFStringAppendFormat(Mutable, 0, CFSTR(": "));
    v11 = CFGetRetainCount((CFTypeRef)a1);
    v12 = CFGetAllocator((CFTypeRef)a1);
    CFStringAppendFormat(Mutable, 0, CFSTR("%p retainCount: %d allocator: %p current time: %@ = %f seconds"), a1, v11, v12, v9, *(_QWORD *)&Seconds);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    if (v9)
      CFRelease(v9);
    if (v5)
      CFRelease(v5);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("(INVALID): "));
    v6 = CFGetRetainCount((CFTypeRef)a1);
    v7 = CFGetAllocator((CFTypeRef)a1);
    CFStringAppendFormat(Mutable, 0, CFSTR("%p retainCount: %d allocator: %p"), a1, v6, v7);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  }
  return Mutable;
}

CMClockRef CMClockGetHostTimeClock(void)
{
  FigThreadRunOnce(&CMClockGetHostTimeClock_sCreateHostTimeClockOnce, (void (*)(void))createHostTimeClock);
  return (CMClockRef)sHostTimeClock;
}

uint64_t CMClockConvertHostTimeToSystemUnits(CMTime *hostTime)
{
  uint64_t result;
  CMTime v2;
  CMTime v3;

  memset(&v3, 0, sizeof(v3));
  v2 = *hostTime;
  CMTimeConvertScale(&v3, &v2, 1000000000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
  result = 0;
  if ((v3.flags & 0x1D) == 1)
    return FigNanosecondsToHostTime(v3.value);
  return result;
}

CMTime *__cdecl CMClockMakeHostTimeFromSystemUnits(CMTime *__return_ptr retstr, uint64_t hostTime)
{
  int64_t v3;

  v3 = FigHostTimeToNanoseconds(hostTime);
  return CMTimeMake(retstr, v3, 1000000000);
}

CFStringRef fhtcCopyDebugDesc(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithCString(v1, "HostTimeClock", 0);
}

void fhtcFinalizeAndCrash()
{
  MEMORY[0x539] = 1;
}

double fhtcGetRate()
{
  return 1.0;
}

uint64_t fhtcGetAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  int64_t UpTimeNanoseconds;
  CMTime v7;

  memset(&v7, 0, sizeof(v7));
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  CMTimeMake(&v7, UpTimeNanoseconds, 1000000000);
  if (a2)
    *a2 = v7;
  if (a3)
    *a3 = v7;
  return 0;
}

uint64_t FigStartForwardingMediaServicesProcessDeathNotification(void *a1, unint64_t a2)
{
  unsigned int v4;
  __CFNotificationCenter *DefaultLocalCenter;

  v4 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigMediaServicesProcessDeathMonitoringTrace[1], CFSTR("processdeathmonitoring_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v4, 0, gFigMediaServicesProcessDeathMonitoringTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1ECDA8418, CFSTR("processdeathmonitoring_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1ECDA8410);
  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return FigNotificationCenterAddWeakListener(DefaultLocalCenter, a1, (CFNotificationCallback)figDependencyDeathRepostNotificationCallback, CFSTR("MediaServicesProcessDeath"), a2, 0, 0);
}

uint64_t figDependencyDeathRepostNotificationCallback(__CFNotificationCenter *a1, const void *a2, const __CFString *a3, int a4, CFTypeRef cf)
{
  return CMNotificationCenterPostNotification(a1, a3, a2, cf);
}

uint64_t FigStopForwardingMediaServicesProcessDeathNotification(const void *a1, const void *a2)
{
  __CFNotificationCenter *DefaultLocalCenter;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)figDependencyDeathRepostNotificationCallback, CFSTR("MediaServicesProcessDeath"), a2);
}

uint64_t FigStartMonitoringMediaServicesProcessDeath(void *a1)
{
  return FigStartMonitoringMediaServicesProcessDeathWithCallback(a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))figObjectDependencyDeathDefaultCallback);
}

uint64_t FigStartMonitoringMediaServicesProcessDeathWithCallback(void *a1, void (__cdecl *a2)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))
{
  unsigned int v4;
  __CFNotificationCenter *DefaultLocalCenter;

  v4 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigMediaServicesProcessDeathMonitoringTrace[1], CFSTR("processdeathmonitoring_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v4, 0, gFigMediaServicesProcessDeathMonitoringTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1ECDA8418, CFSTR("processdeathmonitoring_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1ECDA8410);
  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return FigNotificationCenterAddWeakListener(DefaultLocalCenter, a1, a2, CFSTR("MediaServicesProcessDeath"), (unint64_t)a1, 0, 0);
}

uint64_t figObjectDependencyDeathDefaultCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  uint64_t result;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v10;
  uint64_t v11;
  unsigned int v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t);
  os_log_type_t type;
  int v17;
  uint64_t v18;
  unsigned int v19;
  _BYTE v20[24];
  void *v21;
  __int16 v22;
  unsigned int v23;
  _QWORD v24[17];

  v24[16] = *MEMORY[0x1E0C80C00];
  v19 = 0;
  v18 = 0;
  result = FigCFDictionaryGetInt64IfPresent(a5, CFSTR("ServerCapabilities"), &v18);
  if (!(_DWORD)result)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if ((v18 & 1) == 0)
  {
    if (!FigCFDictionaryGetInt32IfPresent(a5, CFSTR("PID"), &v19))
      FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    if (dword_1ECDA8418)
    {
      v17 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8410, 1, &v17, &type);
      v10 = v17;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v12 = v10;
      else
        v12 = v10 & 0xFFFFFFFE;
      if (v12)
      {
        *(_DWORD *)v20 = 136315906;
        *(_QWORD *)&v20[4] = "figObjectDependencyDeathDefaultCallback";
        *(_WORD *)&v20[12] = 2048;
        *(_QWORD *)&v20[14] = a2;
        *(_WORD *)&v20[22] = 2048;
        v21 = a4;
        v22 = 1024;
        v23 = v19;
        v13 = (_QWORD *)_os_log_send_and_compose_impl();
        LOBYTE(v10) = v17;
      }
      else
      {
        v13 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8410, 1u, 1, v13, v13 != v24, v10, 0, v11);
    }
    v14 = v19;
    *(_QWORD *)v20 = 0;
    *(_QWORD *)&v20[8] = v20;
    *(_QWORD *)&v20[16] = 0x2020000000;
    v15 = (uint64_t (*)(uint64_t))getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_ptr;
    v21 = getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_ptr;
    if (!getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_ptr)
    {
      v24[0] = MEMORY[0x1E0C809B0];
      v24[1] = 3221225472;
      v24[2] = __getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke;
      v24[3] = &unk_1E28D9708;
      v24[4] = v20;
      __getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke((uint64_t)v24);
      v15 = *(uint64_t (**)(uint64_t))(*(_QWORD *)&v20[8] + 24);
    }
    _Block_object_dispose(v20, 8);
    if (!v15)
      figObjectDependencyDeathDefaultCallback_cold_1();
    return v15(v14);
  }
  return result;
}

void sub_18ECC0888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t FigStopMonitoringMediaServicesProcessDeath(const void *a1)
{
  return FigStopMonitoringMediaServicesProcessDeathWithCallback(a1, (uint64_t)figObjectDependencyDeathDefaultCallback);
}

uint64_t FigStopMonitoringMediaServicesProcessDeathWithCallback(const void *a1, uint64_t a2)
{
  __CFNotificationCenter *DefaultLocalCenter;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, a2, CFSTR("MediaServicesProcessDeath"), a1);
}

void *__getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke(uint64_t a1)
{
  void *result;
  void *v3;
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  if (!MediaToolboxLibraryCore_frameworkLibrary)
  {
    v4 = xmmword_1E28D9D00;
    v5 = 0;
    MediaToolboxLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  if (!MediaToolboxLibraryCore_frameworkLibrary)
    __getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke_cold_1(&v3);
  result = dlsym((void *)MediaToolboxLibraryCore_frameworkLibrary, "FigAudioSessionTriggerAVAudioSessionReset");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_ptr = *(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)
                                                                           + 24);
  return result;
}

uint64_t FigEndpointStreamResume(uint64_t a1, uint64_t a2)
{
  uint64_t (*v4)(uint64_t, uint64_t, _QWORD, _QWORD);

  v4 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 16);
  if (v4)
    return v4(a1, a2, 0, 0);
  else
    return 4294954514;
}

uint64_t FigEndpointStreamSuspend(uint64_t a1, uint64_t a2)
{
  uint64_t (*v4)(uint64_t, uint64_t, _QWORD, _QWORD);

  v4 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 8);
  if (v4)
    return v4(a1, a2, 0, 0);
  else
    return 4294954514;
}

uint64_t FigEndpointStreamResumeSync(uint64_t a1, uint64_t a2, int a3)
{
  dispatch_time_t v5;
  dispatch_object_t *SyncContext;
  dispatch_object_t *v7;
  dispatch_object_t v8;
  const __CFArray *v9;
  NSObject *v10;
  uint64_t (*v11)(uint64_t, uint64_t, void (*)(uint64_t, int, uint64_t), dispatch_object_t *);
  const __CFNumber *ValueAtIndex;
  unsigned int valuePtr;

  valuePtr = 0;
  if (a3)
    v5 = dispatch_time(0, 1000000 * a3);
  else
    v5 = -1;
  SyncContext = (dispatch_object_t *)endpointStreamUtil_createSyncContext();
  if (!SyncContext)
  {
    FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0);
    return valuePtr;
  }
  v7 = SyncContext;
  v8 = SyncContext[1];
  if (v8)
    v9 = (const __CFArray *)CFRetain(v8);
  else
    v9 = 0;
  v10 = *v7;
  dispatch_retain(*v7);
  v11 = *(uint64_t (**)(uint64_t, uint64_t, void (*)(uint64_t, int, uint64_t), dispatch_object_t *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 16);
  if (!v11)
  {
    valuePtr = -12782;
    goto LABEL_15;
  }
  valuePtr = v11(a1, a2, endpointStreamUtil_completionCallback, v7);
  if (valuePtr)
    goto LABEL_15;
  if (!dispatch_semaphore_wait(v10, v5))
  {
    if (CFArrayGetCount(v9) >= 1)
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v9, 0);
      CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
      if (!v9)
        goto LABEL_17;
LABEL_16:
      CFRelease(v9);
      goto LABEL_17;
    }
LABEL_15:
    if (!v9)
      goto LABEL_17;
    goto LABEL_16;
  }
  valuePtr = -16764;
  if (v9)
    goto LABEL_16;
LABEL_17:
  if (v10)
    dispatch_release(v10);
  return valuePtr;
}

_QWORD *endpointStreamUtil_createSyncContext()
{
  _QWORD *v0;
  CFMutableArrayRef Mutable;

  v0 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  if (v0
    && (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]),
        (v0[1] = Mutable) != 0))
  {
    *v0 = dispatch_semaphore_create(0);
  }
  else if (FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0))
  {
    free(v0);
    return 0;
  }
  return v0;
}

void endpointStreamUtil_completionCallback(uint64_t a1, int a2, uint64_t a3)
{
  CFNumberRef v4;
  const void *v5;
  int valuePtr;

  valuePtr = a2;
  v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 8), v4);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)a3);
  if (*(_QWORD *)a3)
    dispatch_release(*(dispatch_object_t *)a3);
  v5 = *(const void **)(a3 + 8);
  if (v5)
    CFRelease(v5);
  free((void *)a3);
  if (v4)
    CFRelease(v4);
}

uint64_t FigEndpointStreamSuspendSync(uint64_t a1, uint64_t a2, int a3)
{
  dispatch_time_t v5;
  dispatch_object_t *SyncContext;
  dispatch_object_t *v7;
  dispatch_object_t v8;
  const __CFArray *v9;
  NSObject *v10;
  uint64_t (*v11)(uint64_t, uint64_t, void (*)(uint64_t, int, uint64_t), dispatch_object_t *);
  const __CFNumber *ValueAtIndex;
  unsigned int valuePtr;

  valuePtr = 0;
  if (a3)
    v5 = dispatch_time(0, 1000000 * a3);
  else
    v5 = -1;
  SyncContext = (dispatch_object_t *)endpointStreamUtil_createSyncContext();
  if (!SyncContext)
  {
    FigSignalErrorAt(4294950535, 0, 0, 0, 0, 0, 0);
    return valuePtr;
  }
  v7 = SyncContext;
  v8 = SyncContext[1];
  if (v8)
    v9 = (const __CFArray *)CFRetain(v8);
  else
    v9 = 0;
  v10 = *v7;
  dispatch_retain(*v7);
  v11 = *(uint64_t (**)(uint64_t, uint64_t, void (*)(uint64_t, int, uint64_t), dispatch_object_t *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 8);
  if (!v11)
  {
    valuePtr = -12782;
    goto LABEL_15;
  }
  valuePtr = v11(a1, a2, endpointStreamUtil_completionCallback, v7);
  if (valuePtr)
    goto LABEL_15;
  if (!dispatch_semaphore_wait(v10, v5))
  {
    if (CFArrayGetCount(v9) >= 1)
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v9, 0);
      CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
      if (!v9)
        goto LABEL_17;
LABEL_16:
      CFRelease(v9);
      goto LABEL_17;
    }
LABEL_15:
    if (!v9)
      goto LABEL_17;
    goto LABEL_16;
  }
  valuePtr = -16764;
  if (v9)
    goto LABEL_16;
LABEL_17:
  if (v10)
    dispatch_release(v10);
  return valuePtr;
}

uint64_t FigControlCommandsStartServer()
{
  unsigned int v0;
  CFMutableDictionaryRef Mutable;
  uint64_t v2;
  const char *v4;
  _OWORD v5[3];

  v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigControlCommandsXPCServerTrace[1], CFSTR("controlcommandsserver_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFigControlCommandsXPCServerTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EE141EE8, CFSTR("controlcommandsserver_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EE141EE0);
  v5[0] = xmmword_1E28D9D18;
  v5[1] = *(_OWORD *)&off_1E28D9D28;
  v5[2] = xmmword_1E28D9D38;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetValue(Mutable, CFSTR("xpcServerOption_OptOutOfPurge"), (const void *)*MEMORY[0x1E0C9AE50]);
  if (FigServer_IsMediaparserd())
  {
    v2 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    if (Mutable)
LABEL_3:
      CFRelease(Mutable);
  }
  else
  {
    if (FigServer_IsMediaplaybackd())
      v4 = "com.apple.coremedia.mediaplaybackd.controlcommands.xpc";
    else
      v4 = "com.apple.coremedia.logging.xpc";
    v2 = FigXPCServerStart((uint64_t)v4, (uint64_t)v5, 0, &gControlCommandsServer);
    FigInstallSysdiagnoseBlock((uint64_t)CFSTR("CoreMediaPreferences"), (uint64_t)&__block_literal_global_9);
    if (Mutable)
      goto LABEL_3;
  }
  return v2;
}

uint64_t HandleControlCommandsServerRemoteMessage(uint64_t a1, void *a2, void *a3)
{
  uint64_t OpCode;
  int64_t int64;
  __CFString *Mutable;
  uint64_t PurgeEligibilityForPID;
  uint64_t v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  int v15;
  _QWORD v16[6];
  char v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;

  v15 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v15);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v15 != 1885827696)
    return 4294951145;
  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  v17 = 0;
  int64 = xpc_dictionary_get_int64(a2, "Pid");
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("|%-80s|%-20s|%-64s|%-32s|\n"), "Server", "Purged", "Purge Identifier", "Could Not Purge All Objects");
  if (xpc_dictionary_get_BOOL(a2, "ForcePurge"))
    goto LABEL_6;
  PurgeEligibilityForPID = FigPurgeAndRenewProcessStateTrackerGetPurgeEligibilityForPID(int64, &v17);
  if ((_DWORD)PurgeEligibilityForPID)
  {
    v9 = PurgeEligibilityForPID;
    goto LABEL_7;
  }
  if (v17)
  {
    v9 = 0;
    *((_BYTE *)v19 + 24) = 1;
  }
  else
  {
LABEL_6:
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 0x40000000;
    v16[2] = __HandleLoggingPurgeObjectsAndGenerateReportForPID_block_invoke;
    v16[3] = &unk_1E28D9D90;
    v16[4] = &v18;
    v16[5] = Mutable;
    FigXPCPurgeObjectsForPIDWithReportingBlock(int64, (uint64_t)v16);
    v9 = 0;
  }
LABEL_7:
  v10 = (const void *)*MEMORY[0x1E0C9AE50];
  v11 = (const void *)*MEMORY[0x1E0C9AE40];
  if (*((_BYTE *)v19 + 24))
    v12 = (const void *)*MEMORY[0x1E0C9AE50];
  else
    v12 = (const void *)*MEMORY[0x1E0C9AE40];
  FigXPCMessageSetCFBoolean(a3, "CouldNotPurgeAllObjects", v12);
  if (v17)
    v13 = v10;
  else
    v13 = v11;
  FigXPCMessageSetCFBoolean(a3, "PurgeProhibited", v13);
  FigXPCMessageSetCFString(a3, "Stats", Mutable);
  if (Mutable)
    CFRelease(Mutable);
  _Block_object_dispose(&v18, 8);
  return v9;
}

uint64_t HandleControlCommandsServerRemoteMessageNoReply(_xpc_connection_s *a1, void *a2)
{
  uint64_t result;
  int v4;
  unint64_t v5;

  v4 = 0;
  result = FigXPCMessageGetOpCode(a2, &v4);
  if (!(_DWORD)result)
  {
    if (v4 == 1819242352)
    {
      v5 = 0;
      result = FigXPCServerAssociateObjectWithConnection(a1, CFSTR("Loopback"), (uint64_t)CFSTR("refcon"), (uint64_t)AirPlayLoopbackDispose, 0, &v5);
      if (!(_DWORD)result)
      {
        if (setenv("ENABLE_BUFFERED_LOCAL_PLAYBACK", "1", 1))
        {
          return 4294948106;
        }
        else
        {
          FigAtomicIncrement32((unsigned int *)&gEnableBufferedAirplayEnvClientCount);
          return 0;
        }
      }
    }
    else
    {
      return 4294951145;
    }
  }
  return result;
}

uint64_t AirPlayLoopbackDispose()
{
  uint64_t result;

  result = FigAtomicDecrement32((unsigned int *)&gEnableBufferedAirplayEnvClientCount);
  if (!(_DWORD)result)
    return unsetenv("ENABLE_BUFFERED_LOCAL_PLAYBACK");
  return result;
}

void DumpPreferencesToLog(const __CFString *a1)
{
  const __CFString *v2;
  const __CFString *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  _BYTE *v11;
  CFIndex v12;
  const __CFString *ValueAtIndex;
  CFPropertyListRef v14;
  const void *v15;
  CFIndex v16;
  const __CFString *v17;
  const __CFString *v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  _BYTE *v23;
  const __CFArray *v24;
  os_log_type_t type;
  int v26;
  int v27;
  const char *v28;
  __int16 v29;
  const __CFString *v30;
  __int16 v31;
  CFIndex v32;
  __int16 v33;
  const void *v34;
  _BYTE v35[128];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFString *)*MEMORY[0x1E0C9B260];
  v3 = (const __CFString *)*MEMORY[0x1E0C9B230];
  v4 = CFPreferencesCopyKeyList(a1, (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  if (v4)
  {
    v5 = v4;
    Count = CFArrayGetCount(v4);
    if (dword_1EE141EE8)
    {
      v26 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EE0, 1, &v26, &type);
      v8 = v26;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v10 = v8;
      else
        v10 = v8 & 0xFFFFFFFE;
      if (v10)
      {
        v27 = 136315650;
        v28 = "DumpPreferencesToLog";
        v29 = 2114;
        v30 = a1;
        v31 = 2050;
        v32 = Count;
        v11 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v8) = v26;
      }
      else
      {
        v11 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EE0, 1u, 1, v11, v11 != v35, v8, 0, v9);
    }
    if (Count >= 1)
    {
      v12 = 0;
      v24 = v5;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, v12);
        v14 = CFPreferencesCopyValue(ValueAtIndex, a1, v2, v3);
        if (ValueAtIndex)
        {
          v15 = v14;
          if (v14)
          {
            if (dword_1EE141EE8)
            {
              v16 = Count;
              v17 = v3;
              v18 = v2;
              v26 = 0;
              type = OS_LOG_TYPE_DEFAULT;
              v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141EE0, 1, &v26, &type);
              v20 = v26;
              if (os_log_type_enabled(v19, type))
                v22 = v20;
              else
                v22 = v20 & 0xFFFFFFFE;
              if (v22)
              {
                v27 = 136315906;
                v28 = "DumpPreferencesToLog";
                v29 = 2114;
                v30 = a1;
                v31 = 2114;
                v32 = (CFIndex)ValueAtIndex;
                v33 = 2114;
                v34 = v15;
                v23 = (_BYTE *)_os_log_send_and_compose_impl();
                LOBYTE(v20) = v26;
              }
              else
              {
                v23 = 0;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141EE0, 1u, 1, v23, v23 != v35, v20, 0, v21);
              v2 = v18;
              v3 = v17;
              Count = v16;
              v5 = v24;
            }
            CFRelease(v15);
          }
        }
        ++v12;
      }
      while (Count != v12);
    }
    CFRelease(v5);
  }
}

Float64 CMSyncGetRelativeRate(CMClockOrTimebaseRef ofClockOrTimebase, CMClockOrTimebaseRef relativeToClockOrTimebase)
{
  int PivotTransform;
  Float64 result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = 0;
  v5 = 0u;
  v6 = 0u;
  v4 = 0u;
  PivotTransform = figSyncGetPivotTransform((void *)relativeToClockOrTimebase, (void *)ofClockOrTimebase, (uint64_t)&v4);
  result = *((double *)&v5 + 1);
  if (PivotTransform)
    return NAN;
  return result;
}

OSStatus CMSyncGetRelativeRateAndAnchorTime(CMClockOrTimebaseRef ofClockOrTimebase, CMClockOrTimebaseRef relativeToClockOrTimebase, Float64 *outRelativeRate, CMTime *outOfClockOrTimebaseAnchorTime, CMTime *outRelativeToClockOrTimebaseAnchorTime)
{
  OSStatus result;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  CMTimeEpoch v12;

  v12 = 0;
  v10 = 0u;
  v11 = 0u;
  v9 = 0u;
  result = figSyncGetPivotTransform((void *)relativeToClockOrTimebase, (void *)ofClockOrTimebase, (uint64_t)&v9);
  if (!result)
  {
    if (outRelativeRate)
      *outRelativeRate = *((Float64 *)&v10 + 1);
    if (outOfClockOrTimebaseAnchorTime)
    {
      *(_OWORD *)&outOfClockOrTimebaseAnchorTime->value = v11;
      outOfClockOrTimebaseAnchorTime->epoch = v12;
    }
    if (outRelativeToClockOrTimebaseAnchorTime)
    {
      *(_OWORD *)&outRelativeToClockOrTimebaseAnchorTime->value = v9;
      outRelativeToClockOrTimebaseAnchorTime->epoch = v10;
    }
  }
  return result;
}

CMTime *__cdecl CMSyncConvertTime(CMTime *__return_ptr retstr, CMTime *time, CMClockOrTimebaseRef fromClockOrTimebase, CMClockOrTimebaseRef toClockOrTimebase)
{
  CMTime *result;
  CMTime v7;
  _OWORD v8[3];
  uint64_t v9;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!fromClockOrTimebase || !toClockOrTimebase || (time->flags & 0x1D) != 1)
    return (CMTime *)FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  result = (CMTime *)figSyncGetPivotTransform((void *)fromClockOrTimebase, (void *)toClockOrTimebase, (uint64_t)v8);
  if (!(_DWORD)result)
  {
    v7 = *time;
    return FigSyncApplyTransform(&v7, (uint64_t)v8, retstr);
  }
  return result;
}

Boolean CMSyncMightDrift(CMClockOrTimebaseRef clockOrTimebase1, CMClockOrTimebaseRef clockOrTimebase2)
{
  OpaqueCMClock *v3;
  OpaqueCMClock *v4;
  Boolean v5;

  if (clockOrTimebase1 && clockOrTimebase2)
  {
    v3 = (OpaqueCMClock *)figSyncCopyUltimateMasterClockAndHeight((void *)clockOrTimebase1, 0);
    v4 = (OpaqueCMClock *)figSyncCopyUltimateMasterClockAndHeight((void *)clockOrTimebase2, 0);
    v5 = CMClockMightDrift(v3, v4);
    if (v3)
      CFRelease(v3);
    if (v4)
      CFRelease(v4);
  }
  else
  {
    FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
    return 1;
  }
  return v5;
}

CMTime *__cdecl CMSyncGetTime(CMTime *__return_ptr retstr, CMClockOrTimebaseRef clockOrTimebase)
{
  CFTypeID v4;
  CMTime *result;

  if (clockOrTimebase)
  {
    v4 = CFGetTypeID(clockOrTimebase);
    if (v4 == CMClockGetTypeID())
      return CMClockGetTime(retstr, (CMClockRef)clockOrTimebase);
    else
      return CMTimebaseGetTime(retstr, (CMTimebaseRef)clockOrTimebase);
  }
  else
  {
    result = (CMTime *)FigSignalErrorAt(4294954544, 0, 0, 0, 0, 0, 0);
    *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
    retstr->epoch = 0;
  }
  return result;
}

uint64_t FigClockConvertHostTimeToSystemUnits(CMTime *a1)
{
  CMTime v2;

  v2 = *a1;
  return CMClockConvertHostTimeToSystemUnits(&v2);
}

uint64_t FigTimebaseSetTimerDispatchSourceNextFireTime(OpaqueCMTimebase *a1, NSObject *a2, CMTime *a3)
{
  CMTime v4;

  v4 = *a3;
  return CMTimebaseSetTimerDispatchSourceNextFireTime(a1, a2, &v4, 0);
}

pthread_mutex_t *figSyncCopyUltimateMasterClockAndHeight(void *a1, pthread_mutex_t **a2)
{
  CFTypeID v4;

  v4 = CFGetTypeID(a1);
  if (v4 != CMClockGetTypeID())
    return FigTimebaseCopyUltimateMasterClockAndHeight((pthread_mutex_t **)a1, a2);
  if (a2)
    *a2 = 0;
  CFRetain(a1);
  return (pthread_mutex_t *)a1;
}

CFTypeID CMTimebaseGetTypeID(void)
{
  FigThreadRunOnce(&CMTimebaseGetTypeID_sRegisterFigTimebaseOnce, (void (*)(void))registerFigTimebase);
  return sFigTimebaseID;
}

uint64_t CMTimebaseCreateReadOnlyTimebaseWithFlags(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, char a5, CFTypeRef *a6)
{
  uint64_t v6;
  CFTypeRef v11;
  _QWORD *v12;
  __CFNotificationCenter *DefaultLocalCenter;
  CFTypeRef cf;

  cf = 0;
  v6 = 4294954548;
  if (a2 && a6)
  {
    v6 = figTimebaseCreate(a1, a5, &cf);
    if ((_DWORD)v6)
      goto LABEL_5;
    *((_DWORD *)cf + 4) = 2;
    v11 = CFRetain(a2);
    v12 = cf;
    *((_QWORD *)cf + 3) = v11;
    v12[4] = a3;
    v12[5] = a4;
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    v6 = FigNotificationCenterAddWeakListener(DefaultLocalCenter, v12, (CFNotificationCallback)figTimebaseReflectNotification, 0, (unint64_t)v11, 2, 0);
    if ((_DWORD)v6)
    {
LABEL_5:
      if (cf)
        CFRelease(cf);
    }
    else
    {
      *a6 = cf;
    }
  }
  return v6;
}

uint64_t CMTimebaseCreateReadOnlyTimebase(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  return CMTimebaseCreateReadOnlyTimebaseWithFlags(a1, a2, a3, a4, 0, a5);
}

uint64_t CMTimebaseCreateLoopingTimebase(uint64_t a1, __int128 *a2, const void *a3, OpaqueCMTimebase **a4)
{
  int v6;
  int v7;
  OpaqueCMTimebase *v8;
  uint64_t v9;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  NSObject *v16;
  dispatch_object_t *v17;
  NSObject *UltimateMasterClock;
  dispatch_object_t *v19;
  NSObject *v20;
  dispatch_source_t v21;
  uint64_t v22;
  void *v23;
  NSObject *v24;
  __int128 v25;
  CMTimeRange time1;
  CMTime fireTime;
  CMTime time2;
  dispatch_object_t *v29;

  v29 = 0;
  if (!a3 || !a4)
  {
    v9 = 4294954548;
    if (!a4)
      return v9;
    goto LABEL_20;
  }
  v6 = *((_DWORD *)a2 + 3);
  if ((v6 & 1) == 0 || (v7 = *((_DWORD *)a2 + 9), (v7 & 1) == 0) || *((_QWORD *)a2 + 5))
  {
    v8 = 0;
    v9 = 4294954547;
    goto LABEL_7;
  }
  v8 = 0;
  v9 = 4294954547;
  if (((v7 | v6) & 0x10) != 0 || (*((_QWORD *)a2 + 3) & 0x8000000000000000) != 0)
    goto LABEL_7;
  *(_OWORD *)&time1.start.value = *(__int128 *)((char *)a2 + 24);
  time1.start.epoch = *((_QWORD *)a2 + 5);
  *(_OWORD *)&time2.value = *(_OWORD *)&kCMTimeZero.value;
  time2.epoch = 0;
  if (!CMTimeCompare(&time1.start, &time2))
  {
LABEL_20:
    v8 = 0;
    goto LABEL_7;
  }
  v13 = figTimebaseCreate(a1, 0, &v29);
  v8 = (OpaqueCMTimebase *)v29;
  if ((_DWORD)v13)
    goto LABEL_17;
  *((_DWORD *)v29 + 4) = 1;
  v14 = *a2;
  v15 = a2[2];
  *((_OWORD *)v8 + 4) = a2[1];
  *((_OWORD *)v8 + 5) = v15;
  *((_OWORD *)v8 + 3) = v14;
  v16 = CFRetain(a3);
  v17 = v29;
  v29[17] = v16;
  UltimateMasterClock = figTimebaseFindUltimateMasterClock((pthread_mutex_t **)v17, (uint64_t *)v17 + 19);
  if (UltimateMasterClock)
    UltimateMasterClock = CFRetain(UltimateMasterClock);
  v19 = v29;
  v29[18] = UltimateMasterClock;
  *((_OWORD *)v19 + 10) = *(_OWORD *)&kCMTimeZero.value;
  v19[22] = 0;
  v19[23] = (dispatch_object_t)0x3FF0000000000000;
  *((_OWORD *)v19 + 12) = *(_OWORD *)&kCMTimeZero.value;
  v19[26] = 0;
  *((_BYTE *)v19 + 216) = 0;
  v20 = dispatch_queue_create("com.apple.timebase.loop", 0);
  v29[12] = v20;
  v21 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v20);
  v22 = (uint64_t)v29;
  v29[13] = v21;
  v23 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v22);
  dispatch_set_context(v29[13], v23);
  dispatch_source_set_event_handler_f(v29[13], (dispatch_function_t)figTimebaseLoopEndTimerCallback);
  dispatch_source_set_cancel_handler_f(v29[13], (dispatch_function_t)figTimebaseLoopEndTimerCancelCallback);
  dispatch_resume(v29[13]);
  v13 = CMTimebaseAddTimerDispatchSource((CMTimebaseRef)v29, v29[13]);
  v8 = (OpaqueCMTimebase *)v29;
  if ((_DWORD)v13
    || (v13 = figTimebaseSwitchListenersToNewMaster(v29, 0, (unint64_t)a3),
        v8 = (OpaqueCMTimebase *)v29,
        (_DWORD)v13))
  {
LABEL_17:
    v9 = v13;
  }
  else
  {
    v24 = v29[13];
    v25 = a2[1];
    *(_OWORD *)&time1.start.value = *a2;
    *(_OWORD *)&time1.start.epoch = v25;
    *(_OWORD *)&time1.duration.timescale = a2[2];
    CMTimeRangeGetEnd(&fireTime, &time1);
    v9 = CMTimebaseSetTimerDispatchSourceNextFireTime(v8, v24, &fireTime, 0);
    v8 = (OpaqueCMTimebase *)v29;
    if (!(_DWORD)v9)
      goto LABEL_7;
  }
  if (v8)
  {
    CFRelease(v8);
    goto LABEL_20;
  }
LABEL_7:
  *a4 = v8;
  return v9;
}

void figTimebaseLoopEndTimerCallback(id *a1)
{
  pthread_mutex_t **v1;
  pthread_mutex_t **v2;
  CMTime v3;
  CMTime v4;

  v1 = (pthread_mutex_t **)FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    v2 = v1;
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v1, 1, 0, &v4);
    v4 = *(CMTime *)((_BYTE *)v2 + 8);
    v3 = *(CMTime *)(v2 + 20);
    figTimebaseSetAnchorTimeMaybeNowMaybeNotifying((uint64_t)v2, &v4, &v3, 0, 1);
    CFRelease(v2);
  }
}

void figTimebaseLoopEndTimerCancelCallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

OSStatus CMTimebaseAddTimerDispatchSource(CMTimebaseRef timebase, dispatch_source_t timerSource)
{
  OSStatus v2;
  const __CFDictionary *v6;
  const __CFAllocator *v7;
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v10;
  CFDataRef v11;
  CFDataRef v12;
  CFDictionaryValueCallBacks valueCallBacks;
  CFDictionaryKeyCallBacks keyCallBacks;

  v2 = -12748;
  if (!timebase || !timerSource)
    return v2;
  if (dispatch_source_testcancel(timerSource))
    return FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
  v6 = (const __CFDictionary *)*((_QWORD *)timebase + 38);
  if (!v6)
  {
    keyCallBacks.version = 0;
    keyCallBacks.retain = (CFDictionaryRetainCallBack)cfDispatchSourceRetain;
    keyCallBacks.release = (CFDictionaryReleaseCallBack)cfDispatchSourceRelease;
    memset(&keyCallBacks.copyDescription, 0, 24);
    valueCallBacks.version = 0;
    valueCallBacks.retain = (CFDictionaryRetainCallBack)cfDataFigTimeRetain;
    valueCallBacks.release = (CFDictionaryReleaseCallBack)cfDataFigTimeRelease;
    valueCallBacks.copyDescription = (CFDictionaryCopyDescriptionCallBack)cfDataFigTimeCopyDescription;
    valueCallBacks.equal = (CFDictionaryEqualCallBack)cfDataFigTimeEqual;
    v7 = CFGetAllocator(timebase);
    v6 = CFDictionaryCreateMutable(v7, 0, &keyCallBacks, &valueCallBacks);
    *((_QWORD *)timebase + 38) = v6;
    if (!v6)
      goto LABEL_14;
  }
  if (!*((_QWORD *)timebase + 39))
  {
    v8 = CFGetAllocator(timebase);
    Mutable = CFDictionaryCreateMutable(v8, 0, 0, 0);
    *((_QWORD *)timebase + 39) = Mutable;
    if (!Mutable)
      goto LABEL_14;
    v6 = (const __CFDictionary *)*((_QWORD *)timebase + 38);
  }
  if (!CFDictionaryContainsKey(v6, timerSource))
  {
    v10 = CFGetAllocator(timebase);
    v11 = CFDataCreate(v10, (const UInt8 *)&kCMTimeInvalid, 24);
    if (v11)
    {
      v12 = v11;
      dispatch_source_set_timer(timerSource, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)timebase + 38), timerSource, v12);
      CFRelease(v12);
      goto LABEL_13;
    }
LABEL_14:
    v2 = FigSignalErrorAt(4294954546, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
LABEL_13:
  v2 = 0;
LABEL_15:
  FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  return v2;
}

OSStatus CMTimebaseSetTimerDispatchSourceNextFireTime(CMTimebaseRef timebase, dispatch_source_t timerSource, CMTime *fireTime, uint32_t flags)
{
  OSStatus v4;
  const __CFDictionary *v9;
  uint64_t v10;
  const __CFAllocator *v11;
  CFDataRef v12;
  CFDataRef v13;
  CMTime v15;
  CMTime v16;

  v4 = -12748;
  if (timebase && timerSource)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    v9 = (const __CFDictionary *)*((_QWORD *)timebase + 38);
    if (!v9 || !CFDictionaryContainsKey(v9, timerSource))
    {
      v4 = -12749;
      goto LABEL_10;
    }
    if (dispatch_source_testcancel(timerSource))
    {
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 38), timerSource);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 39), timerSource);
      v10 = 4294954547;
    }
    else
    {
      v11 = CFGetAllocator(timebase);
      v12 = CFDataCreate(v11, (const UInt8 *)fireTime, 24);
      if (v12)
      {
        v13 = v12;
        CFDictionaryReplaceValue(*((CFMutableDictionaryRef *)timebase + 38), timerSource, v12);
        CFRelease(v13);
        CFDictionarySetValue(*((CFMutableDictionaryRef *)timebase + 39), timerSource, (const void *)flags);
        figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)timebase, 1, 0, &v16);
        v15 = *fireTime;
        rescheduleTimerSource(timerSource, &v15, timebase, &v16, 2, flags);
        v4 = 0;
        goto LABEL_10;
      }
      v10 = 4294954546;
    }
    v4 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
LABEL_10:
    FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  }
  return v4;
}

uint64_t FigReadOnlyTimebaseSetTargetTimebase(uint64_t a1, pthread_mutex_t **cf)
{
  uint64_t TransformRelativeToUltimateMasterClock;
  const __CFAllocator *v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  pthread_mutex_t **v8;
  double EffectiveRate;
  pthread_mutex_t *v10;
  double v11;
  pthread_mutex_t *v12;
  uint64_t v13;
  _BOOL4 v14;
  __CFNotificationCenter *DefaultLocalCenter;
  BOOL v16;
  int v17;
  double v18;
  int v19;
  int v20;
  int v22;
  const __CFAllocator *v23;
  CFDictionaryRef v24;
  CFDictionaryRef v25;
  CMTime v27;
  __int128 v28;
  __int128 v29;
  CMTime v30;
  __int128 v31;
  Float64 multiplier[2];
  CMTime v33;
  CMTime v34;
  CMTime rhs;
  CMTime lhs;
  CMTime v37;
  CMTime v38;
  CMTime v39;

  memset(&v34, 0, sizeof(v34));
  TransformRelativeToUltimateMasterClock = 4294954548;
  if (!a1 || !cf)
    return TransformRelativeToUltimateMasterClock;
  if (!*(_QWORD *)(a1 + 24) || figTimebaseIsDescendantOfTimebase(cf, (pthread_mutex_t *)a1))
    return 4294954547;
  *(_OWORD *)multiplier = 0u;
  memset(&v33, 0, sizeof(v33));
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  memset(&v30, 0, sizeof(v30));
  v5 = CFGetAllocator((CFTypeRef)a1);
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a1, 1, 0, &v27);
  v6 = figTimebaseCreatePayloadForNotificationAtTime(v5, &v27);
  if (!v6)
    return 4294954546;
  v7 = v6;
  figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseMasterWillChange"), v6);
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 112));
  v8 = *(pthread_mutex_t ***)(a1 + 24);
  if (v8 == cf)
  {
    TransformRelativeToUltimateMasterClock = 0;
    v10 = 0;
    goto LABEL_50;
  }
  FigReentrantMutexLock(v8[14]);
  EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)v8);
  v10 = FigTimebaseCopyUltimateMasterClockAndHeight(v8, 0);
  TransformRelativeToUltimateMasterClock = FigTimebaseGetTransformRelativeToUltimateMasterClock(v8, 1, (uint64_t)&v31);
  FigReentrantMutexUnlock(v8[14]);
  if ((_DWORD)TransformRelativeToUltimateMasterClock)
  {
LABEL_50:
    v12 = 0;
LABEL_52:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    goto LABEL_54;
  }
  FigReentrantMutexLock(cf[14]);
  v11 = CMTimebaseGetEffectiveRate((CMTimebaseRef)cf);
  v12 = FigTimebaseCopyUltimateMasterClockAndHeight(cf, 0);
  v13 = FigTimebaseGetTransformRelativeToUltimateMasterClock(cf, 1, (uint64_t)&v28);
  if ((_DWORD)v13)
  {
    TransformRelativeToUltimateMasterClock = v13;
    FigReentrantMutexUnlock(cf[14]);
    goto LABEL_52;
  }
  memset(&v39, 0, sizeof(v39));
  memset(&v38, 0, sizeof(v38));
  memset(&v37, 0, sizeof(v37));
  if (CFEqual(v10, v12) && multiplier[1] == *((double *)&v29 + 1))
  {
    lhs = v33;
    rhs = v30;
    CMTimeSubtract(&v39, &lhs, &rhs);
    *(_OWORD *)&lhs.value = v31;
    *(Float64 *)&lhs.epoch = multiplier[0];
    *(_OWORD *)&rhs.value = v28;
    rhs.epoch = v29;
    CMTimeSubtract(&v38, &lhs, &rhs);
    lhs = v38;
    CMTimeMultiplyByFloat64(&v37, &lhs, multiplier[1]);
    lhs = v37;
    rhs = v39;
    v14 = CMTimeCompare(&lhs, &rhs) != 0;
  }
  else
  {
    v14 = 1;
  }
  *(_QWORD *)(a1 + 24) = cf;
  CFRetain(cf);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)a1, (CFNotificationCallback)figTimebaseReflectNotification, 0, (unint64_t)cf, 2, 0);
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(cf, 1, 0, &v34);
  FigReentrantMutexUnlock(cf[14]);
  v16 = EffectiveRate == v11 && !v14;
  v17 = !v16;
  if (!v16)
  {
    v18 = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    v19 = *(_DWORD *)(a1 + 320);
    if (v18 > 0.0)
      v20 = 1;
    else
      v20 = -1;
    if (v18 == 0.0)
      v20 = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 320) = v20;
    v22 = !v14 && v19 == v20;
    if (*(_QWORD *)(a1 + 280))
    {
      v39 = v34;
      rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a1, &v39, v22);
    }
    if (*(_QWORD *)(a1 + 304))
    {
      v39 = v34;
      rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a1, &v39, v22);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  TransformRelativeToUltimateMasterClock = figTimebaseUninstallReadOnlyTimebaseNotifications((const void *)a1, v8);
  CFRelease(v8);
  v23 = CFGetAllocator((CFTypeRef)a1);
  v39 = v34;
  v24 = figTimebaseCreatePayloadForNotificationAtTime(v23, &v39);
  if (v24)
  {
    v25 = v24;
    figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseMasterDidChange"), v24);
    if (v17)
    {
      if (EffectiveRate != v11)
        figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseEffectiveRateChanged"), v25);
      if (v14)
        figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseTimeJumped"), v25);
    }
    CFRelease(v7);
    goto LABEL_43;
  }
  TransformRelativeToUltimateMasterClock = 4294954546;
LABEL_54:
  figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseMasterDidChange"), v7);
  v25 = v7;
LABEL_43:
  CFRelease(v25);
  if (v10)
    CFRelease(v10);
  if (v12)
    CFRelease(v12);
  return TransformRelativeToUltimateMasterClock;
}

uint64_t figTimebaseIsDescendantOfTimebase(pthread_mutex_t **cf, pthread_mutex_t *a2)
{
  pthread_mutex_t **v2;
  pthread_mutex_t *v4;
  uint64_t v5;

  if (cf == (pthread_mutex_t **)a2)
    return 1;
  v2 = cf;
  if (!cf)
    return 0;
  CFRetain(cf);
  while (1)
  {
    FigReentrantMutexLock(v2[14]);
    v4 = v2[3];
    if (!v4)
    {
      v4 = v2[17];
      if (!v4)
        break;
    }
    CFRetain(v4);
    FigReentrantMutexUnlock(v2[14]);
    if (v4 == a2)
    {
      CFRelease(a2);
      v5 = 1;
      goto LABEL_12;
    }
    CFRetain(v4);
    CFRelease(v2);
    CFRelease(v4);
    v2 = (pthread_mutex_t **)v4;
  }
  FigReentrantMutexUnlock(v2[14]);
  v5 = 0;
LABEL_12:
  CFRelease(v2);
  return v5;
}

CFDictionaryRef figTimebaseCreatePayloadForNotificationAtTime(CFAllocatorRef allocator, CMTime *a2)
{
  CFDictionaryRef v3;
  CMTime cf;

  cf = *a2;
  cf.value = (CMTimeValue)CMTimeCopyAsDictionary(&cf, allocator);
  if (!cf.value)
    return 0;
  v3 = CFDictionaryCreate(allocator, (const void **)&kCMTimebaseNotificationKey_EventTime, (const void **)&cf, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (cf.value)
    CFRelease((CFTypeRef)cf.value);
  return v3;
}

CMTime *__cdecl CMTimebaseGetTime(CMTime *__return_ptr retstr, CMTimebaseRef timebase)
{
  CMTime *result;

  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)timebase, 1, 0, retstr);
  return result;
}

uint64_t figTimebasePostNotification(_QWORD *a1, const __CFString *a2, const void *a3)
{
  NSObject *v6;
  CFNotificationCenterRef DefaultLocalCenter;

  v6 = a1[15];
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  if (v6)
    return FigDispatchAsyncPostNotification(v6, DefaultLocalCenter, a2, a1, a3, 0);
  else
    return CMNotificationCenterPostNotification(DefaultLocalCenter, a2, a1, a3);
}

Float64 CMTimebaseGetEffectiveRate(CMTimebaseRef timebase)
{
  pthread_mutex_t **v1;
  double Rate;
  double RelativeRate;
  pthread_mutex_t *v4;

  if (!timebase)
    return 0.0;
  v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  Rate = CMTimebaseGetRate((CMTimebaseRef)v1);
  if (Rate == 0.0)
  {
    RelativeRate = Rate;
    v4 = 0;
    if (!v1)
      goto LABEL_5;
    goto LABEL_4;
  }
  v4 = FigTimebaseCopyUltimateMasterClockAndHeight(v1, 0);
  RelativeRate = CMSyncGetRelativeRate(v1, v4);
  if (v1)
LABEL_4:
    CFRelease(v1);
LABEL_5:
  if (v4)
    CFRelease(v4);
  return RelativeRate;
}

CMClockRef CMTimebaseCopyUltimateSourceClock(CMTimebaseRef timebase)
{
  return (CMClockRef)FigTimebaseCopyUltimateMasterClockAndHeight((pthread_mutex_t **)timebase, 0);
}

void rescheduleValidAndRemoveCancelledTimerSources(CFDictionaryRef *a1, CMTime *a2, int a3)
{
  CFIndex Count;
  uint64_t v7;
  const __CFAllocator *v8;
  const void **v9;
  const void **v10;
  const __CFAllocator *v11;
  const void **v12;
  const void **v13;
  const __CFData *v14;
  const void **v15;
  CFDataRef *v16;
  const void *v17;
  char Value;
  NSObject *v19;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  CMTime v22;
  CMTime v23;

  Count = CFDictionaryGetCount(a1[38]);
  if (Count)
  {
    v7 = Count;
    v8 = CFGetAllocator(a1);
    v9 = (const void **)CFAllocatorAllocate(v8, 8 * v7, 0);
    if (v9)
    {
      v10 = v9;
      v11 = CFGetAllocator(a1);
      v12 = (const void **)CFAllocatorAllocate(v11, 8 * v7, 0);
      if (v12)
      {
        v13 = v12;
        CFDictionaryGetKeysAndValues(a1[38], v10, v12);
        if (v7 >= 1)
        {
          v14 = (const __CFData *)*MEMORY[0x1E0C9AE40];
          v15 = v10;
          v16 = (CFDataRef *)v13;
          do
          {
            v17 = *v15;
            if (dispatch_source_testcancel((dispatch_source_t)*v15))
            {
              CFDictionaryRemoveValue(a1[38], v17);
              CFDictionaryRemoveValue(a1[39], *v15);
            }
            else if (v14 != *v16)
            {
              v23 = *(CMTime *)CFDataGetBytePtr(*v16);
              Value = CFDictionaryGetValue(a1[39], *v15);
              v19 = *v15;
              v22 = *a2;
              rescheduleTimerSource(v19, &v23, (OpaqueCMTimebase *)a1, &v22, a3, Value);
            }
            ++v16;
            ++v15;
            --v7;
          }
          while (v7);
        }
        v20 = CFGetAllocator(a1);
        CFAllocatorDeallocate(v20, v10);
      }
      else
      {
        v13 = v10;
      }
      v21 = CFGetAllocator(a1);
      CFAllocatorDeallocate(v21, v13);
    }
  }
}

uint64_t figTimebaseUninstallReadOnlyTimebaseNotifications(const void *a1, const void *a2)
{
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v5;
  CFNotificationCenterRef v6;

  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  v5 = FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)figTimebaseReflectNotification, 0, a2);
  if (a2)
  {
    v6 = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterBarrier((uint64_t)v6, (uint64_t)a2);
  }
  return v5;
}

OSStatus CMTimebaseCreateWithSourceClock(CFAllocatorRef allocator, CMClockRef sourceClock, CMTimebaseRef *timebaseOut)
{
  OSStatus v5;
  _QWORD *v6;
  CFTypeRef v7;
  CFTypeRef v8;
  CFTypeRef cf;

  cf = 0;
  if (sourceClock && timebaseOut)
  {
    v5 = figTimebaseCreate((uint64_t)allocator, 0, &cf);
    if (!v5)
    {
      *((_DWORD *)cf + 4) = 0;
      v7 = CFRetain(sourceClock);
      *((_QWORD *)cf + 16) = v7;
      v8 = CFRetain(sourceClock);
      v6 = cf;
      *((_QWORD *)cf + 18) = v8;
      v6[19] = 1;
      v6[22] = 0;
      v6[23] = 0;
      v6[26] = 0;
      *((_OWORD *)v6 + 10) = *(_OWORD *)&kCMTimeZero.value;
      *((_OWORD *)v6 + 12) = *(_OWORD *)&kCMTimeZero.value;
      *((_BYTE *)v6 + 216) = 0;
      goto LABEL_10;
    }
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v5 = FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
  if (timebaseOut)
  {
    v6 = 0;
LABEL_10:
    *timebaseOut = (CMTimebaseRef)v6;
  }
  return v5;
}

OSStatus CMTimebaseCreateWithSourceTimebase(CFAllocatorRef allocator, CMTimebaseRef sourceTimebase, CMTimebaseRef *timebaseOut)
{
  OSStatus v5;
  CFTypeRef v6;
  CFTypeRef v7;
  void *v8;
  const void *UltimateMasterClock;
  _OWORD *v10;
  OSStatus v11;
  CFTypeRef cf;

  cf = 0;
  if (sourceTimebase && timebaseOut)
  {
    v5 = figTimebaseCreate((uint64_t)allocator, 0, &cf);
    v6 = cf;
    if (v5)
      goto LABEL_10;
    *((_DWORD *)cf + 4) = 0;
    v7 = CFRetain(sourceTimebase);
    v8 = (void *)cf;
    *((_QWORD *)cf + 17) = v7;
    UltimateMasterClock = (const void *)figTimebaseFindUltimateMasterClock((pthread_mutex_t **)v8, (uint64_t *)v8 + 19);
    if (UltimateMasterClock)
      UltimateMasterClock = CFRetain(UltimateMasterClock);
    v10 = cf;
    *((_QWORD *)cf + 18) = UltimateMasterClock;
    v10[10] = *(_OWORD *)&kCMTimeZero.value;
    *((_QWORD *)v10 + 22) = 0;
    *((_QWORD *)v10 + 23) = 0;
    v10[12] = *(_OWORD *)&kCMTimeZero.value;
    *((_QWORD *)v10 + 26) = 0;
    *((_BYTE *)v10 + 216) = 0;
    v11 = figTimebaseSwitchListenersToNewMaster(v10, 0, (unint64_t)sourceTimebase);
  }
  else
  {
    v11 = FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
  v5 = v11;
  if (!v11)
    goto LABEL_13;
  v6 = cf;
LABEL_10:
  if (v6)
    CFRelease(v6);
  cf = 0;
LABEL_13:
  if (timebaseOut)
    *timebaseOut = (CMTimebaseRef)cf;
  return v5;
}

void figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(pthread_mutex_t **a1@<X0>, int a2@<W1>, int a3@<W2>, CMTime *a4@<X8>)
{
  pthread_mutex_t **v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int value;
  uint64_t v10;
  unsigned int v11;
  Float64 Seconds;
  Float64 v13;
  CMTimeRange *v14;
  pthread_mutex_t **v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  NSObject *v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  Float64 v23;
  CMTimeRange *v24;
  CMTime v25;
  __int128 v26;
  CMTimeEpoch v27;
  CMTime rhs;
  CMTime v29;
  CMTime v30;
  CMTime v31;
  CMTime v32;
  CMTime type;
  CMTime v34;
  CMTime time2;
  unsigned int v36;
  __int16 v37;
  Float64 v38;
  __int16 v39;
  Float64 v40;
  CMTimeRange time[2];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&a4->value = *(_OWORD *)&kCMTimeInvalid.value;
  a4->epoch = 0;
  v26 = *(_OWORD *)&kCMTimeInvalid.value;
  v27 = 0;
  if (a1)
  {
    v7 = figTimebaseCopyTargetTimebase(a1);
    figTimebaseGetMasterTime(&v26, v7);
    *(_OWORD *)&time[0].start.value = v26;
    time[0].start.epoch = v27;
    figTimebaseGetTimeAtMasterTime(v7, &time[0].start, a4);
    if (a3 && dword_1ECDA8438)
    {
      LODWORD(v34.value) = 0;
      LOBYTE(type.value) = 0;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8430, 1, (int *)&v34, &type);
      value = v34.value;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value))
        v11 = value;
      else
        v11 = value & 0xFFFFFFFE;
      if (v11)
      {
        value = *((_DWORD *)v7 + 4);
        *(_OWORD *)&time[0].start.value = v26;
        time[0].start.epoch = v27;
        Seconds = CMTimeGetSeconds(&time[0].start);
        *(_OWORD *)&time[0].start.value = *(_OWORD *)&a4->value;
        time[0].start.epoch = a4->epoch;
        v13 = CMTimeGetSeconds(&time[0].start);
        LODWORD(time2.value) = 136316162;
        *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness";
        LOWORD(time2.flags) = 2048;
        *(_QWORD *)((char *)&time2.flags + 2) = v7;
        HIWORD(time2.epoch) = 1024;
        v36 = value;
        v37 = 2048;
        v38 = Seconds;
        v39 = 2048;
        v40 = v13;
        v14 = (CMTimeRange *)_os_log_send_and_compose_impl();
        LOBYTE(value) = v34.value;
      }
      else
      {
        v14 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8430, 1u, 1, v14, v14 != time, value, 0, v10);
    }
    if (*((_DWORD *)v7 + 4) == 1)
    {
      v25 = *a4;
      v15 = figTimebaseCopyTargetTimebase(v7);
      v16 = (uint64_t)v15;
      if (*((_DWORD *)v15 + 4) == 1)
      {
        v17 = *((_OWORD *)v15 + 4);
        v34 = *(CMTime *)((_BYTE *)v15 + 2);
        type = *(CMTime *)((_BYTE *)v15 + 3);
        memset(&v32, 0, sizeof(v32));
        *(_OWORD *)&time[0].start.value = *((_OWORD *)v15 + 3);
        *(_OWORD *)&time[0].start.epoch = v17;
        *(_OWORD *)&time[0].duration.timescale = *((_OWORD *)v15 + 5);
        CMTimeRangeGetEnd(&v32, time);
        time[0].start = v25;
        time2 = v32;
        if ((CMTimeCompare(&time[0].start, &time2) & 0x80000000) == 0)
        {
          memset(&v31, 0, sizeof(v31));
          *(_OWORD *)&time[0].start.value = v26;
          time[0].start.epoch = v27;
          time2 = v34;
          CMTimeSubtract(&v31, &time[0].start, &time2);
          memset(&v30, 0, sizeof(v30));
          time[0].start = v31;
          time2 = type;
          v18 = CMTimeDivide((uint64_t)time, (uint64_t)&time2, (uint64_t)&v30);
          if (a2)
          {
            memset(&v29, 0, sizeof(v29));
            if (v18 > 0x7FFFFFFF)
            {
              *(_OWORD *)&time[0].start.value = v26;
              time[0].start.epoch = v27;
              time2 = v30;
              CMTimeSubtract(&v29, &time[0].start, &time2);
            }
            else
            {
              memset(time, 0, 24);
              time2 = type;
              CMTimeMultiply(&time[0].start, &time2, v18);
              time2 = v34;
              rhs = time[0].start;
              CMTimeAdd(&v29, &time2, &rhs);
            }
            *(_OWORD *)&time[0].start.value = *(_OWORD *)(v16 + 160);
            time[0].start.epoch = *(_QWORD *)(v16 + 176);
            time2 = v29;
            if (CMTimeCompare(&time[0].start, &time2))
            {
              time[0].start = v34;
              time2 = v29;
              figTimebaseSetAnchorTimeMaybeNowMaybeNotifying(v16, &time[0].start, &time2, 0, 0);
            }
          }
          time[0].start = v34;
          time2 = v30;
          CMTimeAdd(&v25, &time[0].start, &time2);
        }
      }
      CFRelease((CFTypeRef)v16);
      *a4 = v25;
      if (a3 && dword_1ECDA8438)
      {
        LODWORD(v34.value) = 0;
        LOBYTE(type.value) = 0;
        v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8430, 1, (int *)&v34, &type);
        v20 = v34.value;
        if (os_log_type_enabled(v19, type.value))
          v22 = v20;
        else
          v22 = v20 & 0xFFFFFFFE;
        if (v22)
        {
          *(_OWORD *)&time[0].start.value = *(_OWORD *)&a4->value;
          time[0].start.epoch = a4->epoch;
          v23 = CMTimeGetSeconds(&time[0].start);
          LODWORD(time2.value) = 136315394;
          *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness";
          LOWORD(time2.flags) = 2048;
          *(Float64 *)((char *)&time2.flags + 2) = v23;
          v24 = (CMTimeRange *)_os_log_send_and_compose_impl();
          LOBYTE(v20) = v34.value;
        }
        else
        {
          v24 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8430, 1u, 1, v24, v24 != time, v20, 0, v21);
      }
    }
    CFRelease(v7);
  }
}

void CMTimebaseGetTimeWithLogging(pthread_mutex_t **a1@<X0>, CMTime *a2@<X8>)
{
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(a1, 1, 1, a2);
}

CMTime *__cdecl CMTimebaseGetTimeWithTimeScale(CMTime *__return_ptr retstr, CMTime *timebase, CMTimeScale timescale, CMTimeRoundingMethod method)
{
  pthread_mutex_t **v7;
  CMTime v9;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (timebase)
  {
    v7 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v7, 1, 0, retstr);
    if (timescale)
    {
      if ((retstr->flags & 0x1D) == 1 && retstr->timescale != timescale)
      {
        v9 = *retstr;
        timebase = CMTimeConvertScale(retstr, &v9, timescale, method);
      }
    }
    if (v7)
      CFRelease(v7);
  }
  return timebase;
}

pthread_mutex_t **figTimebaseCopyTargetTimebase(pthread_mutex_t **a1)
{
  pthread_mutex_t **v1;
  pthread_mutex_t **i;
  pthread_mutex_t **v3;

  if (!a1)
    return 0;
  v1 = a1;
  CFRetain(a1);
  for (i = 0; ; i = v3)
  {
    v3 = v1;
    if (i)
      CFRelease(i);
    FigReentrantMutexLock(v1[14]);
    v1 = (pthread_mutex_t **)v1[3];
    if (!v1)
      break;
    CFRetain(v3[3]);
    FigReentrantMutexUnlock(v3[14]);
  }
  FigReentrantMutexUnlock(v3[14]);
  return v3;
}

OSStatus CMTimebaseSetTime(CMTimebaseRef timebase, CMTime *time)
{
  OSStatus result;
  uint64_t v5;
  CMTime v6;
  CMTime v7;

  if (!timebase)
    return -12748;
  if ((time->flags & 0x1D) != 1)
  {
    v5 = 4294954548;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  result = figTimebaseVerifyReadWrite((uint64_t)timebase);
  if (!result)
  {
    if (*((_DWORD *)timebase + 4) == 1)
    {
      v5 = 4294954539;
      return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
    }
    v7 = *time;
    memset(&v6, 0, sizeof(v6));
    return figTimebaseSetAnchorTimeMaybeNowMaybeNotifying((uint64_t)timebase, &v7, &v6, 1, 1);
  }
  return result;
}

uint64_t figTimebaseVerifyReadWrite(uint64_t a1)
{
  void (*v1)(uint64_t, _QWORD);

  if (*(_DWORD *)(a1 + 16) != 2)
    return 0;
  v1 = *(void (**)(uint64_t, _QWORD))(a1 + 32);
  if (v1)
    v1(a1, *(_QWORD *)(a1 + 40));
  return FigSignalErrorAt(4294954539, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTimebaseSetAnchorTime(CMTimebaseRef timebase, CMTime *timebaseTime, CMTime *immediateSourceTime)
{
  CMTime v4;
  CMTime v5;

  if (!timebase)
    return -12748;
  if (*((_DWORD *)timebase + 4) == 1)
    return FigSignalErrorAt(4294954539, 0, 0, 0, 0, 0, 0);
  v5 = *timebaseTime;
  v4 = *immediateSourceTime;
  return figTimebaseSetAnchorTimeMaybeNowMaybeNotifying((uint64_t)timebase, &v5, &v4, 0, 1);
}

Float64 CMTimebaseGetRate(CMTimebaseRef timebase)
{
  pthread_mutex_t **v1;
  double v2;

  if (!timebase)
    return 0.0;
  v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  FigReentrantMutexLock(v1[14]);
  v2 = *((double *)v1 + 23);
  FigReentrantMutexUnlock(v1[14]);
  CFRelease(v1);
  return v2;
}

OSStatus CMTimebaseGetTimeAndRate(CMTimebaseRef timebase, CMTime *timeOut, Float64 *rateOut)
{
  CMTime v7;

  if (!timebase)
    return -12748;
  FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
  if (timeOut)
  {
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)timebase, 1, 0, &v7);
    *timeOut = v7;
  }
  if (rateOut)
    *rateOut = CMTimebaseGetRate(timebase);
  FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  return 0;
}

OSStatus CMTimebaseSetRate(CMTimebaseRef timebase, Float64 rate)
{
  OSStatus result;
  CMTime v5;
  __int128 v6;
  uint64_t v7;

  if (!timebase)
    return -12748;
  result = figTimebaseVerifyReadWrite((uint64_t)timebase);
  if (!result)
  {
    v6 = *(_OWORD *)&kCMTimeInvalid.value;
    v7 = 0;
    memset(&v5, 0, sizeof(v5));
    return figTimebaseSetRateAndMaybeAnchorTime((uint64_t)timebase, &v6, &v5, 0, rate);
  }
  return result;
}

OSStatus CMTimebaseSetRateAndAnchorTime(CMTimebaseRef timebase, Float64 rate, CMTime *timebaseTime, CMTime *immediateSourceTime)
{
  CMTime v5;
  CMTime v6;

  v6 = *timebaseTime;
  v5 = *immediateSourceTime;
  return CMTimebaseSetRateAndAnchorTimeWithFlags((uint64_t)timebase, (uint64_t)&v6, &v5, 0, rate);
}

uint64_t CMTimebaseSetRateAndAnchorTimeWithFlags(uint64_t a1, uint64_t a2, CMTime *a3, int a4, double a5)
{
  uint64_t result;
  CMTime v11;
  __int128 v12;
  uint64_t v13;

  if (!a1)
    return 4294954548;
  result = figTimebaseVerifyReadWrite(a1);
  if (!(_DWORD)result)
  {
    v12 = *(_OWORD *)a2;
    v13 = *(_QWORD *)(a2 + 16);
    v11 = *a3;
    return figTimebaseSetRateAndMaybeAnchorTime(a1, &v12, &v11, a4, a5);
  }
  return result;
}

CMTimebaseRef CMTimebaseCopySourceTimebase(CMTimebaseRef timebase)
{
  pthread_mutex_t **v1;
  OpaqueCMTimebase *v2;

  if (!timebase)
    return 0;
  v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  FigReentrantMutexLock(v1[14]);
  v2 = (OpaqueCMTimebase *)v1[17];
  if (v2)
    CFRetain(v1[17]);
  FigReentrantMutexUnlock(v1[14]);
  CFRelease(v1);
  return v2;
}

CMClockRef CMTimebaseGetMasterClock(CMTimebaseRef timebase)
{
  CMClockRef v1;
  OpaqueCMClock *v2;

  v1 = CMTimebaseCopySourceClock(timebase);
  v2 = v1;
  if (v1)
    CFRelease(v1);
  return v2;
}

CMClockRef CMTimebaseCopySourceClock(CMTimebaseRef timebase)
{
  pthread_mutex_t **v1;
  OpaqueCMClock *v2;

  if (!timebase)
    return 0;
  v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  FigReentrantMutexLock(v1[14]);
  v2 = (OpaqueCMClock *)v1[16];
  if (v2)
    CFRetain(v1[16]);
  FigReentrantMutexUnlock(v1[14]);
  CFRelease(v1);
  return v2;
}

CMTimebaseRef CMTimebaseGetMasterTimebase(CMTimebaseRef timebase)
{
  CMTimebaseRef v1;
  OpaqueCMTimebase *v2;

  v1 = CMTimebaseCopySourceTimebase(timebase);
  v2 = v1;
  if (v1)
    CFRelease(v1);
  return v2;
}

CMClockOrTimebaseRef CMTimebaseGetMaster(CMTimebaseRef timebase)
{
  CMClockOrTimebaseRef v1;
  const void *v2;

  v1 = CMTimebaseCopySource(timebase);
  v2 = v1;
  if (v1)
    CFRelease(v1);
  return v2;
}

CMClockOrTimebaseRef CMTimebaseCopySource(CMTimebaseRef timebase)
{
  pthread_mutex_t **v1;
  pthread_mutex_t *v2;

  if (!timebase)
    return 0;
  v1 = figTimebaseCopyTargetTimebase((pthread_mutex_t **)timebase);
  FigReentrantMutexLock(v1[14]);
  v2 = v1[17];
  if (v2 || (v2 = v1[16]) != 0)
    CFRetain(v2);
  FigReentrantMutexUnlock(v1[14]);
  CFRelease(v1);
  return v2;
}

CMClockRef CMTimebaseGetUltimateMasterClock(CMTimebaseRef timebase)
{
  pthread_mutex_t *v1;
  OpaqueCMClock *v2;

  v1 = FigTimebaseCopyUltimateMasterClockAndHeight((pthread_mutex_t **)timebase, 0);
  v2 = (OpaqueCMClock *)v1;
  if (v1)
    CFRelease(v1);
  return v2;
}

pthread_mutex_t *FigTimebaseCopyUltimateMasterClockAndHeight(pthread_mutex_t **a1, pthread_mutex_t **a2)
{
  pthread_mutex_t **v3;
  pthread_mutex_t *v4;
  pthread_mutex_t *v5;

  if (!a1)
    return 0;
  v3 = figTimebaseCopyTargetTimebase(a1);
  FigReentrantMutexLock(v3[14]);
  v4 = v3[18];
  if (v4)
    CFRetain(v3[18]);
  v5 = v3[19];
  FigReentrantMutexUnlock(v3[14]);
  if (a2 && v4)
    *a2 = v5;
  CFRelease(v3);
  return v4;
}

OSStatus CMTimebaseSetSourceClock(CMTimebaseRef timebase, CMClockRef newSourceClock)
{
  OSStatus result;

  result = -12748;
  if (timebase && newSourceClock)
  {
    result = figTimebaseVerifyReadWrite((uint64_t)timebase);
    if (!result)
      return figTimebaseSetMaster((uint64_t)timebase, 0, newSourceClock);
  }
  return result;
}

uint64_t figTimebaseSetMaster(uint64_t a1, void *a2, void *a3)
{
  const __CFAllocator *v6;
  CFDictionaryRef v7;
  double EffectiveRate;
  pthread_mutex_t **v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *UltimateMasterClock;
  _OWORD *v14;
  int v15;
  const __CFString *v16;
  double v17;
  int v18;
  int v19;
  _BOOL4 v20;
  CMTime v22;
  CMTime v23;

  memset(&v23, 0, sizeof(v23));
  if (!a1 || (a2 == 0) == (a3 == 0))
    return 4294954548;
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a1, 1, 0, &v23);
  v6 = CFGetAllocator((CFTypeRef)a1);
  v22 = v23;
  v7 = figTimebaseCreatePayloadForNotificationAtTime(v6, &v22);
  figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseMasterWillChange"), v7);
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 112));
  EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
  figTimebaseSwitchListenersToNewMaster((void *)a1, *(const void **)(a1 + 136), (unint64_t)a2);
  v9 = *(pthread_mutex_t ***)(a1 + 136);
  if (v9)
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v9, 1, 0, &v22);
  else
    CMClockGetTime(&v22, *(CMClockRef *)(a1 + 128));
  v10 = *(const void **)(a1 + 128);
  *(_QWORD *)(a1 + 128) = a3;
  if (a3)
    CFRetain(a3);
  if (v10)
    CFRelease(v10);
  v11 = *(const void **)(a1 + 136);
  *(_QWORD *)(a1 + 136) = a2;
  if (a2)
    CFRetain(a2);
  if (v11)
    CFRelease(v11);
  v12 = *(const void **)(a1 + 144);
  UltimateMasterClock = (const void *)figTimebaseFindUltimateMasterClock((pthread_mutex_t **)a1, (uint64_t *)(a1 + 152));
  *(_QWORD *)(a1 + 144) = UltimateMasterClock;
  if (UltimateMasterClock)
    CFRetain(UltimateMasterClock);
  if (v12)
    CFRelease(v12);
  v14 = (_OWORD *)(a1 + 160);
  *(CMTime *)(a1 + 192) = v23;
  if (a2)
  {
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a2, 1, 0, &v22);
    *v14 = *(_OWORD *)&v22.value;
    *(_QWORD *)(a1 + 176) = v22.epoch;
    *(_BYTE *)(a1 + 216) = 0;
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a2, 1, 0, &v22);
  }
  else
  {
    CMClockGetTime(&v22, (CMClockRef)a3);
    *v14 = *(_OWORD *)&v22.value;
    *(_QWORD *)(a1 + 176) = v22.epoch;
    *(_BYTE *)(a1 + 216) = 0;
    CMClockGetTime(&v22, (CMClockRef)a3);
  }
  if (*(double *)(a1 + 184) != 0.0)
  {
    FigSyncInvertTransform(a1 + 160, a1 + 224);
    if (!v15)
      *(_BYTE *)(a1 + 216) = 1;
  }
  if (CMTimebaseGetEffectiveRate((CMTimebaseRef)a1) == EffectiveRate)
  {
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    v16 = CFSTR("CMTimebaseMasterDidChange");
  }
  else
  {
    v17 = CMTimebaseGetEffectiveRate((CMTimebaseRef)a1);
    v18 = *(_DWORD *)(a1 + 320);
    if (v17 > 0.0)
      v19 = 1;
    else
      v19 = -1;
    if (v17 == 0.0)
      v19 = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 320) = v19;
    v20 = v18 == v19;
    if (*(_QWORD *)(a1 + 280))
    {
      v22 = v23;
      rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a1, &v22, v20);
    }
    if (*(_QWORD *)(a1 + 304))
    {
      v22 = v23;
      rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a1, &v22, v20);
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseMasterDidChange"), v7);
    v16 = CFSTR("CMTimebaseEffectiveRateChanged");
  }
  figTimebasePostNotification((_QWORD *)a1, v16, v7);
  if (v7)
    CFRelease(v7);
  return 0;
}

OSStatus CMTimebaseSetSourceTimebase(CMTimebaseRef timebase, CMTimebaseRef newSourceTimebase)
{
  OSStatus result;

  result = -12748;
  if (timebase)
  {
    if (newSourceTimebase)
    {
      result = figTimebaseVerifyReadWrite((uint64_t)timebase);
      if (!result)
      {
        if (figTimebaseIsDescendantOfTimebase((pthread_mutex_t **)newSourceTimebase, (pthread_mutex_t *)timebase))return -12749;
        else
          return figTimebaseSetMaster((uint64_t)timebase, newSourceTimebase, 0);
      }
    }
  }
  return result;
}

OSStatus CMTimebaseAddTimer(CMTimebaseRef timebase, CFRunLoopTimerRef timer, CFRunLoopRef runloop)
{
  OSStatus v4;
  const __CFAllocator *v8;
  CFMutableDictionaryRef v9;
  const __CFAllocator *v10;
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v12;
  CFMutableDictionaryRef v13;
  const void *Value;
  uint64_t v15;
  const __CFAllocator *v16;
  CFDataRef v17;
  CFDataRef v18;
  CFDictionaryValueCallBacks valueCallBacks;

  if (!timebase)
    return -12748;
  v4 = -12748;
  if (!timer || !runloop)
    return v4;
  if (CFRunLoopTimerGetInterval(timer) < 86400.0)
    return FigSignalErrorAt(4294954545, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
  if (!*((_QWORD *)timebase + 35))
  {
    valueCallBacks.version = 0;
    valueCallBacks.retain = (CFDictionaryRetainCallBack)cfDataFigTimeRetain;
    valueCallBacks.release = (CFDictionaryReleaseCallBack)cfDataFigTimeRelease;
    valueCallBacks.copyDescription = (CFDictionaryCopyDescriptionCallBack)cfDataFigTimeCopyDescription;
    valueCallBacks.equal = (CFDictionaryEqualCallBack)cfDataFigTimeEqual;
    v8 = CFGetAllocator(timebase);
    v9 = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E0C9B390], &valueCallBacks);
    *((_QWORD *)timebase + 35) = v9;
    if (!v9)
      goto LABEL_18;
  }
  if (!*((_QWORD *)timebase + 36))
  {
    v10 = CFGetAllocator(timebase);
    Mutable = CFDictionaryCreateMutable(v10, 0, 0, 0);
    *((_QWORD *)timebase + 36) = Mutable;
    if (!Mutable)
      goto LABEL_18;
  }
  if (!*((_QWORD *)timebase + 37))
  {
    v12 = CFGetAllocator(timebase);
    v13 = CFDictionaryCreateMutable(v12, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)timebase + 37) = v13;
    if (!v13)
      goto LABEL_18;
  }
  if (!CFDictionaryContainsKey(*((CFDictionaryRef *)timebase + 35), timer))
  {
    v16 = CFGetAllocator(timebase);
    v17 = CFDataCreate(v16, (const UInt8 *)&kCMTimeInvalid, 24);
    if (v17)
    {
      v18 = v17;
      CFRunLoopTimerSetNextFireDate(timer, 8073216000.0);
      CFRunLoopWakeUp(runloop);
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)timebase + 35), timer, v18);
      CFRelease(v18);
      CFDictionaryAddValue(*((CFMutableDictionaryRef *)timebase + 37), timer, runloop);
      goto LABEL_17;
    }
LABEL_18:
    v15 = 4294954546;
    goto LABEL_19;
  }
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)timebase + 37), timer);
  if (!FigCFEqual(Value, runloop))
  {
    v15 = 4294954547;
LABEL_19:
    v4 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
LABEL_17:
  v4 = 0;
LABEL_20:
  FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  return v4;
}

BOOL cfDataFigTimeEqual(const __CFData *a1, const __CFData *a2)
{
  const UInt8 *BytePtr;
  const UInt8 *v4;
  __int128 v5;
  __int128 v6;
  CMTime v8;
  CMTime time1;

  BytePtr = CFDataGetBytePtr(a1);
  v4 = CFDataGetBytePtr(a2);
  v5 = *(_OWORD *)BytePtr;
  time1.epoch = *((_QWORD *)BytePtr + 2);
  *(_OWORD *)&time1.value = v5;
  v6 = *(_OWORD *)v4;
  v8.epoch = *((_QWORD *)v4 + 2);
  *(_OWORD *)&v8.value = v6;
  return CMTimeCompare(&time1, &v8) == 0;
}

CFStringRef cfDataFigTimeCopyDescription(const __CFData *a1)
{
  const UInt8 *BytePtr;
  const __CFAllocator *v3;
  __int128 v4;
  CMTime v6;

  BytePtr = CFDataGetBytePtr(a1);
  v3 = CFGetAllocator(a1);
  v4 = *(_OWORD *)BytePtr;
  v6.epoch = *((_QWORD *)BytePtr + 2);
  *(_OWORD *)&v6.value = v4;
  return CMTimeCopyDescription(v3, &v6);
}

OSStatus CMTimebaseRemoveTimer(CMTimebaseRef timebase, CFRunLoopTimerRef timer)
{
  OSStatus v2;
  const __CFDictionary *v5;

  v2 = -12748;
  if (timebase && timer)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    v5 = (const __CFDictionary *)*((_QWORD *)timebase + 35);
    if (v5 && CFDictionaryContainsKey(v5, timer))
    {
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 35), timer);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 36), timer);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 37), timer);
      CFRunLoopTimerSetNextFireDate(timer, 8073216000.0);
      v2 = 0;
    }
    else
    {
      v2 = FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  }
  return v2;
}

OSStatus CMTimebaseSetTimerNextFireTime(CMTimebaseRef timebase, CFRunLoopTimerRef timer, CMTime *fireTime, uint32_t flags)
{
  OSStatus v4;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  __CFRunLoop *Value;
  __CFRunLoop *v12;
  const __CFAllocator *v13;
  CFDataRef v14;
  CFDataRef v15;
  uint64_t v16;
  CMTime v18;
  CMTime v19;

  v4 = -12748;
  if (timebase && timer)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    v9 = (const __CFDictionary *)*((_QWORD *)timebase + 35);
    if (v9 && CFDictionaryContainsKey(v9, timer))
    {
      if (CFRunLoopTimerIsValid(timer))
      {
        v10 = (const __CFDictionary *)*((_QWORD *)timebase + 37);
        if (v10)
        {
          Value = (__CFRunLoop *)CFDictionaryGetValue(v10, timer);
          if (Value)
          {
            v12 = Value;
            v13 = CFGetAllocator(timebase);
            v14 = CFDataCreate(v13, (const UInt8 *)fireTime, 24);
            if (v14)
            {
              v15 = v14;
              CFDictionaryReplaceValue(*((CFMutableDictionaryRef *)timebase + 35), timer, v14);
              CFRelease(v15);
              CFDictionarySetValue(*((CFMutableDictionaryRef *)timebase + 36), timer, (const void *)flags);
              figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)timebase, 1, 0, &v19);
              v18 = *fireTime;
              rescheduleTimer(timer, v12, &v18, timebase, &v19, 2, flags);
              v4 = 0;
LABEL_13:
              FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
              return v4;
            }
            v16 = 4294954546;
LABEL_12:
            v4 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
            goto LABEL_13;
          }
        }
      }
      else
      {
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 35), timer);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 36), timer);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 37), timer);
      }
    }
    v16 = 4294954547;
    goto LABEL_12;
  }
  return v4;
}

OSStatus CMTimebaseSetTimerToFireImmediately(CMTimebaseRef timebase, CFRunLoopTimerRef timer)
{
  OSStatus v2;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  __CFRunLoop *Value;
  __CFRunLoop *v8;
  CFAbsoluteTime Current;

  v2 = -12748;
  if (timebase && timer)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    v5 = (const __CFDictionary *)*((_QWORD *)timebase + 35);
    if (v5 && CFDictionaryContainsKey(v5, timer))
    {
      if (CFRunLoopTimerIsValid(timer))
      {
        v6 = (const __CFDictionary *)*((_QWORD *)timebase + 37);
        if (v6)
        {
          Value = (__CFRunLoop *)CFDictionaryGetValue(v6, timer);
          if (Value)
          {
            v8 = Value;
            CFDictionaryReplaceValue(*((CFMutableDictionaryRef *)timebase + 35), timer, (const void *)*MEMORY[0x1E0C9AE40]);
            Current = CFAbsoluteTimeGetCurrent();
            CFRunLoopTimerSetNextFireDate(timer, Current);
            CFRunLoopWakeUp(v8);
            v2 = 0;
LABEL_11:
            FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
            return v2;
          }
        }
      }
      else
      {
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 35), timer);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 36), timer);
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 37), timer);
      }
    }
    v2 = FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  return v2;
}

dispatch_object_t cfDispatchSourceRetain(int a1, dispatch_object_t object)
{
  dispatch_retain(object);
  return object;
}

void cfDispatchSourceRelease(int a1, dispatch_object_t object)
{
  dispatch_release(object);
}

OSStatus CMTimebaseRemoveTimerDispatchSource(CMTimebaseRef timebase, dispatch_source_t timerSource)
{
  OSStatus v2;
  const __CFDictionary *v5;

  v2 = -12748;
  if (timebase && timerSource)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    v5 = (const __CFDictionary *)*((_QWORD *)timebase + 38);
    if (v5 && CFDictionaryContainsKey(v5, timerSource))
    {
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 38), timerSource);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 39), timerSource);
      dispatch_source_set_timer(timerSource, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
      v2 = 0;
    }
    else
    {
      v2 = -12749;
    }
    FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  }
  return v2;
}

void rescheduleTimerSource(NSObject *a1, CMTime *a2, OpaqueCMTimebase *a3, CMTime *a4, int a5, char a6)
{
  double EffectiveRate;
  dispatch_time_t v13;
  double v14;
  int timescale;
  CMTimeValue value;
  CMClockRef HostTimeClock;
  OpaqueCMClock *v18;
  BOOL v19;
  CMTimeValue v20;
  uint64_t v21;
  uint64_t v22;
  CMTime v23;
  CMTime time1;
  CMTime time;
  CMTime v26;
  CMTime v27;

  memset(&v27, 0, sizeof(v27));
  memset(&v26, 0, sizeof(v26));
  if (!dispatch_source_testcancel(a1))
  {
    if ((a2->flags & 0x1D) != 1)
      goto LABEL_5;
    if (a2->timescale < 1)
      goto LABEL_5;
    EffectiveRate = CMTimebaseGetEffectiveRate(a3);
    if (EffectiveRate == 0.0)
      goto LABEL_5;
    v14 = EffectiveRate;
    timescale = a2->timescale;
    if (timescale <= 1023)
    {
      do
      {
        value = a2->value;
        if ((unint64_t)(a2->value + 0x3FFFFFFFFFFFFFFFLL) > 0x7FFFFFFFFFFFFFFDLL)
          break;
        memset(&time, 0, sizeof(time));
        CMTimeMake(&time, 2 * value, 2 * timescale);
        *a2 = time;
        timescale = a2->timescale;
      }
      while (timescale < 1024);
    }
    HostTimeClock = CMClockGetHostTimeClock();
    time = *a2;
    CMSyncConvertTime(&v27, &time, a3, HostTimeClock);
    memset(&time, 0, sizeof(time));
    v18 = CMClockGetHostTimeClock();
    CMClockGetTime(&time, v18);
    v19 = 0;
    if (v14 <= 0.0 || (time1 = *a2, v23 = *a4, (CMTimeCompare(&time1, &v23) & 0x80000000) == 0))
    {
      if (v14 >= 0.0 || (time1 = *a2, v23 = *a4, CMTimeCompare(&time1, &v23) < 1))
        v19 = 1;
    }
    time1 = v27;
    v23 = time;
    CMTimeSubtract(&v26, &time1, &v23);
    v23 = v26;
    CMTimeConvertScale(&time1, &v23, 1000000000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    v20 = time1.value;
    if ((~time1.flags & 9) != 0)
      v21 = 0;
    else
      v21 = -1;
    if ((~time1.flags & 5) != 0)
      v22 = v21;
    else
      v22 = 8073216000000000000;
    if ((time1.flags & 0x1D) != 1)
      v20 = v22;
    if (v19)
    {
LABEL_30:
      v13 = dispatch_time(0, v20 & ~(v20 >> 63));
      goto LABEL_6;
    }
    if ((a6 & 1) != 0)
      goto LABEL_29;
    if (!a5)
    {
LABEL_5:
      v13 = -1;
LABEL_6:
      dispatch_source_set_timer(a1, v13, 0x7009D32DA3000000uLL, 0);
      return;
    }
    if (a5 != 1)
    {
LABEL_29:
      v20 = 0;
      goto LABEL_30;
    }
  }
}

OSStatus CMTimebaseSetTimerDispatchSourceToFireImmediately(CMTimebaseRef timebase, dispatch_source_t timerSource)
{
  OSStatus v2;
  const __CFDictionary *v5;
  intptr_t v6;
  __CFDictionary *v7;

  v2 = -12748;
  if (timebase && timerSource)
  {
    FigReentrantMutexLock(*((pthread_mutex_t **)timebase + 14));
    v5 = (const __CFDictionary *)*((_QWORD *)timebase + 38);
    if (v5 && CFDictionaryContainsKey(v5, timerSource))
    {
      v6 = dispatch_source_testcancel(timerSource);
      v7 = (__CFDictionary *)*((_QWORD *)timebase + 38);
      if (!v6)
      {
        CFDictionaryReplaceValue(v7, timerSource, (const void *)*MEMORY[0x1E0C9AE40]);
        dispatch_source_set_timer(timerSource, 0, 0x7009D32DA3000000uLL, 0);
        v2 = 0;
        goto LABEL_8;
      }
      CFDictionaryRemoveValue(v7, timerSource);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)timebase + 39), timerSource);
    }
    v2 = FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
LABEL_8:
    FigReentrantMutexUnlock(*((pthread_mutex_t **)timebase + 14));
  }
  return v2;
}

OSStatus CMTimebaseNotificationBarrier(CMTimebaseRef timebase)
{
  CFNotificationCenterRef DefaultLocalCenter;

  if (!timebase)
    return -12748;
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return CMNotificationCenterBarrier((uint64_t)DefaultLocalCenter, (uint64_t)timebase);
}

pthread_mutex_t **CMTimebaseGetTimeClampedAboveAnchorTime@<X0>(pthread_mutex_t **result@<X0>, char *a2@<X1>, CMTime *a3@<X8>)
{
  pthread_mutex_t **v5;
  char v6;
  char v7;

  *(_OWORD *)&a3->value = *(_OWORD *)&kCMTimeInvalid.value;
  a3->epoch = 0;
  v7 = 0;
  if (!result)
  {
    v6 = 0;
    if (!a2)
      return result;
    goto LABEL_5;
  }
  v5 = result;
  FigReentrantMutexLock(result[14]);
  figTimebaseGetAnchorTimebaseTimeIfClamped(v5, &v7, (uint64_t)a3);
  v6 = v7;
  if (!v7)
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(v5, 1, 0, a3);
  result = (pthread_mutex_t **)FigReentrantMutexUnlock(v5[14]);
  if (a2)
LABEL_5:
    *a2 = v6;
  return result;
}

void figTimebaseGetAnchorTimebaseTimeIfClamped(pthread_mutex_t **a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  pthread_mutex_t *v6;
  CMClockOrTimebaseRef v7;
  const void *v8;
  double v9;
  char v10;
  CMTime v11;
  CMTime time1;
  CMTime outRelativeToClockOrTimebaseAnchorTime;
  CMTime outOfClockOrTimebaseAnchorTime;
  CMTime v15;
  Float64 v16;
  Float64 outRelativeRate;

  *(_OWORD *)a3 = *(_OWORD *)&kCMTimeInvalid.value;
  *(_QWORD *)(a3 + 16) = 0;
  v6 = FigTimebaseCopyUltimateMasterClockAndHeight(a1, 0);
  v7 = CMTimebaseCopySource((CMTimebaseRef)a1);
  v8 = v7;
  if (v6 && v7)
  {
    v16 = 0.0;
    outRelativeRate = 0.0;
    memset(&outOfClockOrTimebaseAnchorTime, 0, sizeof(outOfClockOrTimebaseAnchorTime));
    memset(&outRelativeToClockOrTimebaseAnchorTime, 0, sizeof(outRelativeToClockOrTimebaseAnchorTime));
    CMSyncGetRelativeRateAndAnchorTime(a1, v6, &outRelativeRate, 0, 0);
    CMSyncGetRelativeRateAndAnchorTime(a1, v8, 0, &outOfClockOrTimebaseAnchorTime, &outRelativeToClockOrTimebaseAnchorTime);
    CMSyncGetRelativeRateAndAnchorTime(v8, v6, &v16, 0, 0);
    CMSyncGetTime(&v15, v8);
    if (outRelativeRate == 0.0)
    {
LABEL_9:
      v10 = 0;
LABEL_15:
      *a2 = v10;
      goto LABEL_16;
    }
    v9 = v16;
    if (v16 > 0.0)
    {
      time1 = outRelativeToClockOrTimebaseAnchorTime;
      v11 = v15;
      if (CMTimeCompare(&time1, &v11) > 0)
        goto LABEL_14;
      v9 = v16;
    }
    if (v9 >= 0.0)
      goto LABEL_9;
    time1 = outRelativeToClockOrTimebaseAnchorTime;
    v11 = v15;
    if ((CMTimeCompare(&time1, &v11) & 0x80000000) == 0)
      goto LABEL_9;
LABEL_14:
    *(CMTime *)a3 = outOfClockOrTimebaseAnchorTime;
    v10 = 1;
    goto LABEL_15;
  }
  *a2 = 0;
  if (!v6)
  {
    if (!v7)
      return;
    goto LABEL_12;
  }
LABEL_16:
  CFRelease(v6);
  if (!v8)
    return;
LABEL_12:
  CFRelease(v8);
}

__CFString *ftbCopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const __CFAllocator *v4;
  CFStringRef v5;
  Float64 Seconds;
  const char *v7;
  int v8;
  const char *v9;
  uint64_t v10;
  CFIndex v11;
  CFAllocatorRef v12;
  uint64_t v13;
  const char *v14;
  Float64 Rate;
  CMTime time;
  CMTime v18;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness((pthread_mutex_t **)a1, 1, 0, &v18);
  v4 = CFGetAllocator((CFTypeRef)a1);
  time = v18;
  v5 = CMTimeCopyDescription(v4, &time);
  time = v18;
  Seconds = CMTimeGetSeconds(&time);
  v7 = "(UNKNOWN TYPE)";
  v8 = *(_DWORD *)(a1 + 16);
  if (v8 == 1)
    v7 = "(Looping)";
  if (v8 == 2)
    v7 = "(ReadOnly)";
  if (v8)
    v9 = v7;
  else
    v9 = "";
  v10 = *(_QWORD *)(a1 + 24);
  v11 = CFGetRetainCount((CFTypeRef)a1);
  v12 = CFGetAllocator((CFTypeRef)a1);
  v13 = *(_QWORD *)(a1 + 128);
  if (v13)
    v14 = "clock";
  else
    v14 = "timebase";
  if (!v13)
    v13 = *(_QWORD *)(a1 + 136);
  Rate = CMTimebaseGetRate((CMTimebaseRef)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigTimebase: %p %s targetTimebase: %p retainCount: %d allocator: %p master %s: %p rate: %f time: %@ = %f seconds\n"), a1, v9, v10, v11, v12, v14, v13, *(_QWORD *)&Rate, v5, *(_QWORD *)&Seconds);
  if (v5)
    CFRelease(v5);
  return Mutable;
}

uint64_t figTimebaseReflectNotification(int a1, uint64_t a2, const __CFString *cf1, uint64_t a4, const void *a5)
{
  int v9;
  uint64_t result;
  int v11;
  CFTypeID v12;
  const __CFDictionary *Value;
  double EffectiveRate;
  int v15;
  int v16;
  BOOL v17;
  int v19;
  CMTime v20;
  CMTime v21;

  v9 = FigCFEqual(cf1, CFSTR("CMTimebaseTimeJumped"));
  result = FigCFEqual(cf1, CFSTR("CMTimebaseTimeAdjusted"));
  if (a2)
  {
    v11 = result;
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
    if (*(_QWORD *)(a2 + 24) == a4)
    {
      if (v9 | v11 || FigCFEqual(cf1, CFSTR("CMTimebaseEffectiveRateChanged")))
      {
        memset(&v20, 0, sizeof(v20));
        if (a5)
        {
          v12 = CFGetTypeID(a5);
          if (v12 == CFDictionaryGetTypeID())
          {
            Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a5, CFSTR("CMTimebaseEventTime"));
            CMTimeMakeFromDictionary(&v20, Value);
          }
        }
        if ((v20.flags & 1) == 0)
        {
          figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(*(pthread_mutex_t ***)(a2 + 24), 1, 0, &v21);
          v20 = v21;
        }
        v21 = v20;
        EffectiveRate = CMTimebaseGetEffectiveRate((CMTimebaseRef)a2);
        v15 = *(_DWORD *)(a2 + 320);
        if (EffectiveRate > 0.0)
          v16 = 1;
        else
          v16 = -1;
        if (EffectiveRate == 0.0)
          v16 = *(_DWORD *)(a2 + 320);
        *(_DWORD *)(a2 + 320) = v16;
        if (v11)
          v17 = 1;
        else
          v17 = v15 == v16;
        v19 = v17 && v9 == 0;
        if (*(_QWORD *)(a2 + 280))
        {
          v20 = v21;
          rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a2, &v20, v19);
        }
        if (*(_QWORD *)(a2 + 304))
        {
          v20 = v21;
          rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a2, &v20, v19);
        }
      }
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
      return figTimebasePostNotification((_QWORD *)a2, cf1, a5);
    }
    else
    {
      return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
    }
  }
  return result;
}

void figTimebaseTimeJumpedNotificationCallback(int a1, uint64_t a2, const __CFString *cf1, uint64_t a4, const void *a5)
{
  int v9;
  int v10;
  const __CFAllocator *v11;
  CFDictionaryRef v12;
  CMTime v13;
  CMTime v14;

  memset(&v14, 0, sizeof(v14));
  v9 = FigCFEqual(cf1, CFSTR("CMTimebaseTimeJumped"));
  if (!a2)
  {
    FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
    return;
  }
  v10 = v9;
  FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
  if (*(_QWORD *)(a2 + 136) != a4)
  {
    FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
LABEL_6:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
    return;
  }
  figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(a5, a2, &v14);
  if (*(double *)(a2 + 184) == 0.0)
    goto LABEL_6;
  if (*(_QWORD *)(a2 + 280))
  {
    v13 = v14;
    rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a2, &v13, v10 == 0);
  }
  if (*(_QWORD *)(a2 + 304))
  {
    v13 = v14;
    rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a2, &v13, v10 == 0);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
  v11 = CFGetAllocator((CFTypeRef)a2);
  v13 = v14;
  v12 = figTimebaseCreatePayloadForNotificationAtTime(v11, &v13);
  figTimebasePostNotification((_QWORD *)a2, cf1, v12);
  if (v12)
    CFRelease(v12);
}

void figTimebaseMasterDidChangeNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  const void *v8;
  const void *UltimateMasterClock;
  const __CFAllocator *v10;
  CFDictionaryRef v11;
  CMTime v12;
  CMTime v13;

  memset(&v13, 0, sizeof(v13));
  if (a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
    if (*(_QWORD *)(a2 + 136) == a4)
    {
      figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(a5, a2, &v13);
      v8 = *(const void **)(a2 + 144);
      if (v8)
        CFRelease(v8);
      UltimateMasterClock = (const void *)figTimebaseFindUltimateMasterClock((pthread_mutex_t **)a2, (uint64_t *)(a2 + 152));
      if (UltimateMasterClock)
        UltimateMasterClock = CFRetain(UltimateMasterClock);
      *(_QWORD *)(a2 + 144) = UltimateMasterClock;
      v10 = CFGetAllocator((CFTypeRef)a2);
      v12 = v13;
      v11 = figTimebaseCreatePayloadForNotificationAtTime(v10, &v12);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
      figTimebasePostNotification((_QWORD *)a2, CFSTR("CMTimebaseMasterDidChange"), v11);
      if (v11)
        CFRelease(v11);
    }
    else
    {
      FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
    }
  }
  else
  {
    FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
}

void figTimebaseMasterWillChangeNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  const __CFAllocator *v8;
  CFDictionaryRef v9;
  CMTime v10;
  CMTime v11;

  memset(&v11, 0, sizeof(v11));
  if (a2)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 112));
    if (*(_QWORD *)(a2 + 136) == a4)
    {
      figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(a5, a2, &v11);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
      v8 = CFGetAllocator((CFTypeRef)a2);
      v10 = v11;
      v9 = figTimebaseCreatePayloadForNotificationAtTime(v8, &v10);
      figTimebasePostNotification((_QWORD *)a2, CFSTR("CMTimebaseMasterWillChange"), v9);
      if (v9)
        CFRelease(v9);
    }
    else
    {
      FigSignalErrorAt(4294954547, 0, 0, 0, 0, 0, 0);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 112));
    }
  }
  else
  {
    FigSignalErrorAt(4294954548, 0, 0, 0, 0, 0, 0);
  }
}

void figTimebaseGetTimeFromNotificationPayloadOrMasterTimebase(CFTypeRef cf@<X1>, uint64_t a2@<X0>, CMTime *a3@<X8>)
{
  CMTimeFlags flags;
  CMTimeEpoch epoch;
  CFTypeID v8;
  const __CFDictionary *Value;
  CMTime v10;
  CMTimeValue v11;
  CMTimeScale timescale;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  flags = 0;
  timescale = 0;
  epoch = 0;
  if (cf)
  {
    v8 = CFGetTypeID(cf);
    if (v8 == CFDictionaryGetTypeID())
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("CMTimebaseEventTime"));
      CMTimeMakeFromDictionary(&v10, Value);
      v11 = v10.value;
      flags = v10.flags;
      timescale = v10.timescale;
      epoch = v10.epoch;
    }
  }
  if ((flags & 1) == 0)
  {
    figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(*(pthread_mutex_t ***)(a2 + 136), 1, 0, &v10);
    v11 = v10.value;
    flags = v10.flags;
    timescale = v10.timescale;
    epoch = v10.epoch;
  }
  v10.value = v11;
  v10.timescale = timescale;
  v10.flags = flags;
  v10.epoch = epoch;
  figTimebaseGetTimeAtMasterTime((pthread_mutex_t **)a2, &v10, a3);
}

void figTimebaseGetTimeAtMasterTime(pthread_mutex_t **a1@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  pthread_mutex_t **v5;
  __int128 v6;
  CMTime v7;

  *(_OWORD *)&a3->value = *(_OWORD *)&kCMTimeInvalid.value;
  a3->epoch = 0;
  if (a1)
  {
    v5 = figTimebaseCopyTargetTimebase(a1);
    FigReentrantMutexLock(v5[14]);
    if (CMTimebaseGetRate((CMTimebaseRef)v5) == 0.0)
    {
      v6 = *((_OWORD *)v5 + 12);
      a3->epoch = (CMTimeEpoch)v5[26];
      *(_OWORD *)&a3->value = v6;
    }
    else
    {
      v7 = *a2;
      FigSyncApplyTransform(&v7, (uint64_t)(v5 + 20), a3);
    }
    a3->flags &= ~2u;
    FigReentrantMutexUnlock(v5[14]);
    CFRelease(v5);
  }
  else
  {
    a3->flags &= ~2u;
  }
}

uint64_t figTimebaseSetAnchorTimeMaybeNowMaybeNotifying(uint64_t a1, CMTime *a2, CMTime *a3, int a4, int a5)
{
  uint64_t result;
  __int128 v11;
  __int128 v12;
  int v13;
  const __CFAllocator *v14;
  CFDictionaryRef v15;
  CMTime v16;
  CMTime time1;
  CMTime v18;

  memset(&v18, 0, sizeof(v18));
  if (!a1)
    return 4294954548;
  result = figTimebaseVerifyReadWrite(a1);
  if (!(_DWORD)result)
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 112));
    if (*(double *)(a1 + 184) == 0.0
      && (figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(&time1, a1, 0, 0),
          v16 = *a2,
          !CMTimeCompare(&time1, &v16)))
    {
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    }
    else
    {
      if (a4)
      {
        figTimebaseGetMasterTime(&v16, a1);
        *a3 = v16;
        v18 = *a2;
      }
      v11 = *(_OWORD *)&a3->value;
      *(_QWORD *)(a1 + 176) = a3->epoch;
      *(_OWORD *)(a1 + 160) = v11;
      v12 = *(_OWORD *)&a2->value;
      *(_QWORD *)(a1 + 208) = a2->epoch;
      *(_OWORD *)(a1 + 192) = v12;
      *(_BYTE *)(a1 + 216) = 0;
      if (*(double *)(a1 + 184) != 0.0)
      {
        FigSyncInvertTransform(a1 + 160, a1 + 224);
        if (!v13)
          *(_BYTE *)(a1 + 216) = 1;
      }
      if (!a4)
        figTimebaseGetTime_MaybeUpdatingAnchorTimeFromLoopiness(&v18, a1, 0, 0);
      if (*(_QWORD *)(a1 + 280))
      {
        v16 = v18;
        rescheduleValidAndRemoveInvalidTimers((CFDictionaryRef *)a1, &v16, 0);
      }
      if (*(_QWORD *)(a1 + 304))
      {
        v16 = v18;
        rescheduleValidAndRemoveCancelledTimerSources((CFDictionaryRef *)a1, &v16, 0);
      }
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      if (a5 == 1)
      {
        v14 = CFGetAllocator((CFTypeRef)a1);
        v16 = v18;
        v15 = figTimebaseCreatePayloadForNotificationAtTime(v14, &v16);
        figTimebasePostNotification((_QWORD *)a1, CFSTR("CMTimebaseTimeJumped"), v15);
        if (v15)
          CFRelease(v15);
      }
    }
    return 0;
  }
  return result;
}

CMTime *__cdecl CMTimeMake(CMTime *__return_ptr retstr, CMTime *value, int32_t timescale)
{
  retstr->value = (CMTimeValue)value;
  retstr->timescale = timescale;
  retstr->flags = 1;
  retstr->epoch = 0;
  if (timescale <= 0)
  {
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
  }
  return value;
}

CMTime *__cdecl CMTimeMakeWithEpoch(CMTime *__return_ptr retstr, CMTime *value, int32_t timescale, int64_t epoch)
{
  retstr->value = (CMTimeValue)value;
  retstr->timescale = timescale;
  retstr->flags = 1;
  retstr->epoch = epoch;
  if (timescale <= 0)
  {
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
  }
  return value;
}

CMTime *__cdecl CMTimeMakeWithSeconds(CMTime *__return_ptr retstr, Float64 seconds, int32_t preferredTimescale)
{
  double v3;
  int32_t v4;
  BOOL v5;
  int32_t v6;
  BOOL v7;
  const CMTime *v8;
  CMTimeValue v9;
  double v10;
  CMTime *result;

  retstr->value = 0;
  *(_QWORD *)&retstr->timescale = 0;
  retstr->epoch = 0;
  if (preferredTimescale < 1)
    goto LABEL_32;
  retstr->timescale = preferredTimescale;
  retstr->flags = 1;
  if (seconds == 0.0)
    goto LABEL_32;
  v3 = -((double)preferredTimescale * seconds);
  if (seconds >= 0.0)
    v3 = (double)preferredTimescale * seconds;
  if (v3 <= 9.22337204e18)
  {
    v6 = preferredTimescale;
  }
  else
  {
    v4 = preferredTimescale >> 1;
    v5 = preferredTimescale < 2;
    if (preferredTimescale >= 2)
    {
      while (1)
      {
        v3 = -((double)v4 * seconds);
        if (seconds >= 0.0)
          v3 = (double)v4 * seconds;
        if (v3 <= 9.22337204e18)
          break;
        v6 = v4 >> 1;
        v7 = v4 >= 2;
        v5 = v4 < 2;
        v4 >>= 1;
        if (!v7)
          goto LABEL_14;
      }
    }
    v6 = v4;
LABEL_14:
    retstr->timescale = v6;
    if (v5)
    {
      retstr->epoch = 0;
      if (seconds >= 0.0)
        v8 = &kCMTimePositiveInfinity;
      else
        v8 = &kCMTimeNegativeInfinity;
      *(_OWORD *)&retstr->value = *(_OWORD *)&v8->value;
      goto LABEL_32;
    }
  }
  v9 = (uint64_t)v3;
  if (v3 == 9.22337204e18)
    v9 = 0x7FFFFFFFFFFFFFFFLL;
  if (seconds < 0.0)
    v9 = -v9;
  retstr->value = v9;
  v10 = (double)v9 / (double)v6 - seconds;
  if (v10 != 0.0)
  {
    retstr->flags = 3;
    if (preferredTimescale <= 100
      && (v10 > 0.01 || v10 < -0.01)
      && fabs(v10) < 1.0
      && CMTimeMakeWithSeconds_onlyThisManyTimes >= 1)
    {
      --CMTimeMakeWithSeconds_onlyThisManyTimes;
      *(_QWORD *)&preferredTimescale = CFLog();
    }
  }
LABEL_32:
  LODWORD(result) = preferredTimescale;
  return result;
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  CMTimeFlags flags;

  flags = time->flags;
  if ((flags & 0x11) == 1)
  {
    if ((flags & 4) != 0)
      return INFINITY;
    if ((flags & 8) != 0)
      return -INFINITY;
    if ((flags & 0x1D) == 1)
      return (double)time->value / (double)time->timescale;
  }
  return NAN;
}

CMTime *__cdecl CMTimeConvertScale(CMTime *__return_ptr retstr, CMTime *time, int32_t newTimescale, CMTimeRoundingMethod method)
{
  CMTime *v4;
  uint64_t timescale;
  const CMTime *v9;
  CMTimeEpoch epoch;
  int v11;
  int v12;
  CMTimeValue v13;
  int v14;

  v4 = time;
  v14 = 0;
  if ((time->flags & 0x1D) != 1)
    goto LABEL_4;
  if (newTimescale <= 0)
  {
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
    return time;
  }
  timescale = time->timescale;
  if ((_DWORD)timescale == newTimescale)
  {
LABEL_4:
    *retstr = *time;
    return time;
  }
  time = (CMTime *)FigInt64MulDiv(time->value, newTimescale, time->timescale, &v14);
  if (time == (CMTime *)0x7FFFFFFFFFFFFFFFLL)
  {
    retstr->epoch = 0;
    v9 = &kCMTimePositiveInfinity;
    goto LABEL_10;
  }
  if (time == (CMTime *)0x8000000000000000)
  {
    retstr->epoch = 0;
    v9 = &kCMTimeNegativeInfinity;
LABEL_10:
    *(_OWORD *)&retstr->value = *(_OWORD *)&v9->value;
    return time;
  }
  epoch = v4->epoch;
  retstr->value = (CMTimeValue)time;
  retstr->epoch = epoch;
  LODWORD(epoch) = v4->flags & 2 | 1;
  retstr->timescale = newTimescale;
  retstr->flags = epoch;
  v11 = v14;
  if (v14)
  {
    retstr->flags = 3;
    switch(method)
    {
      case kCMTimeRoundingMethod_RoundHalfAwayFromZero:
        if (v11 >= 0)
          v12 = v11;
        else
          v12 = -v11;
        if ((2 * v12) >= timescale)
          goto LABEL_20;
        return time;
      case kCMTimeRoundingMethod_RoundAwayFromZero:
        goto LABEL_20;
      case kCMTimeRoundingMethod_QuickTime:
        if ((int)timescale < newTimescale)
        {
LABEL_20:
          if (v11 < 0)
LABEL_25:
            v13 = (CMTimeValue)&time[-1].epoch + 7;
          else
LABEL_23:
            v13 = (CMTimeValue)&time->value + 1;
          goto LABEL_26;
        }
        if (!time && v4->value < 0)
        {
          v13 = -1;
LABEL_26:
          retstr->value = v13;
          return time;
        }
        break;
      case kCMTimeRoundingMethod_RoundTowardPositiveInfinity:
        if ((v11 & 0x80000000) == 0)
          goto LABEL_23;
        return time;
      case kCMTimeRoundingMethod_RoundTowardNegativeInfinity:
        if (v11 < 0)
          goto LABEL_25;
        return time;
      default:
        return time;
    }
  }
  return time;
}

CMTime *__cdecl CMTimeAdd(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  CMTimeFlags flags;
  CMTimeFlags v6;
  char v7;
  CMTime *v8;
  CMTimeEpoch epoch;
  CMTimeEpoch v10;
  CMTimeScale v11;
  CMTimeScale v12;
  int32_t v13;
  uint64_t v14;
  CMTimeScale v15;
  CMTimeScale v16;
  _BYTE *value;
  CMTimeFlags v18;
  CMTimeValue v19;
  CMTimeFlags v20;
  int v21;
  BOOL v22;
  CMTimeValue v23;
  const CMTime *v24;
  CMTimeScale timescale;
  CMTimeFlags v26;
  CMTime v27;
  CMTime v28;

  retstr->value = 0;
  *(_QWORD *)&retstr->timescale = 0;
  retstr->epoch = 0;
  flags = lhs->flags;
  if ((flags & 1) == 0)
    goto LABEL_66;
  v6 = rhs->flags;
  if ((v6 & 1) == 0)
    goto LABEL_66;
  if ((flags & 4) != 0)
  {
    if ((v6 & 8) == 0)
      goto LABEL_54;
    goto LABEL_66;
  }
  if ((flags & 8) != 0)
  {
    if ((v6 & 4) != 0)
      goto LABEL_66;
LABEL_56:
    retstr->epoch = 0;
    v24 = &kCMTimeNegativeInfinity;
    goto LABEL_57;
  }
  if ((v6 & 4) != 0)
    goto LABEL_54;
  if ((v6 & 8) != 0)
    goto LABEL_56;
  v7 = v6 | flags;
  if ((v7 & 0x10) != 0)
  {
    retstr->epoch = 0;
    v24 = &kCMTimeIndefinite;
    goto LABEL_57;
  }
  v8 = lhs;
  epoch = lhs->epoch;
  v10 = rhs->epoch;
  if (epoch)
  {
    if (!v10 || epoch == v10)
    {
      if (epoch == v10)
        v10 = 0;
      else
        v10 = lhs->epoch;
      goto LABEL_14;
    }
LABEL_66:
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
    return lhs;
  }
LABEL_14:
  if (!lhs->value)
  {
    retstr->value = rhs->value;
    timescale = rhs->timescale;
    goto LABEL_61;
  }
  if (!rhs->value)
  {
    retstr->value = lhs->value;
    timescale = lhs->timescale;
LABEL_61:
    retstr->epoch = v10;
    v26 = v7 & 2 | 1;
    retstr->timescale = timescale;
LABEL_62:
    retstr->flags = v26;
    return lhs;
  }
  v11 = lhs->timescale;
  v12 = rhs->timescale;
  v13 = v11;
  if (v11 != v12)
  {
    v14 = v12;
    v15 = 1;
    if (v11 != -1 && v12 != -1)
    {
      v15 = lhs->timescale;
      if (v12)
      {
        v16 = lhs->timescale;
        do
        {
          v15 = v12;
          v12 = v16 % v12;
          v16 = v15;
        }
        while (v12);
      }
    }
    if (v14 / v15 * v11 <= 0x7FFFFFFF)
      v13 = v14 / v15 * v11;
    else
      v13 = 1000000000;
  }
  while (1)
  {
    if (v13 == v11)
    {
      value = (_BYTE *)v8->value;
      v18 = v8->flags;
    }
    else
    {
      v27 = *v8;
      lhs = CMTimeConvertScale(&v28, &v27, v13, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      v18 = v28.flags;
      if ((v28.flags & 1) == 0)
        goto LABEL_66;
      value = (_BYTE *)v28.value;
      if ((v28.flags & 4) != 0)
      {
        if (v13 >= 2)
          goto LABEL_52;
      }
      else if (v13 >= 2 && (v28.flags & 8) != 0)
      {
        goto LABEL_52;
      }
    }
    if (v13 == rhs->timescale)
    {
      v19 = rhs->value;
      v20 = rhs->flags;
    }
    else
    {
      v27 = *rhs;
      lhs = CMTimeConvertScale(&v28, &v27, v13, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      v20 = v28.flags;
      if ((v28.flags & 1) == 0)
        goto LABEL_66;
      v19 = v28.value;
      if ((v28.flags & 4) != 0)
      {
        if (v13 > 1)
          goto LABEL_52;
      }
      else if (v13 >= 2 && (v28.flags & 8) != 0)
      {
        goto LABEL_52;
      }
    }
    if ((~v18 & 5) == 0)
    {
      if ((~v20 & 9) != 0)
        goto LABEL_54;
      goto LABEL_66;
    }
    v21 = v20 & 5;
    if ((~v18 & 9) == 0)
    {
      if (v21 != 5)
        goto LABEL_56;
      goto LABEL_66;
    }
    if (v21 == 5)
      goto LABEL_54;
    if ((~v20 & 9) == 0)
      goto LABEL_56;
    if ((v18 & 0x1D) != 1 || (v20 & 0x1D) != 1)
      goto LABEL_66;
    v22 = __OFADD__(value, v19);
    v23 = (CMTimeValue)&value[v19];
    if (!v22)
    {
      retstr->value = v23;
      retstr->epoch = v10;
      v26 = (v20 | v18) & 2 | 1;
      retstr->timescale = v13;
      goto LABEL_62;
    }
    if (v13 <= 1)
      break;
LABEL_52:
    v13 = v13 >> 1;
    v11 = v8->timescale;
  }
  if ((v23 & 0x8000000000000000) == 0)
    goto LABEL_56;
LABEL_54:
  retstr->epoch = 0;
  v24 = &kCMTimePositiveInfinity;
LABEL_57:
  *(_OWORD *)&retstr->value = *(_OWORD *)&v24->value;
  return lhs;
}

CMTime *__cdecl CMTimeSubtract(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  CMTimeFlags flags;
  CMTimeFlags v6;
  char v7;
  CMTime *v8;
  CMTimeEpoch epoch;
  CMTimeEpoch v10;
  CMTimeFlags v11;
  const CMTime *v12;
  CMTimeScale timescale;
  CMTimeScale v14;
  CMTimeScale v15;
  int32_t v16;
  uint64_t v17;
  CMTimeScale v18;
  CMTimeScale v19;
  _BYTE *value;
  CMTimeFlags v21;
  CMTimeValue v22;
  CMTimeFlags v23;
  BOOL v24;
  CMTimeValue v25;
  CMTime v26;
  CMTime v27;

  retstr->value = 0;
  *(_QWORD *)&retstr->timescale = 0;
  retstr->epoch = 0;
  flags = lhs->flags;
  if ((flags & 1) == 0)
    goto LABEL_66;
  v6 = rhs->flags;
  if ((v6 & 1) == 0)
    goto LABEL_66;
  if ((flags & 4) != 0)
  {
    if ((v6 & 4) == 0)
      goto LABEL_19;
    goto LABEL_66;
  }
  if ((flags & 8) != 0)
  {
    if ((v6 & 8) != 0)
      goto LABEL_66;
LABEL_21:
    retstr->epoch = 0;
    v12 = &kCMTimeNegativeInfinity;
    goto LABEL_22;
  }
  if ((v6 & 4) != 0)
    goto LABEL_21;
  if ((v6 & 8) != 0)
    goto LABEL_19;
  v7 = v6 | flags;
  if ((v7 & 0x10) != 0)
  {
    retstr->epoch = 0;
    v12 = &kCMTimeIndefinite;
    goto LABEL_22;
  }
  v8 = lhs;
  epoch = lhs->epoch;
  v10 = rhs->epoch;
  if (!epoch)
    goto LABEL_14;
  if (v10 && epoch != v10)
  {
LABEL_66:
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
    return lhs;
  }
  if (epoch == v10)
    v10 = 0;
  else
    v10 = lhs->epoch;
LABEL_14:
  if (!rhs->value)
  {
    retstr->value = lhs->value;
    timescale = lhs->timescale;
    retstr->epoch = v10;
    v11 = v7 & 2 | 1;
    retstr->timescale = timescale;
    goto LABEL_25;
  }
  if (rhs->value != 0x8000000000000000 && !lhs->value)
  {
    *(_OWORD *)&retstr->value = *(_OWORD *)&rhs->value;
    retstr->value = -retstr->value;
    retstr->epoch = v10;
    v11 = v7 & 2 | 1;
LABEL_25:
    retstr->flags = v11;
    return lhs;
  }
  v14 = lhs->timescale;
  v15 = rhs->timescale;
  v16 = v14;
  if (v14 != v15)
  {
    v17 = v15;
    v18 = 1;
    if (v14 != -1 && v15 != -1)
    {
      v18 = lhs->timescale;
      if (v15)
      {
        v19 = lhs->timescale;
        do
        {
          v18 = v15;
          v15 = v19 % v15;
          v19 = v18;
        }
        while (v15);
      }
    }
    if (v17 / v18 * v14 <= 0x7FFFFFFF)
      v16 = v17 / v18 * v14;
    else
      v16 = 1000000000;
  }
  while (1)
  {
    if (v16 == v14)
    {
      value = (_BYTE *)v8->value;
      v21 = v8->flags;
    }
    else
    {
      v26 = *v8;
      lhs = CMTimeConvertScale(&v27, &v26, v16, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      v21 = v27.flags;
      if ((v27.flags & 1) == 0)
        goto LABEL_66;
      value = (_BYTE *)v27.value;
      if ((v27.flags & 4) != 0)
      {
        if (v16 >= 2)
          goto LABEL_62;
      }
      else if (v16 >= 2 && (v27.flags & 8) != 0)
      {
        goto LABEL_62;
      }
    }
    if (v16 == rhs->timescale)
    {
      v22 = rhs->value;
      v23 = rhs->flags;
    }
    else
    {
      v26 = *rhs;
      lhs = CMTimeConvertScale(&v27, &v26, v16, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      v23 = v27.flags;
      if ((v27.flags & 1) == 0)
        goto LABEL_66;
      v22 = v27.value;
      if ((v27.flags & 4) != 0)
      {
        if (v16 > 1)
          goto LABEL_62;
      }
      else if (v16 >= 2 && (v27.flags & 8) != 0)
      {
        goto LABEL_62;
      }
    }
    if ((~v21 & 5) == 0)
    {
      if ((~v23 & 5) != 0)
        goto LABEL_19;
      goto LABEL_66;
    }
    if ((~v21 & 9) == 0)
    {
      if ((~v23 & 9) != 0)
        goto LABEL_21;
      goto LABEL_66;
    }
    if ((~v23 & 5) == 0)
      goto LABEL_21;
    if ((~v23 & 9) == 0)
      goto LABEL_19;
    if ((v21 & 0x1D) != 1 || (v23 & 0x1D) != 1)
      goto LABEL_66;
    v24 = __OFSUB__(value, v22);
    v25 = (CMTimeValue)&value[-v22];
    if (!v24)
    {
      retstr->value = v25;
      retstr->epoch = v10;
      v11 = (v23 | v21) & 2 | 1;
      retstr->timescale = v16;
      goto LABEL_25;
    }
    if (v16 <= 1)
      break;
LABEL_62:
    v16 = v16 >> 1;
    v14 = v8->timescale;
  }
  if ((v25 & 0x8000000000000000) == 0)
    goto LABEL_21;
LABEL_19:
  retstr->epoch = 0;
  v12 = &kCMTimePositiveInfinity;
LABEL_22:
  *(_OWORD *)&retstr->value = *(_OWORD *)&v12->value;
  return lhs;
}

CMTime *__cdecl CMTimeMultiply(CMTime *__return_ptr retstr, CMTime *time, int32_t multiplier)
{
  CMTimeFlags flags;
  CMTime *v6;
  CMTimeEpoch epoch;
  CMTimeScale timescale;
  int32_t v9;
  _BYTE *value;
  CMTimeFlags v11;
  const CMTime *v12;
  CMTime v13;
  CMTime v14;

  flags = time->flags;
  if ((flags & 1) == 0)
  {
LABEL_2:
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
    return time;
  }
  if ((flags & 0x10) == 0)
  {
    if ((flags & 4) != 0)
    {
LABEL_17:
      if (multiplier < 0)
        goto LABEL_20;
    }
    else
    {
      if ((flags & 8) == 0)
      {
        v6 = time;
        epoch = time->epoch;
        timescale = time->timescale;
        v9 = timescale;
        while (1)
        {
          if (v9 == timescale)
          {
            value = (_BYTE *)v6->value;
            v11 = v6->flags;
          }
          else
          {
            v13 = *v6;
            time = CMTimeConvertScale(&v14, &v13, v9, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
            LOBYTE(v11) = v14.flags;
            if ((v14.flags & 1) == 0)
              goto LABEL_2;
            if ((v14.flags & 4) != 0)
              goto LABEL_17;
            if ((v14.flags & 8) != 0)
              goto LABEL_19;
            value = (_BYTE *)v14.value;
          }
          time = (CMTime *)FigInt64MulDiv((int64_t)value, multiplier, 1, 0);
          if ((unint64_t)&time[0xFAAAAAAAAAAAAAABLL] - 7 > 1)
          {
            retstr->value = (CMTimeValue)time;
            retstr->epoch = epoch;
            retstr->timescale = v9;
            retstr->flags = v11 & 2 | 1;
            return time;
          }
          if (v9 < 2)
            break;
          v9 = v9 >> 1;
          timescale = v6->timescale;
        }
        if (((unint64_t)time & 0x8000000000000000) != 0)
          goto LABEL_20;
        goto LABEL_18;
      }
LABEL_19:
      if ((multiplier & 0x80000000) == 0)
      {
LABEL_20:
        retstr->epoch = 0;
        v12 = &kCMTimeNegativeInfinity;
        goto LABEL_21;
      }
    }
LABEL_18:
    retstr->epoch = 0;
    v12 = &kCMTimePositiveInfinity;
    goto LABEL_21;
  }
  retstr->epoch = 0;
  v12 = &kCMTimeIndefinite;
LABEL_21:
  *(_OWORD *)&retstr->value = *(_OWORD *)&v12->value;
  return time;
}

CMTime *__cdecl CMTimeMultiplyByFloat64(CMTime *__return_ptr retstr, CMTime *time, Float64 multiplier)
{
  CMTimeFlags flags;
  CMTime *v6;
  CMTimeEpoch epoch;
  CMTimeScale timescale;
  double v9;
  CMTimeScale v10;
  int32_t v11;
  _BYTE *value;
  CMTimeFlags v13;
  double v14;
  const CMTime *v16;
  double v17;
  CMTimeValue v18;
  CMTime v19;
  CMTime v20;

  retstr->value = 0;
  flags = time->flags;
  if ((flags & 1) == 0)
  {
LABEL_2:
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
    return time;
  }
  if ((flags & 0x10) != 0)
  {
    retstr->epoch = 0;
    v16 = &kCMTimeIndefinite;
    goto LABEL_34;
  }
  if ((flags & 4) != 0)
  {
LABEL_30:
    if (multiplier >= 0.0)
      goto LABEL_33;
LABEL_31:
    retstr->epoch = 0;
    v16 = &kCMTimeNegativeInfinity;
    goto LABEL_34;
  }
  if ((flags & 8) != 0)
  {
LABEL_32:
    if (multiplier < 0.0)
      goto LABEL_33;
    goto LABEL_31;
  }
  v6 = time;
  epoch = time->epoch;
  timescale = time->timescale;
  v9 = (double)(uint64_t)multiplier;
  if (timescale <= 1000000000)
    v10 = 1000000000;
  else
    v10 = time->timescale;
  if (v9 == multiplier)
    v11 = time->timescale;
  else
    v11 = v10;
  while (1)
  {
    if (v11 == timescale)
    {
      value = (_BYTE *)v6->value;
      v13 = v6->flags;
    }
    else
    {
      v19 = *v6;
      time = CMTimeConvertScale(&v20, &v19, v11, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      LOBYTE(v13) = v20.flags;
      if ((v20.flags & 1) == 0)
        goto LABEL_2;
      if ((v20.flags & 4) != 0)
      {
        if (v11 < 2)
          goto LABEL_30;
        goto LABEL_28;
      }
      if ((v20.flags & 8) != 0)
      {
        if (v11 <= 1)
          goto LABEL_32;
        goto LABEL_28;
      }
      value = (_BYTE *)v20.value;
    }
    v14 = (double)(uint64_t)value * multiplier;
    if (v14 <= 9.22337204e18 && v14 >= -9.22337204e18)
    {
      if (v14 >= 9.22337204e18)
      {
        v18 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else if (v14 <= -9.22337204e18)
      {
        v18 = 0x8000000000000000;
      }
      else
      {
        if (v14 >= 0.0)
          v17 = 0.5;
        else
          v17 = -0.5;
        v18 = (uint64_t)(v14 + v17);
      }
      retstr->value = v18;
      retstr->epoch = epoch;
      retstr->timescale = v11;
      retstr->flags = v13 & 2 | 1;
      if ((v13 & 2) == 0
        && ((unint64_t)(v18 - 0x8000000000001) <= 0xFFEFFFFFFFFFFFFELL || v11 <= 999999999
                                                                                && v14 != (double)v18))
      {
        retstr->flags = 3;
      }
      return time;
    }
    if (v11 <= 1)
      break;
LABEL_28:
    v11 = v11 >> 1;
    timescale = v6->timescale;
  }
  if (v14 < 0.0)
    goto LABEL_31;
LABEL_33:
  retstr->epoch = 0;
  v16 = &kCMTimePositiveInfinity;
LABEL_34:
  *(_OWORD *)&retstr->value = *(_OWORD *)&v16->value;
  return time;
}

uint64_t CMTimeDivide(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int v6;
  uint64_t v9;
  uint64_t v10;
  int32_t v11;
  int v12;
  int32_t v13;
  uint64_t v14;
  int v15;
  int v16;
  CMTimeValue value;
  int v18;
  int v19;
  CMTimeValue v20;
  uint64_t result;
  uint64_t v22;
  char v23;
  int v25;
  CMTime v26;
  CMTime v27;

  v4 = *(_DWORD *)(a1 + 12);
  if ((v4 & 1) == 0)
    goto LABEL_48;
  v6 = *(_DWORD *)(a2 + 12);
  if ((v6 & 1) == 0)
    goto LABEL_48;
  if ((*(_DWORD *)(a1 + 12) & 0x1D) != 1 || (*(_DWORD *)(a2 + 12) & 0x1D) != 1)
    goto LABEL_48;
  v9 = *(_QWORD *)(a1 + 16);
  v10 = *(_QWORD *)(a2 + 16);
  if (v9)
  {
    if (v10 && v9 != v10)
      goto LABEL_48;
  }
  else
  {
    v9 = *(_QWORD *)(a2 + 16);
  }
  if (!*(_QWORD *)a2)
    goto LABEL_48;
  if (!*(_QWORD *)a1)
  {
    result = 0;
    if (!a3)
      return result;
    v22 = 0;
    v13 = *(_DWORD *)(a1 + 8);
    v23 = v6 | v4;
    goto LABEL_54;
  }
  v11 = *(_DWORD *)(a1 + 8);
  v12 = *(_DWORD *)(a2 + 8);
  v13 = v11;
  if (v11 != v12)
  {
    v14 = v12;
    v15 = 1;
    if (v11 != -1 && v12 != -1)
    {
      v15 = *(_DWORD *)(a1 + 8);
      if (v12)
      {
        v16 = *(_DWORD *)(a1 + 8);
        do
        {
          v15 = v12;
          v12 = v16 % v12;
          v16 = v15;
        }
        while (v12);
      }
    }
    if (v14 / v15 * v11 <= 0x7FFFFFFF)
      v13 = v14 / v15 * v11;
    else
      v13 = 1000000000;
  }
  while (1)
  {
    if (v13 == v11)
    {
      value = *(_QWORD *)a1;
      v18 = *(_DWORD *)(a1 + 12);
    }
    else
    {
      v26 = *(CMTime *)a1;
      CMTimeConvertScale(&v27, &v26, v13, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      LOBYTE(v18) = v27.flags;
      if ((v27.flags & 1) == 0)
        goto LABEL_48;
      value = v27.value;
      if ((v27.flags & 4) != 0)
      {
        if (v13 >= 2)
          goto LABEL_40;
      }
      else if (v13 >= 2 && (v27.flags & 8) != 0)
      {
        goto LABEL_40;
      }
    }
    if (v13 == *(_DWORD *)(a2 + 8))
      break;
    v26 = *(CMTime *)a2;
    CMTimeConvertScale(&v27, &v26, v13, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
    LOBYTE(v19) = v27.flags;
    if ((v27.flags & 1) == 0)
      goto LABEL_48;
    v20 = v27.value;
    if ((v27.flags & 4) != 0)
    {
      if (v13 <= 1)
        goto LABEL_44;
    }
    else if (v13 < 2 || (v27.flags & 8) == 0)
    {
      goto LABEL_44;
    }
LABEL_40:
    v13 = v13 >> 1;
    v11 = *(_DWORD *)(a1 + 8);
  }
  v20 = *(_QWORD *)a2;
  v19 = *(_DWORD *)(a2 + 12);
LABEL_44:
  if ((v18 & 0x1D) != 1 || (v19 & 0x1D) != 1)
  {
LABEL_48:
    result = 0;
    if (a3)
    {
      v25 = 0;
      v13 = 0;
      v9 = 0;
      v22 = 0;
      goto LABEL_50;
    }
    return result;
  }
  result = value / v20;
  if (!a3)
    return result;
  v22 = value % v20;
  v23 = v19 | v18;
LABEL_54:
  v25 = v23 & 2 | 1;
LABEL_50:
  *(_QWORD *)a3 = v22;
  *(_DWORD *)(a3 + 8) = v13;
  *(_DWORD *)(a3 + 12) = v25;
  *(_QWORD *)(a3 + 16) = v9;
  return result;
}

uint64_t CMTimeRemainder@<X0>(__int128 *a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X8>)
{
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = *a1;
  v7 = *((_QWORD *)a1 + 2);
  v4 = *a2;
  v5 = *((_QWORD *)a2 + 2);
  return CMTimeDivide((uint64_t)&v6, (uint64_t)&v4, (uint64_t)a3);
}

CMTime *__cdecl CMTimeMultiplyByRatio(CMTime *__return_ptr retstr, CMTime *time, int32_t multiplier, int32_t divisor)
{
  int v5;
  CMTimeFlags flags;
  uint64_t v7;
  uint64_t v8;
  CMTime *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int64_t value;
  CMTimeScale timescale;
  uint64_t v15;
  uint64_t v16;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const CMTime *v28;
  CMTimeFlags v29;
  BOOL v30;
  uint64_t v31;
  CMTimeValue v32;
  uint64_t v33;
  int v34;
  CMTimeFlags v35;
  CMTimeEpoch epoch;
  CMTime timea;
  CMTime time1;
  int v39;

  v39 = 0;
  if (divisor >= 0)
    v5 = (multiplier >> 31) | 1;
  else
    v5 = -((multiplier >> 31) | 1);
  flags = time->flags;
  if ((flags & 1) == 0)
    goto LABEL_5;
  if ((flags & 0x10) != 0)
  {
    retstr->epoch = 0;
    v28 = &kCMTimeIndefinite;
    goto LABEL_73;
  }
  LODWORD(v7) = divisor;
  LODWORD(v8) = multiplier;
  v9 = time;
  if (!divisor)
  {
    time1 = *time;
    time = (CMTime *)CMTimeCompare(&time1, (CMTime *)&kCMTimeZero);
    if (!(_DWORD)v8 || !(_DWORD)time)
      goto LABEL_5;
    time1 = *v9;
    time = (CMTime *)CMTimeCompare(&time1, (CMTime *)&kCMTimeZero);
    if ((int)time >= 1)
      goto LABEL_68;
    time1 = *v9;
    time = (CMTime *)CMTimeCompare(&time1, (CMTime *)&kCMTimeZero);
    if ((time & 0x80000000) != 0)
    {
LABEL_71:
      if ((v5 & 0x80000000) == 0)
        goto LABEL_72;
      goto LABEL_69;
    }
  }
  if ((flags & 4) != 0)
  {
    if (!(_DWORD)v8)
      goto LABEL_5;
LABEL_68:
    if (v5 < 0)
      goto LABEL_72;
LABEL_69:
    retstr->epoch = 0;
    v28 = &kCMTimePositiveInfinity;
    goto LABEL_73;
  }
  if ((flags & 8) != 0)
  {
    if ((_DWORD)v8)
      goto LABEL_71;
LABEL_5:
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
    return time;
  }
  if ((_DWORD)v8 && (_DWORD)v7 && (_DWORD)v8 != -1 && (_DWORD)v7 != -1)
  {
    v10 = (int)v7;
    v11 = (int)v8;
    do
    {
      v12 = v11;
      v11 = v10;
      v10 = v12 % v10;
    }
    while (v10);
    if (v11 < 0)
      v11 = -v11;
    if (v11 != 1)
    {
      v8 = (int)v8 / v11;
      v7 = (int)v7 / v11;
    }
  }
  epoch = v9->epoch;
  value = v9->value;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        time = (CMTime *)FigInt64MulDiv(value, v8, 1, 0);
        timescale = v9->timescale;
        if (time)
          v15 = (int)v7;
        else
          v15 = 1;
        v16 = v15 * timescale;
        if ((unint64_t)&time[0xFAAAAAAAAAAAAAABLL] - 7 >= 2
          && v16 <= 0x7FFFFFFF
          && v16 > (uint64_t)0xFFFFFFFF80000000)
        {
          LOBYTE(v29) = 0;
          v30 = 1;
LABEL_89:
          if (v16 >= 0)
            v32 = (CMTimeValue)time;
          else
            v32 = -(uint64_t)time;
          retstr->value = v32;
          if (v16 >= 0)
            LODWORD(v33) = v16;
          else
            v33 = -v16;
          retstr->epoch = epoch;
          retstr->timescale = v33;
          retstr->flags = 1;
          if (v30)
          {
            if ((v29 & 1) != 0)
              v34 = v29 & 2;
            else
              v34 = v9->flags & 2;
            v35 = v34 | 1;
          }
          else
          {
            v35 = 3;
          }
          retstr->flags = v35;
          return time;
        }
        value = v9->value;
        if ((_DWORD)v7 == -1 || value == -1)
          break;
        v19 = v9->value;
        if ((_DWORD)v7)
        {
          v20 = (int)v7;
          v21 = v9->value;
          do
          {
            v19 = v20;
            v20 = v21 % v20;
            v21 = v19;
          }
          while (v20);
        }
        if (v19 < 0)
          v19 = -v19;
        if (v19 == 1)
          break;
        value /= v19;
        v9->value = value;
        v7 = (int)v7 / v19;
      }
      if ((_DWORD)v8 == -1 || timescale == -1)
        break;
      v22 = (int)v8;
      if (timescale)
      {
        v23 = timescale;
        v24 = (int)v8;
        do
        {
          v22 = v23;
          v23 = v24 % v23;
          v24 = v22;
        }
        while (v23);
      }
      if (v22 < 0)
        v22 = -v22;
      if (v22 == 1)
        break;
      v9->timescale = timescale / v22;
      v8 = (int)v8 / v22;
    }
    if (value == -1 || timescale == -1)
      break;
    if (timescale)
    {
      v25 = timescale;
      v26 = v9->value;
      do
      {
        v27 = v25;
        v25 = v26 % v25;
        v26 = v27;
      }
      while (v25);
    }
    else
    {
      v27 = v9->value;
    }
    if (v27 < 0)
      v27 = -v27;
    if (v27 == 1)
      break;
    value /= v27;
    v9->value = value;
    v9->timescale = timescale / v27;
  }
  v16 = 1000000000;
  while (1)
  {
    if (v16 == timescale)
    {
      time = (CMTime *)v9->value;
      v29 = v9->flags;
    }
    else
    {
      timea = *v9;
      time = CMTimeConvertScale(&time1, &timea, v16, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
      LOBYTE(v29) = time1.flags;
      if ((time1.flags & 1) == 0)
        goto LABEL_5;
      time = (CMTime *)time1.value;
      if ((time1.flags & 0xC) != 0)
      {
        if ((unint64_t)v16 >= 2)
          goto LABEL_84;
        if ((time1.flags & 4) != 0)
          goto LABEL_68;
        if ((time1.flags & 8) != 0)
          goto LABEL_71;
      }
    }
    time = (CMTime *)FigInt64MulDiv((int64_t)time, v8, v7, &v39);
    if ((unint64_t)&time[0xFAAAAAAAAAAAAAABLL] - 7 > 1)
    {
      v30 = v39 == 0;
      if ((int)v7 >= 0)
        v31 = (int)v7;
      else
        v31 = -(uint64_t)(int)v7;
      time = (CMTime *)((char *)time + 2 * v39 / v31);
      goto LABEL_89;
    }
    if ((unint64_t)v16 <= 1)
      break;
LABEL_84:
    v16 = (unint64_t)v16 >> 1;
    timescale = v9->timescale;
  }
  if (((unint64_t)time & 0x8000000000000000) == 0)
    goto LABEL_69;
LABEL_72:
  retstr->epoch = 0;
  v28 = &kCMTimeNegativeInfinity;
LABEL_73:
  *(_OWORD *)&retstr->value = *(_OWORD *)&v28->value;
  return time;
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  CMTimeFlags flags;
  CMTimeFlags v4;
  int32_t result;
  CMTimeEpoch epoch;
  CMTimeEpoch v7;
  CMTimeScale timescale;
  CMTimeValue value;
  CMTimeValue v10;
  int32_t v11;

  flags = time1->flags;
  v4 = time2->flags;
  result = v4 & 1;
  if ((flags & 1) != 0)
  {
    if ((v4 & 1) == 0)
      return -1;
    if ((flags & 4) != 0)
    {
      return ((v4 >> 2) & 1) == 0;
    }
    else
    {
      if ((v4 & 4) != 0)
        return -1;
      if ((flags & 0x10) != 0)
      {
        return ((v4 >> 4) & 1) == 0;
      }
      else
      {
        if ((v4 & 0x10) != 0)
          return -1;
        if ((flags & 8) != 0)
        {
          return ((v4 >> 3) & 1) - 1;
        }
        else
        {
          if ((v4 & 8) != 0)
            return 1;
          epoch = time1->epoch;
          v7 = time2->epoch;
          if (epoch > v7)
          {
            return 1;
          }
          else
          {
            if (epoch < v7)
              return -1;
            timescale = time1->timescale;
            value = time1->value;
            v10 = time2->value;
            if (timescale == time2->timescale)
            {
              if (value >= v10)
                v11 = 0;
              else
                v11 = -1;
              if (value > v10)
                return 1;
              else
                return v11;
            }
            else
            {
              return multiplyAndCompare96(value, time2->timescale, v10, timescale);
            }
          }
        }
      }
    }
  }
  return result;
}

CMTime *CMTimeMultiplyTimeByTimeRatio@<X0>(CMTime *result@<X0>, uint64_t a2@<X1>, CMTime *a3@<X2>, uint64_t a4@<X8>)
{
  CMTime *v7;
  uint64_t v8;
  uint64_t value;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t timescale;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int32_t v28;
  int32_t v29;
  int32_t v30;
  CMTimeFlags v31;
  CMTimeEpoch epoch;
  int v33;
  CMTimeFlags flags;
  double v35;
  unint64_t v36;
  double v37;
  unint64_t v38;
  double v39;
  CMTime v40;
  CMTime time1;
  CMTimeValue v42;
  CMTimeScale v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if ((result->flags & 0x1D) != 1
    || (*(_DWORD *)(a2 + 12) & 0x1D) != 1
    || (a3->flags & 0x1D) != 1
    || (v7 = result, time1 = *a3, result = (CMTime *)CMTimeCompare(&time1, (CMTime *)&kCMTimeZero), !(_DWORD)result))
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
    return result;
  }
  v8 = *(_QWORD *)a2;
  if (*(_QWORD *)a2 == (int)*(_QWORD *)a2)
  {
    value = a3->value;
  }
  else
  {
    v10 = *(int *)(a2 + 8);
    if ((_DWORD)v10)
    {
      v11 = *(int *)(a2 + 8);
      v12 = *(_QWORD *)a2;
      do
      {
        v13 = v12;
        v12 = v11;
        v11 = v13 % v11;
      }
      while (v11);
      if (v12 >= 0)
        v14 = v12;
      else
        v14 = -v12;
      v15 = *(_QWORD *)a2;
      if (v14 != 1)
      {
        v15 = v8 / v14;
        *(_QWORD *)a2 = v8 / v14;
        *(_DWORD *)(a2 + 8) = v10 / v14;
      }
    }
    else
    {
      v15 = *(_QWORD *)a2;
    }
    value = a3->value;
    if (v15 && value)
    {
      v16 = a3->value;
      v17 = v15;
      do
      {
        v18 = v17;
        v17 = v16;
        v16 = v18 % v16;
      }
      while (v16);
      if (v17 < 0)
        v17 = -v17;
      if (v17 != 1)
      {
        *(_QWORD *)a2 = v15 / v17;
        value = a3->value / v17;
        a3->value = value;
      }
    }
  }
  if (value != (int)value)
  {
    v19 = v8 + 0x80000000;
    timescale = a3->timescale;
    if ((_DWORD)timescale)
    {
      v21 = a3->timescale;
      v22 = value;
      do
      {
        v23 = v22;
        v22 = v21;
        v21 = v23 % v21;
      }
      while (v21);
      if (v22 < 0)
        v22 = -v22;
      if (v22 != 1)
      {
        value /= v22;
        a3->value = value;
        a3->timescale = timescale / v22;
      }
    }
    if (!HIDWORD(v19) && *(_QWORD *)a2 && value)
    {
      v24 = value;
      v25 = *(_QWORD *)a2;
      do
      {
        v26 = v25;
        v25 = v24;
        v24 = v26 % v24;
      }
      while (v24);
      if (v25 < 0)
        v25 = -v25;
      if (v25 != 1)
      {
        *(uint64_t *)a2 /= v25;
        value = a3->value / v25;
        a3->value = value;
      }
    }
  }
  v27 = *(_QWORD *)a2;
  if (*(_QWORD *)a2 != (int)*(_QWORD *)a2 || (unint64_t)(value + 0x80000000) >> 32)
  {
LABEL_47:
    v33 = *(_DWORD *)(a2 + 12);
    flags = a3->flags;
    if ((v33 & 0x11) == 1)
    {
      if ((v33 & 4) != 0)
      {
        v36 = 0x7FF0000000000000;
        goto LABEL_55;
      }
      if ((v33 & 8) != 0)
      {
        v36 = 0xFFF0000000000000;
        goto LABEL_55;
      }
      if ((v33 & 0x1D) == 1)
      {
        v35 = (double)v27 / (double)*(int *)(a2 + 8);
        goto LABEL_56;
      }
    }
    v36 = 0x7FF8000000000000;
LABEL_55:
    v35 = *(double *)&v36;
LABEL_56:
    if ((a3->flags & 0x11) == 1)
    {
      if ((flags & 4) != 0)
      {
        v38 = 0x7FF0000000000000;
        goto LABEL_64;
      }
      if ((flags & 8) != 0)
      {
        v38 = 0xFFF0000000000000;
        goto LABEL_64;
      }
      if ((a3->flags & 0x1D) == 1)
      {
        v37 = (double)value / (double)a3->timescale;
        goto LABEL_65;
      }
    }
    v38 = 0x7FF8000000000000;
LABEL_64:
    v37 = *(double *)&v38;
LABEL_65:
    v40 = *v7;
    v39 = v35 / v37;
    result = CMTimeMultiplyByFloat64(&time1, &v40, v35 / v37);
    v42 = time1.value;
    v31 = time1.flags;
    v43 = time1.timescale;
    epoch = time1.epoch;
    if (v39 != (double)(uint64_t)v39)
      v31 = time1.flags | 2;
    goto LABEL_67;
  }
  v28 = *(_DWORD *)(a2 + 8);
  v40 = *v7;
  CMTimeMultiplyByRatio(&time1, &v40, v27, v28);
  v43 = time1.timescale;
  v42 = time1.value;
  v29 = a3->timescale;
  v30 = a3->value;
  v40 = time1;
  result = CMTimeMultiplyByRatio(&time1, &v40, v29, v30);
  v42 = time1.value;
  v31 = time1.flags;
  v43 = time1.timescale;
  if ((time1.flags & 2) != 0)
  {
    v27 = *(_QWORD *)a2;
    value = a3->value;
    goto LABEL_47;
  }
  epoch = time1.epoch;
LABEL_67:
  *(_QWORD *)a4 = v42;
  *(_DWORD *)(a4 + 8) = v43;
  *(_DWORD *)(a4 + 12) = v31;
  *(_QWORD *)(a4 + 16) = epoch;
  return result;
}

uint64_t multiplyAndCompare96(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  BOOL v16;

  if ((unint64_t)a1 >> 63 == (unint64_t)a3 >> 63)
  {
    if (a1 >= 0)
      v4 = a1;
    else
      v4 = -a1;
    if (a3 >= 0)
      v5 = a3;
    else
      v5 = -a3;
    v6 = HIDWORD(v4);
    v7 = v4 * (unint64_t)a2;
    v8 = HIDWORD(v7) + v6 * (unint64_t)a2;
    v9 = HIDWORD(v5);
    v10 = v5 * (unint64_t)a4;
    v11 = HIDWORD(v10) + v9 * (unint64_t)a4;
    v12 = v8 > v11;
    if (v8 >= v11)
      v13 = 0;
    else
      v13 = -1;
    if (v12)
      v13 = 1;
    v14 = v7 > (unint64_t)v10;
    if (v7 >= (unint64_t)v10)
      v15 = 0;
    else
      v15 = -1;
    if (v14)
      v15 = 1;
    if (v13)
      v15 = v13;
    if (v15)
      v16 = a1 < 0;
    else
      v16 = 0;
  }
  else
  {
    v16 = a1 < 0;
    v15 = 1;
  }
  if (v16)
    return -v15;
  else
    return v15;
}

CMTime *__cdecl CMTimeMinimum(CMTime *__return_ptr retstr, CMTime *time1, CMTime *time2)
{
  CMTime *result;
  CMTime *v7;
  CMTime v8;
  CMTime time1a;

  time1a = *time1;
  v8 = *time2;
  result = (CMTime *)CMTimeCompare(&time1a, &v8);
  if ((int)result >= 0)
    v7 = time2;
  else
    v7 = time1;
  *(_OWORD *)&retstr->value = *(_OWORD *)&v7->value;
  retstr->epoch = v7->epoch;
  return result;
}

CMTime *__cdecl CMTimeMaximum(CMTime *__return_ptr retstr, CMTime *time1, CMTime *time2)
{
  CMTime *result;
  CMTime *v7;
  CMTime v8;
  CMTime time1a;

  time1a = *time1;
  v8 = *time2;
  result = (CMTime *)CMTimeCompare(&time1a, &v8);
  if ((int)result >= 0)
    v7 = time1;
  else
    v7 = time2;
  *(_OWORD *)&retstr->value = *(_OWORD *)&v7->value;
  retstr->epoch = v7->epoch;
  return result;
}

CMTime *__cdecl CMTimeAbsoluteValue(CMTime *__return_ptr retstr, CMTime *time)
{
  if ((~time->flags & 9) != 0)
  {
    if (time->value < 0)
      time->value = -time->value;
  }
  else
  {
    time->epoch = 0;
    *(_OWORD *)&time->value = *(_OWORD *)&kCMTimePositiveInfinity.value;
  }
  *retstr = *time;
  return time;
}

CFDictionaryRef CMTimeCopyAsDictionary(CMTime *time, CFAllocatorRef allocator)
{
  const __CFAllocator *v4;
  const __CFDictionary *v5;
  uint64_t i;
  const void *v7;
  const void *v9[4];
  void *keys[2];
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)keys = xmmword_1E28D9E90;
  v11 = *(_OWORD *)off_1E28D9EA0;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, time);
  v9[1] = CFNumberCreate(v4, kCFNumberSInt32Type, &time->timescale);
  v9[2] = CFNumberCreate(v4, kCFNumberSInt64Type, &time->epoch);
  v9[3] = CFNumberCreate(v4, kCFNumberSInt32Type, &time->flags);
  v5 = CFDictionaryCreate(allocator, (const void **)keys, v9, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  for (i = 0; i != 4; ++i)
  {
    v7 = v9[i];
    if (v7)
      CFRelease(v7);
  }
  return v5;
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CMTime *dictionaryRepresentation)
{
  CMTime *v3;
  CMTime *TypeID;
  const void *Value;
  const void *v6;
  const void *v7;
  CMTime *v8;
  CMTime *v9;
  CMTime *v10;
  CMTime *v11;
  CMTime *v12;

  retstr->value = 0;
  *(_QWORD *)&retstr->timescale = 0;
  retstr->epoch = 0;
  if (!dictionaryRepresentation)
    goto LABEL_15;
  v3 = dictionaryRepresentation;
  TypeID = (CMTime *)CFDictionaryGetTypeID();
  dictionaryRepresentation = (CMTime *)CFGetTypeID(v3);
  if (TypeID != dictionaryRepresentation)
    goto LABEL_15;
  Value = CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("value"));
  v6 = CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("timescale"));
  v7 = CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("epoch"));
  dictionaryRepresentation = (CMTime *)CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("flags"));
  if (!Value)
    goto LABEL_15;
  v8 = dictionaryRepresentation;
  v9 = (CMTime *)CFGetTypeID(Value);
  dictionaryRepresentation = (CMTime *)CFNumberGetTypeID();
  if (v9 != dictionaryRepresentation)
    goto LABEL_15;
  if (!v6)
    goto LABEL_15;
  v10 = (CMTime *)CFGetTypeID(v6);
  dictionaryRepresentation = (CMTime *)CFNumberGetTypeID();
  if (v10 != dictionaryRepresentation)
    goto LABEL_15;
  if (!v7)
    goto LABEL_15;
  v11 = (CMTime *)CFGetTypeID(v7);
  dictionaryRepresentation = (CMTime *)CFNumberGetTypeID();
  if (v11 != dictionaryRepresentation
    || !v8
    || (v12 = (CMTime *)CFGetTypeID(v8),
        dictionaryRepresentation = (CMTime *)CFNumberGetTypeID(),
        v12 != dictionaryRepresentation)
    || (dictionaryRepresentation = (CMTime *)CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt64Type, retstr),
        !(_DWORD)dictionaryRepresentation)
    || (dictionaryRepresentation = (CMTime *)CFNumberGetValue((CFNumberRef)v6, kCFNumberSInt32Type, &retstr->timescale),
        !(_DWORD)dictionaryRepresentation)
    || (dictionaryRepresentation = (CMTime *)CFNumberGetValue((CFNumberRef)v7, kCFNumberSInt64Type, &retstr->epoch),
        !(_DWORD)dictionaryRepresentation)
    || (dictionaryRepresentation = (CMTime *)CFNumberGetValue((CFNumberRef)v8, kCFNumberSInt32Type, &retstr->flags),
        !(_DWORD)dictionaryRepresentation))
  {
LABEL_15:
    retstr->value = 0;
    *(_QWORD *)&retstr->timescale = 0;
    retstr->epoch = 0;
  }
  return dictionaryRepresentation;
}

CFDictionaryRef CMTimeCopyAsCVBufferTimeDictionary(_DWORD *valuePtr, const __CFAllocator *a2)
{
  void *v4;
  const __CFAllocator *v5;
  CFDictionaryRef v6;
  uint64_t v7;
  char v8;
  char v9;
  const void *v10;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  if ((valuePtr[3] & 0x1D) != 1)
    return 0;
  v4 = (void *)*MEMORY[0x1E0CA8C70];
  keys[0] = *(void **)MEMORY[0x1E0CA8C78];
  keys[1] = v4;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, valuePtr);
  values[1] = CFNumberCreate(v5, kCFNumberSInt32Type, valuePtr + 2);
  v6 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = 0;
  v8 = 1;
  do
  {
    v9 = v8;
    v10 = values[v7];
    if (v10)
      CFRelease(v10);
    v8 = 0;
    v7 = 1;
  }
  while ((v9 & 1) != 0);
  return v6;
}

CFTypeID CMTimeMakeFromCVBufferTimeDictionary@<X0>(CFTypeID result@<X0>, _QWORD *a2@<X8>)
{
  const void *v3;
  CFTypeID TypeID;
  const __CFNumber *Value;
  BOOL v6;
  const __CFNumber *v7;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (!result)
    goto LABEL_10;
  v3 = (const void *)result;
  TypeID = CFDictionaryGetTypeID();
  result = CFGetTypeID(v3);
  if (TypeID != result)
    goto LABEL_10;
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v3, (const void *)*MEMORY[0x1E0CA8C78]);
  result = (CFTypeID)CFDictionaryGetValue((CFDictionaryRef)v3, (const void *)*MEMORY[0x1E0CA8C70]);
  v6 = !Value || result == 0;
  if (!v6
    && (v7 = (const __CFNumber *)result, result = CFNumberGetValue(Value, kCFNumberSInt64Type, a2), (_DWORD)result)
    && (result = CFNumberGetValue(v7, kCFNumberSInt32Type, a2 + 1), (_DWORD)result))
  {
    *((_DWORD *)a2 + 3) = 1;
  }
  else
  {
LABEL_10:
    *a2 = 0;
    a2[1] = 0;
  }
  a2[2] = 0;
  return result;
}

CFStringRef CMTimeCopyDescription(CFAllocatorRef allocator, CMTime *time)
{
  __CFString *Mutable;
  __CFString *v4;
  CMTimeFlags flags;
  CMTimeValue value;
  uint64_t timescale;
  double v8;
  uint64_t v9;

  Mutable = CFStringCreateMutable(allocator, 0);
  v4 = Mutable;
  if (Mutable)
  {
    flags = time->flags;
    if ((flags & 1) != 0)
    {
      if ((flags & 0x10) != 0)
      {
        CFStringAppendFormat(Mutable, 0, CFSTR("{INDEFINITE}"));
      }
      else if ((flags & 4) != 0)
      {
        CFStringAppendFormat(Mutable, 0, CFSTR("{+INFINITY}"));
      }
      else if ((flags & 8) != 0)
      {
        CFStringAppendFormat(Mutable, 0, CFSTR("{-INFINITY}"));
      }
      else if ((time->flags & 0x1D) == 1)
      {
        value = time->value;
        timescale = time->timescale;
        if ((time->flags & 0x11) == 1)
          v8 = (double)value / (double)(int)timescale;
        else
          v8 = NAN;
        CFStringAppendFormat(Mutable, 0, CFSTR("{%lld/%d = %1.3f"), value, timescale, *(_QWORD *)&v8);
        if (time->epoch)
          CFStringAppendFormat(v4, 0, CFSTR(", epoch=%lld"), time->epoch);
        v9 = time->flags;
        if ((time->flags & 0x1F) == 3)
        {
          CFStringAppendFormat(v4, 0, CFSTR(", rounded"));
          v9 = time->flags;
        }
        if (v9 >= 4)
          CFStringAppendFormat(v4, 0, CFSTR(", flags=0x%08x"), v9);
        CFStringAppendFormat(v4, 0, CFSTR("}"));
      }
      else
      {
        CFStringAppendFormat(Mutable, 0, CFSTR("{UNKNOWN}"));
      }
    }
    else
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("{INVALID}"));
    }
  }
  return v4;
}

void CMTimeShow(CMTime *time)
{
  const __CFAllocator *v1;
  const __CFString *v2;
  const __CFString *v3;
  _BYTE timea[32];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(CMTime *)timea = *time;
  v2 = CMTimeCopyDescription(v1, (CMTime *)timea);
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  memset(timea, 0, sizeof(timea));
  if (v2)
  {
    v3 = v2;
    if (CFStringGetCString(v2, timea, 512, 0))
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", timea);
    CFRelease(v3);
  }
}

uint64_t FigPerformanceMonitorGetClassID()
{
  FigThreadRunOnce(&FigPerformanceMonitorGetClassID_sRegisterFigPerformanceMonitorBaseTypeOnce, (void (*)(void))RegisterFigPerformanceMonitorBaseType);
  return sFigPerformanceMonitorClassID;
}

uint64_t RegisterFigPerformanceMonitorBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigPerformanceMonitorClassDesc, ClassID, 1, &sFigPerformanceMonitorClassID);
}

uint64_t FigPerformanceMonitorUpdateOSTransactionData(const void *a1, const char *a2, const char *a3, int a4)
{
  pid_t v8;
  const __CFAllocator *v9;
  CFStringRef v10;
  __CFString *v11;
  _BOOL4 v12;
  uint64_t DerivedStorage;
  CFTypeRef v14;
  CFStringRef v15;
  NSObject *v16;
  uint64_t v17;
  _QWORD v19[9];
  int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  int v28;
  _OWORD buffer[2];
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  v26 = &v25;
  v27 = 0x2020000000;
  v28 = 0;
  v21 = 0;
  v22 = &v21;
  v23 = 0x2020000000;
  v24 = 0;
  v30 = 0;
  memset(buffer, 0, sizeof(buffer));
  v8 = getpid();
  if (proc_name(v8, buffer, 0x21u) >= 1)
  {
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v10 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)buffer, 0x8000100u);
    if (v10)
    {
      v11 = FigRemote_ShouldConnectToMediaplaybackd() ? CFSTR("mediaplaybackd") : CFSTR("mediaserverd");
      v12 = FigCFEqual(v10, v11)
         && !FigGetCFPreferenceBooleanWithDefault(CFSTR("DisableFigPerfMonitor"), CFSTR("com.apple.coremedia"), 0)&& FigDebugIsInternalBuild() != 0;
      CFRelease(v10);
      if (v12)
      {
        if (FigPerformanceMonitorGetGlobal_onceToken != -1)
          dispatch_once_f(&FigPerformanceMonitorGetGlobal_onceToken, 0, (dispatch_function_t)fpm_globalPerformanceMonitorInitOnce);
        if (gPerformanceMonitor)
        {
          DerivedStorage = CMBaseObjectGetDerivedStorage(gPerformanceMonitor);
          if (a1)
            v14 = CFRetain(a1);
          else
            v14 = 0;
          v22[3] = (uint64_t)v14;
          if (a2)
            a2 = (const char *)CFStringCreateWithCString(v9, a2, 0x8000100u);
          if (a3)
            v15 = CFStringCreateWithCString(v9, a3, 0x8000100u);
          else
            v15 = 0;
          v16 = *(NSObject **)(DerivedStorage + 8);
          v19[0] = MEMORY[0x1E0C809B0];
          v19[1] = 3221225472;
          v19[2] = __FigPerformanceMonitorUpdateOSTransactionData_block_invoke;
          v19[3] = &unk_1E28D9EB8;
          v19[4] = &v25;
          v19[5] = &v21;
          v19[6] = DerivedStorage;
          v19[7] = a2;
          v19[8] = v15;
          v20 = a4;
          dispatch_async(v16, v19);
        }
        else
        {
          *((_DWORD *)v26 + 6) = -19070;
        }
      }
    }
  }
  v17 = *((unsigned int *)v26 + 6);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(&v25, 8);
  return v17;
}

void sub_18ECC7A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

CFStringRef FigPerformanceMonitorCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigPerformanceMonitor %p]"), a1);
}

void fpm_globalPerformanceMonitorInitOnce()
{
  const __CFAllocator *v0;
  uint64_t DerivedStorage;
  uint64_t v2;
  dispatch_queue_t v3;
  NSObject *v4;
  CFTypeRef v5;
  const void *v6;
  dispatch_source_t v7;
  NSObject *v8;
  dispatch_time_t v9;
  void *v10;
  int v11;
  const __CFUUID *v12;
  const __CFUUID *v13;
  CFStringRef v14;
  pid_t v15;
  id v16;
  void *v17;
  uint64_t v18;
  void *v19;
  CFMutableArrayRef Mutable;
  CFMutableDictionaryRef v21;
  _QWORD v22[5];
  _QWORD v23[5];
  CFTypeRef v24;

  v24 = 0;
  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  FigThreadRunOnce(&FigPerformanceMonitorGetClassID_sRegisterFigPerformanceMonitorBaseTypeOnce, (void (*)(void))RegisterFigPerformanceMonitorBaseType);
  if (CMDerivedObjectCreate((uint64_t)v0, (uint64_t)&kFigPerformanceMonitor_VTable, (_QWORD *)sFigPerformanceMonitorClassID, &v24))goto LABEL_15;
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v24);
  if (!DerivedStorage)
    goto LABEL_15;
  v2 = DerivedStorage;
  v3 = dispatch_queue_create("com.apple.coremedia.figperfmonitor.state", 0);
  *(_QWORD *)(v2 + 8) = v3;
  if (!v3)
    goto LABEL_18;
  v4 = v3;
  v5 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v24);
  if (v5)
  {
    v6 = v5;
    v7 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v4);
    if (v7)
    {
      v8 = v7;
      v9 = dispatch_time(0, 30000000000);
      dispatch_source_set_timer(v8, v9, 0x6FC23AC00uLL, 0x3B9ACA00uLL);
      v10 = (void *)CFRetain(v6);
      dispatch_set_context(v8, v10);
      dispatch_source_set_event_handler_f(v8, (dispatch_function_t)fpm_timerCallback);
      dispatch_source_set_cancel_handler_f(v8, (dispatch_function_t)fpm_timerCancellationCallback);
      dispatch_resume(v8);
      v11 = 0;
      *(_QWORD *)v2 = v8;
    }
    else
    {
      v11 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v6);
    if (v11)
      goto LABEL_15;
  }
  else if (FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0))
  {
    goto LABEL_15;
  }
  v12 = CFUUIDCreate(v0);
  if (!v12)
  {
LABEL_18:
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
  v13 = v12;
  v14 = CFUUIDCreateString(v0, v12);
  *(_QWORD *)(v2 + 664) = v14;
  if (!v14)
    goto LABEL_19;
  v15 = getpid();
  *(_DWORD *)(v2 + 16) = v15;
  proc_name(v15, (void *)(v2 + 20), 0x21u);
  v16 = objc_alloc_init(MEMORY[0x1E0D1B458]);
  *(_QWORD *)(v2 + 584) = v16;
  if (!v16)
    goto LABEL_19;
  *(_DWORD *)(v2 + 56) = arc4random();
  v17 = (void *)MEMORY[0x193FFC34C]();
  v18 = MEMORY[0x1E0C809B0];
  v23[0] = MEMORY[0x1E0C809B0];
  v23[1] = 3221225472;
  v23[2] = __fpm_performanceMonitorCreate_block_invoke;
  v23[3] = &__block_descriptor_40_e5_v8__0l;
  v23[4] = v2;
  objc_msgSend(*(id *)(v2 + 584), "setScreenOnChangedHandler:", v23);
  v19 = *(void **)(v2 + 584);
  v22[0] = v18;
  v22[1] = 3221225472;
  v22[2] = __fpm_performanceMonitorCreate_block_invoke_3;
  v22[3] = &__block_descriptor_40_e5_v8__0l;
  v22[4] = v2;
  objc_msgSend(v19, "activateWithCompletion:", v22);
  objc_autoreleasePoolPop(v17);
  Mutable = CFArrayCreateMutable(v0, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(v2 + 64) = Mutable;
  if (!Mutable)
    goto LABEL_19;
  v21 = CFDictionaryCreateMutable(v0, 0, 0, MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v2 + 672) = v21;
  if (v21)
  {
    gPerformanceMonitor = (uint64_t)v24;
    v24 = 0;
  }
  else
  {
LABEL_19:
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  CFRelease(v13);
LABEL_15:
  if (v24)
    CFRelease(v24);
}

void __fpm_performanceMonitorCreate_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __fpm_performanceMonitorCreate_block_invoke_2;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v1;
  dispatch_async(v2, block);
}

uint64_t __fpm_performanceMonitorCreate_block_invoke_2(uint64_t a1)
{
  unint64_t UpTimeNanoseconds;
  uint64_t v3;
  uint64_t result;

  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v3 + 648) = UpTimeNanoseconds;
  result = objc_msgSend(*(id *)(v3 + 584), "screenOn");
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 640) = result;
  return result;
}

void __fpm_performanceMonitorCreate_block_invoke_3(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __fpm_performanceMonitorCreate_block_invoke_4;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v1;
  dispatch_async(v2, block);
}

uint64_t __fpm_performanceMonitorCreate_block_invoke_4(uint64_t a1)
{
  unint64_t UpTimeNanoseconds;
  uint64_t v3;
  uint64_t result;

  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v3 + 648) = UpTimeNanoseconds;
  result = objc_msgSend(*(id *)(v3 + 584), "screenOn");
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 640) = result;
  return result;
}

void fpm_finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v2;
  void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v2 = *(NSObject **)DerivedStorage;
  if (*(_QWORD *)DerivedStorage)
  {
    dispatch_source_cancel(v2);
    v2 = *(NSObject **)DerivedStorage;
  }
  dispatch_release(v2);
  v3 = (void *)MEMORY[0x193FFC34C]();

  objc_autoreleasePoolPop(v3);
  v4 = *(const void **)(DerivedStorage + 664);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(DerivedStorage + 64);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(DerivedStorage + 64) = 0;
  }
  v6 = *(const void **)(DerivedStorage + 632);
  if (v6)
    CFRelease(v6);
  v7 = *(NSObject **)(DerivedStorage + 8);
  if (v7)
  {
    dispatch_release(v7);
    *(_QWORD *)(DerivedStorage + 8) = 0;
  }
  v8 = *(const void **)(DerivedStorage + 672);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(DerivedStorage + 672) = 0;
  }
}

CFStringRef fpm_copyDebugDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigPerformanceMonitor %p]"), a1);
}

uint64_t fpm_setProperty(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD block[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  if (a1)
  {
    v1 = *(NSObject **)(CMBaseObjectGetDerivedStorage(a1) + 8);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __fpm_setProperty_block_invoke;
    block[3] = &unk_1E28D9708;
    block[4] = &v5;
    dispatch_sync(v1, block);
    v2 = *((unsigned int *)v6 + 6);
  }
  else
  {
    v2 = FigSignalErrorAt(4294948225, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v6 + 6) = v2;
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18ECC82FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __fpm_setProperty_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = FigSignalErrorAt(4294948224, 0, 0, 0, 0, 0, 0);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void fpm_timerCallback(id *a1)
{
  id *v1;
  uint64_t DerivedStorage;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  uint64_t v6;
  CFIndex v7;
  const __CFDictionary *ValueAtIndex;
  id *Value;
  id *v10;
  uint64_t v11;
  const void *v12;
  const void *v13;
  const __CFAllocator *v14;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v16;
  CFStringRef v17;
  unint64_t UpTimeNanoseconds;
  const __CFArray *v19;
  CFIndex v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  CFIndex i;
  const __CFArray *v24;
  const __CFDictionary *v25;
  const void *v26;
  uint64_t v27;
  int64_t v28;
  int v29;
  void (*v30)(uint64_t);
  int8x16_t v31;
  CFMutableDictionaryRef v32;
  CFMutableDictionaryRef v33;
  const void **v34;
  void *v35;
  CFMutableDictionaryRef v36;
  CFMutableDictionaryRef v37;
  const void **v38;
  void *v39;
  const void **v40;
  void *v41;
  const void **v42;
  void *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  char v47;
  int v48;
  CFMutableDictionaryRef v49;
  void *v50;
  int v51;
  const __CFAllocator *allocator;
  const __CFString *cf;
  id *v54;
  char *v55;
  _QWORD v56[5];
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(uint64_t, uint64_t);
  void (*v61)(uint64_t);
  uint64_t v62;

  v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    v54 = v1;
    DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v1);
    *(_QWORD *)(DerivedStorage + 592) += 30;
    v3 = *(const __CFArray **)(DerivedStorage + 64);
    if (!v3 || !CFArrayGetCount(v3))
      *(_QWORD *)(DerivedStorage + 600) += 30;
    if (*(_BYTE *)(DerivedStorage + 640))
      *(_QWORD *)(DerivedStorage + 608) = (FigGetUpTimeNanoseconds() - *(_QWORD *)(DerivedStorage + 648)) / 0x3B9ACA00;
    v57 = 0;
    Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 64));
    if (Count >= 1)
    {
      v5 = Count;
      v6 = 0;
      v7 = 0;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 64), v7);
        Value = (id *)FigCFDictionaryGetValue(ValueAtIndex, CFSTR("weakRef"));
        v10 = FigCFWeakReferenceHolderCopyReferencedObject(Value);
        FigCFDictionaryGetInt64IfPresent((uint64_t)ValueAtIndex, CFSTR("creationTime"), &v57);
        if (v10)
        {
          v11 = FigGetUpTimeNanoseconds() - v57;
          if (v11 > v6)
          {
            v12 = *(const void **)(DerivedStorage + 632);
            v13 = FigCFDictionaryGetValue(ValueAtIndex, CFSTR("name"));
            *(_QWORD *)(DerivedStorage + 632) = v13;
            if (v13)
              CFRetain(v13);
            if (v12)
              CFRelease(v12);
            v6 = v11;
          }
          ++v7;
          CFRelease(v10);
        }
        else
        {
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(DerivedStorage + 64), v7);
          --v5;
        }
      }
      while (v7 < v5);
      *(_QWORD *)(DerivedStorage + 624) = v6 / 0x3B9ACA00uLL;
    }
    if (proc_pid_rusage(*(_DWORD *)(DerivedStorage + 16), 6, (rusage_info_t *)(DerivedStorage + 72)) == 1
      || __ROR8__(0xFEDCBA987654321 * *(_QWORD *)(DerivedStorage + 592) + 0x91A2B3C4D5E6F0, 4) > 0x123456789ABCDEuLL)
    {
      goto LABEL_74;
    }
    v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    allocator = v14;
    if (Mutable)
    {
      v16 = Mutable;
      v17 = CFStringCreateWithCString(v14, (const char *)(DerivedStorage + 20), 0x8000100u);
      FigCFDictionarySetValue(v16, CFSTR("PidName"), v17);
      FigCFDictionarySetInt64(v16, CFSTR("IdleTime"), *(_QWORD *)(DerivedStorage + 600));
      FigCFDictionarySetInt64(v16, CFSTR("UpTime"), *(_QWORD *)(DerivedStorage + 592));
      FigCFDictionarySetInt64(v16, CFSTR("ScreenOnTime"), *(_QWORD *)(DerivedStorage + 608));
      FigCFDictionarySetInt64(v16, CFSTR("RUFootprint"), *(_QWORD *)(DerivedStorage + 144));
      FigCFDictionarySetInt64(v16, CFSTR("RUBilledEnergy"), *(_QWORD *)(DerivedStorage + 336));
      FigCFDictionarySetInt64(v16, CFSTR("RUServicedEnergy"), *(_QWORD *)(DerivedStorage + 344));
      FigCFDictionarySetInt64(v16, CFSTR("RUCycles"), *(_QWORD *)(DerivedStorage + 328));
      FigCFDictionarySetInt64(v16, CFSTR("RUInstructions"), *(_QWORD *)(DerivedStorage + 320));
      FigCFDictionarySetInt64(v16, CFSTR("RUMaxFootprint"), *(_QWORD *)(DerivedStorage + 312));
      FigCFDictionarySetInt64(v16, CFSTR("RUWiredSize"), *(_QWORD *)(DerivedStorage + 128));
      FigCFDictionarySetInt64(v16, CFSTR("RUBytesRead"), *(_QWORD *)(DerivedStorage + 216));
      FigCFDictionarySetInt64(v16, CFSTR("RUBytesWrite"), *(_QWORD *)(DerivedStorage + 224));
      FigCFDictionarySetInt64(v16, CFSTR("LongestTransactionTime"), *(_QWORD *)(DerivedStorage + 624));
      UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      FigCFDictionarySetInt64(v16, CFSTR("TimeSinceScreenUpdate"), (UpTimeNanoseconds - *(_QWORD *)(DerivedStorage + 648)) / 0x3B9ACA00);
      FigCFDictionarySetValue(v16, CFSTR("LongestTransactionName"), *(const void **)(DerivedStorage + 632));
      FigCFDictionarySetInt(v16, CFSTR("IsScreenOn"), *(unsigned __int8 *)(DerivedStorage + 640));
      FigCFDictionarySetValue(v16, CFSTR("PerfMonSID"), *(const void **)(DerivedStorage + 664));
      v19 = *(const __CFArray **)(DerivedStorage + 64);
      if (v19)
        v20 = CFArrayGetCount(v19);
      else
        v20 = 0;
      FigCFDictionarySetInt64(v16, CFSTR("TransactionCount"), v20);
      FigCFDictionarySetInt64(v16, CFSTR("LastHourRUBytesWrite"), *(_QWORD *)(DerivedStorage + 224) - *(_QWORD *)(DerivedStorage + 576));
      FigCFDictionarySetInt64(v16, CFSTR("LastHourRUBytesRead"), *(_QWORD *)(DerivedStorage + 216) - *(_QWORD *)(DerivedStorage + 568));
      FigCFDictionarySetInt64(v16, CFSTR("LastHourRUBilledEnergy"), *(_QWORD *)(DerivedStorage + 336) - *(_QWORD *)(DerivedStorage + 544));
      FigCFDictionarySetInt64(v16, CFSTR("LastHourRUServicedEnergy"), *(_QWORD *)(DerivedStorage + 344) - *(_QWORD *)(DerivedStorage + 536));
      FigCFDictionarySetInt64(v16, CFSTR("LastHourRUCycles"), *(_QWORD *)(DerivedStorage + 328) - *(_QWORD *)(DerivedStorage + 552));
      FigCFDictionarySetInt64(v16, CFSTR("LastHourRUInstructions"), *(_QWORD *)(DerivedStorage + 320) - *(_QWORD *)(DerivedStorage + 560));
      v21 = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v21)
      {
        v22 = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (v22)
        {
          cf = v17;
          for (i = 0; ; ++i)
          {
            v24 = *(const __CFArray **)(DerivedStorage + 64);
            if (v24)
              v24 = (const __CFArray *)CFArrayGetCount(v24);
            if (i >= (uint64_t)v24)
              break;
            v57 = 0;
            v55 = 0;
            v56[0] = 0;
            v25 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 64), i);
            v26 = FigCFDictionaryGetValue(v25, CFSTR("name"));
            if (CFDictionaryContainsKey(v21, v26))
            {
              FigCFDictionaryGetInt64IfPresent((uint64_t)v21, v26, &v55);
              v27 = (uint64_t)++v55;
            }
            else
            {
              v27 = 1;
            }
            FigCFDictionarySetInt64(v21, v26, v27);
            FigCFDictionaryGetInt64IfPresent((uint64_t)v25, CFSTR("creationTime"), &v57);
            v28 = (FigGetUpTimeNanoseconds() - v57) / 0x3B9ACA00;
            if (CFDictionaryContainsKey(v22, v26))
            {
              FigCFDictionaryGetInt64IfPresent((uint64_t)v22, v26, v56);
              if (v28 <= v56[0])
                continue;
            }
            FigCFDictionarySetInt64(v22, v26, v28);
          }
          FigCFDictionarySetValue(v16, CFSTR("TransactionNameDict"), v21);
          FigCFDictionarySetValue(v16, CFSTR("TransactionTimeDict"), v22);
          v29 = 0;
          v30 = (void (*)(uint64_t))v16;
          v16 = 0;
          v17 = cf;
        }
        else
        {
          v29 = FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0);
          v30 = 0;
        }
      }
      else
      {
        v29 = FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0);
        v30 = 0;
        v22 = 0;
      }
      if (v17)
        CFRelease(v17);
      if (v16)
        CFRelease(v16);
      if (v21)
        CFRelease(v21);
      if (v22)
        CFRelease(v22);
      if (v29)
        goto LABEL_72;
    }
    else
    {
      v30 = 0;
      if (FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0))
        goto LABEL_72;
    }
    v31 = vextq_s8(*(int8x16_t *)(DerivedStorage + 320), *(int8x16_t *)(DerivedStorage + 320), 8uLL);
    *(int8x16_t *)(DerivedStorage + 536) = vextq_s8(*(int8x16_t *)(DerivedStorage + 336), *(int8x16_t *)(DerivedStorage + 336), 8uLL);
    *(int8x16_t *)(DerivedStorage + 552) = v31;
    *(_OWORD *)(DerivedStorage + 568) = *(_OWORD *)(DerivedStorage + 216);
    v55 = 0;
    v32 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v32)
    {
      v33 = v32;
      v57 = 0;
      v58 = (uint64_t)&v57;
      v59 = 0x2020000000;
      v34 = (const void **)getkRTCReportingUserInfoClientNameSymbolLoc_ptr;
      v60 = (void (*)(uint64_t, uint64_t))getkRTCReportingUserInfoClientNameSymbolLoc_ptr;
      if (!getkRTCReportingUserInfoClientNameSymbolLoc_ptr)
      {
        v35 = (void *)RTCReportingLibrary();
        v34 = (const void **)dlsym(v35, "kRTCReportingUserInfoClientName");
        *(_QWORD *)(v58 + 24) = v34;
        getkRTCReportingUserInfoClientNameSymbolLoc_ptr = (uint64_t)v34;
      }
      _Block_object_dispose(&v57, 8);
      if (!v34)
        fpm_timerCallback_cold_1();
      FigCFDictionarySetValue(v33, *v34, CFSTR("CoreMediaPerf"));
      v36 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v36)
      {
        v37 = v36;
        v57 = 0;
        v58 = (uint64_t)&v57;
        v59 = 0x2020000000;
        v38 = (const void **)getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr;
        v60 = (void (*)(uint64_t, uint64_t))getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr;
        if (!getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr)
        {
          v39 = (void *)RTCReportingLibrary();
          v38 = (const void **)dlsym(v39, "kRTCReportingSessionInfoClientType");
          *(_QWORD *)(v58 + 24) = v38;
          getkRTCReportingSessionInfoClientTypeSymbolLoc_ptr = (uint64_t)v38;
        }
        _Block_object_dispose(&v57, 8);
        if (!v38)
          fpm_timerCallback_cold_2();
        FigCFDictionarySetInt(v37, *v38, 53);
        v57 = 0;
        v58 = (uint64_t)&v57;
        v59 = 0x2020000000;
        v40 = (const void **)getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr;
        v60 = (void (*)(uint64_t, uint64_t))getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr;
        if (!getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr)
        {
          v41 = (void *)RTCReportingLibrary();
          v40 = (const void **)dlsym(v41, "kRTCReportingSessionInfoSessionID");
          *(_QWORD *)(v58 + 24) = v40;
          getkRTCReportingSessionInfoSessionIDSymbolLoc_ptr = (uint64_t)v40;
        }
        _Block_object_dispose(&v57, 8);
        if (!v40)
          fpm_timerCallback_cold_3();
        FigCFDictionarySetInt(v37, *v40, *(_DWORD *)(DerivedStorage + 56));
        v57 = 0;
        v58 = (uint64_t)&v57;
        v59 = 0x2020000000;
        v42 = (const void **)getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr;
        v60 = (void (*)(uint64_t, uint64_t))getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr;
        if (!getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr)
        {
          v43 = (void *)RTCReportingLibrary();
          v42 = (const void **)dlsym(v43, "kRTCReportingSessionInfoContainsRealtimeEvents");
          *(_QWORD *)(v58 + 24) = v42;
          getkRTCReportingSessionInfoContainsRealtimeEventsSymbolLoc_ptr = (uint64_t)v42;
        }
        _Block_object_dispose(&v57, 8);
        if (!v42)
          fpm_timerCallback_cold_4();
        v44 = FigCFDictionarySetInt(v37, *v42, 0);
        v45 = (void *)MEMORY[0x193FFC34C](v44);
        v57 = 0;
        v58 = (uint64_t)&v57;
        v59 = 0x3052000000;
        v60 = __Block_byref_object_copy__0;
        v61 = __Block_byref_object_dispose__0;
        v46 = (void *)getRTCReportingClass_softClass;
        v62 = getRTCReportingClass_softClass;
        if (!getRTCReportingClass_softClass)
        {
          v56[0] = MEMORY[0x1E0C809B0];
          v56[1] = 3221225472;
          v56[2] = __getRTCReportingClass_block_invoke;
          v56[3] = &unk_1E28D9708;
          v56[4] = &v57;
          __getRTCReportingClass_block_invoke((uint64_t)v56);
          v46 = *(void **)(v58 + 40);
        }
        _Block_object_dispose(&v57, 8);
        v47 = objc_msgSend(v46, "sendOneMessageWithSessionInfo:userInfo:category:type:payload:error:", v37, v33, 901, 0, v30, &v55);
        v48 = 0;
        if ((v47 & 1) == 0)
          v48 = objc_msgSend(v55, "code");
        objc_autoreleasePoolPop(v45);
        CFRelease(v33);
        v49 = v37;
      }
      else
      {
        v48 = FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0);
        v49 = v33;
      }
      CFRelease(v49);
      if (v48)
        goto LABEL_72;
    }
    else if (FigSignalErrorAt(4294948226, 0, 0, 0, 0, 0, 0))
    {
      goto LABEL_72;
    }
    v50 = (void *)MEMORY[0x193FFC34C]();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("com.apple.%s.internal"), DerivedStorage + 20);
    v57 = MEMORY[0x1E0C809B0];
    v58 = 3221225472;
    v59 = (uint64_t)__fpm_reportingDataForInternalUsingCoreAnalytics_block_invoke;
    v60 = (void (*)(uint64_t, uint64_t))&__block_descriptor_40_e19___NSDictionary_8__0l;
    v61 = v30;
    if (AnalyticsSendEventLazy())
    {
      objc_autoreleasePoolPop(v50);
LABEL_71:
      *(_QWORD *)(DerivedStorage + 656) = FigGetUpTimeNanoseconds();
      goto LABEL_72;
    }
    v51 = FigSignalErrorAt(4294948221, 0, 0, 0, 0, 0, 0);
    objc_autoreleasePoolPop(v50);
    if (!v51)
      goto LABEL_71;
LABEL_72:
    if (v30)
      CFRelease(v30);
LABEL_74:
    CFRelease(v54);
  }
}

void sub_18ECC8E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void fpm_timerCancellationCallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t RTCReportingLibrary()
{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!RTCReportingLibraryCore_frameworkLibrary)
  {
    v2 = xmmword_1E28D9F70;
    v3 = 0;
    RTCReportingLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  if (!RTCReportingLibraryCore_frameworkLibrary)
    RTCReportingLibrary_cold_1(&v1);
  return RTCReportingLibraryCore_frameworkLibrary;
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class __getRTCReportingClass_block_invoke(uint64_t a1)
{
  Class result;

  RTCReportingLibrary();
  result = objc_getClass("RTCReporting");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getRTCReportingClass_block_invoke_cold_1();
  getRTCReportingClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t __fpm_reportingDataForInternalUsingCoreAnalytics_block_invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

char *OUTLINED_FUNCTION_0()
{
  return dlerror();
}

uint64_t FigMetricEventTimelineStartServer()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigMetricEventTimelineStartServer_block_invoke;
  block[3] = &unk_1E28D9FE0;
  block[4] = &v3;
  if (FigMetricEventTimelineStartServer_sFigMetricEventTimelineServerSetupOnce != -1)
    dispatch_once(&FigMetricEventTimelineStartServer_sFigMetricEventTimelineServerSetupOnce, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t metserver_replyingMessageHandler(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  xpc_object_t v10;
  CFTypeRef v11;
  uint64_t v12;
  uint64_t (*v13)(CFTypeRef, _QWORD *, void *, uint64_t);
  uint64_t uint64;
  CFTypeRef v15;
  CFTypeRef v16;
  uint64_t (*v17)(CFTypeRef, CFTypeRef);
  uint64_t v18;
  CFTypeRef v19;
  CFTypeRef v20;
  CFTypeRef v21;
  uint64_t (*v22)(CFTypeRef, CFTypeRef, CFTypeRef);
  char int64;
  CFTypeRef v24;
  CFTypeRef v25;
  uint64_t (*v26)(CFTypeRef, CFTypeRef, _QWORD);
  int64_t v27;
  xpc_object_t array;
  void *v29;
  malloc_zone_t *MallocZoneForMedia;
  uint64_t *v31;
  uint64_t *v32;
  size_t v33;
  uint64_t AllocatorForMedia;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  CFTypeRef v38;
  xpc_object_t v39;
  CFTypeRef v40;
  _QWORD *v41;
  CFTypeRef v42;
  int64_t v43;
  CFTypeRef v44;
  CFTypeRef v45;
  uint64_t (*v46)(CFTypeRef, CFTypeRef, int64_t);
  int v48;
  CFTypeRef cf;
  CFTypeRef v50;
  CFTypeRef v51;

  v48 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v48);
  if ((_DWORD)OpCode)
    return OpCode;
  v7 = 4294951138;
  if (v48 <= 1886741106)
  {
    if (v48 == 1668051817)
    {
      v50 = 0;
      v51 = 0;
      int64 = xpc_dictionary_get_int64(a2, "ClassID");
      v8 = metserver_copyEventTimelineAndCompanion(a1, a2, &v51, &v50);
      if ((_DWORD)v8)
        goto LABEL_43;
      v25 = v50;
      v24 = v51;
      v26 = *(uint64_t (**)(CFTypeRef, CFTypeRef, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v51) + 16)
                                                                   + 24);
      if (v26)
      {
        v8 = v26(v24, v25, int64);
        goto LABEL_43;
      }
LABEL_44:
      v7 = 4294954514;
      goto LABEL_48;
    }
    if (v48 != 1668441460)
    {
      if (v48 != 1684632432)
        return v7;
      uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
      return FigXPCServerDisassociateObjectWithConnection(a1, uint64);
    }
    v50 = 0;
    v51 = 0;
    cf = 0;
    v27 = xpc_dictionary_get_int64(a2, "MaxNoOfClasses");
    array = xpc_dictionary_get_array(a2, "EventCountByClassXPCArray");
    if (array
      && (v29 = array,
          MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia(),
          (v31 = (uint64_t *)malloc_type_zone_calloc(MallocZoneForMedia, 1uLL, 8 * v27, 0x100004000313F17uLL)) != 0))
    {
      v32 = v31;
      if (xpc_array_get_count(v29))
      {
        v33 = 0;
        do
        {
          v32[v33] = xpc_array_get_int64(v29, v33);
          ++v33;
        }
        while (v33 < xpc_array_get_count(v29));
      }
      AllocatorForMedia = FigGetAllocatorForMedia();
      v35 = FigMetricEventTimelineCreate(AllocatorForMedia, v27, v32, CFSTR("metricEventTimeline"), 0, &v51);
      if (!(_DWORD)v35)
      {
        v36 = FigGetAllocatorForMedia();
        v37 = metserver_createCompanion(v36, &cf);
        v38 = cf;
        if ((_DWORD)v37)
        {
          v7 = v37;
        }
        else
        {
          v7 = FigXPCServerAssociateObjectWithConnection(a1, v51, (uint64_t)cf, (uint64_t)FigCFRelease, 0, (unint64_t *)&v50);
          if (!(_DWORD)v7)
          {
            v39 = FigXPCRetain(a1);
            v41 = cf;
            v40 = v50;
            *((_QWORD *)cf + 2) = v39;
            v41[3] = v40;
            xpc_dictionary_set_uint64(a3, ".objectID", (uint64_t)v40);
            cf = 0;
            goto LABEL_38;
          }
          v38 = cf;
        }
        if (v38)
          CFRelease(v38);
LABEL_38:
        v42 = v51;
        if (!v51)
          return v7;
        goto LABEL_51;
      }
    }
    else
    {
      v35 = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
    }
    v7 = v35;
    goto LABEL_38;
  }
  if (v48 > 1936029288)
  {
    if (v48 == 1936029289)
    {
      v50 = 0;
      v51 = 0;
      v43 = xpc_dictionary_get_int64(a2, "EventID");
      v8 = metserver_copyEventTimelineAndCompanion(a1, a2, &v51, &v50);
      if ((_DWORD)v8)
        goto LABEL_43;
      v45 = v50;
      v44 = v51;
      v46 = *(uint64_t (**)(CFTypeRef, CFTypeRef, int64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v51)
                                                                                + 16)
                                                                    + 16);
      if (v46)
      {
        v8 = v46(v44, v45, v43);
        goto LABEL_43;
      }
    }
    else
    {
      if (v48 != 1937006949)
        return v7;
      v50 = 0;
      v51 = 0;
      v8 = metserver_copyEventTimelineAndCompanion(a1, a2, &v51, &v50);
      if ((_DWORD)v8)
        goto LABEL_43;
      v16 = v50;
      v15 = v51;
      v17 = *(uint64_t (**)(CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v51) + 16) + 32);
      if (v17)
      {
        v8 = v17(v15, v16);
        goto LABEL_43;
      }
    }
    goto LABEL_44;
  }
  if (v48 != 1886741107)
  {
    if (v48 != 1919248243)
      return v7;
    v50 = 0;
    v51 = 0;
    v8 = metserver_copyEventTimelineAndCompanion(a1, a2, &v51, &v50);
    if ((_DWORD)v8)
      goto LABEL_43;
    v9 = v50;
    if (!*((_QWORD *)v50 + 2))
    {
      v10 = FigXPCRetain(a1);
      v9 = v50;
      *((_QWORD *)v50 + 2) = v10;
    }
    v11 = v51;
    v12 = v9[4];
    v13 = *(uint64_t (**)(CFTypeRef, _QWORD *, void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v51)
                                                                                     + 16)
                                                                         + 8);
    if (v13)
    {
      v8 = v13(v11, v9, &metserver_registerSubscriber_subscriberCallbacks, v12);
LABEL_43:
      v7 = v8;
      goto LABEL_48;
    }
    goto LABEL_44;
  }
  v50 = 0;
  v51 = 0;
  cf = 0;
  v18 = metserver_copyEventTimelineAndCompanion(a1, a2, &v51, &v50);
  if ((_DWORD)v18)
    goto LABEL_25;
  v18 = FigMetricEventTimelineClientServerXPC_DeserializeAndCopyEvent(a2, &cf);
  if ((_DWORD)v18)
    goto LABEL_25;
  v20 = v50;
  v19 = v51;
  v21 = cf;
  v22 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v51) + 16)
                                                                  + 40);
  if (v22)
  {
    v18 = v22(v19, v20, v21);
LABEL_25:
    v7 = v18;
    goto LABEL_46;
  }
  v7 = 4294954514;
LABEL_46:
  if (cf)
    CFRelease(cf);
LABEL_48:
  if (v51)
    CFRelease(v51);
  v42 = v50;
  if (v50)
LABEL_51:
    CFRelease(v42);
  return v7;
}

uint64_t metserver_noReplyMessageHandler(_xpc_connection_s *a1, void *a2)
{
  return metserver_replyingMessageHandler(a1, a2, 0);
}

void FigCFRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t FigMetricEventTimelineGetIDByAssociatingWithClientConnection(const void *a1, _xpc_connection_s *a2, _QWORD *a3)
{
  uint64_t AllocatorForMedia;
  uint64_t v7;
  CFTypeRef v8;
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  if (a1 && a2 && a3)
  {
    AllocatorForMedia = FigGetAllocatorForMedia();
    v7 = metserver_createCompanion(AllocatorForMedia, &cf);
    v8 = cf;
    if ((_DWORD)v7)
    {
      v9 = v7;
    }
    else
    {
      v9 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gFigMetricEventTimelineServer, a2, a1, (uint64_t)cf, (uint64_t)FigCFRelease, 0, a3);
      v8 = cf;
      if (!(_DWORD)v9)
      {
        *((_QWORD *)cf + 3) = *a3;
        return v9;
      }
    }
    if (v8)
      CFRelease(v8);
    return v9;
  }
  return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
}

uint64_t metserver_createCompanion(uint64_t a1, _QWORD *a2)
{
  uint64_t Instance;
  _QWORD *v4;
  dispatch_queue_t v5;
  uint64_t v6;
  __int128 v8;

  if (!a2)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  v8 = xmmword_1E28DA060;
  if (metricEventTimelineServerCompanion_getTypeID_once != -1)
    dispatch_once_f(&metricEventTimelineServerCompanion_getTypeID_once, &v8, (dispatch_function_t)metserver_registerClass);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
  v4 = (_QWORD *)Instance;
  v5 = dispatch_queue_create("com.apple.coremedia.figmetriceventtimelineserver.callback", 0);
  v4[4] = v5;
  if (v5)
  {
    v6 = 0;
    *a2 = v4;
  }
  else
  {
    v6 = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
    CFRelease(v4);
  }
  return v6;
}

void metserver_didReceiveEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t v6;
  int v8;
  int v9;
  xpc_object_t message;

  message = 0;
  if (!a1)
    goto LABEL_8;
  v6 = *(xpc_object_t *)(a1 + 24);
  if (!v6)
    goto LABEL_7;
  if (!*(_QWORD *)(a1 + 16))
  {
LABEL_8:
    v6 = 0;
    goto LABEL_7;
  }
  v8 = FigXPCCreateBasicMessage(0x65766E74u, (uint64_t)v6, &message);
  v6 = message;
  if (!v8)
  {
    v9 = FigMetricEventTimelineClientServerXPC_SerializeEvent(message, a2, a4);
    v6 = message;
    if (!v9)
    {
      xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), message);
      v6 = message;
    }
  }
LABEL_7:
  FigXPCRelease(v6);
}

uint64_t metserver_copyEventTimelineAndCompanion(_xpc_connection_s *a1, xpc_object_t xdict, CFTypeRef *a3, _QWORD *a4)
{
  uint64_t uint64;
  uint64_t v8;
  CFTypeRef v9;
  uint64_t v10;
  CFTypeRef cf;
  CFTypeRef v13;

  cf = 0;
  v13 = 0;
  uint64 = xpc_dictionary_get_uint64(xdict, ".objectID");
  if (!uint64)
  {
    v8 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &v13, &cf);
  if ((_DWORD)v8)
  {
LABEL_14:
    v10 = v8;
    goto LABEL_10;
  }
  if (a3)
  {
    *a3 = v13;
    v13 = 0;
  }
  if (a4)
  {
    v9 = cf;
    if (cf)
      v9 = CFRetain(cf);
    v10 = 0;
    *a4 = v9;
  }
  else
  {
    v10 = 0;
  }
LABEL_10:
  if (v13)
    CFRelease(v13);
  return v10;
}

void metricEventTimelineServerCompanion_finalize(uint64_t a1)
{
  NSObject *v2;

  FigXPCRelease(*(xpc_object_t *)(a1 + 16));
  v2 = *(NSObject **)(a1 + 32);
  if (v2)
    dispatch_release(v2);
}

uint64_t metserver_registerClass(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  **(_QWORD **)(a1 + 8) = result;
  return result;
}

uint64_t FigCaptionFontFamilyNameListGetTypeID()
{
  FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType);
  return sFigCaptionFontFamilyNameListID;
}

uint64_t fontFamilyList_registerFigCaptionFontFamilyNameListIDType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionFontFamilyNameListID = result;
  return result;
}

uint64_t FigCaptionFontFamilyNameListCreateMutable(const __CFAllocator *a1, uint64_t *a2)
{
  uint64_t Instance;
  uint64_t v5;
  uint64_t v7;

  if (a2)
  {
    FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v5 = Instance;
      *(_QWORD *)(Instance + 16) = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
      *a2 = v5;
      return 0;
    }
    v7 = 4294954510;
  }
  else
  {
    v7 = 4294954516;
  }
  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionFontFamilyNameListCreateMutableCopy(const __CFAllocator *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t Instance;
  _QWORD *v7;
  CFMutableArrayRef MutableCopy;
  uint64_t v10;
  uint64_t v11;

  if (!a3)
  {
    v10 = 4294954516;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v10 = 4294954510;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v7 = (_QWORD *)Instance;
  MutableCopy = CFArrayCreateMutableCopy(a1, 0, *(CFArrayRef *)(a2 + 16));
  v7[2] = MutableCopy;
  if (MutableCopy)
  {
    *a3 = v7;
    return 0;
  }
  else
  {
    v11 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    CFRelease(v7);
    return v11;
  }
}

CFIndex FigCaptionFontFamilyNameListGetCount(uint64_t a1)
{
  const __CFArray *v1;

  if (a1 && (v1 = *(const __CFArray **)(a1 + 16)) != 0)
    return CFArrayGetCount(v1);
  else
    return 0;
}

uint64_t FigCaptionFontFamilyNameListAppend(uint64_t a1, unsigned int a2, const void *a3)
{
  CFMutableDictionaryRef Mutable;

  if (!a1 || a2 >= 2 || !a3)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32(Mutable, CFSTR("kind"), a2);
  CFDictionaryAddValue(Mutable, CFSTR("familyname"), a3);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return 0;
}

uint64_t FigCaptionFontFamilyNameListCopyFamilyKindAndNameAtIndex(uint64_t a1, CFIndex idx, void *a3, _QWORD *a4)
{
  const __CFArray *Count;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v10;
  const void *Value;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  Count = *(const __CFArray **)(a1 + 16);
  if (Count)
    Count = (const __CFArray *)CFArrayGetCount(Count);
  if ((uint64_t)Count <= idx || idx < 0)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), idx);
  v10 = ValueAtIndex;
  if (a3)
    FigCFDictionaryGetInt32IfPresent((uint64_t)ValueAtIndex, CFSTR("kind"), a3);
  if (a4)
  {
    Value = CFDictionaryGetValue(v10, CFSTR("familyname"));
    if (Value)
      Value = CFRetain(Value);
    *a4 = Value;
  }
  return 0;
}

uint64_t fontFamilyList_Init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

void fontFamilyList_Finalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 16);
  if (v1)
    CFRelease(v1);
}

uint64_t fontFamilyList_Equal(CFTypeRef *a1, CFTypeRef *a2)
{
  CFTypeID v4;
  CFTypeID v5;

  if (a1
    && (v4 = CFGetTypeID(a1),
        FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType), a2)&& v4 == sFigCaptionFontFamilyNameListID&& (v5 = CFGetTypeID(a2), FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType), v5 == sFigCaptionFontFamilyNameListID))
  {
    return CFEqual(a1[2], a2[2]);
  }
  else
  {
    return 0;
  }
}

CFHashCode fontFamilyList_Hash(CFTypeRef *a1)
{
  CFTypeID v2;

  if (a1
    && (v2 = CFGetTypeID(a1),
        FigThreadRunOnce(&FigCaptionFontFamilyNameListGetTypeID_sRegisterFigCaptionFontFamilyNameListTypeOnce, (void (*)(void))fontFamilyList_registerFigCaptionFontFamilyNameListIDType), v2 == sFigCaptionFontFamilyNameListID))
  {
    return CFHash(a1[2]);
  }
  else
  {
    return 0;
  }
}

__CFString *fontFamilyList_CopyDebugDesc(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  __CFString *v4;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = Mutable;
  if (a1)
    CFStringAppendFormat(Mutable, 0, CFSTR("<FigCaptionFontFamilyNameList %p> familyNames:%@"), a1, a1[2]);
  else
    CFStringAppendFormat(Mutable, 0, CFSTR("<FigCaptionFontFamilyNameList %p>"), 0);
  return v4;
}

uint64_t FigCPECryptorRemoteRetainCopiedCryptor(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t v6;
  CFTypeRef v7;
  _QWORD *ClassID;
  uint64_t v9;
  uint64_t DerivedStorage;
  CFTypeRef v12;
  CFTypeRef cf[5];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;

  v12 = 0;
  if (a2 && a3)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2000000000;
    v17 = 0;
    cf[0] = (CFTypeRef)MEMORY[0x1E0C809B0];
    cf[1] = (CFTypeRef)0x40000000;
    cf[2] = __cryptorRemote_EnsureClientEstablished_block_invoke;
    cf[3] = &unk_1E28DA188;
    cf[4] = &v14;
    if (cryptorRemote_EnsureClientEstablished_sFigCPECryptorRemoteClientSetupOnce != -1)
      dispatch_once(&cryptorRemote_EnsureClientEstablished_sFigCPECryptorRemoteClientSetupOnce, cf);
    FigXPCRemoteClientKillServerOnTimeout(gFigCPECryptorRemoteClient, *((unsigned int *)v15 + 6), "cryptorRemote_EnsureClientEstablished", 0);
    v6 = *((unsigned int *)v15 + 6);
    _Block_object_dispose(&v14, 8);
    if ((_DWORD)v6)
      return v6;
    v6 = FigXPCRemoteClientRetainCopiedObject(gFigCPECryptorRemoteClient, (uint64_t)a2, &v12);
    v7 = v12;
    if ((_DWORD)v6)
      goto LABEL_17;
    if (v12)
    {
LABEL_15:
      v6 = 0;
      *a3 = v7;
      return v6;
    }
    cf[0] = 0;
    ClassID = (_QWORD *)FigCPECryptorGetClassID();
    v9 = CMDerivedObjectCreate(a1, (uint64_t)&kFigCPECryptorRemote_VTable, ClassID, cf);
    if (!(_DWORD)v9)
    {
      if (cf[0])
      {
        DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf[0]);
        *(_QWORD *)(DerivedStorage + 8) = a2;
        *(_WORD *)DerivedStorage = 0;
        *(_BYTE *)(DerivedStorage + 16) = 0;
        *(_QWORD *)(DerivedStorage + 24) = 0;
        *(_DWORD *)(DerivedStorage + 32) = 0;
        *(_QWORD *)(DerivedStorage + 48) = FigSimpleMutexCreate();
        v6 = FigXPCRemoteClientAssociateObject(gFigCPECryptorRemoteClient, (uint64_t)cf[0], a2);
        if (!(_DWORD)v6)
          v12 = CFRetain(cf[0]);
LABEL_12:
        if (cf[0])
          CFRelease(cf[0]);
        v7 = v12;
        if (!(_DWORD)v6)
          goto LABEL_15;
LABEL_17:
        if (v7)
          CFRelease(v7);
        return v6;
      }
      v9 = FigSignalErrorAt(4294949725, 0, 0, 0, 0, 0, 0);
    }
    v6 = v9;
    goto LABEL_12;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCPECryptorRemoteGetID(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  v4 = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  result = cryptorRemote_GetObjectID(a1, &v4);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t cryptorRemote_GetObjectID(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a2)
  {
    if (*(_BYTE *)DerivedStorage)
    {
      v5 = 4294949723;
    }
    else
    {
      if (!*(_BYTE *)(DerivedStorage + 1))
      {
        *a2 = *(_QWORD *)(DerivedStorage + 8);
        return 0;
      }
      v5 = 4294949722;
    }
  }
  else
  {
    v5 = 4294949726;
  }
  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t cryptorRemote_getExternalProtectionMethods(uint64_t a1, _DWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t result;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!a1)
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  if (!a2)
    return 0;
  v5 = DerivedStorage;
  result = cryptorRemote_ensureStateUpdatedFromServer(a1);
  *a2 = *(_DWORD *)(v5 + 32);
  return result;
}

uint64_t cryptorRemote_ensureStateUpdatedFromServer(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v7;
  xpc_object_t xdict;
  void *v9;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xdict = 0;
  v9 = 0;
  if (*(_BYTE *)DerivedStorage)
  {
    v7 = 4294949723;
LABEL_12:
    v3 = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    goto LABEL_9;
  }
  v2 = DerivedStorage;
  if (*(_BYTE *)(DerivedStorage + 1))
  {
    v7 = 4294949722;
    goto LABEL_12;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 48));
  if (*(_BYTE *)(v2 + 16))
  {
    v3 = 0;
  }
  else
  {
    v4 = FigXPCCreateBasicMessage(0x6E736D74u, *(_QWORD *)(v2 + 8), &v9);
    if ((_DWORD)v4)
    {
      v3 = v4;
    }
    else
    {
      v3 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCPECryptorRemoteClient, (uint64_t)v9, &xdict);
      if (!(_DWORD)v3)
      {
        *(_QWORD *)(v2 + 24) = xpc_dictionary_get_uint64(xdict, "NativeSession");
        *(_DWORD *)(v2 + 32) = xpc_dictionary_get_uint64(xdict, "ExternalProtectionMethods");
        *(_DWORD *)(v2 + 36) = xpc_dictionary_get_uint64(xdict, "CryptorType");
        *(_BYTE *)(v2 + 16) = 1;
      }
    }
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 48));
  v5 = v9;
LABEL_9:
  FigXPCRelease(v5);
  FigXPCRelease(xdict);
  return v3;
}

uint64_t cryptorRemote_DeadConnectionCallback(uint64_t a1)
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage(a1);
  *(_BYTE *)(result + 1) = 1;
  return result;
}

uint64_t cryptorRemote_Invalidate(uint64_t a1)
{
  _BYTE *DerivedStorage;
  uint64_t ObjectID;
  uint64_t v4;
  xpc_object_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = 0;
  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  ObjectID = cryptorRemote_GetObjectID(a1, &v7);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x69637279u, v7, &v6), (_DWORD)ObjectID))
  {
    v4 = ObjectID;
  }
  else
  {
    v4 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, (uint64_t)v6);
    if (!(_DWORD)v4)
      *DerivedStorage = 1;
  }
  FigXPCRelease(v6);
  return v4;
}

uint64_t cryptorRemote_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  const void *v3;
  uint64_t v4;
  void *v6;

  v6 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigXPCRemoteClientDisassociateObject(gFigCPECryptorRemoteClient, *(const void **)(DerivedStorage + 8));
  if (!*(_BYTE *)(DerivedStorage + 1)
    && ((v2 = FigXPCCreateBasicMessage(0x64697370u, *(_QWORD *)(DerivedStorage + 8), &v6), (_DWORD)v2)
     || (v2 = FigXPCRemoteClientSendAsyncMessage(gFigCPECryptorRemoteClient, v6), (_DWORD)v2)))
  {
    v4 = v2;
  }
  else
  {
    FigSimpleMutexDestroy(*(_QWORD *)(DerivedStorage + 48));
    v3 = *(const void **)(DerivedStorage + 40);
    if (v3)
      CFRelease(v3);
    v4 = 0;
  }
  FigXPCRelease(v6);
  return FigXPCRemoteClientKillServerOnTimeout(gFigCPECryptorRemoteClient, v4, "cryptorRemote_Finalize", 0);
}

__CFString *cryptorRemote_CopyDebugDescription(const void *a1)
{
  _BYTE *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;
  CFIndex v5;
  const char *v6;
  CFAllocatorRef v7;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = CFGetRetainCount(a1);
  if (*DerivedStorage)
    v6 = " (invalidated)";
  else
    v6 = "";
  v7 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigCPECryptor_Remote %p retainCount: %ld%s allocator: %p, "), a1, v5, v6, v7);
  CFStringAppendFormat(Mutable, 0, CFSTR(">"));
  return Mutable;
}

uint64_t cryptorRemote_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t DerivedStorage;
  uint64_t v8;
  uint64_t ObjectID;
  CFTypeRef *v10;
  uint64_t v11;
  CFTypeRef v12;
  uint64_t v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v14 = 0;
  if (a4)
  {
    v8 = DerivedStorage;
    ObjectID = cryptorRemote_GetObjectID(a1, &v14);
    if (!(_DWORD)ObjectID)
    {
      if (CFEqual(a2, CFSTR("UUIDString")))
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(v8 + 48));
        v10 = (CFTypeRef *)(v8 + 40);
        if (*(_QWORD *)(v8 + 40))
        {
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(v8 + 48));
LABEL_9:
          v12 = *v10;
          if (*v10)
            v12 = CFRetain(v12);
          v11 = 0;
          *a4 = v12;
          return v11;
        }
        v11 = FigXPCSendStdCopyPropertyMessage(gFigCPECryptorRemoteClient, v14, CFSTR("UUIDString"), (CFTypeRef *)(v8 + 40));
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(v8 + 48));
        if (!(_DWORD)v11)
          goto LABEL_9;
        return v11;
      }
      return FigXPCSendStdCopyPropertyMessage(gFigCPECryptorRemoteClient, v14, a2, a4);
    }
    return ObjectID;
  }
  return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

uint64_t cryptorRemote_SetProperty(uint64_t a1, const void *a2, void *a3)
{
  uint64_t ObjectID;
  CFTypeID v6;
  uint64_t v7;
  CFTypeID v8;
  CFTypeID v9;
  uint64_t v10;
  uint64_t v12;
  int v13[2];

  v12 = 0;
  if (a2 && a3)
  {
    ObjectID = cryptorRemote_GetObjectID(a1, &v12);
    if (!(_DWORD)ObjectID)
    {
      if (CFEqual(a2, CFSTR("KeyRequestError")))
      {
        v6 = CFGetTypeID(a3);
        if (v6 == CFErrorGetTypeID())
        {
          *(_QWORD *)v13 = 0;
          v7 = FigXPCCreateBasicMessage(0x736B7272u, v12, v13);
          if ((_DWORD)v7)
            goto LABEL_19;
          v7 = FigXPCMessageSetCFError(*(void **)v13, "KeyRequestError", (__CFError *)a3);
          if ((_DWORD)v7)
            goto LABEL_19;
          goto LABEL_18;
        }
        return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
      }
      if (CFEqual(a2, CFSTR("CPEBAESCP_VideoFormatDescription")))
      {
        v8 = CFGetTypeID(a3);
        if (v8 == CMFormatDescriptionGetTypeID())
        {
          *(_QWORD *)v13 = 0;
          v7 = FigXPCCreateBasicMessage(0x73666D74u, v12, v13);
          if ((_DWORD)v7)
            goto LABEL_19;
          v7 = FigXPCMessageSetFormatDescription(*(void **)v13, "FormatDescription", (uint64_t)a3);
          if ((_DWORD)v7)
            goto LABEL_19;
          goto LABEL_18;
        }
        return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
      }
      if (CFEqual(a2, CFSTR("CPEAESCP_SUBAUXDATA")))
      {
        v9 = CFGetTypeID(a3);
        if (v9 == CFDataGetTypeID())
        {
          *(_QWORD *)v13 = 0;
          v7 = FigXPCCreateBasicMessage(0x73736164u, v12, v13);
          if ((_DWORD)v7)
            goto LABEL_19;
          v7 = FigXPCMessageSetCFData(*(void **)v13, "SubsampleAuxiliaryData", a3);
          if ((_DWORD)v7)
            goto LABEL_19;
LABEL_18:
          v7 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, *(uint64_t *)v13);
LABEL_19:
          v10 = v7;
          FigXPCRelease(*(xpc_object_t *)v13);
          return v10;
        }
        return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
      }
      return FigXPCSendStdSetPropertyMessage(gFigCPECryptorRemoteClient, v12, a2, a3);
    }
    return ObjectID;
  }
  return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

uint64_t cryptorRemote_getNativeSession(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t result;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!a1)
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  if (!a2)
    return 0;
  v5 = DerivedStorage;
  result = cryptorRemote_ensureStateUpdatedFromServer(a1);
  if (!(_DWORD)result)
    *a2 = *(_QWORD *)(v5 + 24);
  return result;
}

uint64_t cryptorRemote_CreateKeyRequest(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t ObjectID;
  uint64_t v7;
  xpc_object_t v9;
  int v10[2];
  uint64_t v11;

  *(_QWORD *)v10 = 0;
  v11 = 0;
  v9 = 0;
  ObjectID = cryptorRemote_GetObjectID(a1, &v11);
  if (!(_DWORD)ObjectID)
  {
    ObjectID = FigXPCCreateBasicMessage(0x636B6579u, v11, v10);
    if (!(_DWORD)ObjectID)
    {
      ObjectID = FigXPCMessageSetCFDictionary(*(void **)v10, "KeyRequestData", a2);
      if (!(_DWORD)ObjectID)
      {
        ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCPECryptorRemoteClient, *(uint64_t *)v10, &v9);
        if (!(_DWORD)ObjectID)
          ObjectID = FigXPCMessageCopyCFData(v9, "SPCBytes", a4);
      }
    }
  }
  v7 = ObjectID;
  FigXPCRelease(*(xpc_object_t *)v10);
  FigXPCRelease(v9);
  return v7;
}

uint64_t cryptorRemote_SetKeyRequestResponse(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t ObjectID;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  int v10[2];
  uint64_t v11;

  *(_QWORD *)v10 = 0;
  v11 = 0;
  ObjectID = cryptorRemote_GetObjectID(a1, &v11);
  if ((_DWORD)ObjectID)
  {
    v8 = ObjectID;
    v7 = 0;
  }
  else
  {
    v6 = FigXPCCreateBasicMessage(0x736B6579u, v11, v10);
    v7 = *(void **)v10;
    if ((_DWORD)v6
      || (v6 = FigXPCMessageSetCFData(*(void **)v10, "KeyRequestResponse", a2), v7 = *(void **)v10, (_DWORD)v6)
      || (v6 = FigXPCMessageSetCFDictionary(*(void **)v10, "KeyResponseOptionsDictionary", a3),
          v7 = *(void **)v10,
          (_DWORD)v6))
    {
      v8 = v6;
    }
    else
    {
      v8 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, *(uint64_t *)v10);
      v7 = *(void **)v10;
    }
  }
  FigXPCRelease(v7);
  return v8;
}

uint64_t cryptorRemote_GetSerializationToken(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  v4 = 0;
  if (!a2)
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  result = cryptorRemote_GetObjectID(a1, &v4);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t cryptorRemote_CopyPropertyForFormat(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, __CFDictionary **a5)
{
  uint64_t ObjectID;
  uint64_t v9;
  xpc_object_t v11;
  int v12[2];
  uint64_t v13;

  *(_QWORD *)v12 = 0;
  v13 = 0;
  v11 = 0;
  if (a5)
  {
    ObjectID = cryptorRemote_GetObjectID(a1, &v13);
    if (!(_DWORD)ObjectID)
    {
      ObjectID = FigXPCCreateBasicMessage(0x63706666u, v13, v12);
      if (!(_DWORD)ObjectID)
      {
        ObjectID = FigXPCMessageSetCFString(*(void **)v12, ".PropertyName", a2);
        if (!(_DWORD)ObjectID)
        {
          FigXPCMessageSetUInt32(*(void **)v12, "Format", a3);
          ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCPECryptorRemoteClient, *(uint64_t *)v12, &v11);
          if (!(_DWORD)ObjectID)
            ObjectID = FigXPCMessageCopyCFObject(v11, ".Value", a5);
        }
      }
    }
  }
  else
  {
    ObjectID = FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  }
  v9 = ObjectID;
  FigXPCRelease(*(xpc_object_t *)v12);
  FigXPCRelease(v11);
  return v9;
}

uint64_t cryptorRemote_TestAndSetKeyRequestState(uint64_t a1, unsigned int a2, unsigned int a3, BOOL *a4, uint64_t *a5)
{
  uint64_t ObjectID;
  uint64_t v10;
  xpc_object_t v12;
  xpc_object_t xdict;
  uint64_t v14;

  xdict = 0;
  v14 = 0;
  v12 = 0;
  ObjectID = cryptorRemote_GetObjectID(a1, &v14);
  if ((_DWORD)ObjectID
    || (ObjectID = FigXPCCreateBasicMessage(0x74617373u, v14, &xdict), (_DWORD)ObjectID)
    || (xpc_dictionary_set_int64(xdict, "ExpectedState", a2),
        xpc_dictionary_set_int64(xdict, "NewState", a3),
        ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCPECryptorRemoteClient, (uint64_t)xdict, &v12),
        (_DWORD)ObjectID))
  {
    v10 = ObjectID;
  }
  else
  {
    if (a4)
      *a4 = xpc_dictionary_get_BOOL(v12, "WasSetOutFlag");
    v10 = 0;
    if (a5)
      *a5 = xpc_dictionary_get_uint64(v12, "KeyRequestIDOut");
  }
  FigXPCRelease(xdict);
  FigXPCRelease(v12);
  return v10;
}

uint64_t cryptorRemote_AbsorbKeyRequestContext(uint64_t a1, uint64_t a2)
{
  uint64_t ObjectID;
  uint64_t v4;
  xpc_object_t v5;
  xpc_object_t xdict;
  uint64_t value;
  uint64_t v9;

  value = 0;
  v9 = 0;
  xdict = 0;
  ObjectID = cryptorRemote_GetObjectID(a1, &v9);
  if ((_DWORD)ObjectID || (ObjectID = cryptorRemote_GetObjectID(a2, &value), (_DWORD)ObjectID))
  {
    v4 = ObjectID;
    v5 = 0;
  }
  else
  {
    v4 = FigXPCCreateBasicMessage(0x616B7263u, v9, &xdict);
    v5 = xdict;
    if (!(_DWORD)v4)
    {
      xpc_dictionary_set_uint64(xdict, "FromCryptorID", value);
      v4 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, (uint64_t)xdict);
      v5 = xdict;
    }
  }
  FigXPCRelease(v5);
  return v4;
}

uint64_t cryptorRemote_setKeyResponseForAirPlay(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t ObjectID;
  uint64_t v8;
  xpc_object_t v9;
  uint64_t v10;
  xpc_object_t xdict;
  uint64_t v13;

  xdict = 0;
  v13 = 0;
  ObjectID = cryptorRemote_GetObjectID(a1, &v13);
  if ((_DWORD)ObjectID)
  {
    v10 = ObjectID;
    v9 = 0;
  }
  else
  {
    v8 = FigXPCCreateBasicMessage(0x736B6170u, v13, &xdict);
    v9 = xdict;
    if ((_DWORD)v8
      || (xpc_dictionary_set_uint64(xdict, "SessionID", a2),
          v8 = FigXPCMessageSetCFData(xdict, "KeyRequestResponse", a3),
          v9 = xdict,
          (_DWORD)v8)
      || (v8 = FigXPCMessageSetCFDictionary(xdict, "KeyResponseOptionsDictionary", a4), v9 = xdict, (_DWORD)v8))
    {
      v10 = v8;
    }
    else
    {
      v10 = FigXPCRemoteClientSendSyncMessage(gFigCPECryptorRemoteClient, (uint64_t)xdict);
      v9 = xdict;
    }
  }
  FigXPCRelease(v9);
  FigXPCRelease(0);
  return v10;
}

uint64_t cryptorRemote_copySerializedCryptorRecipe(uint64_t a1, CFDataRef *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  CFDataRef v9;
  CFDataRef v10;
  _QWORD v11[4];

  v11[3] = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!a1)
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
  if (!a2)
    return 0;
  v5 = DerivedStorage;
  result = cryptorRemote_ensureStateUpdatedFromServer(a1);
  if (!(_DWORD)result)
  {
    v7 = *(unsigned int *)(v5 + 32);
    v8 = *(int *)(v5 + 36);
    v11[0] = *(_QWORD *)(v5 + 24);
    v11[1] = v7;
    v11[2] = v8;
    v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v11, 24);
    if (v9)
    {
      v10 = v9;
      result = 0;
      *a2 = v10;
    }
    else
    {
      return 4294949725;
    }
  }
  return result;
}

uint64_t FigMetricEventClassInstallEventDeserializeHandler(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *AllocatorForMedia;
  CFNumberRef SInt64;
  uint64_t v6;
  uint64_t Instance;
  const void *v8;
  __int128 v10;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  SInt64 = FigCFNumberCreateSInt64(AllocatorForMedia, a1);
  if (!a2)
  {
    v6 = FigSignalErrorAt(4294947836, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  if (ensureGlobalDeserializeRegister_ensureGlobalDeserializeRegisterOnce != -1)
    dispatch_once(&ensureGlobalDeserializeRegister_ensureGlobalDeserializeRegisterOnce, &__block_literal_global_10);
  v6 = ensureGlobalDeserializeRegister_err;
  if (!ensureGlobalDeserializeRegister_err)
  {
    FigGetAllocatorForMedia();
    v10 = xmmword_1E28DA3F8;
    if (meEventDeserializationCallbackData_getTypeID_once != -1)
      dispatch_once_f(&meEventDeserializationCallbackData_getTypeID_once, &v10, (dispatch_function_t)metutil_registerClass);
    Instance = _CFRuntimeCreateInstance();
    v8 = (const void *)Instance;
    if (Instance)
    {
      *(_QWORD *)(Instance + 16) = a2;
    }
    else
    {
      v6 = FigSignalErrorAt(4294947835, 0, 0, 0, 0, 0, 0);
      if ((_DWORD)v6)
        goto LABEL_12;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
    FigCFDictionarySetValue((void *)gFigMetricEventDeserializeRegistry, SInt64, v8);
    os_unfair_lock_unlock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
    if (v8)
      CFRelease(v8);
    v6 = 0;
  }
LABEL_12:
  if (SInt64)
    CFRelease(SInt64);
  return v6;
}

uint64_t FigMetricEventDeserializeEvent(void *a1, CFTypeRef *a2)
{
  int64_t int64;
  const __CFAllocator *AllocatorForMedia;
  CFNumberRef SInt64;
  _QWORD *Value;
  uint64_t (*v8)(void *, CFTypeRef *);
  uint64_t v9;
  uint64_t v11;
  CFTypeRef cf;

  cf = 0;
  int64 = xpc_dictionary_get_int64(a1, "EventID");
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  SInt64 = FigCFNumberCreateSInt64(AllocatorForMedia, int64);
  if (gFigMetricEventDeserializeRegistry)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
    Value = FigCFDictionaryGetValue((const __CFDictionary *)gFigMetricEventDeserializeRegistry, SInt64);
    os_unfair_lock_unlock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
    if (Value)
    {
      v8 = (uint64_t (*)(void *, CFTypeRef *))Value[2];
      if (v8)
      {
        v9 = v8(a1, &cf);
        if (!(_DWORD)v9)
        {
          *a2 = cf;
          cf = 0;
        }
        if (SInt64)
          goto LABEL_7;
        goto LABEL_8;
      }
    }
    v11 = 4294947834;
  }
  else
  {
    v11 = 4294947833;
  }
  v9 = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  if (SInt64)
LABEL_7:
    CFRelease(SInt64);
LABEL_8:
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t FigMetricEventGetClassID()
{
  if (sRegisterFigMetricEventClassIDOnce != -1)
    dispatch_once_f(&sRegisterFigMetricEventClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventType);
  return sFigMetricEventClassID;
}

uint64_t RegisterFigMetricEventType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigMetricEventClassDesc, ClassID, 1, &sFigMetricEventClassID);
}

uint64_t FigMetricEventGetTypeID()
{
  if (sRegisterFigMetricEventClassIDOnce != -1)
    dispatch_once_f(&sRegisterFigMetricEventClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigMetricEventClassID);
}

uint64_t FigMetricMockEventForTestCreate(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v6;
  CFTypeRef cf;

  cf = 0;
  if (!a3)
    return FigSignalErrorAt(4294947836, 0, 0, 0, 0, 0, 0);
  if (sRegisterFigMetricEventClassIDOnce != -1)
    dispatch_once_f(&sRegisterFigMetricEventClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventType);
  v6 = CMDerivedObjectCreate(a1, (uint64_t)&kFigMetricEventClass_VTable, (_QWORD *)sFigMetricEventClassID, &cf);
  if ((_DWORD)v6)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *(_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf) = a2;
    *a3 = cf;
  }
  return v6;
}

void __ensureGlobalDeserializeRegister_block_invoke()
{
  const __CFAllocator *AllocatorForMedia;

  gFigMetricEventDeserializeRegistryLock = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  gFigMetricEventDeserializeRegistry = (uint64_t)CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (gFigMetricEventDeserializeRegistry)
    os_unfair_lock_unlock((os_unfair_lock_t)&gFigMetricEventDeserializeRegistryLock);
  else
    ensureGlobalDeserializeRegister_err = FigSignalErrorAt(4294947835, 0, 0, 0, 0, 0, 0);
}

uint64_t metutil_registerClass(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  **(_QWORD **)(a1 + 8) = result;
  return result;
}

CFStringRef me_copyFormattingDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("[FigMetricEvent %p]"), a1);
}

CFStringRef meMock_copyDebugDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("[FigMetricEvent %p]"), a1);
}

uint64_t me_getMetricEventID(uint64_t a1)
{
  return *(_QWORD *)CMBaseObjectGetDerivedStorage(a1);
}

uint64_t me_isMock()
{
  return 1;
}

uint64_t CMByteStreamCreateCompositeForRead(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t *a4, uint64_t *a5, CFTypeRef *a6)
{
  uint64_t v6;
  CFTypeRef *v7;
  uint64_t *v8;
  uint64_t *v9;
  _QWORD *ClassID;
  uint64_t v13;
  _QWORD *DerivedStorage;
  void *v15;
  uint64_t v16;
  CFTypeRef v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFTypeRef cf;

  if (!a6)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v6 = a2;
  if (a2 < 1)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v7 = a3;
  if (!a3)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v8 = a4;
  if (!a4)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v9 = a5;
  if (!a5)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  cf = 0;
  ClassID = (_QWORD *)CMByteStreamGetClassID();
  v13 = CMDerivedObjectCreate(a1, (uint64_t)&kFigCompositeByteStreamVTable, ClassID, &cf);
  if ((_DWORD)v13)
    return v13;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
  *DerivedStorage = v6;
  DerivedStorage[2] = 0;
  v15 = malloc_type_malloc(32 * v6, 0x1020040B07D1DCCuLL);
  DerivedStorage[1] = v15;
  if (v15)
  {
    v16 = -16;
    do
    {
      v17 = CFRetain(*v7);
      v18 = DerivedStorage[1];
      v19 = (_QWORD *)(v18 + v16);
      v20 = *v8++;
      v19[2] = v17;
      v19[3] = v20;
      v22 = *v9++;
      v21 = v22;
      v19[5] = v22;
      if (v16 == -16)
        v23 = 0;
      else
        v23 = v19[1] + *v19;
      v19[4] = v23;
      v16 += 32;
      ++v7;
      --v6;
    }
    while (v6);
    v24 = 0;
    DerivedStorage[3] = v21 + *(_QWORD *)(v18 + v16);
    *a6 = cf;
  }
  else
  {
    v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    CFRelease(cf);
  }
  return v24;
}

uint64_t FigCompositeReadByteStreamCreate(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t *a4, uint64_t *a5, CFTypeRef *a6)
{
  return CMByteStreamCreateCompositeForRead(a2, a1, a3, a4, a5, a6);
}

uint64_t FigCompositeByteStreamEqual(uint64_t a1, uint64_t a2)
{
  uint64_t *DerivedStorage;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  v4 = (_QWORD *)CMBaseObjectGetDerivedStorage(a2);
  if (*DerivedStorage == *v4)
  {
    if (*DerivedStorage < 1)
      return 1;
    v5 = v4;
    v6 = 0;
    v7 = 0;
    while (1)
    {
      v8 = DerivedStorage[1] + v6;
      v9 = v5[1] + v6;
      if (*(_QWORD *)(v8 + 8) != *(_QWORD *)(v9 + 8) || *(_QWORD *)(v8 + 24) != *(_QWORD *)(v9 + 24))
        break;
      result = CFEqual(*(CFTypeRef *)v8, *(CFTypeRef *)v9);
      if (!(_DWORD)result)
        return result;
      ++v7;
      v6 += 32;
      if (v7 >= *DerivedStorage)
        return 1;
    }
  }
  return 0;
}

void FigCompositeByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  uint64_t v3;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(uint64_t *)DerivedStorage >= 1)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(DerivedStorage + 8) + v2));
      ++v3;
      v2 += 32;
    }
    while (v3 < *(_QWORD *)DerivedStorage);
  }
  free(*(void **)(DerivedStorage + 8));
}

uint64_t FigCompositeByteStreamCopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFNumberRef *a4)
{
  uint64_t DerivedStorage;
  CFNumberRef v8;
  uint64_t result;
  uint64_t CMBaseObject;
  uint64_t (*v11)(uint64_t, const void *, uint64_t, CFNumberRef *);

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, CFSTR("FBS_EntireLength")) || CFEqual(a2, CFSTR("FBS_AvailableLength")))
  {
    v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, (const void *)(DerivedStorage + 24));
    result = 0;
    *a4 = v8;
  }
  else if (CFEqual(a2, CFSTR("FBS_URL")) || CFEqual(a2, CFSTR("FBS_FileType")))
  {
    CMBaseObject = CMByteStreamGetCMBaseObject(**(_QWORD **)(DerivedStorage + 8));
    v11 = *(uint64_t (**)(uint64_t, const void *, uint64_t, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                              + 8)
                                                                                  + 48);
    if (v11)
      return v11(CMBaseObject, a2, a3, a4);
    else
      return 4294954514;
  }
  else if (CFEqual(a2, CFSTR("FBS_MIMEType")))
  {
    return CMByteStreamCopyProperty(**(_QWORD **)(DerivedStorage + 8), (uint64_t)a2, a3, (uint64_t)a4);
  }
  else
  {
    return FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCompositeByteStreamSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *DerivedStorage;
  uint64_t v6;
  uint64_t v7;
  uint64_t CMBaseObject;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t);
  uint64_t result;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  v6 = 0;
  v7 = -1;
  while (1)
  {
    if (++v7 >= *DerivedStorage)
      return 0;
    CMBaseObject = CMByteStreamGetCMBaseObject(*(_QWORD *)(DerivedStorage[1] + v6));
    v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                             + 56);
    if (!v9)
      break;
    v6 += 32;
    result = v9(CMBaseObject, a2, a3);
    if ((_DWORD)result)
      return result;
  }
  return 4294954514;
}

uint64_t CMByteStreamCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t CMBaseObject;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);

  CMBaseObject = CMByteStreamGetCMBaseObject();
  v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                    + 48);
  if (v8)
    return v8(CMBaseObject, a2, a3, a4);
  else
    return 4294954514;
}

uint64_t FigCompositeByteStreamRead(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5)
{
  uint64_t *DerivedStorage;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t (*v26)(uint64_t, unint64_t, uint64_t, unint64_t, uint64_t *);
  BOOL v27;
  unint64_t *v28;
  uint64_t v30;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage < 1)
    return 4294954423;
  v9 = DerivedStorage;
  v10 = 0;
  v11 = 0;
  v12 = DerivedStorage[1];
  while (1)
  {
    v13 = *(_QWORD *)(v12 + v10 + 16);
    if (v13 <= a3 && *(_QWORD *)(v12 + v10 + 24) + v13 > a3)
      break;
    ++v11;
    v10 += 32;
    if (*DerivedStorage == v11)
      return 4294954423;
  }
  v28 = a5;
  v15 = 0;
  if (a2)
  {
    v16 = v11 - 1;
    do
    {
      if (++v16 >= *v9)
        break;
      v17 = a2 - v15;
      v30 = a2 - v15;
      v18 = (uint64_t *)(v9[1] + v10);
      v19 = v18[2];
      v20 = __OFSUB__(a3, v19);
      v21 = a3 - v19;
      if ((v21 < 0) ^ v20 | (v21 == 0))
        v22 = 0;
      else
        v22 = v21;
      v23 = v18[3] - v22;
      if (v17 > v23)
      {
        v30 = v18[3] - v22;
        v17 = v23;
      }
      v25 = *v18;
      v24 = v18[1];
      v26 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, unint64_t, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(*v18) + 16) + 8);
      if (!v26)
        return 4294954514;
      result = v26(v25, v17, v24 + v22, a4 + v15, &v30);
      if ((_DWORD)result)
        return result;
      v10 += 32;
      v15 += v30;
    }
    while (v15 < a2);
  }
  if (v15)
    v27 = 1;
  else
    v27 = a2 == 0;
  if (v27)
    result = 0;
  else
    result = 4294954423;
  v9[2] = v15 + a3;
  if (v28)
    *v28 = v15;
  return result;
}

uint64_t FigCompositeByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *DerivedStorage;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t, uint64_t, uint64_t *);
  uint64_t v21;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  if (!a3)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v6 = DerivedStorage;
  v7 = *DerivedStorage;
  if (*DerivedStorage < 1)
    return 4294954423;
  v8 = 0;
  v9 = 0;
  v10 = DerivedStorage[1];
  while (1)
  {
    v11 = *(_QWORD *)(v10 + v8 + 16);
    if (v11 <= a2 && *(_QWORD *)(v10 + v8 + 24) + v11 > a2)
      break;
    ++v9;
    v8 += 32;
    if (v7 == v9)
      return 4294954423;
  }
  if (v9 >= v7)
  {
    v13 = 0;
LABEL_20:
    result = 0;
    *a3 = v13;
  }
  else
  {
    v13 = 0;
    while (1)
    {
      v21 = 0;
      v14 = (uint64_t *)(v10 + v8);
      v15 = v14[2];
      v16 = __OFSUB__(a2, v15);
      v17 = a2 - v15;
      v18 = ((v17 < 0) ^ v16) | (v17 == 0) ? 0 : v17;
      v19 = *v14;
      v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(*v14) + 16) + 24);
      if (!v20)
        return 4294954514;
      result = v20(v19, v18, &v21);
      if ((_DWORD)result)
        return result;
      v13 += v21;
      v10 = v6[1];
      if (v21 + v18 >= *(_QWORD *)(v10 + v8 + 24) + *(_QWORD *)(v10 + v8 + 8))
      {
        ++v9;
        v8 += 32;
        if (v9 < *v6)
          continue;
      }
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t FigCompositeByteStreamReadAndCreateBlockBuffer(uint64_t a1, uint64_t appended, uint64_t a3, CMBlockBufferRef *a4, unint64_t *a5)
{
  uint64_t *DerivedStorage;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CMBlockBufferRef v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t (*v28)(uint64_t, unint64_t, uint64_t, CMBlockBufferRef *, uint64_t *);
  uint64_t v29;
  CMBlockBufferRef *v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  CMBlockBufferRef targetBBuf;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  targetBBuf = 0;
  if (*DerivedStorage < 1)
    return 4294954423;
  v10 = DerivedStorage;
  v11 = 0;
  v12 = 0;
  v13 = DerivedStorage[1];
  while (1)
  {
    v14 = *(_QWORD *)(v13 + v11 + 16);
    if (v14 <= a3 && *(_QWORD *)(v13 + v11 + 24) + v14 > a3)
      break;
    ++v12;
    v11 += 32;
    if (*DerivedStorage == v12)
      return 4294954423;
  }
  if (appended)
  {
    v30 = a4;
    v31 = a5;
    v16 = 0;
    v17 = 0;
    v18 = v12 - 1;
    v32 = appended;
    while (1)
    {
      if (++v18 >= *v10)
      {
        appended = 4294954423;
        goto LABEL_28;
      }
      v19 = appended - v17;
      v33 = v19;
      v20 = (uint64_t *)(v10[1] + v11);
      v21 = v20[2];
      v22 = __OFSUB__(a3, v21);
      v23 = a3 - v21;
      if ((v23 < 0) ^ v22 | (v23 == 0))
        v24 = 0;
      else
        v24 = v23;
      v25 = v20[3] - v24;
      if (v19 > v25)
      {
        v33 = v20[3] - v24;
        v19 = v25;
      }
      targetBBuf = 0;
      v27 = *v20;
      v26 = v20[1];
      v28 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t, CMBlockBufferRef *, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(*v20) + 16) + 32);
      if (!v28)
        break;
      v29 = v28(v27, v19, v26 + v24, &targetBBuf, &v33);
      if ((_DWORD)v29)
      {
        appended = v29;
        if (!v16)
          return appended;
LABEL_32:
        CFRelease(v16);
        return appended;
      }
      if (v16)
      {
        appended = CMBlockBufferAppendBufferReference(v16, targetBBuf, 0, 0, 0);
        if (targetBBuf)
          CFRelease(targetBBuf);
        if ((_DWORD)appended)
          goto LABEL_32;
      }
      else
      {
        v16 = targetBBuf;
      }
      v11 += 32;
      appended = v32;
      v17 += v33;
      if (v17 >= v32)
      {
        appended = 0;
LABEL_28:
        a4 = v30;
        a5 = v31;
        goto LABEL_29;
      }
    }
    appended = 4294954514;
    if (!v16)
      return appended;
    goto LABEL_32;
  }
  v17 = 0;
  v16 = 0;
LABEL_29:
  v10[2] = v17 + a3;
  *a4 = v16;
  if (a5)
    *a5 = v17;
  return appended;
}

uint64_t CMByteStreamCreateForBlockBuffer(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _QWORD *ClassID;
  _QWORD *DerivedStorage;
  CFTypeRef v12;
  uint64_t v13[7];

  if (a3)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v13[5] = v4;
  v13[6] = v5;
  v13[0] = 0;
  ClassID = (_QWORD *)CMByteStreamGetClassID();
  result = CMDerivedObjectCreate(a1, (uint64_t)&kFigBBufByteStreamVTable, ClassID, v13);
  if (!(_DWORD)result)
  {
    DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(v13[0]);
    if (a2)
      v12 = CFRetain(a2);
    else
      v12 = 0;
    result = 0;
    *DerivedStorage = v12;
    *a4 = v13[0];
  }
  return result;
}

uint64_t CMByteStreamCreateWritableForBlockBuffer(const __CFAllocator *a1, void *a2, int a3, CFAllocatorRef Default, __int128 *a5, CFTypeRef *a6)
{
  _QWORD *ClassID;
  uint64_t Empty;
  uint64_t DerivedStorage;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  CFTypeRef cf;

  cf = 0;
  if (!a2 || a3)
  {
    Empty = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    ClassID = (_QWORD *)CMByteStreamGetClassID();
    Empty = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigBBufByteStreamVTable, ClassID, &cf);
    if (!(_DWORD)Empty)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      v14 = DerivedStorage;
      if (a5)
      {
        v15 = *a5;
        *(_OWORD *)(DerivedStorage + 76) = *(__int128 *)((char *)a5 + 12);
        *(_OWORD *)(DerivedStorage + 64) = v15;
        *(_BYTE *)(DerivedStorage + 92) = 1;
        *(_QWORD *)(DerivedStorage + 56) = 0;
      }
      else
      {
        if (!Default)
          Default = CFAllocatorGetDefault();
        *(_QWORD *)(v14 + 56) = Default;
        CFRetain(Default);
      }
      Empty = CMBlockBufferCreateEmpty(a1, 0x53u, 0, (CMBlockBufferRef *)(v14 + 40));
      if (!(_DWORD)Empty)
      {
        if (!CMBlockBufferGetDataLength((CMBlockBufferRef)a2)
          || (Empty = CMBlockBufferAssureBlockMemory((CMBlockBufferRef)a2), !(_DWORD)Empty))
        {
          v16 = 0;
          *(_QWORD *)v14 = CFRetain(a2);
          *a6 = cf;
          return v16;
        }
      }
    }
  }
  v16 = Empty;
  if ((_DWORD)Empty && cf)
    CFRelease(cf);
  return v16;
}

uint64_t FigByteStreamCreateForBlockBuffer(const void *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  return CMByteStreamCreateForBlockBuffer(a3, a1, a2, a4);
}

uint64_t FigBBufByteStreamEqual(uint64_t a1, uint64_t a2)
{
  CFTypeRef *DerivedStorage;
  const void *v4;

  DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage(a1);
  v4 = *(const void **)CMBaseObjectGetDerivedStorage(a2);
  return CFEqual(*DerivedStorage, v4);
}

void FigBBufByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_QWORD *)DerivedStorage)
    CFRelease(*(CFTypeRef *)DerivedStorage);
  v2 = *(const void **)(DerivedStorage + 40);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(DerivedStorage + 56);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(DerivedStorage + 8);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(DerivedStorage + 16);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(DerivedStorage + 32);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(DerivedStorage + 24);
  if (v7)
    CFRelease(v7);
}

uint64_t FigBBufByteStreamCopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v7;
  size_t DataLength;
  void *SInt64;
  void *v10;
  uint64_t result;
  const void **v12;
  const void *v13;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, CFSTR("FBS_EntireLength")) || CFEqual(a2, CFSTR("FBS_AvailableLength")))
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    DataLength = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)DerivedStorage);
    SInt64 = FigCFNumberCreateSInt64(v7, DataLength);
LABEL_4:
    v10 = SInt64;
    result = 0;
    *a4 = v10;
    return result;
  }
  if (CFEqual(a2, CFSTR("FBS_EntireLengthAvailableOnDemand")))
    goto LABEL_6;
  if (CFEqual(a2, CFSTR("FBS_URL")))
  {
    v13 = *(const void **)(DerivedStorage + 8);
    if (v13)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_FileType")))
  {
    v13 = *(const void **)(DerivedStorage + 32);
    if (v13)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_MIMEType")))
  {
    v13 = *(const void **)(DerivedStorage + 16);
    if (v13)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_UTI")))
  {
    v13 = *(const void **)(DerivedStorage + 24);
    if (v13)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("DoesReadAhead")) || CFEqual(a2, CFSTR("FBS_ReadSupported")))
  {
LABEL_6:
    v12 = (const void **)MEMORY[0x1E0C9AE50];
LABEL_7:
    v13 = *v12;
LABEL_8:
    SInt64 = (void *)CFRetain(v13);
    goto LABEL_4;
  }
  if (CFEqual(a2, CFSTR("FBS_WriteSupported")))
  {
    v12 = (const void **)MEMORY[0x1E0C9AE50];
    if (!*(_QWORD *)(DerivedStorage + 40))
      v12 = (const void **)MEMORY[0x1E0C9AE40];
    goto LABEL_7;
  }
  return FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBBufByteStreamSetProperty(const void *a1, const void *a2, const __CFString *a3)
{
  _QWORD *DerivedStorage;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  const void *v10;
  CFTypeID v12;
  const void *v13;
  const __CFAllocator *v14;
  CFTypeID v15;
  const void *v16;
  const __CFAllocator *v17;
  uint64_t v18;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (CFEqual(a2, CFSTR("FBS_URL")))
  {
    if (!a3 || (v7 = CFGetTypeID(a3), v7 == CFURLGetTypeID()))
    {
      v8 = (const void *)DerivedStorage[1];
      if (v8)
        CFRelease(v8);
      DerivedStorage[1] = a3;
      if (!a3)
        return 0;
      goto LABEL_14;
    }
    goto LABEL_34;
  }
  if (CFEqual(a2, CFSTR("FBS_FileType")))
  {
    if (!a3 || (v9 = CFGetTypeID(a3), v9 == CFNumberGetTypeID()))
    {
      v10 = (const void *)DerivedStorage[4];
      if (v10)
        CFRelease(v10);
      DerivedStorage[4] = a3;
      if (!a3)
        return 0;
LABEL_14:
      CFRetain(a3);
      return 0;
    }
    goto LABEL_34;
  }
  if (CFEqual(a2, CFSTR("FBS_MIMEType")))
  {
    if (!a3 || (v12 = CFGetTypeID(a3), v12 == CFStringGetTypeID()))
    {
      v13 = (const void *)DerivedStorage[2];
      if (v13)
        CFRelease(v13);
      if (a3)
      {
        v14 = CFGetAllocator(a1);
        DerivedStorage[2] = CFStringCreateCopy(v14, a3);
      }
      else
      {
        DerivedStorage[2] = 0;
      }
      return 0;
    }
    goto LABEL_34;
  }
  if (CFEqual(a2, CFSTR("FBS_UTI")))
  {
    if (!a3 || (v15 = CFGetTypeID(a3), v15 == CFStringGetTypeID()))
    {
      v16 = (const void *)DerivedStorage[3];
      if (v16)
        CFRelease(v16);
      if (a3)
      {
        v17 = CFGetAllocator(a1);
        DerivedStorage[3] = CFStringCreateCopy(v17, a3);
      }
      else
      {
        DerivedStorage[3] = 0;
      }
      return 0;
    }
LABEL_34:
    v18 = 4294954424;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  v18 = 4294954512;
  return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
}

uint64_t FigBBufByteStreamRead(uint64_t a1, size_t a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t CMBaseObject;
  CMBlockBufferRef *DerivedStorage;
  CMBlockBufferRef *v11;
  size_t DataLength;
  size_t v13;
  uint64_t result;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = (CMBlockBufferRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  if ((a3 & 0x8000000000000000) != 0)
  {
    result = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
    v13 = 0;
    if (!a5)
      return result;
    goto LABEL_16;
  }
  v11 = DerivedStorage;
  DataLength = CMBlockBufferGetDataLength(*DerivedStorage);
  if (DataLength - a3 >= a2)
    v13 = a2;
  else
    v13 = DataLength - a3;
  if (DataLength <= a3 || v13 == 0)
  {
    v13 = 0;
    if (a2)
      result = 4294954423;
    else
      result = 0;
    if (a5)
      goto LABEL_16;
  }
  else
  {
    result = CMBlockBufferCopyDataBytes(*v11, a3, v13, a4);
    if (a5)
LABEL_16:
      *a5 = v13;
  }
  return result;
}

uint64_t FigBBufByteStreamWrite(uint64_t a1, size_t a2, size_t a3, char *a4, size_t *a5)
{
  uint64_t CMBaseObject;
  uint64_t DerivedStorage;
  size_t DataLength;
  size_t v12;
  size_t v13;
  uint64_t result;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t *v18;
  size_t v19;
  size_t v20;
  size_t v21;
  const CMBlockBufferCustomBlockSource *v22;
  uint64_t v23;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  DataLength = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)DerivedStorage);
  if (!*(_QWORD *)(DerivedStorage + 40))
  {
    v23 = 4294954419;
    goto LABEL_41;
  }
  if (!a4 || (a3 & 0x8000000000000000) != 0)
  {
    v23 = 4294954424;
LABEL_41:
    result = FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
    goto LABEL_42;
  }
  if (!a2)
    goto LABEL_35;
  v12 = DataLength;
  if (DataLength <= a3)
  {
    v15 = a2;
  }
  else
  {
    if (DataLength - a3 >= a2)
      v13 = a2;
    else
      v13 = DataLength - a3;
    result = CMBlockBufferReplaceDataBytes(a4, *(CMBlockBufferRef *)DerivedStorage, a3, v13);
    if ((_DWORD)result)
      goto LABEL_42;
    v15 = a2 - v13;
    if (a2 == v13)
      goto LABEL_35;
    a3 += v13;
    a4 += v13;
  }
  if (a3 >= v12)
    v16 = a3 - v12;
  else
    v16 = 0;
  v18 = (size_t *)(DerivedStorage + 104);
  v17 = *(_QWORD *)(DerivedStorage + 104);
  if (v17)
  {
    if (a3 <= v12)
    {
LABEL_23:
      if (v15 >= v17)
        v20 = v17;
      else
        v20 = v15;
      memcpy(*(void **)(DerivedStorage + 96), a4, v20);
      v15 -= v20;
      ConsumeSomeBacking(DerivedStorage, v20);
      if (!v15)
      {
LABEL_35:
        result = 0;
        if (!a5)
          return result;
        goto LABEL_36;
      }
      v16 = 0;
      a4 += v20;
      goto LABEL_28;
    }
    if (v16 >= v17)
      v19 = *(_QWORD *)(DerivedStorage + 104);
    else
      v19 = v16;
    bzero(*(void **)(DerivedStorage + 96), v19);
    ConsumeSomeBacking(DerivedStorage, v19);
    v16 -= v19;
    if (!v16)
    {
      v17 = *v18;
      if (*v18)
        goto LABEL_23;
      v16 = 0;
    }
  }
LABEL_28:
  v21 = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(DerivedStorage + 40));
  if (*(_BYTE *)(DerivedStorage + 92))
    v22 = (const CMBlockBufferCustomBlockSource *)(DerivedStorage + 64);
  else
    v22 = 0;
  result = CMBlockBufferAppendMemoryBlock(*(CMBlockBufferRef *)(DerivedStorage + 40), 0, (v15 + v16 + 0x3FFF) & 0xFFFFFFFFFFFFC000, *(CFAllocatorRef *)(DerivedStorage + 56), v22, 0, (v15 + v16 + 0x3FFF) & 0xFFFFFFFFFFFFC000, 1u);
  if (!(_DWORD)result)
  {
    CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(DerivedStorage + 40), v21, (size_t *)(DerivedStorage + 104), 0, (char **)(DerivedStorage + 96));
    if (v16)
      bzero(*(void **)(DerivedStorage + 96), v16);
    memcpy((void *)(*(_QWORD *)(DerivedStorage + 96) + v16), a4, v15);
    ConsumeSomeBacking(DerivedStorage, v15 + v16);
    goto LABEL_35;
  }
LABEL_42:
  a2 = 0;
  if (!a5)
    return result;
LABEL_36:
  *a5 = a2;
  return result;
}

uint64_t FigBBufByteStreamGetAvailableLengthAtOffset(uint64_t a1, size_t a2, size_t *a3)
{
  uint64_t CMBaseObject;
  CMBlockBufferRef *DerivedStorage;
  OSStatus DataPointer;
  size_t v8;
  size_t totalLengthOut;

  totalLengthOut = 0;
  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = (CMBlockBufferRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (!a3)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  if ((a2 & 0x8000000000000000) != 0)
  {
    v8 = 0;
  }
  else
  {
    DataPointer = CMBlockBufferGetDataPointer(*DerivedStorage, a2, 0, &totalLengthOut, 0);
    v8 = 0;
    if (!DataPointer)
      v8 = totalLengthOut - a2;
  }
  *a3 = v8;
  return 0;
}

uint64_t FigBBufByteStreamReadAndCreateBlockBuffer(const void *a1, size_t a2, size_t a3, CMBlockBufferRef *a4, size_t *a5)
{
  uint64_t CMBaseObject;
  CMBlockBufferRef *DerivedStorage;
  CMBlockBufferRef *v12;
  size_t DataLength;
  size_t v14;
  const __CFAllocator *v16;
  uint64_t result;
  CMBlockBufferRef blockBufferOut;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = (CMBlockBufferRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  blockBufferOut = 0;
  if ((a3 & 0x8000000000000000) != 0)
  {
    result = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
    v14 = 0;
    if (!a5)
      goto LABEL_17;
    goto LABEL_16;
  }
  v12 = DerivedStorage;
  DataLength = CMBlockBufferGetDataLength(*DerivedStorage);
  if (DataLength - a3 >= a2)
    v14 = a2;
  else
    v14 = DataLength - a3;
  if (DataLength <= a3 || v14 == 0)
  {
    v14 = 0;
    if (a2)
      result = 4294954423;
    else
      result = 0;
    if (a5)
      goto LABEL_16;
  }
  else
  {
    v16 = CFGetAllocator(a1);
    result = CMBlockBufferCreateWithBufferReference(v16, *v12, a3, v14, 0, &blockBufferOut);
    if (a5)
LABEL_16:
      *a5 = v14;
  }
LABEL_17:
  *a4 = blockBufferOut;
  return result;
}

uint64_t ConsumeSomeBacking(uint64_t a1, size_t dataLength)
{
  uint64_t result;
  size_t v5;

  result = CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)a1, *(CMBlockBufferRef *)(a1 + 40), *(_QWORD *)(a1 + 48), dataLength, 4u);
  *(_QWORD *)(a1 + 48) += dataLength;
  v5 = *(_QWORD *)(a1 + 104) - dataLength;
  *(_QWORD *)(a1 + 104) = v5;
  if (v5)
    v5 = *(_QWORD *)(a1 + 96) + dataLength;
  *(_QWORD *)(a1 + 96) = v5;
  return result;
}

uint64_t FigCaptionDynamicStyleGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
  return sFigCaptionDynamicStyleID;
}

uint64_t RegisterFigCaptionDynamicStyleType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionDynamicStyleID = result;
  return result;
}

uint64_t FigCaptionDynamicStyleCreateMutable(const __CFAllocator *a1, const void *a2, _QWORD *a3)
{
  uint64_t Instance;
  _QWORD *v7;
  CFMutableDictionaryRef Mutable;
  uint64_t v9;

  if (a2 && a3)
  {
    FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v7 = (_QWORD *)Instance;
      Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v7[2] = Mutable;
      if (Mutable)
      {
        v9 = FigCaptionDynamicStyleAddKeyFrameValue((uint64_t)v7, a2, 0.0);
        if (!(_DWORD)v9)
        {
          *a3 = v7;
          return v9;
        }
      }
      else
      {
        FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        v9 = 0;
      }
      CFRelease(v7);
      return v9;
    }
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionDynamicStyleAddKeyFrameValue(uint64_t a1, const void *a2, double a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  const void *v7;
  double valuePtr;

  valuePtr = a3;
  if (!a1 || a3 < 0.0 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
  if (!v5)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  v6 = v5;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v5, a2);
  v7 = *(const void **)(a1 + 24);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 24) = 0;
  }
  CFRelease(v6);
  return 0;
}

uint64_t FigCaptionDynamicStyleCreate(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v4;
  CFTypeRef cf;

  cf = 0;
  if (!a3)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v4 = FigCaptionDynamicStyleCreateMutable(a1, a2, &cf);
  if ((_DWORD)v4)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *a3 = cf;
  }
  return v4;
}

CFIndex FigCaptionDynamicStyleGetKeyFrameCount(CFIndex result)
{
  uint64_t v1;
  const __CFArray *v2;

  if (result)
  {
    v1 = result;
    v2 = *(const __CFArray **)(result + 24);
    if (!v2)
    {
      fcds_initializeSortedKeyFrameValues(v1);
      v2 = *(const __CFArray **)(v1 + 24);
    }
    return CFArrayGetCount(v2);
  }
  return result;
}

void fcds_initializeSortedKeyFrameValues(uint64_t a1)
{
  CFIndex Count;
  CFMutableArrayRef v3;
  CFIndex v4;
  CFTypeRef *v5;
  CFTypeRef *ValueAtIndex;
  const void *v7;
  CFArrayCallBacks v8;
  CFRange v9;

  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
  *(_OWORD *)&v8.version = xmmword_1E28DA6B0;
  *(_OWORD *)&v8.release = unk_1E28DA6C0;
  v8.equal = 0;
  v3 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, &v8);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)fcds_appendRelativeTimeAndValueToArray, v3);
  v9.location = 0;
  v9.length = Count;
  CFArraySortValues(v3, v9, (CFComparatorFunction)fcds_compareRelativeTime, 0);
  if (CFArrayGetCount(v3) >= 1)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(v3, v4);
      if (v5 && FigCFEqual(v5[1], ValueAtIndex[1]))
      {
        CFArrayRemoveValueAtIndex(v3, v4);
      }
      else
      {
        ++v4;
        v5 = ValueAtIndex;
      }
    }
    while (v4 < CFArrayGetCount(v3));
  }
  v7 = *(const void **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v3;
  if (v3)
    CFRetain(v3);
  if (v7)
    CFRelease(v7);
  if (v3)
    CFRelease(v3);
}

uint64_t FigCaptionDynamicStyleCopyKeyFrameValueAtIndex(CFIndex a1, CFIndex a2, _QWORD *a3, _QWORD *a4)
{
  CFIndex KeyFrameCount;
  const __CFArray *v9;
  _QWORD *ValueAtIndex;
  CFTypeRef v11;

  KeyFrameCount = FigCaptionDynamicStyleGetKeyFrameCount(a1);
  if (!a1 || a2 < 0 || KeyFrameCount <= a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v9 = *(const __CFArray **)(a1 + 24);
  if (!v9)
  {
    fcds_initializeSortedKeyFrameValues(a1);
    v9 = *(const __CFArray **)(a1 + 24);
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v9, a2);
  if (a3)
    *a3 = *ValueAtIndex;
  if (a4)
  {
    v11 = (CFTypeRef)ValueAtIndex[1];
    if (v11)
      v11 = CFRetain(v11);
    *a4 = v11;
  }
  return 0;
}

uint64_t FigCaptionDynamicStyleCopyKeyFrameValueAtRelativeTime(CFIndex a1, _QWORD *a2, _QWORD *a3, double a4)
{
  CFIndex KeyFrameCount;
  CFIndex v9;
  const __CFArray *v10;
  CFIndex v11;
  CFIndex v12;
  double *ValueAtIndex;
  _BOOL8 v14;
  CFIndex v15;
  _QWORD *v16;
  CFTypeRef v17;
  double v19[2];
  CFRange v20;

  KeyFrameCount = FigCaptionDynamicStyleGetKeyFrameCount(a1);
  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v9 = KeyFrameCount;
  if (KeyFrameCount <= 0)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v10 = *(const __CFArray **)(a1 + 24);
  if (!v10)
  {
    fcds_initializeSortedKeyFrameValues(a1);
    v10 = *(const __CFArray **)(a1 + 24);
  }
  v19[0] = a4;
  v19[1] = 0.0;
  v20.location = 0;
  v20.length = v9;
  v11 = CFArrayBSearchValues(v10, v20, v19, (CFComparatorFunction)fcds_compareRelativeTime, 0);
  if (v11 >= v9)
  {
    v15 = v9 - 1;
  }
  else
  {
    v12 = v11;
    if (v11)
    {
      ValueAtIndex = (double *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v11);
      v14 = v19[0] > *ValueAtIndex || v19[0] < *ValueAtIndex;
      v15 = v12 - v14;
    }
    else
    {
      v15 = 0;
    }
  }
  v16 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v15);
  if (a2)
    *a2 = *v16;
  if (a3)
  {
    v17 = (CFTypeRef)v16[1];
    if (v17)
      v17 = CFRetain(v17);
    *a3 = v17;
  }
  return 0;
}

uint64_t fcds_compareRelativeTime(double *a1, double *a2)
{
  if (*a1 < *a2)
    return -1;
  else
    return *a1 > *a2;
}

CFDictionaryRef *FigCaptionDynamicStyleGetInitialValue(CFDictionaryRef *a1)
{
  CFDictionaryRef *Value;
  CFNumberRef v2;
  uint64_t valuePtr;

  Value = a1;
  valuePtr = 0;
  if (a1)
  {
    v2 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
    Value = (CFDictionaryRef *)CFDictionaryGetValue(Value[2], v2);
    if (v2)
      CFRelease(v2);
  }
  return Value;
}

uint64_t fcds_Init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

void fcds_Finalize(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 24);
  if (v3)
    CFRelease(v3);
}

CFTypeRef *fcds_Equal(CFTypeRef *result, CFTypeRef *a2)
{
  CFTypeRef *v3;
  CFTypeID v4;
  CFTypeID v5;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID(result);
    FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
    result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionDynamicStyleID)
      {
        v5 = CFGetTypeID(a2);
        FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
        if (v5 == sFigCaptionDynamicStyleID)
          return (CFTypeRef *)(CFEqual(v3[2], a2[2]) != 0);
        else
          return 0;
      }
    }
  }
  return result;
}

uint64_t fcds_Hash(const void *a1)
{
  CFTypeID v2;
  CFIndex KeyFrameCount;
  CFIndex v4;
  CFIndex v5;
  uint64_t v6;
  double v8;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&sRegisterFigCaptionDynamicStyleTypeOnce, (void (*)(void))RegisterFigCaptionDynamicStyleType);
  if (v2 != sFigCaptionDynamicStyleID)
    return 0;
  KeyFrameCount = FigCaptionDynamicStyleGetKeyFrameCount((CFIndex)a1);
  if (!KeyFrameCount)
    return 0;
  v4 = KeyFrameCount;
  v5 = 0;
  v6 = 0;
  v8 = 0.0;
  do
  {
    if (FigCaptionDynamicStyleCopyKeyFrameValueAtIndex((CFIndex)a1, v5, &v8, 0))
      break;
    v6 ^= (unint64_t)(v8 * 1000.0);
    ++v5;
  }
  while (v4 != v5);
  return v6;
}

CFStringRef fcds_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionDynamicStyle %p]"), a1);
}

__CFString *fcds_CopyDebugDesc(CFIndex a1)
{
  __CFString *Mutable;
  CFIndex KeyFrameCount;
  CFIndex v4;
  CFTypeRef cf;
  uint64_t v7;

  Mutable = CFStringCreateMutable(0, 0);
  KeyFrameCount = FigCaptionDynamicStyleGetKeyFrameCount(a1);
  cf = 0;
  CFStringAppendFormat(Mutable, 0, CFSTR("FigCaptionDynamicStyle (number of values = %ld)\n"), KeyFrameCount);
  if (KeyFrameCount)
  {
    v4 = 0;
    v7 = 0;
    while (!FigCaptionDynamicStyleCopyKeyFrameValueAtIndex(a1, v4, &v7, &cf))
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("  %3.2f : %@\n"), v7, cf);
      if (KeyFrameCount - 1 == v4)
        break;
      ++v4;
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
    }
    if (cf)
      CFRelease(cf);
  }
  return Mutable;
}

void fcds_appendRelativeTimeAndValueToArray(const __CFNumber *a1, uint64_t a2, __CFArray *a3)
{
  _QWORD *v6;

  v6 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 16, 0);
  CFNumberGetValue(a1, kCFNumberDoubleType, v6);
  v6[1] = a2;
  CFArrayAppendValue(a3, v6);
}

uint64_t FigEndpointXPCDemuxCreate(const void *a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v6;
  _QWORD *ClassID;
  uint64_t v8;
  unint64_t *DerivedStorage;
  __CFNotificationCenter *DefaultLocalCenter;
  CFTypeRef cf;

  cf = 0;
  if (endpointXPCDemux_initializeLogging_initLoggingOnce == -1)
  {
    if (!a1)
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    dispatch_once(&endpointXPCDemux_initializeLogging_initLoggingOnce, &__block_literal_global_11);
    if (!a1)
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (!a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v6 = *MEMORY[0x1E0C9AE00];
  ClassID = (_QWORD *)FigEndpointExtendedGetClassID();
  v8 = CMDerivedObjectCreate(v6, (uint64_t)&kFigEndpointXPCDemuxVTable, ClassID, &cf);
  if ((_DWORD)v8)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    DerivedStorage = (unint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
    *DerivedStorage = (unint64_t)CFRetain(a1);
    DerivedStorage[1] = (unint64_t)CFRetain(a2);
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)cf, (CFNotificationCallback)endpointXPCDemux_handleCentralNotification, 0, *DerivedStorage, 0, 0);
    v8 = 0;
    *a3 = cf;
  }
  return v8;
}

uint64_t endpointXPCDemux_handleCentralNotification(__CFNotificationCenter *a1, const void *a2, const __CFString *a3, int a4, CFTypeRef cf)
{
  return CMNotificationCenterPostNotification(a1, a3, a2, cf);
}

BOOL FigEndpointIsXPCDemux(uint64_t a1)
{
  return a1 && (_UNKNOWN *)CMBaseObjectGetVTable(a1) == &kFigEndpointXPCDemuxVTable;
}

BOOL FigEndpointXPCDemuxEndpointsMatch(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *DerivedStorage;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  return *DerivedStorage == a2 && DerivedStorage[1] == a3;
}

uint64_t FigEndpointXPCDemux_Invalidate(uint64_t a1)
{
  uint64_t *DerivedStorage;
  uint64_t v2;
  uint64_t (*v3)(uint64_t);

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  v2 = *DerivedStorage;
  if (!*DerivedStorage)
    return 4294954516;
  v3 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(*DerivedStorage) + 8) + 24);
  if (v3)
    return v3(v2);
  else
    return 4294954514;
}

void FigEndpointXPCDemux_Finalize(const void *a1)
{
  uint64_t DerivedStorage;
  __CFNotificationCenter *DefaultLocalCenter;
  const void *v4;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)endpointXPCDemux_handleCentralNotification, 0, *(const void **)DerivedStorage);
  if (*(_QWORD *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(_QWORD *)DerivedStorage = 0;
  }
  v4 = *(const void **)(DerivedStorage + 8);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(DerivedStorage + 8) = 0;
  }
}

CFStringRef FigEndpointXPCDemux_CopyDebugDescription(uint64_t a1)
{
  _QWORD *DerivedStorage;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<FigEndpointXPCDemux %p: central=%@, sub=%@>"), a1, *DerivedStorage, DerivedStorage[1]);
}

uint64_t FigEndpointXPCDemux_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *DerivedStorage;
  uint64_t CMBaseObject;
  uint64_t (*v9)(uint64_t, const void *, uint64_t, uint64_t);

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  if (!CFEqual(a2, CFSTR("iOSEntityIsDoingTurnByTurn"))
    && !CFEqual(a2, CFSTR("CarEntityIsDoingTurnByTurn"))
    && !CFEqual(a2, CFSTR("CarEntityIsDoingVoiceRecognition"))
    && !CFEqual(a2, CFSTR("CarEntityOwnsScreen"))
    && !CFEqual(a2, CFSTR("CarEntityOwnsMainAudio"))
    && !CFEqual(a2, CFSTR("CarPlaySubEndpoint")))
  {
    return FigEndpointCopyProperty(DerivedStorage[1], (uint64_t)a2, a3, a4);
  }
  CMBaseObject = FigEndpointGetCMBaseObject(*DerivedStorage);
  v9 = *(uint64_t (**)(uint64_t, const void *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                     + 8)
                                                                         + 48);
  if (v9)
    return v9(CMBaseObject, a2, a3, a4);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_SetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *DerivedStorage;
  uint64_t CMBaseObject;
  uint64_t (*v7)(uint64_t, uint64_t, uint64_t);

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  CMBaseObject = FigEndpointGetCMBaseObject(*DerivedStorage);
  v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8) + 56);
  if (v7)
    return v7(CMBaseObject, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t CMBaseObject;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);

  CMBaseObject = FigEndpointGetCMBaseObject(a1);
  v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                    + 48);
  if (v8)
    return v8(CMBaseObject, a2, a3, a4);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_ActivateForFeaturesWithCompletionCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v9 = *(_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v9)
                                                                                          + 16)
                                                                              + 8);
  if (v10)
    return v10(v9, a2, a3, a4, a5);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_DeactivateWithCompletionCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);

  v7 = *(_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v7) + 16) + 16);
  if (v8)
    return v8(v7, a2, a3, a4);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_Dissociate(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t);

  v1 = *(_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  v2 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v1) + 16) + 32);
  if (v2)
    return v2(v1);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_SetDelegateRemoteControl(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v4)(uint64_t, uint64_t);

  v3 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 8);
  v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v3) + 16) + 56);
  if (v4)
    return v4(v3, a2);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_CreatePlaybackSession(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v4)(uint64_t, uint64_t);

  v3 = *(_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v3) + 16) + 72);
  if (v4)
    return v4(v3, a2);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_RequestCarUI(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 8);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_BorrowScreen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 16);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_UnborrowScreen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 24);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_TakeScreen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 32);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_DisableBluetoothConnectivityToDevice(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 40);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_DuckAudio(uint64_t a1, uint64_t a2)
{
  uint64_t FigEndpoint;
  char *v4;
  _QWORD *ClassID;
  uint64_t (*v6)(char *, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v4 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v4
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v4, ClassID)))
  {
    v4 = 0;
  }
  v6 = *(uint64_t (**)(char *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v4) + 24) + 48);
  if (v6)
    return v6(v4, a2);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_SetHIDInputMode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 56);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_CopyHIDInputMode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t FigEndpoint;
  char *v8;
  _QWORD *ClassID;
  uint64_t (*v10)(char *, uint64_t, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v8 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v8
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v8, ClassID)))
  {
    v8 = 0;
  }
  v10 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v8) + 24)
                                                                    + 64);
  if (v10)
    return v10(v8, a2, a3, a4);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_SendCommand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t FigEndpoint;
  char *v10;
  _QWORD *ClassID;
  uint64_t (*v12)(char *, uint64_t, uint64_t, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v10 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v10
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v10, ClassID)))
  {
    v10 = 0;
  }
  v12 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                         + 24)
                                                                             + 72);
  if (v12)
    return v12(v10, a2, a3, a4, a5);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_CreateRemoteControlSession(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 80);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_CreateCommChannel(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 88);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_SendData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t FigEndpoint;
  char *v10;
  _QWORD *ClassID;
  uint64_t (*v12)(char *, uint64_t, uint64_t, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v10 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v10
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v10, ClassID)))
  {
    v10 = 0;
  }
  v12 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                         + 24)
                                                                             + 96);
  if (v12)
    return v12(v10, a2, a3, a4, a5);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_CloseCommChannel(uint64_t a1, uint64_t a2)
{
  uint64_t FigEndpoint;
  char *v4;
  _QWORD *ClassID;
  uint64_t (*v6)(char *, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v4 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v4
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v4, ClassID)))
  {
    v4 = 0;
  }
  v6 = *(uint64_t (**)(char *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v4) + 24) + 104);
  if (v6)
    return v6(v4, a2);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_RequestScreenViewArea(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 112);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_CopyCurrentScreenViewArea(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)(CMBaseObjectGetDerivedStorage(FigEndpoint) + 8);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 120);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_AcquireAndCopyResource(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t FigEndpoint;
  char *v8;
  _QWORD *ClassID;
  uint64_t (*v10)(char *, uint64_t, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v8 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v8
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v8, ClassID)))
  {
    v8 = 0;
  }
  v10 = *(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v8) + 24)
                                                                    + 128);
  if (v10)
    return v10(v8, a2, a3, a4);
  else
    return 4294954514;
}

uint64_t FigEndpointXPCDemux_RelinquishResource(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  char *v6;
  _QWORD *ClassID;
  uint64_t (*v8)(char *, uint64_t, uint64_t);

  FigEndpoint = FigEndpointExtendedGetFigEndpoint();
  v6 = *(char **)CMBaseObjectGetDerivedStorage(FigEndpoint);
  if (!v6
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v6, ClassID)))
  {
    v6 = 0;
  }
  v8 = *(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v6) + 24) + 136);
  if (v8)
    return v8(v6, a2, a3);
  else
    return 4294954514;
}

uint64_t FigSecCopyOutmostBundleSignedWithSameCertificateAsCodeAtURL(const __CFURL *a1, CFURLRef *a2)
{
  uint64_t v4;
  CFAllocatorRef *v5;
  const __CFAllocator *v6;
  const __CFString *v7;
  Boolean v8;
  const __CFURL *v9;
  uint64_t v10;
  const __CFURL *PathComponent;
  CFURLRef v12;
  const __CFURL *v13;
  int v14;
  const __CFArray *Value;
  const __CFArray *v16;
  void *ValueAtIndex;
  void *v18;
  CFTypeID v19;
  int v20;
  CFDataRef v21;
  const __CFData *v22;
  CFTypeID v23;
  unint64_t Length;
  CC_LONG v25;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  unsigned __int8 *MutableBytePtr;
  __CFString *v29;
  const UInt8 *v30;
  CFIndex v31;
  const __CFString *v32;
  SecRequirementRef v33;
  const __CFAllocator *v34;
  CFStringRef v35;
  int v36;
  OSStatus v37;
  OSStatus v38;
  CFErrorRef v39;
  CFURLRef v40;
  CFURLRef v41;
  CFURLRef *v43;
  SecStaticCodeRef staticCode;
  CFStringRef string;
  SecRequirementRef requirement;
  CFErrorRef errors;
  CFTypeRef cf[130];

  cf[128] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  staticCode = 0;
  cf[0] = 0;
  v4 = FigCFURLCopyCanonicalPath(a1, cf);
  v5 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if ((_DWORD)v4)
  {
    v10 = v4;
    v9 = 0;
  }
  else
  {
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v7 = (const __CFString *)cf[0];
    v8 = CFURLHasDirectoryPath(a1);
    v9 = CFURLCreateWithFileSystemPath(v6, v7, kCFURLPOSIXPathStyle, v8);
    v10 = SecStaticCodeCreateWithPath(v9, 0, &staticCode);
  }
  if (cf[0])
    CFRelease(cf[0]);
  if (v9)
    CFRelease(v9);
  if ((_DWORD)v10)
  {
    v33 = 0;
    v12 = 0;
    goto LABEL_85;
  }
  cf[0] = 0;
  v10 = SecCodeCopyPath(staticCode, 0, (CFURLRef *)cf);
  v43 = a2;
  if ((_DWORD)v10)
  {
    v12 = 0;
  }
  else
  {
    if (CFURLHasDirectoryPath((CFURLRef)cf[0]))
    {
      if (!cf[0])
      {
        v12 = 0;
        goto LABEL_20;
      }
      PathComponent = (const __CFURL *)CFRetain(cf[0]);
    }
    else
    {
      PathComponent = CFURLCreateCopyDeletingLastPathComponent(*v5, (CFURLRef)cf[0]);
    }
    v12 = PathComponent;
  }
  if (cf[0])
    CFRelease(cf[0]);
  if ((_DWORD)v10)
  {
    v33 = 0;
    goto LABEL_85;
  }
  if (v12)
  {
    v13 = (const __CFURL *)CFRetain(v12);
    goto LABEL_21;
  }
LABEL_20:
  v13 = 0;
LABEL_21:
  requirement = 0;
  errors = 0;
  cf[0] = 0;
  v14 = SecCodeCopySigningInformation(staticCode, 2u, (CFDictionaryRef *)cf);
  if (!v14)
  {
    if (cf[0])
    {
      Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)cf[0], (const void *)*MEMORY[0x1E0CD6CE0]);
      if (Value)
      {
        v16 = Value;
        if (CFArrayGetCount(Value) > 0)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(v16, 0);
          if (ValueAtIndex)
          {
            v18 = ValueAtIndex;
            v19 = CFGetTypeID(ValueAtIndex);
            if (v19 == SecCertificateGetTypeID())
            {
              CFRetain(v18);
              v20 = 0;
              goto LABEL_30;
            }
          }
        }
      }
    }
    v14 = FigSignalErrorAt(4294949676, 0, 0, 0, 0, 0, 0);
  }
  v20 = v14;
  v18 = 0;
LABEL_30:
  if (cf[0])
    CFRelease(cf[0]);
  if (v20)
  {
    v33 = 0;
    if (!v18)
      goto LABEL_52;
    goto LABEL_51;
  }
  v21 = SecCertificateCopyData((SecCertificateRef)v18);
  if (v21)
  {
    v22 = v21;
    v23 = CFGetTypeID(v21);
    if (v23 != CFDataGetTypeID() || (Length = CFDataGetLength(v22), HIDWORD(Length)))
    {
      v20 = FigSignalErrorAt(4294949676, 0, 0, 0, 0, 0, 0);
      Mutable = 0;
    }
    else
    {
      v25 = Length;
      Mutable = CFDataCreateMutable(*v5, 20);
      CFDataSetLength(Mutable, 20);
      BytePtr = CFDataGetBytePtr(v22);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      CC_SHA1(BytePtr, v25, MutableBytePtr);
      v20 = 0;
    }
    CFRelease(v22);
    if (!v20)
    {
LABEL_38:
      v29 = CFStringCreateMutable(*v5, 0);
      v30 = CFDataGetBytePtr(Mutable);
      if (CFDataGetLength(Mutable) >= 1)
      {
        v31 = 0;
        do
          CFStringAppendFormat(v29, 0, CFSTR("%02x"), v30[v31++]);
        while (CFDataGetLength(Mutable) > v31);
      }
      if (Mutable)
        goto LABEL_42;
      goto LABEL_43;
    }
  }
  else
  {
    v20 = FigSignalErrorAt(4294949676, 0, 0, 0, 0, 0, 0);
    Mutable = 0;
    if (!v20)
      goto LABEL_38;
  }
  v29 = 0;
  if (Mutable)
LABEL_42:
    CFRelease(Mutable);
LABEL_43:
  if (v20)
  {
    v32 = 0;
    v33 = requirement;
  }
  else
  {
    v32 = CFStringCreateWithFormat(*v5, 0, CFSTR("certificate leaf = H\"%@\""), v29);
    v20 = SecRequirementCreateWithStringAndErrors(v32, 0, &errors, &requirement);
    v33 = requirement;
    if (!v20)
    {
      requirement = 0;
      goto LABEL_46;
    }
  }
  if (v33)
  {
    CFRelease(v33);
    v33 = 0;
  }
LABEL_46:
  if (v29)
    CFRelease(v29);
  if (v32)
    CFRelease(v32);
  if (!v18)
    goto LABEL_52;
LABEL_51:
  CFRelease(v18);
LABEL_52:
  if (errors)
    CFRelease(errors);
  if (!v20)
  {
    v34 = *v5;
    while (1)
    {
      v35 = CFURLCopyPath(v12);
      v36 = CFEqual(v35, CFSTR("/"));
      if (v35)
        CFRelease(v35);
      if (v36)
        break;
      requirement = 0;
      errors = 0;
      string = 0;
      v37 = FigCFURLCopyCanonicalPath(v12, &string);
      if (v37)
      {
        v38 = v37;
      }
      else
      {
        CFStringGetFileSystemRepresentation(string, (char *)cf, 1024);
        if (access((const char *)cf, 4))
        {
          v38 = -17621;
        }
        else
        {
          v38 = SecStaticCodeCreateWithPath(v12, 0, &errors);
          v39 = errors;
          if (!v38)
          {
            v38 = SecStaticCodeCheckValidityWithErrors(errors, 0, v33, &requirement);
            v39 = errors;
          }
          if (v39)
            CFRelease(v39);
        }
      }
      if (requirement)
        CFRelease(requirement);
      if (string)
        CFRelease(string);
      if (v38)
      {
        v40 = v13;
      }
      else
      {
        if (v12)
          CFRetain(v12);
        v40 = v12;
        if (v13)
        {
          CFRelease(v13);
          v40 = v12;
        }
      }
      v41 = CFURLCreateCopyDeletingLastPathComponent(v34, v12);
      if (v12)
        CFRelease(v12);
      v12 = v41;
      v13 = v40;
      if (v38 != -67062)
      {
        v12 = v41;
        v13 = v40;
        if (v38 != -67028)
        {
          v12 = v41;
          v13 = v40;
          if (v38)
            goto LABEL_84;
        }
      }
    }
  }
  v41 = v12;
  v40 = v13;
LABEL_84:
  v10 = 0;
  *v43 = v40;
  v12 = v41;
LABEL_85:
  if (staticCode)
    CFRelease(staticCode);
  if (v33)
    CFRelease(v33);
  if (v12)
    CFRelease(v12);
  return v10;
}

uint64_t FigSecCopyOutmostBundleSignedWithSameCertificateAsCodeOfMainBundle(_QWORD *a1)
{
  CFTypeRef v2;

  if (sEstablishOutmostContainerURLOfMainBundleOnce != -1)
    dispatch_once_f(&sEstablishOutmostContainerURLOfMainBundleOnce, 0, (dispatch_function_t)EstablishOutmostContainerURLOfMainBundle);
  v2 = (CFTypeRef)sOutmostContainerURLOfMainBundle;
  if (sOutmostContainerURLOfMainBundle)
    v2 = CFRetain((CFTypeRef)sOutmostContainerURLOfMainBundle);
  *a1 = v2;
  return sOutmostContainerURLOfMainBundleEstablishmentResult;
}

void EstablishOutmostContainerURLOfMainBundle()
{
  __CFBundle *MainBundle;
  const __CFURL *v1;

  MainBundle = CFBundleGetMainBundle();
  v1 = CFBundleCopyExecutableURL(MainBundle);
  sOutmostContainerURLOfMainBundleEstablishmentResult = FigSecCopyOutmostBundleSignedWithSameCertificateAsCodeAtURL(v1, (CFURLRef *)&sOutmostContainerURLOfMainBundle);
  if (v1)
    CFRelease(v1);
}

BOOL FigIsSecTaskGPUExtensionOfBrowserEngine(SecTaskRef task)
{
  _BOOL8 v2;
  CFTypeRef v3;

  if (sLoadBrowserFrameworkOnce != -1)
    dispatch_once(&sLoadBrowserFrameworkOnce, &__block_literal_global_12);
  v2 = 0;
  if (task)
  {
    if (s_SEBrowserEngineEntitlementGPU)
    {
      v3 = SecTaskCopyValueForEntitlement(task, (CFStringRef)s_SEBrowserEngineEntitlementGPU, 0);
      v2 = v3 == (CFTypeRef)*MEMORY[0x1E0C9AE50];
      if (v3)
        CFRelease(v3);
    }
  }
  return v2;
}

uint64_t *__loadBrowserEngineFramework_block_invoke()
{
  uint64_t *result;

  result = (uint64_t *)dlopen("/System/Library/Frameworks/BrowserEngineCore.framework/BrowserEngineCore", 4);
  if (result)
  {
    result = (uint64_t *)dlsym(result, "_BEBrowserEngineEntitlementRendering");
    s_SEBrowserEngineEntitlementGPU = *result;
  }
  return result;
}

uint64_t CMByteStreamGetClassID()
{
  FigThreadRunOnce(&CMByteStreamGetClassID_sRegisterFigByteStreamBaseTypeOnce, (void (*)(void))RegisterFigByteStreamBaseType);
  return sFigByteStreamClassID;
}

uint64_t CMByteStreamBaseGetTypeID()
{
  FigThreadRunOnce(&CMByteStreamGetClassID_sRegisterFigByteStreamBaseTypeOnce, (void (*)(void))RegisterFigByteStreamBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigByteStreamClassID);
}

uint64_t CMCreateContiguousBlockBufferFromStream(uint64_t a1, CFAllocatorRef allocator, size_t size, uint64_t a4, CMBlockBufferRef *a5, size_t *a6)
{
  void *v12;
  void *v13;
  uint64_t (*v14)(uint64_t, size_t, uint64_t, void *, size_t *);
  uint64_t v15;
  uint64_t v16;
  size_t dataLength;
  CMBlockBufferRef blockBufferOut;

  dataLength = 0;
  blockBufferOut = 0;
  if (!size)
  {
LABEL_11:
    v16 = 0;
    goto LABEL_12;
  }
  v12 = CFAllocatorAllocate(allocator, size, 0);
  if (v12)
  {
    v13 = v12;
    v14 = *(uint64_t (**)(uint64_t, size_t, uint64_t, void *, size_t *))(*(_QWORD *)(CMBaseObjectGetVTable(a1)
                                                                                           + 16)
                                                                               + 8);
    if (!v14)
    {
      v16 = 4294954514;
      goto LABEL_9;
    }
    v15 = v14(a1, size, a4, v13, &dataLength);
    if ((_DWORD)v15)
    {
LABEL_7:
      v16 = v15;
LABEL_9:
      CFAllocatorDeallocate(allocator, v13);
      goto LABEL_12;
    }
    if (dataLength)
    {
      v15 = CMBlockBufferCreateWithMemoryBlock(allocator, v13, size, allocator, 0, 0, dataLength, 0, &blockBufferOut);
      v16 = 0;
      if (!(_DWORD)v15)
        goto LABEL_12;
      goto LABEL_7;
    }
    CFAllocatorDeallocate(allocator, v13);
    goto LABEL_11;
  }
  v16 = FigSignalErrorAt(4294967188, 0, 0, 0, 0, 0, 0);
LABEL_12:
  *a5 = blockBufferOut;
  if (a6)
    *a6 = dataLength;
  return v16;
}

uint64_t CMByteStreamWriteBlockBuffer()
{
  uint64_t v0;
  OpaqueCMBlockBuffer *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  OpaqueCMBlockBuffer *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  size_t v14;
  size_t v15;
  char *v16;
  uint64_t (*v17)(uint64_t, size_t, unint64_t, char *, uint64_t *);
  char *dataPointerOut;
  uint64_t v19;
  size_t lengthAtOffsetOut;
  _BYTE destination[16384];
  uint64_t v22;

  v0 = MEMORY[0x1E0C80A78]();
  v6 = v5;
  v22 = *MEMORY[0x1E0C80C00];
  if (v3)
  {
    v7 = v4;
    v8 = v3;
    v9 = v2;
    v10 = v1;
    v11 = v0;
    v12 = 0;
    v19 = 0;
    lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    while (1)
    {
      result = CMBlockBufferGetDataPointer(v10, v12 + v9, &lengthAtOffsetOut, 0, &dataPointerOut);
      if ((_DWORD)result)
        goto LABEL_21;
      v14 = lengthAtOffsetOut;
      if (lengthAtOffsetOut >= v8 - v12)
      {
        lengthAtOffsetOut = v8 - v12;
        v14 = v8 - v12;
      }
      else if (!(lengthAtOffsetOut >> 14))
      {
        if (v8 - v12 >= 0x4000)
          v15 = 0x4000;
        else
          v15 = v8 - v12;
        lengthAtOffsetOut = v15;
        result = CMBlockBufferCopyDataBytes(v10, v12 + v9, v15, destination);
        if ((_DWORD)result)
          goto LABEL_21;
        dataPointerOut = destination;
        v14 = lengthAtOffsetOut;
      }
      v16 = dataPointerOut;
      v17 = *(uint64_t (**)(uint64_t, size_t, unint64_t, char *, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(v11) + 16)
                                                                                           + 16);
      if (!v17)
      {
        result = 4294954514;
LABEL_21:
        if (!v6)
          return result;
        goto LABEL_22;
      }
      result = v17(v11, v14, v12 + v7, v16, &v19);
      if ((_DWORD)result)
        goto LABEL_21;
      if (!v19)
        break;
      v12 += v19;
      if (v12 >= v8)
        goto LABEL_18;
    }
    result = FigSignalErrorAt(4294954423, 0, 0, 0, 0, 0, 0);
    if (v6)
      goto LABEL_22;
  }
  else
  {
    v12 = 0;
LABEL_18:
    result = 0;
    if (v6)
LABEL_22:
      *v6 = v12;
  }
  return result;
}

uint64_t CMByteStreamAppend(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v8)(uint64_t, _QWORD, uint64_t *);
  uint64_t result;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v12;

  v8 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 24);
  if (!v8)
    return 4294954514;
  v12 = 0;
  result = v8(a1, 0, &v12);
  if ((_DWORD)result)
    return result;
  v10 = v12;
  v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(a1)
                                                                                          + 16)
                                                                              + 16);
  if (v11)
    return v11(a1, a2, v10, a3, a4);
  else
    return 4294954514;
}

uint64_t CMByteStreamAppendBlockBuffer(uint64_t a1)
{
  uint64_t (*v2)(uint64_t, _QWORD, uint64_t *);
  uint64_t result;
  uint64_t v4;

  v2 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 24);
  if (!v2)
    return 4294954514;
  v4 = 0;
  result = v2(a1, 0, &v4);
  if (!(_DWORD)result)
    return CMByteStreamWriteBlockBuffer();
  return result;
}

pthread_mutex_t *FigByteStreamStatsSetupWorker(pthread_mutex_t *result)
{
  _QWORD *p_sig;

  if (result)
  {
    p_sig = &result->__sig;
    *(_OWORD *)&result->__opaque[24] = 0u;
    *(_OWORD *)&result->__opaque[40] = 0u;
    *(_OWORD *)&result->__sig = 0u;
    *(_OWORD *)&result->__opaque[8] = 0u;
    result = FigSimpleMutexCreate();
    *p_sig = result;
  }
  return result;
}

double FigByteStreamStatsTeardownWorker(uint64_t a1)
{
  uint64_t v2;
  double result;

  if (a1)
  {
    v2 = *(_QWORD *)a1;
    if (v2)
      FigSimpleMutexDestroy(v2);
    result = 0.0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

pthread_mutex_t *FigByteStreamStatsLogOneRead(pthread_mutex_t *result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6)
{
  pthread_mutex_t *v7;
  BOOL v8;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (result)
  {
    v7 = result;
    result = (pthread_mutex_t *)result->__sig;
    v8 = result && a4 == 0;
    if (v8 && a6 != 0)
    {
      v10 = a3 - a2;
      v11 = (unsigned __int128)((a3 - a2) * (__int128)0x20C49BA5E353F7CFLL) >> 64;
      FigSimpleMutexLock(result);
      ++*(_DWORD *)v7->__opaque;
      *(_QWORD *)&v7->__opaque[8] += a6;
      v12 = *(int *)&v7->__opaque[16];
      if (!(_DWORD)v12 || v12 > a6)
        *(_DWORD *)&v7->__opaque[16] = a6;
      v13 = (v11 >> 7) + ((unint64_t)v11 >> 63);
      if (*(int *)&v7->__opaque[20] < a6)
        *(_DWORD *)&v7->__opaque[20] = a6;
      v14 = *(_QWORD *)&v7->__opaque[32];
      *(_QWORD *)&v7->__opaque[24] += v13;
      if (v13 < v14 || v14 == 0)
        *(_QWORD *)&v7->__opaque[32] = v13;
      if (v13 > *(_QWORD *)&v7->__opaque[40])
        *(_QWORD *)&v7->__opaque[40] = v13;
      if (v10 < 1000000000)
      {
        if (v10 >= 500000000)
          ++*(_DWORD *)&v7->__opaque[52];
      }
      else
      {
        ++*(_DWORD *)&v7->__opaque[48];
      }
      return (pthread_mutex_t *)FigSimpleMutexUnlock((pthread_mutex_t *)v7->__sig);
    }
  }
  return result;
}

CFDictionaryRef FigByteStreamStatsCreateStatsDictionary(const __CFAllocator *a1, const void *a2, CFURLRef anURL, uint64_t a4)
{
  pthread_mutex_t *v6;
  CFStringRef v8;
  uint64_t v9;
  double v10;
  const __CFString *v11;
  const __CFAllocator *v12;
  CFDictionaryRef v13;
  uint64_t i;
  const void *v15;
  double v17;
  int valuePtr;
  void *values[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  CFTypeRef v25;
  void *keys[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  const __CFString *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v30 = xmmword_1E28DA9E0;
  v31 = *(_OWORD *)off_1E28DA9F0;
  v32 = CFSTR("ByteStreamType");
  *(_OWORD *)keys = xmmword_1E28DA9A0;
  v27 = *(_OWORD *)&off_1E28DA9B0;
  v28 = xmmword_1E28DA9C0;
  v29 = *(_OWORD *)&off_1E28DA9D0;
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  *(_OWORD *)values = 0u;
  v20 = 0u;
  valuePtr = 0;
  v17 = 0.0;
  if (a4 && (v6 = *(pthread_mutex_t **)a4) != 0)
  {
    if (anURL)
    {
      v8 = CFURLGetString(anURL);
      v6 = *(pthread_mutex_t **)a4;
    }
    else
    {
      v8 = 0;
    }
    FigSimpleMutexLock(v6);
    v9 = *(int *)(a4 + 8);
    if ((_DWORD)v9)
    {
      valuePtr = *(_QWORD *)(a4 + 16) / v9;
      v10 = (double)(*(_QWORD *)(a4 + 32) / v9);
    }
    else
    {
      v10 = 0.0;
    }
    if (v8)
      v11 = v8;
    else
      v11 = CFSTR("UNKNOWN");
    values[0] = (void *)CFRetain(v11);
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    values[1] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, (const void *)(a4 + 8));
    *(_QWORD *)&v20 = CFNumberCreate(v12, kCFNumberSInt64Type, (const void *)(a4 + 16));
    *((_QWORD *)&v20 + 1) = CFNumberCreate(v12, kCFNumberSInt32Type, (const void *)(a4 + 24));
    *(_QWORD *)&v21 = CFNumberCreate(v12, kCFNumberSInt32Type, (const void *)(a4 + 28));
    *((_QWORD *)&v21 + 1) = CFNumberCreate(v12, kCFNumberSInt32Type, &valuePtr);
    v17 = (double)*(uint64_t *)(a4 + 32) / 1000000.0;
    *(_QWORD *)&v22 = CFNumberCreate(v12, kCFNumberDoubleType, &v17);
    v17 = (double)*(uint64_t *)(a4 + 40) / 1000000.0;
    *((_QWORD *)&v22 + 1) = CFNumberCreate(v12, kCFNumberDoubleType, &v17);
    v17 = (double)*(uint64_t *)(a4 + 48) / 1000000.0;
    *(_QWORD *)&v23 = CFNumberCreate(v12, kCFNumberDoubleType, &v17);
    v17 = v10 / 1000000.0;
    *((_QWORD *)&v23 + 1) = CFNumberCreate(v12, kCFNumberDoubleType, &v17);
    *(_QWORD *)&v24 = CFNumberCreate(v12, kCFNumberSInt32Type, (const void *)(a4 + 56));
    *((_QWORD *)&v24 + 1) = CFNumberCreate(v12, kCFNumberSInt32Type, (const void *)(a4 + 60));
    v25 = CFRetain(a2);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a4);
    v13 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 13, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v13 = 0;
  }
  for (i = 0; i != 13; ++i)
  {
    v15 = values[i];
    if (v15)
      CFRelease(v15);
  }
  return v13;
}

uint64_t FigByteStreamCopySHA1Digest(uint64_t a1, CFDataRef *a2)
{
  void *v4;
  uint64_t (*v5)(uint64_t, const __CFString *, _QWORD, CFNumberRef *);
  unsigned int v6;
  CFNumberRef v7;
  CC_SHA1_CTX *v8;
  _BOOL4 v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t, void *, CFNumberRef *);
  uint64_t v14;
  unsigned int v15;
  uint64_t valuePtr;
  uint64_t v18;
  char v19;
  CFNumberRef number[4];

  number[3] = *(CFNumberRef *)MEMORY[0x1E0C80C00];
  v19 = 0;
  valuePtr = 0;
  v18 = 0;
  if (!a2)
  {
    v6 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    v4 = 0;
    goto LABEL_24;
  }
  *a2 = 0;
  v4 = malloc_type_malloc(0x10000uLL, 0xCEF03D8EuLL);
  if (!v4)
  {
    v6 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_34:
    v8 = 0;
    goto LABEL_24;
  }
  number[0] = 0;
  v5 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1)
                                                                                                + 8)
                                                                                    + 48);
  if (!v5)
  {
    v8 = 0;
LABEL_23:
    v6 = -12782;
    goto LABEL_24;
  }
  v6 = v5(a1, CFSTR("FBS_EntireLength"), 0, number);
  v7 = number[0];
  if (!v6)
  {
    CFNumberGetValue(number[0], kCFNumberSInt64Type, &valuePtr);
    v7 = number[0];
  }
  if (v7)
    CFRelease(v7);
  if (v6)
    goto LABEL_34;
  v8 = FigDigestSHA1Create();
  FigThreadRegisterAbortAction((uint64_t (*)())figByteStreamDigestAbortAction, (_opaque_pthread_t *)&v19, &v18);
  v9 = v19 == 0;
  v10 = valuePtr;
  v11 = valuePtr > 0;
  if (!v19 && valuePtr >= 1)
  {
    v12 = 0;
    do
    {
      number[0] = 0;
      v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16)
                                                                                       + 8);
      if (!v13)
        goto LABEL_23;
      if ((unint64_t)(v10 - v12) >= 0x10000)
        v14 = 0x10000;
      else
        v14 = v10 - v12;
      v15 = v13(a1, v14, v12, v4, number);
      if (v15)
      {
        v6 = v15;
        goto LABEL_24;
      }
      FigDigestSHA1AppendData(v8, v4, (CC_LONG)number[0]);
      v12 += (uint64_t)number[0];
      v9 = v19 == 0;
      v10 = valuePtr;
      v11 = v12 < valuePtr;
    }
    while (!v19 && v12 < valuePtr);
  }
  v6 = 0;
  if (v9 && !v11)
  {
    FigDigestSHA1GetDigest(v8, (unsigned __int8 *)number);
    v6 = 0;
    *a2 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)number, 20);
  }
LABEL_24:
  if (v18)
    FigThreadUnregisterAbortAction(v18);
  if (v8)
    FigDigestSHA1Destroy(v8);
  free(v4);
  if (v19)
    return 4294954425;
  else
    return v6;
}

_BYTE *figByteStreamDigestAbortAction(_BYTE *result)
{
  *result = 1;
  return result;
}

CFStringRef FigByteStreamBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigByteStream %p]"), a1);
}

uint64_t frb_FigRingBufferOutOfBounds(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  BOOL v4;
  unsigned int v5;
  BOOL v6;

  if (a3)
    v4 = a1 <= a3;
  else
    v4 = 1;
  v5 = !v4;
  if (a4)
    v6 = a2 > a4;
  else
    v6 = 0;
  if (v6)
    return 1;
  else
    return v5;
}

size_t frb_FigCFRingBufferGetSize(__CFString *a1)
{
  CFTypeID TypeID;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;

  if (!a1)
    return 0;
  TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
    return CFStringGetLength(a1);
  v4 = CFNumberGetTypeID();
  if (v4 == CFGetTypeID(a1))
    return CFNumberGetByteSize((CFNumberRef)a1);
  v5 = CFDataGetTypeID();
  if (v5 == CFGetTypeID(a1))
    return CFDataGetLength((CFDataRef)a1);
  v6 = CMBlockBufferGetTypeID();
  if (v6 == CFGetTypeID(a1))
    return CMBlockBufferGetDataLength((CMBlockBufferRef)a1);
  else
    return 0;
}

size_t frb_FigCStrRingBufferGetSize(const char *a1)
{
  return strlen(a1) + 1;
}

_QWORD *FigRingBufferCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t (**a4)())
{
  uint64_t (**v6)();
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v8;
  _QWORD *v9;

  if (a4)
    v6 = a4;
  else
    v6 = kFigTypeCFRingBufferCallBacks;
  Mutable = CFArrayCreateMutable(a1, 0, (const CFArrayCallBacks *)v6[2]);
  if (Mutable)
  {
    v8 = Mutable;
    v9 = malloc_type_calloc(1uLL, 0x40uLL, 0x1060040C52B20C0uLL);
    if (v9)
    {
      *v9 = CFRetain(v8);
      v9[1] = v6;
      v9[2] = 0;
      v9[3] = a3;
      v9[4] = 0;
      v9[5] = a2;
      v9[6] = 0;
      v9[7] = 0;
    }
    CFRelease(v8);
  }
  else
  {
    syslog(3, "Failed to allocate CFArray for ring buffer");
    return 0;
  }
  return v9;
}

uint64_t FigRingBufferAppendValueAndEvictBuffer(uint64_t a1, const void *a2, __CFArray *a3)
{
  CFIndex Count;
  uint64_t v7;
  char v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  const void *ValueAtIndex;
  CFIndex i;
  const void *v14;
  uint64_t (*v15)(const void *);
  const void *v16;
  CFIndex v18;
  uint64_t result;

  if (!a1)
    return 4294950815;
  if (!*(_QWORD *)(a1 + 8))
    return 4294950813;
  if (!a2)
    return 4294950814;
  Count = CFArrayGetCount(*(CFArrayRef *)a1);
  v7 = (*(uint64_t (**)(const void *))(*(_QWORD *)(a1 + 8) + 8))(a2);
  if (!Count)
  {
    v18 = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    goto LABEL_36;
  }
  if (!(**(unsigned int (***)(uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 8))(Count + 1, *(_QWORD *)(a1 + 16) + v7, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 24)))
  {
LABEL_34:
    v18 = *(_QWORD *)(a1 + 32);
    goto LABEL_36;
  }
  v8 = 0;
  do
  {
    if (Count < 1)
      return 4294950816;
    v9 = *(_QWORD *)(a1 + 32);
    if (v9 == *(_QWORD *)(a1 + 48))
    {
      if (a3 && !v8)
      {
LABEL_24:
        while (v9 < CFArrayGetCount(*(CFArrayRef *)a1))
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, v9);
          CFArrayAppendValue(a3, ValueAtIndex);
          ++v9;
        }
        v9 = *(_QWORD *)(a1 + 32);
        if (v9 >= 1)
        {
          for (i = 0; i < v9; ++i)
          {
            v14 = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, i);
            CFArrayAppendValue(a3, v14);
            v9 = *(_QWORD *)(a1 + 32);
          }
        }
      }
      v8 = 1;
      goto LABEL_29;
    }
    if (v8)
      v10 = 0;
    else
      v10 = (unint64_t)(*(_QWORD *)(a1 + 56) + v7) > *(_QWORD *)(a1 + 24);
    v11 = !v10;
    if (!v11)
      v8 = 1;
    if ((v11 & 1) == 0 && a3)
      goto LABEL_24;
LABEL_29:
    if (v9 >= Count)
    {
      v9 = 0;
      *(_QWORD *)(a1 + 32) = 0;
    }
    v15 = *(uint64_t (**)(const void *))(*(_QWORD *)(a1 + 8) + 8);
    v16 = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, v9);
    *(_QWORD *)(a1 + 16) -= v15(v16);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)a1, *(_QWORD *)(a1 + 32));
  }
  while ((**(unsigned int (***)(CFIndex, uint64_t, _QWORD, _QWORD))(a1 + 8))(Count--, *(_QWORD *)(a1 + 16) + v7, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 24)));
  if (!v8)
    goto LABEL_34;
  v18 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 48) = v18;
  *(_QWORD *)(a1 + 56) = 0;
LABEL_36:
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)a1, v18, a2);
  result = 0;
  ++*(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 16) += v7;
  *(_QWORD *)(a1 + 56) += v7;
  return result;
}

void FigRingBufferFlush(uint64_t a1, __CFArray *a2)
{
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex v6;
  const void *v7;

  if (a1)
  {
    if (a2)
    {
      for (i = *(_QWORD *)(a1 + 32); i < CFArrayGetCount(*(CFArrayRef *)a1); ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, i);
        CFArrayAppendValue(a2, ValueAtIndex);
      }
      if (*(uint64_t *)(a1 + 32) >= 1)
      {
        v6 = 0;
        do
        {
          v7 = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, v6);
          CFArrayAppendValue(a2, v7);
          ++v6;
        }
        while (v6 < *(_QWORD *)(a1 + 32));
      }
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)a1);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
  }
}

void FigRingBufferRelease(uint64_t a1)
{
  __CFArray *v2;

  if (a1)
  {
    v2 = *(__CFArray **)a1;
    if (v2)
    {
      CFArrayRemoveAllValues(v2);
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 0;
      if (*(_QWORD *)a1)
        CFRelease(*(CFTypeRef *)a1);
      free((void *)a1);
    }
  }
}

CFIndex FigRingBufferGetCount(const __CFArray **a1)
{
  const __CFArray *v1;

  if (a1 && (v1 = *a1) != 0)
    return CFArrayGetCount(v1);
  else
    return 0;
}

uint64_t FigRingBufferGetSize(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

void FigRingBufferGetEntries(uint64_t a1, __CFArray *a2)
{
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex v6;
  const void *v7;

  if (a1)
  {
    if (a2)
    {
      for (i = *(_QWORD *)(a1 + 32); i < CFArrayGetCount(*(CFArrayRef *)a1); ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, i);
        CFArrayAppendValue(a2, ValueAtIndex);
      }
      if (*(uint64_t *)(a1 + 32) >= 1)
      {
        v6 = 0;
        do
        {
          v7 = CFArrayGetValueAtIndex(*(CFArrayRef *)a1, v6);
          CFArrayAppendValue(a2, v7);
          ++v6;
        }
        while (v6 < *(_QWORD *)(a1 + 32));
      }
    }
  }
}

uint64_t CMByteStreamCreateForFileURL(uint64_t a1, const void *a2, unsigned int a3, CFTypeRef *a4)
{
  _QWORD *ClassID;
  uint64_t v9;
  uint64_t DerivedStorage;
  const __CFURL *v11;
  uint64_t v12;
  uint64_t Buffer;
  CFTypeRef cf;

  cf = 0;
  ClassID = (_QWORD *)CMByteStreamGetClassID();
  v9 = CMDerivedObjectCreate(a1, (uint64_t)&kFigFileByteStreamVTable, ClassID, &cf);
  if ((_DWORD)v9)
    return v9;
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  v11 = (const __CFURL *)CFRetain(a2);
  *(_QWORD *)DerivedStorage = v11;
  *(_DWORD *)(DerivedStorage + 4216) = -1;
  *(_BYTE *)(DerivedStorage + 4220) = 1;
  *(_DWORD *)(DerivedStorage + 16) = a3;
  v12 = FigFileForkOpenMainByCFURL(v11, a3, (int **)(DerivedStorage + 8));
  if ((_DWORD)v12)
  {
    Buffer = v12;
LABEL_9:
    CFRelease(cf);
    return Buffer;
  }
  FigByteStreamStatsSetupWorker((pthread_mutex_t *)(DerivedStorage + 4152));
  Buffer = fbs_SetupSmallReadBuffer(DerivedStorage + 24, a3);
  if ((_DWORD)Buffer)
  {
    FigFileForkClose(*(int **)(DerivedStorage + 8));
    goto LABEL_9;
  }
  *a4 = cf;
  return Buffer;
}

uint64_t fbs_SetupSmallReadBuffer(uint64_t a1, __int16 a2)
{
  pthread_mutex_t *v3;

  if ((a2 & 0x133) != 0)
    return 0;
  v3 = FigSimpleMutexCreate();
  *(_QWORD *)(a1 + 4112) = v3;
  if (v3)
  {
    *(_BYTE *)(a1 + 4120) = 1;
    return 0;
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigByteStreamCreateFromOpenFileWithFlags(unsigned int *a1, uint64_t a2, char a3, CFTypeRef *a4)
{
  _QWORD *ClassID;
  uint64_t v9;
  uint64_t DerivedStorage;
  int DarwinFileDesc;
  CFURLRef v12;
  uint64_t v13;
  CFTypeRef cf;
  UInt8 buffer[1024];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  cf = 0;
  ClassID = (_QWORD *)CMByteStreamGetClassID();
  v9 = CMDerivedObjectCreate(a2, (uint64_t)&kFigFileByteStreamVTable, ClassID, &cf);
  if ((_DWORD)v9)
  {
LABEL_9:
    v13 = v9;
    goto LABEL_11;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  *(_QWORD *)(DerivedStorage + 8) = a1;
  FigByteStreamStatsSetupWorker((pthread_mutex_t *)(DerivedStorage + 4152));
  *(_QWORD *)DerivedStorage = 0;
  *(_BYTE *)(DerivedStorage + 4220) = 0;
  *(_DWORD *)(DerivedStorage + 4216) = -1;
  if ((a3 & 2) == 0
    || (bzero(buffer, 0x400uLL),
        *(_BYTE *)(DerivedStorage + 4220) = 1,
        DarwinFileDesc = FigFileGetDarwinFileDesc(a1),
        fcntl(DarwinFileDesc, 50, buffer) != -1)
    && (v12 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], buffer, 1024, 0),
        (*(_QWORD *)DerivedStorage = v12) != 0))
  {
    if ((a3 & 1) == 0 || (v9 = fbs_SetupSmallReadBuffer(DerivedStorage + 24, 0), !(_DWORD)v9))
    {
      v13 = 0;
      *a4 = cf;
      return v13;
    }
    goto LABEL_9;
  }
  v13 = 4294954422;
LABEL_11:
  if (cf)
    CFRelease(cf);
  return v13;
}

uint64_t FigByteStreamCreateFromOpenFileAssumingOwnership(unsigned int *a1, uint64_t a2, CFTypeRef *a3)
{
  return FigByteStreamCreateFromOpenFileWithFlags(a1, a2, 2, a3);
}

uint64_t FigByteStreamCreateFromReadOnlyOpenFile(unsigned int *a1, uint64_t a2, CFTypeRef *a3)
{
  return FigByteStreamCreateFromOpenFileWithFlags(a1, a2, 1, a3);
}

uint64_t FigByteStreamCreateFromReadOnlyOpenFileAssumingOwnership(unsigned int *a1, uint64_t a2, CFTypeRef *a3)
{
  return FigByteStreamCreateFromOpenFileWithFlags(a1, a2, 3, a3);
}

uint64_t FigByteStreamCreateForFileURL(const void *a1, unsigned int a2, uint64_t a3, CFTypeRef *a4)
{
  return CMByteStreamCreateForFileURL(a3, a1, a2, a4);
}

uint64_t FigFileByteStreamEqual(uint64_t a1, uint64_t a2)
{
  CFTypeRef *DerivedStorage;
  const void *v4;

  DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage(a1);
  v4 = *(const void **)CMBaseObjectGetDerivedStorage(a2);
  return FigCFEqual(*DerivedStorage, v4);
}

__CFString *FigFileByteStreamCopyDebugDescription(uint64_t a1)
{
  CFTypeRef *DerivedStorage;
  __CFString *Mutable;
  CFStringRef v3;
  CFStringRef v4;

  DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage(a1);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v3 = CFCopyDescription(*DerivedStorage);
  if (v3)
  {
    v4 = v3;
    CFStringAppendFormat(Mutable, 0, CFSTR("<FigFileByteStream %p>{%@}"), DerivedStorage, v3);
    CFRelease(v4);
  }
  return Mutable;
}

uint64_t FigFileByteStreamSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage;
  CFTypeID TypeID;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!CFEqual(a2, CFSTR("FBS_IOPolicy")))
    return 4294954512;
  if (!a3)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  TypeID = CFNumberGetTypeID();
  if (TypeID != CFGetTypeID(a3))
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  CFNumberGetValue((CFNumberRef)a3, kCFNumberIntType, (void *)(DerivedStorage + 4216));
  return 0;
}

uint64_t FigFileByteStreamReadAndCreateBlockBuffer(const void *a1, size_t a2, uint64_t a3, CMBlockBufferRef *a4, size_t *a5)
{
  const __CFAllocator *v10;

  v10 = CFGetAllocator(a1);
  return CMCreateContiguousBlockBufferFromStream((uint64_t)a1, v10, a2, a3, a4, a5);
}

uint64_t FigFileByteStreamSynchronize(uint64_t a1, char a2)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  return FigFileForkSynchronize(*(int **)(DerivedStorage + 8), a2 & 1);
}

uint64_t FigFileByteStreamPreallocateStorageSpace(uint64_t a1, uint64_t a2, char a3, _QWORD *a4)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  return FigFileForkPreallocateStorageSpace(*(int **)(DerivedStorage + 8), a2, a3 & 2, a4);
}

uint64_t FigFileByteStreamWriteBlockBufferOptimized(uint64_t a1, OpaqueCMBlockBuffer *a2, size_t a3, size_t a4, off_t a5, _QWORD *a6)
{
  uint64_t DerivedStorage;
  size_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  unsigned int DataPointer;
  size_t v15;
  size_t *v16;
  size_t *v17;
  uint64_t v18;
  size_t *v19;
  size_t v20;
  unsigned int v21;
  size_t v22;
  size_t *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v27;
  char *dataPointerOut;
  uint64_t v31;
  size_t lengthAtOffsetOut;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v31 = 0;
  lengthAtOffsetOut = 0;
  if (a4)
  {
    v10 = 0;
    v11 = 0;
    v12 = a4;
    v13 = a3;
    do
    {
      if ((_DWORD)v11 == 0x7FFFFFFF)
      {
        v27 = 4294954422;
        goto LABEL_25;
      }
      DataPointer = CMBlockBufferGetDataPointer(a2, v13, &lengthAtOffsetOut, 0, 0);
      if (DataPointer)
        goto LABEL_26;
      v15 = lengthAtOffsetOut;
      if (v12 < lengthAtOffsetOut)
        v15 = v12;
      v13 += v15;
      ++v11;
      v10 += 16;
      v12 -= v15;
    }
    while (v12);
    v16 = (size_t *)malloc_type_malloc(v10, 0xD1AAB5CuLL);
    if (!v16)
      goto LABEL_29;
    v17 = v16;
    v18 = v11 + 1;
    v19 = v16 + 1;
    v20 = a4;
    while (1)
    {
      dataPointerOut = 0;
      if (!--v18)
        break;
      v21 = CMBlockBufferGetDataPointer(a2, a3, &lengthAtOffsetOut, 0, &dataPointerOut);
      if (v21)
        goto LABEL_28;
      v22 = lengthAtOffsetOut;
      if (v20 < lengthAtOffsetOut)
        v22 = v20;
      *(v19 - 1) = (size_t)dataPointerOut;
      *v19 = v22;
      v19 += 2;
      a3 += v22;
      v20 -= v22;
      if (!v20)
        goto LABEL_18;
    }
    v21 = FigSignalErrorAt(4294954422, 0, 0, 0, 0, 0, 0);
LABEL_28:
    v25 = v21;
  }
  else
  {
    v23 = (size_t *)malloc_type_malloc(0, 0x2CFEBD2BuLL);
    if (v23)
    {
      v17 = v23;
      LODWORD(v11) = 0;
LABEL_18:
      v24 = FigFileForkWriteIOVecArray(*(int **)(DerivedStorage + 8), *(_DWORD *)(DerivedStorage + 4216), (uint64_t)v17, v11, a5, &v31);
      v25 = v24;
      if (a6 && !v24)
        *a6 = v31;
    }
    else
    {
LABEL_29:
      v27 = 4294954420;
LABEL_25:
      DataPointer = FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
LABEL_26:
      v25 = DataPointer;
      v17 = 0;
    }
  }
  free(v17);
  if (v31 == a4)
    return 0;
  else
    return v25;
}

uint64_t plugin_CreateStandardPluginObjectInternal(const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  _QWORD *ClassID;
  uint64_t v13;
  _QWORD *DerivedStorage;
  const CFArrayCallBacks *v15;
  dispatch_queue_t v16;
  uint64_t v17;
  CFTypeRef cf;

  cf = 0;
  ClassID = (_QWORD *)FigHALAudioPluginGetClassID();
  v13 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigHALAudioPluginVTable, ClassID, &cf);
  if ((_DWORD)v13)
    goto LABEL_11;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
  DerivedStorage[1] = a2;
  DerivedStorage[4] = a4;
  DerivedStorage[5] = a5;
  v15 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  DerivedStorage[3] = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  DerivedStorage[2] = dispatch_queue_create("FigHALStandardPluginDeviceManagementQueue", 0);
  DerivedStorage[9] = CFArrayCreateMutable(a1, 0, v15);
  DerivedStorage[10] = CFArrayCreateMutable(a1, 0, v15);
  v16 = dispatch_queue_create("FigHALStandardPluginEndpointManagementQueue", 0);
  DerivedStorage[6] = v16;
  DerivedStorage[7] = a3;
  if (!DerivedStorage[3] || !DerivedStorage[2] || !DerivedStorage[9] || !DerivedStorage[10] || !v16)
  {
    v13 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
LABEL_11:
    v17 = v13;
    goto LABEL_12;
  }
  v17 = FigHALAudioObjectMapperAddPluginObjectMapping(a2, (uint64_t)cf);
  if (!(_DWORD)v17)
  {
    *a6 = cf;
    return v17;
  }
LABEL_12:
  if (cf)
    CFRelease(cf);
  return v17;
}

uint64_t FigHALAudioCreateStandardPluginObject(const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  return plugin_CreateStandardPluginObjectInternal(a1, a2, a3, a4, 0, a5);
}

void plugin_Finalize(uint64_t a1)
{
  _QWORD *DerivedStorage;
  const void *v2;
  NSObject *v3;
  const void *v4;
  const void *v5;
  NSObject *v6;
  const void *v7;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  v2 = (const void *)DerivedStorage[3];
  if (v2)
  {
    CFRelease(v2);
    DerivedStorage[3] = 0;
  }
  v3 = DerivedStorage[2];
  if (v3)
  {
    dispatch_release(v3);
    DerivedStorage[2] = 0;
  }
  v4 = (const void *)DerivedStorage[9];
  if (v4)
  {
    CFRelease(v4);
    DerivedStorage[9] = 0;
  }
  v5 = (const void *)DerivedStorage[10];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[10] = 0;
  }
  v6 = DerivedStorage[6];
  if (v6)
  {
    dispatch_release(v6);
    DerivedStorage[6] = 0;
  }
  v7 = (const void *)DerivedStorage[8];
  if (v7)
  {
    CFRelease(v7);
    DerivedStorage[8] = 0;
  }
}

CFStringRef plugin_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  CFStringRef v5;
  _QWORD v7[7];
  _QWORD block[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v2 = *(NSObject **)(DerivedStorage + 16);
  v3 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __plugin_CopyDebugDescription_block_invoke;
  block[3] = &unk_1E28DABE0;
  block[4] = &v17;
  block[5] = DerivedStorage;
  dispatch_sync(v2, block);
  v4 = *(NSObject **)(DerivedStorage + 48);
  v7[0] = v3;
  v7[1] = 0x40000000;
  v7[2] = __plugin_CopyDebugDescription_block_invoke_2;
  v7[3] = &unk_1E28DAC08;
  v7[5] = &v9;
  v7[6] = DerivedStorage;
  v7[4] = &v13;
  dispatch_sync(v4, v7);
  v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("FigHALStandardPlugin: %ld devices %ld activated endpoints %ld audio streams"), v18[3], v14[3], v10[3]);
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  return v5;
}

uint64_t plugin_GetObjectID()
{
  return 1;
}

uint64_t plugin_HasProperty(uint64_t a1, int *a2)
{
  int v2;
  uint64_t result;
  BOOL v4;
  int v5;

  v2 = *a2;
  result = 1;
  if (*a2 <= 1819107690)
  {
    v4 = v2 == 1668047219;
    v5 = 1684370979;
  }
  else
  {
    v4 = v2 == 1819107691 || v2 == 1870098020;
    v5 = 1969841252;
  }
  if (!v4 && v2 != v5)
    return 0;
  return result;
}

uint64_t plugin_IsPropertySettable()
{
  return 0;
}

uint64_t plugin_GetPropertyDataSize(uint64_t a1, int *a2)
{
  uint64_t DerivedStorage;
  int v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v4 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v4 == 1668047219)
      return 4;
    if (v4 != 1684370979)
      return 0;
LABEL_9:
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = 0;
    v6 = *(NSObject **)(DerivedStorage + 16);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __plugin_GetPropertyDataSize_block_invoke;
    v8[3] = &unk_1E28DAC30;
    v8[4] = &v9;
    v8[5] = DerivedStorage;
    dispatch_sync(v6, v8);
    v5 = (4 * *((_DWORD *)v10 + 6));
    _Block_object_dispose(&v9, 8);
    return v5;
  }
  switch(v4)
  {
    case 1819107691:
      return 8;
    case 1870098020:
      goto LABEL_9;
    case 1969841252:
      return 4;
    default:
      return 0;
  }
}

uint64_t plugin_GetPropertyData(uint64_t a1, int *a2, int a3, uint64_t a4, unsigned int a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t DerivedStorage;
  uint64_t v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  _QWORD block[7];
  _QWORD v20[7];
  unsigned int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v14 = 0;
  v15 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v15 != 1668047219)
    {
      if (v15 != 1684370979)
        return v14;
LABEL_11:
      v22 = 0;
      v23 = &v22;
      v24 = 0x2000000000;
      v25 = 0;
      v17 = *(NSObject **)(DerivedStorage + 16);
      v20[0] = MEMORY[0x1E0C809B0];
      v20[1] = 0x40000000;
      v20[2] = __plugin_GetPropertyData_block_invoke;
      v20[3] = &unk_1E28DAC58;
      v21 = a5;
      v20[4] = &v22;
      v20[5] = DerivedStorage;
      v20[6] = a7;
      dispatch_sync(v17, v20);
      *a6 = 4 * *((_DWORD *)v23 + 6);
      _Block_object_dispose(&v22, 8);
      return 0;
    }
    *a6 = 4;
    if (a5 >= 4)
    {
      v14 = 0;
      *a7 = 1634757735;
      return v14;
    }
    return 561211770;
  }
  if (v15 == 1819107691)
  {
    *a6 = 8;
    if (a5 >= 8)
    {
      v14 = 0;
      *(_QWORD *)a7 = CFSTR("Apple Inc.");
      return v14;
    }
    return 561211770;
  }
  if (v15 == 1870098020)
    goto LABEL_11;
  if (v15 != 1969841252)
    return v14;
  if (a5 > 3 && a3 == 8 && a4)
  {
    v16 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __plugin_GetPropertyData_block_invoke_2;
    block[3] = &__block_descriptor_tmp_9;
    block[4] = DerivedStorage;
    block[5] = a4;
    block[6] = a7;
    dispatch_sync(v16, block);
    v14 = 0;
    *a6 = 4;
    return v14;
  }
  return FigSignalErrorAt(561211770, 0, 0, 0, 0, 0, 0);
}

uint64_t plugin_SetPropertyData()
{
  return 2003332927;
}

uint64_t plugin_Initialize(uint64_t a1, uint64_t a2)
{
  _QWORD *DerivedStorage;
  void (*v5)(_QWORD, _QWORD, uint64_t, CFTypeRef *);
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  _QWORD v11[6];
  _QWORD block[6];
  CFTypeRef v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  *DerivedStorage = a2;
  v5 = (void (*)(_QWORD, _QWORD, uint64_t, CFTypeRef *))DerivedStorage[5];
  v6 = MEMORY[0x1E0C809B0];
  if (v5)
  {
    v13 = 0;
    v5(*MEMORY[0x1E0C9AE00], DerivedStorage[1], a2, &v13);
    if (v13)
    {
      v7 = DerivedStorage[2];
      block[0] = v6;
      block[1] = 0x40000000;
      block[2] = __plugin_Initialize_block_invoke;
      block[3] = &__block_descriptor_tmp_10_1;
      block[4] = DerivedStorage;
      block[5] = v13;
      dispatch_sync(v7, block);
      CFRelease(v13);
    }
  }
  v8 = DerivedStorage[6];
  v11[0] = v6;
  v11[1] = 0x40000000;
  v11[2] = __plugin_Initialize_block_invoke_2;
  v11[3] = &unk_1E28DACC0;
  v11[4] = &v14;
  v11[5] = a1;
  dispatch_sync(v8, v11);
  v9 = *((unsigned int *)v15 + 6);
  _Block_object_dispose(&v14, 8);
  return v9;
}

void ActivatedEndpointsChangedNotificationCallback(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  _QWORD block[5];

  v3 = *(NSObject **)(CMBaseObjectGetDerivedStorage(a2) + 48);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __ActivatedEndpointsChangedNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_12_0;
  block[4] = a2;
  dispatch_async(v3, block);
}

uint64_t PeruseActivatedEndpoints(const void *a1)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v3;
  uint64_t v4;
  CFMutableArrayRef MutableCopy;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  void *ValueAtIndex;
  CFIndex FirstIndexOfValue;
  __CFNotificationCenter *DefaultLocalCenter;
  CFIndex v14;
  CFIndex v15;
  CFIndex i;
  const void *v17;
  __CFNotificationCenter *v18;
  const __CFArray *v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex j;
  const void *v23;
  uint64_t v24;
  CFTypeRef cf;
  CFRange v27;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  cf = 0;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = FigEndpointManagerCopyActivatedEndpoints(*(_QWORD *)(DerivedStorage + 64), (const __CFAllocator *)*MEMORY[0x1E0C9AE00], (__CFArray **)&cf);
  if ((_DWORD)v4)
    goto LABEL_22;
  MutableCopy = FigCFArrayCreateMutableCopy(v3, (CFArrayRef)cf);
  if (!MutableCopy)
  {
    v4 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
LABEL_22:
    v24 = v4;
    goto LABEL_18;
  }
  v6 = MutableCopy;
  v7 = *(const __CFArray **)(DerivedStorage + 72);
  if (v7)
  {
    Count = CFArrayGetCount(v7);
    if (Count >= 1)
    {
      v9 = Count;
      v10 = 0;
      do
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 72), v10);
        v27.length = CFArrayGetCount(v6);
        v27.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v6, v27, ValueAtIndex);
        if (FirstIndexOfValue == -1)
        {
          DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
          CMNotificationCenterRemoveListener(DefaultLocalCenter, a1, (int)EndpointStreamsChangedNotificationCallback, CFSTR("Endpoint_StreamsChanged"), ValueAtIndex);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(DerivedStorage + 72), v10);
          --v9;
        }
        else
        {
          CFArrayRemoveValueAtIndex(v6, FirstIndexOfValue);
          ++v10;
        }
      }
      while (v10 < v9);
    }
  }
  v14 = CFArrayGetCount(v6);
  if (v14 >= 1)
  {
    v15 = v14;
    for (i = 0; i != v15; ++i)
    {
      v17 = CFArrayGetValueAtIndex(v6, i);
      CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 72), v17);
      v18 = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterAddListener(v18, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))EndpointStreamsChangedNotificationCallback, CFSTR("Endpoint_StreamsChanged"), (unint64_t)v17);
    }
  }
  v19 = *(const __CFArray **)(DerivedStorage + 72);
  if (v19)
  {
    v20 = CFArrayGetCount(v19);
    if (v20 >= 1)
    {
      v21 = v20;
      for (j = 0; j != v21; ++j)
      {
        v23 = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 72), j);
        PeruseAudioStreamsForEndpoint(a1, (uint64_t)v23);
      }
    }
  }
  CFRelease(v6);
  v24 = 0;
LABEL_18:
  if (cf)
    CFRelease(cf);
  return v24;
}

void EndpointStreamsChangedNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage;
  NSObject *v7;
  _QWORD v8[6];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a2);
  CFRetain(a4);
  v7 = *(NSObject **)(DerivedStorage + 48);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __EndpointStreamsChangedNotificationCallback_block_invoke;
  v8[3] = &__block_descriptor_tmp_13_0;
  v8[4] = a2;
  v8[5] = a4;
  dispatch_async(v7, v8);
}

void PeruseAudioStreamsForEndpoint(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v5;
  CFIndex Count;
  CFMutableArrayRef MutableCopy;
  const __CFArray *v8;
  const __CFArray *v9;
  CFIndex v10;
  CFIndex v11;
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex FirstIndexOfValue;
  CFIndex v15;
  CFIndex v16;
  CFIndex j;
  const void *v18;
  _QWORD *v19;
  NSObject *v20;
  __CFNotificationCenter *DefaultLocalCenter;
  CFArrayRef theArray;
  _QWORD block[7];
  uint64_t v24;
  CFRange v25;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  theArray = 0;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!FigEndpointCopyStreamsForTypeAndSubType(a2, *MEMORY[0x1E0C9AE00], (uint64_t)CFSTR("Audio"), 0, &theArray))
  {
    if (!theArray)
      return;
    Count = CFArrayGetCount(theArray);
    if (Count)
    {
      MutableCopy = CFArrayCreateMutableCopy(v5, Count, theArray);
      if (MutableCopy)
      {
        v8 = MutableCopy;
        v9 = *(const __CFArray **)(DerivedStorage + 80);
        if (v9)
        {
          v10 = CFArrayGetCount(v9);
          if (v10 >= 1)
          {
            v11 = v10;
            for (i = 0; i != v11; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 80), i);
              v25.length = CFArrayGetCount(v8);
              v25.location = 0;
              FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v8, v25, ValueAtIndex);
              if (FirstIndexOfValue != -1)
                CFArrayRemoveValueAtIndex(v8, FirstIndexOfValue);
            }
          }
        }
        v15 = CFArrayGetCount(v8);
        if (v15 >= 1)
        {
          v16 = v15;
          for (j = 0; j != v16; ++j)
          {
            v18 = CFArrayGetValueAtIndex(v8, j);
            v19 = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
            v24 = 0;
            if (!((unsigned int (*)(const __CFAllocator *, _QWORD, _QWORD, uint64_t, const void *, _QWORD, uint64_t *))v19[4])(v5, v19[1], *v19, a2, v18, 0, &v24))
            {
              v20 = v19[2];
              block[0] = MEMORY[0x1E0C809B0];
              block[1] = 0x40000000;
              block[2] = __CreateDeviceForEndpointStream_block_invoke;
              block[3] = &__block_descriptor_tmp_14_2;
              block[4] = v19;
              block[5] = v24;
              block[6] = a1;
              dispatch_sync(v20, block);
              FigHALAudioPropertySendChanges((uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))*v19, 1, 2, (uint64_t)"#vedbolg");
            }
            CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 80), v18);
            DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
            CMNotificationCenterAddListener(DefaultLocalCenter, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))EndpointStreamDissociationNotificationCallback, CFSTR("EndpointStreamNotification_Dissociated"), (unint64_t)v18);
          }
        }
        CFRelease(v8);
      }
      else
      {
        FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  if (theArray)
    CFRelease(theArray);
}

void EndpointStreamDissociationNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage;
  NSObject *v7;
  _QWORD block[7];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a2);
  CFRetain(a4);
  v7 = *(NSObject **)(DerivedStorage + 48);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __EndpointStreamDissociationNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_16_0;
  block[4] = a2;
  block[5] = a4;
  block[6] = DerivedStorage;
  dispatch_async(v7, block);
}

void DeviceUnpluggedNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  NSObject *v7;
  _QWORD block[7];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a2);
  v7 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __DeviceUnpluggedNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_15_1;
  block[4] = a2;
  block[5] = a4;
  block[6] = DerivedStorage;
  dispatch_sync(v7, block);
  FigHALAudioPropertySendChanges(*(uint64_t (***)(_QWORD, uint64_t, uint64_t, uint64_t))DerivedStorage, 1, 2, (uint64_t)"#vedbolg");
}

uint64_t FigMachPortReleaseReceiveRight_(mach_port_name_t name, uint64_t a2, const char *a3, const char *a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;

  if (!name)
    return 0;
  v9 = mach_port_mod_refs(*MEMORY[0x1E0C83DA0], name, 1u, -1);
  v10 = v9;
  if ((_DWORD)v9)
    FigSignalErrorAt(v9, 0, (uint64_t)"returned by mach_port_mod_refs while releasing mach port receive right", a2, a3, a4, a5);
  return v10;
}

uint64_t FigMachPortReleaseSendRight_(mach_port_name_t name, uint64_t a2, const char *a3, const char *a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;

  v9 = mach_port_deallocate(*MEMORY[0x1E0C83DA0], name);
  v10 = v9;
  if ((_DWORD)v9)
    FigSignalErrorAt(v9, 0, (uint64_t)"returned by mach_port_deallocate while releasing mach port send right", a2, a3, a4, a5);
  return v10;
}

BOOL FigNetworkHistoryAreAnyRequestsActive(uint64_t a1)
{
  pthread_mutex_t **DerivedStorage;
  _BOOL8 v3;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  v3 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 80) != 0x7FFFFFFFFFFFFFFFLL;
  FigSimpleMutexUnlock(*DerivedStorage);
  return v3;
}

uint64_t FigNetworkHistoryGetActiveLatencyRange(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  pthread_mutex_t **DerivedStorage;
  _QWORD *FirstRequestEntryAfterTime;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigNetworkHistoryBeginImmutabilty(a1);
  FigSimpleMutexLock(*DerivedStorage);
  FirstRequestEntryAfterTime = fnh_getFirstRequestEntryAfterTime(a1, a2);
  v10 = 0;
  for (i = 0x7FFFFFFFFFFFFFFFLL;
        FirstRequestEntryAfterTime;
        FirstRequestEntryAfterTime = fnh_getFirstRequestEntryAfterTime(a1, *FirstRequestEntryAfterTime + 1))
  {
    v12 = FirstRequestEntryAfterTime[2];
    v13 = v12 - *FirstRequestEntryAfterTime;
    if (v13 >= i)
      v14 = i;
    else
      v14 = v12 - *FirstRequestEntryAfterTime;
    if (v13 <= v10)
      v13 = v10;
    if (v12 >= 1)
    {
      i = v14;
      v10 = v13;
    }
  }
  FigSimpleMutexUnlock(*DerivedStorage);
  result = FigNetworkHistoryEndImmutability(a1);
  if (i == 0x7FFFFFFFFFFFFFFFLL)
    v16 = 0;
  else
    v16 = i;
  *a3 = v16;
  *a4 = v10;
  return result;
}

uint64_t FigNetworkHistoryBeginImmutabilty(uint64_t a1)
{
  pthread_mutex_t **DerivedStorage;
  uint64_t v3;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  v3 = CMBaseObjectGetDerivedStorage(a1);
  ++*(_QWORD *)(v3 + 120);
  FigSimpleMutexUnlock(*DerivedStorage);
  return 0;
}

_QWORD *fnh_getFirstRequestEntryAfterTime(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  _QWORD *result;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(a1) + 120) < 1)
    return 0;
  for (result = *(_QWORD **)(DerivedStorage + 40); result; result = (_QWORD *)result[7])
  {
    if (*result >= a2)
      break;
  }
  return result;
}

uint64_t FigNetworkHistoryEndImmutability(uint64_t a1)
{
  pthread_mutex_t **DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  v3 = CMBaseObjectGetDerivedStorage(a1);
  v4 = *(_QWORD *)(v3 + 120);
  if (v4 <= 0)
  {
    v5 = FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *(_QWORD *)(v3 + 120) = v4 - 1;
    if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(a1) + 120) <= 0)
      fnh_runAllEnqueuedCommands(a1, 0);
    v5 = 0;
  }
  FigSimpleMutexUnlock(*DerivedStorage);
  return v5;
}

uint64_t FigNetworkHistoryRequestBecameActive(const void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t Global;
  uint64_t v11;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v7 = CFGetAllocator(a1);
  v8 = CFAllocatorAllocate(v7, 72, 0);
  v9 = (uint64_t)v8;
  if (v8)
  {
    v8[8] = 0;
    *((_OWORD *)v8 + 2) = 0u;
    *((_OWORD *)v8 + 3) = 0u;
    *(_OWORD *)v8 = 0u;
    *((_OWORD *)v8 + 1) = 0u;
  }
  else
  {
    v11 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)v11)
      return v11;
  }
  if (*(_BYTE *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistoryRequestBecameActive(Global, a2, v9 + 48);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  v11 = fnh_runOrEnqueueCommand(a1, fnh_requestBecameActiveCommand, v9, a2, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  if (a3 && !(_DWORD)v11)
    *a3 = v9;
  return v11;
}

uint64_t FigNetworkHistoryGetGlobal()
{
  uint64_t v0;
  __CFDictionary *Mutable;
  __CFDictionary *v2;
  const void *v3;
  uint64_t v4;
  uint64_t v6;

  if (fnh_ensureGlobalNetworkHistoryIsSetup_onceToken != -1)
    dispatch_once_f(&fnh_ensureGlobalNetworkHistoryIsSetup_onceToken, 0, (dispatch_function_t)fnh_globalNetworkHistoryOnce);
  FigSimpleMutexLock((pthread_mutex_t *)gNetworkHistoryAccessorMutex);
  if (!gNetworkHistory)
  {
    v6 = 0;
    v0 = *MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v2 = Mutable;
      v3 = (const void *)*MEMORY[0x1E0C9AE40];
      CFDictionarySetValue(Mutable, CFSTR("NetworkHistoryCreateOption_EnableLogging"), (const void *)*MEMORY[0x1E0C9AE40]);
      CFDictionarySetValue(v2, CFSTR("NetworkHistoryCreateOption_ContributesToGlobalHistory"), v3);
      FigCFDictionarySetInt64(v2, CFSTR("NetworkHistoryCreateOption_MaxWindowSize"), 600000000000);
      FigCFDictionarySetInt64(v2, CFSTR("NetworkHistoryCreateOption_BytesReceivedMaxResolution"), 5000000000);
      FigNetworkHistoryCreate(v0, (uint64_t)v2, (CFTypeRef *)&v6);
      CFRelease(v2);
      v4 = v6;
    }
    else
    {
      v4 = 0;
    }
    gNetworkHistory = v4;
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)gNetworkHistoryAccessorMutex);
  return gNetworkHistory;
}

uint64_t fnh_runOrEnqueueCommand(const void *a1, void (*a2)(_QWORD *), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  _QWORD *v11;
  _QWORD *v12;
  CFTypeRef v13;
  _QWORD *v14;
  _QWORD v16[4];

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 120) < 1)
  {
    v16[0] = a1;
    v16[1] = a3;
    v16[2] = a4;
    v16[3] = a5;
    a2(v16);
    return 0;
  }
  CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v11 = malloc_type_calloc(1uLL, 0x38uLL, 0x10A0040F617279DuLL);
  if (v11)
  {
    v12 = v11;
    *v11 = a2;
    if (a1)
      v13 = CFRetain(a1);
    else
      v13 = 0;
    v12[1] = v13;
    v12[2] = a3;
    v12[3] = a4;
    v12[4] = a5;
    v12[5] = 0;
    v14 = *(_QWORD **)(DerivedStorage + 136);
    v12[6] = v14;
    *v14 = v12;
    *(_QWORD *)(DerivedStorage + 136) = v12 + 5;
    return 0;
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

void fnh_requestBecameActiveCommand(uint64_t *a1)
{
  uint64_t v1;
  uint64_t *v2;
  const void *v3;
  _QWORD *DerivedStorage;
  NSObject *v5;
  CFNotificationCenterRef DefaultLocalCenter;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = (uint64_t *)a1[1];
  v1 = a1[2];
  v3 = (const void *)*a1;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(*a1);
  CMBaseObjectGetDerivedStorage((uint64_t)v3);
  if (*(_QWORD *)(CMBaseObjectGetDerivedStorage((uint64_t)v3) + 80) == 0x7FFFFFFFFFFFFFFFLL)
  {
    v5 = DerivedStorage[1];
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigDispatchAsyncPostNotification(v5, DefaultLocalCenter, CFSTR("NetworkHistoryNotification_NetworkBecameActive"), v3, 0, 0);
  }
  fnh_purgeExpiredListEntriesOnQueue(v3, v1);
  v7 = DerivedStorage + 6;
  v8 = **(uint64_t ***)(DerivedStorage[6] + 8);
  *v2 = v1;
  if (v8)
  {
    while (*v8 > v1)
    {
      v8 = **(uint64_t ***)(v8[8] + 8);
      if (!v8)
        goto LABEL_6;
    }
    v11 = v8[7];
    v9 = (uint64_t **)(v8 + 7);
    v10 = v11;
  }
  else
  {
LABEL_6:
    v9 = (uint64_t **)(DerivedStorage + 5);
    v10 = DerivedStorage[5];
  }
  v2[7] = v10;
  if (v10)
    v7 = (_QWORD *)(v10 + 64);
  *v7 = v2 + 7;
  *v9 = v2;
  v2[8] = (uint64_t)v9;
  ++DerivedStorage[12];
  v12 = DerivedStorage[10];
  if (v12 >= v1)
    v12 = v1;
  DerivedStorage[10] = v12;
}

uint64_t FigNetworkHistorySetRequestSentTimestamp(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t Global;
  uint64_t v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(_BYTE *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistorySetRequestSentTimestamp(Global, *(_QWORD *)(a2 + 48), a3);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  v8 = fnh_runOrEnqueueCommand(a1, (void (*)(_QWORD *))fnh_setRequestSentTimestampCommand, a2, a3, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v8;
}

uint64_t fnh_setRequestSentTimestampCommand(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t result;

  v1 = (uint64_t *)a1[1];
  v2 = a1[2];
  if (*v1 > v2)
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  result = CMBaseObjectGetDerivedStorage(*a1);
  v1[1] = v2;
  return result;
}

uint64_t FigNetworkHistorySetRequestLatency(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t Global;
  uint64_t v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(_BYTE *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistorySetRequestLatency(Global, *(_QWORD *)(a2 + 48), a3);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  v8 = fnh_runOrEnqueueCommand(a1, (void (*)(_QWORD *))fnh_setRequestLatencyCommand, a2, a3, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v8;
}

uint64_t fnh_setRequestLatencyCommand(uint64_t *a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t result;

  v1 = *a1;
  v2 = (uint64_t *)a1[1];
  v3 = a1[2];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  if (*v2 > v3 || v2[1] > v3)
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  v5 = DerivedStorage;
  CMBaseObjectGetDerivedStorage(v1);
  v2[2] = v3;
  result = fnh_updateEarliestActiveRequestFirstBytesSentTimestamp(v1, v3);
  ++*(_QWORD *)(v5 + 104);
  return result;
}

uint64_t FigNetworkHistoryRequestReceivedBytes(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t Global;
  uint64_t v10;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(_BYTE *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistoryRequestReceivedBytes(Global, *(_QWORD *)(a2 + 48), a3, a4);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  v10 = fnh_runOrEnqueueCommand(a1, (void (*)(_QWORD *))fnh_requestReceivedBytesCommand, a2, a4, a3);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v10;
}

uint64_t fnh_requestReceivedBytesCommand(uint64_t *a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;

  v2 = (uint64_t *)a1[1];
  v1 = a1[2];
  if (v2[4] > v1)
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  v3 = v2[2];
  if (v3 > v1 || v3 <= 0)
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  v4 = (const void *)*a1;
  v5 = a1[3];
  CMBaseObjectGetDerivedStorage(*a1);
  v6 = v2[4];
  if (!v6)
  {
    v7 = v2[1];
    if (!v7)
      v7 = *v2;
    v8 = 0x7FFFFFFFFFFFFFFFLL;
    if ((unint64_t)(v1 - *v2) > 0x1DCD6500)
      v8 = v7 + 250000000;
    v9 = v2[2];
    v10 = v9 - v7;
    if (v9 < v7)
      ++v10;
    v11 = v7 + (v10 >> 1);
    if (v9 >= 1)
      v6 = v11;
    else
      v6 = v8;
    v2[4] = v6;
  }
  result = fnh_addBytesToBytesReceivedEntriesBetweenTimestamps(v4, v5, v6, v1, v1);
  if (!(_DWORD)result)
  {
    v13 = v2[5] + v5;
    v2[4] = v1;
    v2[5] = v13;
  }
  return result;
}

uint64_t FigNetworkHistoryRequestBecameInactive(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t Global;
  uint64_t v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(_BYTE *)(DerivedStorage + 33) && (const void *)FigNetworkHistoryGetGlobal() != a1)
  {
    Global = FigNetworkHistoryGetGlobal();
    FigNetworkHistoryRequestBecameInactive(Global, *(_QWORD *)(a2 + 48), a3);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  v8 = fnh_runOrEnqueueCommand(a1, (void (*)(_QWORD *))fnh_requestBecameInactiveCommand, a2, a3, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v8;
}

uint64_t fnh_requestBecameInactiveCommand(uint64_t *a1)
{
  const void *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  NSObject *v13;
  CFNotificationCenterRef DefaultLocalCenter;

  v1 = (const void *)*a1;
  v2 = (uint64_t *)a1[1];
  v3 = a1[2];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  v2[3] = v3;
  if (*v2 > v3 || v2[2] > v3)
    return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
  v5 = DerivedStorage;
  CMBaseObjectGetDerivedStorage((uint64_t)v1);
  fnh_purgeExpiredListEntriesOnQueue(v1, v3);
  fnh_updateEarliestActiveRequestFirstBytesSentTimestamp((uint64_t)v1, v3);
  v6 = v2[1];
  if (!v6)
    v6 = *v2;
  if ((unint64_t)(v3 - *v2) <= 0x1DCD6500)
    v7 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v7 = v6 + 250000000;
  v8 = v2[2];
  v9 = v8 - v6;
  if (v8 < v6)
    ++v9;
  v10 = v6 + (v9 >> 1);
  if (v8 >= 1)
    v11 = v10;
  else
    v11 = v7;
  if (v11 == 0x7FFFFFFFFFFFFFFFLL
    || (result = fnh_addBytesToBytesReceivedEntriesBetweenTimestamps(v1, 0, v11, v2[3], v3), !(_DWORD)result))
  {
    result = CMBaseObjectGetDerivedStorage((uint64_t)v1);
    if (*(_QWORD *)(result + 80) == 0x7FFFFFFFFFFFFFFFLL)
    {
      v13 = *(NSObject **)(v5 + 8);
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      return FigDispatchAsyncPostNotification(v13, DefaultLocalCenter, CFSTR("NetworkHistoryNotification_NetworkBecameInactive"), v1, 0, 0);
    }
  }
  return result;
}

uint64_t FigNetworkHistoryGetFirstBandwidthSampleAfterTime(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  pthread_mutex_t **DerivedStorage;
  uint64_t *FirstBytesReceivedEntryAfterTime;
  uint64_t v12;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*DerivedStorage);
  FirstBytesReceivedEntryAfterTime = (uint64_t *)fnh_getFirstBytesReceivedEntryAfterTime(a1, a2, a4, 0);
  if (FirstBytesReceivedEntryAfterTime)
    v12 = fnh_populateBandwidthSampleFromBytesReceivedEntry((uint64_t)a1, FirstBytesReceivedEntryAfterTime, a3, a5);
  else
    v12 = 0;
  FigSimpleMutexUnlock(*DerivedStorage);
  return v12;
}

uint64_t fnh_getFirstBytesReceivedEntryAfterTime(const void *a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD *DerivedStorage;
  uint64_t result;
  uint64_t v10;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 120) < 1)
    return 0;
  fnh_purgeExpiredListEntriesOnQueue(a1, a3);
  fnh_updateEarliestActiveRequestFirstBytesSentTimestamp((uint64_t)a1, a3);
  if (DerivedStorage[9] == 0x7FFFFFFFFFFFFFFFLL)
    goto LABEL_5;
  if (fnh_addBytesToBytesReceivedEntriesBetweenTimestamps(a1, 0, DerivedStorage[11], a3, a3))
    return 0;
  DerivedStorage[11] = a3;
LABEL_5:
  result = DerivedStorage[7];
  if (result)
  {
    if (a4)
    {
      v10 = **(_QWORD **)(DerivedStorage[8] + 8);
      do
      {
        result = v10;
        v10 = **(_QWORD **)(*(_QWORD *)(v10 + 40) + 8);
      }
      while (v10 && *(_QWORD *)(v10 + 8) >= a2);
    }
    else
    {
      do
      {
        if (*(_QWORD *)(result + 8) >= a2)
          break;
        result = *(_QWORD *)(result + 32);
      }
      while (result);
    }
  }
  return result;
}

uint64_t fnh_populateBandwidthSampleFromBytesReceivedEntry(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  result = 0;
  if (a2 && *(uint64_t *)(DerivedStorage + 120) >= 1)
  {
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)a4 = 0u;
    v9 = a2[1];
    v10 = v9 - 1;
    if (v9 - 1 <= *a2)
      v10 = *a2;
    v11 = a3 + v10 / a3 * a3;
    if (v9 > v11)
    {
      return 0;
    }
    else
    {
      *(_QWORD *)a4 = *a2;
      do
      {
        v12 = a2[1];
        if (v12 > v11)
          break;
        v13 = a2[2];
        v14 = *(_QWORD *)(a4 + 16);
        v15 = v12 - *a2 + *(_QWORD *)(a4 + 32);
        *(_QWORD *)(a4 + 24) += a2[3];
        *(_QWORD *)(a4 + 32) = v15;
        v16 = v13 <= v14 ? v14 : v13;
        *(_QWORD *)(a4 + 8) = v12;
        *(_QWORD *)(a4 + 16) = v16;
        a2 = (uint64_t *)a2[4];
        *(_QWORD *)(a4 + 40) = a2;
      }
      while (a2);
      return 1;
    }
  }
  return result;
}

uint64_t FigNetworkHistoryGetNextBandwidthSample(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  pthread_mutex_t **DerivedStorage;
  uint64_t v10;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  v10 = fnh_populateBandwidthSampleFromBytesReceivedEntry(a1, a2, a3, a5);
  FigSimpleMutexUnlock(*DerivedStorage);
  return v10;
}

uint64_t FigNetworkHistoryGetFirstLatencySampleAfterTime(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  pthread_mutex_t **DerivedStorage;
  _QWORD *FirstRequestEntryAfterTime;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(a1) + 120) >= 1
    && (FirstRequestEntryAfterTime = fnh_getFirstRequestEntryAfterTime(a1, a2)) != 0)
  {
    while (1)
    {
      v9 = FirstRequestEntryAfterTime[2];
      if (v9 >= 1)
        break;
      v10 = 0;
      FirstRequestEntryAfterTime = (_QWORD *)FirstRequestEntryAfterTime[7];
      if (!FirstRequestEntryAfterTime)
        goto LABEL_8;
    }
    v11 = FirstRequestEntryAfterTime[5];
    *a4 = v9 - *FirstRequestEntryAfterTime;
    a4[1] = v11;
    a4[2] = FirstRequestEntryAfterTime[7];
    v10 = 1;
  }
  else
  {
    v10 = 0;
  }
LABEL_8:
  FigSimpleMutexUnlock(*DerivedStorage);
  return v10;
}

uint64_t FigNetworkHistoryGetNextValidLatencySample(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4)
{
  pthread_mutex_t **DerivedStorage;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*DerivedStorage);
  v8 = CMBaseObjectGetDerivedStorage(a1);
  v9 = 0;
  if (a2 && *(uint64_t *)(v8 + 120) >= 1)
  {
    while (1)
    {
      v10 = a2[2];
      if (v10 >= 1)
        break;
      v9 = 0;
      a2 = (_QWORD *)a2[7];
      if (!a2)
        goto LABEL_7;
    }
    v11 = a2[5];
    *a4 = v10 - *a2;
    a4[1] = v11;
    a4[2] = a2[7];
    v9 = 1;
  }
LABEL_7:
  FigSimpleMutexUnlock(*DerivedStorage);
  return v9;
}

uint64_t FigNetworkHistoryGetMaxWindowSize(uint64_t a1)
{
  return *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 16);
}

uint64_t FigNetworkHistoryGetBytesReceivedMaxResolution(uint64_t a1)
{
  return *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 24);
}

uint64_t FigNetworkHistoryGetLastActiveTimestamp(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(a1) + 120) < 1)
    goto LABEL_5;
  if (*(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 80) == 0x7FFFFFFFFFFFFFFFLL)
  {
    v5 = **(_QWORD **)(*(_QWORD *)(DerivedStorage + 64) + 8);
    if (v5)
    {
      a2 = *(_QWORD *)(v5 + 8);
      goto LABEL_6;
    }
LABEL_5:
    a2 = 0;
  }
LABEL_6:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return a2;
}

uint64_t FigNetworkHistoryGetFirstActiveTimestamp(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t *v5;
  uint64_t v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (*(uint64_t *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 120) <= 0)
    fnh_purgeExpiredListEntriesOnQueue(a1, a2);
  if (*(_QWORD *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 80) != 0x7FFFFFFFFFFFFFFFLL)
  {
    v5 = (uint64_t *)(DerivedStorage + 80);
    goto LABEL_7;
  }
  v5 = *(uint64_t **)(DerivedStorage + 56);
  if (v5)
  {
LABEL_7:
    v6 = *v5;
    goto LABEL_8;
  }
  v6 = 0;
LABEL_8:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v6;
}

void fnh_purgeExpiredListEntriesOnQueue(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  const __CFAllocator *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  const __CFAllocator *v20;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v5 = *(uint64_t **)(DerivedStorage + 40);
  if (v5)
  {
    v6 = (_QWORD *)DerivedStorage;
    v7 = a2 - *(_QWORD *)(DerivedStorage + 16);
    do
    {
      v8 = v5[3];
      if (v8 < *v5)
      {
LABEL_11:
        v8 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else
      {
        v9 = v5;
        do
        {
          if (*v9 >= v8)
            break;
          v10 = v9[3];
          if (v10 < *v9)
            goto LABEL_11;
          if (v8 <= v10)
            v8 = v9[3];
          v9 = (uint64_t *)v9[7];
        }
        while (v9);
      }
      if (v8 > v7)
        break;
      v11 = v5[7];
      v12 = (uint64_t *)v5[8];
      if (v11)
      {
        *(_QWORD *)(v11 + 64) = v12;
        v12 = (uint64_t *)v5[8];
      }
      else
      {
        v6[6] = v12;
      }
      *v12 = v11;
      v13 = CFGetAllocator(a1);
      CFAllocatorDeallocate(v13, v5);
      --v6[12];
      v5 = (uint64_t *)v6[5];
    }
    while (v5);
  }
  v14 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v15 = *(_QWORD **)(v14 + 56);
  if (v15)
  {
    v16 = v14;
    v17 = a2 - *(_QWORD *)(v14 + 16);
    do
    {
      if (v17 <= v15[1])
        break;
      CMBaseObjectGetDerivedStorage((uint64_t)a1);
      v18 = v15[4];
      v19 = (_QWORD *)v15[5];
      if (v18)
      {
        *(_QWORD *)(v18 + 40) = v19;
        v19 = (_QWORD *)v15[5];
      }
      else
      {
        *(_QWORD *)(v16 + 64) = v19;
      }
      *v19 = v18;
      v20 = CFGetAllocator(a1);
      CFAllocatorDeallocate(v20, v15);
      v15 = *(_QWORD **)(v16 + 56);
    }
    while (v15);
  }
}

uint64_t FigNetworkHistoryCopySharedPredictor(const void *a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  id *v6;
  const void *v7;
  uint64_t v8;
  const void *v9;
  CFTypeRef v10;
  uint64_t v11;
  CFTypeRef cf;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  cf = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  v6 = *(id **)(DerivedStorage + 112);
  if (v6)
  {
    v7 = FigCFWeakReferenceHolderCopyReferencedObject(v6);
    cf = v7;
    if (v7)
      goto LABEL_8;
  }
  v8 = FigNetworkHistoricalPredictorCreate(*MEMORY[0x1E0C9AE00], a1, v5, &cf);
  if (!(_DWORD)v8)
  {
    v9 = *(const void **)(DerivedStorage + 112);
    if (v9)
      CFRelease(v9);
    v10 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)cf);
    *(_QWORD *)(DerivedStorage + 112) = v10;
    if (v10)
    {
      v7 = cf;
LABEL_8:
      v11 = 0;
      *a2 = v7;
      cf = 0;
      goto LABEL_9;
    }
    v8 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  v11 = v8;
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  if (cf)
    CFRelease(cf);
  return v11;
}

uint64_t FigNetworkHistoricalPredictorCreate(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v7;
  _QWORD *DerivedStorage;
  CFTypeRef v9;
  pthread_mutex_t *v10;
  CFMutableDictionaryRef v11;
  uint64_t v12;
  uint64_t v14;
  CFDictionaryValueCallBacks v15;
  CFTypeRef cf;

  *(_OWORD *)&v15.version = xmmword_1E28DADC8;
  *(_OWORD *)&v15.release = *(_OWORD *)&off_1E28DADD8;
  v15.equal = 0;
  cf = 0;
  if (a4)
  {
    FigThreadRunOnce(&FigNetworkPredictorGetClassID_sRegisterFigNetworkPredictorBaseTypeOnce, (void (*)(void))RegisterFigNetworkPredictorBaseType);
    v7 = CMDerivedObjectCreate(a1, (uint64_t)&kFigNetworkHistoricalVTable, (_QWORD *)sFigNetworkPredictorClassID, &cf);
    if ((_DWORD)v7)
      goto LABEL_13;
    DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
    if (a2)
      v9 = CFRetain(a2);
    else
      v9 = 0;
    *DerivedStorage = v9;
    v10 = FigSimpleMutexCreate();
    DerivedStorage[1] = v10;
    if (v10)
    {
      v11 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], &v15);
      DerivedStorage[2] = v11;
      if (v11)
      {
        v12 = 0;
        *a4 = cf;
        return v12;
      }
    }
    v14 = 4294954510;
  }
  else
  {
    v14 = 4294949561;
  }
  v7 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
LABEL_13:
  v12 = v7;
  if (cf)
    CFRelease(cf);
  return v12;
}

uint64_t FigNetworkHistoryDisableThrottleDetection(uint64_t a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (!*(_BYTE *)(DerivedStorage + 34))
  {
    CMBaseObjectGetDerivedStorage(a1);
    *(_BYTE *)(DerivedStorage + 34) = 1;
  }
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
}

uint64_t FigNetworkHistoryGetClassID()
{
  FigThreadRunOnce(&FigNetworkHistoryGetClassID_sRegisterFigNetworkHistoryBaseTypeOnce, (void (*)(void))RegisterFigNetworkHistoryBaseType);
  return sFigNetworkHistoryClassID;
}

uint64_t RegisterFigNetworkHistoryBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigNetworkHistoryClassDesc, ClassID, 1, &sFigNetworkHistoryClassID);
}

uint64_t FigNetworkHistoryGetCFTypeID()
{
  FigThreadRunOnce(&FigNetworkHistoryGetClassID_sRegisterFigNetworkHistoryBaseTypeOnce, (void (*)(void))RegisterFigNetworkHistoryBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigNetworkHistoryClassID);
}

uint64_t FigNetworkHistoryCreate(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v6;
  uint64_t DerivedStorage;
  pthread_mutex_t *v8;
  dispatch_queue_t v9;
  uint64_t v10;
  CFTypeRef cf;

  cf = 0;
  if (a3)
  {
    fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigNetworkHistoryTrace[1], CFSTR("fnh_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFigNetworkHistoryTrace);
    fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigNetworkHistoryTrace[3], CFSTR("fnh_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &gFigNetworkHistoryTrace[2]);
    FigThreadRunOnce(&FigNetworkHistoryGetClassID_sRegisterFigNetworkHistoryBaseTypeOnce, (void (*)(void))RegisterFigNetworkHistoryBaseType);
    v6 = CMDerivedObjectCreate(a1, (uint64_t)&kNetworkHistory_VTable, (_QWORD *)sFigNetworkHistoryClassID, &cf);
    if (!(_DWORD)v6)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      v8 = FigSimpleMutexCreate();
      *(_QWORD *)DerivedStorage = v8;
      if (v8)
      {
        v9 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.networkhistory.notification", 0, 0);
        *(_QWORD *)(DerivedStorage + 8) = v9;
        if (v9)
        {
          *(_QWORD *)(DerivedStorage + 128) = 0;
          *(_QWORD *)(DerivedStorage + 136) = DerivedStorage + 128;
          *(_QWORD *)(DerivedStorage + 40) = 0;
          *(_QWORD *)(DerivedStorage + 48) = DerivedStorage + 40;
          *(_QWORD *)(DerivedStorage + 56) = 0;
          *(_QWORD *)(DerivedStorage + 64) = DerivedStorage + 56;
          *(_OWORD *)(DerivedStorage + 16) = xmmword_18EDDCC40;
          *(int64x2_t *)(DerivedStorage + 72) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
          *(_WORD *)(DerivedStorage + 32) = 257;
          *(_QWORD *)(DerivedStorage + 88) = 0;
          *(_QWORD *)(DerivedStorage + 96) = 0;
          if (a2)
          {
            FigCFDictionaryGetInt64IfPresent(a2, CFSTR("NetworkHistoryCreateOption_MaxWindowSize"), (void *)(DerivedStorage + 16));
            FigCFDictionaryGetInt64IfPresent(a2, CFSTR("NetworkHistoryCreateOption_BytesReceivedMaxResolution"), (void *)(DerivedStorage + 24));
            FigCFDictionaryGetBooleanIfPresent(a2, CFSTR("NetworkHistoryCreateOption_EnableLogging"), (Boolean *)(DerivedStorage + 32));
            FigCFDictionaryGetBooleanIfPresent(a2, CFSTR("NetworkHistoryCreateOption_ContributesToGlobalHistory"), (Boolean *)(DerivedStorage + 33));
          }
          CMBaseObjectGetDerivedStorage((uint64_t)cf);
          v10 = 0;
          *a3 = cf;
          return v10;
        }
      }
      v6 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    v10 = v6;
    if (cf)
      CFRelease(cf);
    return v10;
  }
  return FigSignalErrorAt(4294949566, 0, 0, 0, 0, 0, 0);
}

uint64_t FigNetworkPredictorGetClassID()
{
  FigThreadRunOnce(&FigNetworkPredictorGetClassID_sRegisterFigNetworkPredictorBaseTypeOnce, (void (*)(void))RegisterFigNetworkPredictorBaseType);
  return sFigNetworkPredictorClassID;
}

uint64_t RegisterFigNetworkPredictorBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigNetworkPredictorClassDesc, ClassID, 1, &sFigNetworkPredictorClassID);
}

uint64_t FigNetworkPredictorGetCFTypeID()
{
  FigThreadRunOnce(&FigNetworkPredictorGetClassID_sRegisterFigNetworkPredictorBaseTypeOnce, (void (*)(void))RegisterFigNetworkPredictorBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigNetworkPredictorClassID);
}

void fnhp_freeBandwidthPredictionCacheEntry(int a1, void *a2)
{
  free(a2);
}

uint64_t fnh_updateEarliestActiveRequestFirstBytesSentTimestamp(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  result = CMBaseObjectGetDerivedStorage(a1);
  v4 = 0x7FFFFFFFFFFFFFFFLL;
  *(int64x2_t *)(result + 72) = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  v5 = *(uint64_t **)(result + 40);
  if (v5)
  {
    do
    {
      v6 = *v5;
      if (v5[3] < *v5)
      {
        v7 = v5[1];
        v8 = v5[2];
        if (!v7)
          v7 = *v5;
        if (v7 + 250000000 < v4 && (unint64_t)(a2 - v6) > 0x1DCD6500)
          v10 = v7 + 250000000;
        else
          v10 = v4;
        v11 = v8 - v7;
        if (v8 < v7)
          ++v11;
        v12 = v7 + (v11 >> 1);
        if (v12 < v4)
          v4 = v12;
        if (v8 < 1)
          v4 = v10;
        if (v6 >= v4)
          v6 = v4;
        *(_QWORD *)(result + 72) = v4;
        *(_QWORD *)(result + 80) = v6;
      }
      v5 = (uint64_t *)v5[7];
    }
    while (v5);
    if (v4 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v4 <= *(_QWORD *)(result + 88))
        v4 = *(_QWORD *)(result + 88);
      *(_QWORD *)(result + 88) = v4;
    }
  }
  return result;
}

uint64_t fnh_addBytesToBytesReceivedEntriesBetweenTimestamps(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  uint64_t v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t *v14;
  const __CFAllocator *v15;
  uint64_t result;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t **v20;
  uint64_t v21;
  const __CFAllocator *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t **v26;
  uint64_t v27;
  uint64_t v28;
  const __CFAllocator *v29;
  uint64_t **v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t **v35;
  uint64_t **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  double v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v60;
  uint64_t v61;
  uint64_t *v62;
  const __CFAllocator *v63;
  uint64_t v64;
  uint64_t v65;
  const __CFAllocator *v66;
  uint64_t v67;
  const __CFAllocator *v68;
  uint64_t **v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t *v72;
  uint64_t **v73;
  uint64_t **v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  __int128 __s1;
  __int128 v80;
  __int128 v81;
  uint64_t *v82;
  uint64_t *v83;
  uint64_t *v84;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a4 - 2 * *(_QWORD *)(DerivedStorage + 16) <= a3)
    v11 = a3;
  else
    v11 = a4 - 2 * *(_QWORD *)(DerivedStorage + 16);
  v12 = (uint64_t **)(DerivedStorage + 56);
  v78 = DerivedStorage;
  v13 = (uint64_t **)(DerivedStorage + 64);
  v14 = **(uint64_t ***)(*(_QWORD *)(DerivedStorage + 64) + 8);
  v82 = 0;
  v83 = v14;
  if (!v14)
  {
    v15 = CFGetAllocator(a1);
    result = fnh_createBytesReceivedEntry(v15, a4, &v83);
    if ((_DWORD)result)
      return result;
    v17 = (uint64_t)*v12;
    v14 = v83;
    v18 = v83;
    v83[4] = (uint64_t)*v12;
    v19 = v18 + 4;
    if (v17)
      v20 = (uint64_t **)(v17 + 40);
    else
      v20 = v13;
    *v20 = v19;
    *v12 = v14;
    v14[5] = (uint64_t)v12;
  }
  v77 = a4 - v11;
  while (1)
  {
    v21 = *v14;
    if (*v14 <= a4)
      break;
    v14 = **(uint64_t ***)(v14[5] + 8);
    if (!v14)
    {
      v83 = 0;
      v22 = CFGetAllocator(a1);
      result = fnh_createBytesReceivedEntry(v22, a4, &v83);
      if ((_DWORD)result)
        return result;
      v23 = *v12;
      v14 = v83;
      v24 = v83;
      v83[4] = (uint64_t)*v12;
      v25 = v24 + 4;
      if (v23)
        v26 = (uint64_t **)(v23 + 5);
      else
        v26 = v13;
      *v26 = v25;
      *v12 = v14;
LABEL_27:
      v14[5] = (uint64_t)v12;
      goto LABEL_28;
    }
  }
  v27 = v14[1];
  if (v11 > v27)
    goto LABEL_22;
  v28 = v27 - 1;
  if (v28 > v21)
    v21 = v28;
  if (*(_QWORD *)(v78 + 24) + v21 / *(_QWORD *)(v78 + 24) * *(_QWORD *)(v78 + 24) < a4)
  {
LABEL_22:
    v29 = CFGetAllocator(a1);
    result = fnh_createBytesReceivedEntry(v29, a4, &v82);
    if ((_DWORD)result)
      return result;
    v31 = v14[4];
    v30 = (uint64_t **)(v14 + 4);
    v12 = v30;
    v32 = v82;
    v33 = v82;
    v82[4] = v31;
    v34 = v33 + 4;
    v35 = (uint64_t **)(v31 + 40);
    if (v31)
      v36 = v35;
    else
      v36 = v13;
    *v36 = v34;
    *v30 = v32;
    v14 = v32;
    goto LABEL_27;
  }
LABEL_28:
  v37 = *(_QWORD *)(v78 + 24);
  v39 = v14 + 1;
  v38 = v14[1];
  v40 = v38 - 1;
  v41 = *v14;
  if (v38 - 1 <= *v14)
    v40 = *v14;
  v42 = v37 + v40 / v37 * v37;
  if (v11 >= v42)
  {
    v43 = 0;
LABEL_84:
    if (v43)
    {
      do
      {
        v14[2] = a5;
        v14 = (uint64_t *)v14[4];
      }
      while (v14);
    }
  }
  else
  {
    v43 = 0;
    v44 = (double)a2;
    v45 = v14;
    while (1)
    {
      v46 = v41 / v37 * v37;
      if (v11 <= v46)
        v47 = v46;
      else
        v47 = v11;
      if (v42 >= a4)
        v48 = a4;
      else
        v48 = v42;
      if (v77 < 1)
        v49 = 1.0;
      else
        v49 = (double)(v48 - v47) / (double)v77;
      v50 = (uint64_t)(v49 * v44);
      v80 = 0u;
      v81 = 0u;
      __s1 = 0u;
      v51 = *(_OWORD *)v45;
      v52 = *((_OWORD *)v45 + 2);
      v80 = *((_OWORD *)v45 + 1);
      v81 = v52;
      __s1 = v51;
      if (v41 >= v47)
        v41 = v47;
      *v45 = v41;
      if (v38 <= v48)
        v38 = v48;
      *v39 = v38;
      v45[3] += v50;
      if (!v43 && !memcmp(&__s1, v45, 0x30uLL))
      {
        v43 = 0;
      }
      else
      {
        v45[2] = a5;
        v43 = 1;
      }
      v53 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      v54 = **(uint64_t ***)(v45[5] + 8);
      if (v54)
      {
        v55 = v53;
        do
        {
          v56 = *v45;
          v58 = *v54;
          v57 = v54[1];
          if (*v45 >= v57 && v56 != v58)
            break;
          if (v56 >= v58)
            v56 = *v54;
          *v45 = v56;
          if (*v39 > v57)
            v57 = *v39;
          *v39 = v57;
          v45[3] += v54[3];
          v61 = v54[4];
          v60 = v54[5];
          v62 = **(uint64_t ***)(v60 + 8);
          if (v61)
          {
            *(_QWORD *)(v61 + 40) = v60;
            v60 = v54[5];
          }
          else
          {
            *(_QWORD *)(v55 + 64) = v60;
          }
          *(_QWORD *)v60 = v61;
          v63 = CFGetAllocator(a1);
          CFAllocatorDeallocate(v63, v54);
          v54 = v62;
        }
        while (v62);
      }
      CMBaseObjectGetDerivedStorage((uint64_t)a1);
      if (v11 >= *v45)
        break;
      v64 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      v65 = *v45 - 1;
      v14 = **(uint64_t ***)(v45[5] + 8);
      v84 = v14;
      if (v14)
      {
        if (v65 > v14[1])
        {
          v66 = CFGetAllocator(a1);
          result = fnh_createBytesReceivedEntry(v66, v65, &v84);
          if ((_DWORD)result)
            return result;
          v14 = v84;
          v84[5] = v45[5];
          v14[4] = (uint64_t)v45;
          *(_QWORD *)v45[5] = v14;
          v45[5] = (uint64_t)(v14 + 4);
        }
      }
      else
      {
        v67 = v64;
        v68 = CFGetAllocator(a1);
        result = fnh_createBytesReceivedEntry(v68, v65, &v84);
        if ((_DWORD)result)
          return result;
        v70 = *(_QWORD *)(v67 + 56);
        v69 = (uint64_t **)(v67 + 56);
        v14 = v84;
        v71 = v84;
        v84[4] = v70;
        v72 = v71 + 4;
        v73 = (uint64_t **)(v70 + 40);
        if (v70)
          v74 = v73;
        else
          v74 = v69 + 1;
        *v74 = v72;
        *v69 = v14;
        v14[5] = (uint64_t)v69;
      }
      v75 = (_QWORD *)v14[4];
      if (v75 && v14[1] > *v75)
      {
        result = FigSignalErrorAt(4294949564, 0, 0, 0, 0, 0, 0);
        v14 = v45;
        if ((_DWORD)result)
          return result;
      }
      else
      {
        v45 = v14;
      }
      v37 = *(_QWORD *)(v78 + 24);
      v39 = v14 + 1;
      v38 = v14[1];
      v76 = v38 - 1;
      v41 = *v14;
      if (v38 - 1 <= *v14)
        v76 = *v14;
      v42 = v37 + v76 / v37 * v37;
      if (v11 >= v42)
        goto LABEL_84;
    }
  }
  return 0;
}

uint64_t fnh_createBytesReceivedEntry(const __CFAllocator *a1, uint64_t a2, _QWORD *a3)
{
  _OWORD *v5;

  v5 = CFAllocatorAllocate(a1, 48, 0);
  if (!v5)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  *v5 = 0u;
  v5[1] = 0u;
  v5[2] = 0u;
  *(_QWORD *)v5 = a2;
  *((_QWORD *)v5 + 1) = a2;
  *((_QWORD *)v5 + 2) = a2;
  *a3 = v5;
  return 0;
}

void fnh_runAllEnqueuedCommands(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  void (*v9)(_OWORD *);
  __int128 v10;
  _QWORD *v11;
  const void *v12;
  _OWORD v13[2];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v5 = *(char **)(DerivedStorage + 128);
  if (v5)
  {
    v6 = DerivedStorage;
    do
    {
      v7 = (char *)*((_QWORD *)v5 + 5);
      v8 = v7;
      if (!a2)
      {
        CMBaseObjectGetDerivedStorage(a1);
        v9 = *(void (**)(_OWORD *))v5;
        v10 = *(_OWORD *)(v5 + 24);
        v13[0] = *(_OWORD *)(v5 + 8);
        v13[1] = v10;
        v9(v13);
        v8 = (char *)*((_QWORD *)v5 + 5);
      }
      v11 = (_QWORD *)*((_QWORD *)v5 + 6);
      if (v8)
      {
        *((_QWORD *)v8 + 6) = v11;
        v11 = (_QWORD *)*((_QWORD *)v5 + 6);
      }
      else
      {
        *(_QWORD *)(v6 + 136) = v11;
      }
      *v11 = v8;
      v12 = (const void *)*((_QWORD *)v5 + 1);
      if (v12)
        CFRelease(v12);
      free(v5);
      v5 = v7;
    }
    while (v7);
  }
}

CFStringRef FigNetworkHistoryCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigNetworkHistory %p]"), a1);
}

const __CFAllocator *fnh_finalize(const void *a1)
{
  uint64_t *DerivedStorage;
  _QWORD *v3;
  _QWORD *i;
  uint64_t v5;
  _QWORD *v6;
  const __CFAllocator *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  const __CFAllocator *v13;
  const void *v14;
  NSObject *v15;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  fnh_runAllEnqueuedCommands((uint64_t)a1, 1);
  v3 = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  for (i = (_QWORD *)v3[5]; i; i = (_QWORD *)v3[5])
  {
    v5 = i[7];
    v6 = (_QWORD *)i[8];
    if (v5)
    {
      *(_QWORD *)(v5 + 64) = v6;
      v6 = (_QWORD *)i[8];
    }
    else
    {
      v3[6] = v6;
    }
    *v6 = v5;
    v7 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v7, i);
  }
  v3[12] = 0;
  v8 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v9 = *(_QWORD **)(v8 + 56);
  if (v9)
  {
    v10 = v8;
    do
    {
      v11 = v9[4];
      v12 = (_QWORD *)v9[5];
      if (v11)
      {
        *(_QWORD *)(v11 + 40) = v12;
        v12 = (_QWORD *)v9[5];
      }
      else
      {
        *(_QWORD *)(v10 + 64) = v12;
      }
      *v12 = v11;
      v13 = CFGetAllocator(a1);
      CFAllocatorDeallocate(v13, v9);
      v9 = *(_QWORD **)(v10 + 56);
    }
    while (v9);
  }
  v14 = (const void *)DerivedStorage[14];
  if (v14)
    CFRelease(v14);
  v15 = DerivedStorage[1];
  if (v15)
    dispatch_release(v15);
  return FigSimpleMutexDestroy(*DerivedStorage);
}

pthread_mutex_t *fnh_globalNetworkHistoryOnce()
{
  pthread_mutex_t *result;

  result = FigSimpleMutexCreate();
  gNetworkHistoryAccessorMutex = (uint64_t)result;
  return result;
}

CFStringRef FigNetworkPredictorCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigNetworkPredictor %p]"), a1);
}

const __CFAllocator *fnhp_finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_QWORD *)DerivedStorage)
    CFRelease(*(CFTypeRef *)DerivedStorage);
  v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
    CFRelease(v2);
  return FigSimpleMutexDestroy(*(_QWORD *)(DerivedStorage + 8));
}

uint64_t fnhp_copyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  CFTypeRef *DerivedStorage;
  CFTypeRef v7;
  uint64_t result;

  DerivedStorage = (CFTypeRef *)CMBaseObjectGetDerivedStorage(a1);
  if (!CFEqual(a2, CFSTR("NetworkPredictorProperty_History")))
    return 4294949566;
  if (*DerivedStorage)
    v7 = CFRetain(*DerivedStorage);
  else
    v7 = 0;
  result = 0;
  *a4 = v7;
  return result;
}

uint64_t fnhp_makePrediction(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *DerivedStorage;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  double (*v45)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t *v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 *v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  uint64_t *v107;
  uint64_t StartTimestamp;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  double v113;
  double v114;
  double v115;
  uint64_t v116;
  double v117;
  __int128 v118;
  __int128 v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  double v131;
  double v132;
  double v133;
  uint64_t v134;
  uint64_t v135;
  int NextBandwidthSample;
  double v137;
  double v138;
  double v139;
  uint64_t v140;
  double v141;
  double v142;
  double v143;
  uint64_t v144;
  uint64_t v146;
  uint64_t v147;
  uint64_t *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  char v155;
  uint64_t v156;
  double v157;
  double v158;
  double v159;
  uint64_t v160;
  uint64_t v161;
  int v162;
  double v165;
  double v166;
  double v167;
  _BOOL4 v168;
  _BOOL4 v169;
  double v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  int v176;
  int v177;
  int64_t v178;
  unint64_t v179;
  uint64_t *v180;
  unint64_t v181;
  unint64_t v182;
  uint64_t v183;
  double v184;
  double v185;
  uint64_t v186;
  unint64_t v187;
  double v188;
  uint64_t v189;
  uint64_t v190;
  unint64_t v191;
  double v192;
  BOOL v193;
  unint64_t v194;
  double v195;
  __int128 v196;
  __int128 v197;
  _QWORD *v198;
  uint64_t v199;
  uint64_t *v200;
  uint64_t v201;
  uint64_t v202;
  __int128 v203;
  char v204;
  int v205;
  uint64_t v206;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226[2];
  __int128 v227;
  _BYTE v228[208];
  __int128 v229;
  __int128 v230;
  _BYTE v231[192];
  uint64_t v232;

  v232 = *MEMORY[0x1E0C80C00];
  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_QWORD *)(a4 + 80) = 0;
  FigNetworkHistoryBeginImmutabilty(*DerivedStorage);
  switch(*(_QWORD *)a3)
  {
    case 0:
      v8 = *(_OWORD *)(a3 + 176);
      v219 = *(_OWORD *)(a3 + 160);
      v220 = v8;
      v9 = *(_OWORD *)(a3 + 208);
      v221 = *(_OWORD *)(a3 + 192);
      v222 = v9;
      v10 = *(_OWORD *)(a3 + 112);
      v215 = *(_OWORD *)(a3 + 96);
      v216 = v10;
      v11 = *(_OWORD *)(a3 + 144);
      v217 = *(_OWORD *)(a3 + 128);
      v218 = v11;
      v12 = *(_OWORD *)(a3 + 48);
      v211 = *(_OWORD *)(a3 + 32);
      v212 = v12;
      v13 = *(_OWORD *)(a3 + 80);
      v213 = *(_OWORD *)(a3 + 64);
      v214 = v13;
      v14 = *(_OWORD *)(a3 + 16);
      v209 = *(_OWORD *)a3;
      v210 = v14;
      v15 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
      v223 = 0;
      v16 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(*v15) + 24);
      *(_OWORD *)&v228[144] = v219;
      *(_OWORD *)&v228[160] = v220;
      *(_OWORD *)&v228[176] = v221;
      *(_OWORD *)&v228[192] = v222;
      *(_OWORD *)&v228[80] = v215;
      *(_OWORD *)&v228[96] = v216;
      *(_OWORD *)&v228[112] = v217;
      *(_OWORD *)&v228[128] = v218;
      *(_OWORD *)&v228[16] = v211;
      *(_OWORD *)&v228[32] = v212;
      *(_OWORD *)&v228[48] = v213;
      *(_OWORD *)&v228[64] = v214;
      v227 = v209;
      *(_OWORD *)v228 = v210;
      fnhp_medianAlgorithmForLatency(a1, a2, &v227, v16, (_QWORD *)(a4 + 32), (double *)(a4 + 40), &v223);
      *(_OWORD *)&v231[128] = v219;
      *(_OWORD *)&v231[144] = v220;
      *(_OWORD *)&v231[160] = v221;
      *(_OWORD *)&v231[176] = v222;
      *(_OWORD *)&v231[64] = v215;
      *(_OWORD *)&v231[80] = v216;
      *(_OWORD *)&v231[96] = v217;
      *(_OWORD *)&v231[112] = v218;
      *(_OWORD *)v231 = v211;
      *(_OWORD *)&v231[16] = v212;
      *(_OWORD *)&v231[32] = v213;
      *(_OWORD *)&v231[48] = v214;
      v229 = v209;
      v230 = v210;
      v17 = v223;
      v225 = 0;
      v226[0] = 0;
      *(_QWORD *)&v208 = 0;
      v224 = 0;
      v227 = v209;
      *(_OWORD *)v228 = v210;
      *(_OWORD *)&v228[152] = *(_OWORD *)&v231[136];
      *(_OWORD *)&v228[168] = *(_OWORD *)&v231[152];
      *(_OWORD *)&v228[184] = *(_OWORD *)&v231[168];
      *(_OWORD *)&v228[88] = *(_OWORD *)&v231[72];
      *(_OWORD *)&v228[104] = *(_OWORD *)&v231[88];
      *(_OWORD *)&v228[120] = *(_OWORD *)&v231[104];
      *(_OWORD *)&v228[136] = *(_OWORD *)&v231[120];
      *(_OWORD *)&v228[24] = *(_OWORD *)&v231[8];
      *(_OWORD *)&v228[40] = *(_OWORD *)&v231[24];
      *(_OWORD *)&v228[56] = *(_OWORD *)&v231[40];
      *(_OWORD *)&v228[72] = *(_OWORD *)&v231[56];
      *(_QWORD *)&v228[200] = *((_QWORD *)&v222 + 1);
      *(_QWORD *)&v228[16] = 0;
      v18 = fnhp_constantLatencyTimeWeightedAlgorithmForBandwidth(a1, 0, a2, &v227, (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_constantWeightForBandwidthSample, 0, v226, (double *)&v225, (double *)&v224, (uint64_t *)&v208);
      if ((_DWORD)v18)
        goto LABEL_30;
      if (v17 >= 0)
        v19 = v17;
      else
        v19 = v17 + 1;
      v20 = v208 + (v19 >> 1);
      if (v20 < 1)
        v21 = 0.0;
      else
        v21 = (double)v226[0] + (double)(v19 >> 1) / (double)v20 * (0.0 - (double)v226[0]);
      *(_QWORD *)a4 = llround(v21);
      v22 = v224;
      *(_QWORD *)(a4 + 8) = v225;
      *(_QWORD *)(a4 + 16) = v22;
      *(_QWORD *)(a4 + 48) = v20;
      goto LABEL_28;
    case 1:
      v24 = *(_OWORD *)(a3 + 176);
      *(_OWORD *)&v228[144] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v228[160] = v24;
      v25 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v228[192] = v25;
      v26 = *(_OWORD *)(a3 + 112);
      *(_OWORD *)&v228[80] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v228[96] = v26;
      v27 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v228[112] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v228[128] = v27;
      v28 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)&v228[16] = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v228[32] = v28;
      v29 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v228[48] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v228[64] = v29;
      v30 = *(_OWORD *)(a3 + 16);
      v227 = *(_OWORD *)a3;
      *(_OWORD *)v228 = v30;
      v23 = fnhp_constantLatencyPredictionAlgorithm(a1, a2, &v227, a4);
      goto LABEL_11;
    case 2:
      v31 = *(_OWORD *)(a3 + 176);
      v32 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[144] = v31;
      v33 = *(_OWORD *)(a3 + 176);
      v34 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v231[160] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v231[176] = v34;
      v35 = *(_OWORD *)(a3 + 112);
      v36 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v35;
      v37 = *(_OWORD *)(a3 + 112);
      v38 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v38;
      v39 = *(_OWORD *)(a3 + 48);
      v40 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v39;
      v41 = *(_OWORD *)(a3 + 48);
      v42 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v42;
      v43 = *(_OWORD *)(a3 + 16);
      v229 = *(_OWORD *)a3;
      v230 = v43;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = v33;
      v44 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = v44;
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = v37;
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = v32;
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = v41;
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = v36;
      v227 = v229;
      *(_OWORD *)v228 = v40;
      v45 = (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_linearTimeWeightForBandwidthSample;
      goto LABEL_18;
    case 3:
      v46 = *(_OWORD *)(a3 + 176);
      v47 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[144] = v46;
      v48 = *(_OWORD *)(a3 + 176);
      v49 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v231[160] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v231[176] = v49;
      v50 = *(_OWORD *)(a3 + 112);
      v51 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v50;
      v52 = *(_OWORD *)(a3 + 112);
      v53 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v53;
      v54 = *(_OWORD *)(a3 + 48);
      v55 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v54;
      v56 = *(_OWORD *)(a3 + 48);
      v57 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v57;
      v58 = *(_OWORD *)(a3 + 16);
      v229 = *(_OWORD *)a3;
      v230 = v58;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = v48;
      v59 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = v59;
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = v52;
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = v47;
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = v56;
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = v51;
      v227 = v229;
      *(_OWORD *)v228 = v55;
      v45 = (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_quadraticTimeWeightForBandwidthSample;
      goto LABEL_18;
    case 4:
      v208 = *(_OWORD *)a3;
      v60 = *(_QWORD *)(a3 + 16);
      v61 = *(_OWORD *)(a3 + 168);
      v62 = *(_OWORD *)(a3 + 200);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 184);
      *(_OWORD *)&v231[144] = v62;
      *(_QWORD *)&v231[160] = *(_QWORD *)(a3 + 216);
      v63 = *(_OWORD *)(a3 + 104);
      v64 = *(_OWORD *)(a3 + 136);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 120);
      *(_OWORD *)&v231[80] = v64;
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 152);
      *(_OWORD *)&v231[112] = v61;
      v65 = *(_OWORD *)(a3 + 40);
      v66 = *(_OWORD *)(a3 + 72);
      *(_OWORD *)v231 = *(_OWORD *)(a3 + 56);
      *(_OWORD *)&v231[16] = v66;
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 88);
      *(_OWORD *)&v231[48] = v63;
      v229 = *(_OWORD *)(a3 + 24);
      v230 = v65;
      v67 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
      v68 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(*v67) + 24);
      *(double *)v226 = (double)v60
                      / 1000000000.0
                      * ((double)v60
                       / 1000000000.0)
                      * 0.01
                      / ((double)v68
                       / 1000000000.0
                       * ((double)v68
                        / 1000000000.0));
      v227 = v208;
      *(_OWORD *)&v228[152] = *(_OWORD *)&v231[112];
      *(_OWORD *)&v228[168] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[184] = *(_OWORD *)&v231[144];
      *(_OWORD *)&v228[88] = *(_OWORD *)&v231[48];
      *(_OWORD *)&v228[104] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[120] = *(_OWORD *)&v231[80];
      *(_OWORD *)&v228[136] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[24] = v230;
      *(_OWORD *)&v228[40] = *(_OWORD *)v231;
      v226[1] = v68;
      *(_QWORD *)v228 = v60;
      *(_QWORD *)&v228[200] = *(_QWORD *)&v231[160];
      *(_OWORD *)&v228[56] = *(_OWORD *)&v231[16];
      *(_OWORD *)&v228[72] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[8] = v229;
      v18 = fnhp_timeWeightedConstantLatencyPredictionAlgorithm(a1, (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_quadraticTimeWeightWithHighPassUtilizationFilterForBandwidthSample, (uint64_t)v226, a2, &v227, a4);
      if ((_DWORD)v18)
        goto LABEL_30;
      v227 = v208;
      *(_OWORD *)&v228[152] = *(_OWORD *)&v231[112];
      *(_OWORD *)&v228[168] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[184] = *(_OWORD *)&v231[144];
      *(_OWORD *)&v228[88] = *(_OWORD *)&v231[48];
      *(_OWORD *)&v228[104] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[120] = *(_OWORD *)&v231[80];
      *(_OWORD *)&v228[136] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[24] = v230;
      *(_OWORD *)&v228[40] = *(_OWORD *)v231;
      *(_OWORD *)&v228[56] = *(_OWORD *)&v231[16];
      *(_QWORD *)v228 = v60;
      *(_QWORD *)&v228[200] = *(_QWORD *)&v231[160];
      *(_OWORD *)&v228[72] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[8] = v229;
      goto LABEL_20;
    case 5:
      v69 = *(_OWORD *)(a3 + 176);
      v70 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[144] = v69;
      v71 = *(_OWORD *)(a3 + 176);
      v72 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v231[160] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v231[176] = v72;
      v73 = *(_OWORD *)(a3 + 112);
      v74 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v73;
      v75 = *(_OWORD *)(a3 + 112);
      v76 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v76;
      v77 = *(_OWORD *)(a3 + 48);
      v78 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v77;
      v79 = *(_OWORD *)(a3 + 48);
      v80 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v80;
      v81 = *(_OWORD *)(a3 + 16);
      v229 = *(_OWORD *)a3;
      v230 = v81;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = v71;
      v82 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = v82;
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = v75;
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = v70;
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = v79;
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = v74;
      v227 = v229;
      *(_OWORD *)v228 = v78;
      v45 = (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_logisticTimeWeightForBandwidthSample;
LABEL_18:
      v18 = fnhp_timeWeightedConstantLatencyPredictionAlgorithm(a1, v45, 0, a2, &v227, a4);
      if ((_DWORD)v18)
        goto LABEL_30;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = *(_OWORD *)&v231[144];
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = *(_OWORD *)&v231[176];
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
      v227 = v229;
      *(_OWORD *)v228 = v230;
LABEL_20:
      v83 = *(_OWORD *)(a4 + 48);
      v211 = *(_OWORD *)(a4 + 32);
      v212 = v83;
      v213 = *(_OWORD *)(a4 + 64);
      *(_QWORD *)&v214 = *(_QWORD *)(a4 + 80);
      v84 = *(_OWORD *)(a4 + 16);
      v209 = *(_OWORD *)a4;
      v210 = v84;
      v85 = &v209;
      break;
    case 6:
      v86 = *(_OWORD *)(a3 + 176);
      v87 = *(_OWORD *)(a3 + 144);
      v219 = *(_OWORD *)(a3 + 160);
      v220 = v86;
      v88 = *(_OWORD *)(a3 + 176);
      v89 = *(_OWORD *)(a3 + 208);
      v221 = *(_OWORD *)(a3 + 192);
      v222 = v89;
      v90 = *(_OWORD *)(a3 + 112);
      v91 = *(_OWORD *)(a3 + 80);
      v215 = *(_OWORD *)(a3 + 96);
      v216 = v90;
      v92 = *(_OWORD *)(a3 + 112);
      v93 = *(_OWORD *)(a3 + 144);
      v217 = *(_OWORD *)(a3 + 128);
      v218 = v93;
      v94 = *(_OWORD *)(a3 + 48);
      v95 = *(_OWORD *)(a3 + 16);
      v211 = *(_OWORD *)(a3 + 32);
      v212 = v94;
      v96 = *(_OWORD *)(a3 + 48);
      v97 = *(_OWORD *)(a3 + 80);
      v213 = *(_OWORD *)(a3 + 64);
      v214 = v97;
      v98 = *(_OWORD *)(a3 + 16);
      v209 = *(_OWORD *)a3;
      v210 = v98;
      v99 = *(_OWORD *)(a3 + 176);
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[144] = v99;
      v100 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v231[160] = *(_OWORD *)(a3 + 192);
      *(_OWORD *)&v231[176] = v100;
      v101 = *(_OWORD *)(a3 + 112);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v101;
      v102 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v102;
      v103 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v103;
      v104 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v104;
      v105 = *(_OWORD *)(a3 + 16);
      v229 = *(_OWORD *)a3;
      v230 = v105;
      *(_OWORD *)&v228[144] = v219;
      *(_OWORD *)&v228[160] = v88;
      v106 = *(_OWORD *)(a3 + 208);
      *(_OWORD *)&v228[176] = v221;
      *(_OWORD *)&v228[192] = v106;
      *(_OWORD *)&v228[80] = v215;
      *(_OWORD *)&v228[96] = v92;
      *(_OWORD *)&v228[112] = v217;
      *(_OWORD *)&v228[128] = v87;
      *(_OWORD *)&v228[16] = v211;
      *(_OWORD *)&v228[32] = v96;
      *(_OWORD *)&v228[48] = v213;
      *(_OWORD *)&v228[64] = v91;
      v227 = v209;
      *(_OWORD *)v228 = v95;
      v107 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
      StartTimestamp = fnhp_getStartTimestamp(a1, a2, (uint64_t)&v227, 1);
      v227 = 0uLL;
      *(_QWORD *)v228 = 0;
      if (FigNetworkHistoryGetFirstLatencySampleAfterTime(*v107, StartTimestamp, v109, &v227))
      {
        v111 = 0;
        v112 = 0;
        v113 = 0.0;
        v114 = 0.0;
        do
        {
          ++v111;
          v112 += v227;
          v115 = (double)(uint64_t)v227 - v114;
          v114 = v114 + 1.0 / (double)v111 * v115;
          v113 = v113 + v115 * ((double)(uint64_t)v227 - v114);
        }
        while (FigNetworkHistoryGetNextValidLatencySample(*v107, *(_QWORD **)v228, v110, &v227));
        v116 = v112 / v111;
        if (v113 <= 2.22044605e-16)
          v117 = 0.0;
        else
          v117 = sqrt(v113 / (double)v111);
        *(double *)(a4 + 40) = v117;
      }
      else
      {
        v116 = 0;
      }
      *(_QWORD *)(a4 + 32) = v116;
      *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
      *(_OWORD *)&v228[160] = *(_OWORD *)&v231[144];
      *(_OWORD *)&v228[176] = *(_OWORD *)&v231[160];
      *(_OWORD *)&v228[192] = *(_OWORD *)&v231[176];
      *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
      *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
      *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
      *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
      *(_OWORD *)&v228[16] = *(_OWORD *)v231;
      *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
      *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
      *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
      v227 = v229;
      *(_OWORD *)v228 = v230;
      v18 = fnhp_constantLatencyTimeWeightedAlgorithmForBandwidth(a1, v116, a2, &v227, (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_logisticTimeWeightForBandwidthSample, 0, (uint64_t *)a4, (double *)(a4 + 8), (double *)(a4 + 16), (uint64_t *)(a4 + 48));
      if ((_DWORD)v18)
        goto LABEL_30;
LABEL_28:
      *(_OWORD *)&v228[144] = v219;
      *(_OWORD *)&v228[160] = v220;
      *(_OWORD *)&v228[176] = v221;
      *(_OWORD *)&v228[192] = v222;
      *(_OWORD *)&v228[80] = v215;
      *(_OWORD *)&v228[96] = v216;
      *(_OWORD *)&v228[112] = v217;
      *(_OWORD *)&v228[128] = v218;
      *(_OWORD *)&v228[16] = v211;
      *(_OWORD *)&v228[32] = v212;
      *(_OWORD *)&v228[48] = v213;
      *(_OWORD *)&v228[64] = v214;
      v227 = v209;
      *(_OWORD *)v228 = v210;
      v118 = *(_OWORD *)(a4 + 48);
      *(_OWORD *)v231 = *(_OWORD *)(a4 + 32);
      *(_OWORD *)&v231[16] = v118;
      *(_OWORD *)&v231[32] = *(_OWORD *)(a4 + 64);
      *(_QWORD *)&v231[48] = *(_QWORD *)(a4 + 80);
      v119 = *(_OWORD *)(a4 + 16);
      v229 = *(_OWORD *)a4;
      v230 = v119;
      v85 = &v229;
      break;
    case 7:
      v171 = *(_OWORD *)(a3 + 144);
      *(_OWORD *)&v231[96] = *(_OWORD *)(a3 + 128);
      *(_OWORD *)&v231[112] = v171;
      *(_OWORD *)&v231[128] = *(_OWORD *)(a3 + 160);
      *(_OWORD *)&v231[137] = *(_OWORD *)(a3 + 169);
      v172 = *(_OWORD *)(a3 + 80);
      *(_OWORD *)&v231[32] = *(_OWORD *)(a3 + 64);
      *(_OWORD *)&v231[48] = v172;
      v173 = *(_OWORD *)(a3 + 112);
      *(_OWORD *)&v231[64] = *(_OWORD *)(a3 + 96);
      *(_OWORD *)&v231[80] = v173;
      v174 = *(_OWORD *)(a3 + 16);
      v229 = *(_OWORD *)a3;
      v230 = v174;
      v175 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)v231 = *(_OWORD *)(a3 + 32);
      *(_OWORD *)&v231[16] = v175;
      v176 = *(unsigned __int8 *)(a3 + 185);
      v177 = *(unsigned __int8 *)(a3 + 186);
      LODWORD(v226[0]) = *(_DWORD *)(a3 + 187);
      BYTE4(v226[0]) = *(_BYTE *)(a3 + 191);
      v178 = *(_QWORD *)(a3 + 208);
      v203 = *(_OWORD *)(a3 + 192);
      v179 = *(_QWORD *)(a3 + 216);
      v180 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
      *(_QWORD *)&v214 = 0;
      v212 = 0u;
      v213 = 0u;
      v210 = 0u;
      v211 = 0u;
      v209 = 0u;
      v204 = v177;
      if (v176 || !v177)
      {
        v183 = 0;
        v18 = 0;
        v184 = 1.0;
        if (v176 && v177)
        {
          v199 = a4;
          v185 = 0.0;
          v186 = -3000000000;
          v206 = 4000000000;
          v187 = 3000000000;
          v181 = *((_QWORD *)&v203 + 1);
          do
          {
            if (v187 + v178 + 1000000000 >= a2)
            {
              v192 = 0.0;
            }
            else
            {
              v202 = v186;
              v205 = 0;
              v188 = 0.0;
              do
              {
                *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
                *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
                *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
                *(_OWORD *)&v228[153] = *(_OWORD *)&v231[137];
                *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
                *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
                *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
                *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
                v227 = v229;
                *(_OWORD *)v228 = v230;
                *(_OWORD *)&v228[16] = *(_OWORD *)v231;
                *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
                v228[169] = v176;
                v228[170] = v204;
                *(_DWORD *)&v228[171] = v226[0];
                v228[175] = BYTE4(v226[0]);
                *(_OWORD *)&v228[176] = v203;
                *(_QWORD *)&v228[192] = v187 + v178;
                *(_QWORD *)&v228[200] = 3000000000;
                fnhp_constantLatencyPredictionAlgorithm(a1, a2, &v227, (uint64_t)&v209);
                v189 = a2;
                v190 = v209;
                *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
                *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
                *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
                *(_OWORD *)&v228[153] = *(_OWORD *)&v231[137];
                *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
                *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
                *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
                *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
                v227 = v229;
                *(_OWORD *)v228 = v230;
                *(_OWORD *)&v228[16] = *(_OWORD *)v231;
                *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
                v228[169] = v176;
                v228[170] = v204;
                *(_DWORD *)&v228[171] = v226[0];
                v228[175] = BYTE4(v226[0]);
                *(_OWORD *)&v228[176] = v203;
                *(_QWORD *)&v228[192] = v178;
                *(_QWORD *)&v228[200] = v187;
                v191 = v189;
                fnhp_constantLatencyPredictionAlgorithm(a1, v189, &v227, (uint64_t)&v209);
                if (v190 && (_QWORD)v209)
                {
                  v188 = v188 + (double)(v190 - v209) * (double)(v190 - v209);
                  ++v205;
                }
                v178 += v187;
                a2 = v191;
              }
              while (v206 + v178 < v191);
              v186 = v202;
              v178 += v202;
              if (v205)
                v192 = v188 / (double)v205;
              else
                v192 = 0.0;
              v179 = v187;
            }
            if (v185 == 0.0)
            {
              v181 = v187;
            }
            else if (v192 < v185 && v192 != 0.0)
            {
              v181 = v187;
            }
            else
            {
              v192 = v185;
            }
            v186 -= 2000000000;
            v206 += 2000000000;
            v185 = v192;
            v193 = v187 >= 0x3F5476A00;
            v187 += 2000000000;
          }
          while (!v193);
          if (v181)
            v194 = v181;
          else
            v194 = v203;
          *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
          *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
          *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
          *(_OWORD *)&v228[153] = *(_OWORD *)&v231[137];
          *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
          *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
          *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
          *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
          v227 = v229;
          *(_OWORD *)v228 = v230;
          *(_OWORD *)&v228[16] = *(_OWORD *)v231;
          *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
          v228[169] = v176;
          v228[170] = v204;
          *(_DWORD *)&v228[171] = v226[0];
          v228[175] = BYTE4(v226[0]);
          *(_QWORD *)&v228[176] = v203;
          *(_QWORD *)&v228[184] = v194;
          *(_QWORD *)&v228[192] = a2 - v194;
          *(_QWORD *)&v228[200] = v179;
          v18 = fnhp_constantLatencyPredictionAlgorithm(a1, a2, &v227, (uint64_t)&v209);
          v184 = *((double *)&v209 + 1);
          v183 = v209;
          a4 = v199;
        }
        else
        {
          v181 = *((_QWORD *)&v203 + 1);
        }
      }
      else
      {
        if (v178)
        {
          v181 = *((_QWORD *)&v203 + 1);
          v182 = a2 - *((_QWORD *)&v203 + 1);
          if (v178 > (uint64_t)(a2 - *((_QWORD *)&v203 + 1)))
            v182 = v178;
        }
        else
        {
          v182 = a2 - *(_QWORD *)(CMBaseObjectGetDerivedStorage(*v180) + 16);
          v181 = *((_QWORD *)&v203 + 1);
        }
        *(_OWORD *)&v228[112] = *(_OWORD *)&v231[96];
        *(_OWORD *)&v228[128] = *(_OWORD *)&v231[112];
        *(_OWORD *)&v228[144] = *(_OWORD *)&v231[128];
        *(_OWORD *)&v228[153] = *(_OWORD *)&v231[137];
        *(_OWORD *)&v228[48] = *(_OWORD *)&v231[32];
        *(_OWORD *)&v228[64] = *(_OWORD *)&v231[48];
        *(_OWORD *)&v228[80] = *(_OWORD *)&v231[64];
        *(_OWORD *)&v228[96] = *(_OWORD *)&v231[80];
        v227 = v229;
        *(_OWORD *)v228 = v230;
        *(_OWORD *)&v228[16] = *(_OWORD *)v231;
        *(_OWORD *)&v228[32] = *(_OWORD *)&v231[16];
        v228[169] = 0;
        v228[170] = v204;
        *(_DWORD *)&v228[171] = v226[0];
        v228[175] = BYTE4(v226[0]);
        *(_QWORD *)&v228[176] = v203;
        *(_QWORD *)&v228[184] = v181;
        *(_QWORD *)&v228[192] = v182;
        *(_QWORD *)&v228[200] = v179;
        v18 = fnhp_constantLatencyPredictionAlgorithm(a1, a2, &v227, (uint64_t)&v209);
        v184 = *((double *)&v209 + 1);
        v183 = v209;
      }
      if (v184 <= 0.0)
        v195 = 1.0;
      else
        v195 = 1.0 / v184;
      *(double *)&v214 = v195;
      *(_QWORD *)&v213 = v181;
      *((_QWORD *)&v213 + 1) = v183;
      v196 = v212;
      *(_OWORD *)(a4 + 32) = v211;
      *(_OWORD *)(a4 + 48) = v196;
      v197 = v210;
      *(_OWORD *)a4 = v209;
      *(_OWORD *)(a4 + 16) = v197;
      *(_OWORD *)(a4 + 64) = v213;
      *(_QWORD *)(a4 + 80) = v214;
      if ((_DWORD)v18)
        goto LABEL_80;
      goto LABEL_31;
    default:
      v23 = FigSignalErrorAt(4294949561, 0, 0, 0, 0, 0, 0);
LABEL_11:
      v18 = v23;
      if ((_DWORD)v23)
        goto LABEL_80;
      goto LABEL_31;
  }
  fnhp_makeSafeBandwidthMultiplier((uint64_t)&v227, (uint64_t)v85);
  *(_QWORD *)(a4 + 24) = v120;
LABEL_30:
  if (!(_DWORD)v18)
  {
LABEL_31:
    if ((*(_BYTE *)(a3 + 8) & 1) == 0 || *(_BYTE *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 34))
      goto LABEL_77;
    v121 = *(_QWORD *)(a3 + 16);
    v122 = *(_QWORD *)(a3 + 24);
    v201 = a3;
    v123 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
    v124 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(*v123) + 24);
    memset(v228, 0, 32);
    v227 = 0u;
    FigNetworkHistoryBeginImmutabilty(*v123);
    if (v122)
      v125 = v122;
    else
      v125 = v121;
    if (!FigNetworkHistoryGetFirstBandwidthSampleAfterTime((const void *)*v123, (uint64_t)(a2 - v125) / v124 * v124, v124, a2, (uint64_t)&v227))
    {
      FigNetworkHistoryEndImmutability(*v123);
      goto LABEL_76;
    }
    v127 = (uint64_t *)a4;
    v128 = 0;
    v129 = 0;
    v130 = 0;
    v131 = 0.0;
    v132 = 0.0;
    v133 = 0.0;
    while (1)
    {
      v134 = *(_QWORD *)&v228[8];
      v135 = *(_QWORD *)&v228[16];
      NextBandwidthSample = FigNetworkHistoryGetNextBandwidthSample(*v123, *(uint64_t **)&v228[24], v124, v126, (uint64_t)&v227);
      if (v124 != v135)
        goto LABEL_49;
      v133 = v133 + 1.0;
      v137 = (double)(8 * v134) / ((double)v124 / 1000000000.0);
      if (v133 <= 2.22044605e-16)
      {
        v131 = v131 + (v137 - v132) * v137;
        v132 = 0.0;
      }
      else
      {
        v138 = v137 - v132;
        v132 = v132 + 1.0 / v133 * (v137 - v132);
        v131 = v131 + v138 * (v137 - v132);
        if (v131 > 2.22044605e-16)
        {
          v139 = sqrt(v131 / v133);
          goto LABEL_42;
        }
      }
      v139 = 0.0;
LABEL_42:
      ++v129;
      if (v139 / v132 <= 0.05)
      {
        v140 = v128 + 1;
        if (v128 > 1)
        {
          if (v137 < (double)v130)
            v137 = (double)v130;
          v130 = (uint64_t)v137;
          goto LABEL_69;
        }
        ++v128;
      }
      else
      {
        v128 = 0;
      }
LABEL_49:
      if (v128)
        v140 = v128;
      else
        v140 = 0;
      if (v128)
        v141 = v133;
      else
        v141 = 0.0;
      if (v128)
        v142 = v132;
      else
        v142 = 0.0;
      if (v128)
        v143 = v131;
      else
        v143 = 0.0;
      if (v128)
        v144 = v129;
      else
        v144 = 0;
      if (v129 >= 1)
      {
        v133 = v141;
        v132 = v142;
      }
      else
      {
        v140 = v128;
      }
      if (v129 >= 1)
      {
        v131 = v143;
        v129 = v144;
      }
LABEL_69:
      v128 = v140;
      if (!NextBandwidthSample)
      {
        FigNetworkHistoryEndImmutability(*v123);
        a4 = (uint64_t)v127;
        if (v130 >= 1 && v130 < *v127)
        {
          *v127 = v130;
          v127[3] = 0x3FEE666666666666;
        }
LABEL_76:
        a3 = v201;
LABEL_77:
        if ((*(_BYTE *)(a3 + 8) & 2) == 0 || *(_BYTE *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 34))
        {
          v18 = 0;
          break;
        }
        v198 = (_QWORD *)a4;
        v146 = *(_QWORD *)(a3 + 16);
        v147 = *(_QWORD *)(a3 + 24);
        v148 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
        v149 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(*v148) + 24);
        memset(v228, 0, 32);
        v227 = 0u;
        FigNetworkHistoryBeginImmutabilty(*v148);
        if (v147)
          v150 = v147;
        else
          v150 = v146;
        if (!FigNetworkHistoryGetFirstBandwidthSampleAfterTime((const void *)*v148, (uint64_t)(a2 - v150) / v149 * v149, v149, a2, (uint64_t)&v227))
        {
          FigNetworkHistoryEndImmutability(*v148);
          v18 = 4294949557;
          break;
        }
        v200 = DerivedStorage;
        v152 = 0;
        v153 = 0;
        v154 = 0;
        v155 = 0;
        v156 = 0;
        v157 = 0.0;
        v158 = 0.0;
        v159 = 0.0;
        while (1)
        {
LABEL_86:
          v160 = *(_QWORD *)&v228[8];
          v161 = *(_QWORD *)&v228[16];
          v162 = FigNetworkHistoryGetNextBandwidthSample(*v148, *(uint64_t **)&v228[24], v149, v151, (uint64_t)&v227);
          if (v149 == v161 && v160 >= 1 && v153 <= 10)
          {
            ++v153;
            v154 += v160;
LABEL_105:
            if (!v162)
              goto LABEL_111;
            continue;
          }
          if (v153 < 1)
            goto LABEL_105;
          if ((unint64_t)v153 >= 3)
            break;
          v154 = 0;
          v153 = 0;
          if (!v162)
            goto LABEL_111;
        }
        v159 = v159 + 1.0;
        v165 = (double)(8 * v154 / v153) / ((double)v149 / 1000000000.0);
        v166 = v165 - v158;
        if (v159 <= 2.22044605e-16)
        {
          v157 = v157 + v166 * v165;
          v158 = 0.0;
        }
        else
        {
          v158 = v158 + 1.0 / v159 * v166;
          v157 = v157 + v166 * (v165 - v158);
          if (v157 > 2.22044605e-16)
          {
            v167 = sqrt(v157 / v159);
            goto LABEL_98;
          }
        }
        v167 = 0.0;
LABEL_98:
        v154 = 0;
        v153 = 0;
        v168 = v152 > 1;
        v169 = v167 / v158 <= 0.05;
        v170 = (double)v156;
        if (v158 >= (double)v156)
          v170 = v158;
        ++v152;
        if (v168 && v169)
        {
          v156 = (uint64_t)v170;
          v155 = 1;
        }
        if (!v162)
        {
LABEL_111:
          FigNetworkHistoryEndImmutability(*v148);
          if (v155)
          {
            v18 = 0;
            *v198 = v156;
            v198[3] = 0x3FEE666666666666;
          }
          else
          {
            v18 = 4294949557;
          }
          DerivedStorage = v200;
          break;
        }
        goto LABEL_86;
      }
    }
  }
LABEL_80:
  FigNetworkHistoryEndImmutability(*DerivedStorage);
  return v18;
}

uint64_t fnhp_constantLatencyPredictionAlgorithm(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  _OWORD v25[5];
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;

  v6 = a3[11];
  v37 = a3[10];
  v38 = v6;
  v7 = a3[13];
  v39 = a3[12];
  v40 = v7;
  v8 = a3[7];
  v33 = a3[6];
  v34 = v8;
  v9 = a3[9];
  v35 = a3[8];
  v36 = v9;
  v10 = a3[3];
  v29 = a3[2];
  v30 = v10;
  v11 = a3[5];
  v31 = a3[4];
  v32 = v11;
  v12 = a3[1];
  v27 = *a3;
  v28 = v12;
  v13 = fnhp_timeWeightedConstantLatencyPredictionAlgorithm(a1, (double (*)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t))fnhp_constantWeightForBandwidthSample, 0, a2, &v27, a4);
  if (!(_DWORD)v13)
  {
    v14 = a3[11];
    v37 = a3[10];
    v38 = v14;
    v15 = a3[13];
    v39 = a3[12];
    v40 = v15;
    v16 = a3[7];
    v33 = a3[6];
    v34 = v16;
    v17 = a3[9];
    v35 = a3[8];
    v36 = v17;
    v18 = a3[3];
    v29 = a3[2];
    v30 = v18;
    v19 = a3[5];
    v31 = a3[4];
    v32 = v19;
    v20 = a3[1];
    v27 = *a3;
    v28 = v20;
    v21 = *(_OWORD *)(a4 + 48);
    v25[2] = *(_OWORD *)(a4 + 32);
    v25[3] = v21;
    v25[4] = *(_OWORD *)(a4 + 64);
    v26 = *(_QWORD *)(a4 + 80);
    v22 = *(_OWORD *)(a4 + 16);
    v25[0] = *(_OWORD *)a4;
    v25[1] = v22;
    fnhp_makeSafeBandwidthMultiplier((uint64_t)&v27, (uint64_t)v25);
    *(_QWORD *)(a4 + 24) = v23;
  }
  return v13;
}

void fnhp_medianAlgorithmForLatency(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, _QWORD *a5, double *a6, _QWORD *a7)
{
  uint64_t DerivedStorage;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t StartTimestamp;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  double v35;
  uint64_t v36;
  _QWORD *v37;
  double v38;
  double v39;
  void *v40;
  void *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t *MedianValueOfCArray;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v15 = CMBaseObjectGetDerivedStorage(*(_QWORD *)DerivedStorage);
  v16 = a3[11];
  v58 = a3[10];
  v59 = v16;
  v17 = a3[13];
  v60 = a3[12];
  v61 = v17;
  v18 = a3[7];
  v54 = a3[6];
  v55 = v18;
  v19 = a3[9];
  v56 = a3[8];
  v57 = v19;
  v20 = a3[3];
  v50 = a3[2];
  v51 = v20;
  v21 = a3[5];
  v52 = a3[4];
  v53 = v21;
  v22 = a3[1];
  v48 = *a3;
  v49 = v22;
  StartTimestamp = fnhp_getStartTimestamp(a1, a2, (uint64_t)&v48, a4);
  v48 = 0uLL;
  *(_QWORD *)&v49 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  v25 = malloc_type_calloc(*(_QWORD *)(v15 + 96), 8uLL, 0x100004000313F17uLL);
  if (v25)
  {
    if (FigNetworkHistoryGetFirstLatencySampleAfterTime(*(_QWORD *)DerivedStorage, StartTimestamp, v24, &v48))
    {
      v26 = *(_QWORD *)DerivedStorage;
      v27 = CMBaseObjectGetDerivedStorage(*(_QWORD *)DerivedStorage);
      FigSimpleMutexLock(*(pthread_mutex_t **)v27);
      if (*(uint64_t *)(CMBaseObjectGetDerivedStorage(v26) + 120) < 1)
        v28 = 0;
      else
        v28 = *(_QWORD *)(v27 + 104);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)v27);
      v29 = v49;
      v30 = CMBaseObjectGetDerivedStorage(a1);
      if (v29 != *(_QWORD *)(v30 + 32) || *(_QWORD *)(v30 + 24) != v28)
      {
        v32 = 0;
        v33 = 0;
        *(_QWORD *)(DerivedStorage + 32) = v29;
        v34 = 0.0;
        v35 = 0.0;
        do
        {
          v36 = v48;
          v37 = (_QWORD *)v49;
          v25[v32++] = v48;
          v33 += v36;
          v38 = (double)v32;
          v39 = (double)v36 - v35;
          v35 = v35 + 1.0 / (double)v32 * v39;
          v34 = v34 + v39 * ((double)v36 - v35);
        }
        while (FigNetworkHistoryGetNextValidLatencySample(*(_QWORD *)DerivedStorage, v37, v31, &v48));
        *(_QWORD *)(DerivedStorage + 24) = v28;
        v40 = malloc_type_calloc(v32, 8uLL, 0x10040436913F5uLL);
        v41 = v40;
        if (v40)
        {
          v42 = 0;
          v43 = v25;
          do
            *((_QWORD *)v40 + v42++) = v43++;
          while (v32 != v42);
          MedianValueOfCArray = (uint64_t *)FigGetMedianValueOfCArray((uint64_t)v40, v32, (uint64_t (*)(_QWORD, uint64_t, _QWORD))fnhp_compareInt64, (uint64_t (*)(const void *, uint64_t))fnhp_averageInt64, 8uLL);
          v45 = MedianValueOfCArray;
          if (MedianValueOfCArray)
            v46 = *MedianValueOfCArray;
          else
            v46 = 0;
        }
        else
        {
          v46 = 0;
          v45 = 0;
        }
        free(v41);
        free(v45);
        *(_QWORD *)(DerivedStorage + 40) = v46;
        if (v34 <= 2.22044605e-16)
          v47 = 0;
        else
          v47 = (uint64_t)sqrt(v34 / v38);
        *(_QWORD *)(DerivedStorage + 48) = v47;
        *(_QWORD *)(DerivedStorage + 56) = v33;
      }
      if (a5)
        *a5 = *(_QWORD *)(DerivedStorage + 40);
      if (a6)
        *a6 = (double)*(uint64_t *)(DerivedStorage + 48);
      if (a7)
        *a7 = *(_QWORD *)(DerivedStorage + 56);
    }
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  free(v25);
}

CFIndex fnhp_makeSafeBandwidthMultiplier(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  CFIndex result;
  CFArrayRef theArray[2];
  CFArrayRef v8[2];
  CFArrayRef v9[2];
  CFArrayRef v10[2];
  CFArrayRef v11[2];
  _OWORD __s2[5];

  v4 = *(_OWORD *)(a1 + 128);
  *(_OWORD *)v9 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)v10 = v4;
  *(_OWORD *)v11 = *(_OWORD *)(a1 + 144);
  memset(__s2, 0, sizeof(__s2));
  v5 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)theArray = *(_OWORD *)(a1 + 80);
  *(_OWORD *)v8 = v5;
  result = memcmp(theArray, __s2, 0x50uLL);
  if ((_DWORD)result)
  {
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(theArray[0], (double)*(uint64_t *)(a1 + 72));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(theArray[1], (double)*(uint64_t *)a2);
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v8[0], *(double *)(a2 + 8) / (double)*(uint64_t *)a2);
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v8[1], *(double *)(a2 + 8) / sqrt((double)*(uint64_t *)(a2 + 48)));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v9[1], (double)*(uint64_t *)(a2 + 32));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v10[0], *(double *)(a2 + 40) / (double)*(uint64_t *)(a2 + 32));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v10[1], *(double *)(a2 + 40) / sqrt((double)*(uint64_t *)(a2 + 48)));
    fnhp_makeSafeBandwidthMultiplierForSingleVariable(v11[0], (double)*(uint64_t *)(a2 + 48));
    return fnhp_makeSafeBandwidthMultiplierForSingleVariable(v9[0], *(double *)(a2 + 16) / (double)*(uint64_t *)a2);
  }
  return result;
}

uint64_t fnhp_getStartTimestamp(uint64_t a1, uint64_t LastActiveTimestamp, uint64_t a3, uint64_t a4)
{
  uint64_t *DerivedStorage;

  if (*(_BYTE *)(a3 + 160))
  {
    DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
    LastActiveTimestamp = FigNetworkHistoryGetLastActiveTimestamp(*DerivedStorage, LastActiveTimestamp);
  }
  return (LastActiveTimestamp - fnhp_getWindowSize(a1, *(_QWORD *)(a3 + 16))) / a4 * a4;
}

uint64_t fnhp_getWindowSize(uint64_t a1, uint64_t a2)
{
  uint64_t *DerivedStorage;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  if (a2 <= 0)
    return *(_QWORD *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 16);
  return a2;
}

unint64_t fnhp_compareInt64(_QWORD *a1, _QWORD *a2)
{
  return (*a1 > *a2) - (unint64_t)(*a1 < *a2);
}

_QWORD *fnhp_averageInt64(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;

  v2 = *a1;
  v3 = *a2;
  result = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (result)
  {
    if (v3 >= 0)
      v5 = v3;
    else
      v5 = v3 + 1;
    if (v2 >= 0)
      v6 = v2;
    else
      v6 = v2 + 1;
    *result = v3 + v2 - (v6 >> 1) - (v5 >> 1);
  }
  return result;
}

uint64_t fnhp_constantLatencyTimeWeightedAlgorithmForBandwidth(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, double (*a5)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a6, uint64_t *a7, double *a8, double *a9, uint64_t *a10)
{
  uint64_t *DerivedStorage;
  unint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t result;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  v19 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 24);
  v50 = 0;
  v20 = a4[11];
  v46 = a4[10];
  v47 = v20;
  v21 = a4[13];
  v48 = a4[12];
  v49 = v21;
  v22 = a4[7];
  v42 = a4[6];
  v43 = v22;
  v23 = a4[9];
  v44 = a4[8];
  v45 = v23;
  v24 = a4[3];
  v38 = a4[2];
  v39 = v24;
  v25 = a4[5];
  v40 = a4[4];
  v41 = v25;
  v26 = a4[1];
  v36 = *a4;
  v37 = v26;
  result = fnhp_constantLatencyTimeWeightedAlgorithmForBandwidthHelper(a1, a2, a3, (uint64_t)&v36, a5, a6, 0, v19, 0.0, &v50, 0, 0, a10);
  if (!(_DWORD)result)
  {
    if (v19 <= 0x3B9ACA00)
      v28 = 1000000000;
    else
      v28 = v19;
    v29 = a4[11];
    v46 = a4[10];
    v47 = v29;
    v30 = a4[13];
    v48 = a4[12];
    v49 = v30;
    v31 = a4[7];
    v42 = a4[6];
    v43 = v31;
    v32 = a4[9];
    v44 = a4[8];
    v45 = v32;
    v33 = a4[3];
    v38 = a4[2];
    v39 = v33;
    v34 = a4[5];
    v40 = a4[4];
    v41 = v34;
    v35 = a4[1];
    v36 = *a4;
    v37 = v35;
    result = fnhp_constantLatencyTimeWeightedAlgorithmForBandwidthHelper(a1, a2, a3, (uint64_t)&v36, a5, a6, fnhp_bwSampleVariainceLimitingAtMean, v28, (double)v50, 0, a8, a9, 0);
    if (!(_DWORD)result)
      *a7 = v50;
  }
  return result;
}

double fnhp_constantWeightForBandwidthSample()
{
  return 1.0;
}

uint64_t fnhp_constantLatencyTimeWeightedAlgorithmForBandwidthHelper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double (*a5)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a6, double (*a7)(double, double), uint64_t a8, double a9, _QWORD *a10, double *a11, double *a12, uint64_t *a13)
{
  uint64_t DerivedStorage;
  uint64_t StartTimestamp;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  int64x2_t v28;
  uint64_t WindowSize;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  int64x2_t v42;
  uint64_t v43;
  CFNumberRef BandwidthPredictionCacheKey;
  CFNumberRef v45;
  const void *Value;
  uint64_t v47;
  uint64_t *v48;
  const void *v49;
  pthread_mutex_t **v50;
  uint64_t *FirstBytesReceivedEntryAfterTime;
  int v52;
  uint64_t v53;
  int64x2_t v54;
  BOOL v55;
  double v56;
  double v57;
  double v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  int64x2_t v67;
  uint64_t v68;
  CFNumberRef v69;
  CFNumberRef v70;
  uint64_t v71;
  uint64_t LastActiveTimestamp;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  double v79;
  int64x2_t v80;
  int64x2_t v81;
  uint64_t v82;
  double v83;
  double v84;
  int NextBandwidthSample;
  int v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  int64x2_t v95;
  uint64_t v96;
  CFNumberRef v97;
  double *v98;
  uint64_t v99;
  double v100;
  double v101;
  double v102;
  int v103;
  double v104;
  uint64_t v105;
  uint64_t v106;
  _BOOL4 v108;
  _BOOL4 v109;
  char v110;
  double v111;
  double v112;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  double v117;
  uint64_t v118;
  double v119;
  double v120;
  uint64_t v121;
  uint64_t v122;
  double v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  int64x2_t v127;
  double v128;
  double v129;
  double v130;
  double v131;
  double v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  double v145;
  int v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  int64x2_t v160;
  int64x2_t v161;
  int64x2_t v162;
  int64x2_t v163[3];
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  StartTimestamp = *(_QWORD *)(a4 + 208);
  if (!StartTimestamp)
  {
    v20 = *(_OWORD *)(a4 + 160);
    v21 = *(_OWORD *)(a4 + 192);
    v22 = *(_OWORD *)(a4 + 208);
    v172 = *(_OWORD *)(a4 + 176);
    v173 = v21;
    v174 = v22;
    v23 = *(_OWORD *)(a4 + 96);
    v24 = *(_OWORD *)(a4 + 128);
    v25 = *(_OWORD *)(a4 + 144);
    v168 = *(_OWORD *)(a4 + 112);
    v169 = v24;
    v170 = v25;
    v171 = v20;
    v26 = *(_OWORD *)(a4 + 48);
    v163[2] = *(int64x2_t *)(a4 + 32);
    v164 = v26;
    v27 = *(_OWORD *)(a4 + 80);
    v165 = *(_OWORD *)(a4 + 64);
    v166 = v27;
    v167 = v23;
    v28 = *(int64x2_t *)(a4 + 16);
    v163[0] = *(int64x2_t *)a4;
    v163[1] = v28;
    StartTimestamp = fnhp_getStartTimestamp(a1, a3, (uint64_t)v163, a8);
  }
  WindowSize = fnhp_getWindowSize(a1, *(_QWORD *)(a4 + 16));
  v30 = a3 - StartTimestamp;
  if (WindowSize > a3 - StartTimestamp)
    v30 = fnhp_getWindowSize(a1, *(_QWORD *)(a4 + 16));
  v115 = StartTimestamp;
  if (*(_QWORD *)(a4 + 216))
    v31 = *(_QWORD *)(a4 + 216);
  else
    v31 = v30;
  v161 = 0u;
  v162 = 0u;
  v160 = 0u;
  if (a2 >= 0)
    v32 = a2;
  else
    v32 = a2 + 1;
  v33 = *(_QWORD *)(a4 + 32);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (!*(_QWORD *)(a4 + 16))
    *(_QWORD *)(a4 + 16) = *(_QWORD *)(CMBaseObjectGetDerivedStorage(*(_QWORD *)DerivedStorage) + 16);
  v34 = *(_OWORD *)(a4 + 160);
  v35 = *(_OWORD *)(a4 + 192);
  v36 = *(_OWORD *)(a4 + 208);
  v172 = *(_OWORD *)(a4 + 176);
  v173 = v35;
  v174 = v36;
  v37 = *(_OWORD *)(a4 + 96);
  v38 = *(_OWORD *)(a4 + 128);
  v39 = *(_OWORD *)(a4 + 144);
  v168 = *(_OWORD *)(a4 + 112);
  v169 = v38;
  v170 = v39;
  v171 = v34;
  v40 = *(_OWORD *)(a4 + 48);
  v163[2] = *(int64x2_t *)(a4 + 32);
  v164 = v40;
  v41 = *(_OWORD *)(a4 + 80);
  v165 = *(_OWORD *)(a4 + 64);
  v166 = v41;
  v167 = v37;
  v42 = *(int64x2_t *)(a4 + 16);
  v163[0] = *(int64x2_t *)a4;
  v163[1] = v42;
  v43 = CMBaseObjectGetDerivedStorage(a1);
  BandwidthPredictionCacheKey = fnhp_createBandwidthPredictionCacheKey(v163[0].i64, a8);
  v128 = 0.0;
  v152 = DerivedStorage;
  if (!BandwidthPredictionCacheKey
    || (v45 = BandwidthPredictionCacheKey,
        Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v43 + 16), BandwidthPredictionCacheKey),
        CFRelease(v45),
        !Value))
  {
    v121 = 0;
    v122 = 0;
    v118 = 0;
    v127 = 0uLL;
    v125 = 0;
    v126 = 0;
    v124 = 0;
    v116 = 0;
    v119 = 0.0;
    v120 = 0.0;
    v123 = 0.0;
    v117 = 0.0;
    goto LABEL_29;
  }
  v128 = *(double *)Value;
  v47 = *((_QWORD *)Value + 3);
  v121 = *((_QWORD *)Value + 4);
  v122 = *((_QWORD *)Value + 2);
  v119 = *((double *)Value + 5);
  v120 = *((double *)Value + 1);
  v123 = *((double *)Value + 6);
  v117 = *((double *)Value + 7);
  v127 = *((int64x2_t *)Value + 4);
  v125 = *((_QWORD *)Value + 11);
  v126 = *((_QWORD *)Value + 10);
  v124 = *((_QWORD *)Value + 12);
  v116 = *((_QWORD *)Value + 13);
  v48 = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  memset(v163, 0, sizeof(v163));
  v118 = v47;
  if (v47 != v115)
  {
LABEL_29:
    v59 = *(_OWORD *)(a4 + 160);
    v60 = *(_OWORD *)(a4 + 192);
    v61 = *(_OWORD *)(a4 + 208);
    v172 = *(_OWORD *)(a4 + 176);
    v173 = v60;
    v174 = v61;
    v62 = *(_OWORD *)(a4 + 96);
    v63 = *(_OWORD *)(a4 + 128);
    v64 = *(_OWORD *)(a4 + 144);
    v168 = *(_OWORD *)(a4 + 112);
    v169 = v63;
    v170 = v64;
    v171 = v59;
    v65 = *(_OWORD *)(a4 + 48);
    v163[2] = *(int64x2_t *)(a4 + 32);
    v164 = v65;
    v66 = *(_OWORD *)(a4 + 80);
    v165 = *(_OWORD *)(a4 + 64);
    v166 = v66;
    v167 = v62;
    v67 = *(int64x2_t *)(a4 + 16);
    v163[0] = *(int64x2_t *)a4;
    v163[1] = v67;
    v68 = CMBaseObjectGetDerivedStorage(a1);
    v69 = fnhp_createBandwidthPredictionCacheKey(v163[0].i64, a8);
    if (v69)
    {
      v70 = v69;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v68 + 16), v69);
      CFRelease(v70);
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    v155 = 0;
    v156 = 0;
    v57 = 0.0;
    v147 = 1;
    v58 = 0.0;
    v56 = 0.0;
    v71 = v115;
LABEL_32:
    if (!FigNetworkHistoryGetFirstBandwidthSampleAfterTime(*(const void **)DerivedStorage, v71, a8, a3, (uint64_t)&v160))
    {
      v99 = 4294949559;
      goto LABEL_94;
    }
    goto LABEL_33;
  }
  v49 = (const void *)*v48;
  v50 = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(*v48);
  FigSimpleMutexLock(*v50);
  FirstBytesReceivedEntryAfterTime = (uint64_t *)fnh_getFirstBytesReceivedEntryAfterTime(v49, v127.i64[1] - a8 + 1, a3, 1);
  if (!FirstBytesReceivedEntryAfterTime)
  {
    FigSimpleMutexUnlock(*v50);
    goto LABEL_29;
  }
  v52 = fnh_populateBandwidthSampleFromBytesReceivedEntry((uint64_t)v49, FirstBytesReceivedEntryAfterTime, a8, (uint64_t)v163);
  FigSimpleMutexUnlock(*v50);
  if (!v52)
    goto LABEL_29;
  v54.i64[0] = v125;
  v54.i64[1] = v124;
  v55 = (~vaddv_s16((int16x4_t)vand_s8((int8x8_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64(v127, v163[0]), (int32x4_t)vceqq_s64(v54, *(int64x2_t *)((char *)&v163[1] + 8)))), 0xFuLL)), (int8x8_t)0x8000400020001)) & 0xF) == 0&& v126 == v163[1].i64[0];
  if (!v55 || a7 && v117 < vabdd_f64(v123, a9))
    goto LABEL_29;
  v147 = 0;
  if (!FigNetworkHistoryGetNextBandwidthSample(*(_QWORD *)DerivedStorage, (uint64_t *)v163[2].i64[1], a8, v53, (uint64_t)&v160))
  {
    v71 = v127.i64[1] + 1;
    v118 = v115;
    a9 = v123;
    v155 = v121;
    v156 = v122;
    v57 = v119;
    v56 = v120;
    v58 = v128;
    goto LABEL_32;
  }
  v118 = v115;
  a9 = v123;
  v155 = v121;
  v156 = v122;
  v57 = v119;
  v56 = v120;
  v58 = v128;
LABEL_33:
  v153 = a8;
  v154 = a4;
  v114 = 8 * v33;
  LastActiveTimestamp = FigNetworkHistoryGetLastActiveTimestamp(*(_QWORD *)DerivedStorage, a3);
  v159 = 0;
  v73 = 0;
  v74 = 0;
  v75 = 0;
  v140 = 0;
  v141 = 0;
  v138 = 0;
  v139 = 0;
  v142 = 0;
  v146 = 0;
  v133 = 0;
  v134 = 0;
  v135 = 0;
  v136 = 0;
  v76 = 0;
  v77 = 0;
  v78 = 0;
  v137 = 0;
  v145 = 0.0;
  v129 = 0.0;
  v130 = 0.0;
  v131 = 0.0;
  v132 = 0.0;
  v148 = LastActiveTimestamp - v31;
  v149 = LastActiveTimestamp;
  v79 = 0.0;
  do
  {
    v80 = v161;
    v81 = v162;
    v157 = v160.i64[1];
    v158 = v160.i64[0];
    v163[0] = v160;
    v163[1] = v161;
    v163[2] = v162;
    v83 = a5(v163, v148, v149, v154, a6);
    if (v83 < 0.0)
    {
      v99 = FigSignalErrorAt(4294949561, 0, 0, 0, 0, 0, 0);
      goto LABEL_94;
    }
    v84 = v83;
    NextBandwidthSample = FigNetworkHistoryGetNextBandwidthSample(*(_QWORD *)v152, (uint64_t *)v81.i64[1], v153, v82, (uint64_t)&v160);
    if (v147)
    {
      if (NextBandwidthSample && v159)
      {
        if (v142)
        {
          v146 = 1;
          v128 = v132;
          v118 = v134;
          v121 = v133;
          v122 = v135;
          v119 = v130;
          v120 = v131;
          v123 = v129;
          v117 = v145;
          v127.i64[0] = v141;
          v127.i64[1] = v140;
          v125 = v138;
          v126 = v139;
          v124 = v137;
          v116 = v136;
        }
        v145 = 0.0;
        if (v56 <= 2.22044605e-16 || v57 <= 2.22044605e-16)
        {
          v142 = 1;
          v140 = v74;
          v141 = v75;
          v138 = v78;
          v139 = v73;
          v136 = v76;
          v137 = v77;
          v131 = v56;
          v132 = v58;
          v135 = v156;
        }
        else
        {
          v142 = 1;
          v140 = v74;
          v141 = v75;
          v138 = v78;
          v139 = v73;
          v136 = v76;
          v137 = v77;
          v131 = v56;
          v132 = v58;
          v135 = v156;
          v145 = sqrt(v57 / v56);
        }
        v133 = v155;
        v134 = v115;
        v129 = a9;
        v130 = v57;
      }
      else if (v146)
      {
        v86 = NextBandwidthSample;
        v87 = *(_OWORD *)(v154 + 160);
        v88 = *(_OWORD *)(v154 + 192);
        v89 = *(_OWORD *)(v154 + 208);
        v172 = *(_OWORD *)(v154 + 176);
        v173 = v88;
        v174 = v89;
        v90 = *(_OWORD *)(v154 + 96);
        v91 = *(_OWORD *)(v154 + 128);
        v92 = *(_OWORD *)(v154 + 144);
        v168 = *(_OWORD *)(v154 + 112);
        v169 = v91;
        v170 = v92;
        v171 = v87;
        v93 = *(_OWORD *)(v154 + 48);
        v163[2] = *(int64x2_t *)(v154 + 32);
        v164 = v93;
        v94 = *(_OWORD *)(v154 + 80);
        v165 = *(_OWORD *)(v154 + 64);
        v166 = v94;
        v167 = v90;
        v95 = *(int64x2_t *)(v154 + 16);
        v163[0] = *(int64x2_t *)v154;
        v163[1] = v95;
        v96 = CMBaseObjectGetDerivedStorage(a1);
        v97 = fnhp_createBandwidthPredictionCacheKey(v163[0].i64, v153);
        v98 = (double *)malloc_type_calloc(1uLL, 0x70uLL, 0x1000040AC4F46D1uLL);
        if (v97)
        {
          if (v98)
          {
            *v98 = v128;
            v98[1] = v120;
            *((_QWORD *)v98 + 2) = v122;
            *((_QWORD *)v98 + 3) = v118;
            *((_QWORD *)v98 + 4) = v121;
            v98[5] = v119;
            v98[6] = v123;
            v98[7] = v117;
            *((int64x2_t *)v98 + 4) = v127;
            *((_QWORD *)v98 + 10) = v126;
            *((_QWORD *)v98 + 11) = v125;
            *((_QWORD *)v98 + 12) = v124;
            *((_QWORD *)v98 + 13) = v116;
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v96 + 16), v97, v98);
            v99 = 0;
          }
          else
          {
            v99 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          }
          CFRelease(v97);
          if ((_DWORD)v99)
            goto LABEL_94;
        }
        else
        {
          v99 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          if ((_DWORD)v99)
            goto LABEL_94;
        }
        NextBandwidthSample = v86;
        v146 = 1;
      }
      else
      {
        v146 = 0;
      }
    }
    if (v81.i64[0] >= 1)
    {
      v100 = v84 * (double)v81.i64[0];
      v56 = v56 + v100;
      v101 = (double)(8 * v80.i64[1]) / ((double)v81.i64[0] / 1000000000.0);
      if (v56 <= 2.22044605e-16)
        v102 = 0.0;
      else
        v102 = v58 + v100 / v56 * (v101 - v58);
      if (a7)
      {
        v103 = NextBandwidthSample;
        v104 = a7((double)(8 * v80.i64[1]) / ((double)v81.i64[0] / 1000000000.0), a9);
        NextBandwidthSample = v103;
        v79 = v79 + v100 * (v104 - v58) * (v104 - v102);
      }
      v57 = v57 + (v101 - v58) * v100 * (v101 - v102);
      v155 += v80.i64[1];
      v156 += v81.i64[0];
      v58 = v102;
    }
    v75 = v158;
    --v159;
    v73 = v80.i64[0];
    v74 = v157;
    v76 = v81.i64[1];
    v77 = v81.i64[0];
    v78 = v80.i64[1];
  }
  while (NextBandwidthSample);
  v106 = *(_QWORD *)(v154 + 56);
  v105 = *(_QWORD *)(v154 + 64);
  v108 = v106 > 0 && v106 <= v155;
  if (v106)
    v109 = v108;
  else
    v109 = v105 == 0;
  if (v105 < 1)
  {
    if (v109)
      goto LABEL_78;
LABEL_96:
    v99 = 4294949558;
    goto LABEL_94;
  }
  v110 = v105 <= v156 || v109;
  if ((v110 & 1) == 0)
    goto LABEL_96;
LABEL_78:
  if (*(_QWORD *)(v154 + 32))
    v58 = (double)v114 / ((double)(v32 >> 1) / 1000000000.0 + (double)v114 / v58);
  v111 = 0.0;
  v112 = 0.0;
  if (v56 > 2.22044605e-16)
  {
    v112 = 0.0;
    if (v57 > 2.22044605e-16)
      v112 = sqrt(v57 / v56);
  }
  if (v56 > 2.22044605e-16 && v79 > 2.22044605e-16)
    v111 = sqrt(v79 / v56);
  if (a10)
    *a10 = llround(v58);
  if (a11)
    *a11 = v112;
  if (a12)
    *a12 = v111;
  v99 = 0;
  if (a13)
    *a13 = v156;
LABEL_94:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v152 + 8));
  return v99;
}

double fnhp_bwSampleVariainceLimitingAtMean(double result, double a2)
{
  if (result >= a2)
    return a2;
  return result;
}

CFNumberRef fnhp_createBandwidthPredictionCacheKey(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  _QWORD valuePtr[3];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  v2 = *a1;
  v3 = a1[2];
  v4 = *(_OWORD *)(a1 + 5);
  valuePtr[1] = 0;
  v7 = 0u;
  v19 = 0;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  valuePtr[0] = v2;
  valuePtr[2] = v3;
  if (v2 == 4)
    v8 = v4;
  v20 = a2;
  valuePtr[0] = CFHashBytes();
  return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongLongType, valuePtr);
}

CFIndex fnhp_makeSafeBandwidthMultiplierForSingleVariable(CFArrayRef theArray, long double a2)
{
  CFIndex v4;
  double v5;
  CFIndex result;
  double v7;
  double v8;

  v4 = 0;
  v5 = 0.0;
  if (!theArray)
    goto LABEL_3;
LABEL_2:
  for (result = CFArrayGetCount(theArray); v4 < result; result = 0)
  {
    v8 = 0.0;
    if (FigCFArrayGetDoubleAtIndex(theArray, v4, &v8))
    {
      v7 = v8;
      v5 = v5 + v7 * pow(a2, (double)v4);
    }
    ++v4;
    if (theArray)
      goto LABEL_2;
LABEL_3:
    ;
  }
  return result;
}

uint64_t fnhp_timeWeightedConstantLatencyPredictionAlgorithm(uint64_t a1, double (*a2)(int64x2_t *, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6)
{
  uint64_t *DerivedStorage;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  v44 = 0;
  v13 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(*DerivedStorage) + 24);
  v14 = a5[11];
  v40 = a5[10];
  v41 = v14;
  v15 = a5[13];
  v42 = a5[12];
  v43 = v15;
  v16 = a5[7];
  v36 = a5[6];
  v37 = v16;
  v17 = a5[9];
  v38 = a5[8];
  v39 = v17;
  v18 = a5[3];
  v32 = a5[2];
  v33 = v18;
  v19 = a5[5];
  v34 = a5[4];
  v35 = v19;
  v20 = a5[1];
  v30 = *a5;
  v31 = v20;
  fnhp_medianAlgorithmForLatency(a1, a4, &v30, v13, &v44, (double *)(a6 + 40), 0);
  v21 = v44;
  *(_QWORD *)(a6 + 32) = v44;
  v22 = a5[11];
  v40 = a5[10];
  v41 = v22;
  v23 = a5[13];
  v42 = a5[12];
  v43 = v23;
  v24 = a5[7];
  v36 = a5[6];
  v37 = v24;
  v25 = a5[9];
  v38 = a5[8];
  v39 = v25;
  v26 = a5[3];
  v32 = a5[2];
  v33 = v26;
  v27 = a5[5];
  v34 = a5[4];
  v35 = v27;
  v28 = a5[1];
  v30 = *a5;
  v31 = v28;
  return fnhp_constantLatencyTimeWeightedAlgorithmForBandwidth(a1, v21, a4, &v30, a2, a3, (uint64_t *)a6, (double *)(a6 + 8), (double *)(a6 + 16), (uint64_t *)(a6 + 48));
}

double fnhp_linearTimeWeightForBandwidthSample(uint64_t a1, uint64_t a2)
{
  return fmax((double)(*(_QWORD *)(a1 + 8) - a2) / 1000000000.0, 0.0);
}

double fnhp_quadraticTimeWeightForBandwidthSample(uint64_t a1, uint64_t a2)
{
  double v2;

  v2 = (double)(*(_QWORD *)(a1 + 8) - a2) / 1000000000.0;
  return fmax(v2 * v2, 0.0);
}

double fnhp_quadraticTimeWeightWithHighPassUtilizationFilterForBandwidthSample(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double v5;
  double v6;
  double v7;
  double v8;

  v5 = (double)(*(_QWORD *)(a1 + 8) - a2) / 1000000000.0;
  v6 = fmax(v5 * v5, 0.0);
  v7 = *(double *)(a4 + 40);
  if (v7 > 0.0)
  {
    v8 = *(double *)a5 + -0.01;
    v6 = v6
       * (v8
        / (exp(-(*(double *)(a4 + 48) * ((double)*(uint64_t *)(a1 + 32) / (double)*(uint64_t *)(a5 + 8) - v7))) + 1.0)
        + 0.01);
  }
  return fmax(v6, 0.0);
}

double fnhp_logisticTimeWeightForBandwidthSample(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return fmax(10000000.0 / (exp(((double)(*(_QWORD *)(a1 + 8) - a2) / (double)(a3 - a2) + -0.916666667) * -25.0) + 1.0), 0.0);
}

uint64_t FigTransportConnectionXPCSetCurrentConnection(uint64_t a1)
{
  uint64_t result;
  void (*v3)(uint64_t, _QWORD, _QWORD *);
  _QWORD v4[5];

  if (ntcxpc_getReceiver_once != -1)
    dispatch_once(&ntcxpc_getReceiver_once, &__block_literal_global_13);
  result = _os_feature_enabled_impl();
  if ((_DWORD)result)
  {
    FigSimpleMutexLock((pthread_mutex_t *)qword_1EE1410A8);
    if (ntcxpc_getReceiver_receiver)
      CFRelease((CFTypeRef)ntcxpc_getReceiver_receiver);
    ntcxpc_getReceiver_receiver = (uint64_t)FigCFWeakReferenceHolderCreateWithReferencedObject(a1);
    if (qword_1EE1410A0)
      _Block_release((const void *)qword_1EE1410A0);
    qword_1EE1410A0 = (uint64_t)FigTransportConnectionUSBCopyEventHandler(a1);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __FigTransportConnectionXPCSetCurrentConnection_block_invoke;
    v4[3] = &__block_descriptor_tmp_13;
    v4[4] = &ntcxpc_getReceiver_receiver;
    v3 = *(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 8);
    if (v3)
      v3(a1, 0, v4);
    return FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE1410A8);
  }
  return result;
}

uint64_t FigTransportXPCConnectionServerStart()
{
  uint64_t v0;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v2;
  uint64_t v3;
  unsigned int v4;
  _BYTE *v5;
  uint64_t v6;
  NSObject *v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  _BYTE *v12;
  char v13;
  os_log_type_t type;
  int v15;
  _OWORD v16[3];
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v16[0] = xmmword_1E28DAF38;
  v16[1] = *(_OWORD *)algn_1E28DAF48;
  v16[2] = xmmword_1E28DAF58;
  if (!_os_feature_enabled_impl())
    return 0;
  v0 = FigXPCServerStart((uint64_t)"com.apple.coremedia.nerotransportconnectionxpc", (uint64_t)v16, 0, &FigTransportXPCConnectionServerStart_sNTCServer);
  if (!(_DWORD)v0)
  {
    v15 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v15, &type);
    v2 = v15;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v4 = v2;
    else
      v4 = v2 & 0xFFFFFFFE;
    if (v4)
    {
      v17 = 136315138;
      v18 = "FigTransportXPCConnectionServerStart";
      v5 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v2) = v15;
    }
    else
    {
      v5 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v5, v5 != v21, v2, 0, v3);
    return 0;
  }
  v6 = v0;
  v15 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  v8 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v15, &type);
  v9 = v15;
  if (os_log_type_enabled(v8, type))
    v11 = v9;
  else
    v11 = v9 & 0xFFFFFFFE;
  if (v11)
  {
    v17 = 136315394;
    v18 = "FigTransportXPCConnectionServerStart";
    v19 = 1024;
    v20 = v6;
    v12 = (_BYTE *)_os_log_send_and_compose_impl();
    v13 = v15;
  }
  else
  {
    v13 = v9;
    v12 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v12, v12 != v21, v13, 0, v10);
  return v6;
}

uint64_t ntcxpc_handleClientMessage(void *a1, void *a2)
{
  uint64_t OpCode;
  void *v5;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v7;
  uint64_t v8;
  unsigned int v9;
  CMBlockBufferRef *v10;
  _DWORD *data;
  _DWORD *v12;
  uint64_t BlockBufferData;
  uint64_t v14;
  uint64_t v15;
  int64_t v16;
  id *v17;
  CMBlockBufferRef v18;
  uint64_t (*v19)(id *, _DWORD *, CMBlockBufferRef, int64_t);
  uint64_t v20;
  int64_t int64;
  id *v22;
  uint64_t (*v23)(id *, int64_t);
  id *v24;
  int v26;
  os_log_type_t type;
  int v28;
  _BYTE length[12];
  __int16 v30;
  int v31;
  CMBlockBufferRef theBuffer[17];

  theBuffer[16] = *(CMBlockBufferRef *)MEMORY[0x1E0C80C00];
  v26 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v26);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v26 != 1701736821)
  {
    if (v26 != 1718383464)
    {
      if (v26 == 1768843636)
      {
        if (ntcxpc_getReceiver_once != -1)
          dispatch_once(&ntcxpc_getReceiver_once, &__block_literal_global_13);
        FigSimpleMutexLock((pthread_mutex_t *)qword_1EE1410A8);
        v5 = (void *)qword_1EE141098;
        if (qword_1EE141098)
        {
          qword_1EE141098 = 0;
          xpc_release(v5);
        }
        qword_1EE141098 = (uint64_t)xpc_retain(a1);
        dword_1EE1410B0 = xpc_connection_get_pid((xpc_connection_t)a1);
        v28 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v28, &type);
        v7 = v28;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v9 = v7;
        else
          v9 = v7 & 0xFFFFFFFE;
        if (v9)
        {
          *(_DWORD *)length = 136315394;
          *(_QWORD *)&length[4] = "ntcxpc_handleInit";
          v30 = 1024;
          v31 = dword_1EE1410B0;
          v10 = (CMBlockBufferRef *)_os_log_send_and_compose_impl();
          LOBYTE(v7) = v28;
        }
        else
        {
          v10 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v10, v10 != theBuffer, v7, 0, v8);
        FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE1410A8);
      }
      return 0;
    }
    if (ntcxpc_getReceiver_once != -1)
      dispatch_once(&ntcxpc_getReceiver_once, &__block_literal_global_13);
    int64 = xpc_dictionary_get_int64(a2, "flushPendingPackage");
    FigSimpleMutexLock((pthread_mutex_t *)qword_1EE1410A8);
    if (ntcxpc_getReceiver_receiver)
    {
      v22 = FigCFWeakReferenceHolderCopyReferencedObject((id *)ntcxpc_getReceiver_receiver);
      FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE1410A8);
      if (v22)
      {
        v23 = *(uint64_t (**)(id *, int64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v22) + 16) + 40);
        if (v23)
          v20 = v23(v22, int64);
        else
          v20 = 4294954514;
        v24 = v22;
        goto LABEL_44;
      }
    }
    else
    {
      FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE1410A8);
    }
    return 4294955265;
  }
  if (ntcxpc_getReceiver_once != -1)
    dispatch_once(&ntcxpc_getReceiver_once, &__block_literal_global_13);
  theBuffer[0] = 0;
  *(_QWORD *)length = 0;
  data = xpc_dictionary_get_data(a2, "enqueuePkgHeader", (size_t *)length);
  if (!data)
    goto LABEL_47;
  v12 = data;
  BlockBufferData = FigXPCMessageCreateBlockBufferData((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2, "enqueuePackage", theBuffer);
  if ((_DWORD)BlockBufferData)
  {
    v20 = BlockBufferData;
    v17 = 0;
    goto LABEL_40;
  }
  v14 = *v12;
  v15 = *(_QWORD *)length;
  if (CMBlockBufferGetDataLength(theBuffer[0]) + v15 != v14 || *v12 < 8u)
  {
LABEL_47:
    v17 = 0;
    v20 = 4294954516;
    goto LABEL_40;
  }
  v16 = xpc_dictionary_get_int64(a2, "enqueuePriority");
  FigSimpleMutexLock((pthread_mutex_t *)qword_1EE1410A8);
  if (!ntcxpc_getReceiver_receiver)
  {
    FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE1410A8);
    v17 = 0;
    goto LABEL_36;
  }
  v17 = FigCFWeakReferenceHolderCopyReferencedObject((id *)ntcxpc_getReceiver_receiver);
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE1410A8);
  if (!v17)
  {
LABEL_36:
    v20 = 4294955265;
    goto LABEL_40;
  }
  v18 = theBuffer[0];
  v19 = *(uint64_t (**)(id *, _DWORD *, CMBlockBufferRef, int64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v17)
                                                                                        + 16)
                                                                            + 32);
  if (v19)
    v20 = v19(v17, v12, v18, v16);
  else
    v20 = 4294954514;
LABEL_40:
  if (theBuffer[0])
    CFRelease(theBuffer[0]);
  if (v17)
  {
    v24 = v17;
LABEL_44:
    CFRelease(v24);
  }
  return v20;
}

BOOL ntcxpc_verifyConnection(_xpc_connection_s *a1)
{
  pid_t pid;
  _BOOL8 HasEntitlement;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v11[2];
  const char *v12;
  __int16 v13;
  pid_t v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  pid = xpc_connection_get_pid(a1);
  HasEntitlement = FigXPCConnectionHasEntitlement((uint64_t)a1, (uint64_t)"com.apple.coremedia.nerotransportconnectionxpc.allow");
  if (!HasEntitlement)
  {
    v11[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v11, &type);
    v5 = v11[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v7 = v5;
    else
      v7 = v5 & 0xFFFFFFFE;
    if (v7)
    {
      v11[1] = 136315394;
      v12 = "ntcxpc_verifyConnection";
      v13 = 1024;
      v14 = pid;
      v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v11[0];
    }
    else
    {
      v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v8, v8 != &v15, v5, 0, v6);
  }
  return HasEntitlement;
}

pthread_mutex_t *__ntcxpc_getReceiver_block_invoke()
{
  pthread_mutex_t *result;

  result = FigSimpleMutexCreate();
  qword_1EE1410A8 = (uint64_t)result;
  return result;
}

uint64_t FigScheduledIOGetTypeID()
{
  FigThreadRunOnce(&FigScheduledIOGetClassID_sRegisterFigScheduledIOBaseTypeOnce, (void (*)(void))RegisterFigScheduledIOBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigScheduledIOClassID);
}

uint64_t FigScheduledIOBatchGetClassID()
{
  FigThreadRunOnce(&FigScheduledIOBatchGetClassID_sRegisterFigScheduledIOBatchBaseTypeOnce, (void (*)(void))RegisterFigScheduledIOBatchBaseType);
  return sFigScheduledIOClassID;
}

uint64_t RegisterFigScheduledIOBatchBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigScheduledIOBatchClassDesc, ClassID, 1, &sFigScheduledIOBatchClassID);
}

uint64_t FigScheduledIOBatchGetTypeID()
{
  FigThreadRunOnce(&FigScheduledIOGetClassID_sRegisterFigScheduledIOBaseTypeOnce, (void (*)(void))RegisterFigScheduledIOBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigScheduledIOClassID);
}

CFTypeRef FigScheduledIOBaseCopyFormattingDesc()
{
  return CFRetain(CFSTR("[FigScheduledIORef]"));
}

CFTypeRef FigScheduledIOBatchBaseCopyFormattingDesc()
{
  return CFRetain(CFSTR("[FigScheduledIOBatchRef]"));
}

uint64_t FigReadSchedulerCopyForByteStream(uint64_t a1, uint64_t *a2)
{
  CFTypeRef v3;
  id *Value;
  id *v5;
  uint64_t v6;
  const __CFAllocator *v7;
  uint64_t Instance;
  const char *v9;
  __CFDictionary *Mutable;
  CFStringRef v11;
  OpaqueCMMemoryPool *v12;
  CFAllocatorRef Allocator;
  dispatch_queue_t v14;
  dispatch_queue_t v15;
  dispatch_queue_t v16;
  dispatch_queue_t v17;
  CFMutableArrayRef v18;
  CFMutableArrayRef v19;
  CFMutableArrayRef v20;
  CFMutableArrayRef v21;
  unint64_t v22;
  dispatch_source_t v23;
  void *v24;
  CFTypeRef v25;
  uint64_t v26;
  char __str[16];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  if (rsRegistry_OneTimeInitialization_sRSRegistryInitOnce != -1)
    dispatch_once_f(&rsRegistry_OneTimeInitialization_sRSRegistryInitOnce, 0, (dispatch_function_t)rsRegistry_PerformInitialization);
  v3 = CFRetain((CFTypeRef)*MEMORY[0x1E0C9B0D0]);
  FigSimpleMutexLock((pthread_mutex_t *)gRSRegistry_0);
  Value = (id *)CFDictionaryGetValue((CFDictionaryRef)gRSRegistry_1, v3);
  if (!Value || (v5 = FigCFWeakReferenceHolderCopyReferencedObject(Value)) == 0)
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    *(_OWORD *)__str = 0u;
    v29 = 0u;
    if (FigReadSchedulerGetTypeID_sRegisterFigReadSchedulerTypeOnce != -1)
      dispatch_once_f(&FigReadSchedulerGetTypeID_sRegisterFigReadSchedulerTypeOnce, &FigReadSchedulerGetTypeID_sFigReadSchedulerID, (dispatch_function_t)readScheduler_RegisterType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v6 = Instance;
      *(_QWORD *)(Instance + 16) = 0;
      v9 = (const char *)(Instance + 400);
      snprintf((char *)(Instance + 400), 0x10uLL, "%p", (const void *)Instance);
      Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v11 = CFStringCreateWithFormat(v7, 0, CFSTR("ReadScheduler-%s"), v9);
      CFDictionarySetValue(Mutable, CFSTR("FigMemoryPool_LoggingName"), v11);
      *(_QWORD *)(v6 + 104) = CMMemoryPoolCreate(Mutable);
      if (v11)
        CFRelease(v11);
      if (Mutable)
        CFRelease(Mutable);
      v12 = *(OpaqueCMMemoryPool **)(v6 + 104);
      if (v12)
      {
        Allocator = CMMemoryPoolGetAllocator(v12);
        *(_QWORD *)(v6 + 112) = Allocator;
        if (Allocator)
        {
          CFRetain(Allocator);
          snprintf(__str, 0x100uLL, "com.apple.coremedia.readscheduler.%s.internal", v9);
          v14 = FigDispatchQueueCreateWithPriority(__str, 0, 4u);
          *(_QWORD *)(v6 + 56) = v14;
          if (v14)
          {
            snprintf(__str, 0x100uLL, "com.apple.coremedia.readscheduler.%s.requests", v9);
            v15 = dispatch_queue_create_with_target_V2(__str, 0, *(dispatch_queue_t *)(v6 + 56));
            *(_QWORD *)(v6 + 64) = v15;
            if (v15)
            {
              snprintf(__str, 0x100uLL, "com.apple.coremedia.readscheduler.%s.callbacks", v9);
              v16 = FigDispatchQueueCreateWithPriority(__str, 0, 4u);
              *(_QWORD *)(v6 + 72) = v16;
              if (v16)
              {
                *(_BYTE *)(v6 + 376) = 0;
                snprintf(__str, 0x100uLL, "com.apple.coremedia.readscheduler.%s.reads", v9);
                v17 = FigDispatchQueueCreateWithPriority(__str, 0, 4u);
                *(_QWORD *)(v6 + 120) = v17;
                if (v17)
                {
                  v18 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
                  *(_QWORD *)(v6 + 24) = v18;
                  if (v18)
                  {
                    v19 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
                    *(_QWORD *)(v6 + 32) = v19;
                    if (v19)
                    {
                      v20 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
                      *(_QWORD *)(v6 + 40) = v20;
                      if (v20)
                      {
                        v21 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
                        *(_QWORD *)(v6 + 48) = v21;
                        if (v21)
                        {
                          *(_OWORD *)(v6 + 88) = xmmword_18EDDCCA0;
                          v22 = *MEMORY[0x1E0C85AD8];
                          *(_QWORD *)(v6 + 392) = *MEMORY[0x1E0C85AD8];
                          *(_DWORD *)(v6 + 388) = 0x200000 / v22;
                          v23 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v6 + 64));
                          *(_QWORD *)(v6 + 80) = v23;
                          if (v23)
                          {
                            v24 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v6);
                            dispatch_set_context(*(dispatch_object_t *)(v6 + 80), v24);
                            dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v6 + 80), (dispatch_function_t)readScheduler_DeadlineTimerHandler);
                            dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(v6 + 80), (dispatch_function_t)readScheduler_DeadlineTimerCancelCallback);
                            dispatch_resume(*(dispatch_object_t *)(v6 + 80));
                            v25 = FigCFWeakReferenceHolderCreateWithReferencedObject(v6);
                            CFDictionarySetValue((CFMutableDictionaryRef)gRSRegistry_1, v3, v25);
                            CFRelease(v25);
                            goto LABEL_27;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v26 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
      CFRelease((CFTypeRef)v6);
    }
    else
    {
      v26 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
    }
    v6 = 0;
    goto LABEL_28;
  }
  v6 = (uint64_t)v5;
LABEL_27:
  v26 = 0;
LABEL_28:
  *a2 = v6;
  FigSimpleMutexUnlock((pthread_mutex_t *)gRSRegistry_0);
  if (v3)
    CFRelease(v3);
  return v26;
}

uint64_t rsBatch_RegisterType(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigReadSchedulerCreateBatch(void *a1, _QWORD *a2)
{
  const __CFAllocator *v4;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  v4 = CFGetAllocator(a1);
  v5 = rsBatch_Create(v4, &cf);
  v6 = cf;
  if ((_DWORD)v5)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    FigCFWeakReferenceStore((id *)cf + 2, a1);
    *a2 = v6;
  }
  return v5;
}

uint64_t rsBatch_Create(const __CFAllocator *a1, _QWORD *a2)
{
  uint64_t Instance;
  _QWORD *v5;
  dispatch_group_t v6;
  pthread_mutex_t *v7;
  CFMutableSetRef Mutable;
  uint64_t v10;

  if (FigReadSchedulerBatchGetTypeID_sRegisterRSBatchTypeOnce != -1)
    dispatch_once_f(&FigReadSchedulerBatchGetTypeID_sRegisterRSBatchTypeOnce, &FigReadSchedulerBatchGetTypeID_sRSBatchID, (dispatch_function_t)rsBatch_RegisterType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
  v5 = (_QWORD *)Instance;
  *(_DWORD *)(Instance + 52) = 0;
  *(_BYTE *)(Instance + 48) = 0;
  v6 = dispatch_group_create();
  v5[5] = v6;
  if (v6
    && (v7 = FigSimpleMutexCreate(), (v5[3] = v7) != 0)
    && (Mutable = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]), (v5[4] = Mutable) != 0))
  {
    *a2 = v5;
    return 0;
  }
  else
  {
    v10 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
    CFRelease(v5);
    return v10;
  }
}

uint64_t FigReadSchedulerBatchAddReadWithDeadline(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, _QWORD *a12)
{
  uint64_t v20;
  id v21;
  const void *v22;
  CFAllocatorRef v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v27;
  const void *v28;
  _QWORD *v29;

  v29 = 0;
  if (!a1)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  if (*(_DWORD *)(a1 + 52))
  {
    v20 = 4294949513;
  }
  else
  {
    v20 = 4294949515;
    if (a3 && a5 && a9)
    {
      v28 = a6;
      v21 = FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
      if (v21)
      {
        v22 = v21;
        v23 = CFGetAllocator(v21);
        v24 = rsRequest_Create((uint64_t)v23, (uint64_t)v22, a2, a3, a4, a5, v28, 0, a7, a8, a9, a10, a11, &v29);
        v25 = v29;
        if (!(_DWORD)v24 && (CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v29), a12))
        {
          *a12 = v25[4];
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        }
        else
        {
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
          if (!v25)
            goto LABEL_13;
        }
        CFRelease(v25);
LABEL_13:
        CFRelease(v22);
        return v24;
      }
      v20 = 4294949515;
    }
  }
  v27 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return v27;
}

uint64_t rsRequest_Create(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, const void *a7, char a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _QWORD *a14)
{
  _QWORD *Instance;
  _QWORD *v20;
  CFTypeRef v21;

  if (rsRequest_GetTypeID_sRegisterRSRequestTypeOnce != -1)
    dispatch_once_f(&rsRequest_GetTypeID_sRegisterRSRequestTypeOnce, &rsRequest_GetTypeID_sRSRequestID, (dispatch_function_t)rsRequest_RegisterType);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
  v20 = Instance;
  Instance[2] = a2;
  Instance[3] = a3;
  Instance[4] = FigAtomicIncrement64(&gNextRequestID);
  if (a7)
    v21 = CFRetain(a7);
  else
    v21 = 0;
  v20[5] = v21;
  v20[6] = CFRetain(a4);
  v20[7] = a5;
  v20[8] = a6;
  *((_BYTE *)v20 + 104) = a8;
  v20[11] = a9;
  v20[12] = a10;
  v20[14] = a11;
  v20[15] = a12;
  v20[16] = a13;
  *a14 = v20;
  return 0;
}

uint64_t FigReadSchedulerBatchAddBackgroundRead(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  uint64_t v19;
  id v20;
  const void *v21;
  CFAllocatorRef v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v26;
  const void *v27;
  _QWORD *v28;

  v28 = 0;
  if (!a1)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  if (*(_DWORD *)(a1 + 52))
  {
    v19 = 4294949513;
  }
  else
  {
    v19 = 4294949515;
    if (a3 && a5 && a8)
    {
      v27 = a6;
      v20 = FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
      if (v20)
      {
        v21 = v20;
        v22 = CFGetAllocator(v20);
        v23 = rsRequest_Create((uint64_t)v22, (uint64_t)v21, a2, a3, a4, a5, v27, 1, a7, 0, a8, a9, a10, &v28);
        v24 = v28;
        if (!(_DWORD)v23 && (CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v28), a11))
        {
          *a11 = v24[4];
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        }
        else
        {
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
          if (!v24)
            goto LABEL_13;
        }
        CFRelease(v24);
LABEL_13:
        CFRelease(v21);
        return v23;
      }
      v19 = 4294949515;
    }
  }
  v26 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return v26;
}

uint64_t FigReadSchedulerBatchCommit(uint64_t a1)
{
  dispatch_queue_t *v2;
  dispatch_queue_t *v3;
  CFTypeRef *v4;
  CFTypeRef *v5;
  uint64_t v6;

  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (*(_DWORD *)(a1 + 52))
    {
      v6 = 0;
    }
    else
    {
      v2 = (dispatch_queue_t *)FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
      if (v2)
      {
        v3 = v2;
        v4 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
        if (v4)
        {
          v5 = v4;
          v4[1] = CFRetain((CFTypeRef)a1);
          *v5 = CFRetain(v3);
          *(_DWORD *)(a1 + 52) = 1;
          dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
          dispatch_async_f(v3[8], v5, (dispatch_function_t)readScheduler_HandleBatchCommit);
          v6 = 0;
        }
        else
        {
          v6 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        CFRelease(v3);
        return v6;
      }
      v6 = FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return v6;
  }
  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleBatchCommit(uint64_t a1)
{
  CFIndex Count;
  CFMutableArrayRef *v3;

  Count = CFSetGetCount(*(CFSetRef *)(*(_QWORD *)(a1 + 8) + 32));
  v3 = *(CFMutableArrayRef **)a1;
  if (Count)
  {
    CFArrayAppendValue(v3[6], *(const void **)(a1 + 8));
    CFSetApplyFunction(*(CFSetRef *)(*(_QWORD *)(a1 + 8) + 32), (CFSetApplierFunction)readScheduler_BatchRequestIngestApplierFunction, *(void **)a1);
    readScheduler_IssueReadsAndScheduleWakeup(*(_QWORD *)a1);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v3, *(_QWORD *)(a1 + 8));
  }
  CFRelease(*(CFTypeRef *)a1);
  CFRelease(*(CFTypeRef *)(a1 + 8));
  free((void *)a1);
}

uint64_t FigReadSchedulerBatchCancel(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  CFTypeRef *v4;
  CFTypeRef *v5;
  NSObject *v6;
  void (__cdecl *v7)(void *);
  uint64_t v8;

  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (*(_DWORD *)(a1 + 52) == 2)
    {
      v8 = 0;
    }
    else
    {
      v2 = FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
      if (v2)
      {
        v3 = v2;
        v4 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
        if (v4)
        {
          v5 = v4;
          v4[1] = CFRetain((CFTypeRef)a1);
          *v5 = CFRetain(v3);
          if (*(_DWORD *)(a1 + 52))
          {
            v6 = v3[7];
            v7 = (void (__cdecl *)(void *))readScheduler_HandleCommittedBatchCancellation;
          }
          else
          {
            *(_DWORD *)(a1 + 52) = 1;
            dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
            v6 = v3[7];
            v7 = (void (__cdecl *)(void *))readScheduler_HandleOpenBatchCancellation;
          }
          dispatch_async_f(v6, v5, v7);
          v8 = 0;
        }
        else
        {
          v8 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        CFRelease(v3);
        return v8;
      }
      v8 = FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return v8;
  }
  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleOpenBatchCancellation(CFTypeRef *a1)
{
  CFIndex Count;
  CFMutableArrayRef *v3;
  const __CFAllocator *v4;
  const __CFSet *Copy;
  void *v6;

  Count = CFSetGetCount(*((CFSetRef *)a1[1] + 4));
  v3 = (CFMutableArrayRef *)*a1;
  if (Count)
  {
    CFArrayAppendValue(v3[6], a1[1]);
    v4 = CFGetAllocator(*((CFTypeRef *)a1[1] + 4));
    Copy = CFSetCreateCopy(v4, *((CFSetRef *)a1[1] + 4));
    v6 = (void *)*a1;
    *((_BYTE *)a1[1] + 48) = 1;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)readScheduler_CancelRequestApplierFunction, v6);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v3, (uint64_t)a1[1]);
    Copy = 0;
  }
  CFRelease(*a1);
  CFRelease(a1[1]);
  free(a1);
  if (Copy)
    CFRelease(Copy);
}

void readScheduler_HandleCommittedBatchCancellation(CFTypeRef *a1)
{
  CFArrayRef *v2;
  const __CFSet *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  CFArrayRef *ValueAtIndex;
  CFIndex v8;
  CFIndex v9;
  CFIndex v10;
  const void *v11;
  const __CFAllocator *v12;
  const __CFSet *Copy;
  void *v14;

  if (CFSetGetCount(*((CFSetRef *)a1[1] + 4)))
  {
    readScheduler_RemoveMatchingRequestsFromReadArray(*((const __CFArray **)*a1 + 4), *((const __CFSet **)a1[1] + 4));
    readScheduler_RemoveMatchingRequestsFromReadArray(*((const __CFArray **)*a1 + 5), *((const __CFSet **)a1[1] + 4));
    v2 = (CFArrayRef *)*a1;
    v3 = (const __CFSet *)*((_QWORD *)a1[1] + 4);
    Count = CFArrayGetCount(*((CFArrayRef *)*a1 + 3));
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(v2[3], i);
        v8 = CFArrayGetCount(ValueAtIndex[6]);
        if (v8 >= 1)
        {
          v9 = v8;
          v10 = 0;
          do
          {
            v11 = CFArrayGetValueAtIndex(ValueAtIndex[6], v10);
            if (CFSetContainsValue(v3, v11))
            {
              CFArrayRemoveValueAtIndex(ValueAtIndex[6], v10);
              --v9;
            }
            else
            {
              ++v10;
            }
          }
          while (v10 < v9);
        }
        if (!CFArrayGetCount(ValueAtIndex[6]))
          *((_BYTE *)ValueAtIndex + 114) = 1;
      }
    }
    v12 = CFGetAllocator(*((CFTypeRef *)a1[1] + 4));
    Copy = CFSetCreateCopy(v12, *((CFSetRef *)a1[1] + 4));
    v14 = (void *)*a1;
    *((_BYTE *)a1[1] + 48) = 1;
    CFSetApplyFunction(Copy, (CFSetApplierFunction)readScheduler_CancelRequestApplierFunction, v14);
  }
  else
  {
    Copy = 0;
  }
  CFRelease(*a1);
  CFRelease(a1[1]);
  free(a1);
  if (Copy)
    CFRelease(Copy);
}

uint64_t FigReadSchedulerBatchExpedite(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  CFTypeRef *v4;
  CFTypeRef *v5;
  NSObject *v6;
  void (__cdecl *v7)(void *);
  uint64_t v8;

  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (*(_DWORD *)(a1 + 52) == 2)
    {
      v8 = 0;
    }
    else
    {
      v2 = FigCFWeakReferenceLoadAndRetain((id *)(a1 + 16));
      if (v2)
      {
        v3 = v2;
        v4 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
        if (v4)
        {
          v5 = v4;
          v4[1] = CFRetain((CFTypeRef)a1);
          *v5 = CFRetain(v3);
          if (*(_DWORD *)(a1 + 52))
          {
            v6 = v3[8];
            v7 = (void (__cdecl *)(void *))readScheduler_HandleCommittedBatchExpedite;
          }
          else
          {
            *(_DWORD *)(a1 + 52) = 1;
            dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
            v6 = v3[8];
            v7 = (void (__cdecl *)(void *))readScheduler_HandleOpenBatchExpedite;
          }
          dispatch_async_f(v6, v5, v7);
          v8 = 0;
        }
        else
        {
          v8 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        CFRelease(v3);
        return v8;
      }
      v8 = FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    return v8;
  }
  return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleOpenBatchExpedite(const void **a1)
{
  CFIndex Count;
  const void *v3;
  const __CFAllocator *v4;
  __CFArray *Mutable;
  CFRange v6;

  Count = CFSetGetCount(*((CFSetRef *)a1[1] + 4));
  v3 = *a1;
  if (Count)
  {
    v4 = CFGetAllocator(v3);
    Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
    CFArrayAppendValue(*((CFMutableArrayRef *)*a1 + 6), a1[1]);
    CFSetApplyFunction(*((CFSetRef *)a1[1] + 4), (CFSetApplierFunction)readScheduler_BatchRequestIngestApplierFunction, (void *)*a1);
    readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(*((const __CFArray **)*a1 + 4), *((const __CFSet **)a1[1] + 4), Mutable);
    readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(*((const __CFArray **)*a1 + 5), *((const __CFSet **)a1[1] + 4), Mutable);
    v6.length = CFArrayGetCount(Mutable);
    v6.location = 0;
    CFArrayApplyFunction(Mutable, v6, (CFArrayApplierFunction)readScheduler_ExpediteReadsArrayApplierFunction, (void *)*a1);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v3, (uint64_t)a1[1]);
    Mutable = 0;
  }
  CFRelease(*a1);
  CFRelease(a1[1]);
  free(a1);
  if (Mutable)
    CFRelease(Mutable);
}

void readScheduler_HandleCommittedBatchExpedite(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFArray *Mutable;
  CFRange v4;

  if (CFSetGetCount(*(CFSetRef *)(*(_QWORD *)(a1 + 8) + 32)))
  {
    v2 = CFGetAllocator(*(CFTypeRef *)a1);
    Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(*(const __CFArray **)(*(_QWORD *)a1 + 32), *(const __CFSet **)(*(_QWORD *)(a1 + 8) + 32), Mutable);
      readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(*(const __CFArray **)(*(_QWORD *)a1 + 40), *(const __CFSet **)(*(_QWORD *)(a1 + 8) + 32), Mutable);
      if (CFArrayGetCount(Mutable))
      {
        v4.length = CFArrayGetCount(Mutable);
        v4.location = 0;
        CFArrayApplyFunction(Mutable, v4, (CFArrayApplierFunction)readScheduler_ExpediteReadsArrayApplierFunction, *(void **)a1);
      }
      else
      {
        readScheduler_CompleteBatch(*(_QWORD *)a1, *(_QWORD *)(a1 + 8));
      }
    }
    else
    {
      FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    Mutable = 0;
  }
  CFRelease(*(CFTypeRef *)a1);
  CFRelease(*(CFTypeRef *)(a1 + 8));
  free((void *)a1);
  if (Mutable)
    CFRelease(Mutable);
}

uint64_t FigReadSchedulerBatchAwaitCompletion(uint64_t a1)
{
  int v2;
  uint64_t v4;

  if (a1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    v2 = *(_DWORD *)(a1 + 52);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    if (v2)
    {
      dispatch_group_wait(*(dispatch_group_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL);
      if (!*(_BYTE *)(a1 + 48))
        return 0;
      v4 = 4294949511;
    }
    else
    {
      v4 = 4294949512;
    }
  }
  else
  {
    v4 = 4294949515;
  }
  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t readScheduler_RegisterType(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigReadSchedulerGetNewClientID(uint64_t a1, unint64_t *a2)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  *a2 = FigAtomicIncrement64(&FigReadSchedulerGetNewClientID_sNextClientID);
  return 0;
}

uint64_t FigReadSchedulerRequestReadWithDeadline(dispatch_queue_t *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, _QWORD *a12)
{
  CFAllocatorRef v19;
  uint64_t v20;
  void *v21;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a3 || !a5 || !a9)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  v19 = CFGetAllocator(a1);
  v20 = rsRequest_Create((uint64_t)v19, (uint64_t)a1, a2, a3, a4, a5, a6, 0, a7, a8, a9, a10, a11, &cf);
  v21 = (void *)cf;
  if (!(_DWORD)v20)
  {
    if (a12)
      *a12 = *((_QWORD *)cf + 4);
    CFRetain(a1);
    CFRetain(v21);
    dispatch_async_f(a1[8], v21, (dispatch_function_t)readScheduler_HandleReadRequest);
  }
  if (v21)
    CFRelease(v21);
  return v20;
}

void readScheduler_HandleReadRequest(_QWORD *a1)
{
  const void *v2;

  v2 = (const void *)a1[2];
  readScheduler_IngestRequest((uint64_t)v2, (uint64_t)a1);
  readScheduler_IssueReadsAndScheduleWakeup((uint64_t)v2);
  CFRelease(a1);
  CFRelease(v2);
}

uint64_t FigReadSchedulerRequestBackgroundRead(dispatch_queue_t *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  CFAllocatorRef v19;
  uint64_t v20;
  void *v21;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a3 || !a5 || !a8)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  v19 = CFGetAllocator(a1);
  v20 = rsRequest_Create((uint64_t)v19, (uint64_t)a1, a2, a3, a4, a5, a6, 1, a7, 0, a8, a9, a10, &cf);
  v21 = (void *)cf;
  if (!(_DWORD)v20)
  {
    if (a11)
      *a11 = *((_QWORD *)cf + 4);
    CFRetain(a1);
    CFRetain(v21);
    dispatch_async_f(a1[8], v21, (dispatch_function_t)readScheduler_HandleReadRequest);
  }
  if (v21)
    CFRelease(v21);
  return v20;
}

uint64_t FigReadSchedulerCancelRequest(dispatch_queue_t *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;

  if (a1 && a2)
  {
    v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040EDED9539uLL);
    if (v4)
    {
      v5 = v4;
      *v4 = CFRetain(a1);
      v5[1] = a2;
      dispatch_async_f(a1[8], v5, (dispatch_function_t)readScheduler_HandleCancelOneRequestJob);
      return 0;
    }
    v7 = 4294949516;
  }
  else
  {
    v7 = 4294949515;
  }
  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

void readScheduler_HandleCancelOneRequestJob(uint64_t *a1)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  CFArrayRef *ValueAtIndex;
  CFIndex v9;
  CFIndex v10;
  CFIndex v11;
  _QWORD *v12;

  v2 = readScheduler_RemoveAndRetainRequestFromReadArray(*(const __CFArray **)(*a1 + 32), a1[1]);
  if (v2)
    goto LABEL_3;
  v2 = readScheduler_RemoveAndRetainRequestFromReadArray(*(const __CFArray **)(*a1 + 40), a1[1]);
  if (v2)
    goto LABEL_3;
  v3 = *a1;
  v4 = a1[1];
  Count = CFArrayGetCount(*(CFArrayRef *)(*a1 + 24));
  if (Count >= 1)
  {
    v6 = Count;
    v7 = 0;
    do
    {
      ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 24), v7);
      v9 = CFArrayGetCount(ValueAtIndex[6]);
      if (v9 < 1)
      {
LABEL_11:
        v2 = 0;
      }
      else
      {
        v10 = v9;
        v11 = 0;
        while (1)
        {
          v12 = CFArrayGetValueAtIndex(ValueAtIndex[6], v11);
          if (v12[4] == v4)
            break;
          if (v10 == ++v11)
            goto LABEL_11;
        }
        v2 = CFRetain(v12);
        CFArrayRemoveValueAtIndex(ValueAtIndex[6], v11);
      }
      if (!CFArrayGetCount(ValueAtIndex[6]))
        *((_BYTE *)ValueAtIndex + 114) = 1;
      ++v7;
    }
    while (v7 < v6 && !v2);
    if (v2)
    {
LABEL_3:
      v2[27] = -17785;
      readScheduler_HandleFailedRequest(*a1, v2);
      CFRelease(v2);
    }
  }
  CFRelease((CFTypeRef)*a1);
  free(a1);
}

uint64_t FigReadSchedulerExpediteRequest(dispatch_queue_t *a1, uint64_t a2, int a3)
{
  const __CFAllocator *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  dispatch_group_t *v10;
  CFTypeRef v11;
  uint64_t v12;
  uint64_t v14;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  if (!a2)
  {
    v14 = 4294949515;
LABEL_14:
    v7 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
  v6 = CFGetAllocator(a1);
  v7 = rsBatch_Create(v6, &cf);
  if (!(_DWORD)v7)
  {
    v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004014030ADEuLL);
    if (v8)
    {
      v9 = v8;
      *v8 = CFRetain(a1);
      v9[1] = a2;
      v10 = (dispatch_group_t *)cf;
      v11 = CFRetain(cf);
      v9[2] = v11;
      *((_DWORD *)v11 + 13) = 1;
      dispatch_group_enter(*((dispatch_group_t *)v11 + 5));
      dispatch_async_f(a1[8], v9, (dispatch_function_t)readScheduler_HandleExpediteSingleRequestJob);
      if (a3)
        dispatch_group_wait(v10[5], 0xFFFFFFFFFFFFFFFFLL);
      v12 = 0;
      goto LABEL_8;
    }
    v14 = 4294949516;
    goto LABEL_14;
  }
LABEL_15:
  v12 = v7;
LABEL_8:
  if (cf)
    CFRelease(cf);
  return v12;
}

void readScheduler_HandleExpediteSingleRequestJob(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFArray *Mutable;
  CFArrayRef *v4;
  uint64_t v5;
  __CFSet *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  CFArrayRef *ValueAtIndex;
  CFIndex v11;
  CFIndex v12;
  CFIndex v13;
  _QWORD *v14;
  CFIndex v15;
  CFMutableArrayRef *v16;
  CFRange v17;

  v2 = CFGetAllocator(*(CFTypeRef *)a1);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  if (!readScheduler_RemoveAndCollectReadForRequestToExpediteFromReadArray(*(const __CFArray **)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 8), *(__CFSet **)(*(_QWORD *)(a1 + 16) + 32), Mutable)&& !readScheduler_RemoveAndCollectReadForRequestToExpediteFromReadArray(*(const __CFArray **)(*(_QWORD *)a1 + 40), *(_QWORD *)(a1 + 8), *(__CFSet **)(*(_QWORD *)(a1 + 16) + 32), Mutable))
  {
    v4 = *(CFArrayRef **)a1;
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(__CFSet **)(*(_QWORD *)(a1 + 16) + 32);
    Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)a1 + 24));
    if (Count >= 1)
    {
      v8 = Count;
      v9 = 0;
      while (1)
      {
        ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(v4[3], v9);
        v11 = CFArrayGetCount(ValueAtIndex[6]);
        if (v11 >= 1)
          break;
LABEL_9:
        if (++v9 == v8)
          goto LABEL_12;
      }
      v12 = v11;
      v13 = 0;
      while (1)
      {
        v14 = CFArrayGetValueAtIndex(ValueAtIndex[6], v13);
        if (v14[4] == v5)
          break;
        if (v12 == ++v13)
          goto LABEL_9;
      }
      CFSetAddValue(v6, v14);
    }
  }
LABEL_12:
  v15 = CFSetGetCount(*(CFSetRef *)(*(_QWORD *)(a1 + 16) + 32));
  v16 = *(CFMutableArrayRef **)a1;
  if (v15)
  {
    CFArrayAppendValue(v16[6], *(const void **)(a1 + 16));
    v17.length = CFArrayGetCount(Mutable);
    v17.location = 0;
    CFArrayApplyFunction(Mutable, v17, (CFArrayApplierFunction)readScheduler_ExpediteReadsArrayApplierFunction, *(void **)a1);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v16, *(_QWORD *)(a1 + 16));
  }
  CFRelease(*(CFTypeRef *)a1);
  CFRelease(*(CFTypeRef *)(a1 + 16));
  free((void *)a1);
  CFRelease(Mutable);
}

uint64_t FigReadSchedulerCancelAllClientRequests(dispatch_queue_t *a1, uint64_t a2, int a3)
{
  const __CFAllocator *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  dispatch_group_t *v10;
  CFTypeRef v11;
  uint64_t v12;
  uint64_t v14;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  if (!a2)
  {
    v14 = 4294949515;
LABEL_14:
    v7 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
  v6 = CFGetAllocator(a1);
  v7 = rsBatch_Create(v6, &cf);
  if (!(_DWORD)v7)
  {
    v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
    if (v8)
    {
      v9 = v8;
      *v8 = CFRetain(a1);
      v10 = (dispatch_group_t *)cf;
      v11 = CFRetain(cf);
      v9[1] = v11;
      v9[2] = a2;
      *((_DWORD *)v11 + 13) = 1;
      dispatch_group_enter(*((dispatch_group_t *)v11 + 5));
      dispatch_async_f(a1[8], v9, (dispatch_function_t)readScheduler_HandleCancelAllClientRequestsJob);
      if (a3)
        dispatch_group_wait(v10[5], 0xFFFFFFFFFFFFFFFFLL);
      v12 = 0;
      goto LABEL_8;
    }
    v14 = 4294949516;
    goto LABEL_14;
  }
LABEL_15:
  v12 = v7;
LABEL_8:
  if (cf)
    CFRelease(cf);
  return v12;
}

void readScheduler_HandleCancelAllClientRequestsJob(const void **a1)
{
  const void *v2;
  CFArrayRef *v3;
  __CFSet *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  CFArrayRef *ValueAtIndex;
  CFIndex v9;
  CFIndex v10;
  CFIndex v11;
  _QWORD *v12;
  CFIndex v13;
  uint64_t v14;
  const __CFAllocator *v15;
  const __CFSet *Copy;

  readScheduler_RemoveAndCollectClientRequestsFromReadArray(*((const __CFArray **)*a1 + 4), (uint64_t)a1[2], *((__CFSet **)a1[1] + 4));
  readScheduler_RemoveAndCollectClientRequestsFromReadArray(*((const __CFArray **)*a1 + 5), (uint64_t)a1[2], *((__CFSet **)a1[1] + 4));
  v2 = a1[2];
  v3 = (CFArrayRef *)*a1;
  v4 = (__CFSet *)*((_QWORD *)a1[1] + 4);
  Count = CFArrayGetCount(*((CFArrayRef *)*a1 + 3));
  if (Count >= 1)
  {
    v6 = Count;
    for (i = 0; i != v6; ++i)
    {
      ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(v3[3], i);
      v9 = CFArrayGetCount(ValueAtIndex[6]);
      if (v9 >= 1)
      {
        v10 = v9;
        v11 = 0;
        do
        {
          v12 = CFArrayGetValueAtIndex(ValueAtIndex[6], v11);
          if ((const void *)v12[3] == v2)
          {
            CFSetAddValue(v4, v12);
            CFArrayRemoveValueAtIndex(ValueAtIndex[6], v11);
            --v10;
          }
          else
          {
            ++v11;
          }
        }
        while (v11 < v10);
      }
      if (!CFArrayGetCount(ValueAtIndex[6]))
        *((_BYTE *)ValueAtIndex + 114) = 1;
    }
  }
  v13 = CFSetGetCount(*((CFSetRef *)a1[1] + 4));
  v14 = (uint64_t)*a1;
  if (v13)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(v14 + 48), a1[1]);
    v15 = CFGetAllocator(*((CFTypeRef *)a1[1] + 4));
    Copy = CFSetCreateCopy(v15, *((CFSetRef *)a1[1] + 4));
    CFSetApplyFunction(Copy, (CFSetApplierFunction)readScheduler_CancelRequestApplierFunction, (void *)*a1);
  }
  else
  {
    readScheduler_CompleteBatch(v14, (uint64_t)a1[1]);
    Copy = 0;
  }
  CFRelease(*a1);
  CFRelease(a1[1]);
  free(a1);
  if (Copy)
    CFRelease(Copy);
}

uint64_t FigReadSchedulerExpediteAllClientRequests(dispatch_queue_t *a1, uint64_t a2, int a3)
{
  const __CFAllocator *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  dispatch_group_t *v10;
  CFTypeRef v11;
  uint64_t v12;
  uint64_t v14;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
    return FigSignalErrorAt(4294949515, 0, 0, 0, 0, 0, 0);
  if (!a2)
  {
    v14 = 4294949515;
LABEL_14:
    v7 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
  v6 = CFGetAllocator(a1);
  v7 = rsBatch_Create(v6, &cf);
  if (!(_DWORD)v7)
  {
    v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
    if (v8)
    {
      v9 = v8;
      *v8 = CFRetain(a1);
      v10 = (dispatch_group_t *)cf;
      v11 = CFRetain(cf);
      v9[1] = v11;
      v9[2] = a2;
      *((_DWORD *)v11 + 13) = 1;
      dispatch_group_enter(*((dispatch_group_t *)v11 + 5));
      dispatch_async_f(a1[8], v9, (dispatch_function_t)readScheduler_HandleExpediteAllClientRequestsJob);
      if (a3)
        dispatch_group_wait(v10[5], 0xFFFFFFFFFFFFFFFFLL);
      v12 = 0;
      goto LABEL_8;
    }
    v14 = 4294949516;
    goto LABEL_14;
  }
LABEL_15:
  v12 = v7;
LABEL_8:
  if (cf)
    CFRelease(cf);
  return v12;
}

void readScheduler_HandleExpediteAllClientRequestsJob(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFArray *Mutable;
  uint64_t v4;
  CFArrayRef *v5;
  __CFSet *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  CFArrayRef *ValueAtIndex;
  CFIndex v11;
  CFIndex v12;
  CFIndex j;
  _QWORD *v14;
  CFIndex v15;
  CFMutableArrayRef *v16;
  CFRange v17;

  v2 = CFGetAllocator(*(CFTypeRef *)a1);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  readScheduler_RemoveAndCollectClientReadsToExpediteFromReadArray(*(const __CFArray **)(*(_QWORD *)a1 + 32), *(_QWORD *)(a1 + 16), *(__CFSet **)(*(_QWORD *)(a1 + 8) + 32), Mutable);
  readScheduler_RemoveAndCollectClientReadsToExpediteFromReadArray(*(const __CFArray **)(*(_QWORD *)a1 + 40), *(_QWORD *)(a1 + 16), *(__CFSet **)(*(_QWORD *)(a1 + 8) + 32), Mutable);
  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(CFArrayRef **)a1;
  v6 = *(__CFSet **)(*(_QWORD *)(a1 + 8) + 32);
  Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)a1 + 24));
  if (Count >= 1)
  {
    v8 = Count;
    for (i = 0; i != v8; ++i)
    {
      ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(v5[3], i);
      v11 = CFArrayGetCount(ValueAtIndex[6]);
      if (v11 >= 1)
      {
        v12 = v11;
        for (j = 0; j != v12; ++j)
        {
          v14 = CFArrayGetValueAtIndex(ValueAtIndex[6], j);
          if (v14[3] == v4)
            CFSetAddValue(v6, v14);
        }
      }
    }
  }
  v15 = CFSetGetCount(*(CFSetRef *)(*(_QWORD *)(a1 + 8) + 32));
  v16 = *(CFMutableArrayRef **)a1;
  if (v15)
  {
    CFArrayAppendValue(v16[6], *(const void **)(a1 + 8));
    v17.length = CFArrayGetCount(Mutable);
    v17.location = 0;
    CFArrayApplyFunction(Mutable, v17, (CFArrayApplierFunction)readScheduler_ExpediteReadsArrayApplierFunction, *(void **)a1);
  }
  else
  {
    readScheduler_CompleteBatch((uint64_t)v16, *(_QWORD *)(a1 + 8));
  }
  CFRelease(*(CFTypeRef *)a1);
  CFRelease(*(CFTypeRef *)(a1 + 8));
  free((void *)a1);
  CFRelease(Mutable);
}

CFMutableDictionaryRef rsRegistry_PerformInitialization()
{
  CFMutableDictionaryRef result;

  gRSRegistry_0 = (uint64_t)FigSimpleMutexCreate();
  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  gRSRegistry_1 = (uint64_t)result;
  return result;
}

void readScheduler_DeadlineTimerHandler(id *a1)
{
  id *v1;
  id *v2;

  v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    v2 = v1;
    dispatch_source_set_timer((dispatch_source_t)v1[10], 0xFFFFFFFFFFFFFFFFLL, 0, 0);
    v2[11] = (id)0x7FFFFFFFFFFFFFFFLL;
    readScheduler_IssueReadsAndScheduleWakeup((uint64_t)v2);
    CFRelease(v2);
  }
}

void readScheduler_DeadlineTimerCancelCallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void readScheduler_IssueReadsAndScheduleWakeup(uint64_t a1)
{
  int i;
  int64_t UpTimeNanoseconds;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  _QWORD *ValueAtIndex;
  CFTypeRef v8;
  CFIndex v9;
  CFIndex v10;
  CFIndex v11;
  _BYTE *v12;
  _QWORD *v13;
  uint64_t v14;
  int64_t v15;
  dispatch_time_t v16;
  uint64_t v17;
  void (__cdecl *v18)(void *);

  for (i = 0; i != 4; ++i)
  {
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
    if (Count >= 1)
    {
      v5 = Count;
      v6 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), v6);
        if (ValueAtIndex[10] - *(_QWORD *)(a1 + 96) <= UpTimeNanoseconds)
          break;
        if (v5 == ++v6)
          goto LABEL_8;
      }
      v8 = CFRetain(ValueAtIndex);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 32), v6);
      if (v8)
        goto LABEL_14;
    }
LABEL_8:
    v9 = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
    if (v9 < 1)
      break;
    v10 = v9;
    v11 = 0;
    while (1)
    {
      v12 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v11);
      if (!v12[113])
        break;
      if (v10 == ++v11)
        goto LABEL_15;
    }
    v8 = CFRetain(v12);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 40), v11);
    if (!v8)
      break;
LABEL_14:
    readScheduler_IssueOneRead(a1, (uint64_t)v8);
    CFRelease(v8);
  }
LABEL_15:
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 32))
    && (v13 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), 0)) != 0
    && (v14 = v13[10] - *(_QWORD *)(a1 + 96), v14 < *(_QWORD *)(a1 + 88)))
  {
    v15 = v14 - FigGetUpTimeNanoseconds();
    if (v15 >= 1)
    {
      v16 = dispatch_time(0, v15);
      *(_QWORD *)(a1 + 88) = v14;
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 80), v16, 0xFFFFFFFFFFFFFFFFLL, 0);
      goto LABEL_20;
    }
LABEL_21:
    CFRetain((CFTypeRef)a1);
    v17 = 64;
    if (*(int *)(a1 + 380) <= 3)
    {
      v18 = (void (__cdecl *)(void *))readScheduler_CallIssueReadsAndScheduleWakeup;
    }
    else
    {
      v17 = 120;
      v18 = (void (__cdecl *)(void *))readScheduler_LetReadsProgress;
    }
    dispatch_async_f(*(dispatch_queue_t *)(a1 + v17), (void *)a1, v18);
  }
  else
  {
LABEL_20:
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 40)) != *(_DWORD *)(a1 + 384))
      goto LABEL_21;
  }
}

void readScheduler_LetReadsProgress(dispatch_queue_t *a1)
{
  CFRetain(a1);
  dispatch_async_f(a1[8], a1, (dispatch_function_t)readScheduler_CallIssueReadsAndScheduleWakeup);
  CFRelease(a1);
}

void readScheduler_CallIssueReadsAndScheduleWakeup(const void *a1)
{
  readScheduler_IssueReadsAndScheduleWakeup();
  CFRelease(a1);
}

void readScheduler_IssueOneRead(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 24), (const void *)a2);
  FigAtomicIncrement32((unsigned int *)(a1 + 380));
  if (*(_BYTE *)(a1 + 376))
  {
    v4 = 0;
    v5 = 0;
    v6 = (int *)(a1 + 176);
    v7 = 0x7FFFFFFF;
    while (*((_QWORD *)v6 - 1) != *(_QWORD *)(a2 + 32))
    {
      v9 = *v6;
      v6 += 16;
      v8 = v9;
      if (v9 < v7)
      {
        v5 = v4;
        v7 = v8;
      }
      if (++v4 == 4)
        goto LABEL_10;
    }
    v5 = v4;
LABEL_10:
    v10 = a1 + ((uint64_t)v5 << 6) + 120;
  }
  else
  {
    v10 = a1 + 120;
  }
  *(_QWORD *)(a2 + 24) = v10;
  FigAtomicIncrement32((unsigned int *)(v10 + 56));
  *(_QWORD *)(*(_QWORD *)(a2 + 24) + 48) = *(_QWORD *)(a2 + 32);
  CFRetain((CFTypeRef)a1);
  CFRetain((CFTypeRef)a2);
  dispatch_async_f(**(dispatch_queue_t **)(a2 + 24), (void *)a2, (dispatch_function_t)readScheduler_PerformRead);
}

void readScheduler_PerformRead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  uint64_t v18;
  vm_address_t v19;
  OSStatus DataPointer;
  char *v21;
  vm_address_t v22;
  CMBlockBufferRef v23;
  uint64_t v24;
  CFTypeRef v25;
  int v26;
  uint64_t v27;
  char *v28;
  int v29;
  BOOL v30;
  const void *v31;
  const void *v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  const __CFAllocator *v36;
  _OWORD *v37;
  CMBlockBufferRef theBuffer;
  char *dataPointerOut;

  v5 = *(_QWORD *)(a1 + 16);
  if (*(_BYTE *)(a1 + 114))
  {
    *(_DWORD *)(a1 + 64) = 0;
    goto LABEL_45;
  }
  v6 = *(_QWORD *)(a1 + 24);
  v7 = (_QWORD *)(a1 + 96);
  v8 = *(_QWORD *)(a1 + 104) - *(_QWORD *)(a1 + 96);
  v9 = *(_QWORD *)(v5 + 392);
  theBuffer = 0;
  dataPointerOut = 0;
  v37 = (_OWORD *)(a1 + 96);
  if (*(_QWORD *)(v6 + 8))
  {
    v10 = FigCFWeakReferenceLoadAndRetain((id *)(v6 + 32));
    if (*(id *)(a1 + 32) == v10
      && (v11 = *v7, v12 = *(_QWORD *)(v6 + 16), v13 = __OFSUB__(*v7, v12), v14 = *v7 - v12, v14 < 0 == v13)
      && (v15 = *(_QWORD *)(v6 + 24), v11 <= v15))
    {
      if (*(_QWORD *)(a1 + 104) < v15)
        v15 = *(_QWORD *)(a1 + 104);
      v34 = v15 - v11;
      v18 = v34 + 1;
      v35 = *(_QWORD *)(v5 + 392);
      v17 = v35 * v14;
      v16 = (v34 + 1) * v35;
      if (v34 == v8)
      {
        v36 = CFGetAllocator((CFTypeRef)v5);
        DataPointer = CMBlockBufferCreateWithBufferReference(v36, *(CMBlockBufferRef *)(v6 + 8), v17, v16, 0, &theBuffer);
        if (DataPointer)
          goto LABEL_52;
        v23 = theBuffer;
        if (theBuffer)
        {
          v21 = 0;
          v22 = 0;
LABEL_14:
          v24 = *(_QWORD *)(a1 + 88) + *(_QWORD *)(v5 + 392) * v18;
          v25 = CFRetain(v23);
          v26 = 0;
          if (!v10)
            goto LABEL_16;
          goto LABEL_15;
        }
      }
    }
    else
    {
      v16 = 0;
      v17 = 0;
      v18 = 0;
    }
  }
  else
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v10 = 0;
  }
  v19 = v9 + v9 * v8;
  DataPointer = FigMemoryPoolCreateBlockBuffer(*(_QWORD *)(v5 + 104), v19, &theBuffer, a4);
  if (!DataPointer)
  {
    DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if (!DataPointer)
    {
      v21 = dataPointerOut;
      if (!v16)
      {
LABEL_13:
        v22 = v19 - v16;
        v23 = theBuffer;
        goto LABEL_14;
      }
      DataPointer = CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(v6 + 8), v17, v16, dataPointerOut);
      if (!DataPointer)
      {
        v21 = &dataPointerOut[v16];
        dataPointerOut += v16;
        goto LABEL_13;
      }
    }
  }
LABEL_52:
  v26 = DataPointer;
  v16 = 0;
  v22 = 0;
  v24 = 0;
  v21 = 0;
  v25 = 0;
  if (v10)
LABEL_15:
    CFRelease(v10);
LABEL_16:
  if (theBuffer)
    CFRelease(theBuffer);
  if (v26)
    goto LABEL_43;
  if (v22)
  {
    dataPointerOut = 0;
    v27 = *(_QWORD *)(a1 + 32);
    v28 = *(char **)(*(_QWORD *)(CMBaseObjectGetVTable(v27) + 16) + 8);
    if (v28)
    {
      v26 = ((uint64_t (*)(uint64_t, vm_address_t, uint64_t, char *, char **))v28)(v27, v22, v24, v21, &dataPointerOut);
      v28 = dataPointerOut;
    }
    else
    {
      v26 = -12782;
    }
    if (v22 <= (unint64_t)v28)
    {
      v29 = 0;
    }
    else
    {
      bzero(&v28[(_QWORD)v21], v22 - (_QWORD)v28);
      if (v16)
        v30 = v26 == 0;
      else
        v30 = 1;
      if (!v30)
        v26 = 0;
      v29 = 1;
      v28 = dataPointerOut;
    }
    v16 += (size_t)v28;
    if (!v16)
      goto LABEL_43;
    goto LABEL_34;
  }
  v26 = 0;
  v29 = 0;
  if (v16)
  {
LABEL_34:
    *(_QWORD *)(a1 + 40) = CFRetain(v25);
    *(_QWORD *)(a1 + 72) = v16;
    if (v29)
    {
      FigCFWeakReferenceStore((id *)(v6 + 32), 0);
      v31 = *(const void **)(v6 + 8);
      if (v31)
      {
        CFRelease(v31);
        *(_QWORD *)(v6 + 8) = 0;
      }
    }
    else if (v22)
    {
      FigCFWeakReferenceStore((id *)(v6 + 32), *(id *)(a1 + 32));
      v32 = *(const void **)(v6 + 8);
      v33 = *(const void **)(a1 + 40);
      *(_QWORD *)(v6 + 8) = v33;
      if (v33)
        CFRetain(v33);
      if (v32)
        CFRelease(v32);
      *(_OWORD *)(v6 + 16) = *v37;
    }
  }
LABEL_43:
  *(_DWORD *)(a1 + 64) = v26;
  if (v25)
    CFRelease(v25);
LABEL_45:
  FigAtomicDecrement32((unsigned int *)(v5 + 380));
  FigAtomicDecrement32((unsigned int *)(*(_QWORD *)(a1 + 24) + 56));
  CFRetain((CFTypeRef)v5);
  CFRetain((CFTypeRef)a1);
  dispatch_async_f(*(dispatch_queue_t *)(v5 + 56), (void *)a1, (dispatch_function_t)readScheduler_HandleOneCompletedRead);
  CFRelease((CFTypeRef)a1);
  CFRelease((CFTypeRef)v5);
}

void readScheduler_HandleOneCompletedRead(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  CFIndex FirstIndexOfValue;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const void *ValueAtIndex;
  int appended;
  size_t v10;
  OpaqueCMBlockBuffer *v11;
  const __CFAllocator *v12;
  const __CFArray *v13;
  CFIndex v14;
  CFIndex j;
  const void *v16;
  size_t v17;
  char *dataPointerOut;
  CFRange v19;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(const __CFArray **)(v2 + 24);
  v19.length = CFArrayGetCount(v3);
  v19.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v3, v19, (const void *)a1);
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 24), FirstIndexOfValue);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (Count)
  {
    v6 = Count;
    if (Count >= 1)
    {
      for (i = 0; i != v6; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), i);
        appended = *(_DWORD *)(a1 + 64);
        if (!appended)
        {
          v10 = *((_QWORD *)ValueAtIndex + 7) - *(_QWORD *)(a1 + 88);
          if (v10 >= *(_QWORD *)(a1 + 72))
          {
            appended = FigSignalErrorAt(4294949514, 0, 0, 0, 0, 0, 0);
          }
          else
          {
            v11 = (OpaqueCMBlockBuffer *)*((_QWORD *)ValueAtIndex + 5);
            if (v11)
            {
              if (CMBlockBufferIsEmpty(v11))
              {
                appended = CMBlockBufferAppendBufferReference(*((CMBlockBufferRef *)ValueAtIndex + 5), *(CMBlockBufferRef *)(a1 + 40), v10, *((_QWORD *)ValueAtIndex + 8), 0);
              }
              else
              {
                v17 = 0;
                dataPointerOut = 0;
                appended = CMBlockBufferAssureBlockMemory(*((CMBlockBufferRef *)ValueAtIndex + 5));
                if (!appended)
                {
                  appended = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1 + 40), v10, &v17, 0, &dataPointerOut);
                  if (!appended)
                    appended = CMBlockBufferReplaceDataBytes(dataPointerOut, *((CMBlockBufferRef *)ValueAtIndex + 5), 0, *((_QWORD *)ValueAtIndex + 8));
                }
              }
            }
            else
            {
              v12 = CFGetAllocator(ValueAtIndex);
              appended = CMBlockBufferCreateWithBufferReference(v12, *(CMBlockBufferRef *)(a1 + 40), v10, *((_QWORD *)ValueAtIndex + 8), 0, (CMBlockBufferRef *)ValueAtIndex + 5);
            }
          }
        }
        *((_DWORD *)ValueAtIndex + 27) = appended;
      }
    }
    v13 = *(const __CFArray **)(a1 + 48);
    *(_QWORD *)(a1 + 48) = 0;
    v14 = CFArrayGetCount(v13);
    CFRetain(v13);
    dispatch_async_f(*(dispatch_queue_t *)(v2 + 72), v13, (dispatch_function_t)readScheduler_DispatchFulfilledRequestsCallbacks);
    if (v14 >= 1)
    {
      for (j = 0; j != v14; ++j)
      {
        v16 = CFArrayGetValueAtIndex(v13, j);
        readScheduler_UpdateBatches(v2, v16, 0);
      }
    }
    CFRelease(v13);
  }
  CFRelease((CFTypeRef)a1);
  CFRelease((CFTypeRef)v2);
}

void readScheduler_DispatchFulfilledRequestsCallbacks(const __CFArray *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex i;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v3 = Count;
    for (i = 0; i != v3; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      readScheduler_CallRequestCallback((uint64_t)ValueAtIndex);
    }
  }
  CFRelease(a1);
}

void readScheduler_UpdateBatches(uint64_t a1, const void *a2, int a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  CFSetRef *ValueAtIndex;
  uint64_t v10;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (Count >= 1)
  {
    v7 = Count;
    v8 = 0;
    do
    {
      ValueAtIndex = (CFSetRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v8);
      v10 = (uint64_t)ValueAtIndex;
      if (a3 && CFSetContainsValue(ValueAtIndex[4], a2))
        *(_BYTE *)(v10 + 48) = 1;
      CFSetRemoveValue(*(CFMutableSetRef *)(v10 + 32), a2);
      if (CFSetGetCount(*(CFSetRef *)(v10 + 32)))
      {
        ++v8;
      }
      else
      {
        readScheduler_CompleteBatch(a1, v10);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 48), v8);
        --v7;
      }
    }
    while (v8 < v7);
  }
}

void readScheduler_CallRequestCallback(uint64_t a1)
{
  const void *v2;

  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 112))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64), *(unsigned int *)(a1 + 108));
  v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

void readScheduler_CompleteBatch(uint64_t a1, uint64_t a2)
{
  FigSimpleMutexLock(*(pthread_mutex_t **)(a2 + 24));
  *(_DWORD *)(a2 + 52) = 2;
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a2 + 32));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a2 + 24));
  CFRetain((CFTypeRef)a2);
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 72), (void *)a2, (dispatch_function_t)readScheduler_NotifyCompletedBatch);
}

void readScheduler_NotifyCompletedBatch(dispatch_group_t *a1)
{
  __CFNotificationCenter *DefaultLocalCenter;

  dispatch_group_leave(a1[5]);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("readSchedulerNotification_BatchCompleted"), a1, 0);
  CFRelease(a1);
}

double rsBatch_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

id rsBatch_Finalize(uint64_t a1)
{
  const void *v2;
  NSObject *v3;

  v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_release(v3);
    *(_QWORD *)(a1 + 40) = 0;
  }
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 24));
  return FigCFWeakReferenceStore((id *)(a1 + 16), 0);
}

__CFString *rsBatch_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  CFIndex v3;
  int v4;
  const char *v5;
  const char *v6;
  const char *v7;
  CFIndex Count;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = CFGetRetainCount((CFTypeRef)a1);
  v4 = *(_DWORD *)(a1 + 52);
  v5 = "Completed";
  if (v4 == 1)
    v5 = "Committed";
  if (v4)
    v6 = v5;
  else
    v6 = "Open";
  if (*(_BYTE *)(a1 + 48))
    v7 = "and Cancelled";
  else
    v7 = "";
  Count = CFSetGetCount(*(CFSetRef *)(a1 + 32));
  CFStringAppendFormat(Mutable, 0, CFSTR("RSBatch %p RC %d State %s%s req %d"), a1, v3, v6, v7, Count);
  CFSetApplyFunction(*(CFSetRef *)(a1 + 32), (CFSetApplierFunction)rsBatch_RequestSetDebugDescApplierFunction, Mutable);
  return Mutable;
}

void rsBatch_RequestSetDebugDescApplierFunction(const void *a1, __CFString *a2)
{
  CFStringRef v3;

  v3 = CFCopyDescription(a1);
  CFStringAppendFormat(a2, 0, CFSTR("\n\t%@"), v3);
  if (v3)
    CFRelease(v3);
}

uint64_t rsRequest_RegisterType(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

double rsRequest_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 128) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void rsRequest_Finalize(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 48) = 0;
  }
}

__CFString *rsRequest_CopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  int v4;
  CFIndex v5;
  const char *v6;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = *(unsigned __int8 *)(a1 + 104);
  v5 = CFGetRetainCount((CFTypeRef)a1);
  if (v4)
  {
    if ((*(_QWORD *)(a1 + 88) & 0x100000000) != 0)
      v6 = "Latched ";
    else
      v6 = "";
    CFStringAppendFormat(Mutable, 0, CFSTR("RSRequest %p RC %d Background %sreqID %lld clientID %lld %zd bytes @ %lld [%lld:%lld]"), a1, v5, v6, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80));
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("RSRequest %p RC %d reqID %lld clientID %lld %zd bytes @ %lld [%lld:%lld] time %lld"), a1, v5, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 96));
  }
  return Mutable;
}

void readScheduler_BatchRequestIngestApplierFunction(uint64_t a1, uint64_t a2)
{
  readScheduler_IngestRequest(a2, a1);
}

void readScheduler_IngestRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  _QWORD *v11;
  uint64_t v12;
  const __CFArray *v13;
  CFIndex v14;
  CFIndex v15;
  CFIndex v16;
  char *ValueAtIndex;
  _QWORD *v18;
  _OWORD *v19;
  const __CFAllocator *v20;
  uint64_t Instance;
  uint64_t v22;
  CFMutableArrayRef Mutable;
  int v24;
  int v25;
  int v26;
  CFIndex v27;
  CFIndex v28;
  CFIndex v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex v38;
  _QWORD *v39;
  uint64_t v40;
  _BOOL4 v42;
  uint64_t v43;
  int v44;
  __int128 v45;

  v4 = *(_QWORD *)(a2 + 56);
  v5 = *(_QWORD *)(a1 + 392);
  *(_QWORD *)(a2 + 72) = (v4 & (unint64_t)-v5) / v5;
  v6 = (_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 80) = ((v4 + v5 + *(_QWORD *)(a2 + 64) - 1) & (unint64_t)-v5) / v5 - 1;
  v7 = *(_QWORD *)(a2 + 96);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count < 1)
  {
LABEL_8:
    v12 = 40;
    if (!*(_BYTE *)(a2 + 104))
      v12 = 32;
    v13 = *(const __CFArray **)(a1 + v12);
    if (*(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72) < *(int *)(a1 + 388))
    {
      v14 = CFArrayGetCount(v13);
      if (v14 >= 1)
      {
        v15 = v14;
        v16 = 0;
        while (1)
        {
          v45 = 0uLL;
          ValueAtIndex = (char *)CFArrayGetValueAtIndex(v13, v16);
          if (*(_QWORD *)(a2 + 48) == *((_QWORD *)ValueAtIndex + 4))
          {
            v18 = ValueAtIndex;
            v19 = ValueAtIndex + 96;
            if (readScheduler_CombinePageRanges(a1, (_QWORD *)ValueAtIndex + 12, v6, &v45) == 1)
              break;
          }
          if (v15 == ++v16)
            goto LABEL_16;
        }
        v43 = v45;
        if (*((uint64_t *)&v45 + 1) <= v18[13])
          v25 = 2 * ((uint64_t)v45 < v18[12]);
        else
          v25 = (2 * ((uint64_t)v45 < v18[12])) | 4;
        *v19 = v45;
        v18[11] = *(_QWORD *)(v18[2] + 392) * v43;
        readScheduler_AddRequestToRead((uint64_t)v18, a2);
        if (v7 >= v18[10])
        {
          v22 = 0;
          v24 = 1;
        }
        else
        {
          v22 = (uint64_t)CFRetain(v18);
          CFArrayRemoveValueAtIndex(v13, v16);
          v18[10] = v7;
          v24 = 1;
          if (v22)
          {
            v26 = 0;
LABEL_25:
            v27 = CFArrayGetCount(v13);
            if (v27 < 1)
            {
              v29 = 0;
            }
            else
            {
              v28 = v27;
              v29 = 0;
              while (1)
              {
                v30 = CFArrayGetValueAtIndex(v13, v29);
                v31 = *(_QWORD *)(v22 + 80);
                v32 = v30[10];
                if (v31 < v32)
                  break;
                if (v31 == v32)
                {
                  v33 = v30;
                  v34 = *((_QWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v22 + 48), 0) + 4);
                  if (v34 < *((_QWORD *)CFArrayGetValueAtIndex((CFArrayRef)v33[6], 0) + 4))
                    break;
                }
                if (v28 == ++v29)
                {
                  v29 = v28;
                  break;
                }
              }
            }
            CFArrayInsertValueAtIndex(v13, v29, (const void *)v22);
            if (v26)
              v16 = -1;
            else
              v16 = v29;
            goto LABEL_36;
          }
          v16 = -1;
        }
LABEL_36:
        if (v24 && v25)
        {
          while (1)
          {
            v35 = CFArrayGetValueAtIndex(v13, v16);
            v36 = CFArrayGetCount(v13);
            if (v36 < 1)
              break;
            v37 = v36;
            v38 = 0;
            while (1)
            {
              if (v16 != v38)
              {
                v45 = 0uLL;
                v39 = CFArrayGetValueAtIndex(v13, v38);
                if (v35[4] == v39[4])
                {
                  v40 = (uint64_t)v39;
                  if (readScheduler_CombinePageRanges(a1, v39 + 12, v35 + 12, &v45) == 1)
                    break;
                }
              }
              if (v37 == ++v38)
                goto LABEL_55;
            }
            if (v38 >= v16)
            {
              readScheduler_CombineReads(v13, (uint64_t)v35, v40, &v45, v38);
            }
            else
            {
              v42 = *((uint64_t *)&v45 + 1) > *(_QWORD *)(v40 + 104) || (uint64_t)v45 < *(_QWORD *)(v40 + 96);
              readScheduler_CombineReads(v13, v40, (uint64_t)v35, &v45, v16);
              v16 = v38;
              if (!v42)
                break;
            }
          }
        }
LABEL_55:
        if (v22)
          CFRelease((CFTypeRef)v22);
        return;
      }
    }
LABEL_16:
    v20 = CFGetAllocator((CFTypeRef)a1);
    if (rsRead_GetTypeID_sRegisterRSReadTypeOnce != -1)
      dispatch_once_f(&rsRead_GetTypeID_sRegisterRSReadTypeOnce, &rsRead_GetTypeID_sRSReadID, (dispatch_function_t)rsRead_RegisterType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v22 = Instance;
      Mutable = CFArrayCreateMutable(v20, 0, MEMORY[0x1E0C9B378]);
      *(_QWORD *)(v22 + 48) = Mutable;
      if (Mutable)
      {
LABEL_20:
        *(_QWORD *)(v22 + 16) = a1;
        *(_QWORD *)(v22 + 56) = FigAtomicIncrement64(&gNextReadID);
        *(_QWORD *)(v22 + 80) = v7;
        *(_QWORD *)(v22 + 32) = CFRetain(*(CFTypeRef *)(a2 + 48));
        *(_OWORD *)(v22 + 96) = *(_OWORD *)v6;
        *(_QWORD *)(v22 + 88) = *(_QWORD *)(*(_QWORD *)(v22 + 16) + 392) * *(_QWORD *)(a2 + 72);
        if (*(_BYTE *)(a2 + 104))
        {
          *(_BYTE *)(v22 + 112) = 1;
          if ((*(_BYTE *)(a2 + 92) & 1) != 0)
          {
            *(_BYTE *)(v22 + 113) = 1;
            FigAtomicIncrement32((unsigned int *)(a1 + 384));
          }
          else
          {
            *(_BYTE *)(v22 + 113) = 0;
          }
        }
        readScheduler_AddRequestToRead(v22, a2);
        v24 = 0;
        v25 = 0;
        v26 = 1;
        goto LABEL_25;
      }
      v44 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
      CFRelease((CFTypeRef)v22);
    }
    else
    {
      v44 = FigSignalErrorAt(4294949516, 0, 0, 0, 0, 0, 0);
    }
    if (v44)
    {
      *(_DWORD *)(a2 + 108) = v44;
      readScheduler_HandleFailedRequest(a1, (_DWORD *)a2);
      return;
    }
    v22 = 0;
    goto LABEL_20;
  }
  v9 = Count;
  v10 = 0;
  while (1)
  {
    v11 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v10);
    if (*(_QWORD *)(a2 + 48) == v11[4] && *v6 >= v11[12] && *(_QWORD *)(a2 + 80) <= v11[13] && !*((_BYTE *)v11 + 114))
      break;
    if (v9 == ++v10)
      goto LABEL_8;
  }
  readScheduler_AddRequestToRead((uint64_t)v11, a2);
}

uint64_t readScheduler_CombinePageRanges(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *a3;
  if (*a3 <= *a2)
    v5 = *a2;
  else
    v5 = *a3;
  if (*a3 >= *a2)
    v6 = a3;
  else
    v6 = a2;
  if (*a3 < *a2)
  {
    v7 = a3;
  }
  else
  {
    v4 = *a2;
    v7 = a2;
  }
  if (v4 == v5)
  {
    *a4 = v5;
    v8 = v6[1];
    if (v7[1] > v8)
      v8 = v7[1];
  }
  else
  {
    v9 = v7[1];
    if (v9 >= v5 - 1)
    {
      *a4 = v4;
      v8 = v6[1];
      if (v9 > v8)
        v8 = v9;
    }
    else
    {
      if (v5 - v9 > 2)
        return 0;
      *a4 = v4;
      v8 = v6[1];
    }
  }
  a4[1] = v8;
  if (v8 - v4 < *(int *)(a1 + 388))
    return 1;
  else
    return 2;
}

void readScheduler_AddRequestToRead(uint64_t a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  uint64_t v6;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  while ((Count & 0x8000000000000000) == 0)
  {
    v5 = Count;
    if (Count)
    {
      v6 = *(_QWORD *)(a2 + 32);
      --Count;
      if (v6 <= *((_QWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v5 - 1) + 4))
        continue;
    }
    CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 48), v5, (const void *)a2);
    break;
  }
  if (*(_BYTE *)(a2 + 104) && (*(_BYTE *)(a2 + 92) & 1) == 0 && *(_BYTE *)(a1 + 112))
  {
    if (*(_BYTE *)(a1 + 113))
    {
      *(_BYTE *)(a1 + 113) = 0;
      FigAtomicDecrement32((unsigned int *)(*(_QWORD *)(a1 + 16) + 384));
    }
  }
}

void readScheduler_HandleFailedRequest(uint64_t a1, _DWORD *cf)
{
  _BOOL4 v4;

  v4 = cf[27] == -17785;
  CFRetain(cf);
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 72), cf, (dispatch_function_t)readScheduler_DispatchRequestCallback);
  readScheduler_UpdateBatches(a1, cf, v4);
}

uint64_t rsRead_RegisterType(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

double rsRead_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 112) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void rsRead_Finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[4];
  if (v2)
  {
    CFRelease(v2);
    a1[4] = 0;
  }
  v3 = (const void *)a1[5];
  if (v3)
  {
    CFRelease(v3);
    a1[5] = 0;
  }
  v4 = (const void *)a1[6];
  if (v4)
  {
    CFRelease(v4);
    a1[6] = 0;
  }
}

__CFString *rsRead_CopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFIndex Count;
  int v5;
  CFIndex v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex i;
  const void *ValueAtIndex;
  CFStringRef v14;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  v5 = *(unsigned __int8 *)(a1 + 112);
  v6 = CFGetRetainCount((CFTypeRef)a1);
  if (v5)
  {
    if (*(_BYTE *)(a1 + 113))
      v7 = "Latched ";
    else
      v7 = "";
    v8 = *(_QWORD *)(a1 + 24);
    if (v8)
      v9 = *(unsigned int *)(v8 + 40);
    else
      v9 = 0xFFFFFFFFLL;
    CFStringAppendFormat(Mutable, 0, CFSTR("RSRead %p RC %d Background %sreadID %lld context %d BS %@ @ %lld [%lld:%lld] numReqs %d\n"), a1, v6, v7, *(_QWORD *)(a1 + 56), v9, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), Count);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 24);
    if (v10)
      v11 = *(unsigned int *)(v10 + 40);
    else
      v11 = 0xFFFFFFFFLL;
    CFStringAppendFormat(Mutable, 0, CFSTR("RSRead %p RC %d readID %lld context %d BS %@ @ %lld [%lld:%lld] time %lld numReqs %d\n"), a1, v6, *(_QWORD *)(a1 + 56), v11, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 80), Count);
  }
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), i);
      v14 = CFCopyDescription(ValueAtIndex);
      CFStringAppendFormat(Mutable, 0, CFSTR("\t%2d. %@\n"), i, v14);
      if (v14)
        CFRelease(v14);
    }
  }
  return Mutable;
}

void readScheduler_DispatchRequestCallback(const void *a1)
{
  readScheduler_CallRequestCallback((uint64_t)a1);
  CFRelease(a1);
}

void readScheduler_CombineReads(__CFArray *a1, uint64_t a2, uint64_t a3, _OWORD *a4, CFIndex a5)
{
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(*(CFArrayRef *)(a3 + 48));
  if (Count >= 1)
  {
    v11 = Count;
    for (i = 0; i != v11; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 48), i);
      readScheduler_AddRequestToRead(a2, (uint64_t)ValueAtIndex);
    }
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a3 + 48));
  if (*(_BYTE *)(a3 + 112) && *(_BYTE *)(a3 + 113))
  {
    *(_BYTE *)(a3 + 113) = 0;
    FigAtomicDecrement32((unsigned int *)(*(_QWORD *)(a3 + 16) + 384));
  }
  *(_OWORD *)(a2 + 96) = *a4;
  *(_QWORD *)(a2 + 88) = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 392) * *(_QWORD *)a4;
  CFArrayRemoveValueAtIndex(a1, a5);
}

void readScheduler_CancelRequestApplierFunction(_DWORD *cf, uint64_t a2)
{
  cf[27] = -17785;
  readScheduler_HandleFailedRequest(a2, cf);
}

void readScheduler_RemoveMatchingRequestsFromReadArray(const __CFArray *a1, const __CFSet *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  CFArrayRef *ValueAtIndex;
  CFIndex v8;
  CFIndex v9;
  CFIndex v10;
  const void *v11;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v5 = Count;
    v6 = 0;
    do
    {
      ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v6);
      v8 = CFArrayGetCount(ValueAtIndex[6]);
      if (v8 >= 1)
      {
        v9 = v8;
        v10 = 0;
        do
        {
          v11 = CFArrayGetValueAtIndex(ValueAtIndex[6], v10);
          if (CFSetContainsValue(a2, v11))
          {
            CFArrayRemoveValueAtIndex(ValueAtIndex[6], v10);
            --v9;
          }
          else
          {
            ++v10;
          }
        }
        while (v10 < v9);
      }
      if (CFArrayGetCount(ValueAtIndex[6]))
      {
        ++v6;
      }
      else
      {
        CFArrayRemoveValueAtIndex(a1, v6);
        --v5;
      }
    }
    while (v6 < v5);
  }
}

void readScheduler_RemoveAndCollectMatchingReadsToExpediteFromReadArray(const __CFArray *a1, const __CFSet *a2, __CFArray *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  CFArrayRef *ValueAtIndex;
  CFIndex v10;
  CFIndex v11;
  const void *v12;
  CFIndex v13;
  const void *v14;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v7 = Count;
    v8 = 0;
    while (1)
    {
      ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v8);
      v10 = CFArrayGetCount(ValueAtIndex[6]);
      if (v10 < 1)
        goto LABEL_10;
      v11 = v10;
      v12 = CFArrayGetValueAtIndex(ValueAtIndex[6], 0);
      if (!CFSetContainsValue(a2, v12))
        break;
LABEL_5:
      CFArrayAppendValue(a3, ValueAtIndex);
      CFArrayRemoveValueAtIndex(a1, v8);
      --v7;
LABEL_11:
      if (v8 >= v7)
        return;
    }
    v13 = 1;
    while (v11 != v13)
    {
      v14 = CFArrayGetValueAtIndex(ValueAtIndex[6], v13++);
      if (CFSetContainsValue(a2, v14))
      {
        if (v13 - 1 < v11)
          goto LABEL_5;
        break;
      }
    }
LABEL_10:
    ++v8;
    goto LABEL_11;
  }
}

void readScheduler_ExpediteReadsArrayApplierFunction(uint64_t a1, uint64_t a2)
{
  readScheduler_IssueOneRead(a2, a1);
}

double readScheduler_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void readScheduler_Finalize(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  uint64_t i;
  _QWORD *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;

  v2 = a1[10];
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = a1[10];
    if (v3)
    {
      dispatch_release(v3);
      a1[10] = 0;
    }
  }
  for (i = 0; i != 32; i += 8)
  {
    v5 = &a1[i];
    FigCFWeakReferenceStore((id *)&a1[i + 19], 0);
    v6 = (const void *)a1[i + 16];
    if (v6)
    {
      CFRelease(v6);
      v5[16] = 0;
    }
    v7 = v5[15];
    if (v7)
    {
      dispatch_release(v7);
      v5[15] = 0;
    }
  }
  v8 = (const void *)a1[2];
  if (v8)
  {
    CFRelease(v8);
    a1[2] = 0;
  }
  v9 = (const void *)a1[3];
  if (v9)
  {
    CFRelease(v9);
    a1[3] = 0;
  }
  v10 = (const void *)a1[4];
  if (v10)
  {
    CFRelease(v10);
    a1[4] = 0;
  }
  v11 = (const void *)a1[5];
  if (v11)
  {
    CFRelease(v11);
    a1[5] = 0;
  }
  v12 = (const void *)a1[6];
  if (v12)
  {
    CFRelease(v12);
    a1[6] = 0;
  }
  v13 = (const void *)a1[14];
  if (v13)
  {
    CFRelease(v13);
    a1[14] = 0;
  }
  v14 = (const void *)a1[13];
  if (v14)
  {
    CFRelease(v14);
    a1[13] = 0;
  }
  v15 = a1[8];
  if (v15)
  {
    dispatch_release(v15);
    a1[8] = 0;
  }
  v16 = a1[9];
  if (v16)
  {
    dispatch_release(v16);
    a1[9] = 0;
  }
  v17 = a1[7];
  if (v17)
  {
    dispatch_release(v17);
    a1[7] = 0;
  }
}

__CFString *readScheduler_CopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  __CFString *v4;
  CFIndex v5;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = FigCFCopyCompactDescription(*(const __CFSet **)(a1 + 16));
  v5 = CFGetRetainCount((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigReadScheduler %p(%d) \"%s\": sched=%@ background=%@ inFlight=%@ batches=%@ inProg=%d info={%@}"), a1, v5, a1 + 400, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 380), v4);
  if (v4)
    CFRelease(v4);
  return Mutable;
}

CFTypeRef readScheduler_RemoveAndRetainRequestFromReadArray(const __CFArray *a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  CFArrayRef *ValueAtIndex;
  CFIndex v8;
  CFIndex v9;
  CFIndex v10;
  _QWORD *v11;
  CFTypeRef v12;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v6);
    v8 = CFArrayGetCount(ValueAtIndex[6]);
    if (v8 >= 1)
    {
      v9 = v8;
      v10 = 0;
      while (1)
      {
        v11 = CFArrayGetValueAtIndex(ValueAtIndex[6], v10);
        if (v11[4] == a2)
          break;
        if (v9 == ++v10)
          goto LABEL_9;
      }
      v12 = CFRetain(v11);
      CFArrayRemoveValueAtIndex(ValueAtIndex[6], v10);
      if (v12)
        break;
    }
LABEL_9:
    if (++v6 == v5)
      return 0;
  }
  if (!CFArrayGetCount(ValueAtIndex[6]))
    CFArrayRemoveValueAtIndex(a1, v6);
  return v12;
}

uint64_t readScheduler_RemoveAndCollectReadForRequestToExpediteFromReadArray(const __CFArray *a1, uint64_t a2, __CFSet *a3, __CFArray *a4)
{
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  CFArrayRef *ValueAtIndex;
  CFIndex v12;
  CFIndex v13;
  CFIndex v14;
  _QWORD *v15;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v9 = Count;
  v10 = 0;
  while (1)
  {
    ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v10);
    v12 = CFArrayGetCount(ValueAtIndex[6]);
    if (v12 >= 1)
      break;
LABEL_7:
    if (++v10 == v9)
      return 0;
  }
  v13 = v12;
  v14 = 0;
  while (1)
  {
    v15 = CFArrayGetValueAtIndex(ValueAtIndex[6], v14);
    if (v15[4] == a2)
      break;
    if (v13 == ++v14)
      goto LABEL_7;
  }
  CFSetAddValue(a3, v15);
  CFArrayAppendValue(a4, ValueAtIndex);
  CFArrayRemoveValueAtIndex(a1, v10);
  return 1;
}

void readScheduler_RemoveAndCollectClientRequestsFromReadArray(const __CFArray *a1, uint64_t a2, __CFSet *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  CFArrayRef *ValueAtIndex;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  _QWORD *v13;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v7 = Count;
    v8 = 0;
    do
    {
      ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v8);
      v10 = CFArrayGetCount(ValueAtIndex[6]);
      if (v10 >= 1)
      {
        v11 = v10;
        v12 = 0;
        do
        {
          v13 = CFArrayGetValueAtIndex(ValueAtIndex[6], v12);
          if (v13[3] == a2)
          {
            CFSetAddValue(a3, v13);
            CFArrayRemoveValueAtIndex(ValueAtIndex[6], v12);
            --v11;
          }
          else
          {
            ++v12;
          }
        }
        while (v12 < v11);
      }
      if (CFArrayGetCount(ValueAtIndex[6]))
      {
        ++v8;
      }
      else
      {
        CFArrayRemoveValueAtIndex(a1, v8);
        --v7;
      }
    }
    while (v8 < v7);
  }
}

void readScheduler_RemoveAndCollectClientReadsToExpediteFromReadArray(const __CFArray *a1, uint64_t a2, __CFSet *a3, __CFArray *a4)
{
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  CFArrayRef *ValueAtIndex;
  CFIndex v12;
  CFIndex v13;
  CFIndex v14;
  int v15;
  _QWORD *v16;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v9 = Count;
    v10 = 0;
    do
    {
      ValueAtIndex = (CFArrayRef *)CFArrayGetValueAtIndex(a1, v10);
      v12 = CFArrayGetCount(ValueAtIndex[6]);
      if (v12 < 1)
        goto LABEL_10;
      v13 = v12;
      v14 = 0;
      v15 = 0;
      do
      {
        v16 = CFArrayGetValueAtIndex(ValueAtIndex[6], v14);
        if (v16[3] == a2)
        {
          CFSetAddValue(a3, v16);
          v15 = 1;
        }
        ++v14;
      }
      while (v13 != v14);
      if (v15)
      {
        CFArrayAppendValue(a4, ValueAtIndex);
        CFArrayRemoveValueAtIndex(a1, v10);
        --v9;
      }
      else
      {
LABEL_10:
        ++v10;
      }
    }
    while (v10 < v9);
  }
}

uint64_t FigNTPClientGetTypeID()
{
  if (sRegisterFigNTPClientTypeOnce != -1)
    dispatch_once_f(&sRegisterFigNTPClientTypeOnce, 0, (dispatch_function_t)RegisterFigNTPClientIDType);
  return sFigNTPClientID;
}

uint64_t RegisterFigNTPClientIDType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigNTPClientID = result;
  return result;
}

uint64_t FigNTPClientCreate(uint64_t a1, uint64_t *a2)
{
  unsigned int v3;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  uint64_t Instance;
  uint64_t v10;
  uint64_t CFPreferenceOrOptionNumberWithDefault;
  NSObject *v12;
  uint64_t result;
  uint64_t v14;
  _QWORD block[6];
  int v16;
  os_log_type_t type;
  int v18[2];
  const char *v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigNTPTrace[1], CFSTR("figntp_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v3, 0, gFigNTPTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EE141F28, CFSTR("figntp_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EE141F20);
  if (dword_1EE141F28)
  {
    v18[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F20, 1, v18, &type);
    v5 = v18[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v7 = v5;
    else
      v7 = v5 & 0xFFFFFFFE;
    if (v7)
    {
      v18[1] = 136315138;
      v19 = "FigNTPClientCreate";
      v8 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v18[0];
    }
    else
    {
      v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F20, 1u, 1, v8, v8 != &v20, v5, 0, v6);
  }
  if (a2)
  {
    if (sRegisterFigNTPClientTypeOnce != -1)
      dispatch_once_f(&sRegisterFigNTPClientTypeOnce, 0, (dispatch_function_t)RegisterFigNTPClientIDType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v10 = Instance;
      *(_QWORD *)(Instance + 16) = 0;
      *(_QWORD *)(Instance + 24) = 0;
      *(_DWORD *)(Instance + 32) = 0;
      CFPreferenceOrOptionNumberWithDefault = (int)FigGetCFPreferenceOrOptionNumberWithDefault(0, CFSTR("ntp_timeout"), CFSTR("com.apple.coremedia"), 1);
      *(_DWORD *)(v10 + 80) = 0;
      *(_QWORD *)(v10 + 40) = FigDispatchQueueCreateWithPriority("com.apple.coremedia.figntpclient", 0, 0);
      *(_QWORD *)(v10 + 56) = FigDispatchQueueCreateWithPriority("com.apple.coremedia.figntpclient_dns", 0, 0);
      CFRetain((CFTypeRef)v10);
      v12 = *(NSObject **)(v10 + 40);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __FigNTPClientCreate_block_invoke;
      block[3] = &__block_descriptor_tmp_14;
      v16 = 5;
      block[4] = CFPreferenceOrOptionNumberWithDefault;
      block[5] = v10;
      dispatch_async(v12, block);
      result = 0;
      *a2 = v10;
      return result;
    }
    v14 = 4294951425;
  }
  else
  {
    v14 = 4294951426;
  }
  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

unint64_t figntp_gettime()
{
  unsigned int v0;
  uint64_t v1;
  timespec v3;

  v3.tv_sec = 0;
  v3.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC, &v3);
  v0 = sntp_datestamp_from_timespec(v3.tv_sec);
  return sntp_timestamp_from_datestamp(v0, v1);
}

uint64_t FigNTPGetTimeOfDay(uint64_t a1, _OWORD *a2)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2800000000;
  v10 = 0;
  v11 = 0;
  v3 = *(NSObject **)(a1 + 40);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __FigNTPGetTimeOfDay_block_invoke;
  v6[3] = &unk_1E28DB1F8;
  v6[5] = &v12;
  v6[6] = a1;
  v6[4] = &v7;
  dispatch_sync(v3, v6);
  if (a2)
    *a2 = *(_OWORD *)(v8 + 3);
  v4 = *((unsigned int *)v13 + 6);
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v12, 8);
  return v4;
}

unint64_t FigNTPTimestampFromTimeOfDayTime(CMTime *a1)
{
  Float64 Seconds;
  unsigned int v2;
  uint64_t v3;
  CMTime v5;

  v5 = *a1;
  Seconds = CMTimeGetSeconds(&v5);
  sntp_datestamp_from_double(Seconds + 2208988800.0);
  return sntp_timestamp_from_datestamp(v2, v3);
}

CMTime *FigTimeOfDayTimeFromNTPTimestamp@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  unint64_t v4;
  double v5;

  v3 = sntp_timestamp_to_datestamp(a1);
  v5 = sntp_datestamp_to_double(v3, v4);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  return CMTimeMake((CMTime *)a2, (uint64_t)((v5 + -2208988800.0) * 1000000.0), 1000000);
}

double figNTPClient_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 80) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void FigNTPClient_Finalize(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *(NSObject **)(a1 + 56);
  if (v2)
    dispatch_release(v2);
  v3 = *(NSObject **)(a1 + 40);
  if (v3)
    dispatch_release(v3);
}

CFStringRef FigNTPClient_CopyFormattingDesc(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("FigNTPClient"));
}

CFStringRef FigNTPClient_CopyDebugDesc(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("FigNTPClient"));
}

void figNTPClient_addressInfoCallBack(uint64_t a1, char a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFNumberRef UInt32;

  if (a4)
  {
    FigSignalErrorAt(4294951422, 0, 0, 0, 0, 0, 0);
  }
  else if (a1 && a6)
  {
    if ((a2 & 2) != 0 && *(_BYTE *)(a6 + 1) == 2)
    {
      UInt32 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_DWORD *)(a6 + 4));
      CFArrayAppendValue(*(CFMutableArrayRef *)(a8 + 72), UInt32);
      if (UInt32)
        CFRelease(UInt32);
      *(_BYTE *)(a8 + 64) = 1;
    }
    if ((a2 & 1) == 0)
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a8 + 48));
  }
}

void __figNTPClient_sntp_unicast_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  unsigned int Count;
  const __CFNumber *ValueAtIndex;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _OWORD v15[5];
  sockaddr v16;
  sockaddr v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 64))
  {
    v3 = *(const __CFArray **)(v2 + 72);
    if (v3)
    {
      Count = CFArrayGetCount(v3);
      v3 = *(const __CFArray **)(*(_QWORD *)(a1 + 40) + 72);
    }
    else
    {
      Count = 0;
    }
    ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v3, *(_DWORD *)(a1 + 80) % Count);
    *(_DWORD *)&v17.sa_len = 512;
    *(_DWORD *)&v17.sa_data[10] = 0;
    *(_QWORD *)&v17.sa_data[2] = FigCFNumberGetUInt64(ValueAtIndex);
    *(_WORD *)v17.sa_data = bswap32(*(unsigned __int16 *)(a1 + 84)) >> 16;
    v6 = socket(2, 2, 17);
    if (v6)
    {
      v7 = v6;
      if (*(_BYTE *)(a1 + 88)
        && (*(_QWORD *)&v16.sa_len = 2063598080, *(_QWORD *)&v16.sa_data[6] = 0, bind(v6, &v16, 0x10u)))
      {
        v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v9 = 3;
      }
      else
      {
        if (!connect(v7, &v17, 0x10u))
        {
          sntp_client_exchange(v7, (timeval *)(a1 + 48), *(uint64_t (**)(void))(a1 + 64), (uint64_t)v15);
          v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v11 = v15[4];
          v12 = v15[3];
          v13 = v15[2];
          v14 = v15[0];
          *(_OWORD *)(v10 + 40) = v15[1];
          *(_OWORD *)(v10 + 56) = v13;
          *(_OWORD *)(v10 + 72) = v12;
          *(_OWORD *)(v10 + 88) = v11;
          *(_OWORD *)(v10 + 24) = v14;
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 84) = *(_DWORD *)&v17.sa_data[2];
          goto LABEL_15;
        }
        v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v9 = 4;
      }
      *(_DWORD *)(v8 + 24) = v9;
LABEL_15:
      close(v7);
      goto LABEL_16;
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 2;
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
LABEL_16:
  DNSServiceRefDeallocate(*(DNSServiceRef *)(a1 + 72));
}

uint64_t FigSandboxRegistrationRemoteGetTypeID()
{
  if (sRegisterFigSandboxRegistrationRemoteTypeOnce != -1)
    dispatch_once_f(&sRegisterFigSandboxRegistrationRemoteTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationRemoteType);
  return sFigSandboxRegistrationRemoteID;
}

uint64_t RegisterFigSandboxRegistrationRemoteType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigSandboxRegistrationRemoteID = result;
  return result;
}

uint64_t FigSandboxRegistrationRemoteCreate(int a1, const char *a2, const void *a3, const void *a4, NSObject *a5, _QWORD *a6)
{
  const __CFAllocator *v12;
  _QWORD *Instance;
  uint64_t v14;
  CFTypeRef v15;
  size_t v16;
  CFDataRef v17;
  CFDataRef v18;
  uint64_t v19;
  const void *uint64;
  uint64_t v21;
  xpc_object_t xdict;
  int v24[2];

  xdict = 0;
  *(_QWORD *)v24 = 0;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (sRegisterFigSandboxRegistrationRemoteTypeOnce != -1)
    dispatch_once_f(&sRegisterFigSandboxRegistrationRemoteTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationRemoteType);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (!Instance)
    goto LABEL_17;
  v14 = remoteSandboxReg_copyRemoteClientForProcess(a1, Instance + 7);
  if ((_DWORD)v14)
    goto LABEL_18;
  Instance[2] = CFRetain(a3);
  v15 = CFRetain(a4);
  Instance[3] = a5;
  Instance[4] = v15;
  dispatch_retain(a5);
  v14 = FigXPCCreateBasicMessage(0x63726538u, 0, v24);
  if ((_DWORD)v14)
    goto LABEL_18;
  v16 = strlen(a2);
  v17 = CFDataCreate(v12, (const UInt8 *)a2, v16 + 1);
  if (!v17)
  {
LABEL_17:
    v14 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
LABEL_18:
    v21 = v14;
    goto LABEL_14;
  }
  v18 = v17;
  v19 = FigXPCMessageSetCFData(*(void **)v24, "ExtensionTokenData", v17);
  if ((_DWORD)v19)
    goto LABEL_19;
  if (FigIsItOKToLogURLs())
    FigXPCMessageSetCFString(*(void **)v24, "ExtensionPath", a3);
  v19 = FigXPCRemoteClientSendSyncMessageCreatingReply(Instance[7], *(uint64_t *)v24, &xdict);
  if ((_DWORD)v19)
  {
LABEL_19:
    v21 = v19;
  }
  else
  {
    uint64 = (const void *)xpc_dictionary_get_uint64(xdict, ".objectID");
    v21 = FigXPCRemoteClientAssociateObject(Instance[7], (uint64_t)Instance, uint64);
    if (!(_DWORD)v21)
    {
      Instance[5] = uint64;
      *a6 = Instance;
      Instance = 0;
    }
  }
  CFRelease(v18);
LABEL_14:
  FigXPCRelease(*(xpc_object_t *)v24);
  FigXPCRelease(xdict);
  if (Instance)
    CFRelease(Instance);
  return v21;
}

uint64_t remoteSandboxReg_copyRemoteClientForProcess(int a1, _QWORD *a2)
{
  uint64_t result;
  const void *v4;
  CFTypeRef v5;
  _QWORD v6[4];
  int v7;
  _QWORD block[4];
  int v9;

  if (a1 == 2)
  {
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __remoteSandboxReg_copyRemoteClientForProcess_block_invoke_2;
    v6[3] = &__block_descriptor_tmp_6_2;
    v7 = 2;
    if (remoteSandboxReg_copyRemoteClientForProcess_gCaptureSandboxRegRemoteClientSetupOnce != -1)
      dispatch_once(&remoteSandboxReg_copyRemoteClientForProcess_gCaptureSandboxRegRemoteClientSetupOnce, v6);
    result = remoteSandboxReg_copyRemoteClientForProcess_captureErr;
    if (!remoteSandboxReg_copyRemoteClientForProcess_captureErr)
    {
      v4 = (const void *)gCameraCaptureSandboxRegistrationRemoteClient;
      if (!gCameraCaptureSandboxRegistrationRemoteClient)
        goto LABEL_7;
      goto LABEL_12;
    }
  }
  else if (a1 == 1)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __remoteSandboxReg_copyRemoteClientForProcess_block_invoke;
    block[3] = &__block_descriptor_tmp_5_1;
    v9 = 1;
    if (remoteSandboxReg_copyRemoteClientForProcess_gPlaybackSandboxRegRemoteClientSetupOnce != -1)
      dispatch_once(&remoteSandboxReg_copyRemoteClientForProcess_gPlaybackSandboxRegRemoteClientSetupOnce, block);
    result = remoteSandboxReg_copyRemoteClientForProcess_playbackErr;
    if (!remoteSandboxReg_copyRemoteClientForProcess_playbackErr)
    {
      v4 = (const void *)gPlaybackSandboxRegistrationRemoteClient;
      if (!gPlaybackSandboxRegistrationRemoteClient)
      {
LABEL_7:
        v5 = 0;
LABEL_13:
        result = 0;
        *a2 = v5;
        return result;
      }
LABEL_12:
      v5 = CFRetain(v4);
      goto LABEL_13;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t FigSandboxRegistrationRemoteGetObjectID(uint64_t a1, _QWORD *a2)
{
  if (!a1 || !a2 || *(_BYTE *)(a1 + 48))
    return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)(a1 + 40);
  return 0;
}

double figSandboxRegistrationRemoteInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void figSandboxRegistrationRemoteFinalize(uint64_t a1)
{
  const void *v2;
  CFTypeRef v3;
  CFTypeRef v4;
  NSObject *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  NSObject *v10;
  _QWORD block[6];
  xpc_object_t v12;

  v12 = 0;
  if (*(_QWORD *)(a1 + 24))
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
    {
      if (*(_QWORD *)(a1 + 32))
      {
        v3 = CFRetain(v2);
        v4 = CFRetain(*(CFTypeRef *)(a1 + 32));
        v5 = *(NSObject **)(a1 + 24);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = __figSandboxRegistrationRemoteFinalize_block_invoke;
        block[3] = &__block_descriptor_tmp_15;
        block[4] = v4;
        block[5] = v3;
        dispatch_async(v5, block);
      }
    }
  }
  v6 = *(const void **)(a1 + 40);
  if (v6)
  {
    FigXPCRemoteClientDisassociateObject(*(_QWORD *)(a1 + 56), v6);
    if (!*(_BYTE *)(a1 + 48))
    {
      FigXPCCreateBasicMessage(0x646F6F6Du, *(_QWORD *)(a1 + 40), &v12);
      FigXPCRemoteClientSendSyncMessage(*(_QWORD *)(a1 + 56), (uint64_t)v12);
    }
  }
  v7 = *(const void **)(a1 + 56);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 56) = 0;
  }
  FigXPCRelease(v12);
  v8 = *(const void **)(a1 + 16);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v9 = *(const void **)(a1 + 32);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v10 = *(NSObject **)(a1 + 24);
  if (v10)
    dispatch_release(v10);
}

const __CFString *figSandboxRegistrationRemoteCopyFormattingDesc()
{
  return CFSTR("[FigSandboxRegistrationRemote]");
}

__CFString *figSandboxRegistrationRemoteCopyDebugDesc(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigSandboxRegistrationRemote %p> objectID %lld"), a1, a1[5]);
  return Mutable;
}

void __figSandboxRegistrationRemoteFinalize_block_invoke(uint64_t a1)
{
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), *(const void **)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t __remoteSandboxReg_copyRemoteClientForProcess_block_invoke(uint64_t a1)
{
  uint64_t result;

  if (FigRemote_ShouldConnectToMediaplaybackd())
    result = remoteSandboxReg_createRemoteClientForProcess(*(_DWORD *)(a1 + 32), &gPlaybackSandboxRegistrationRemoteClient);
  else
    result = remoteSandboxReg_copyRemoteClientForProcess(2, &gPlaybackSandboxRegistrationRemoteClient);
  remoteSandboxReg_copyRemoteClientForProcess_playbackErr = result;
  return result;
}

uint64_t remoteSandboxReg_createRemoteClientForProcess(int a1, _QWORD *a2)
{
  void (*v4)();
  int ShouldConnectToMediaplaybackd;
  const char *v6;
  const char *v7;
  _QWORD v9[8];

  if (a1 == 1)
  {
    v4 = remoteSandboxReg_PlaybackProcessDied;
  }
  else
  {
    if (a1 != 2)
      return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
    v4 = remoteSandboxReg_CameraCaptureProcessDied;
  }
  v9[0] = 1;
  v9[1] = remoteSandboxReg_DeadConnectionCallback;
  v9[2] = 0;
  v9[3] = 0;
  v9[4] = v4;
  memset(&v9[5], 0, 24);
  ShouldConnectToMediaplaybackd = FigRemote_ShouldConnectToMediaplaybackd();
  v6 = "com.apple.coremedia.mediaplaybackd.sandboxserver.xpc";
  if (a1 != 1)
    v6 = "com.apple.coremedia.sandboxserver.xpc";
  if (ShouldConnectToMediaplaybackd)
    v7 = v6;
  else
    v7 = "com.apple.coremedia.sandboxserver.xpc";
  return FigXPCRemoteClientCreate((uint64_t)v7, (uint64_t)v9, 0, a2);
}

uint64_t __remoteSandboxReg_copyRemoteClientForProcess_block_invoke_2(uint64_t a1)
{
  uint64_t result;

  result = remoteSandboxReg_createRemoteClientForProcess(*(_DWORD *)(a1 + 32), &gCameraCaptureSandboxRegistrationRemoteClient);
  remoteSandboxReg_copyRemoteClientForProcess_captureErr = result;
  return result;
}

void remoteSandboxReg_PlaybackProcessDied()
{
  fsbxpc_sandboxClientReset(1);
}

void remoteSandboxReg_CameraCaptureProcessDied()
{
  fsbxpc_sandboxClientReset(2);
}

uint64_t remoteSandboxReg_DeadConnectionCallback(uint64_t result)
{
  *(_BYTE *)(result + 48) = 1;
  return result;
}

uint64_t FigHALAudioStreamGetClassID()
{
  if (FigHALAudioStreamGetClassID_sRegisterFigHALAudioStreamClassOnce != -1)
    dispatch_once(&FigHALAudioStreamGetClassID_sRegisterFigHALAudioStreamClassOnce, &__block_literal_global_14);
  return FigHALAudioStreamGetClassID_sFigHALAudioStreamClassID;
}

uint64_t FigCaptionDataCreateMutableCopy(const __CFAllocator *a1, uint64_t a2, _QWORD *a3)
{
  __CFAttributedString *Mutable;
  uint64_t (*v6)(uint64_t);
  const __CFString *v7;
  const __CFAllocator *v8;
  __CFDictionary *v9;
  const __CFArray *v10;
  CFIndex v11;
  const void *ValueAtIndex;
  uint64_t CMBaseObject;
  uint64_t (*v14)(uint64_t, const void *, const __CFAllocator *, CFTypeRef *);
  uint64_t v15;
  const void *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *);
  CFStringRef v19;
  CFIndex v20;
  CFNumberRef v21;
  const __CFString *v22;
  CFIndex Length;
  CFIndex v24;
  uint64_t i;
  uint64_t (*v26)(uint64_t, uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *, CFRange *);
  uint64_t v27;
  uint64_t v28;
  _QWORD *ClassID;
  _QWORD *DerivedStorage;
  uint64_t v31;
  pthread_mutex_t *v32;
  _QWORD *v34;
  __CFDictionary *v35;
  CFIndex Count;
  const __CFString *theString;
  CFRange v39;
  CFTypeRef cf;
  CFStringRef attrName;
  uint64_t valuePtr;
  CFTypeRef value;
  CFArrayRef theArray;
  CFTypeRef v45;
  CFRange v46;

  v45 = 0;
  value = 0;
  theArray = 0;
  attrName = 0;
  valuePtr = 0;
  cf = 0;
  if (!a3)
  {
    v28 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    Mutable = 0;
    goto LABEL_49;
  }
  if (!a2)
  {
    v28 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v21 = 0;
    goto LABEL_64;
  }
  Mutable = CFAttributedStringCreateMutable(a1, 0);
  if (!Mutable)
  {
    v28 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    v21 = 0;
    goto LABEL_45;
  }
  v6 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(a2) + 16) + 8);
  if (v6)
    v7 = (const __CFString *)v6(a2);
  else
    v7 = &stru_1E28E82E0;
  v46.location = 0;
  v46.length = 0;
  theString = v7;
  CFAttributedStringReplaceString(Mutable, v46, v7);
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigThreadRunOnce(&fmcd_getCaptionPropertyKeys_sCaptionPropertyKeysOnce, (void (*)(void))fmcd_initializeCaptionPropertyKeys);
  v10 = (const __CFArray *)sCaptionPropertyKeys;
  if (CFArrayGetCount((CFArrayRef)sCaptionPropertyKeys))
  {
    v11 = 0;
    while (1)
    {
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      ValueAtIndex = CFArrayGetValueAtIndex(v10, v11);
      CMBaseObject = FigCaptionDataGetCMBaseObject(a2);
      v14 = *(uint64_t (**)(uint64_t, const void *, const __CFAllocator *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                                + 48);
      if (!v14)
        break;
      v15 = v14(CMBaseObject, ValueAtIndex, v8, &cf);
      if ((_DWORD)v15)
        goto LABEL_67;
      if (cf)
      {
        v16 = CFArrayGetValueAtIndex(v10, v11);
        CFDictionaryAddValue(v9, v16, cf);
      }
      if (++v11 >= (unint64_t)CFArrayGetCount(v10))
        goto LABEL_16;
    }
LABEL_36:
    v21 = 0;
    v28 = 4294954514;
    if (!v9)
      goto LABEL_45;
    goto LABEL_40;
  }
LABEL_16:
  v17 = FigCaptionDataGetCMBaseObject(a2);
  v18 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(v17) + 8) + 48);
  if (!v18)
    goto LABEL_36;
  v15 = v18(v17, CFSTR("StylePropertyKeysInUse"), v8, &theArray);
  if ((_DWORD)v15)
  {
LABEL_67:
    v28 = v15;
    v21 = 0;
    if (!v9)
      goto LABEL_45;
  }
  else
  {
    v34 = a3;
    v35 = v9;
    Count = CFArrayGetCount(theArray);
    if (Count)
    {
      v19 = 0;
      v20 = 0;
      v21 = 0;
      do
      {
        v22 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v20);
        Length = CFStringGetLength(theString);
        if (Length)
        {
          v24 = Length;
          for (i = 0; i != v24; i += v39.length)
          {
            v39.location = 0;
            v39.length = 0;
            if (value)
            {
              CFRelease(value);
              value = 0;
            }
            v26 = *(uint64_t (**)(uint64_t, uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *, CFRange *))(*(_QWORD *)(CMBaseObjectGetVTable(a2) + 16) + 24);
            if (!v26)
            {
              v28 = 4294954514;
              goto LABEL_39;
            }
            v27 = v26(a2, i, v22, a1, &value, &v39);
            if ((_DWORD)v27)
              goto LABEL_61;
            if (value)
            {
              CFAttributedStringSetAttribute(Mutable, v39, v22, value);
              if (v19)
              {
                CFRelease(v19);
                attrName = 0;
              }
              if (v21)
                CFRelease(v21);
              fmcd_createStylePropertyRunIDKey((uint64_t)v22, &attrName);
              v21 = CFNumberCreate(v8, kCFNumberCFIndexType, &valuePtr);
              if (!v21)
              {
                v27 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
                goto LABEL_61;
              }
              v19 = attrName;
              CFAttributedStringSetAttribute(Mutable, v39, attrName, v21);
              ++valuePtr;
            }
          }
        }
        ++v20;
      }
      while (v20 != Count);
    }
    else
    {
      v21 = 0;
    }
    ClassID = (_QWORD *)FigCaptionDataGetClassID();
    v27 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigCaptionDataVTable, ClassID, &v45);
    if (!(_DWORD)v27)
    {
      DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)v45);
      v31 = valuePtr;
      *DerivedStorage = Mutable;
      DerivedStorage[1] = v35;
      DerivedStorage[2] = v31;
      v32 = FigSimpleMutexCreate();
      DerivedStorage[3] = v32;
      if (v32)
      {
        v28 = 0;
        Mutable = 0;
        *v34 = v45;
        v45 = 0;
        goto LABEL_45;
      }
      v28 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_64:
      Mutable = 0;
      goto LABEL_45;
    }
LABEL_61:
    v28 = v27;
LABEL_39:
    v9 = v35;
    if (!v35)
      goto LABEL_45;
  }
LABEL_40:
  CFRelease(v9);
LABEL_45:
  if (cf)
    CFRelease(cf);
  if (v21)
    CFRelease(v21);
LABEL_49:
  if (attrName)
    CFRelease(attrName);
  if (value)
    CFRelease(value);
  if (theArray)
    CFRelease(theArray);
  if (Mutable)
    CFRelease(Mutable);
  if (v45)
    CFRelease(v45);
  return v28;
}

CFStringRef fmcd_createStylePropertyRunIDKey(uint64_t a1, CFStringRef *a2)
{
  CFStringRef result;

  result = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@%@"), a1, CFSTR("_InternalUseOnly_StyleRunID"));
  if (!result)
    return (CFStringRef)FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  *a2 = result;
  return result;
}

uint64_t FigCaptionDataCreateMutable(const __CFAllocator *a1, CFTypeRef *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  _QWORD *DerivedStorage;
  CFMutableAttributedStringRef Mutable;
  CFMutableDictionaryRef v8;
  pthread_mutex_t *v9;
  uint64_t v10;
  CFTypeRef cf;

  cf = 0;
  if (a2)
  {
    ClassID = (_QWORD *)FigCaptionDataGetClassID();
    v5 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigCaptionDataVTable, ClassID, &cf);
    if (!(_DWORD)v5)
    {
      if (cf)
        DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      else
        DerivedStorage = 0;
      Mutable = CFAttributedStringCreateMutable(a1, 0);
      *DerivedStorage = Mutable;
      if (Mutable)
      {
        v8 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        DerivedStorage[1] = v8;
        if (v8)
        {
          v9 = FigSimpleMutexCreate();
          DerivedStorage[3] = v9;
          if (v9)
          {
            v10 = 0;
            *a2 = cf;
            return v10;
          }
        }
      }
      v5 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    v10 = v5;
    if (cf)
      CFRelease(cf);
    return v10;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

CFArrayRef fmcd_initializeCaptionPropertyKeys()
{
  CFArrayRef result;
  const void *v1[14];

  v1[13] = *(const void **)MEMORY[0x1E0C80C00];
  v1[0] = CFSTR("Region");
  v1[1] = CFSTR("Animation");
  v1[2] = CFSTR("TextAlign");
  v1[3] = CFSTR("MultiRowAlign");
  v1[4] = CFSTR("SourceInformation");
  v1[5] = CFSTR("LinePadding");
  v1[6] = CFSTR("LineHeight");
  v1[7] = CFSTR("BackgroundColor");
  v1[8] = CFSTR("FillLineGap");
  v1[9] = CFSTR("Hidden");
  v1[10] = CFSTR("RubyAlign");
  v1[11] = CFSTR("RubyPosition");
  v1[12] = CFSTR("RubyReserve");
  result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1, 13, MEMORY[0x1E0C9B378]);
  sCaptionPropertyKeys = (uint64_t)result;
  return result;
}

BOOL fmcd_Equal(char *a1, char *a2)
{
  _QWORD *ClassID;
  _QWORD *v5;
  _BOOL8 result;
  uint64_t (*v7)(char *);
  const __CFString *v8;
  uint64_t (*v9)(char *);
  const __CFString *v10;

  if (a1 && (ClassID = (_QWORD *)FigCaptionDataGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID))
    || a2 && (v5 = (_QWORD *)FigCaptionDataGetClassID(), !CMBaseObjectIsMemberOfClass(a2, v5)))
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else if (a1 == a2)
  {
    return 1;
  }
  else
  {
    result = 0;
    if (a1 && a2)
    {
      v7 = *(uint64_t (**)(char *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 16) + 8);
      if (v7)
        v8 = (const __CFString *)v7(a1);
      else
        v8 = &stru_1E28E82E0;
      v9 = *(uint64_t (**)(char *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a2) + 16) + 8);
      if (v9)
        v10 = (const __CFString *)v9(a2);
      else
        v10 = &stru_1E28E82E0;
      return FigCFEqual(v8, v10) != 0;
    }
  }
  return result;
}

const __CFAllocator *fmcd_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;

  if (a1)
    DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  else
    DerivedStorage = 0;
  if (*(_QWORD *)DerivedStorage)
    CFRelease(*(CFTypeRef *)DerivedStorage);
  v2 = *(const void **)(DerivedStorage + 8);
  if (v2)
    CFRelease(v2);
  return FigSimpleMutexDestroy(*(_QWORD *)(DerivedStorage + 24));
}

__CFString *fmcd_CopyDebugDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFStringRef CaptionText;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CaptionText = fmcd_GetCaptionText((uint64_t)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("\tCaptionData: %p text<%@>"), a1, CaptionText);
  return Mutable;
}

uint64_t fmcd_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  uint64_t (*v9)(uint64_t);
  const __CFString *v10;
  void *v11;
  CFAttributedStringRef *v12;
  int v13;
  const __CFDictionary *v14;
  unint64_t v15;
  CFIndex v16;
  size_t v17;
  const void **v18;
  CFMutableSetRef Mutable;
  CFMutableSetRef v20;
  CFIndex Length;
  CFIndex v22;
  CFIndex v23;
  const __CFDictionary *Attributes;
  CFIndex Count;
  uint64_t v26;
  void *Value;
  uint64_t v29;
  CFRange v30;

  if (a1)
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    if (!a2)
      goto LABEL_40;
  }
  else
  {
    DerivedStorage = 0;
    if (!a2)
    {
LABEL_40:
      v29 = 4294954516;
      return FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
    }
  }
  if (!a4)
    goto LABEL_40;
  if (CFEqual(a2, CFSTR("Text")))
  {
    v9 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 8);
    if (v9)
    {
      v10 = (const __CFString *)v9(a1);
      if (!v10)
      {
        v11 = 0;
        goto LABEL_36;
      }
    }
    else
    {
      v10 = &stru_1E28E82E0;
    }
    v11 = (void *)CFRetain(v10);
    goto LABEL_36;
  }
  if (CFEqual(a2, CFSTR("StylePropertyKeysInUse")))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 24));
    if (a1)
      v12 = (CFAttributedStringRef *)CMBaseObjectGetDerivedStorage(a1);
    else
      v12 = 0;
    Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
    if (Mutable)
    {
      v20 = Mutable;
      Length = CFAttributedStringGetLength(*v12);
      if (Length)
      {
        v22 = Length;
        v23 = 0;
        do
        {
          v30.location = 0;
          v30.length = 0;
          Attributes = CFAttributedStringGetAttributes(*v12, v23, &v30);
          CFDictionaryApplyFunction(Attributes, (CFDictionaryApplierFunction)fmcd_collectKeys, v20);
          v23 = v30.length + v30.location;
        }
        while (v30.length + v30.location != v22);
      }
      Count = CFSetGetCount(v20);
      v11 = CFArrayCreateMutable(a3, Count, MEMORY[0x1E0C9B378]);
      if (v11)
      {
        CFSetApplyFunction(v20, (CFSetApplierFunction)fmcd_addKeyToArray, v11);
        v26 = 0;
      }
      else
      {
        v26 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      }
      CFRelease(v20);
    }
    else
    {
      v26 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      v11 = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 24));
    if ((_DWORD)v26)
    {
      if (v11)
        CFRelease(v11);
      return v26;
    }
LABEL_36:
    v26 = 0;
    *a4 = v11;
    return v26;
  }
  v13 = CFEqual(a2, CFSTR("CaptionPropertyKeysInUse"));
  v14 = *(const __CFDictionary **)(DerivedStorage + 8);
  if (!v13)
  {
    Value = (void *)CFDictionaryGetValue(v14, a2);
    v11 = Value;
    if (Value)
      CFRetain(Value);
    goto LABEL_36;
  }
  v15 = CFDictionaryGetCount(v14);
  v16 = v15;
  if (v15)
  {
    if (v15 >> 61)
      goto LABEL_38;
    v17 = 8 * v15;
    if (!(8 * v16))
      goto LABEL_38;
    v18 = (const void **)malloc_type_malloc(v17, 0xD1AAB5CuLL);
    if (!v18)
      goto LABEL_38;
  }
  else
  {
    v18 = 0;
  }
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(DerivedStorage + 8), v18, 0);
  v11 = CFArrayCreate(a3, v18, v16, MEMORY[0x1E0C9B378]);
  free(v18);
  if (v11)
    goto LABEL_36;
LABEL_38:
  v29 = 4294954510;
  return FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
}

uint64_t fmcd_SetProperty(uint64_t a1, const void *a2, void *a3)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  CFTypeID v8;
  uint64_t (*v9)(uint64_t, void *);
  uint64_t result;
  CFTypeID v11;
  CFTypeID TypeID;
  CFTypeID v13;
  CFTypeID v14;
  CFDictionaryRef *v15;
  CFTypeID v16;
  CFDictionaryRef *InitialValue;
  CFTypeID v18;
  CFDictionaryRef *v19;
  CFTypeID v20;
  CFDictionaryRef *v21;
  CFTypeID v22;
  CFDictionaryRef *v23;
  CFTypeID v24;
  CFDictionaryRef *v25;
  CFTypeID v26;
  CFDictionaryRef *v27;
  uint64_t v28;
  double v29;

  if (!a1)
    goto LABEL_63;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!DerivedStorage || !a2)
    goto LABEL_63;
  v7 = DerivedStorage;
  if (!CFEqual(a2, CFSTR("Text")))
  {
    if (CFEqual(a2, CFSTR("Region")))
    {
      if (!a3)
        goto LABEL_63;
      v11 = CFGetTypeID(a3);
      TypeID = FigCaptionRegionGetTypeID();
      goto LABEL_12;
    }
    if (CFEqual(a2, CFSTR("Animation")))
    {
      if (a3)
      {
        v13 = CFGetTypeID(a3);
        if (v13 != CFStringGetTypeID()
          || !CFEqual(a3, CFSTR("Animation_CharacterReveal")) && !CFEqual(a3, CFSTR("Animation_None")))
        {
          goto LABEL_63;
        }
      }
LABEL_13:
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v7 + 8), a2, a3);
      return 0;
    }
    if (CFEqual(a2, CFSTR("TextAlign")))
      goto LABEL_23;
    if (CFEqual(a2, CFSTR("LinePadding")))
    {
      v29 = 0.0;
      if (!a3)
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v16 = CFGetTypeID(a3);
      if (v16 != FigCaptionDynamicStyleGetTypeID())
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      if (!FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      InitialValue = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      v18 = CFGetTypeID(InitialValue);
      if (v18 != CFDictionaryGetTypeID())
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v19 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(v19, &v29);
      if ((_DWORD)result)
        return result;
      if (v29 < 0.0)
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      goto LABEL_13;
    }
    if (CFEqual(a2, CFSTR("LineHeight")))
    {
      if (!a3)
        goto LABEL_63;
      v20 = CFGetTypeID(a3);
      if (v20 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
        goto LABEL_63;
      v21 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
LABEL_40:
      v11 = CFGetTypeID(v21);
      TypeID = CFDictionaryGetTypeID();
      goto LABEL_12;
    }
    if (!CFEqual(a2, CFSTR("MultiRowAlign")))
    {
      if (CFEqual(a2, CFSTR("SourceInformation")))
      {
        if (!a3)
          goto LABEL_63;
        v21 = (CFDictionaryRef *)a3;
        goto LABEL_40;
      }
      if (CFEqual(a2, CFSTR("BackgroundColor")))
      {
        if (!a3)
          goto LABEL_63;
        v22 = CFGetTypeID(a3);
        if (v22 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
          goto LABEL_63;
        v23 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        v11 = CFGetTypeID(v23);
        TypeID = CGColorGetTypeID();
        goto LABEL_12;
      }
      if (CFEqual(a2, CFSTR("FillLineGap")) || CFEqual(a2, CFSTR("Hidden")))
      {
        if (!a3)
          goto LABEL_63;
        v24 = CFGetTypeID(a3);
        if (v24 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
          goto LABEL_63;
        v25 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        v11 = CFGetTypeID(v25);
        TypeID = CFBooleanGetTypeID();
        goto LABEL_12;
      }
      if (!CFEqual(a2, CFSTR("RubyAlign")) && !CFEqual(a2, CFSTR("RubyPosition")))
      {
        if (!CFEqual(a2, CFSTR("RubyReserve")))
        {
          v28 = 4294954512;
          return FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
        }
        if (!a3)
          goto LABEL_63;
        v26 = CFGetTypeID(a3);
        if (v26 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
          goto LABEL_63;
        v27 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        v11 = CFGetTypeID(v27);
        TypeID = FigCaptionRubyReserveGetTypeID();
LABEL_12:
        if (v11 == TypeID)
          goto LABEL_13;
LABEL_63:
        v28 = 4294954516;
        return FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
      }
    }
LABEL_23:
    if (!a3)
      goto LABEL_63;
    v14 = CFGetTypeID(a3);
    if (v14 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
      goto LABEL_63;
    v15 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    v11 = CFGetTypeID(v15);
    TypeID = CFStringGetTypeID();
    goto LABEL_12;
  }
  if (!a3)
    goto LABEL_63;
  v8 = CFGetTypeID(a3);
  if (v8 != CFStringGetTypeID())
    goto LABEL_63;
  v9 = *(uint64_t (**)(uint64_t, void *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 16);
  if (v9)
    return v9(a1, a3);
  else
    return 4294954514;
}

CFStringRef fmcd_GetCaptionText(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  CFStringRef String;
  uint64_t v5;

  if (a1 && (DerivedStorage = CMBaseObjectGetDerivedStorage(a1)) != 0)
  {
    v2 = DerivedStorage;
    if (*(_QWORD *)DerivedStorage)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 24));
      String = CFAttributedStringGetString(*(CFAttributedStringRef *)v2);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 24));
      return String;
    }
    v5 = 4294954512;
  }
  else
  {
    v5 = 4294954516;
  }
  FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  return 0;
}

void fmcd_collectKeys(const __CFString *a1, uint64_t a2, __CFSet *a3)
{
  if (!CFStringHasSuffix(a1, CFSTR("_InternalUseOnly_StyleRunID")))
    CFSetAddValue(a3, a1);
}

void fmcd_addKeyToArray(void *value, CFMutableArrayRef theArray)
{
  CFArrayAppendValue(theArray, value);
}

uint64_t fmcd_SetCaptionText(const void *a1, const __CFString *a2)
{
  uint64_t DerivedStorage;
  const void **v5;
  const __CFAllocator *v6;
  __CFAttributedString *Mutable;
  __CFAttributedString *v8;
  const void *v9;
  uint64_t v11;
  CFRange v12;

  if (!a1 || (DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1), !a2))
  {
    v11 = 4294954516;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  v5 = (const void **)DerivedStorage;
  v6 = CFGetAllocator(a1);
  Mutable = CFAttributedStringCreateMutable(v6, 0);
  if (!Mutable)
  {
    v11 = 4294954510;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  v8 = Mutable;
  v12.location = 0;
  v12.length = 0;
  CFAttributedStringReplaceString(Mutable, v12, a2);
  v9 = *v5;
  *v5 = v8;
  CFRetain(v8);
  if (v9)
    CFRelease(v9);
  CFRelease(v8);
  return 0;
}

uint64_t fmcd_CopyStylePropertyAtIndex(uint64_t a1, CFIndex a2, const __CFString *a3, uint64_t a4, _QWORD *a5, CFRange *a6)
{
  CFAttributedStringRef *DerivedStorage;
  CFAttributedStringRef *v11;
  const __CFString *String;
  const __CFAttributedString *v13;
  const __CFString *v14;
  CFTypeRef AttributeAndLongestEffectiveRange;
  CFRange v17;
  CFRange longestEffectiveRange;
  CFStringRef v19;
  CFRange v20;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DerivedStorage = (CFAttributedStringRef *)CMBaseObjectGetDerivedStorage(a1);
  longestEffectiveRange.length = 0;
  v19 = 0;
  v17.length = 0;
  longestEffectiveRange.location = 0;
  v17.location = 0;
  if (!DerivedStorage)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (a2 < 0)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v11 = DerivedStorage;
  String = CFAttributedStringGetString(*DerivedStorage);
  if (CFStringGetLength(String) <= a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  fmcd_createStylePropertyRunIDKey((uint64_t)a3, &v19);
  FigSimpleMutexLock((pthread_mutex_t *)v11[3]);
  v13 = *v11;
  v14 = v19;
  v20.length = CFAttributedStringGetLength(*v11);
  v20.location = 0;
  CFAttributedStringGetAttributeAndLongestEffectiveRange(v13, a2, v14, v20, &longestEffectiveRange);
  AttributeAndLongestEffectiveRange = CFAttributedStringGetAttributeAndLongestEffectiveRange(*v11, a2, a3, longestEffectiveRange, &v17);
  FigSimpleMutexUnlock((pthread_mutex_t *)v11[3]);
  if (AttributeAndLongestEffectiveRange)
    CFRetain(AttributeAndLongestEffectiveRange);
  if (a5)
  {
    *a5 = AttributeAndLongestEffectiveRange;
    AttributeAndLongestEffectiveRange = 0;
  }
  if (a6)
    *a6 = v17;
  if (AttributeAndLongestEffectiveRange)
    CFRelease(AttributeAndLongestEffectiveRange);
  if (v14)
    CFRelease(v14);
  return 0;
}

uint64_t fmcd_SetStylePropertyInRange(uint64_t a1, const __CFString *a2, const void *a3, CFIndex a4, CFIndex a5)
{
  CFAttributedStringRef *DerivedStorage;
  CFAttributedStringRef *v10;
  const __CFString *String;
  const __CFString *v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFStringRef v15;
  uint64_t v16;
  CFStringRef attrName;
  CFRange v19;
  CFRange v20;

  if (a1)
  {
    DerivedStorage = (CFAttributedStringRef *)CMBaseObjectGetDerivedStorage(a1);
    attrName = 0;
    if (DerivedStorage)
    {
      if (a2)
      {
        if (a3)
        {
          if ((a4 & 0x8000000000000000) == 0)
          {
            v10 = DerivedStorage;
            String = CFAttributedStringGetString(*DerivedStorage);
            if (a4 < CFStringGetLength(String) && ((a4 + a5) & 0x8000000000000000) == 0)
            {
              v12 = CFAttributedStringGetString(*v10);
              if (a4 + a5 <= CFStringGetLength(v12))
              {
                v19.location = a4;
                v19.length = a5;
                CFAttributedStringSetAttribute(*v10, v19, a2, a3);
                fmcd_createStylePropertyRunIDKey((uint64_t)a2, &attrName);
                v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, v10 + 2);
                if (v13)
                {
                  v14 = v13;
                  v15 = attrName;
                  v20.location = a4;
                  v20.length = a5;
                  CFAttributedStringSetAttribute(*v10, v20, attrName, v13);
                  v10[2] = (CFAttributedStringRef)((char *)v10[2] + 1);
                  CFRelease(v14);
                  v16 = 0;
                  if (!v15)
                    return v16;
                }
                else
                {
                  v16 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
                  v15 = attrName;
                  if (!attrName)
                    return v16;
                }
                CFRelease(v15);
                return v16;
              }
            }
          }
        }
      }
    }
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t fmcd_RemoveStylePropertyInRange(uint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4)
{
  CFAttributedStringRef *DerivedStorage;
  CFAttributedStringRef *v8;
  const __CFString *String;
  const __CFString *v10;
  CFStringRef v11;
  CFStringRef attrName;
  CFRange v14;
  CFRange v15;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DerivedStorage = (CFAttributedStringRef *)CMBaseObjectGetDerivedStorage(a1);
  attrName = 0;
  if (!DerivedStorage)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (a3 < 0)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v8 = DerivedStorage;
  String = CFAttributedStringGetString(*DerivedStorage);
  if (a3 >= CFStringGetLength(String))
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (a3 + a4 < 0)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v10 = CFAttributedStringGetString(*v8);
  if (a3 + a4 > CFStringGetLength(v10))
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v14.location = a3;
  v14.length = a4;
  CFAttributedStringRemoveAttribute(*v8, v14, a2);
  fmcd_createStylePropertyRunIDKey((uint64_t)a2, &attrName);
  v11 = attrName;
  v15.location = a3;
  v15.length = a4;
  CFAttributedStringRemoveAttribute(*v8, v15, attrName);
  if (v11)
    CFRelease(v11);
  return 0;
}

uint64_t FigVirtualCaptureCardRemoteCreate(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  _QWORD *ClassID;
  _QWORD *DerivedStorage;
  const void *uint64;
  uint64_t v8;
  xpc_object_t xdict;
  xpc_object_t v11;
  CFTypeRef cf;

  v11 = 0;
  cf = 0;
  xdict = 0;
  v4 = remoteVirtualCaptureCardClient_EnsureClientEstablished();
  if ((_DWORD)v4
    || (ClassID = (_QWORD *)FigVirtualCaptureCardGetClassID(),
        v4 = CMDerivedObjectCreate(a1, (uint64_t)&kRemoteFigVirtualCaptureCard_VTable, ClassID, &cf),
        (_DWORD)v4)
    || (DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf),
        v4 = FigXPCCreateBasicMessage(0x63726538u, 0, &v11),
        (_DWORD)v4)
    || (v4 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigVirtualCaptureCardRemoteClient, (uint64_t)v11, &xdict),
        (_DWORD)v4))
  {
    v8 = v4;
  }
  else
  {
    uint64 = (const void *)xpc_dictionary_get_uint64(xdict, ".objectID");
    *DerivedStorage = uint64;
    v8 = FigXPCRemoteClientAssociateObject(gFigVirtualCaptureCardRemoteClient, (uint64_t)cf, uint64);
    if (!(_DWORD)v8)
    {
      *a2 = cf;
      cf = 0;
      goto LABEL_7;
    }
  }
  if (cf)
    CFRelease(cf);
LABEL_7:
  FigXPCRelease(v11);
  FigXPCRelease(xdict);
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, v8, "FigVirtualCaptureCardRemoteCreate", 0);
  return v8;
}

BOOL FigVirtualCaptureCardRemoteSupported()
{
  return remoteVirtualCaptureCardClient_EnsureClientEstablished() == 0;
}

uint64_t remoteVirtualCaptureCardClient_EnsureClientEstablished()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __remoteVirtualCaptureCardClient_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E28DB4E0;
  block[4] = &v3;
  if (remoteVirtualCaptureCardClient_EnsureClientEstablished_gFigVirtualCaptureCardRemoteClientSetupOnce != -1)
    dispatch_once(&remoteVirtualCaptureCardClient_EnsureClientEstablished_gFigVirtualCaptureCardRemoteClientSetupOnce, block);
  if (gFigVirtualCaptureCardRemoteClient)
  {
    v0 = *((unsigned int *)v4 + 6);
  }
  else
  {
    v0 = FigSignalErrorAt(4294950083, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v4 + 6) = v0;
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t remoteVirtualCaptureCardClient_DeadConnectionCallback(uint64_t a1)
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage(a1);
  *(_BYTE *)(result + 9) = 1;
  return result;
}

uint64_t remoteFigVirtualCaptureCard_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v6 = 0;
  FigXPCRemoteClientDisassociateObject(gFigVirtualCaptureCardRemoteClient, *(const void **)DerivedStorage);
  if (*(_BYTE *)(DerivedStorage + 9))
  {
    v2 = 0;
    v3 = 0;
  }
  else
  {
    v4 = FigXPCCreateBasicMessage(0x64697370u, *(_QWORD *)DerivedStorage, &v6);
    v2 = v6;
    if ((_DWORD)v4)
    {
      v3 = v4;
    }
    else
    {
      v3 = FigXPCRemoteClientSendAsyncMessage(gFigVirtualCaptureCardRemoteClient, v6);
      v2 = v6;
    }
  }
  FigXPCRelease(v2);
  return FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, v3, "remoteFigVirtualCaptureCard_Finalize", 0);
}

__CFString *remoteFigVirtualCaptureCard_CopyDebugDescription(const void *a1)
{
  _QWORD *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;
  CFIndex v5;
  CFAllocatorRef v6;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = CFGetRetainCount(a1);
  v6 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigVirtualCaptureCardRemote %p retainCount: %ld allocator: %p objectID %016llx"), a1, v5, v6, *DerivedStorage);
  return Mutable;
}

uint64_t remoteFigVirtualCaptureCard_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t ObjectID;
  uint64_t v7;
  uint64_t v9;

  v9 = 0;
  if (a2 && a4)
  {
    *a4 = 0;
    ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v9);
    if (!(_DWORD)ObjectID)
      ObjectID = FigXPCSendStdCopyPropertyMessage(gFigVirtualCaptureCardRemoteClient, v9, a2, a4);
  }
  else
  {
    ObjectID = FigSignalErrorAt(4294950086, 0, 0, 0, 0, 0, 0);
  }
  v7 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_CopyProperty", 0);
  return v7;
}

uint64_t remoteFigVirtualCaptureCard_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t ObjectID;
  uint64_t v6;
  uint64_t v8;

  v8 = 0;
  if (a2)
  {
    ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v8);
    if (!(_DWORD)ObjectID)
      ObjectID = FigXPCSendStdSetPropertyMessage(gFigVirtualCaptureCardRemoteClient, v8, a2, a3);
  }
  else
  {
    ObjectID = FigSignalErrorAt(4294950086, 0, 0, 0, 0, 0, 0);
  }
  v6 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_SetProperty", 0);
  return v6;
}

uint64_t remoteVirtualCaptureCardClient_GetObjectID(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!a1 || *(_BYTE *)(DerivedStorage + 9) || *(_BYTE *)(DerivedStorage + 8))
    return FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)DerivedStorage;
  return 0;
}

uint64_t remoteFigVirtualCaptureCard_showSystemUserInterface(uint64_t a1)
{
  uint64_t ObjectID;
  uint64_t v2;
  xpc_object_t v4;
  uint64_t v5;

  v4 = 0;
  v5 = 0;
  ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v5);
  if (!(_DWORD)ObjectID)
  {
    ObjectID = FigXPCCreateBasicMessage(0x73686F77u, v5, &v4);
    if (!(_DWORD)ObjectID)
      ObjectID = FigXPCRemoteClientSendSyncMessage(gFigVirtualCaptureCardRemoteClient, (uint64_t)v4);
  }
  v2 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_showSystemUserInterface", 0);
  FigXPCRelease(v4);
  return v2;
}

uint64_t remoteFigVirtualCaptureCard_reserveForCaptureToFile(uint64_t a1, const __CFURL *a2)
{
  uint64_t ObjectID;
  uint64_t v4;
  xpc_object_t xdict;
  uint64_t v7;
  UInt8 buffer[1024];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  xdict = 0;
  v7 = 0;
  ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v7);
  if (!(_DWORD)ObjectID)
  {
    ObjectID = FigXPCCreateBasicMessage(0x72657376u, v7, &xdict);
    if (!(_DWORD)ObjectID)
    {
      if (CFURLGetFileSystemRepresentation(a2, 1u, buffer, 1024))
      {
        xpc_dictionary_set_string(xdict, "FileURL", (const char *)buffer);
        ObjectID = FigXPCRemoteClientSendSyncMessage(gFigVirtualCaptureCardRemoteClient, (uint64_t)xdict);
      }
      else
      {
        ObjectID = FigSignalErrorAt(4294950078, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  v4 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_reserveForCaptureToFile", 0);
  FigXPCRelease(xdict);
  return v4;
}

uint64_t remoteFigVirtualCaptureCard_saveCapture(uint64_t a1)
{
  uint64_t ObjectID;
  uint64_t v2;
  xpc_object_t v4;
  uint64_t v5;

  v4 = 0;
  v5 = 0;
  ObjectID = remoteVirtualCaptureCardClient_GetObjectID(a1, &v5);
  if (!(_DWORD)ObjectID)
  {
    ObjectID = FigXPCCreateBasicMessage(0x73617665u, v5, &v4);
    if (!(_DWORD)ObjectID)
      ObjectID = FigXPCRemoteClientSendSyncMessage(gFigVirtualCaptureCardRemoteClient, (uint64_t)v4);
  }
  v2 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigVirtualCaptureCardRemoteClient, ObjectID, "remoteFigVirtualCaptureCard_saveCapture", 0);
  FigXPCRelease(v4);
  return v2;
}

uint64_t FigAV1BridgeParsingStateGetTypeID()
{
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  return FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID;
}

uint64_t RegisterFigAV1BridgeParsingStateType(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigAV1Bridge_LocateSubsampleRangeForCBCS(OpaqueCMBlockBuffer *a1, uint64_t a2, size_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, _QWORD *a7, _QWORD *a8)
{
  return locateSubsampleRangeForCBCS(a1, a2, a3, a4, 0, a5, a6, a7, a8);
}

uint64_t locateSubsampleRangeForCBCS(CMBlockBufferRef theBuffer, uint64_t a2, size_t a3, uint64_t a4, int a5, _QWORD *a6, uint64_t a7, _QWORD *a8, _QWORD *a9)
{
  size_t DataLength;
  size_t v17;
  OpaqueCMBlockBuffer *v18;
  uint64_t DataPointer;
  uint64_t v20;
  size_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  void **v31;
  unsigned int v33;
  int v34;
  void *v35[2];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  CMBlockBufferRef blockBufferOut;
  size_t totalLengthOut;
  char *dataPointerOut;

  totalLengthOut = 0;
  dataPointerOut = 0;
  blockBufferOut = 0;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  *(_OWORD *)v35 = 0u;
  v36 = 0u;
  v34 = 0;
  if (!a4 || !theBuffer)
    goto LABEL_19;
  if (a6)
    *a6 = 0;
  if (a8)
    *a8 = 0;
  if (a9)
    *a9 = 0;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!DataLength)
    goto LABEL_19;
  v17 = DataLength;
  if (CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
  {
    v18 = (OpaqueCMBlockBuffer *)CFRetain(theBuffer);
    blockBufferOut = v18;
  }
  else
  {
    DataPointer = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theBuffer, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v17, 0, &blockBufferOut);
    if ((_DWORD)DataPointer)
    {
LABEL_20:
      v20 = DataPointer;
      goto LABEL_41;
    }
    v18 = blockBufferOut;
  }
  DataPointer = CMBlockBufferGetDataPointer(v18, 0, 0, &totalLengthOut, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_20;
  if (a3)
  {
    if (a3 + a2 <= totalLengthOut)
    {
      totalLengthOut = a3;
      dataPointerOut += a2;
      goto LABEL_21;
    }
    goto LABEL_19;
  }
  if (a2)
  {
LABEL_19:
    DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
LABEL_21:
  v35[0] = malloc_type_malloc(0x48uLL, 0x1070040C633F987uLL);
  if (!v35[0])
  {
LABEL_40:
    v20 = 4294954584;
    goto LABEL_41;
  }
  v21 = totalLengthOut;
  if (totalLengthOut)
  {
    v22 = 0;
    v23 = a4 + 3184;
    v24 = a4 + 16;
    v25 = a4 + 1504;
    v26 = dataPointerOut;
    while (1)
    {
      v33 = 0;
      v27 = FigAV1Bridge_parseOBU((uint64_t)v26, v21, v22, v23, v24, v25, (uint64_t)v35, -1, a5, &v33, &v34);
      if ((_DWORD)v27)
      {
        v20 = v27;
        goto LABEL_33;
      }
      v28 = totalLengthOut;
      if (totalLengthOut < v33)
        goto LABEL_29;
      if (!v33)
        break;
      if ((v34 & 8) == 0)
      {
        v26 = &dataPointerOut[v33];
        v22 += v33;
        v21 = totalLengthOut - v33;
        totalLengthOut = v21;
        dataPointerOut = v26;
        if (v28 != v33)
          continue;
      }
LABEL_29:
      v20 = 0;
      goto LABEL_33;
    }
    v20 = 4294954582;
LABEL_33:
    if ((_DWORD)v20)
      goto LABEL_41;
  }
  else
  {
    v20 = 0;
  }
  v29 = v36;
  if ((v36 - 1) <= 0x7FFFFFFD)
  {
    if (a6)
      *a6 = v36;
    v20 = 0;
    if (a8)
    {
      if (a9)
      {
        if (v29 < a7)
          goto LABEL_40;
        v20 = 0;
        v31 = &v35[a7];
        *a8 = v31[3];
        *a9 = v31[67];
      }
    }
  }
LABEL_41:
  free(v35[0]);
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v20;
}

uint64_t FigAV1Bridge_AdvanceParsingStateForFrame(OpaqueCMBlockBuffer *a1, uint64_t a2, size_t a3, uint64_t a4)
{
  return locateSubsampleRangeForCBCS(a1, a2, a3, a4, 1, 0, 0, 0, 0);
}

uint64_t FigAV1Bridge_GetProfileTierLevelFromAV1CodecConfigurationRecord(char *a1, unint64_t a2, _BYTE *a3, _BYTE *a4, _BYTE *a5)
{
  uint64_t v6;
  uint64_t Instance;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _OWORD v17[3];
  int v18;

  v18 = 0;
  memset(v17, 0, sizeof(v17));
  if (!a1 || a2 <= 3)
  {
    v6 = 4294954584;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v6 = 4294954583;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  v13 = (const void *)Instance;
  v16 = 0;
  v14 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v16, &v18, (unsigned int *)v17);
  if ((_DWORD)v14)
  {
    v15 = v14;
  }
  else if ((v18 & 0x20) != 0)
  {
    if (a3)
      *a3 = v17[0];
    if (a4)
      *a4 = BYTE4(v17[0]);
    v15 = 0;
    if (a5)
      *a5 = BYTE8(v17[0]);
  }
  else
  {
    v15 = 4294954584;
  }
  CFRelease(v13);
  return v15;
}

uint64_t FigAV1Bridge_parseav1c(char *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, _DWORD *a7, unsigned int *a8)
{
  int v8;
  unsigned int v9;
  unsigned int v11;
  int v12;
  int v13;

  if (!a1 || !a3 || !a4 || !a5 || !a8)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (a7)
    *a7 = 0;
  v8 = *a1;
  if ((v8 & 0x80000000) == 0)
    return 4294954582;
  if ((v8 & 0x7F) != 1)
    return 4294954579;
  v9 = a1[1];
  *a8 = v9 >> 5;
  if (v9 > 0x5F)
    return 4294954582;
  a8[1] = a1[1] & 0x1F;
  a8[2] = a1[2] >> 7;
  v11 = a1[2];
  a8[4] = (v11 >> 4) & 1;
  a8[5] = (a1[2] >> 3) & 1;
  a8[6] = (a1[2] >> 2) & 1;
  a8[7] = a1[2] & 3;
  if ((v11 & 0x40) != 0)
    v12 = 10;
  else
    v12 = 8;
  if ((v11 & 0x20) != 0)
    v13 = 12;
  else
    v13 = v12;
  a8[3] = v13;
  if (a7)
    *a7 |= 0x20u;
  if (a2 < 5)
    return 0;
  else
    return FigAV1Bridge_parseOBU((uint64_t)(a1 + 4), a2 - 4, 0, a3, a4, a5, 0, 2, 1, a6, a7);
}

uint64_t FigAV1Bridge_GetChromaFormatAndBitDepthsFromAV1CodecConfigurationRecord(char *a1, unint64_t a2, char *a3, _BYTE *a4, _BYTE *a5)
{
  uint64_t v6;
  uint64_t Instance;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  int v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int v21;

  v21 = 0;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  if (!a1 || a2 <= 3)
  {
    v6 = 4294954584;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v6 = 4294954583;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  v13 = (const void *)Instance;
  v17 = 0;
  v14 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v17, &v21, (unsigned int *)&v18);
  if ((_DWORD)v14)
  {
    v15 = v14;
  }
  else if ((v21 & 0x20) != 0)
  {
    if (a5)
      *a5 = BYTE12(v18);
    if (a4)
      *a4 = BYTE12(v19);
    if (a3)
    {
      if ((_DWORD)v19)
      {
        v16 = 111;
      }
      else if (DWORD2(v19))
      {
        v16 = 110;
      }
      else if (DWORD1(v19))
      {
        v16 = 100;
      }
      else
      {
        v16 = 0;
      }
      v15 = 0;
      *a3 = v16;
    }
    else
    {
      v15 = 0;
    }
  }
  else
  {
    v15 = 4294954584;
  }
  CFRelease(v13);
  return v15;
}

uint64_t FigAV1Bridge_GetColorRangeFromAV1CodecConfigurationRecord(char *a1, unint64_t a2, BOOL *a3)
{
  uint64_t v4;
  uint64_t Instance;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _OWORD v13[3];
  int v14;

  v14 = 0;
  memset(v13, 0, sizeof(v13));
  if (!a1 || a2 <= 3)
  {
    v4 = 4294954584;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v4 = 4294954583;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  v9 = (_DWORD *)Instance;
  v12 = 0;
  v10 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v12, &v14, (unsigned int *)v13);
  if ((_DWORD)v10)
  {
    v11 = v10;
  }
  else if ((v14 & 2) != 0)
  {
    v11 = 0;
    if (*a3)
      *a3 = v9[13] > 0;
  }
  else
  {
    v11 = 4294954584;
  }
  CFRelease(v9);
  return v11;
}

uint64_t FigAV1Bridge_CreateParsingStateFromAV1FormatDescription(const opaqueCMFormatDescription *a1, _QWORD *a2)
{
  const __CFDictionary *Extension;
  const __CFDictionary *v4;
  CFTypeID v5;
  const void *Value;
  const void *ValueAtIndex;
  CFTypeID v8;
  CFTypeID v9;
  uint64_t v11;

  if (a1 && a2)
  {
    Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(a1, CFSTR("SampleDescriptionExtensionAtoms"));
    if (Extension)
    {
      v4 = Extension;
      v5 = CFGetTypeID(Extension);
      if (v5 == CFDictionaryGetTypeID())
      {
        Value = CFDictionaryGetValue(v4, CFSTR("av1C"));
        if (Value)
        {
          ValueAtIndex = Value;
          v8 = CFGetTypeID(Value);
          if (v8 != CFArrayGetTypeID() || (ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0)) != 0)
          {
            v9 = CFGetTypeID(ValueAtIndex);
            if (v9 == CFDataGetTypeID())
              return FigAV1Bridge_CreateParsingStateFromAV1CodecConfigurationRecord((const __CFData *)ValueAtIndex, a2);
          }
        }
      }
    }
    v11 = 4294954581;
  }
  else
  {
    v11 = 4294954584;
  }
  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAV1Bridge_CreateParsingStateFromAV1CodecConfigurationRecord(const __CFData *a1, _QWORD *a2)
{
  unint64_t Length;
  uint64_t v5;
  unint64_t v7;
  uint64_t Instance;
  const void *v9;
  const UInt8 *BytePtr;
  uint64_t v11;
  int v12;
  int v13;

  v13 = 0;
  if (!a1 || !a2 || (Length = CFDataGetLength(a1), Length <= 3))
  {
    v5 = 4294954584;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v7 = Length;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v5 = 4294954583;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v9 = (const void *)Instance;
  BytePtr = CFDataGetBytePtr(a1);
  v12 = 0;
  if (FigAV1Bridge_parseOBU((uint64_t)BytePtr, v7, 0, (uint64_t)v9 + 3184, (uint64_t)v9 + 16, (uint64_t)v9 + 1504, 0, 2, 1, &v12, &v13))
  {
    v11 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    CFRelease(v9);
  }
  else
  {
    v11 = 0;
    *a2 = v9;
  }
  return v11;
}

uint64_t FigAV1Bridge_parseOBU(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, __int16 a8, int a9, _DWORD *a10, _DWORD *a11)
{
  uint64_t v12;
  uint64_t v14;
  uint64_t v19;
  int bits;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  _BOOL4 v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  BOOL v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  size_t v60;
  _BYTE *v61;
  __int16 v62;
  __int16 v63;
  char v64;
  char v65;
  uint64_t v66;
  uint64_t j;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  unsigned int v74;
  int v75;
  int v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  _DWORD *v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  int v87;
  char v88;
  unsigned int v89;
  int v90;
  int v91;
  unsigned int v92;
  int v93;
  int v94;
  _BOOL4 v95;
  int v96;
  int v97;
  uint64_t v98;
  int v99;
  int v100;
  _DWORD *v101;
  int v102;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  BOOL v107;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  BOOL v113;
  uint64_t v115;
  int v116;
  int v117;
  int v118;
  BOOL v119;
  uint64_t n;
  uint64_t v122;
  int v123;
  uint64_t v124;
  _DWORD *v125;
  int v126;
  int v127;
  BOOL v128;
  uint64_t v130;
  int v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  _BOOL4 v136;
  int v137;
  int v138;
  char *v139;
  char *v140;
  int v141;
  int v142;
  unsigned int v143;
  int v144;
  uint64_t v145;
  int v146;
  uint64_t v147;
  unsigned int v148;
  uint64_t v149;
  unsigned int v150;
  unsigned int v151;
  _QWORD *v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  char *v158;
  uint64_t v159;
  uint64_t v160;
  unint64_t v161;
  unsigned __int8 *v162;
  uint64_t v163;
  unint64_t v164;
  unint64_t v165;
  BOOL v166;
  int v167;
  uint64_t v168;
  uint64_t v169;
  unsigned __int8 *v170;
  int v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  char v176;
  int v177;
  _WORD *v178;
  _WORD *v179;
  void *v180;
  _WORD *v181;
  _WORD *v182;
  uint64_t i;
  void *v184;
  uint64_t ii;
  int v186;
  uint64_t v187;
  int v188;
  _BOOL4 v189;
  int v190;
  _BOOL4 v191;
  int v192;
  int v193;
  int v194;
  char v195;
  int v196;
  int v197;
  signed int v198;
  unsigned int v199;
  int v200;
  unsigned int v201;
  int v202;
  int v203;
  unsigned int v204;
  unsigned int v205;
  int v206;
  unsigned int v207;
  int v208;
  int v209;
  int v210;
  int v211;
  uint64_t v212;
  uint64_t v213;
  _WORD *v214;
  int v215;
  unsigned int v216;
  signed int v217;
  int v218;
  unsigned int v219;
  unsigned int v220;
  int v221;
  int v222;
  int v223;
  uint64_t v224;
  uint64_t v225;
  _WORD *v226;
  _DWORD *v227;
  char v228;
  int v229;
  int v230;
  int v231;
  int v232;
  uint64_t v233;
  int k;
  signed int v235;
  int v236;
  unsigned int v237;
  int v238;
  int v239;
  int v240;
  int v241;
  int v242;
  int v243;
  int v244;
  int v245;
  int v246;
  unsigned __int16 v247;
  int v248;
  __int16 v249;
  int v250;
  uint64_t v251;
  int v252;
  int v253;
  int v254;
  uint64_t v255;
  uint64_t v256;
  int v257;
  int v258;
  uint64_t v259;
  _DWORD *v260;
  int v261;
  int v262;
  int v263;
  int v264;
  int v265;
  int v266;
  int v267;
  int v268;
  int v269;
  int v270;
  int v271;
  uint64_t v272;
  _BOOL4 v273;
  uint64_t v274;
  uint64_t v275;
  int v276;
  int v277;
  _BOOL4 v278;
  int v279;
  int v280;
  int v281;
  uint64_t v282;
  int v283;
  int v284;
  int v285;
  int v286;
  int v287;
  uint64_t v288;
  int v289;
  int v290;
  int v291;
  int v292;
  uint64_t v293;
  int v294;
  int v295;
  int v296;
  int v297;
  uint64_t m;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  unsigned int v302;
  uint64_t v303;
  int *v304;
  uint64_t v305;
  char v306;
  int v307;
  int v308;
  char v309;
  int v310;
  int v311;
  int v312;
  int v313;
  uint64_t v314;
  unsigned int v315;
  int v316;
  int v317;
  int v318;
  int v319;
  int v320;
  int v321;
  int v322;
  int v323;
  int v324;
  char v325;
  char v326;
  int v327;
  uint64_t v328;
  uint64_t v329;
  unsigned __int8 v330;
  uint64_t v331;
  int v332;
  uint64_t v333;
  _DWORD *v334;
  int v335;
  int v336;
  int v337;
  int v338;
  unsigned int v339;
  uint64_t v340;
  _DWORD *v341;
  _DWORD *v342;
  int v343;
  int v344;
  int v345;
  int v346;
  unsigned int v347;
  int v348;
  unsigned int v349;
  unsigned int v350;
  int v351;
  int v352;
  int v353;
  int v354;
  int v355;
  int v356;
  int v357;
  int v358;
  int v359;
  uint64_t v360;
  int v361;
  int v362;
  int v363;
  _BOOL4 v364;
  int v365;
  int v366;
  int v367;
  int v368;
  int v369;
  _BYTE *v370;
  uint64_t v371;
  uint64_t v372;
  char v373;
  char v374;
  int v375;
  _BOOL4 v376;
  int v377;
  _BYTE *v378;
  uint64_t v379;
  int v380;
  uint64_t v381;
  char v382;
  char v383;
  _DWORD *v384;
  _OWORD *v385;
  __int128 v386;
  __int128 v387;
  __int128 v388;
  __int128 v389;
  __int128 v390;
  __int128 v391;
  __int128 v392;
  __int128 v393;
  __int128 v394;
  __int128 v395;
  unsigned int v396;
  int v397;
  int v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  char v402;
  char v403;
  int v404;
  uint64_t v405;
  uint64_t v406;
  _BYTE *v407;
  unsigned __int8 v408;
  void *v409;
  _BYTE *v410;
  int v411;
  char v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  void *v417;
  _DWORD *v418;
  BOOL v419;
  int v421;
  uint64_t v422;
  int v423;
  _DWORD *v424;
  int v425;
  _DWORD *v426;
  _DWORD *v427;
  uint64_t v428;
  uint64_t v429;
  int v430;
  int v431;
  unsigned int v432;
  int uleb128;
  int v434;
  uint64_t v435;
  __int128 v436;
  __int128 v437;
  __int128 v438;
  __int128 v439;
  __int128 v440;
  __int128 v441;
  __int128 v442;
  __int128 v443;
  __int128 v444;
  uint64_t v445;

  v445 = *MEMORY[0x1E0C80C00];
  v437 = 0u;
  v438 = 0u;
  v436 = 0u;
  if (a2 <= 2 || !a1 || (v12 = a4) == 0 || !a5 || (v14 = a6) == 0)
  {
    v19 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    v30 = 0;
    v432 = 0;
    uleb128 = 0;
    goto LABEL_814;
  }
  *((_QWORD *)&v437 + 1) = a1;
  *(_QWORD *)&v438 = a1;
  *((_QWORD *)&v438 + 1) = a1 + a2;
  v436 = 0uLL;
  LODWORD(v437) = 0;
  av1_get_bits((uint64_t)&v436, 1u);
  v19 = v436;
  if ((_DWORD)v436)
    return v19;
  bits = av1_get_bits((uint64_t)&v436, 4u);
  v19 = v436;
  if ((_DWORD)v436)
    return v19;
  v434 = bits;
  v430 = a3;
  v21 = av1_get_bits((uint64_t)&v436, 1u);
  v19 = v436;
  if ((_DWORD)v436)
    return v19;
  v22 = v21;
  v435 = a5;
  v23 = av1_get_bits((uint64_t)&v436, 1u);
  v19 = v436;
  if ((_DWORD)v436)
    return v19;
  v24 = v23;
  av1_get_bits((uint64_t)&v436, 1u);
  v19 = v436;
  if ((_DWORD)v436)
    return v19;
  if (v22)
  {
    v25 = av1_get_bits((uint64_t)&v436, 3u);
    v19 = v436;
    if ((_DWORD)v436)
      return v19;
    v26 = v25;
    v431 = av1_get_bits((uint64_t)&v436, 2u);
    v19 = v436;
    if ((_DWORD)v436)
      return v19;
    av1_get_bits((uint64_t)&v436, 3u);
    v19 = v436;
    if ((_DWORD)v436)
      return v19;
    if (v24)
      goto LABEL_16;
LABEL_19:
    uleb128 = ~v22 + a2;
    goto LABEL_20;
  }
  v26 = 0;
  v431 = 0;
  if (!v24)
    goto LABEL_19;
LABEL_16:
  uleb128 = av1_get_uleb128(&v436);
  v19 = v436;
  if ((_DWORD)v436)
    return v19;
LABEL_20:
  v27 = 8 * (DWORD2(v437) - v438) - v437;
  if ((v27 & 7) != 0)
    return 4294954582;
  v28 = v27 >> 3;
  if (v28 > a2)
    return 4294954582;
  v432 = 8 * (DWORD2(v437) - v438) - v437;
  if ((v434 - 3) <= 0xFFFFFFFD)
  {
    if (v22)
    {
      v29 = *(_DWORD *)(v12 + 6052);
      if (v29)
      {
        if ((((1 << (v431 + 8)) | (1 << v26)) & ~v29) != 0)
        {
          v30 = 0;
          v19 = 0;
          goto LABEL_814;
        }
      }
    }
  }
  v30 = 0;
  v19 = 0;
  switch(v434)
  {
    case 1:
      v31 = av1_get_bits((uint64_t)&v436, 3u);
      *(_DWORD *)v435 = v31;
      if (v31 > 1)
        goto LABEL_115;
      v32 = v31;
      v33 = av1_get_bits((uint64_t)&v436, 1u);
      *(_DWORD *)(v435 + 940) = v33;
      v34 = av1_get_bits((uint64_t)&v436, 1u);
      *(_DWORD *)(v435 + 944) = v34;
      if (v34)
      {
        if (!v33)
          return 4294954584;
        v428 = a7;
        *(_DWORD *)(v435 + 948) = 0;
        *(_DWORD *)(v435 + 968) = 0;
        *(_DWORD *)(v435 + 988) = 0;
        *(_DWORD *)(v435 + 40) = 1;
        *(_DWORD *)(v435 + 56) = 0;
        *(_DWORD *)(v435 + 44) = av1_get_bits((uint64_t)&v436, 3u);
        *(_DWORD *)(v435 + 48) = av1_get_bits((uint64_t)&v436, 2u);
        *(_QWORD *)(v435 + 64) = 0;
        *(_DWORD *)(v435 + 60) = 0;
        goto LABEL_665;
      }
      v72 = av1_get_bits((uint64_t)&v436, 1u);
      *(_DWORD *)(v435 + 948) = v72;
      if (!v72)
      {
        v428 = a7;
        *(_DWORD *)(v435 + 968) = 0;
        v175 = v435;
        v176 = 1;
        goto LABEL_648;
      }
      *(_DWORD *)(v435 + 952) = av1_get_bits((uint64_t)&v436, 0x20u);
      *(_DWORD *)(v435 + 956) = av1_get_bits((uint64_t)&v436, 0x20u);
      v73 = av1_get_bits((uint64_t)&v436, 1u);
      *(_DWORD *)(v435 + 960) = v73;
      if (!v73)
        goto LABEL_646;
      v74 = 0;
      while (!av1_get_bits((uint64_t)&v436, 1u))
      {
        if (++v74 == 32)
          goto LABEL_115;
      }
      if (!v74)
      {
        v246 = 0;
        goto LABEL_644;
      }
      v246 = av1_get_bits((uint64_t)&v436, v74) + ~(-1 << v74);
      if (v246 != -1)
      {
LABEL_644:
        v19 = v436;
        if ((_DWORD)v436)
          return v19;
        *(_DWORD *)(v435 + 964) = v246 + 1;
LABEL_646:
        v175 = v435;
        v176 = 1;
        v337 = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v435 + 968) = v337;
        v428 = a7;
        if (v337)
        {
          *(_DWORD *)(v435 + 972) = av1_get_bits((uint64_t)&v436, 5u) + 1;
          *(_DWORD *)(v435 + 976) = av1_get_bits((uint64_t)&v436, 0x20u);
          *(_DWORD *)(v435 + 980) = av1_get_bits((uint64_t)&v436, 5u) + 1;
          v176 = 0;
          *(_DWORD *)(v435 + 984) = av1_get_bits((uint64_t)&v436, 5u) + 1;
        }
LABEL_648:
        v338 = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v175 + 988) = v338;
        v339 = av1_get_bits((uint64_t)&v436, 5u);
        v340 = v339 + 1;
        *(_DWORD *)(v175 + 40) = v340;
        if (v339 <= 0x7FFFFFFE)
        {
          v341 = (_DWORD *)(v435 + 68);
          v342 = (_DWORD *)(v435 + 1108);
          while (1)
          {
            v343 = av1_get_bits((uint64_t)&v436, 0xCu);
            *(v341 - 3) = v343;
            if (v343)
            {
              if (!(_BYTE)v343 || (v343 & 0xF00) == 0)
                break;
            }
            v344 = av1_get_bits((uint64_t)&v436, 3u) + 2;
            *(v341 - 6) = v344;
            *(v341 - 5) = av1_get_bits((uint64_t)&v436, 2u);
            if (v344 < 4)
              v345 = 0;
            else
              v345 = av1_get_bits((uint64_t)&v436, 1u);
            *(v341 - 2) = v345;
            if ((v176 & 1) != 0)
            {
              *(v341 - 1) = 0;
            }
            else
            {
              v346 = av1_get_bits((uint64_t)&v436, 1u);
              *(v341 - 1) = v346 != 0;
              if (v346)
              {
                v347 = *(_DWORD *)(v435 + 972);
                *(v342 - 2) = av1_get_bits((uint64_t)&v436, v347);
                *(v342 - 1) = av1_get_bits((uint64_t)&v436, v347);
                *v342 = av1_get_bits((uint64_t)&v436, 1u);
              }
            }
            if (v338)
            {
              v348 = av1_get_bits((uint64_t)&v436, 1u);
              *v341 = v348 != 0;
              if (v348)
                *(v341 - 4) = av1_get_bits((uint64_t)&v436, 4u) + 1;
            }
            else
            {
              *v341 = 0;
            }
            v341 += 7;
            v342 += 3;
            if (!--v340)
              goto LABEL_665;
          }
LABEL_755:
          v149 = check_for_overrun(&v436, v432, uleb128);
          if ((_DWORD)v149)
            return v149;
          *(_QWORD *)(v12 + 3312) = v435;
          if (v437 <= 7)
            v19 = 0;
          else
            v19 = 4294954584;
          v30 = 2;
          a7 = v428;
          goto LABEL_810;
        }
LABEL_665:
        v349 = av1_get_bits((uint64_t)&v436, 4u) + 1;
        *(_DWORD *)(v435 + 992) = v349;
        v350 = av1_get_bits((uint64_t)&v436, 4u) + 1;
        *(_DWORD *)(v435 + 996) = v350;
        *(_DWORD *)(v435 + 4) = av1_get_bits((uint64_t)&v436, v349) + 1;
        *(_DWORD *)(v435 + 8) = av1_get_bits((uint64_t)&v436, v350) + 1;
        if (v34)
        {
          *(_DWORD *)(v435 + 1000) = 0;
        }
        else
        {
          v351 = av1_get_bits((uint64_t)&v436, 1u);
          *(_DWORD *)(v435 + 1000) = v351;
          if (v351)
          {
            v352 = av1_get_bits((uint64_t)&v436, 4u);
            *(_DWORD *)(v435 + 1004) = v352 + 2;
            *(_DWORD *)(v435 + 1008) = v352 + av1_get_bits((uint64_t)&v436, 3u) + 3;
          }
        }
        *(_DWORD *)(v435 + 1012) = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v435 + 1016) = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v435 + 1020) = av1_get_bits((uint64_t)&v436, 1u);
        if (v34)
        {
          *(_QWORD *)(v435 + 1040) = 0;
          *(_OWORD *)(v435 + 1024) = 0u;
          *(_QWORD *)(v435 + 1048) = 0x200000000;
          *(_QWORD *)(v435 + 1056) = 2;
          goto LABEL_682;
        }
        *(_DWORD *)(v435 + 1024) = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v435 + 1028) = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v435 + 1032) = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v435 + 1036) = av1_get_bits((uint64_t)&v436, 1u);
        v353 = av1_get_bits((uint64_t)&v436, 1u);
        v354 = v353;
        *(_DWORD *)(v435 + 1040) = v353;
        if (v353)
        {
          *(_DWORD *)(v435 + 1044) = av1_get_bits((uint64_t)&v436, 1u);
          v353 = av1_get_bits((uint64_t)&v436, 1u);
        }
        else
        {
          *(_DWORD *)(v435 + 1044) = 0;
          *(_DWORD *)(v435 + 1060) = 0;
        }
        *(_DWORD *)(v435 + 1048) = v353;
        if (av1_get_bits((uint64_t)&v436, 1u))
        {
          *(_DWORD *)(v435 + 1052) = 2;
        }
        else
        {
          v355 = av1_get_bits((uint64_t)&v436, 1u);
          *(_DWORD *)(v435 + 1052) = v355;
          if (!v355)
            goto LABEL_678;
        }
        if (!av1_get_bits((uint64_t)&v436, 1u))
        {
          v356 = av1_get_bits((uint64_t)&v436, 1u);
LABEL_680:
          *(_DWORD *)(v435 + 1056) = v356;
          if (v354)
            *(_DWORD *)(v435 + 1060) = av1_get_bits((uint64_t)&v436, 3u) + 1;
LABEL_682:
          *(_DWORD *)(v435 + 1064) = av1_get_bits((uint64_t)&v436, 1u);
          *(_DWORD *)(v435 + 1068) = av1_get_bits((uint64_t)&v436, 1u);
          *(_DWORD *)(v435 + 1072) = av1_get_bits((uint64_t)&v436, 1u);
          *(_DWORD *)(v435 + 32) = av1_get_bits((uint64_t)&v436, 1u);
          if (v32 == 1)
            v357 = 0;
          else
            v357 = av1_get_bits((uint64_t)&v436, 1u);
          *(_DWORD *)(v435 + 1084) = v357;
          v358 = av1_get_bits((uint64_t)&v436, 1u);
          *(_DWORD *)(v435 + 1088) = v358;
          if (v358)
          {
            v359 = av1_get_bits((uint64_t)&v436, 8u);
            *(_DWORD *)(v435 + 16) = v359;
            v360 = v435;
            v361 = av1_get_bits((uint64_t)&v436, 8u);
            *(_DWORD *)(v435 + 20) = v361;
            v362 = av1_get_bits((uint64_t)&v436, 8u);
            *(_DWORD *)(v435 + 24) = v362;
            if (!v357)
            {
              if (v359 == 1 && v361 == 13 && !v362)
              {
                *(_DWORD *)(v435 + 12) = 3;
                *(_QWORD *)(v435 + 1076) = 0;
                *(_DWORD *)(v435 + 36) = 1;
                if (v32 != 1)
                  return 4294954584;
                goto LABEL_753;
              }
LABEL_694:
              *(_DWORD *)(v360 + 36) = av1_get_bits((uint64_t)&v436, 1u);
              if (v32)
              {
                if (v32 == 1)
                {
                  v365 = 0;
                  *(_DWORD *)(v360 + 12) = 3;
                  *(_QWORD *)(v360 + 1076) = 0;
LABEL_752:
                  *(_DWORD *)(v360 + 28) = v365;
LABEL_753:
                  v364 = av1_get_bits((uint64_t)&v436, 1u) != 0;
                  goto LABEL_754;
                }
                if (*(_DWORD *)(v360 + 1076) != 1 || *(_DWORD *)(v360 + 1080) != 1)
                {
                  v365 = 0;
                  goto LABEL_752;
                }
              }
              else
              {
                *(_DWORD *)(v360 + 12) = 1;
                *(_QWORD *)(v360 + 1076) = 0x100000001;
              }
              v365 = av1_get_bits((uint64_t)&v436, 2u);
              goto LABEL_752;
            }
          }
          else
          {
            *(_QWORD *)(v435 + 16) = 0x200000002;
            *(_DWORD *)(v435 + 24) = 2;
            v360 = v435;
            if (!v357)
              goto LABEL_694;
          }
          v363 = av1_get_bits((uint64_t)&v436, 1u);
          v364 = 0;
          *(_DWORD *)(v360 + 36) = v363;
          *(_DWORD *)(v360 + 12) = 0;
          *(_QWORD *)(v360 + 1076) = 0x100000001;
          *(_DWORD *)(v360 + 28) = 0;
LABEL_754:
          *(_DWORD *)(v360 + 1092) = v364;
          *(_DWORD *)(v360 + 1096) = av1_get_bits((uint64_t)&v436, 1u);
          av1_get_bits((uint64_t)&v436, 1u);
          goto LABEL_755;
        }
LABEL_678:
        v356 = 2;
        goto LABEL_680;
      }
LABEL_115:
      v428 = a7;
      v19 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      if (!(_DWORD)v19)
        goto LABEL_755;
      return v19;
    case 2:
    case 15:
      goto LABEL_810;
    case 3:
    case 6:
      if ((a8 & 4) != 0)
        goto LABEL_42;
      goto LABEL_39;
    case 4:
      v14 = *(_QWORD *)(v12 + 3328);
      if (!v14)
        return 4294954584;
      v30 = 0;
      goto LABEL_36;
    case 5:
      if ((a8 & 0x10) == 0)
      {
LABEL_39:
        v30 = 0;
        v19 = 0;
        goto LABEL_810;
      }
      v48 = v28;
      v49 = a7;
      v440 = v437;
      v441 = v438;
      v439 = v436;
      v50 = DWORD2(v437);
      v51 = v438;
      v52 = v437;
      v53 = av1_get_uleb128(&v439);
      v19 = v439;
      if ((_DWORD)v439)
        goto LABEL_800;
      v54 = uleb128 - ((8 * (v50 - v51) - v52 - v432) >> 3);
      if ((v54 + v48) <= a2)
      {
        a7 = v49;
        if (v54 >= 1)
        {
          while (!*(_BYTE *)(a1 + (v48 - 1 + v54)))
          {
            v55 = __OFSUB__(v54--, 1);
            if ((v54 < 0) ^ v55 | (v54 == 0))
            {
              v54 = 0;
              break;
            }
          }
        }
        switch(v53)
        {
          case 1:
            if (v54 <= 5)
              goto LABEL_801;
            v442 = v439;
            v443 = v440;
            v444 = v441;
            v178 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
            *(_QWORD *)(v12 + 3344) = v178;
            if (!v178)
              goto LABEL_808;
            v179 = v178;
            *v178 = av1_get_bits((uint64_t)&v442, 0x10u);
            v179[1] = av1_get_bits((uint64_t)&v442, 0x10u);
            if (!check_for_overrun(&v442, v432, uleb128))
            {
              if ((a8 & 0x100) == 0)
              {
                v180 = *(void **)(v12 + 3344);
                if (v180)
                {
                  *(_QWORD *)(v12 + 3344) = 0;
                  free(v180);
                }
              }
              v19 = 0;
              v68 = 256;
              goto LABEL_809;
            }
            v417 = *(void **)(v12 + 3344);
            if (!v417)
              goto LABEL_808;
            *(_QWORD *)(v12 + 3344) = 0;
            break;
          case 2:
            if (v54 <= 25)
              goto LABEL_801;
            v442 = v439;
            v443 = v440;
            v444 = v441;
            v181 = malloc_type_malloc(0x18uLL, 0x1000040504FFAC1uLL);
            *(_QWORD *)(v12 + 3360) = v181;
            if (!v181)
              goto LABEL_808;
            v182 = v181;
            for (i = 0; i != 6; i += 2)
            {
              v182[i] = av1_get_bits((uint64_t)&v442, 0x10u);
              v182[i + 1] = av1_get_bits((uint64_t)&v442, 0x10u);
            }
            v182[6] = av1_get_bits((uint64_t)&v442, 0x10u);
            v182[7] = av1_get_bits((uint64_t)&v442, 0x10u);
            *((_DWORD *)v182 + 4) = av1_get_bits((uint64_t)&v442, 0x20u);
            *((_DWORD *)v182 + 5) = av1_get_bits((uint64_t)&v442, 0x20u);
            if (!check_for_overrun(&v442, v432, uleb128))
            {
              a7 = v49;
              if ((a8 & 0x200) == 0)
              {
                v184 = *(void **)(v12 + 3360);
                if (v184)
                {
                  *(_QWORD *)(v12 + 3360) = 0;
                  free(v184);
                }
              }
              v19 = 0;
              v68 = 512;
              goto LABEL_809;
            }
            v417 = *(void **)(v12 + 3360);
            a7 = v49;
            if (!v417)
              goto LABEL_808;
            *(_QWORD *)(v12 + 3360) = 0;
            break;
          case 4:
            if (v54 > 7)
            {
              v56 = av1_get_bits((uint64_t)&v439, 8u);
              *(_BYTE *)(v12 + 3376) = v56;
              if (v56 == -1)
                *(_BYTE *)(v12 + 3377) = av1_get_bits((uint64_t)&v439, 8u);
              v57 = check_for_overrun(&v439, v432, uleb128);
              if (!(_DWORD)v57)
              {
                if ((a8 & 0x40) == 0)
                {
                  if ((a8 & 0x80) != 0)
                  {
                    v442 = v439;
                    v443 = v440;
                    v444 = v441;
                    if (*(unsigned __int8 *)(v12 + 3376) == 181)
                    {
                      v58 = v12;
                      v59 = uleb128 - ((8 * (DWORD2(v443) - (_DWORD)v444) - (v443 + v432)) >> 3);
                      if (v59 - 512 >= 0xFFFFFE07)
                      {
                        v60 = v59 + 1;
                        v61 = malloc_type_malloc(v60, 0x127CE23AuLL);
                        *(_QWORD *)(v58 + 3400) = v61;
                        if (v61)
                        {
                          *v61 = *(_BYTE *)(v58 + 3376);
                          v62 = av1_get_bits((uint64_t)&v442, 0x10u);
                          *(_WORD *)(v58 + 3378) = v62;
                          *(_BYTE *)(*(_QWORD *)(v58 + 3400) + 1) = HIBYTE(v62);
                          *(_BYTE *)(*(_QWORD *)(v58 + 3400) + 2) = *(_BYTE *)(v58 + 3378);
                          v63 = av1_get_bits((uint64_t)&v442, 0x10u);
                          *(_WORD *)(v58 + 3380) = v63;
                          *(_BYTE *)(*(_QWORD *)(v58 + 3400) + 3) = HIBYTE(v63);
                          *(_BYTE *)(*(_QWORD *)(v58 + 3400) + 4) = *(_BYTE *)(v58 + 3380);
                          if (*(_WORD *)(v58 + 3378) == 60 && *(_WORD *)(v58 + 3380) == 1)
                          {
                            v64 = av1_get_bits((uint64_t)&v442, 8u);
                            *(_BYTE *)(*(_QWORD *)(v58 + 3400) + 5) = v64;
                            if (v64 == 4
                              && (v65 = av1_get_bits((uint64_t)&v442, 8u),
                                  *(_BYTE *)(*(_QWORD *)(v58 + 3400) + 6) = v65,
                                  v65 == 1))
                            {
                              *(_BYTE *)(*(_QWORD *)(v58 + 3400) + 7) = av1_get_bits((uint64_t)&v442, 8u);
                              v66 = 4294954579;
                              if ((*(_BYTE *)(*(_QWORD *)(v58 + 3400) + 7) & 0xC0) == 0x40 && v60 >= 9)
                              {
                                for (j = 8; j != v60; ++j)
                                  *(_BYTE *)(*(_QWORD *)(v58 + 3400) + j) = av1_get_bits((uint64_t)&v442, 8u);
                                v19 = check_for_overrun(&v442, v432, uleb128);
                                if (!(_DWORD)v19)
                                {
                                  *(_QWORD *)(v58 + 3384) = v60;
                                  v12 = v58;
                                  v68 = 128;
                                  a7 = v49;
LABEL_809:
                                  v30 = v68 | 0x10;
                                  goto LABEL_810;
                                }
                                goto LABEL_831;
                              }
                            }
                            else
                            {
                              v66 = 4294954579;
                            }
LABEL_830:
                            v19 = FigSignalErrorAt(v66, 0, 0, 0, 0, 0, 0);
LABEL_831:
                            v12 = v58;
                            goto LABEL_775;
                          }
                          v19 = 0;
                        }
                        else
                        {
                          v19 = 4294954584;
                        }
                        v12 = v58;
LABEL_775:
                        a7 = v49;
                        goto LABEL_776;
                      }
                      v66 = 4294954584;
                      goto LABEL_830;
                    }
                    goto LABEL_423;
                  }
LABEL_808:
                  v68 = 0;
                  v19 = 0;
                  goto LABEL_809;
                }
                v443 = v440;
                v444 = v441;
                v442 = v439;
                if (uleb128 - ((8 * (DWORD2(v440) - (_DWORD)v441) - (v440 + v432)) >> 3) + 1 >= 7)
                {
                  v247 = av1_get_bits((uint64_t)&v442, 0x10u);
                  v248 = v247;
                  *(_WORD *)(v12 + 3378) = v247;
                  v249 = av1_get_bits((uint64_t)&v442, 0x20u);
                  v19 = 0;
                  *(_WORD *)(v12 + 3380) = v249;
                  if (v248 != 59 || v249 != 2048)
                    goto LABEL_776;
                  v250 = av1_get_bits((uint64_t)&v442, 2u);
                  v251 = check_for_overrun(&v442, v432, uleb128);
                  if ((_DWORD)v251)
                    goto LABEL_745;
                  if (v250
                    || av1_get_bits((uint64_t)&v442, 3u) != 6
                    || av1_get_bits((uint64_t)&v442, 5u) != 31
                    || av1_get_bits((uint64_t)&v442, 5u) != 6
                    || av1_get_bits((uint64_t)&v442, 1u) != 1
                    || av1_get_bits((uint64_t)&v442, 5u) != 1
                    || av1_get_bits((uint64_t)&v442, 1u))
                  {
LABEL_423:
                    v19 = 0;
                    goto LABEL_776;
                  }
                  if (av1_get_bits((uint64_t)&v442, 1u)
                    || av1_get_bits((uint64_t)&v442, 1u)
                    || av1_get_bits((uint64_t)&v442, 1u)
                    || av1_get_bits((uint64_t)&v442, 1u))
                  {
                    v399 = 4294954579;
                    goto LABEL_744;
                  }
                  if (av1_get_bits((uint64_t)&v442, 1u) != 1)
                    goto LABEL_796;
                  v396 = 0;
                  v397 = 1;
                  while (v397)
                  {
                    v398 = av1_get_bits((uint64_t)&v442, 8u);
                    v397 = av1_get_bits((uint64_t)&v442, 1u);
                    if (!check_for_overrun(&v442, v432, uleb128))
                    {
                      if (v397)
                        v396 = ((v398 + v396) << 8) + 256;
                      else
                        v396 += v398;
                      if (!(_DWORD)v442)
                        continue;
                    }
                    goto LABEL_743;
                  }
                  if (v396 - 513 >= 0xFFFFFE00)
                  {
                    v410 = malloc_type_malloc((2 * v396) | 1, 0x582E55F0uLL);
                    *(_QWORD *)(v12 + 3400) = v410;
                    if (v410)
                    {
                      v411 = 0;
                      *v410 = 25;
                      *(_QWORD *)(v12 + 3384) = 1;
                      do
                      {
                        v412 = av1_get_bits((uint64_t)&v442, 8u);
                        if (v411 == 2)
                        {
                          if ((v412 & 0xFC) != 0)
                          {
                            v411 = 2;
                          }
                          else
                          {
                            v411 = 0;
                            v413 = *(_QWORD *)(v12 + 3400);
                            v414 = *(_QWORD *)(v12 + 3384);
                            *(_QWORD *)(v12 + 3384) = v414 + 1;
                            *(_BYTE *)(v413 + v414) = 3;
                          }
                        }
                        v415 = *(_QWORD *)(v12 + 3400);
                        v416 = *(_QWORD *)(v12 + 3384);
                        *(_QWORD *)(v12 + 3384) = v416 + 1;
                        *(_BYTE *)(v415 + v416) = v412;
                        if (v412)
                          v411 = 0;
                        else
                          ++v411;
                        --v396;
                      }
                      while (v396);
                      if (av1_get_bits((uint64_t)&v442, 5u))
                      {
                        v399 = 4294954584;
                        a7 = v49;
                        goto LABEL_744;
                      }
                      a7 = v49;
                      if (av1_get_bits((uint64_t)&v442, 2u) == 1
                        && !av1_get_bits((uint64_t)&v442, 2u)
                        && !av1_get_bits((uint64_t)&v442, 8u))
                      {
                        v19 = check_for_overrun(&v442, v432, uleb128);
                        if (!(_DWORD)v19)
                        {
                          v68 = 64;
                          goto LABEL_809;
                        }
LABEL_776:
                        v409 = *(void **)(v12 + 3400);
                        if (v409)
                        {
                          *(_QWORD *)(v12 + 3400) = 0;
                          free(v409);
                        }
                        v68 = 0;
                        goto LABEL_809;
                      }
                      goto LABEL_743;
                    }
LABEL_796:
                    v19 = 4294954584;
                    goto LABEL_776;
                  }
                }
LABEL_743:
                v399 = 4294954584;
LABEL_744:
                v251 = FigSignalErrorAt(v399, 0, 0, 0, 0, 0, 0);
LABEL_745:
                v19 = v251;
                goto LABEL_776;
              }
LABEL_802:
              v19 = v57;
              goto LABEL_590;
            }
LABEL_801:
            v57 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
            goto LABEL_802;
          default:
            goto LABEL_808;
        }
        free(v417);
        goto LABEL_808;
      }
      v19 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
LABEL_800:
      v30 = 0;
      a7 = v49;
      goto LABEL_810;
    case 7:
      v30 = 0;
      if ((a8 & 4) == 0)
      {
        v19 = 0;
        goto LABEL_810;
      }
      v19 = 0;
      if (*(_QWORD *)(v12 + 3328))
        goto LABEL_810;
LABEL_42:
      v423 = v28;
      v19 = 4294954584;
      v429 = a7;
      if (!a7)
        return v19;
      v38 = *(_QWORD *)(v12 + 3312);
      if (!v38)
        return v19;
      v425 = v26;
      v39 = *(_DWORD *)(v435 + 944);
      if (v39)
      {
        v40 = 0;
        *(_DWORD *)(v14 + 232) = 0;
        *(_DWORD *)(v14 + 260) = 0;
        v426 = (_DWORD *)(v14 + 232);
        *(_DWORD *)(v14 + 276) = 1;
        v424 = (_DWORD *)(v14 + 276);
      }
      else
      {
        v43 = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v14 + 260) = v43 != 0;
        if (v43)
        {
          v44 = av1_get_bits((uint64_t)&v436, 3u);
          *(_DWORD *)(v14 + 264) = v44;
          if (*(_DWORD *)(v435 + 968) && !*(_DWORD *)(v435 + 960))
            *(_DWORD *)(v14 + 272) = av1_get_bits((uint64_t)&v436, *(_DWORD *)(v435 + 984));
          v45 = uleb128;
          if (*(_DWORD *)(v435 + 1000))
          {
            v46 = av1_get_bits((uint64_t)&v436, *(_DWORD *)(v435 + 1008));
            *(_DWORD *)(v14 + 268) = v46;
            v47 = *(_QWORD *)(v12 + 328 * v44 + 3432);
            if (!v47 || *(_DWORD *)(v47 + 268) != v46)
              return 4294954584;
          }
          goto LABEL_586;
        }
        v40 = av1_get_bits((uint64_t)&v436, 2u);
        *(_DWORD *)(v14 + 232) = v40;
        v137 = av1_get_bits((uint64_t)&v436, 1u);
        v424 = (_DWORD *)(v14 + 276);
        v426 = (_DWORD *)(v14 + 232);
        *(_DWORD *)(v14 + 276) = v137 != 0;
        if (!v137)
        {
          v138 = av1_get_bits((uint64_t)&v436, 1u);
          v41 = 0;
          *(_DWORD *)(v14 + 280) = v138;
          goto LABEL_50;
        }
      }
      if (*(_DWORD *)(v435 + 968) && !*(_DWORD *)(v435 + 960))
        *(_DWORD *)(v14 + 272) = av1_get_bits((uint64_t)&v436, *(_DWORD *)(v435 + 984));
      v41 = 1;
LABEL_50:
      if (v40 != 3)
      {
        if (v40)
        {
          if (!v39)
            goto LABEL_53;
        }
        else if (!(v41 | v39))
        {
LABEL_53:
          v42 = av1_get_bits((uint64_t)&v436, 1u) != 0;
          goto LABEL_96;
        }
      }
      v42 = 1;
LABEL_96:
      *(_DWORD *)(v14 + 284) = v42;
      *(_DWORD *)(v14 + 288) = av1_get_bits((uint64_t)&v436, 1u);
      v69 = *(_DWORD *)(v435 + 1052);
      if (v69 == 2)
        v69 = av1_get_bits((uint64_t)&v436, 1u);
      *(_DWORD *)(v14 + 292) = v69;
      if (v69)
      {
        v69 = *(_DWORD *)(v435 + 1056);
        if (v69 == 2)
          v69 = av1_get_bits((uint64_t)&v436, 1u);
      }
      if ((*(_DWORD *)(v14 + 232) & 1) != 0)
        v70 = v69;
      else
        v70 = 1;
      *(_DWORD *)(v14 + 296) = v70;
      if (*(_DWORD *)(v435 + 1000))
        *(_DWORD *)(v14 + 268) = av1_get_bits((uint64_t)&v436, *(_DWORD *)(v435 + 1008));
      if (v39)
      {
        v71 = 0;
      }
      else if (*v426 == 3)
      {
        v71 = 1;
      }
      else
      {
        v71 = av1_get_bits((uint64_t)&v436, 1u);
      }
      *(_DWORD *)(v14 + 300) = v71;
      v75 = *(_DWORD *)(v435 + 1040);
      if (v75)
        v76 = av1_get_bits((uint64_t)&v436, *(_DWORD *)(v435 + 1060));
      else
        v76 = 0;
      *(_DWORD *)(v14 + 248) = v76;
      v421 = v71;
      if (!v42 && (*(_BYTE *)v426 & 1) != 0)
      {
        v77 = v12;
        v78 = av1_get_bits((uint64_t)&v436, 3u);
      }
      else
      {
        v77 = v12;
        v78 = 7;
      }
      *(_DWORD *)(v14 + 304) = v78;
      if (*(_DWORD *)(v435 + 968))
      {
        v79 = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v14 + 308) = v79;
        if (v79)
        {
          v80 = *(_DWORD *)(v38 + 40);
          if (v80 >= 1)
          {
            v81 = 0;
            v82 = (_DWORD *)(v435 + 64);
            do
            {
              if (*v82)
              {
                v83 = *(v82 - 2);
                if (!v83 || (((1 << (*(_DWORD *)(v14 + 256) + 8)) | (1 << *(_DWORD *)(v14 + 252))) & ~v83) == 0)
                {
                  *(_DWORD *)(v14 + 312 + 4 * v81) = av1_get_bits((uint64_t)&v436, *(_DWORD *)(v435 + 980));
                  v80 = *(_DWORD *)(v38 + 40);
                }
              }
              ++v81;
              v82 += 7;
            }
            while (v81 < v80);
          }
        }
      }
      v84 = !v42;
      v85 = *v426;
      if ((*v426 & 1) == 0)
      {
        v12 = v77;
        v86 = v435;
        if (v85 || !*v424)
        {
          v87 = av1_get_bits((uint64_t)&v436, 8u);
          *(_DWORD *)(v14 + 440) = v87;
          v88 = v87 == 255 || !v42;
          if (v75 && (v88 & 1) == 0)
          {
            v89 = *(_DWORD *)(v435 + 1060);
            v90 = 8;
            do
            {
              av1_get_bits((uint64_t)&v436, v89);
              --v90;
            }
            while (v90);
          }
        }
        else
        {
          *(_DWORD *)(v14 + 440) = 255;
        }
        read_frame_size(v12, (uint64_t)&v436, (_DWORD *)v14, (_DWORD *)v435, 0);
        v136 = *(_DWORD *)(v14 + 292) && !*(_DWORD *)(v14 + 456) && av1_get_bits((uint64_t)&v436, 1u) != 0;
        v177 = 0;
        *(_DWORD *)(v14 + 464) = v136;
LABEL_304:
        *(_DWORD *)(v14 + 512) = v177;
        v191 = !*(_DWORD *)(v86 + 944) && !*(_DWORD *)(v14 + 288) && av1_get_bits((uint64_t)&v436, 1u) == 0;
        *(_DWORD *)(v14 + 516) = v191;
        v192 = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v14 + 520) = v192;
        v193 = *(_DWORD *)(v86 + 1012);
        v194 = (64 << v193) - 1;
        v195 = v193 + 6;
        v196 = (v194 + *(_DWORD *)(v14 + 236)) >> v195;
        v197 = *(_DWORD *)(v14 + 244);
        v198 = 0x1000u >> v195;
        v199 = -1;
        do
          ++v199;
        while (v198 << v199 < v196);
        *(_DWORD *)(v14 + 528) = v199;
        if (v196 >= 64)
          v200 = 64;
        else
          v200 = v196;
        v201 = -1;
        do
          ++v201;
        while (1 << v201 < v200);
        v202 = (v197 + v194) >> v195;
        *(_DWORD *)(v14 + 532) = v201;
        if (v202 >= 64)
          v203 = 64;
        else
          v203 = (v197 + v194) >> v195;
        v204 = -1;
        do
          ++v204;
        while (1 << v204 < v203);
        v205 = 0x900000u >> (2 * v195);
        *(_DWORD *)(v14 + 548) = v204;
        v206 = v196 * v202;
        v207 = -1;
        do
          ++v207;
        while ((int)(v205 << v207) < v206);
        v208 = v199;
        if (v207 > v199)
        {
          v208 = -1;
          do
            ++v208;
          while ((int)(v205 << v208) < v206);
        }
        if (v192)
        {
          while (1)
          {
            *(_DWORD *)(v14 + 536) = v199;
            if (v199 >= v201 || !av1_get_bits((uint64_t)&v436, 1u))
              break;
            ++v199;
          }
          if (v196 < 1)
          {
            LODWORD(v213) = 0;
          }
          else
          {
            v209 = 0;
            v210 = ((v196 - 1) >> v199) + 1;
            if (v196 <= v210)
              v211 = ((v196 - 1) >> v199) + 1;
            else
              v211 = v196;
            v212 = (v211 - 1) / v210 + 1;
            LODWORD(v213) = v212;
            v214 = (_WORD *)(v14 + 560);
            do
            {
              *v214++ = v209;
              v209 += v210;
              --v212;
            }
            while (v212);
          }
          *(_DWORD *)(v14 + 540) = v213;
          v220 = (v208 - v199) & ~((int)(v208 - v199) >> 31);
          *(_DWORD *)(v14 + 544) = v220;
          while (1)
          {
            *(_DWORD *)(v14 + 552) = v220;
            if (v220 >= v204 || !av1_get_bits((uint64_t)&v436, 1u))
              break;
            ++v220;
          }
          if (v202 < 1)
          {
            LODWORD(v225) = 0;
            v227 = (_DWORD *)v435;
          }
          else
          {
            v221 = 0;
            v222 = ((v202 - 1) >> v220) + 1;
            if (v202 <= v222)
              v223 = ((v202 - 1) >> v220) + 1;
            else
              v223 = v202;
            v224 = (v223 - 1) / v222 + 1;
            LODWORD(v225) = v224;
            v226 = (_WORD *)(v14 + 690);
            v227 = (_DWORD *)v435;
            do
            {
              *v226++ = v221;
              v221 += v222;
              --v224;
            }
            while (v224);
          }
          *(_DWORD *)(v14 + 556) = v225;
        }
        else
        {
          *(_DWORD *)(v14 + 540) = 0;
          if (v196 < 1)
          {
            LODWORD(v213) = 0;
            v216 = 0;
          }
          else
          {
            v213 = 0;
            v215 = 0;
            v216 = 0;
            do
            {
              if (v196 - v215 >= v198)
                v217 = v198;
              else
                v217 = v196 - v215;
              if (v217 < 2)
                v218 = 1;
              else
                v218 = av1_get_uniform(&v436, v217) + 1;
              *(_WORD *)(v14 + 560 + 2 * v213) = v215;
              if ((int)v216 <= v218)
                v216 = v218;
              *(_DWORD *)(v14 + 540) = v213 + 1;
              v219 = v213++;
              if (v219 > 0x3E)
                break;
              v215 += v218;
            }
            while (v215 < v196);
          }
          v199 = -1;
          do
            ++v199;
          while (1 << v199 < (int)v213);
          *(_DWORD *)(v14 + 536) = v199;
          if (v208)
            v228 = v208 + 1;
          else
            v228 = 0;
          v229 = v206 >> v228;
          if (v216 <= 1)
            v230 = 1;
          else
            v230 = v216;
          v231 = v229 / v230;
          if (v231 <= 1)
            v232 = 1;
          else
            v232 = v231;
          *(_DWORD *)(v14 + 556) = 0;
          if (v202 < 1)
          {
            LODWORD(v225) = 0;
          }
          else
          {
            v233 = v12;
            v225 = 0;
            for (k = 0; k < v202; k += v236)
            {
              if (v202 - k >= v232)
                v235 = v232;
              else
                v235 = v202 - k;
              if (v235 < 2)
                v236 = 1;
              else
                v236 = av1_get_uniform(&v436, v235) + 1;
              *(_WORD *)(v14 + 690 + 2 * v225) = k;
              *(_DWORD *)(v14 + 556) = v225 + 1;
              v237 = v225++;
              if (v237 > 0x3E)
                break;
            }
            v12 = v233;
          }
          v220 = -1;
          v227 = (_DWORD *)v435;
          do
            ++v220;
          while (1 << v220 < (int)v225);
          *(_DWORD *)(v14 + 552) = v220;
        }
        *(_WORD *)(v14 + 520 + 2 * (int)v213 + 40) = v196;
        *(_WORD *)(v14 + 520 + 2 * (int)v225 + 170) = v202;
        v238 = v199 | v220;
        if (v199 | v220)
        {
          v239 = av1_get_bits((uint64_t)&v436, v199 + v220);
          *(_DWORD *)(v14 + 820) = v239;
          if (v239 >= (int)v225 * (int)v213)
            return 4294954584;
          v238 = av1_get_bits((uint64_t)&v436, 2u) + 1;
        }
        else
        {
          *(_DWORD *)(v14 + 820) = 0;
        }
        *(_DWORD *)(v14 + 524) = v238;
        v240 = av1_get_bits((uint64_t)&v436, 8u);
        *(_DWORD *)(v14 + 824) = v240;
        if (av1_get_bits((uint64_t)&v436, 1u))
          v241 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
        else
          v241 = 0;
        *(_DWORD *)(v14 + 828) = v241;
        if (!v227[271])
        {
          if (v227[273])
            v242 = av1_get_bits((uint64_t)&v436, 1u);
          else
            v242 = 0;
          if (av1_get_bits((uint64_t)&v436, 1u))
            v243 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
          else
            v243 = 0;
          *(_DWORD *)(v14 + 832) = v243;
          if (av1_get_bits((uint64_t)&v436, 1u))
            v244 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
          else
            v244 = 0;
          *(_DWORD *)(v14 + 836) = v244;
          if (v242)
          {
            if (av1_get_bits((uint64_t)&v436, 1u))
              v245 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
            else
              v245 = 0;
            *(_DWORD *)(v14 + 840) = v245;
            if (av1_get_bits((uint64_t)&v436, 1u))
              v244 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
            else
              v244 = 0;
          }
          else
          {
            *(_DWORD *)(v14 + 840) = v243;
          }
          *(_DWORD *)(v14 + 844) = v244;
        }
        v252 = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v14 + 848) = v252;
        if (v252)
        {
          *(_DWORD *)(v14 + 852) = av1_get_bits((uint64_t)&v436, 4u);
          v253 = av1_get_bits((uint64_t)&v436, 4u);
          *(_DWORD *)(v14 + 856) = v253;
          if (v227[273])
            v253 = av1_get_bits((uint64_t)&v436, 4u);
          *(_DWORD *)(v14 + 860) = v253;
        }
        v254 = av1_get_bits((uint64_t)&v436, 1u);
        *(_DWORD *)(v14 + 864) = v254;
        if (v254)
        {
          v255 = *(int *)(v14 + 304);
          if ((_DWORD)v255 == 7)
          {
            *(_DWORD *)(v14 + 868) = 1;
            *(_QWORD *)(v14 + 872) = 0x100000000;
          }
          else
          {
            v257 = av1_get_bits((uint64_t)&v436, 1u);
            *(_DWORD *)(v14 + 868) = v257;
            if (v257)
              v257 = av1_get_bits((uint64_t)&v436, 1u);
            *(_DWORD *)(v14 + 872) = v257;
            v258 = av1_get_bits((uint64_t)&v436, 1u);
            *(_DWORD *)(v14 + 876) = v258;
            if (!v258)
            {
              v272 = *(_QWORD *)(v12 + 328 * *(int *)(v14 + 4 * v255 + 472) + 3432);
              if (!v272)
                return 4294954584;
              memcpy((void *)(v14 + 880), (const void *)(v272 + 880), 0x108uLL);
              if (v240)
              {
LABEL_467:
                v269 = av1_get_bits((uint64_t)&v436, 1u);
                *(_DWORD *)(v14 + 1208) = v269;
                if (v269)
                {
                  *(_DWORD *)(v14 + 1212) = av1_get_bits((uint64_t)&v436, 2u);
                  if (!*(_DWORD *)(v14 + 464))
                  {
                    v270 = av1_get_bits((uint64_t)&v436, 1u);
                    *(_DWORD *)(v14 + 1216) = v270 != 0;
                    if (v270)
                    {
                      *(_DWORD *)(v14 + 1220) = av1_get_bits((uint64_t)&v436, 2u);
                      v271 = av1_get_bits((uint64_t)&v436, 1u);
                      goto LABEL_477;
                    }
LABEL_476:
                    v271 = 0;
                    *(_DWORD *)(v14 + 1220) = 0;
LABEL_477:
                    *(_DWORD *)(v14 + 1224) = v271;
                    v273 = !v241
                        && !*(_DWORD *)(v14 + 832)
                        && !*(_DWORD *)(v14 + 836)
                        && !*(_DWORD *)(v14 + 840)
                        && *(_DWORD *)(v14 + 844) == 0;
                    *(_DWORD *)(v14 + 1228) = 1;
                    v274 = 880;
                    v275 = 1176;
                    do
                    {
                      v276 = v240;
                      if (v254)
                      {
                        v277 = *(_DWORD *)(v14 + v274) + v240;
                        if (v277 >= 255)
                          v277 = 255;
                        v276 = v277 & ~(v277 >> 31);
                      }
                      *(_DWORD *)(v14 + v275) = v276;
                      if (v276)
                        v278 = 0;
                      else
                        v278 = v273;
                      *(_DWORD *)(v14 + v275 - 32) = v278;
                      v279 = *(_DWORD *)(v14 + 1228) & v278;
                      *(_DWORD *)(v14 + 1228) = v279;
                      v274 += 32;
                      v275 += 4;
                    }
                    while (v274 != 1136);
                    if (v279 || *(_DWORD *)(v14 + 464))
                    {
                      *(_DWORD *)(v14 + 1296) = 0;
                      *(_OWORD *)(v14 + 1232) = 0u;
                      *(_QWORD *)(v14 + 1248) = 0x100000001;
                      *(_OWORD *)(v14 + 1256) = default_mode_ref_deltas;
                      *(_OWORD *)(v14 + 1272) = unk_18EDDCD10;
                      *(_QWORD *)(v14 + 1288) = -1;
                    }
                    else
                    {
                      v320 = av1_get_bits((uint64_t)&v436, 6u);
                      *(_DWORD *)(v14 + 1232) = v320;
                      v321 = av1_get_bits((uint64_t)&v436, 6u);
                      *(_DWORD *)(v14 + 1236) = v321;
                      if (!v227[271] && v320 | v321)
                      {
                        *(_DWORD *)(v14 + 1240) = av1_get_bits((uint64_t)&v436, 6u);
                        *(_DWORD *)(v14 + 1244) = av1_get_bits((uint64_t)&v436, 6u);
                      }
                      *(_DWORD *)(v14 + 1296) = av1_get_bits((uint64_t)&v436, 3u);
                      v322 = av1_get_bits((uint64_t)&v436, 1u);
                      *(_DWORD *)(v14 + 1248) = v322;
                      if (!v322 || (v323 = av1_get_bits((uint64_t)&v436, 1u), (*(_DWORD *)(v14 + 1252) = v323) == 0))
                      {
LABEL_495:
                        if (v227[267] && !*(_DWORD *)(v14 + 464))
                        {
                          *(_DWORD *)(v14 + 1300) = av1_get_bits((uint64_t)&v436, 2u) + 3;
                          v332 = av1_get_bits((uint64_t)&v436, 2u);
                          *(_DWORD *)(v14 + 1304) = v332;
                          if (v332 == 31)
                          {
LABEL_500:
                            if (v227[268] && !*(_DWORD *)(v14 + 464))
                            {
                              v316 = av1_get_bits((uint64_t)&v436, 2u);
                              *(_DWORD *)(v14 + 1372) = v316;
                              if (v227[271])
                              {
                                v317 = 0;
                                v318 = 0;
                                *(_DWORD *)(v14 + 1376) = 0;
                              }
                              else
                              {
                                v317 = av1_get_bits((uint64_t)&v436, 2u);
                                *(_DWORD *)(v14 + 1376) = v317;
                                v318 = av1_get_bits((uint64_t)&v436, 2u);
                              }
                              *(_DWORD *)(v14 + 1380) = v318;
                              if (v316 || v317 | v318)
                              {
                                v335 = v227[253];
                                v336 = v335 + 6;
                                *(_DWORD *)(v14 + 1384) = v335 + 6;
                                if (av1_get_bits((uint64_t)&v436, 1u))
                                {
                                  v336 = v335 + 7;
                                  *(_DWORD *)(v14 + 1384) = v335 + 7;
                                  a7 = v429;
                                  if (!v227[253])
                                  {
                                    v336 += av1_get_bits((uint64_t)&v436, 1u);
                                    *(_DWORD *)(v14 + 1384) = v336;
                                  }
                                }
                                else
                                {
                                  a7 = v429;
                                }
                                *(_DWORD *)(v14 + 1388) = v336;
                                if (v317 | v318 && v227[269] == 1 && v227[270] == 1)
                                  *(_DWORD *)(v14 + 1388) = v336 - av1_get_bits((uint64_t)&v436, 1u);
LABEL_504:
                                if (v279)
                                {
                                  v280 = 0;
                                }
                                else if (av1_get_bits((uint64_t)&v436, 1u))
                                {
                                  v280 = 2;
                                }
                                else
                                {
                                  v280 = 1;
                                }
                                *(_DWORD *)(v14 + 1392) = v280;
                                if ((*(_BYTE *)(v14 + 232) & 1) != 0)
                                {
                                  v281 = av1_get_bits((uint64_t)&v436, 1u);
                                  *(_DWORD *)(v14 + 1396) = v281;
                                  *(_DWORD *)(v14 + 1400) = 0;
                                  if (v281)
                                  {
                                    if ((*(_BYTE *)v426 & 1) == 0 || !v227[260])
                                      goto LABEL_542;
                                    v282 = 0;
                                    v283 = 0;
                                    v284 = 0;
                                    v285 = v227[265];
                                    v286 = 1 << (v285 - 1);
                                    v287 = v286 - 1;
                                    v289 = -1;
                                    v290 = -1;
                                    do
                                    {
                                      if (v285)
                                      {
                                        v288 = v14 + 472;
                                        v291 = *(_DWORD *)(v12 + 328 * *(int *)(v14 + 472 + 4 * v282) + 3440);
                                        v292 = ((v291 - *(_DWORD *)(v14 + 248)) & v287)
                                             - ((v291 - *(_DWORD *)(v14 + 248)) & v286);
                                        if (v292 < 1)
                                        {
                                          if (v292 < 0
                                            && (v290 == -1 || ((v291 - v290) & v287) > ((v291 - v290) & v286)))
                                          {
                                            v290 = *(_DWORD *)(v12 + 328 * *(int *)(v288 + 4 * v282) + 3440);
                                            v284 = v282;
                                          }
                                        }
                                        else if (v289 == -1 || ((v289 - v291) & v287) > ((v289 - v291) & v286))
                                        {
                                          v289 = *(_DWORD *)(v12 + 328 * *(int *)(v288 + 4 * v282) + 3440);
                                          v283 = v282;
                                        }
                                      }
                                      ++v282;
                                    }
                                    while (v282 != 7);
                                    if (v290 != -1 && v289 != -1)
                                      goto LABEL_536;
                                    if (v290 == -1)
                                      goto LABEL_542;
                                    v293 = 0;
                                    v283 = 0;
                                    v294 = -1;
                                    do
                                    {
                                      if (v285)
                                      {
                                        v295 = *(_DWORD *)(v12 + 328 * *(int *)(v14 + 472 + 4 * v293) + 3440);
                                        if (((v295 - v290) & v287) < ((v295 - v290) & v286)
                                          && (v294 == -1 || ((v295 - v294) & v287) > ((v295 - v294) & v286)))
                                        {
                                          v294 = *(_DWORD *)(v12 + 328 * *(int *)(v14 + 472 + 4 * v293) + 3440);
                                          v283 = v293;
                                        }
                                      }
                                      ++v293;
                                    }
                                    while (v293 != 7);
                                    if (v294 == -1)
                                    {
LABEL_542:
                                      v281 = 0;
                                    }
                                    else
                                    {
LABEL_536:
                                      if (v284 >= v283)
                                        v296 = v283;
                                      else
                                        v296 = v284;
                                      *(_DWORD *)(v14 + 1408) = v296;
                                      if (v284 <= v283)
                                        v284 = v283;
                                      *(_DWORD *)(v14 + 1412) = v284;
                                      *(_DWORD *)(v14 + 1400) = 1;
                                      v281 = av1_get_bits((uint64_t)&v436, 1u);
                                    }
                                  }
                                }
                                else
                                {
                                  v281 = 0;
                                  *(_QWORD *)(v14 + 1396) = 0;
                                }
                                *(_DWORD *)(v14 + 1404) = v281;
                                if (!*(_DWORD *)(v14 + 284) && (*(_BYTE *)v426 & 1) != 0)
                                {
                                  v297 = v227[258];
                                  if (v297)
                                    v297 = av1_get_bits((uint64_t)&v436, 1u) != 0;
                                }
                                else
                                {
                                  v297 = 0;
                                }
                                *(_DWORD *)(v14 + 1416) = v297;
                                *(_DWORD *)(v14 + 1420) = av1_get_bits((uint64_t)&v436, 1u);
                                for (m = 1424; m != 1676; m += 36)
                                {
                                  v299 = v14 + m;
                                  *(_OWORD *)v299 = dav1d_default_wm_params;
                                  *(_OWORD *)(v299 + 16) = *(_OWORD *)&dword_18EDDCD38;
                                  *(_DWORD *)(v299 + 32) = 0;
                                }
                                if ((*(_BYTE *)v426 & 1) != 0)
                                {
                                  v300 = 0;
                                  v301 = v14 + 1448;
                                  while (!av1_get_bits((uint64_t)&v436, 1u))
                                  {
                                    *(_DWORD *)(v301 + v300 - 24) = 0;
LABEL_573:
                                    v300 += 36;
                                    if (v300 == 252)
                                      goto LABEL_574;
                                  }
                                  if (av1_get_bits((uint64_t)&v436, 1u))
                                  {
                                    v302 = 2;
                                  }
                                  else if (av1_get_bits((uint64_t)&v436, 1u))
                                  {
                                    v302 = 1;
                                  }
                                  else
                                  {
                                    v302 = 3;
                                  }
                                  *(_DWORD *)(v301 + v300 - 24) = v302;
                                  v303 = *(int *)(v14 + 304);
                                  v304 = (int *)&dav1d_default_wm_params;
                                  if ((_DWORD)v303 != 7)
                                  {
                                    v305 = *(_QWORD *)(v12 + 328 * *(int *)(v14 + 4 * v303 + 472) + 3432);
                                    if (!v305)
                                      return 4294954584;
                                    v304 = (int *)(v305 + v300 + 1424);
                                  }
                                  if (v302 <= 1)
                                  {
                                    if (*(_DWORD *)(v14 + 500))
                                      v306 = 9;
                                    else
                                      v306 = 8;
                                    if (*(_DWORD *)(v14 + 500))
                                      v309 = 13;
                                    else
                                      v309 = 14;
                                    v307 = *(_DWORD *)(v301 + v300 - 12);
                                    v308 = *(_DWORD *)(v301 + v300 - 8);
                                  }
                                  else
                                  {
                                    v306 = 12;
                                    v307 = 2 * av1_get_bits_subexp(&v436, (v304[3] - 0x10000) >> 1, 12) + 0x10000;
                                    *(_DWORD *)(v301 + v300 - 12) = v307;
                                    v308 = 2 * av1_get_bits_subexp(&v436, v304[4] >> 1, 12);
                                    *(_DWORD *)(v301 + v300 - 8) = v308;
                                    if (v302 == 3)
                                    {
                                      *(_DWORD *)(v301 + v300 - 4) = 2 * av1_get_bits_subexp(&v436, v304[5] >> 1, 12);
                                      v307 = 2 * av1_get_bits_subexp(&v436, (v304[6] - 0x10000) >> 1, 12) + 0x10000;
                                      v309 = 10;
LABEL_572:
                                      *(_DWORD *)(v301 + v300) = v307;
                                      *(_DWORD *)(v301 + v300 - 20) = av1_get_bits_subexp(&v436, v304[1] >> v309, v306) << v309;
                                      *(_DWORD *)(v301 + v300 - 16) = av1_get_bits_subexp(&v436, v304[2] >> v309, v306) << v309;
                                      a7 = v429;
                                      v227 = (_DWORD *)v435;
                                      goto LABEL_573;
                                    }
                                    v309 = 10;
                                  }
                                  *(_DWORD *)(v301 + v300 - 4) = -v308;
                                  goto LABEL_572;
                                }
LABEL_574:
                                if (v227[274] && (*v424 || *(_DWORD *)(v14 + 280)))
                                {
                                  v310 = av1_get_bits((uint64_t)&v436, 1u);
                                  *(_DWORD *)(v14 + 224) = v310 != 0;
                                  v45 = uleb128;
                                  if (v310)
                                  {
                                    v311 = av1_get_bits((uint64_t)&v436, 0x10u);
                                    if (*v426 == 1)
                                    {
                                      v312 = av1_get_bits((uint64_t)&v436, 1u);
                                      *(_DWORD *)(v14 + 228) = v312 != 0;
                                      if (!v312)
                                      {
                                        v313 = av1_get_bits((uint64_t)&v436, 3u);
                                        v314 = 472;
                                        v19 = 4294954584;
                                        while (*(_DWORD *)(v14 + v314) != v313)
                                        {
                                          v314 += 4;
                                          if (v314 == 500)
                                            return v19;
                                        }
                                        v385 = *(_OWORD **)(v12 + 328 * v313 + 3432);
                                        a7 = v429;
                                        if (!v385)
                                          return 4294954584;
                                        v386 = v385[1];
                                        *(_OWORD *)v14 = *v385;
                                        *(_OWORD *)(v14 + 16) = v386;
                                        v387 = v385[2];
                                        v388 = v385[3];
                                        v389 = v385[5];
                                        *(_OWORD *)(v14 + 64) = v385[4];
                                        *(_OWORD *)(v14 + 80) = v389;
                                        *(_OWORD *)(v14 + 32) = v387;
                                        *(_OWORD *)(v14 + 48) = v388;
                                        v390 = v385[6];
                                        v391 = v385[7];
                                        v392 = v385[9];
                                        *(_OWORD *)(v14 + 128) = v385[8];
                                        *(_OWORD *)(v14 + 144) = v392;
                                        *(_OWORD *)(v14 + 96) = v390;
                                        *(_OWORD *)(v14 + 112) = v391;
                                        v393 = v385[10];
                                        v394 = v385[11];
                                        v395 = v385[13];
                                        *(_OWORD *)(v14 + 192) = v385[12];
                                        *(_OWORD *)(v14 + 208) = v395;
                                        *(_OWORD *)(v14 + 160) = v393;
                                        *(_OWORD *)(v14 + 176) = v394;
                                        *(_DWORD *)v14 = v311;
                                        v45 = uleb128;
                                        goto LABEL_586;
                                      }
                                    }
                                    else
                                    {
                                      *(_DWORD *)(v14 + 228) = 1;
                                    }
                                    *(_DWORD *)v14 = v311;
                                    v319 = av1_get_bits((uint64_t)&v436, 4u);
                                    *(_DWORD *)(v14 + 4) = v319;
                                    if (v319 > 14)
                                      return 4294954584;
                                    v327 = v319;
                                    if (v319 >= 1)
                                    {
                                      v328 = 0;
                                      v329 = 2 * v319;
                                      do
                                      {
                                        v330 = av1_get_bits((uint64_t)&v436, 8u);
                                        v331 = v14 + v328;
                                        *(_BYTE *)(v14 + v328 + 8) = v330;
                                        if (v328)
                                        {
                                          if (*(unsigned __int8 *)(v331 + 6) >= v330)
                                            return 4294954584;
                                        }
                                        *(_BYTE *)(v331 + 9) = av1_get_bits((uint64_t)&v436, 8u);
                                        v328 += 2;
                                      }
                                      while (v329 != v328);
                                    }
                                    if (v227[271])
                                    {
                                      *(_DWORD *)(v14 + 36) = 0;
                                      v427 = (_DWORD *)(v14 + 36);
                                    }
                                    else
                                    {
                                      v366 = av1_get_bits((uint64_t)&v436, 1u);
                                      *(_DWORD *)(v14 + 36) = v366 != 0;
                                      v427 = (_DWORD *)(v14 + 36);
                                      if (!v366 && (v227[270] != 1 || v327 || v227[269] != 1))
                                      {
                                        v400 = v12;
                                        v401 = 0;
                                        v402 = 1;
                                        while (1)
                                        {
                                          v403 = v402;
                                          v404 = av1_get_bits((uint64_t)&v436, 4u);
                                          *(_DWORD *)(v14 + 4 * v401 + 40) = v404;
                                          if (v404 > 10)
                                            return 4294954584;
                                          if (v404 >= 1)
                                            break;
LABEL_771:
                                          v402 = 0;
                                          v401 = 1;
                                          if ((v403 & 1) == 0)
                                          {
                                            v12 = v400;
                                            v227 = (_DWORD *)v435;
                                            goto LABEL_702;
                                          }
                                        }
                                        v405 = 0;
                                        v406 = v404;
                                        v407 = (_BYTE *)(v14 + 49 + 20 * v401);
                                        while (1)
                                        {
                                          v408 = av1_get_bits((uint64_t)&v436, 8u);
                                          *(v407 - 1) = v408;
                                          if (v405)
                                          {
                                            if (*(v407 - 3) >= v408)
                                              return 4294954584;
                                          }
                                          *v407 = av1_get_bits((uint64_t)&v436, 8u);
                                          v407 += 2;
                                          if (++v405 >= v406)
                                            goto LABEL_771;
                                        }
                                      }
                                    }
                                    *(_QWORD *)(v14 + 40) = 0;
LABEL_702:
                                    if (v227[269] == 1
                                      && v227[270] == 1
                                      && (*(_DWORD *)(v14 + 40) == 0) == (*(_DWORD *)(v14 + 44) != 0))
                                    {
                                      return 4294954584;
                                    }
                                    v422 = v12;
                                    *(_DWORD *)(v14 + 88) = av1_get_bits((uint64_t)&v436, 2u) + 8;
                                    v367 = av1_get_bits((uint64_t)&v436, 2u);
                                    *(_DWORD *)(v14 + 92) = v367;
                                    v368 = v367 + v367 * v367;
                                    v369 = 2 * v368;
                                    if (v327 && v369 > 0)
                                    {
                                      v370 = (_BYTE *)(v14 + 96);
                                      v371 = (2 * v368);
                                      do
                                      {
                                        *v370++ = av1_get_bits((uint64_t)&v436, 8u) ^ 0x80;
                                        --v371;
                                      }
                                      while (v371);
                                    }
                                    v372 = 0;
                                    v373 = 1;
                                    do
                                    {
                                      v374 = v373;
                                      if (*(_DWORD *)(v14 + 4 * v372 + 40) || *v427)
                                      {
                                        v375 = *(_DWORD *)(v14 + 4);
                                        v376 = v375 != 0;
                                        v377 = v369 | v376;
                                        if ((v369 | v376) >= 1)
                                        {
                                          v378 = (_BYTE *)(v14 + 120 + 28 * v372);
                                          v379 = v369 | v376;
                                          do
                                          {
                                            *v378++ = av1_get_bits((uint64_t)&v436, 8u) ^ 0x80;
                                            --v379;
                                          }
                                          while (v379);
                                        }
                                        if (!v375)
                                          *(_BYTE *)(v14 + 28 * v372 + v377 + 120) = 0;
                                      }
                                      v373 = 0;
                                      v372 = 1;
                                    }
                                    while ((v374 & 1) != 0);
                                    *(_QWORD *)(v14 + 176) = av1_get_bits((uint64_t)&v436, 2u) + 6;
                                    v380 = av1_get_bits((uint64_t)&v436, 2u);
                                    v381 = 0;
                                    *(_DWORD *)(v14 + 184) = v380;
                                    v382 = 1;
                                    v12 = v422;
                                    v45 = uleb128;
                                    do
                                    {
                                      v383 = v382;
                                      v384 = (_DWORD *)(v14 + 4 * v381);
                                      if (v384[10])
                                      {
                                        v384[47] = av1_get_bits((uint64_t)&v436, 8u) - 128;
                                        v384[49] = av1_get_bits((uint64_t)&v436, 8u) - 128;
                                        v384[51] = av1_get_bits((uint64_t)&v436, 9u) - 256;
                                      }
                                      v382 = 0;
                                      v381 = 1;
                                    }
                                    while ((v383 & 1) != 0);
                                    *(_DWORD *)(v14 + 212) = av1_get_bits((uint64_t)&v436, 1u);
                                    *(_DWORD *)(v14 + 216) = av1_get_bits((uint64_t)&v436, 1u);
                                    a7 = v429;
LABEL_586:
                                    *(_QWORD *)(v12 + 3328) = v14;
                                    *(_DWORD *)(v14 + 252) = v425;
                                    *(_DWORD *)(v14 + 256) = v431;
                                    *(_DWORD *)(a7 + 12) = 0;
                                    *(_DWORD *)(a7 + 16) = 0;
                                    if (v434 != 6)
                                    {
                                      av1_get_bits((uint64_t)&v436, 1u);
                                      v19 = check_for_overrun(&v436, v432, v45);
                                      if ((_DWORD)v19)
                                        return v19;
LABEL_590:
                                      v30 = 0;
LABEL_810:
                                      if (!*(_QWORD *)(v12 + 3312))
                                        goto LABEL_814;
                                      v418 = *(_DWORD **)(v12 + 3328);
                                      if (!v418)
                                        goto LABEL_814;
                                      if (v418[65])
                                        goto LABEL_813;
                                      if (*(_DWORD *)(a7 + 16) == v418[139] * v418[135])
                                      {
                                        if (*(_DWORD *)(a7 + 12))
                                        {
                                          if (a9 == 1)
                                            dav1d_submit_frame(v12);
LABEL_813:
                                          *(_QWORD *)(v12 + 3328) = 0;
                                          goto LABEL_814;
                                        }
                                        v30 |= 0x40000000u;
                                      }
LABEL_814:
                                      if (*((_QWORD *)&v437 + 1))
                                        v419 = (_DWORD)v19 == 0;
                                      else
                                        v419 = 0;
                                      if (v419)
                                      {
                                        if (a10)
                                          *a10 = uleb128 + (v432 >> 3);
                                        v19 = 0;
                                        if (a11)
                                          *a11 |= v30;
                                      }
                                      return v19;
                                    }
                                    if (*(_DWORD *)(v14 + 260))
                                    {
                                      v30 = 0;
                                      v19 = 0;
                                      goto LABEL_813;
                                    }
                                    v315 = v437;
                                    LODWORD(v437) = 0;
                                    *((_QWORD *)&v436 + 1) = 0;
                                    if (v315 <= 7)
                                    {
                                      LODWORD(v28) = v423;
                                      if (*(_DWORD *)(v14 + 556) * *(_DWORD *)(v14 + 540))
                                      {
                                        v30 = 4;
LABEL_36:
                                        v35 = *(_DWORD *)(a7 + 12);
                                        if (v35)
                                        {
                                          v36 = v28;
                                          v37 = uleb128;
                                        }
                                        else
                                        {
                                          v36 = v28;
                                          v37 = uleb128;
                                          if (*(int *)(a7 + 8) < 1)
                                          {
                                            v139 = (char *)malloc_type_realloc(*(void **)a7, 0x48uLL, 0x1070040C633F987uLL);
                                            if (!v139)
                                              return 4294954584;
                                            *(_QWORD *)a7 = v139;
                                            v140 = &v139[72 * *(int *)(a7 + 12)];
                                            *((_QWORD *)v140 + 8) = 0;
                                            *((_OWORD *)v140 + 2) = 0u;
                                            *((_OWORD *)v140 + 3) = 0u;
                                            *(_OWORD *)v140 = 0u;
                                            *((_OWORD *)v140 + 1) = 0u;
                                            v35 = *(_DWORD *)(a7 + 12);
                                            *(_DWORD *)(a7 + 8) = v35 + 1;
                                            v14 = *(_QWORD *)(v12 + 3328);
                                            if (!v14)
                                              return 4294954584;
                                          }
                                          else
                                          {
                                            v35 = 0;
                                          }
                                        }
                                        v141 = *(_DWORD *)(v14 + 556) * *(_DWORD *)(v14 + 540);
                                        v142 = v141 - 1;
                                        if (v141 > 1 && av1_get_bits((uint64_t)&v436, 1u))
                                        {
                                          v143 = *(_DWORD *)(v14 + 552) + *(_DWORD *)(v14 + 536);
                                          v144 = av1_get_bits((uint64_t)&v436, v143);
                                          v145 = *(_QWORD *)a7 + 72 * v35;
                                          *(_DWORD *)(v145 + 64) = v144;
                                          v142 = av1_get_bits((uint64_t)&v436, v143);
                                          *(_DWORD *)(v145 + 68) = v142;
                                          v146 = *(_DWORD *)(v145 + 64);
                                        }
                                        else
                                        {
                                          v146 = 0;
                                          v147 = *(_QWORD *)a7 + 72 * v35;
                                          *(_DWORD *)(v147 + 64) = 0;
                                          *(_DWORD *)(v147 + 68) = v142;
                                        }
                                        if (v146 > v142 || v146 != *(_DWORD *)(a7 + 16))
                                        {
                                          *(_DWORD *)(a7 + 12) = 0;
                                          *(_DWORD *)(a7 + 16) = 0;
                                        }
                                        v148 = v437;
                                        LODWORD(v437) = 0;
                                        *((_QWORD *)&v436 + 1) = 0;
                                        if (v148 <= 7)
                                        {
                                          v149 = check_for_overrun(&v436, v432, v37);
                                          if ((_DWORD)v149)
                                            return v149;
                                          v150 = 8 * (DWORD2(v437) - v438) - v437;
                                          if (v36 + v37 >= v150 >> 3)
                                          {
                                            v151 = v150 >> 3;
                                            v152 = *(_QWORD **)a7;
                                            v153 = *(_DWORD *)(a7 + 12);
                                            v154 = *(_QWORD *)a7 + 72 * v153;
                                            *(_QWORD *)v154 = *((_QWORD *)&v437 + 1);
                                            *(_DWORD *)(a7 + 16) += *(_DWORD *)(v154 + 68) - *(_DWORD *)(v154 + 64) + 1;
                                            *(_QWORD *)(v154 + 8) = v36 + v37 - v151;
                                            v155 = (v153 + 1);
                                            *(_DWORD *)(a7 + 12) = v155;
                                            if ((v153 & 0x80000000) == 0)
                                            {
                                              v156 = 0;
                                              v157 = v151 + v430;
                                              do
                                              {
                                                v158 = (char *)&v152[9 * v156];
                                                v159 = *((int *)v158 + 16);
                                                v160 = *((int *)v158 + 17);
                                                if ((int)v159 <= (int)v160)
                                                {
                                                  v162 = (unsigned __int8 *)v152[9 * v156];
                                                  v161 = v152[9 * v156 + 1];
                                                  do
                                                  {
                                                    if (v159 == v160)
                                                    {
                                                      *(_QWORD *)(a7 + 8 * v160 + 536) = v161;
                                                      v163 = *(_QWORD *)(v12 + 3328);
                                                      v164 = v161;
                                                    }
                                                    else
                                                    {
                                                      v163 = *(_QWORD *)(v12 + 3328);
                                                      v165 = *(unsigned int *)(v163 + 524);
                                                      v166 = v161 >= v165;
                                                      v161 -= v165;
                                                      if (!v166)
                                                        return 4294954584;
                                                      if ((_DWORD)v165)
                                                      {
                                                        v167 = 0;
                                                        v168 = 0;
                                                        v169 = (v165 - 1);
                                                        v170 = v162;
                                                        do
                                                        {
                                                          v171 = *v170++;
                                                          v168 |= (v171 << v167);
                                                          v167 += 8;
                                                          LODWORD(v165) = v165 - 1;
                                                        }
                                                        while ((_DWORD)v165);
                                                        v162 += v169 + 1;
                                                      }
                                                      else
                                                      {
                                                        v168 = 0;
                                                      }
                                                      v164 = v168 + 1;
                                                      if (v164 > v161)
                                                        return 4294954584;
                                                      *(_QWORD *)(a7 + 8 * v159 + 536) = v164;
                                                    }
                                                    if (v159 < 1)
                                                    {
                                                      v173 = (v157 + *(_DWORD *)(v163 + 524));
                                                      v174 = v159;
                                                    }
                                                    else
                                                    {
                                                      if (v159 == v160)
                                                        v172 = 0;
                                                      else
                                                        v172 = *(unsigned int *)(v163 + 524);
                                                      v173 = *(_QWORD *)(a7 + 8 * (v159 - 1) + 536)
                                                           + *(_QWORD *)(a7 + 8 * (v159 - 1) + 24)
                                                           + v172;
                                                      v174 = v159;
                                                    }
                                                    v162 += v164;
                                                    v161 -= v164;
                                                    *(_QWORD *)(a7 + 8 * v174 + 24) = v173;
                                                    ++v159;
                                                  }
                                                  while ((_DWORD)v160 + 1 != (_DWORD)v159);
                                                }
                                                ++v156;
                                              }
                                              while (v156 != v155);
                                            }
                                            v19 = 0;
                                            v30 |= 8u;
                                            goto LABEL_810;
                                          }
                                          v19 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
                                          goto LABEL_814;
                                        }
                                      }
                                    }
                                    return 4294954584;
                                  }
                                }
                                else
                                {
                                  *(_DWORD *)(v14 + 224) = 0;
                                  v45 = uleb128;
                                }
                                *(_OWORD *)(v14 + 192) = 0u;
                                *(_OWORD *)(v14 + 208) = 0u;
                                *(_OWORD *)(v14 + 160) = 0u;
                                *(_OWORD *)(v14 + 176) = 0u;
                                *(_OWORD *)(v14 + 128) = 0u;
                                *(_OWORD *)(v14 + 144) = 0u;
                                *(_OWORD *)(v14 + 96) = 0u;
                                *(_OWORD *)(v14 + 112) = 0u;
                                *(_OWORD *)(v14 + 64) = 0u;
                                *(_OWORD *)(v14 + 80) = 0u;
                                *(_OWORD *)(v14 + 32) = 0u;
                                *(_OWORD *)(v14 + 48) = 0u;
                                *(_OWORD *)v14 = 0u;
                                *(_OWORD *)(v14 + 16) = 0u;
                                goto LABEL_586;
                              }
                              *(_DWORD *)(v14 + 1384) = 8;
LABEL_503:
                              a7 = v429;
                              goto LABEL_504;
                            }
LABEL_502:
                            *(_DWORD *)(v14 + 1372) = 0;
                            *(_QWORD *)(v14 + 1376) = 0;
                            goto LABEL_503;
                          }
                          if (1 << v332 <= 1)
                            v333 = 1;
                          else
                            v333 = (1 << v332);
                          v334 = (_DWORD *)(v14 + 1340);
                          do
                          {
                            *(v334 - 8) = av1_get_bits((uint64_t)&v436, 6u);
                            if (!v227[271])
                              *v334 = av1_get_bits((uint64_t)&v436, 6u);
                            ++v334;
                            --v333;
                          }
                          while (v333);
LABEL_498:
                          if (v279 && !*(_DWORD *)(v14 + 456))
                            goto LABEL_502;
                          goto LABEL_500;
                        }
LABEL_497:
                        *(_QWORD *)(v14 + 1304) = 0;
                        *(_DWORD *)(v14 + 1340) = 0;
                        goto LABEL_498;
                      }
                      v324 = 8;
                      do
                      {
                        if (av1_get_bits((uint64_t)&v436, 1u))
                          av1_get_bits((uint64_t)&v436, 7u);
                        --v324;
                      }
                      while (v324);
                      v325 = 1;
                      do
                      {
                        v326 = v325;
                        if (av1_get_bits((uint64_t)&v436, 1u))
                          av1_get_bits((uint64_t)&v436, 7u);
                        v325 = 0;
                      }
                      while ((v326 & 1) != 0);
                    }
                    if (v279)
                      goto LABEL_497;
                    goto LABEL_495;
                  }
LABEL_475:
                  *(_DWORD *)(v14 + 1216) = 0;
                  goto LABEL_476;
                }
LABEL_474:
                *(_DWORD *)(v14 + 1212) = 0;
                goto LABEL_475;
              }
LABEL_473:
              *(_DWORD *)(v14 + 1208) = 0;
              goto LABEL_474;
            }
          }
          v259 = 0;
          *(_QWORD *)(v14 + 1136) = 0xFFFFFFFF00000000;
          v260 = (_DWORD *)(v14 + 908);
          do
          {
            if (av1_get_bits((uint64_t)&v436, 1u))
            {
              v261 = (int)(av1_get_bits((uint64_t)&v436, 9u) << 23) >> 23;
              *(_DWORD *)(v14 + 1140) = v259;
            }
            else
            {
              v261 = 0;
            }
            *(v260 - 7) = v261;
            if (av1_get_bits((uint64_t)&v436, 1u))
            {
              v262 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
              *(_DWORD *)(v14 + 1140) = v259;
            }
            else
            {
              v262 = 0;
            }
            *(v260 - 6) = v262;
            if (av1_get_bits((uint64_t)&v436, 1u))
            {
              v263 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
              *(_DWORD *)(v14 + 1140) = v259;
            }
            else
            {
              v263 = 0;
            }
            *(v260 - 5) = v263;
            if (av1_get_bits((uint64_t)&v436, 1u))
            {
              v264 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
              *(_DWORD *)(v14 + 1140) = v259;
            }
            else
            {
              v264 = 0;
            }
            *(v260 - 4) = v264;
            if (av1_get_bits((uint64_t)&v436, 1u))
            {
              v265 = (int)(av1_get_bits((uint64_t)&v436, 7u) << 25) >> 25;
              *(_DWORD *)(v14 + 1140) = v259;
            }
            else
            {
              v265 = 0;
            }
            *(v260 - 3) = v265;
            if (av1_get_bits((uint64_t)&v436, 1u))
            {
              v266 = av1_get_bits((uint64_t)&v436, 3u);
              *(_DWORD *)(v14 + 1140) = v259;
              *(_DWORD *)(v14 + 1136) = 1;
            }
            else
            {
              v266 = -1;
            }
            *(v260 - 2) = v266;
            v267 = av1_get_bits((uint64_t)&v436, 1u);
            *(v260 - 1) = v267;
            if (v267)
            {
              *(_DWORD *)(v14 + 1140) = v259;
              *(_DWORD *)(v14 + 1136) = 1;
            }
            v268 = av1_get_bits((uint64_t)&v436, 1u);
            *v260 = v268;
            if (v268)
            {
              *(_DWORD *)(v14 + 1140) = v259;
              *(_DWORD *)(v14 + 1136) = 1;
            }
            ++v259;
            v260 += 8;
          }
          while (v259 != 8);
        }
        else
        {
          v256 = 0;
          *(_QWORD *)(v14 + 1136) = 0;
          *(_OWORD *)(v14 + 1120) = 0u;
          *(_OWORD *)(v14 + 1104) = 0u;
          *(_OWORD *)(v14 + 1088) = 0u;
          *(_OWORD *)(v14 + 1072) = 0u;
          *(_OWORD *)(v14 + 1056) = 0u;
          *(_OWORD *)(v14 + 1040) = 0u;
          *(_OWORD *)(v14 + 1008) = 0u;
          *(_OWORD *)(v14 + 1024) = 0u;
          *(_OWORD *)(v14 + 976) = 0u;
          *(_OWORD *)(v14 + 992) = 0u;
          *(_OWORD *)(v14 + 944) = 0u;
          *(_OWORD *)(v14 + 960) = 0u;
          *(_OWORD *)(v14 + 912) = 0u;
          *(_OWORD *)(v14 + 928) = 0u;
          *(_OWORD *)(v14 + 880) = 0u;
          *(_OWORD *)(v14 + 896) = 0u;
          do
          {
            *(_DWORD *)(v14 + 900 + v256) = -1;
            v256 += 32;
          }
          while (v256 != 256);
        }
        if (v240)
          goto LABEL_467;
        goto LABEL_473;
      }
      *(_DWORD *)(v14 + 464) = 0;
      v12 = v77;
      v86 = v435;
      if (v85 == 3)
        v91 = 255;
      else
        v91 = av1_get_bits((uint64_t)&v436, 8u);
      *(_DWORD *)(v14 + 440) = v91;
      if (v42)
      {
        if (!v75)
          goto LABEL_222;
        v92 = *(_DWORD *)(v435 + 1060);
        v93 = 8;
        do
        {
          av1_get_bits((uint64_t)&v436, v92);
          --v93;
        }
        while (v93);
      }
      if (v75)
      {
        v94 = av1_get_bits((uint64_t)&v436, 1u);
        v95 = v94 != 0;
        *(_DWORD *)(v14 + 468) = v95;
        if (v94)
        {
          v96 = av1_get_bits((uint64_t)&v436, 3u);
          *(_DWORD *)(v14 + 472) = v96;
          *(_QWORD *)(v14 + 476) = -1;
          v97 = av1_get_bits((uint64_t)&v436, 3u);
          v98 = 0;
          *(_DWORD *)(v14 + 484) = v97;
          *(_DWORD *)(v14 + 496) = -1;
          *(_QWORD *)(v14 + 488) = -1;
          v99 = *(_DWORD *)(v435 + 1060);
          v100 = 1 << (v99 - 1);
          v101 = (_DWORD *)(v77 + 3440);
          do
          {
            if (!*((_QWORD *)v101 - 1))
              return 4294954584;
            if (v99)
              v102 = ((*v101 - v76) & (v100 - 1)) - ((*v101 - v76) & v100);
            else
              v102 = 0;
            *(_DWORD *)((char *)&v442 + v98) = v102 + v100;
            v98 += 4;
            v101 += 82;
          }
          while (v98 != 32);
          v103 = 0;
          v439 = 0u;
          v440 = 0u;
          *((_DWORD *)&v439 + v96) = 1;
          *((_DWORD *)&v439 + v97) = 1;
          v104 = -1;
          v105 = -1;
          do
          {
            v106 = *((_DWORD *)&v442 + v103);
            if (*((_DWORD *)&v439 + v103))
              v107 = 1;
            else
              v107 = v106 < v100;
            if (!v107 && v106 >= v105)
            {
              *(_DWORD *)(v14 + 496) = v103;
              v104 = v103;
              v105 = v106;
            }
            ++v103;
          }
          while (v103 != 8);
          if (v105 != -1)
            *((_DWORD *)&v439 + v104) = 1;
          v109 = 0;
          v110 = 0x7FFFFFFF;
          v111 = -1;
          do
          {
            v112 = *((_DWORD *)&v442 + v109);
            if (*((_DWORD *)&v439 + v109))
              v113 = 1;
            else
              v113 = v112 < v100;
            if (!v113 && v112 < v110)
            {
              *(_DWORD *)(v14 + 488) = v109;
              v111 = v109;
              v110 = v112;
            }
            ++v109;
          }
          while (v109 != 8);
          if (v110 != 0x7FFFFFFF)
            *((_DWORD *)&v439 + v111) = 1;
          v115 = 0;
          v116 = 0x7FFFFFFF;
          v117 = -1;
          do
          {
            v118 = *((_DWORD *)&v442 + v115);
            if (*((_DWORD *)&v439 + v115))
              v119 = 1;
            else
              v119 = v118 < v100;
            if (!v119 && v118 < v116)
            {
              *(_DWORD *)(v14 + 492) = v115;
              v117 = v115;
              v116 = v118;
            }
            ++v115;
          }
          while (v115 != 8);
          if (v116 != 0x7FFFFFFF)
            *((_DWORD *)&v439 + v117) = 1;
          for (n = 1; n != 7; ++n)
          {
            v122 = v14 + 4 * n;
            v123 = *(_DWORD *)(v122 + 472);
            if (v123 < 0)
            {
              v124 = 0;
              v125 = (_DWORD *)(v122 + 472);
              v126 = -1;
              do
              {
                v127 = *((_DWORD *)&v442 + v124);
                if (*((_DWORD *)&v439 + v124))
                  v128 = 0;
                else
                  v128 = v127 < v100;
                if (v128 && v127 >= v126)
                {
                  *v125 = v124;
                  v123 = v124;
                  v126 = v127;
                }
                ++v124;
              }
              while (v124 != 8);
              if (v126 != -1)
                *((_DWORD *)&v439 + v123) = 1;
            }
          }
          v130 = 0;
          v131 = 0x7FFFFFFF;
          v132 = -1;
          do
          {
            if (*((_DWORD *)&v442 + v130) < v131)
            {
              v131 = *((_DWORD *)&v442 + v130);
              v132 = v130;
            }
            ++v130;
          }
          while (v130 != 8);
          v133 = 0;
          v134 = v14 + 472;
          do
          {
            if ((*(_DWORD *)(v134 + v133) & 0x80000000) != 0)
              *(_DWORD *)(v134 + v133) = v132;
            v133 += 4;
          }
          while (v133 != 28);
          v135 = v84;
        }
        else
        {
          v135 = v84;
          v95 = 0;
        }
LABEL_286:
        for (ii = 472; ii != 500; ii += 4)
        {
          if (!v95)
            *(_DWORD *)(v14 + ii) = av1_get_bits((uint64_t)&v436, 3u);
          if (*(_DWORD *)(v435 + 1000))
          {
            v186 = av1_get_bits((uint64_t)&v436, *(_DWORD *)(v435 + 1004));
            v187 = *(_QWORD *)(v12 + 328 * *(int *)(v14 + ii) + 3432);
            if (!v187
              || *(_DWORD *)(v187 + 268) != ((*(_DWORD *)(v14 + 268) + (1 << *(_DWORD *)(v435 + 1008)) + ~v186) & ((1 << *(_DWORD *)(v435 + 1008)) - 1)))
            {
              return 4294954584;
            }
          }
        }
        if (v421)
          v188 = v135;
        else
          v188 = 0;
        read_frame_size(v12, (uint64_t)&v436, (_DWORD *)v14, (_DWORD *)v435, v188);
        if (*(_DWORD *)(v14 + 296))
          v189 = 0;
        else
          v189 = av1_get_bits((uint64_t)&v436, 1u) != 0;
        *(_DWORD *)(v14 + 500) = v189;
        if (av1_get_bits((uint64_t)&v436, 1u))
          v190 = 4;
        else
          v190 = av1_get_bits((uint64_t)&v436, 2u);
        *(_DWORD *)(v14 + 504) = v190;
        *(_DWORD *)(v14 + 508) = av1_get_bits((uint64_t)&v436, 1u);
        if (!*(_DWORD *)(v14 + 284))
        {
          v177 = *(_DWORD *)(v435 + 1048);
          if (!v177)
            goto LABEL_304;
          v177 = *(_DWORD *)(v435 + 1040);
          if (!v177)
            goto LABEL_304;
          if ((*(_BYTE *)v426 & 1) != 0)
          {
            v177 = av1_get_bits((uint64_t)&v436, 1u) != 0;
            goto LABEL_304;
          }
        }
        v177 = 0;
        goto LABEL_304;
      }
LABEL_222:
      v135 = !v42;
      v95 = 0;
      *(_DWORD *)(v14 + 468) = 0;
      goto LABEL_286;
    default:
      v19 = 0;
      v30 = 0x40000000;
      goto LABEL_810;
  }
}

uint64_t FigAV1Bridge_Getav1CStartAndLength(const __CFData *a1, const UInt8 **a2, unint64_t *a3)
{
  const UInt8 *BytePtr;
  unint64_t Length;

  if (!a1)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (Length <= 3)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (a2)
    *a2 = BytePtr;
  if (a3)
    *a3 = Length;
  return 0;
}

uint64_t FigAV1Bridge_GetSeqOBU_VUI_NCLC(char *a1, unint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v6;
  uint64_t Instance;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _OWORD v17[3];
  int v18;

  v18 = 0;
  memset(v17, 0, sizeof(v17));
  if (!a1 || a2 <= 3)
  {
    v6 = 4294954584;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v6 = 4294954583;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  v13 = (_DWORD *)Instance;
  v16 = 0;
  v14 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v16, &v18, (unsigned int *)v17);
  if ((_DWORD)v14)
  {
    v15 = v14;
  }
  else if ((v18 & 2) != 0)
  {
    if (a3)
      *a3 = v13[8];
    if (a4)
      *a4 = v13[9];
    v15 = 0;
    if (a5)
      *a5 = v13[10];
  }
  else
  {
    v15 = 4294954584;
  }
  CFRelease(v13);
  return v15;
}

uint64_t FigAV1Bridge_GetSeqOBU_VUI_AspectRatio(char *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v5;
  uint64_t Instance;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _OWORD v15[3];
  int v16;

  v16 = 0;
  memset(v15, 0, sizeof(v15));
  if (!a1 || a2 <= 3)
  {
    v5 = 4294954584;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v5 = 4294954583;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  v11 = (_DWORD *)Instance;
  v14 = 0;
  v12 = FigAV1Bridge_parseav1c(a1, a2, Instance + 3184, Instance + 16, Instance + 1504, &v14, &v16, (unsigned int *)v15);
  if ((_DWORD)v12)
  {
    v13 = v12;
  }
  else if ((v16 & 4) != 0)
  {
    if (*a3)
      *a3 = v11[435] * v11[487];
    v13 = 0;
    if (*a4)
      *a4 = v11[437] * v11[488];
  }
  else
  {
    v13 = 4294954584;
  }
  CFRelease(v11);
  return v13;
}

uint64_t FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence(uint64_t a1, unint64_t a2, CFIndex *a3, CFDataRef *a4)
{
  unint64_t v4;
  uint64_t v7;
  uint64_t Instance;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  CFIndex v13;
  const __CFAllocator *v14;
  const UInt8 *v15;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  CFDataRef v17;
  void *v18;
  unsigned int v20;
  int v21;

  v21 = 0;
  if (!a1)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  v4 = a2;
  if (!a2)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  if (!a4)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  v7 = a1;
  if (a3)
    *a3 = 0;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  v9 = (_QWORD *)Instance;
  if (!Instance)
  {
LABEL_27:
    v12 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_24;
  }
  v10 = 0;
  *(_QWORD *)(Instance + 6584) = 0;
  do
  {
    v20 = 0;
    v11 = FigAV1Bridge_parseOBU(v7, v4, v10, (uint64_t)(v9 + 398), (uint64_t)(v9 + 2), (uint64_t)(v9 + 188), 0, 86, 0, &v20, &v21);
    if ((_DWORD)v11)
    {
      v12 = v11;
      goto LABEL_24;
    }
    if (v4 < v20)
      break;
    if (!v20)
    {
      v12 = 4294954582;
      goto LABEL_24;
    }
    if ((v21 & 0x40) != 0)
      break;
    v7 += v20;
    v10 += v20;
    v4 -= v20;
  }
  while (v4);
  v12 = 0;
  v13 = v9[821];
  if (v13)
  {
    if (a3)
    {
      *a3 = v13;
      v13 = v9[821];
      if (!v13)
      {
        v12 = 0;
        goto LABEL_24;
      }
    }
    v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v15 = (const UInt8 *)v9[823];
    GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    v17 = CFDataCreateWithBytesNoCopy(v14, v15, v13, GlobalCFAllocatorFigMalloc);
    if (v17)
    {
      v12 = 0;
      v9[823] = 0;
      *a4 = v17;
      goto LABEL_24;
    }
    goto LABEL_27;
  }
LABEL_24:
  v18 = (void *)v9[823];
  if (v18)
  {
    v9[823] = 0;
    free(v18);
  }
  CFRelease(v9);
  return v12;
}

uint64_t FigAV1Bridge_CopyITU_T_T35MetadataHDR10PlusMetadata(uint64_t a1, unint64_t a2, CFDataRef *a3)
{
  unint64_t v3;
  uint64_t v5;
  uint64_t Instance;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  CFIndex v11;
  const __CFAllocator *v12;
  const UInt8 *v13;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  CFDataRef v15;
  void *v16;
  unsigned int v18;
  int v19;

  v19 = 0;
  if (!a1)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  v3 = a2;
  if (!a2)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  if (!a3)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  v5 = a1;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  v7 = (_QWORD *)Instance;
  if (!Instance)
  {
LABEL_22:
    v10 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  v8 = 0;
  *(_QWORD *)(Instance + 6584) = 0;
  do
  {
    v18 = 0;
    v9 = FigAV1Bridge_parseOBU(v5, v3, v8, (uint64_t)(v7 + 398), (uint64_t)(v7 + 2), (uint64_t)(v7 + 188), 0, 146, 0, &v18, &v19);
    if ((_DWORD)v9)
    {
      v10 = v9;
      goto LABEL_19;
    }
    if (v3 < v18)
      break;
    if (!v18)
    {
      v10 = 4294954582;
      goto LABEL_19;
    }
    if ((v19 & 0x80) != 0)
      break;
    v5 += v18;
    v8 += v18;
    v3 -= v18;
  }
  while (v3);
  v10 = 0;
  v11 = v7[821];
  if (v11)
  {
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v13 = (const UInt8 *)v7[823];
    GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    v15 = CFDataCreateWithBytesNoCopy(v12, v13, v11, GlobalCFAllocatorFigMalloc);
    if (v15)
    {
      v10 = 0;
      v7[823] = 0;
      *a3 = v15;
      goto LABEL_19;
    }
    goto LABEL_22;
  }
LABEL_19:
  v16 = (void *)v7[823];
  if (v16)
  {
    v7[823] = 0;
    free(v16);
  }
  CFRelease(v7);
  return v10;
}

uint64_t FigAV1Bridge_CopyCLLIDataFromAV1ConfigurationRecordConfigOBU(const __CFData *a1, CFDataRef *a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v6;
  uint64_t Instance;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  const UInt8 *v12;
  const __CFAllocator *v13;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  CFDataRef v15;
  void *v16;
  unsigned int v18;
  int v19;

  v19 = 0;
  if (!a1)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (!Length)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  if (!a2)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  v6 = Length;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  v8 = (_QWORD *)Instance;
  if (Instance)
  {
    v9 = 0;
    *(_QWORD *)(Instance + 6528) = 0;
    do
    {
      v18 = 0;
      v10 = FigAV1Bridge_parseOBU((uint64_t)BytePtr, v6, v9, (uint64_t)(v8 + 398), (uint64_t)(v8 + 2), (uint64_t)(v8 + 188), 0, 274, 0, &v18, &v19);
      if ((_DWORD)v10)
      {
        v11 = v10;
LABEL_19:
        *a2 = 0;
        goto LABEL_20;
      }
      if (v6 < v18)
        break;
      if (!v18)
      {
        v11 = 4294954582;
        goto LABEL_19;
      }
      if ((v19 & 0x100) != 0)
        break;
      BytePtr += v18;
      v9 += v18;
      v6 -= v18;
    }
    while (v6);
    v11 = 0;
    v12 = (const UInt8 *)v8[816];
    if (!v12)
      goto LABEL_19;
    v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    v15 = CFDataCreateWithBytesNoCopy(v13, v12, 4, GlobalCFAllocatorFigMalloc);
    if (!v15)
      goto LABEL_23;
    v11 = 0;
    v8[816] = 0;
    *a2 = v15;
  }
  else
  {
LABEL_23:
    v11 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
LABEL_20:
  v16 = (void *)v8[816];
  if (v16)
  {
    v8[816] = 0;
    free(v16);
  }
  CFRelease(v8);
  return v11;
}

uint64_t FigAV1Bridge_CopyMDCVDataFromAV1ConfigurationRecordConfigOBU(const __CFData *a1, CFDataRef *a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v6;
  uint64_t Instance;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  const UInt8 *v12;
  const __CFAllocator *v13;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  CFDataRef v15;
  void *v16;
  unsigned int v18;
  int v19;

  v19 = 0;
  if (!a1)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (!Length)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  if (!a2)
    FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1();
  v6 = Length;
  if (FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce != -1)
    dispatch_once_f(&FigAV1BridgeParsingStateGetTypeID_sRegisterFigAV1BridgeParsingStateTypeOnce, &FigAV1BridgeParsingStateGetTypeID_sFigAV1BridgeParsingStateTypeID, (dispatch_function_t)RegisterFigAV1BridgeParsingStateType);
  Instance = _CFRuntimeCreateInstance();
  v8 = (_QWORD *)Instance;
  if (Instance)
  {
    v9 = 0;
    *(_QWORD *)(Instance + 6544) = 0;
    do
    {
      v18 = 0;
      v10 = FigAV1Bridge_parseOBU((uint64_t)BytePtr, v6, v9, (uint64_t)(v8 + 398), (uint64_t)(v8 + 2), (uint64_t)(v8 + 188), 0, 530, 0, &v18, &v19);
      if ((_DWORD)v10)
      {
        v11 = v10;
LABEL_19:
        *a2 = 0;
        goto LABEL_20;
      }
      if (v6 < v18)
        break;
      if (!v18)
      {
        v11 = 4294954582;
        goto LABEL_19;
      }
      if ((v19 & 0x200) != 0)
        break;
      BytePtr += v18;
      v9 += v18;
      v6 -= v18;
    }
    while (v6);
    v11 = 0;
    v12 = (const UInt8 *)v8[818];
    if (!v12)
      goto LABEL_19;
    v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    v15 = CFDataCreateWithBytesNoCopy(v13, v12, 24, GlobalCFAllocatorFigMalloc);
    if (!v15)
      goto LABEL_23;
    v11 = 0;
    v8[818] = 0;
    *a2 = v15;
  }
  else
  {
LABEL_23:
    v11 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
LABEL_20:
  v16 = (void *)v8[818];
  if (v16)
  {
    v8[818] = 0;
    free(v16);
  }
  CFRelease(v8);
  return v11;
}

void FigAV1BridgeParsingState_Init(uint64_t a1)
{
  bzero((void *)(a1 + 16), 0x2410uLL);
}

__CFString *FigAV1BridgeParsingState_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigAV1BridgeParsingState %p"), a1);
  return Mutable;
}

unint64_t av1_get_bits(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  int v3;
  unsigned int v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  unsigned __int8 *v8;
  unint64_t v9;

  if (a2 - 33 >= 0xFFFFFFE0)
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (v4 >= a2)
    {
      v3 = 0;
    }
    else if (v4 > 0x38)
    {
      v3 = -12714;
    }
    else
    {
      v5 = 0;
      v6 = *(_QWORD *)(a1 + 40);
      v7 = *(_DWORD *)(a1 + 4);
      v8 = *(unsigned __int8 **)(a1 + 24);
      do
      {
        v5 <<= 8;
        v4 += 8;
        *(_DWORD *)(a1 + 16) = v4;
        if (!v7)
        {
          *(_QWORD *)(a1 + 24) = v8 + 1;
          v5 |= *v8++;
        }
        if ((unint64_t)v8 >= v6)
        {
          *(_DWORD *)a1 = v7;
          v7 = 1;
          *(_DWORD *)(a1 + 4) = 1;
        }
      }
      while (v4 < a2);
      v3 = 0;
      *(_QWORD *)(a1 + 8) |= v5 << -(char)v4;
    }
    v9 = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 16) = v4 - a2;
    *(_QWORD *)(a1 + 8) = v9 << a2;
    v2 = v9 >> -(char)a2;
  }
  else
  {
    v2 = 0;
    v3 = -12714;
  }
  *(_DWORD *)a1 = v3;
  return v2;
}

unint64_t av1_get_uleb128(_DWORD *a1)
{
  unint64_t v2;
  unint64_t v3;
  char bits;
  BOOL v5;

  v2 = 0;
  v3 = 0;
  do
  {
    bits = av1_get_bits((uint64_t)a1, 8u);
    v3 |= (unint64_t)(bits & 0x7F) << v2;
    if ((bits & 0x80) == 0)
      break;
    v5 = v2 >= 0x31;
    v2 += 7;
  }
  while (!v5);
  if (bits < 0 || HIDWORD(v3))
    *a1 = -12714;
  return v3;
}

uint64_t check_for_overrun(_DWORD *a1, unsigned int a2, int a3)
{
  unsigned int v3;
  BOOL v4;
  unsigned int v5;

  if (*a1)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v3 = 8 * (a1[6] - a1[8]) - a1[4];
  v4 = v3 >= a2;
  v5 = v3 - a2;
  if (!v4)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (v5 <= 8 * a3)
    return 0;
  return 4294954584;
}

uint64_t dav1d_submit_frame(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _OWORD *v6;
  uint64_t i;
  uint64_t result;
  _DWORD *v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  char v13;
  _DWORD *v14;
  int v15;
  signed int v16;
  unsigned int v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;

  v2 = *(_QWORD *)(a1 + 3312);
  v3 = *(_QWORD *)(a1 + 3304) + 40;
  *(_QWORD *)a1 = v3;
  *(_QWORD *)(a1 + 8) = v2;
  v4 = *(_QWORD *)(a1 + 3328);
  v5 = *(_QWORD *)(a1 + 3320);
  *(_QWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 24) = v4;
  v6 = (_OWORD *)(a1 + 2264);
  if (picture_alloc_with_edges(a1 + 2264, *(_DWORD *)(v4 + 240), *(_DWORD *)(v4 + 244), v2, v3, v4, v5, *(_QWORD *)(a1 + 3336), *(_QWORD *)(a1 + 3352), a1 + 3376, *(_QWORD *)(a1 + 3368), 2 * *(_DWORD *)(v2 + 32) + 8))
  {
LABEL_2:
    for (i = 0; i != 1960; i += 280)
    {
      if (*(_QWORD *)(a1 + i + 56))
        dav1d_picture_unref_internal((_OWORD *)(a1 + i + 32));
    }
    *(_OWORD *)(a1 + 2232) = 0u;
    *(_OWORD *)(a1 + 2248) = 0u;
    *(_OWORD *)(a1 + 2200) = 0u;
    *(_OWORD *)(a1 + 2216) = 0u;
    *(_OWORD *)(a1 + 2168) = 0u;
    *(_OWORD *)(a1 + 2184) = 0u;
    *(_OWORD *)(a1 + 2136) = 0u;
    *(_OWORD *)(a1 + 2152) = 0u;
    *(_OWORD *)(a1 + 2104) = 0u;
    *(_OWORD *)(a1 + 2120) = 0u;
    *(_OWORD *)(a1 + 2072) = 0u;
    *(_OWORD *)(a1 + 2088) = 0u;
    *(_OWORD *)(a1 + 2040) = 0u;
    *(_OWORD *)(a1 + 2056) = 0u;
    *(_OWORD *)(a1 + 2008) = 0u;
    *(_OWORD *)(a1 + 2024) = 0u;
    *(_OWORD *)(a1 + 1992) = 0u;
    result = (uint64_t)dav1d_picture_unref_internal(v6);
    *(_DWORD *)(a1 + 2948) = 0;
    return result;
  }
  *(_QWORD *)(a1 + 3400) = 0;
  *(_DWORD *)(a1 + 2540) = *(_DWORD *)(a1 + 6056);
  *(_DWORD *)(a1 + 6056) = 0;
  v9 = *(_DWORD **)(a1 + 24);
  *(_DWORD *)(a1 + 2536) = v9[69];
  v10 = v9[59];
  v11 = (_QWORD *)(a1 + 1992);
  if (v10 == v9[60])
  {
    result = dav1d_picture_ref(v11, v6);
    if ((_DWORD)result)
      goto LABEL_2;
  }
  else
  {
    result = picture_alloc_with_edges((uint64_t)v11, v10, *(_DWORD *)(a1 + 2332), *(_QWORD *)(a1 + 2264), *(_QWORD *)(a1 + 2456), *(_QWORD *)(a1 + 2272), *(_QWORD *)(a1 + 2448), *(_QWORD *)(a1 + 2464), *(_QWORD *)(a1 + 2472), *(_QWORD *)(a1 + 2408), *(_QWORD *)(a1 + 2480), *(_DWORD *)(a1 + 2340));
    if ((_DWORD)result)
      goto LABEL_2;
  }
  v12 = 0;
  v13 = 0;
  v14 = *(_DWORD **)(a1 + 24);
  *(_DWORD *)(a1 + 3096) = (v14[59] + 3) >> 2;
  v15 = v14[61];
  *(_DWORD *)(a1 + 3100) = (v15 + 3) >> 2;
  v16 = ((v14[59] + 7) >> 2) & 0xFFFFFFFE;
  *(_DWORD *)(a1 + 3104) = v16;
  v17 = ((v15 + 7) >> 2) & 0xFFFFFFFE;
  *(_DWORD *)(a1 + 3108) = v17;
  v16 += 31;
  *(_DWORD *)(a1 + 3112) = v16 >> 5;
  *(_DWORD *)(a1 + 3116) = (int)(v17 + 31) >> 5;
  v18 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 1012);
  v19 = 16 << v18;
  *(_DWORD *)(a1 + 3128) = 16 << v18;
  v18 += 4;
  *(_DWORD *)(a1 + 3124) = v18;
  *(_DWORD *)(a1 + 3120) = (int)(v17 + v19 - 1) >> v18;
  *(_QWORD *)(a1 + 3088) = (int)(v16 & 0xFFFFFFE0);
  *(_DWORD *)(a1 + 3288) = ~(-1 << *(_DWORD *)(a1 + 2068));
  v20 = v14[110];
  do
  {
    if (((v20 >> v13) & 1) != 0)
    {
      if (*(_QWORD *)(a1 + v12 + 3448))
        dav1d_picture_unref_internal((_OWORD *)(a1 + v12 + 3424));
      result = dav1d_picture_ref((_QWORD *)(a1 + v12 + 3424), v6);
      *(_QWORD *)(a1 + v12 + 3696) = *(_QWORD *)(a1 + 2536);
      v21 = *(_QWORD *)(a1 + 24);
      if (v21)
        *(_DWORD *)(a1 + v12 + 3440) = *(_DWORD *)(*(_QWORD *)(a1 + 3328) + 248);
      v22 = a1 + v12;
      *(_QWORD *)(a1 + v12 + 3704) = *(_QWORD *)(a1 + 2672);
      if (!*(_DWORD *)(v21 + 464))
        *(_QWORD *)(v22 + 3712) = *(_QWORD *)(a1 + 2544);
      *(_OWORD *)(v22 + 3720) = *(_OWORD *)(a1 + 2704);
      *(_OWORD *)(v22 + 3732) = *(_OWORD *)(a1 + 2716);
    }
    ++v13;
    v12 += 328;
  }
  while (v12 != 2624);
  return result;
}

unint64_t read_frame_size(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int a5)
{
  uint64_t v9;
  unint64_t result;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int bits;
  int v17;
  int v18;
  int v19;

  if (a5)
  {
    v9 = 472;
    while (1)
    {
      result = av1_get_bits(a2, 1u);
      if ((_DWORD)result)
        break;
      v9 += 4;
      if ((_DWORD)v9 == 500)
        goto LABEL_5;
    }
    v12 = a1 + 328 * *(int *)(*(_QWORD *)(a1 + 3328) + v9);
    v13 = *(_DWORD *)(v12 + 3488);
    a3[60] = v13;
    a3[61] = *(_DWORD *)(v12 + 3492);
    v14 = *(_QWORD *)(v12 + 3432);
    a3[111] = *(_DWORD *)(v14 + 444);
    a3[112] = *(_DWORD *)(v14 + 448);
    if (a4[266])
    {
      result = av1_get_bits(a2, 1u);
      a3[114] = result != 0;
      if ((_DWORD)result)
      {
        result = av1_get_bits(a2, 3u);
        a3[113] = result + 9;
        v15 = a3[60];
        v13 = (8 * v15 + (((int)result + 9) >> 1)) / ((int)result + 9);
        if (v15 >= 16)
          v15 = 16;
        if (v13 <= v15)
          v13 = v15;
        goto LABEL_28;
      }
      v13 = a3[60];
    }
    else
    {
      a3[114] = 0;
    }
    a3[113] = 8;
LABEL_28:
    a3[59] = v13;
    return result;
  }
LABEL_5:
  if (a3[75])
  {
    a3[60] = av1_get_bits(a2, a4[248]) + 1;
    v11 = av1_get_bits(a2, a4[249]) + 1;
  }
  else
  {
    a3[60] = a4[1];
    v11 = a4[2];
  }
  a3[61] = v11;
  if (a4[266])
  {
    bits = av1_get_bits(a2, 1u);
    a3[114] = bits != 0;
    if (bits)
    {
      v17 = av1_get_bits(a2, 3u);
      a3[113] = v17 + 9;
      v18 = a3[60];
      v19 = (8 * v18 + ((v17 + 9) >> 1)) / (v17 + 9);
      if (v18 >= 16)
        v18 = 16;
      if (v19 <= v18)
        v19 = v18;
      goto LABEL_22;
    }
  }
  else
  {
    a3[114] = 0;
  }
  a3[113] = 8;
  v19 = a3[60];
LABEL_22:
  a3[59] = v19;
  result = av1_get_bits(a2, 1u);
  a3[115] = result;
  if ((_DWORD)result)
  {
    a3[111] = av1_get_bits(a2, 0x10u) + 1;
    result = av1_get_bits(a2, 0x10u);
    a3[112] = result + 1;
  }
  else
  {
    *(_QWORD *)(a3 + 111) = *((_QWORD *)a3 + 30);
  }
  return result;
}

unint64_t av1_get_uniform(_DWORD *a1, unsigned int a2)
{
  unsigned int v3;
  unsigned int v4;
  unint64_t bits;

  if (a2 <= 1)
  {
    bits = 0;
    *a1 = -12714;
  }
  else
  {
    v3 = __clz(a2);
    v4 = (1 << -(char)v3) - a2;
    bits = av1_get_bits((uint64_t)a1, v3 ^ 0x1F);
    if (bits >= v4)
      return av1_get_bits((uint64_t)a1, 1u) - v4 + 2 * (_DWORD)bits;
  }
  return bits;
}

uint64_t av1_get_bits_subexp(_DWORD *a1, int a2, char a3)
{
  int v4;
  int v5;
  unsigned int v6;
  int v7;
  int uniform;
  unsigned int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;

  v4 = 1 << a3;
  v5 = (1 << a3) + a2;
  v6 = 2 << a3;
  if ((2 << a3) < 0x18)
  {
    v7 = 0;
LABEL_3:
    uniform = av1_get_uniform(a1, (v6 | 1) - v7);
    goto LABEL_11;
  }
  v7 = 0;
  if (av1_get_bits((uint64_t)a1, 1u))
  {
    v9 = 2;
    v10 = 8;
    while (1)
    {
      v7 += v10;
      if (v7 + (24 << (v9 - 2)) > v6)
        goto LABEL_3;
      v10 = 8 << (v9++ - 2);
      if (!av1_get_bits((uint64_t)a1, 1u))
        goto LABEL_10;
    }
  }
  v9 = 3;
LABEL_10:
  uniform = av1_get_bits((uint64_t)a1, v9);
LABEL_11:
  v11 = uniform + v7;
  v12 = 2 * v5;
  v13 = uniform + v7 + 1;
  v14 = v6 - v5 - (v13 >> 1);
  if (((uniform + v7) & 1) == 0)
    v14 = v6 - v5 + ((uniform + v7) >> 1);
  if (v11 <= 2 * (v6 - v5))
    v15 = v14;
  else
    v15 = uniform + v7;
  v16 = v6 - v15;
  v17 = v5 - (v13 >> 1);
  if ((v11 & 1) == 0)
    v17 = v5 + (v11 >> 1);
  if (v12 >= v11)
    v11 = v17;
  if (v12 > v6)
    v11 = v16;
  return v11 - v4;
}

uint64_t dav1d_picture_ref(_QWORD *a1, const void *a2)
{
  if (!a1 || a1[3] || !a2)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  memcpy(a1, a2, 0x110uLL);
  return 0;
}

_OWORD *dav1d_picture_unref_internal(_OWORD *result)
{
  if (!result)
    return (_OWORD *)FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  result[15] = 0u;
  result[16] = 0u;
  result[13] = 0u;
  result[14] = 0u;
  result[11] = 0u;
  result[12] = 0u;
  result[9] = 0u;
  result[10] = 0u;
  result[7] = 0u;
  result[8] = 0u;
  result[5] = 0u;
  result[6] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[1] = 0u;
  result[2] = 0u;
  *result = 0u;
  return result;
}

uint64_t picture_alloc_with_edges(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12)
{
  if ((a12 - 17) <= 0xFFFFFFEF)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  *(_DWORD *)(a1 + 64) = a2;
  *(_DWORD *)(a1 + 68) = a3;
  *(_QWORD *)a1 = a4;
  *(_QWORD *)(a1 + 8) = a6;
  *(_QWORD *)(a1 + 144) = a10;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(a1 + 76) = a12;
  *(_OWORD *)(a1 + 80) = xmmword_18EDDCD50;
  *(_QWORD *)(a1 + 96) = -1;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 184) = a7;
  *(_QWORD *)(a1 + 192) = a5;
  *(_QWORD *)(a1 + 200) = a8;
  *(_QWORD *)(a1 + 208) = a9;
  *(_QWORD *)(a1 + 216) = a11;
  return 0;
}

uint64_t OUTLINED_FUNCTION_0_0()
{
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLRequestInfoCreateMutable(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  __CFDictionary *Mutable;
  __CFDictionary *v6;
  uint64_t v8;

  if (a2)
  {
    if (a3)
    {
      Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v6 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("RequestInfoURL"), a2);
        *a3 = CFRetain(v6);
        CFRelease(v6);
        return 0;
      }
      v8 = 4294954510;
    }
    else
    {
      v8 = 4294954516;
    }
  }
  else
  {
    v8 = 4294954516;
  }
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLRequestInfoCreateMutableCopy(const __CFAllocator *a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v5;
  uint64_t v7;

  if (theDict)
  {
    if (a3)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(a1, 0, theDict);
      if (MutableCopy)
      {
        v5 = MutableCopy;
        *a3 = CFRetain(MutableCopy);
        CFRelease(v5);
        return 0;
      }
      v7 = 4294954510;
    }
    else
    {
      v7 = 4294954516;
    }
  }
  else
  {
    v7 = 4294954516;
  }
  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLRequestInfoSetByteRange(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = FigCFDictionarySetInt64(a1, CFSTR("RequestInfoByteRangeStart"), a2);
  if (!(_DWORD)result)
    return FigCFDictionarySetInt64(a1, CFSTR("RequestInfoByteRangeLength"), a3);
  return result;
}

uint64_t FigCustomURLRequestInfoSetHTTPHeaders(CFMutableDictionaryRef theDict, CFTypeRef cf)
{
  const __CFAllocator *v4;
  CFDictionaryRef Copy;
  CFDictionaryRef v6;

  if (!cf)
  {
    CFDictionaryRemoveValue(theDict, CFSTR("RequestInfoHTTPHeaders"));
    return 0;
  }
  v4 = CFGetAllocator(cf);
  Copy = CFDictionaryCreateCopy(v4, (CFDictionaryRef)cf);
  if (Copy)
  {
    v6 = Copy;
    CFDictionarySetValue(theDict, CFSTR("RequestInfoHTTPHeaders"), Copy);
    CFRelease(v6);
    return 0;
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLRequestInfoSetIsRenewalRequest(__CFDictionary *a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, CFSTR("RequestInfoIsRenewalRequest"), *v2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetIsPingRequest(__CFDictionary *a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, CFSTR("RequestInfoIsPingRequest"), *v2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetDefaultLatency(void *a1, uint64_t a2)
{
  FigCFDictionarySetInt64(a1, CFSTR("RequestInfoDefaultLatency"), a2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetExpectedToBlock(__CFDictionary *a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, CFSTR("RequestInfoExpectedToBlock"), *v2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetUserAgent(const __CFDictionary *a1, const void *a2)
{
  return figCustomURLRequestInfoReplaceValueForHTTPHeader(a1, CFSTR("User-Agent"), a2);
}

uint64_t figCustomURLRequestInfoReplaceValueForHTTPHeader(const __CFDictionary *a1, const void *a2, const void *a3)
{
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v8;
  __CFDictionary *MutableCopy;
  const __CFAllocator *v10;
  __CFDictionary *v11;
  CFDictionaryRef theDict;

  theDict = 0;
  v6 = FigCustomURLRequestInfoCopyHTTPHeaders(a1, (const void **)&theDict);
  if (!(_DWORD)v6)
  {
    v10 = CFGetAllocator(a1);
    MutableCopy = CFDictionaryCreateMutableCopy(v10, 0, theDict);
LABEL_5:
    v11 = MutableCopy;
    if (MutableCopy)
    {
      if (a3)
        CFDictionarySetValue(MutableCopy, a2, a3);
      else
        CFDictionaryRemoveValue(MutableCopy, a2);
      v7 = FigCustomURLRequestInfoSetHTTPHeaders(a1, v11);
      CFRelease(v11);
    }
    else
    {
      v7 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    goto LABEL_10;
  }
  v7 = v6;
  if ((_DWORD)v6 == -17360)
  {
    v8 = CFGetAllocator(a1);
    MutableCopy = CFDictionaryCreateMutable(v8, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_5;
  }
LABEL_10:
  if (theDict)
    CFRelease(theDict);
  return v7;
}

uint64_t FigCustomURLRequestInfoSetAcceptEncoding(const __CFDictionary *a1, const void *a2)
{
  return figCustomURLRequestInfoReplaceValueForHTTPHeader(a1, CFSTR("Accept-Encoding"), a2);
}

uint64_t FigCustomURLRequestInfoSetCryptor(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionarySetValue(a1, CFSTR("RequestInfoCryptor"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("RequestInfoCryptor"));
  return 0;
}

uint64_t FigCustomURLRequestInfoSetCryptorKeyAttributes(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionarySetValue(a1, CFSTR("RequestInfoCryptKeyAttributes"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("RequestInfoCryptKeyAttributes"));
  return 0;
}

uint64_t FigCustomURLRequestInfoSetCryptorID(void *a1, uint64_t a2)
{
  if (a2)
    FigCFDictionarySetInt64(a1, CFSTR("RequestInfoCryptorID"), a2);
  else
    CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, CFSTR("RequestInfoCryptorID"));
  return 0;
}

uint64_t FigCustomURLRequestInfoSetCryptorKeyRequestID(void *a1, uint64_t a2)
{
  if (a2)
    FigCFDictionarySetInt64(a1, CFSTR("RequestInfoCryptorKeyRequestID"), a2);
  else
    CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, CFSTR("RequestInfoCryptorKeyRequestID"));
  return 0;
}

uint64_t FigCustomURLRequestInfoSetAllowedUniversalTypeIdentifiers(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionarySetValue(a1, CFSTR("AllowedUniversalTypeIdentifiers"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("AllowedUniversalTypeIdentifiers"));
  return 0;
}

uint64_t FigCustomURLRequestInfoSetIsSecureStopSupported(__CFDictionary *a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, CFSTR("RequestInfoIsSecureStopSupported"), *v2);
  return 0;
}

uint64_t FigCustomURLRequestInfoSetNetworkHistory(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionarySetValue(a1, CFSTR("RequestInfoNetworkHistory"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("RequestInfoNetworkHistory"));
  return 0;
}

uint64_t FigCustomURLRequestInfoGetByteRange(uint64_t a1, void *a2, void *a3)
{
  if (!FigCFDictionaryGetInt64IfPresent(a1, CFSTR("RequestInfoByteRangeStart"), a2))
    return 4294949936;
  if (FigCFDictionaryGetInt64IfPresent(a1, CFSTR("RequestInfoByteRangeLength"), a3))
    return 0;
  return 4294949936;
}

uint64_t FigCustomURLRequestInfoGetIsRenewalRequest(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, CFSTR("RequestInfoIsRenewalRequest"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoGetIsPingRequest(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, CFSTR("RequestInfoIsPingRequest"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoGetDefaultLatency(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, CFSTR("RequestInfoDefaultLatency"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoGetExpectedToBlock(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, CFSTR("RequestInfoExpectedToBlock"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoCopyURL(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("RequestInfoURL"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoCopyHTTPHeaders(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("RequestInfoHTTPHeaders"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoCopyUserAgent(const __CFDictionary *a1, CFTypeRef *a2)
{
  return figCustomURLRequestInfoCopyHTTPHeader(a1, CFSTR("User-Agent"), a2);
}

uint64_t figCustomURLRequestInfoCopyHTTPHeader(const __CFDictionary *a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v5;
  const void *Value;
  uint64_t v7;
  CFDictionaryRef theDict;

  theDict = 0;
  v5 = FigCustomURLRequestInfoCopyHTTPHeaders(a1, (const void **)&theDict);
  if ((_DWORD)v5)
  {
    v7 = v5;
  }
  else
  {
    Value = CFDictionaryGetValue(theDict, a2);
    if (Value)
    {
      v7 = 0;
      *a3 = CFRetain(Value);
    }
    else
    {
      v7 = 4294949936;
    }
  }
  if (theDict)
    CFRelease(theDict);
  return v7;
}

uint64_t FigCustomURLRequestInfoCopyAcceptEncoding(const __CFDictionary *a1, CFTypeRef *a2)
{
  return figCustomURLRequestInfoCopyHTTPHeader(a1, CFSTR("Accept-Encoding"), a2);
}

uint64_t FigCustomURLRequestInfoCopyCryptor(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("RequestInfoCryptor"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoCopyCryptKeyAttributes(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("RequestInfoCryptKeyAttributes"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoGetCryptorID(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, CFSTR("RequestInfoCryptorID"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoGetCryptorKeyRequestID(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, CFSTR("RequestInfoCryptorKeyRequestID"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoCopyAllowedUniversalTypeIdentifiers(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("AllowedUniversalTypeIdentifiers"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLRequestInfoGetIsSecureStopSupported(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, CFSTR("RequestInfoIsSecureStopSupported"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoCreateMutable(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  __CFDictionary *Mutable;
  __CFDictionary *v6;
  uint64_t v8;

  if (a2)
  {
    if (a3)
    {
      Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v6 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("ResponseInfoRequestInfo"), a2);
        *a3 = CFRetain(v6);
        CFRelease(v6);
        return 0;
      }
      v8 = 4294954510;
    }
    else
    {
      v8 = 4294954516;
    }
  }
  else
  {
    v8 = 4294954516;
  }
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoCreateMutableCopy(const __CFAllocator *a1, CFDictionaryRef theDict, CFMutableDictionaryRef *a3)
{
  CFMutableDictionaryRef MutableCopy;
  uint64_t v6;

  if (theDict)
  {
    if (a3)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(a1, 0, theDict);
      if (MutableCopy)
      {
        *a3 = MutableCopy;
        return 0;
      }
      v6 = 4294954510;
    }
    else
    {
      v6 = 4294954516;
    }
  }
  else
  {
    v6 = 4294954516;
  }
  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoSetRequestInfo(__CFDictionary *a1, void *value)
{
  CFDictionarySetValue(a1, CFSTR("ResponseInfoRequestInfo"), value);
  return 0;
}

uint64_t FigCustomURLResponseInfoCreate(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  uint64_t Mutable;
  CFDictionaryRef Copy;
  CFDictionaryRef v7;
  uint64_t v8;
  uint64_t v10;
  CFDictionaryRef theDict;

  theDict = 0;
  if (!a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!a3)
  {
    v10 = 4294954516;
LABEL_12:
    Mutable = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  Mutable = FigCustomURLResponseInfoCreateMutable(a1, a2, (CFTypeRef *)&theDict);
  if ((_DWORD)Mutable)
  {
LABEL_13:
    v8 = Mutable;
    goto LABEL_6;
  }
  Copy = CFDictionaryCreateCopy(a1, theDict);
  if (!Copy)
  {
    v10 = 4294954510;
    goto LABEL_12;
  }
  v7 = Copy;
  *a3 = CFRetain(Copy);
  CFRelease(v7);
  v8 = 0;
LABEL_6:
  if (theDict)
    CFRelease(theDict);
  return v8;
}

uint64_t FigCustomURLResponseInfoSetHTTPStatusCode(void *a1, uint64_t a2)
{
  return FigCFDictionarySetCFIndex(a1, CFSTR("ResponseInfoHTTPStatusCode"), a2);
}

uint64_t FigCustomURLResponseInfoSetContentLength(void *a1, uint64_t a2)
{
  return FigCFDictionarySetInt64(a1, CFSTR("ResponseInfoContentLength"), a2);
}

uint64_t FigCustomURLResponseInfoSetResourceSize(void *a1, uint64_t a2)
{
  return FigCFDictionarySetInt64(a1, CFSTR("ResponseInfoResourceSize"), a2);
}

uint64_t FigCustomURLResponseInfoSetIsCachingDisabled(__CFDictionary *a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, CFSTR("ResponseInfoIsCachingDisabled"), *v2);
  return 0;
}

uint64_t FigCustomURLResponseInfoSetIsByteRangeAccessSupported(__CFDictionary *a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, CFSTR("ResponseInfoIsByteRangeAccessSupported"), *v2);
  return 0;
}

uint64_t FigCustomURLResponseInfoSetIsEntireLengthAvailableOnDemand(__CFDictionary *a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, CFSTR("ResponseInfoEntireLengthAvailableOnDemand"), *v2);
  return 0;
}

uint64_t FigCustomURLResponseInfoSetUniversalTypeIdentifier(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionarySetValue(a1, CFSTR("ResponseInfoUTI"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("ResponseInfoUTI"));
  return 0;
}

uint64_t FigCustomURLResponseInfoSetContentRenewalDate(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionarySetValue(a1, CFSTR("ResponseInfoContentRenewalDate"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("ResponseInfoContentRenewalDate"));
  return 0;
}

uint64_t FigCustomURLResponseInfoSetFinalURL(__CFDictionary *a1, void *value)
{
  if (value)
    CFDictionarySetValue(a1, CFSTR("ResponseInfoURL"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("ResponseInfoURL"));
  return 0;
}

uint64_t FigCustomURLResponseInfoSetHTTPHeaders(CFMutableDictionaryRef theDict, CFTypeRef cf)
{
  const __CFAllocator *v4;
  CFDictionaryRef Copy;
  CFDictionaryRef v6;

  if (!cf)
  {
    CFDictionaryRemoveValue(theDict, CFSTR("ResponseInfoHTTPHeaders"));
    return 0;
  }
  v4 = CFGetAllocator(cf);
  Copy = CFDictionaryCreateCopy(v4, (CFDictionaryRef)cf);
  if (Copy)
  {
    v6 = Copy;
    CFDictionarySetValue(theDict, CFSTR("ResponseInfoHTTPHeaders"), Copy);
    CFRelease(v6);
    return 0;
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoSetRedirectLocation(const __CFDictionary *a1, const __CFURL *a2)
{
  uint64_t v4;
  uint64_t v5;
  const __CFAllocator *v6;
  __CFDictionary *Mutable;
  const __CFAllocator *v8;
  __CFDictionary *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  CFStringRef v12;
  uint64_t v13;
  uint64_t v14;
  CFDictionaryRef theDict;

  theDict = 0;
  v4 = FigCustomURLResponseInfoCopyHTTPHeaders(a1, (const void **)&theDict);
  if ((_DWORD)v4)
  {
    v5 = v4;
    if ((_DWORD)v4 != -17360)
      goto LABEL_14;
    v6 = CFGetAllocator(a1);
    Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v8 = CFGetAllocator(a1);
    Mutable = CFDictionaryCreateMutableCopy(v8, 0, theDict);
  }
  v9 = Mutable;
  if (Mutable)
  {
    if (a2)
    {
      v10 = CFURLCopyAbsoluteURL(a2);
      if (v10)
      {
        v11 = v10;
        v12 = CFURLGetString(v10);
        if (v12)
        {
          CFDictionarySetValue(v9, CFSTR("Location"), v12);
          v13 = FigCustomURLResponseInfoSetHTTPHeaders(a1, v9);
        }
        else
        {
          v13 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        }
        v5 = v13;
        CFRelease(v11);
        goto LABEL_13;
      }
      v14 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      CFDictionaryRemoveValue(Mutable, CFSTR("Location"));
      v14 = FigCustomURLResponseInfoSetHTTPHeaders(a1, v9);
    }
    v5 = v14;
LABEL_13:
    CFRelease(v9);
    goto LABEL_14;
  }
  v5 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_14:
  if (theDict)
    CFRelease(theDict);
  return v5;
}

uint64_t FigCustomURLResponseInfoCopyHTTPHeaders(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("ResponseInfoHTTPHeaders"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoSetAllValuesFromResponseInfo(void *a1, const void *a2)
{
  uint64_t v4;
  void *value;

  value = 0;
  if (FigCFEqual(a1, a2))
    return 0;
  v4 = FigCustomURLResponseInfoCopyRequestInfo((const __CFDictionary *)a1, (const void **)&value);
  if (!(_DWORD)v4)
  {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, CFSTR("ResponseInfoRequestInfo"));
    FigCFDictionaryAddEntriesToDictionaryWithRecursion(a2, (const __CFDictionary *)a1, 1);
    CFDictionarySetValue((CFMutableDictionaryRef)a1, CFSTR("ResponseInfoRequestInfo"), value);
  }
  if (value)
    CFRelease(value);
  return v4;
}

uint64_t FigCustomURLResponseInfoCopyRequestInfo(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("ResponseInfoRequestInfo"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoSetRedirectRequestHeaders(CFMutableDictionaryRef theDict, const __CFDictionary *a2)
{
  CFDictionaryRef Copy;
  CFDictionaryRef v4;

  if (!a2)
  {
    CFDictionaryRemoveValue(theDict, CFSTR("ResponseInfoRedirectRequestHeaders"));
    return 0;
  }
  Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
  if (Copy)
  {
    v4 = Copy;
    CFDictionarySetValue(theDict, CFSTR("ResponseInfoRedirectRequestHeaders"), Copy);
    CFRelease(v4);
    return 0;
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLResponseInfoSetRoundTripTime(__CFDictionary *a1, double a2)
{
  if (a2 <= 2.22044605e-16)
    CFDictionaryRemoveValue(a1, CFSTR("ResponseInfoRoundTripTime"));
  else
    FigCFDictionarySetDouble(a1, CFSTR("ResponseInfoRoundTripTime"), a2);
  return 0;
}

uint64_t FigCustomURLResponseInfoSetSuppressErrorLogging(__CFDictionary *a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, CFSTR("ResponseInfoSuppressErrorLogging"), *v2);
  return 0;
}

uint64_t FigCustomURLResponseInfoGetHTTPStatusCode(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetCFIndexIfPresent(a1, CFSTR("ResponseInfoHTTPStatusCode"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoGetContentLength(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, CFSTR("ResponseInfoContentLength"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoGetResourceSize(uint64_t a1, void *a2)
{
  if (FigCFDictionaryGetInt64IfPresent(a1, CFSTR("ResponseInfoResourceSize"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoGetIsCachingDisabled(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, CFSTR("ResponseInfoIsCachingDisabled"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoGetIsByteRangeAccessSupported(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, CFSTR("ResponseInfoIsByteRangeAccessSupported"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoGetEntireLengthAvailableOnDemand(uint64_t a1, Boolean *a2)
{
  if (FigCFDictionaryGetBooleanIfPresent(a1, CFSTR("ResponseInfoEntireLengthAvailableOnDemand"), a2))
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoCopyUniversalTypeIdentifier(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("ResponseInfoUTI"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoCopyContentRenewalDate(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("ResponseInfoContentRenewalDate"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

uint64_t FigCustomURLResponseInfoCopyFinalURL(const __CFDictionary *a1, const void **value)
{
  uint64_t v4;
  uint64_t v5;
  CFDictionaryRef theDict;

  theDict = 0;
  if (!CFDictionaryGetValueIfPresent(a1, CFSTR("ResponseInfoURL"), value))
  {
    v4 = FigCustomURLResponseInfoCopyRequestInfo(a1, (const void **)&theDict);
    if ((_DWORD)v4)
    {
      v5 = v4;
      goto LABEL_7;
    }
    CFDictionaryGetValueIfPresent(theDict, CFSTR("RequestInfoURL"), value);
  }
  if (*value)
    CFRetain(*value);
  v5 = 0;
LABEL_7:
  if (theDict)
    CFRelease(theDict);
  return v5;
}

uint64_t FigCustomURLResponseInfoCopyRedirectLocation(const __CFDictionary *a1, CFURLRef *a2)
{
  uint64_t v3;
  const __CFString *Value;
  const __CFString *v5;
  const __CFAllocator *v6;
  CFURLRef v7;
  uint64_t v8;
  CFDictionaryRef theDict;

  theDict = 0;
  v3 = FigCustomURLResponseInfoCopyHTTPHeaders(a1, (const void **)&theDict);
  if (!(_DWORD)v3)
  {
    Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("Location"));
    if (!Value)
    {
      v8 = 4294949936;
      goto LABEL_5;
    }
    v5 = Value;
    v6 = CFGetAllocator(theDict);
    v7 = CFURLCreateWithString(v6, v5, 0);
    *a2 = v7;
    if (v7)
    {
      v8 = 0;
      goto LABEL_5;
    }
    v3 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  v8 = v3;
LABEL_5:
  if (theDict)
    CFRelease(theDict);
  return v8;
}

uint64_t FigCustomURLResponseInfoCopyRedirectRequestHeaders(const __CFDictionary *a1, const void **value)
{
  int ValueIfPresent;

  ValueIfPresent = CFDictionaryGetValueIfPresent(a1, CFSTR("ResponseInfoRedirectRequestHeaders"), value);
  if (*value)
    CFRetain(*value);
  if (ValueIfPresent)
    return 0;
  else
    return 4294949936;
}

double FigCustomURLResponseInfoGetRoundTripTime(uint64_t a1)
{
  double v2;

  v2 = 0.0;
  FigCFDictionaryGetDoubleIfPresent(a1, CFSTR("ResponseInfoRoundTripTime"), &v2);
  return v2;
}

uint64_t FigCustomURLHandlerGetClassID()
{
  FigThreadRunOnce(&FigCustomURLHandlerGetClassID_sRegisterFigCustomURLHandlerBaseTypeOnce, (void (*)(void))RegisterFigCustomURLHandlerBaseType);
  return sFigCustomURLHandlerClassID;
}

uint64_t RegisterFigCustomURLHandlerBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigCustomURLHandlerClassDesc, ClassID, 1, &sFigCustomURLHandlerClassID);
}

uint64_t FigCustomURLHandlerGetTypeID()
{
  FigThreadRunOnce(&FigCustomURLHandlerGetClassID_sRegisterFigCustomURLHandlerBaseTypeOnce, (void (*)(void))RegisterFigCustomURLHandlerBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigCustomURLHandlerClassID);
}

uint64_t FigCustomURLHandlerCreate(const void *a1, const char *a2, uint64_t a3, NSObject *a4, __int128 *a5, uint64_t a6, CFTypeRef *a7)
{
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t DerivedStorage;
  pthread_mutex_t *v16;
  CFTypeRef v17;
  __int128 v18;
  CFTypeRef v19;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v28;
  os_log_type_t type;
  int v32;
  CFTypeRef cf;
  int v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  CFTypeRef v39;
  __int16 v40;
  uint64_t v41;
  char v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  cf = 0;
  if (FigNote_AllowInternalDefaultLogs())
  {
    if (FigNote_AllowInternalDefaultLogs())
      v12 = 2;
    else
      v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigCustomURLHandlingTrace[1], CFSTR("curl_handling_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v12, 0, gFigCustomURLHandlingTrace);
  if (FigNote_AllowInternalDefaultLogs())
    v13 = 2;
  else
    v13 = 1;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1ECDA8458, CFSTR("curl_handling_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v13, 0, &qword_1ECDA8450);
  if (!a2 || !a3 || !a4 || !a5 || !*((_QWORD *)a5 + 1) || !a7 || strnlen(a2, 0x40uLL) >= 0x40)
  {
    v28 = 4294949916;
LABEL_35:
    v14 = FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
    goto LABEL_36;
  }
  FigThreadRunOnce(&FigCustomURLHandlerGetClassID_sRegisterFigCustomURLHandlerBaseTypeOnce, (void (*)(void))RegisterFigCustomURLHandlerBaseType);
  v14 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kCustomURLHandler_VTable, (_QWORD *)sFigCustomURLHandlerClassID, &cf);
  if (!(_DWORD)v14)
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
    v14 = figCustomURLWorkQueueCreate((CFTypeRef *)DerivedStorage);
    if (!(_DWORD)v14)
    {
      v16 = FigReentrantMutexCreate();
      *(_QWORD *)(DerivedStorage + 8) = v16;
      if (v16)
      {
        v17 = a1 ? CFRetain(a1) : 0;
        *(_QWORD *)(DerivedStorage + 16) = v17;
        dispatch_retain(a4);
        *(_QWORD *)(DerivedStorage + 40) = a4;
        v18 = *a5;
        *(_QWORD *)(DerivedStorage + 64) = *((_QWORD *)a5 + 2);
        *(_OWORD *)(DerivedStorage + 48) = v18;
        *(_QWORD *)(DerivedStorage + 24) = a2;
        v19 = FigCFWeakReferenceHolderCreateWithReferencedObject(a3);
        *(_QWORD *)(DerivedStorage + 32) = v19;
        if (v19)
        {
          FigCFDictionaryGetBooleanIfPresent(a6, CFSTR("CURLHOption_ClientRequestsRepresentAccurateNetworkStatistics"), (Boolean *)(DerivedStorage + 72));
          *(_QWORD *)(DerivedStorage + 80) = 0;
          *(_QWORD *)(DerivedStorage + 88) = DerivedStorage + 80;
          if (dword_1ECDA8458)
          {
            v32 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v32, &type);
            v21 = v32;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
              v23 = v21;
            else
              v23 = v21 & 0xFFFFFFFE;
            if (v23)
            {
              v24 = *(_QWORD *)(DerivedStorage + 24);
              v34 = 136315906;
              v35 = "FigCustomURLHandlerCreate";
              v36 = 2082;
              v37 = v24;
              v38 = 2048;
              v39 = cf;
              v40 = 2114;
              v41 = a6;
              v25 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v21) = v32;
            }
            else
            {
              v25 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v25, v25 != &v42, v21, 0, v22);
          }
          v26 = 0;
          *a7 = cf;
          return v26;
        }
      }
      v28 = 4294954510;
      goto LABEL_35;
    }
  }
LABEL_36:
  v26 = v14;
  if (cf)
    CFRelease(cf);
  return v26;
}

uint64_t figCustomURLWorkQueueCreate(CFTypeRef *a1)
{
  uint64_t Instance;
  _QWORD *v3;
  pthread_mutex_t *v4;
  uint64_t v5;

  if (sFigCustomURLWorkQueueRegisterTypeOnce != -1)
    dispatch_once_f(&sFigCustomURLWorkQueueRegisterTypeOnce, 0, (dispatch_function_t)figCustomURLWorkQueueRegisterType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  v3 = (_QWORD *)Instance;
  v4 = FigReentrantMutexCreate();
  v3[2] = v4;
  if (v4)
  {
    v3[3] = 0;
    v3[4] = v3 + 3;
    v5 = 0;
    *a1 = CFRetain(v3);
  }
  else
  {
    v5 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  CFRelease(v3);
  return v5;
}

uint64_t FigCustomURLLoaderGetClassID()
{
  FigThreadRunOnce(&FigCustomURLLoaderGetClassID_sRegisterFigCustomURLLoaderBaseTypeOnce, (void (*)(void))RegisterFigCustomURLLoaderBaseType);
  return sFigCustomURLLoaderClassID;
}

uint64_t RegisterFigCustomURLLoaderBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigCustomURLLoaderClassDesc, ClassID, 1, &sFigCustomURLLoaderClassID);
}

uint64_t FigCustomURLLoaderGetCFTypeID()
{
  FigThreadRunOnce(&FigCustomURLLoaderGetClassID_sRegisterFigCustomURLLoaderBaseTypeOnce, (void (*)(void))RegisterFigCustomURLLoaderBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigCustomURLLoaderClassID);
}

uint64_t FigCustomURLLoaderCreate(const void *a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t DerivedStorage;
  pthread_mutex_t *v9;
  const __CFAllocator *v10;
  CFMutableDictionaryRef Mutable;
  CFMutableArrayRef v12;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v14;
  uint64_t v15;
  unsigned int v16;
  char *v17;
  CFTypeRef v18;
  uint64_t v19;
  uint64_t v21;
  os_log_type_t type;
  int v23;
  CFTypeRef cf;
  int v25;
  const char *v26;
  __int16 v27;
  CFTypeRef v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  cf = 0;
  if (FigNote_AllowInternalDefaultLogs())
  {
    if (FigNote_AllowInternalDefaultLogs())
      v5 = 2;
    else
      v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigCustomURLHandlingTrace[1], CFSTR("curl_handling_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v5, 0, gFigCustomURLHandlingTrace);
  if (FigNote_AllowInternalDefaultLogs())
    v6 = 2;
  else
    v6 = 1;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1ECDA8458, CFSTR("curl_handling_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v6, 0, &qword_1ECDA8450);
  if (!a3)
  {
    v21 = 4294949916;
    goto LABEL_35;
  }
  FigThreadRunOnce(&FigCustomURLLoaderGetClassID_sRegisterFigCustomURLLoaderBaseTypeOnce, (void (*)(void))RegisterFigCustomURLLoaderBaseType);
  v7 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kCustomURLLoader_VTable, (_QWORD *)sFigCustomURLLoaderClassID, &cf);
  if ((_DWORD)v7)
    goto LABEL_36;
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  v7 = figCustomURLWorkQueueCreate((CFTypeRef *)DerivedStorage);
  if ((_DWORD)v7)
    goto LABEL_36;
  v9 = FigReentrantMutexCreate();
  *(_QWORD *)(DerivedStorage + 8) = v9;
  if (!v9
    || (!a1 ? (v10 = 0) : (v10 = (const __CFAllocator *)CFRetain(a1)),
        (*(_QWORD *)(DerivedStorage + 16) = v10,
         Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
         (*(_QWORD *)(DerivedStorage + 40) = Mutable) == 0)
     || (v12 = CFArrayCreateMutable(*(CFAllocatorRef *)(DerivedStorage + 16), 0, MEMORY[0x1E0C9B378]),
         (*(_QWORD *)(DerivedStorage + 48) = v12) == 0)))
  {
    v21 = 4294954510;
LABEL_35:
    v7 = FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
    goto LABEL_36;
  }
  v7 = FigCFWeakReferenceTableCreate(*(const __CFAllocator **)(DerivedStorage + 16), 1, (uint64_t *)(DerivedStorage + 56));
  if ((_DWORD)v7)
  {
LABEL_36:
    v19 = v7;
    goto LABEL_30;
  }
  if (dword_1ECDA8458)
  {
    v23 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v23, &type);
    v14 = v23;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v16 = v14;
    else
      v16 = v14 & 0xFFFFFFFE;
    if (v16)
    {
      v25 = 136315394;
      v26 = "FigCustomURLLoaderCreate";
      v27 = 2048;
      v28 = cf;
      v17 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v14) = v23;
    }
    else
    {
      v17 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v17, v17 != &v29, v14, 0, v15);
  }
  v18 = cf;
  if (cf)
    v18 = CFRetain(cf);
  v19 = 0;
  *a3 = v18;
LABEL_30:
  if (cf)
    CFRelease(cf);
  return v19;
}

CFStringRef FigCustomURLHandlerCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCustomURLHandler %p]"), a1);
}

uint64_t curlh_invalidate(uint64_t a1)
{
  uint64_t DerivedStorage;
  _QWORD *v3;
  _QWORD *v4;
  const void *v5;
  const void *v6;
  NSObject *v7;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (!*(_BYTE *)(DerivedStorage + 73))
  {
    *(_BYTE *)(DerivedStorage + 73) = 1;
    v3 = *(_QWORD **)(CMBaseObjectGetDerivedStorage(a1) + 80);
    if (v3)
    {
      do
      {
        v4 = (_QWORD *)v3[8];
        curlh_removeAndFreeCustomURLRequestEntry(a1, v3);
        v3 = v4;
      }
      while (v4);
    }
    v5 = *(const void **)(DerivedStorage + 16);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(DerivedStorage + 16) = 0;
    }
    v6 = *(const void **)(DerivedStorage + 32);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(DerivedStorage + 32) = 0;
    }
    v7 = *(NSObject **)(DerivedStorage + 40);
    if (v7)
    {
      dispatch_release(v7);
      *(_QWORD *)(DerivedStorage + 40) = 0;
    }
    if (*(_QWORD *)DerivedStorage)
    {
      CFRelease(*(CFTypeRef *)DerivedStorage);
      *(_QWORD *)DerivedStorage = 0;
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return 0;
}

uint64_t curlh_finalize(uint64_t a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  curlh_invalidate(a1);
  return FigReentrantMutexDestroy(*(_QWORD *)(DerivedStorage + 8));
}

uint64_t curlh_copyDebugDescription()
{
  return 0;
}

void curlh_removeAndFreeCustomURLRequestEntry(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  const void *v4;
  NSObject *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  uint64_t v9;
  _QWORD *v10;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v4 = (const void *)a2[1];
  if (v4)
  {
    CFRelease(v4);
    a2[1] = 0;
  }
  v5 = a2[2];
  if (v5)
  {
    dispatch_release(v5);
    a2[2] = 0;
  }
  v6 = (const void *)a2[4];
  if (v6)
  {
    CFRelease(v6);
    a2[4] = 0;
  }
  v7 = (const void *)a2[7];
  if (v7)
  {
    CFRelease(v7);
    a2[7] = 0;
  }
  v8 = (const void *)a2[5];
  if (v8)
  {
    CFRelease(v8);
    a2[5] = 0;
  }
  v9 = a2[8];
  v10 = (_QWORD *)a2[9];
  if (v9)
  {
    *(_QWORD *)(v9 + 72) = v10;
    v10 = (_QWORD *)a2[9];
  }
  else
  {
    *(_QWORD *)(DerivedStorage + 88) = v10;
  }
  *v10 = v9;
  CFAllocatorDeallocate(*(CFAllocatorRef *)(DerivedStorage + 16), a2);
}

uint64_t curlh_sendResponseInfo(const void *a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage;
  uint64_t *v7;
  void *v8;
  uint64_t v9;
  CFTypeRef v10;
  uint64_t v11;
  const void *v12;
  uint64_t v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a3)
  {
    v14 = 4294949926;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v7 = (uint64_t *)DerivedStorage;
  v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x106004049771C40uLL);
  if (!v8)
  {
    v14 = 4294954510;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v9 = (uint64_t)v8;
  if (a1)
    v10 = CFRetain(a1);
  else
    v10 = 0;
  *(_QWORD *)v9 = v10;
  *(_QWORD *)(v9 + 8) = a2;
  *(_QWORD *)(v9 + 16) = CFRetain(a3);
  v11 = figCustomURLWorkQueueEnqueue(*v7, (uint64_t)curlh_sendResponseInfoDispatch, v9);
  if ((_DWORD)v11)
  {
    if (*(_QWORD *)v9)
      CFRelease(*(CFTypeRef *)v9);
    v12 = *(const void **)(v9 + 16);
    if (v12)
      CFRelease(v12);
    free((void *)v9);
  }
  return v11;
}

uint64_t curlh_sendData(const void *a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage;
  uint64_t *v7;
  void *v8;
  uint64_t v9;
  CFTypeRef v10;
  uint64_t v11;
  const void *v12;
  uint64_t v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a3)
  {
    v14 = 4294949926;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v7 = (uint64_t *)DerivedStorage;
  v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x1060040B6A22668uLL);
  if (!v8)
  {
    v14 = 4294954510;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v9 = (uint64_t)v8;
  if (a1)
    v10 = CFRetain(a1);
  else
    v10 = 0;
  *(_QWORD *)v9 = v10;
  *(_QWORD *)(v9 + 8) = a2;
  *(_QWORD *)(v9 + 16) = CFRetain(a3);
  v11 = figCustomURLWorkQueueEnqueue(*v7, (uint64_t)curlh_sendDataDispatch, v9);
  if ((_DWORD)v11)
  {
    if (*(_QWORD *)v9)
      CFRelease(*(CFTypeRef *)v9);
    v12 = *(const void **)(v9 + 16);
    if (v12)
      CFRelease(v12);
    free((void *)v9);
  }
  return v11;
}

uint64_t curlh_finishLoading(const void *a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t *DerivedStorage;
  void *v9;
  uint64_t v10;
  CFTypeRef v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t v14;
  const void *v15;
  const void *v16;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v9 = malloc_type_calloc(1uLL, 0x20uLL, 0x1060040EF2C8554uLL);
  if (!v9)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  v10 = (uint64_t)v9;
  if (a1)
    v11 = CFRetain(a1);
  else
    v11 = 0;
  *(_QWORD *)v10 = v11;
  *(_QWORD *)(v10 + 8) = a2;
  if (a3)
    v12 = CFRetain(a3);
  else
    v12 = 0;
  *(_QWORD *)(v10 + 16) = v12;
  if (a4)
    v13 = CFRetain(a4);
  else
    v13 = 0;
  *(_QWORD *)(v10 + 24) = v13;
  v14 = figCustomURLWorkQueueEnqueue(*DerivedStorage, (uint64_t)curlh_finishLoadingDispatch, v10);
  if ((_DWORD)v14)
  {
    if (*(_QWORD *)v10)
      CFRelease(*(CFTypeRef *)v10);
    v15 = *(const void **)(v10 + 16);
    if (v15)
      CFRelease(v15);
    v16 = *(const void **)(v10 + 24);
    if (v16)
      CFRelease(v16);
    free((void *)v10);
  }
  return v14;
}

uint64_t curlh_handleRequest(const void *a1, const void *a2, uint64_t a3, const void *a4, NSObject *a5, uint64_t a6, uint64_t a7, const void *a8)
{
  uint64_t DerivedStorage;
  uint64_t *v16;
  const __CFAllocator *v17;
  const UInt8 *v18;
  _QWORD *v19;
  CFDataRef v20;
  CFDataRef v21;
  CFTypeRef v22;
  uint64_t v23;
  CFTypeRef v24;
  uint64_t v25;
  uint64_t result;
  uint64_t v27;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1 || !a2 || !a4 || !a5 || !a7)
  {
    v27 = 4294949926;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  v16 = (uint64_t *)DerivedStorage;
  if (handleRequestRec_getCFAllocator_sOnceToken != -1)
    dispatch_once_f(&handleRequestRec_getCFAllocator_sOnceToken, &handleRequestRec_getCFAllocator_sAllocator, (dispatch_function_t)handleRequestRec_initializeCFAllocatorOnce);
  v17 = (const __CFAllocator *)handleRequestRec_getCFAllocator_sAllocator;
  if (handleRequestRec_getCFAllocator_sAllocator
    || (result = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0), !(_DWORD)result))
  {
    v18 = (const UInt8 *)malloc_type_calloc(1uLL, 0x40uLL, 0x10E0040BCA754A7uLL);
    if (v18)
    {
      v19 = v18;
      v20 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18, 64, v17);
      if (v20)
      {
        v21 = v20;
        *v19 = CFRetain(a1);
        v19[1] = CFRetain(a2);
        v19[2] = a3;
        v19[3] = CFRetain(a4);
        dispatch_retain(a5);
        v19[4] = a5;
        v19[5] = a6;
        v19[6] = a7;
        v22 = a8;
        if (a8)
          v22 = CFRetain(a8);
        v19[7] = v22;
        v23 = *v16;
        v24 = CFRetain(v21);
        v25 = figCustomURLWorkQueueEnqueue(v23, (uint64_t)curlh_handleRequestDispatch, (uint64_t)v24);
        CFRelease(v21);
        return v25;
      }
      free(v19);
    }
    v27 = 4294954510;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t curlh_cancelRequest(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1)
  {
    v10 = 4294949926;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v5 = (uint64_t *)DerivedStorage;
  v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
  if (!v6)
  {
    v10 = 4294954510;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v7 = (uint64_t)v6;
  *v6 = CFRetain(a1);
  *(_QWORD *)(v7 + 8) = a2;
  v8 = figCustomURLWorkQueueEnqueue(*v5, (uint64_t)curlh_cancelRequestDispatch, v7);
  if ((_DWORD)v8)
  {
    if (*(_QWORD *)v7)
      CFRelease(*(CFTypeRef *)v7);
    free((void *)v7);
  }
  return v8;
}

uint64_t curlh_requestSetDormant(const void *a1, uint64_t a2, char a3)
{
  uint64_t DerivedStorage;
  uint64_t *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1)
  {
    v12 = 4294949926;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v7 = (uint64_t *)DerivedStorage;
  v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x10600407BD382EDuLL);
  if (!v8)
  {
    v12 = 4294954510;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v9 = (uint64_t)v8;
  *v8 = CFRetain(a1);
  *(_QWORD *)(v9 + 8) = a2;
  *(_BYTE *)(v9 + 16) = a3;
  v10 = figCustomURLWorkQueueEnqueue(*v7, (uint64_t)curlh_requestSetDormantDispatch, v9);
  if ((_DWORD)v10)
  {
    if (*(_QWORD *)v9)
      CFRelease(*(CFTypeRef *)v9);
    free((void *)v9);
  }
  return v10;
}

uint64_t curlh_lookupAndRetainRegisteredInfoForRequestID(const void *a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  CFTypeRef v12;
  uint64_t v13;
  const void *v14;
  uint64_t v16;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1 || !a3)
  {
    v16 = 4294949926;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  v9 = (uint64_t *)DerivedStorage;
  v10 = malloc_type_calloc(1uLL, 0x20uLL, 0x10E00402E54A04BuLL);
  if (!v10)
  {
    v16 = 4294954510;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  v11 = (uint64_t)v10;
  *v10 = CFRetain(a1);
  *(_QWORD *)(v11 + 8) = a2;
  *(_QWORD *)(v11 + 16) = a3;
  if (a4)
    v12 = CFRetain(a4);
  else
    v12 = 0;
  *(_QWORD *)(v11 + 24) = v12;
  v13 = figCustomURLWorkQueueEnqueue(*v9, (uint64_t)curlh_lookupAndRetainRegisteredInfoForRequestIDDispatch, v11);
  if ((_DWORD)v13)
  {
    if (*(_QWORD *)v11)
      CFRelease(*(CFTypeRef *)v11);
    v14 = *(const void **)(v11 + 24);
    if (v14)
      CFRelease(v14);
    free((void *)v11);
  }
  return v13;
}

uint64_t figCustomURLWorkQueueEnqueue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v9;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(_DWORD *)(a1 + 40) == 4)
  {
    v9 = 4294954511;
    goto LABEL_8;
  }
  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0xA0040114AFA65uLL);
  if (!v6)
  {
    v9 = 4294954510;
LABEL_8:
    v7 = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)v7)
      goto LABEL_5;
    goto LABEL_4;
  }
  *v6 = a2;
  v6[1] = a3;
  v6[2] = 0;
  **(_QWORD **)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 32) = v6 + 2;
LABEL_4:
  figCustomURLWorkQueueDrain(a1, 0);
  v7 = 0;
LABEL_5:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v7;
}

void curlh_sendResponseInfoDispatch(uint64_t *a1)
{
  uint64_t v2;
  const void *v3;
  const void *v4;
  uint64_t DerivedStorage;
  int RequestEntryForRequestID;
  _QWORD *v7;
  unint64_t UpTimeNanoseconds;
  int v9;
  uint64_t v10;
  int v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef v15;
  dispatch_object_t object;
  CFTypeRef v17;
  uint64_t v18;
  uint64_t v19;
  CFTypeRef cf;
  CFTypeRef v21;

  v3 = (const void *)*a1;
  v2 = a1[1];
  v4 = (const void *)a1[2];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  object = 0;
  v17 = 0;
  v14 = 0;
  v15 = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 73))
  {
    RequestEntryForRequestID = FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    goto LABEL_35;
  }
  RequestEntryForRequestID = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v3, v2, &v15, 0, &v17, &object, &v14, 0, 0);
  if (RequestEntryForRequestID)
    goto LABEL_35;
  v21 = 0;
  if (!v4)
  {
    v13 = 4294949926;
    goto LABEL_41;
  }
  RequestEntryForRequestID = curlh_getRequestEntryForRequestID((uint64_t)v3, v2, &v21);
  if (RequestEntryForRequestID)
  {
LABEL_35:
    v11 = RequestEntryForRequestID;
    goto LABEL_36;
  }
  v7 = v21;
  if (!*((_QWORD *)v21 + 7))
  {
    v7[7] = CFRetain(v4);
    goto LABEL_7;
  }
  v13 = 4294949920;
LABEL_41:
  RequestEntryForRequestID = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
  if (RequestEntryForRequestID)
    goto LABEL_35;
LABEL_7:
  cf = 0;
  v21 = 0;
  v19 = 0;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v18 = 0;
  v9 = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v3, v2, &v21, 0, 0, 0, 0, 0, 0);
  if (v9)
  {
LABEL_15:
    v11 = v9;
    goto LABEL_17;
  }
  if (curlh_copyNetworkHistoryIfReporting(v3, v2, &cf, &v19))
  {
    FigCFDictionaryGetInt64IfPresent((uint64_t)v21, CFSTR("RequestInfoDefaultLatency"), &v18);
    v10 = v19;
    if (!v19)
    {
      curlh_requestSetDormantOnQueue(v3, v2, 0, &v19);
      v10 = v19;
    }
    if (v18)
    {
      v11 = FigNetworkHistorySetRequestSentTimestamp(cf, v10, UpTimeNanoseconds - v18);
      if (v11)
        goto LABEL_17;
      v10 = v19;
    }
    v9 = FigNetworkHistorySetRequestLatency(cf, v10, UpTimeNanoseconds);
    goto LABEL_15;
  }
  v11 = 0;
LABEL_17:
  if (cf)
    CFRelease(cf);
  if (v21)
    CFRelease(v21);
  if (!v11)
  {
    curl_dispatchDataCallback(object, v17, v14, v2, v4, 0, 0, 0, 0);
    goto LABEL_23;
  }
LABEL_36:
  if (v11 && v17)
  {
    curlh_cleanupRegisteredInfoForRequestID(v3, v2);
    curl_dispatchDataCallbackWithError(object, v17, v14, v2, v15, v4, v11);
  }
LABEL_23:
  if (v15)
    CFRelease(v15);
  if (v17)
    CFRelease(v17);
  if (object)
    dispatch_release(object);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  v12 = (const void *)a1[2];
  if (v12)
    CFRelease(v12);
  free(a1);
}

uint64_t figCustomURLWorkQueueDrain(uint64_t result, int a2)
{
  int v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  int v7;

  v2 = *(_DWORD *)(result + 40);
  if (v2 != 4)
  {
    v3 = result;
    if (a2 || (v2 - 1) >= 3)
    {
      v5 = (_QWORD *)(result + 24);
      v4 = *(_QWORD **)(result + 24);
      *(_DWORD *)(result + 40) = 1;
      if (v4)
      {
        do
        {
          v6 = v4[2];
          *v5 = v6;
          if (!v6)
            *(_QWORD *)(v3 + 32) = v5;
          FigReentrantMutexUnlock(*(pthread_mutex_t **)(v3 + 16));
          ((void (*)(_QWORD))*v4)(v4[1]);
          free(v4);
          result = FigReentrantMutexLock(*(pthread_mutex_t **)(v3 + 16));
          v7 = *(_DWORD *)(v3 + 40);
          if ((v7 - 2) < 2)
          {
            *(_DWORD *)(v3 + 40) = 3;
            return result;
          }
          if (v7 == 4)
            return FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
          v4 = (_QWORD *)*v5;
        }
        while (*v5);
        if (v7 != 1)
          return result;
      }
      *(_DWORD *)(v3 + 40) = 0;
    }
  }
  return result;
}

uint64_t curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(const void *a1, uint64_t a2, _QWORD *a3, _QWORD *a4, CFTypeRef *a5, NSObject **a6, _QWORD *a7, _QWORD *a8, _QWORD *a9)
{
  uint64_t DerivedStorage;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  const void *v21;
  const void *v22;
  CFTypeRef v23;
  uint64_t v24;
  id *v25;
  uint64_t v26;
  id *v27;
  uint64_t v28;
  CFTypeRef v29;
  uint64_t v30;
  CFTypeRef v31;
  CFTypeRef v32;
  CFTypeRef *v34;
  NSObject **v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  CFTypeRef cf;
  uint64_t v42;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 73))
  {
    v30 = FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
    goto LABEL_36;
  }
  v18 = *(_QWORD *)(DerivedStorage + 80);
  if (!v18)
  {
    v30 = 4294949922;
    goto LABEL_36;
  }
  v34 = a5;
  v35 = a6;
  v36 = a7;
  v37 = a3;
  v38 = a4;
  v39 = a8;
  v40 = DerivedStorage;
  cf = 0;
  v42 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  do
  {
    v24 = *(_QWORD *)(v18 + 64);
    v25 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(v18 + 8));
    v26 = *(_QWORD *)v18;
    if (v25)
    {
      v27 = v25;
      if (v26 != a2)
      {
LABEL_8:
        CFRelease(v27);
        goto LABEL_10;
      }
      if (!v23)
      {
        v22 = *(const void **)(v18 + 32);
        v21 = *(const void **)(v18 + 56);
        v23 = CFRetain(v25);
        v20 = *(NSObject **)(v18 + 16);
        v19 = *(_QWORD *)(v18 + 24);
        cf = *(CFTypeRef *)(v18 + 40);
        v42 = *(_QWORD *)(v18 + 48);
        goto LABEL_8;
      }
      v30 = FigSignalErrorAt(4294949924, 0, 0, 0, 0, 0, 0);
      CFRelease(v27);
      DerivedStorage = v40;
LABEL_35:
      CFRelease(v23);
      goto LABEL_36;
    }
    v28 = curlh_cleanupRegisteredInfoForRequestID(a1, v26);
    if ((_DWORD)v28)
    {
      v30 = v28;
      DerivedStorage = v40;
      if (!v23)
        goto LABEL_36;
      goto LABEL_35;
    }
LABEL_10:
    v18 = v24;
  }
  while (v24);
  if (v23)
  {
    if (v34)
      *v34 = CFRetain(v23);
    if (v35)
    {
      dispatch_retain(v20);
      *v35 = v20;
    }
    if (v36)
      *v36 = v19;
    DerivedStorage = v40;
    if (v37)
    {
      if (v22)
        v29 = CFRetain(v22);
      else
        v29 = 0;
      *v37 = v29;
    }
    if (v38)
    {
      if (v21)
        v31 = CFRetain(v21);
      else
        v31 = 0;
      *v38 = v31;
    }
    if (v39)
    {
      v32 = cf;
      if (cf)
        v32 = CFRetain(cf);
      *v39 = v32;
    }
    v30 = 0;
    if (a9)
      *a9 = v42;
    goto LABEL_35;
  }
  v30 = 4294949922;
  DerivedStorage = v40;
LABEL_36:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v30;
}

void curl_dispatchDataCallback(NSObject *a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5, const void *a6, int a7, const void *a8, const void *a9)
{
  _QWORD *v17;
  CFTypeRef v18;
  CFTypeRef v19;
  CFTypeRef v20;
  CFTypeRef v21;
  CFTypeRef v22;

  v17 = malloc_type_calloc(1uLL, 0x40uLL, 0x10E00408CCBC589uLL);
  if (a2)
    v18 = CFRetain(a2);
  else
    v18 = 0;
  *v17 = v18;
  v17[1] = a3;
  v17[2] = a4;
  if (a5)
    v19 = CFRetain(a5);
  else
    v19 = 0;
  v17[3] = v19;
  if (a6)
    v20 = CFRetain(a6);
  else
    v20 = 0;
  v17[4] = v20;
  *((_DWORD *)v17 + 10) = a7;
  if (a8)
    v21 = CFRetain(a8);
  else
    v21 = 0;
  v17[6] = v21;
  if (a9)
    v22 = CFRetain(a9);
  else
    v22 = 0;
  v17[7] = v22;
  dispatch_async_f(a1, v17, (dispatch_function_t)curl_performDataCallbackDispatch);
}

uint64_t curlh_cleanupRegisteredInfoForRequestID(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t RequestEntryForRequestID;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v7;
  uint64_t v8;
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v10;
  _QWORD *v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v12 = 0;
  RequestEntryForRequestID = curlh_getRequestEntryForRequestID((uint64_t)a1, a2, &v12);
  if ((_DWORD)RequestEntryForRequestID)
    return RequestEntryForRequestID;
  curlh_removeAndFreeCustomURLRequestEntry((uint64_t)a1, v12);
  Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(DerivedStorage + 16), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v7 = Mutable;
    v8 = FigCFDictionarySetInt64(Mutable, CFSTR("CURLHRequestCompletedNotificationKey_RequestID"), a2);
    if (!(_DWORD)v8)
    {
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      v8 = CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("CURLHNotification_RequestCompleted"), a1, v7);
    }
    v10 = v8;
    CFRelease(v7);
    return v10;
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

void curl_dispatchDataCallbackWithError(NSObject *a1, const void *a2, uint64_t a3, uint64_t a4, const void *a5, CFTypeRef cf, int a7)
{
  CFAllocatorRef *v12;
  CFErrorRef v13;
  CFTypeRef cfa;

  cfa = cf;
  v12 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (cf)
  {
    CFRetain(cf);
  }
  else if (!a5 || (FigCustomURLResponseInfoCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a5, &cfa), !cfa))
  {
    FigSignalErrorAt(4294949914, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v13 = CFErrorCreate(*v12, CFSTR("CoreMediaErrorDomain"), a7, 0);
  curl_dispatchDataCallback(a1, a2, a3, a4, cfa, 0, 1, v13, 0);
  if (v13)
    CFRelease(v13);
LABEL_8:
  if (cfa)
    CFRelease(cfa);
}

uint64_t curlh_getRequestEntryForRequestID(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t DerivedStorage;
  _QWORD *v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  *a3 = 0;
  v6 = *(_QWORD **)(DerivedStorage + 80);
  if (!v6)
    return FigSignalErrorAt(4294949922, 0, 0, 0, 0, 0, 0);
  while (*v6 != a2)
  {
    v6 = (_QWORD *)v6[8];
    if (!v6)
      return FigSignalErrorAt(4294949922, 0, 0, 0, 0, 0, 0);
  }
  *a3 = v6;
  return 0;
}

BOOL curlh_copyNetworkHistoryIfReporting(const void *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  _BOOL4 shouldReportToNetworkHistory;
  CFTypeRef cf;

  cf = 0;
  if (curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(a1, a2, &cf, 0, 0, 0, 0, a3, a4))
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    shouldReportToNetworkHistory = curlh_shouldReportToNetworkHistory((uint64_t)a1, (uint64_t)cf);
    if (cf)
      CFRelease(cf);
    if (shouldReportToNetworkHistory)
      return *a3 != 0;
  }
  return 0;
}

uint64_t curlh_requestSetDormantOnQueue(const void *a1, uint64_t a2, int a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  int64_t UpTimeNanoseconds;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  _QWORD *v15;
  NSObject *v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  os_log_type_t v24;
  os_log_type_t type[4];
  uint64_t v26;
  uint64_t v27;
  CFTypeRef cf;
  uint64_t v29;
  dispatch_object_t object;
  CFTypeRef v31;
  CFTypeRef v32;
  CFTypeRef v33;
  int v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  const void *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  double v45;
  _QWORD v46[19];

  v46[16] = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v32 = 0;
  v33 = 0;
  object = 0;
  v31 = 0;
  cf = 0;
  v29 = 0;
  v27 = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 73))
  {
    FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  if (curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(a1, a2, &v32, &v31, &v33, &object, &v29, 0, 0))goto LABEL_28;
  if (!curlh_copyNetworkHistoryIfReporting(a1, a2, &cf, &v27) || (v27 == 0) == a3)
    goto LABEL_26;
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  if (a3)
  {
    if (dword_1ECDA8458)
    {
      LODWORD(v26) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, (int *)&v26, type);
      v11 = v26;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
        v13 = v11;
      else
        v13 = v11 & 0xFFFFFFFE;
      if (v13)
      {
        v14 = *(_QWORD *)(DerivedStorage + 24);
        v34 = 136316418;
        v35 = "curlh_requestSetDormantOnQueue";
        v36 = 2082;
        v37 = v14;
        v38 = 2048;
        v39 = a1;
        v40 = 2048;
        v41 = a2;
        v42 = 2048;
        v43 = v27;
        v44 = 2048;
        v45 = (double)UpTimeNanoseconds / 1000000000.0;
        v15 = (_QWORD *)_os_log_send_and_compose_impl();
        LOBYTE(v11) = v26;
      }
      else
      {
        v15 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v15, v15 != v46, v11, 0, v12);
    }
    FigNetworkHistoryRequestBecameInactive(cf, v27, UpTimeNanoseconds);
    v22 = 0;
    v27 = 0;
  }
  else
  {
    v26 = 1000000;
    FigCFDictionaryGetInt64IfPresent((uint64_t)v32, CFSTR("RequestInfoDefaultLatency"), &v26);
    FigNetworkHistoryRequestBecameActive(cf, UpTimeNanoseconds - v26, &v27);
    FigNetworkHistorySetRequestLatency(cf, v27, UpTimeNanoseconds);
    if (dword_1ECDA8458)
    {
      *(_DWORD *)type = 0;
      v24 = OS_LOG_TYPE_DEFAULT;
      v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, (int *)type, &v24);
      v17 = *(_DWORD *)type;
      if (os_log_type_enabled(v16, v24))
        v19 = v17;
      else
        v19 = v17 & 0xFFFFFFFE;
      if (v19)
      {
        v20 = *(_QWORD *)(DerivedStorage + 24);
        v34 = 136316418;
        v35 = "curlh_requestSetDormantOnQueue";
        v36 = 2082;
        v37 = v20;
        v38 = 2048;
        v39 = a1;
        v40 = 2048;
        v41 = a2;
        v42 = 2048;
        v43 = v27;
        v44 = 2048;
        v45 = (double)UpTimeNanoseconds / 1000000000.0;
        v21 = (_QWORD *)_os_log_send_and_compose_impl();
        LOBYTE(v17) = type[0];
      }
      else
      {
        v21 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v21, v21 != v46, v17, 0, v18);
    }
    v22 = v27;
  }
  v46[0] = 0;
  if (!curlh_getRequestEntryForRequestID((uint64_t)a1, a2, v46))
  {
    *(_QWORD *)(v46[0] + 48) = v22;
LABEL_26:
    if (a4)
      *a4 = v27;
  }
LABEL_28:
  if (cf)
    CFRelease(cf);
  if (v33)
    CFRelease(v33);
  if (v32)
    CFRelease(v32);
  if (v31)
    CFRelease(v31);
  if (object)
    dispatch_release(object);
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
}

BOOL curlh_shouldReportToNetworkHistory(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  Boolean v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v6 = 0;
  FigCFDictionaryGetBooleanIfPresent(a2, CFSTR("RequestInfoExpectedToBlock"), &v6);
  return *(_BYTE *)(DerivedStorage + 72) && v6 == 0;
}

void curl_performDataCallbackDispatch(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 8))(*(_QWORD *)a1, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 48);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 56);
  if (v5)
    CFRelease(v5);
  free((void *)a1);
}

void curlh_sendDataDispatch(uint64_t *a1)
{
  uint64_t v2;
  const void *v3;
  OpaqueCMBlockBuffer *v4;
  uint64_t DerivedStorage;
  int v6;
  CFTypeRef v7;
  uint64_t v8;
  size_t DataLength;
  unint64_t UpTimeNanoseconds;
  int v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef v15;
  CFTypeRef v16;
  CFTypeRef v17;
  uint64_t v18;
  dispatch_object_t object;
  CFTypeRef v20;
  uint64_t v21;
  CFTypeRef cf;

  v3 = (const void *)*a1;
  v2 = a1[1];
  v4 = (OpaqueCMBlockBuffer *)a1[2];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  object = 0;
  v20 = 0;
  v17 = 0;
  v18 = 0;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 73))
  {
    v13 = 4294949925;
LABEL_32:
    v6 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
    goto LABEL_33;
  }
  v6 = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v3, v2, &v17, &v16, &v20, &object, &v18, 0, 0);
  if (v6)
  {
LABEL_33:
    v11 = v6;
    goto LABEL_34;
  }
  if (!v16)
  {
    v13 = 4294949921;
    goto LABEL_32;
  }
  if (curlh_copyNetworkHistoryIfReporting(v3, v2, &v15, &v14) && !v14)
    curlh_requestSetDormantOnQueue(v3, v2, 0, &v14);
  v21 = 0;
  cf = 0;
  if (!v4)
    goto LABEL_14;
  if (curlh_copyNetworkHistoryIfReporting(v3, v2, &cf, &v21))
  {
    v8 = v21;
    v7 = cf;
    DataLength = CMBlockBufferGetDataLength(v4);
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    v11 = FigNetworkHistoryRequestReceivedBytes(v7, v8, DataLength, UpTimeNanoseconds);
  }
  else
  {
    v11 = 0;
  }
  if (cf)
    CFRelease(cf);
  if (!v11)
  {
LABEL_14:
    curl_dispatchDataCallback(object, v20, v18, v2, v16, v4, 0, 0, 0);
    goto LABEL_15;
  }
LABEL_34:
  if (v11 && v20)
  {
    curlh_cleanupRegisteredInfoForRequestID(v3, v2);
    curl_dispatchDataCallbackWithError(object, v20, v18, v2, v17, v16, v11);
  }
LABEL_15:
  if (v15)
    CFRelease(v15);
  if (v17)
    CFRelease(v17);
  if (v16)
    CFRelease(v16);
  if (v20)
    CFRelease(v20);
  if (object)
    dispatch_release(object);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  v12 = (const void *)a1[2];
  if (v12)
    CFRelease(v12);
  free(a1);
}

void curlh_finishLoadingDispatch(uint64_t *a1)
{
  uint64_t v2;
  const void *v3;
  __CFError *v4;
  const void *v5;
  uint64_t DerivedStorage;
  int v7;
  const __CFDictionary *v8;
  const void *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int Code;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v16;
  unsigned int v17;
  uint64_t v18;
  const char *v19;
  _BYTE *v20;
  uint64_t *v21;
  _BOOL8 v22;
  char v23;
  const void *v24;
  const void *v25;
  int v26;
  os_log_type_t type;
  int v28;
  CFDictionaryRef theDict;
  CFTypeRef cf;
  uint64_t v31;
  dispatch_object_t object;
  CFTypeRef v33;
  int v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  const void *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  void *v43;
  __int16 v44;
  int v45;
  _BYTE v46[128];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v3 = (const void *)*a1;
  v2 = a1[1];
  v4 = (__CFError *)a1[2];
  v5 = (const void *)a1[3];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  object = 0;
  v33 = 0;
  cf = 0;
  v31 = 0;
  theDict = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 73))
  {
    v7 = FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    goto LABEL_48;
  }
  v7 = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v3, v2, &cf, &theDict, &v33, &object, &v31, 0, 0);
  if (!v7)
  {
    v8 = theDict;
    if (!theDict)
    {
      v7 = FigCustomURLResponseInfoCreate(*(const __CFAllocator **)(DerivedStorage + 16), cf, (CFTypeRef *)&theDict);
      if (v7)
        goto LABEL_48;
      v8 = theDict;
    }
    v9 = (const void *)*MEMORY[0x1E0C9AE50];
    if (v9 == CFDictionaryGetValue(v8, CFSTR("ResponseInfoSuppressErrorLogging")))
    {
      if (dword_1ECDA8458)
      {
        v28 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v28, &type);
        v16 = v28;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v17 = v16;
        else
          v17 = v16 & 0xFFFFFFFE;
        if (v17)
        {
          v18 = *(_QWORD *)(DerivedStorage + 24);
          v19 = "suppressed";
          if (!v4)
            v19 = 0;
          v34 = 136316162;
          v35 = "curlh_finishLoadingOnQueue";
          v36 = 2082;
          v37 = v18;
          v38 = 2048;
          v39 = v3;
          v40 = 2048;
          v41 = v2;
          v42 = 2080;
          v43 = (void *)v19;
          v20 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v16) = v28;
        }
        else
        {
          v20 = 0;
        }
        v21 = (uint64_t *)qword_1ECDA8450;
        v22 = v20 != v46;
        v23 = v16;
        goto LABEL_28;
      }
    }
    else if (dword_1ECDA8458)
    {
      v28 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v28, &type);
      LODWORD(v11) = v28;
      if (os_log_type_enabled(v10, type))
        v13 = v11;
      else
        v13 = v11 & 0xFFFFFFFE;
      if (v13)
      {
        v11 = *(_QWORD *)(DerivedStorage + 24);
        if (v4)
          Code = CFErrorGetCode(v4);
        else
          Code = 0;
        v34 = 136316419;
        v35 = "curlh_finishLoadingOnQueue";
        v36 = 2082;
        v37 = v11;
        v38 = 2048;
        v39 = v3;
        v40 = 2048;
        v41 = v2;
        v42 = 2113;
        v43 = v4;
        v44 = 1024;
        v45 = Code;
        v20 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v11) = v28;
      }
      else
      {
        v20 = 0;
      }
      v21 = (uint64_t *)qword_1ECDA8450;
      v22 = v20 != v46;
      v23 = v11;
LABEL_28:
      fig_log_call_emit_and_clean_up_after_send_and_compose(v21, 1u, 1, v20, v22, v23, 0, v12);
    }
    v7 = curlh_networkHistoryRequestBecameInactive(v3, v2);
    if (!v7)
    {
      v7 = curlh_cleanupRegisteredInfoForRequestID(v3, v2);
      if (!v7)
      {
        curl_dispatchDataCallback(object, v33, v31, v2, theDict, 0, 1, v4, v5);
        goto LABEL_32;
      }
    }
  }
LABEL_48:
  v26 = v7;
  if (v7 && v33)
  {
    curlh_cleanupRegisteredInfoForRequestID(v3, v2);
    curl_dispatchDataCallbackWithError(object, v33, v31, v2, cf, theDict, v26);
  }
LABEL_32:
  if (cf)
    CFRelease(cf);
  if (theDict)
    CFRelease(theDict);
  if (v33)
    CFRelease(v33);
  if (object)
    dispatch_release(object);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  v24 = (const void *)a1[2];
  if (v24)
    CFRelease(v24);
  v25 = (const void *)a1[3];
  if (v25)
    CFRelease(v25);
  free(a1);
}

uint64_t curlh_networkHistoryRequestBecameInactive(const void *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  CFTypeRef v4;
  unint64_t UpTimeNanoseconds;
  uint64_t v7;
  CFTypeRef cf;

  v7 = 0;
  cf = 0;
  v2 = 0;
  if (curlh_copyNetworkHistoryIfReporting(a1, a2, &cf, &v7))
  {
    v3 = v7;
    if (v7)
    {
      v4 = cf;
      UpTimeNanoseconds = FigGetUpTimeNanoseconds();
      v2 = FigNetworkHistoryRequestBecameInactive(v4, v3, UpTimeNanoseconds);
    }
  }
  if (cf)
    CFRelease(cf);
  return v2;
}

void curlh_handleRequestDispatch(const __CFData *a1)
{
  uint64_t *BytePtr;
  const void *v3;
  const void *v4;
  uint64_t v5;
  uint64_t DerivedStorage;
  uint64_t v7;
  id *v8;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t *v15;
  const __CFAllocator *v16;
  const UInt8 *v17;
  UInt8 *v18;
  CFDataRef v19;
  CFDataRef v20;
  CFTypeRef v21;
  CFTypeRef v22;
  CFTypeRef v23;
  NSObject *v24;
  void *v25;
  int v26;
  int v27;
  uint64_t *v28;
  const void *v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  CFTypeRef v33;
  CFTypeRef v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  _BYTE *v41;
  os_log_type_t type;
  int v43;
  int v44;
  const char *v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  const void *v49;
  __int16 v50;
  uint64_t v51;
  _BYTE v52[128];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  BytePtr = (uint64_t *)CFDataGetBytePtr(a1);
  v4 = (const void *)*BytePtr;
  v3 = (const void *)BytePtr[1];
  v5 = BytePtr[2];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*BytePtr);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 73))
  {
    v26 = FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    goto LABEL_36;
  }
  v7 = CMBaseObjectGetDerivedStorage((uint64_t)v4);
  v8 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(v7 + 32));
  if (!v8)
  {
    v26 = -17373;
    goto LABEL_37;
  }
  if (dword_1ECDA8458)
  {
    v43 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v43, &type);
    v10 = v43;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v12 = v10;
    else
      v12 = v10 & 0xFFFFFFFE;
    if (v12)
    {
      v13 = *(_QWORD *)(DerivedStorage + 24);
      v44 = 136315906;
      v45 = "curlh_handleRequestOnQueue";
      v46 = 2082;
      v47 = v13;
      v48 = 2048;
      v49 = v4;
      v50 = 2048;
      v51 = v5;
      v14 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v10) = v43;
    }
    else
    {
      v14 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v14, v14 != v52, v10, 0, v11);
  }
  v15 = (uint64_t *)CMBaseObjectGetDerivedStorage((uint64_t)v4);
  if (performHandleRequestCallbackRec_getCFAllocator_sOnceToken != -1)
    dispatch_once_f(&performHandleRequestCallbackRec_getCFAllocator_sOnceToken, &performHandleRequestCallbackRec_getCFAllocator_sAllocator, (dispatch_function_t)performHandleRequestCallbackRec_initializeCFAllocatorOnce);
  v16 = (const __CFAllocator *)performHandleRequestCallbackRec_getCFAllocator_sAllocator;
  if (performHandleRequestCallbackRec_getCFAllocator_sAllocator
    || (v27 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0)) == 0)
  {
    v17 = (const UInt8 *)malloc_type_calloc(1uLL, 0x38uLL, 0x10E0040A6443F3CuLL);
    if (v17)
    {
      v18 = (UInt8 *)v17;
      v19 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v17, 56, v16);
      if (v19)
      {
        v20 = v19;
        *(_QWORD *)v18 = v15[7];
        *((_QWORD *)v18 + 1) = CFRetain(v8);
        if (v4)
          v21 = CFRetain(v4);
        else
          v21 = 0;
        *((_QWORD *)v18 + 2) = v21;
        *((_QWORD *)v18 + 3) = v5;
        if (v3)
          v22 = CFRetain(v3);
        else
          v22 = 0;
        *((_QWORD *)v18 + 4) = v22;
        *((_QWORD *)v18 + 5) = curlh_handleRequestCompletionHandlerDispatch;
        if (a1)
          v23 = CFRetain(a1);
        else
          v23 = 0;
        *((_QWORD *)v18 + 6) = v23;
        figCustomURLWorkQueueSuspendDraining(*v15);
        v24 = v15[5];
        v25 = (void *)CFRetain(v20);
        dispatch_async_f(v24, v25, (dispatch_function_t)curlh_performHandleRequestCallbackDispatch);
        CFRelease(v20);
        goto LABEL_26;
      }
      free(v18);
    }
    v26 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_36:
    if (!v26)
      goto LABEL_44;
    goto LABEL_37;
  }
  v26 = v27;
LABEL_37:
  v28 = (uint64_t *)CFDataGetBytePtr(a1);
  v29 = (const void *)*v28;
  v30 = CMBaseObjectGetDerivedStorage(*v28);
  v31 = malloc_type_calloc(1uLL, 0x20uLL, 0x10E004018FB7DF4uLL);
  if (v31)
  {
    v32 = v31;
    if (v29)
      v33 = CFRetain(v29);
    else
      v33 = 0;
    *v32 = v33;
    v32[1] = v28[6];
    v34 = (CFTypeRef)v28[7];
    if (v34)
      v34 = CFRetain(v34);
    v32[2] = v34;
    *((_DWORD *)v32 + 6) = v26;
    figCustomURLWorkQueueSuspendDraining(*(_QWORD *)v30);
    dispatch_async_f(*(dispatch_queue_t *)(v30 + 40), v32, (dispatch_function_t)curlh_haltHandleRequestBeforeCallbackDueToErrorDispatch);
  }
  else
  {
    v35 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)v35)
    {
      v36 = v35;
      v43 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v37 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 0, &v43, &type);
      v38 = v43;
      if (os_log_type_enabled(v37, type))
        v40 = v38;
      else
        v40 = v38 & 0xFFFFFFFE;
      if (v40)
      {
        v44 = 136315138;
        v45 = "curlh_haltHandleRequestBeforeCallbackDueToError";
        v41 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v38) = v43;
      }
      else
      {
        v41 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 0, 1, v41, v41 != v52, v38, 0, v39);
      ((void (*)(uint64_t, _QWORD, uint64_t))v28[6])(v28[7], 0, v36);
    }
  }
LABEL_44:
  if (v8)
LABEL_26:
    CFRelease(v8);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (a1)
    CFRelease(a1);
}

uint64_t handleRequestRec_initializeCFAllocatorOnce(_QWORD *a1)
{
  uint64_t result;
  CFTypeRef v3;

  v3 = 0;
  result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))handleRequestRec_dealloc, &v3);
  if (!(_DWORD)result)
    *a1 = v3;
  return result;
}

void handleRequestRec_dealloc(const void **a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  NSObject *v5;
  const void *v6;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  v3 = a1[1];
  if (v3)
    CFRelease(v3);
  v4 = a1[3];
  if (v4)
    CFRelease(v4);
  v5 = a1[4];
  if (v5)
    dispatch_release(v5);
  v6 = a1[7];
  if (v6)
    CFRelease(v6);
  free(a1);
}

uint64_t curlh_handleRequestCompletionHandlerDispatch(const __CFData *a1, unsigned int a2, uint64_t a3)
{
  const UInt8 *BytePtr;
  uint64_t v6;
  const __CFDictionary *v7;
  uint64_t v8;
  uint64_t (*v9)(_QWORD, _QWORD, _QWORD);
  uint64_t v10;
  uint64_t DerivedStorage;
  uint64_t v12;
  int ValueIfPresent;
  void *v14;
  unint64_t UpTimeNanoseconds;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(_QWORD, _QWORD, _QWORD);
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  CFTypeRef v23;
  CFTypeRef v24;
  CFTypeRef v25;
  _QWORD *v26;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v28;
  uint64_t v29;
  unsigned int v30;
  const char *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  os_log_type_t type;
  int v41;
  void *value;
  int v43;
  const char *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  const char *v52;
  uint64_t v53[18];

  v53[16] = *MEMORY[0x1E0C80C00];
  BytePtr = CFDataGetBytePtr(a1);
  v6 = *(_QWORD *)BytePtr;
  v7 = (const __CFDictionary *)*((_QWORD *)BytePtr + 1);
  v8 = *((_QWORD *)BytePtr + 3);
  v38 = *((_QWORD *)BytePtr + 2);
  v39 = *((_OWORD *)BytePtr + 2);
  v9 = (uint64_t (*)(_QWORD, _QWORD, _QWORD))*((_QWORD *)BytePtr + 6);
  v10 = *((_QWORD *)BytePtr + 7);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)BytePtr);
  value = 0;
  if ((_DWORD)a3)
    goto LABEL_34;
  v12 = DerivedStorage;
  if (!a2)
    goto LABEL_21;
  v53[0] = 0;
  v37 = DerivedStorage;
  if (!curlh_shouldReportToNetworkHistory(v6, (uint64_t)v7))
  {
    v17 = v10;
    v18 = v9;
    v19 = 0;
    v14 = 0;
    goto LABEL_11;
  }
  ValueIfPresent = CFDictionaryGetValueIfPresent(v7, CFSTR("RequestInfoNetworkHistory"), (const void **)&value);
  if (!value)
  {
    v14 = 0;
    if (ValueIfPresent)
      goto LABEL_6;
LABEL_10:
    v17 = v10;
    v18 = v9;
    v19 = 0;
    goto LABEL_11;
  }
  CFRetain(value);
  v14 = value;
  if (!ValueIfPresent)
    goto LABEL_10;
LABEL_6:
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v16 = FigNetworkHistoryRequestBecameActive(v14, UpTimeNanoseconds, v53);
  if ((_DWORD)v16)
  {
    a3 = v16;
    goto LABEL_32;
  }
  v17 = v10;
  v18 = v9;
  v14 = value;
  v19 = v53[0];
LABEL_11:
  v20 = CMBaseObjectGetDerivedStorage(v6);
  v21 = CFAllocatorAllocate(*(CFAllocatorRef *)(v20 + 16), 80, 0);
  v22 = v21;
  if (v21)
  {
    *v21 = v38;
    dispatch_retain((dispatch_object_t)v39);
    *((_OWORD *)v22 + 1) = v39;
    v23 = v7 ? CFRetain(v7) : 0;
    v22[4] = v23;
    v22[7] = 0;
    v24 = v14 ? CFRetain(v14) : 0;
    v22[5] = v24;
    v22[6] = v19;
    v25 = FigCFWeakReferenceHolderCreateWithReferencedObject(v8);
    v22[1] = v25;
    if (v25)
    {
      v22[8] = 0;
      v26 = *(_QWORD **)(v20 + 88);
      v22[9] = v26;
      *v26 = v22;
      *(_QWORD *)(v20 + 88) = v22 + 8;
LABEL_20:
      v9 = v18;
      v10 = v17;
      v12 = v37;
LABEL_21:
      if (dword_1ECDA8458)
      {
        v41 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v41, &type);
        v28 = v41;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v30 = v28;
        else
          v30 = v28 & 0xFFFFFFFE;
        if (v30)
        {
          v31 = "YES";
          v32 = *(_QWORD *)(v12 + 24);
          v44 = "curlh_handleRequestCompletionHandler";
          v45 = 2082;
          v43 = 136316162;
          if (!a2)
            v31 = "NO";
          v46 = v32;
          v47 = 2048;
          v48 = v6;
          v49 = 2048;
          v50 = v38;
          v51 = 2080;
          v52 = v31;
          v33 = (uint64_t *)_os_log_send_and_compose_impl();
          LOBYTE(v28) = v41;
        }
        else
        {
          v33 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v33, v33 != v53, v28, 0, v29);
      }
      a3 = 0;
      goto LABEL_32;
    }
  }
  v36 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  if (!(_DWORD)v36)
    goto LABEL_20;
  a3 = v36;
  CFAllocatorDeallocate(*(CFAllocatorRef *)(v20 + 16), v22);
  v9 = v18;
  v10 = v17;
LABEL_32:
  if (value)
    CFRelease(value);
LABEL_34:
  if ((_DWORD)a3)
    v34 = 0;
  else
    v34 = a2;
  return v9(v10, v34, a3);
}

uint64_t figCustomURLWorkQueueSuspendDraining(uint64_t a1)
{
  unsigned int v2;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v2 = *(_DWORD *)(a1 + 40);
  if (v2 >= 4)
  {
    if (v2 == 4)
      FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 2;
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
}

uint64_t curlh_performHandleRequestCallbackDispatch(const __CFData *a1)
{
  const UInt8 *BytePtr;

  BytePtr = CFDataGetBytePtr(a1);
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, void (*)(const __CFData *, uint64_t, uint64_t), const __CFData *))BytePtr)(*((_QWORD *)BytePtr + 1), *((_QWORD *)BytePtr + 2), *((_QWORD *)BytePtr + 4), *((_QWORD *)BytePtr + 3), curlh_handleRequestCallbackShimCompletionHandler, a1);
}

uint64_t performHandleRequestCallbackRec_initializeCFAllocatorOnce(_QWORD *a1)
{
  uint64_t result;
  CFTypeRef v3;

  v3 = 0;
  result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))performHandleRequestCallbackRec_dealloc, &v3);
  if (!(_DWORD)result)
    *a1 = v3;
  return result;
}

void performHandleRequestCallbackRec_dealloc(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  v2 = (const void *)a1[1];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[2];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[4];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[6];
  if (v5)
    CFRelease(v5);
  free(a1);
}

void curlh_handleRequestCallbackShimCompletionHandler(const __CFData *a1, uint64_t a2, uint64_t a3)
{
  const UInt8 *BytePtr;
  uint64_t DerivedStorage;

  BytePtr = CFDataGetBytePtr(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*((_QWORD *)BytePtr + 2));
  (*((void (**)(_QWORD, uint64_t, uint64_t))BytePtr + 5))(*((_QWORD *)BytePtr + 6), a2, a3);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (!*(_BYTE *)(DerivedStorage + 73))
    figCustomURLWorkQueueResumeDraining(*(_QWORD *)DerivedStorage);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (a1)
    CFRelease(a1);
}

uint64_t figCustomURLWorkQueueResumeDraining(uint64_t a1)
{
  unsigned int v2;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v2 = *(_DWORD *)(a1 + 40);
  if (v2 >= 3)
  {
    if (v2 == 3)
    {
      figCustomURLWorkQueueDrain(a1, 1);
    }
    else if (v2 == 4)
    {
      FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 1;
  }
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
}

void curlh_haltHandleRequestBeforeCallbackDueToErrorDispatch(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v3;

  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)a1);
  (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16), 0, *(unsigned int *)(a1 + 24));
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 73))
    FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
  else
    figCustomURLWorkQueueResumeDraining(*(_QWORD *)DerivedStorage);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  v3 = *(const void **)(a1 + 16);
  if (v3)
    CFRelease(v3);
  free((void *)a1);
}

void curlh_cancelRequestDispatch(uint64_t *a1)
{
  const void *v2;
  uint64_t v3;
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  id *v12;
  CFTypeRef v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  CFTypeRef v18;
  CFTypeRef v19;
  os_log_type_t type;
  int v21;
  uint64_t v22;
  dispatch_object_t object;
  CFTypeRef v24;
  CFTypeRef v25;
  CFTypeRef cf;
  int v27;
  const char *v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  const void *v32;
  __int16 v33;
  uint64_t v34;
  char v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v2 = (const void *)*a1;
  v3 = a1[1];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  v25 = 0;
  cf = 0;
  object = 0;
  v24 = 0;
  v22 = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 73))
  {
    FigSignalErrorAt(4294949925, 0, 0, 0, 0, 0, 0);
    v12 = 0;
  }
  else
  {
    if (dword_1ECDA8458)
    {
      v21 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v21, &type);
      v6 = v21;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v8 = v6;
      else
        v8 = v6 & 0xFFFFFFFE;
      if (v8)
      {
        v9 = *(_QWORD *)(DerivedStorage + 24);
        v27 = 136315906;
        v28 = "curlh_cancelRequestOnQueue";
        v29 = 2082;
        v30 = v9;
        v31 = 2048;
        v32 = v2;
        v33 = 2048;
        v34 = v3;
        v10 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v6) = v21;
      }
      else
      {
        v10 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v10, v10 != &v35, v6, 0, v7);
    }
    v11 = CMBaseObjectGetDerivedStorage((uint64_t)v2);
    v12 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(v11 + 32));
    if (v12
      && !curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v2, v3, &v25, &v24, &cf, &object, &v22, 0, 0)&& (v24|| !FigCustomURLResponseInfoCreateMutable(*(const __CFAllocator **)(DerivedStorage + 16), v25, &v24))&& !curlh_networkHistoryRequestBecameInactive(v2, v3))
    {
      v13 = v25;
      v14 = CMBaseObjectGetDerivedStorage((uint64_t)v2);
      if (!*(_QWORD *)(v14 + 64))
        goto LABEL_24;
      v15 = v14;
      v16 = malloc_type_calloc(1uLL, 0x28uLL, 0x10E00409DBA6119uLL);
      if (v16)
      {
        v17 = v16;
        *v16 = *(_QWORD *)(v15 + 64);
        v16[1] = CFRetain(v12);
        if (v2)
          v18 = CFRetain(v2);
        else
          v18 = 0;
        v17[2] = v18;
        v17[3] = v3;
        if (v13)
          v19 = CFRetain(v13);
        else
          v19 = 0;
        v17[4] = v19;
        dispatch_async_f(*(dispatch_queue_t *)(v15 + 40), v17, (dispatch_function_t)curlh_performRequestCancelledCallbackDispatch);
        goto LABEL_24;
      }
      if (!FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0))
      {
LABEL_24:
        curl_dispatchDataCallback(object, cf, v22, v3, v24, 0, 2, 0, 0);
        curlh_cleanupRegisteredInfoForRequestID(v2, v3);
      }
    }
  }
  if (cf)
    CFRelease(cf);
  if (v12)
    CFRelease(v12);
  if (v25)
    CFRelease(v25);
  if (v24)
    CFRelease(v24);
  if (object)
    dispatch_release(object);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  free(a1);
}

void curlh_performRequestCancelledCallbackDispatch(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD))*a1)(a1[1], a1[2], a1[4], a1[3]);
  v2 = (const void *)a1[1];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[2];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[4];
  if (v4)
    CFRelease(v4);
  free(a1);
}

void curlh_requestSetDormantDispatch(uint64_t a1)
{
  curlh_requestSetDormantOnQueue(*(const void **)a1, *(_QWORD *)(a1 + 8), *(unsigned __int8 *)(a1 + 16), 0);
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  free((void *)a1);
}

void curlh_lookupAndRetainRegisteredInfoForRequestIDDispatch(uint64_t a1)
{
  CFTypeRef v2;
  uint64_t v3;
  uint64_t v4;
  void (*v5)(CFTypeRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, CFTypeRef, NSObject *, uint64_t, uint64_t, uint64_t);
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  CFTypeRef v14;

  v2 = *(CFTypeRef *)a1;
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(void (**)(CFTypeRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, CFTypeRef, NSObject *, uint64_t, uint64_t, uint64_t))(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v14 = 0;
  v12 = 0;
  v13 = 0;
  v10 = 0;
  v11 = 0;
  v8 = 0;
  v9 = 0;
  v6 = curlh_lookupAndRetainRegisteredInfoForRequestIDOnQueue(v2, v3, &v13, &v12, &v14, &v11, &v10, &v9, &v8);
  v5(v2, v3, v4, v6, v13, v12, v14, v11, v10, v9, v8);
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  v7 = *(const void **)(a1 + 24);
  if (v7)
    CFRelease(v7);
  free((void *)a1);
}

uint64_t figCustomURLWorkQueueRegisterType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCustomURLWorkQueueTypeID = result;
  return result;
}

double figCustomURLWorkQueueInit(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

uint64_t figCustomURLWorkQueueFinalize(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (*(_DWORD *)(a1 + 40) != 4)
  {
    v3 = (_QWORD *)(a1 + 24);
    v2 = *(_QWORD **)(a1 + 24);
    *(_DWORD *)(a1 + 40) = 4;
    if (v2)
    {
      do
      {
        v4 = v2[2];
        *v3 = v4;
        if (!v4)
          *(_QWORD *)(a1 + 32) = v3;
        free(v2);
        v2 = (_QWORD *)*v3;
      }
      while (*v3);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return FigReentrantMutexDestroy(*(_QWORD *)(a1 + 16));
}

CFStringRef figCustomURLWorkQueueCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCustomURLWorkQueue %p]"), a1);
}

CFStringRef figCustomURLWorkQueueCopyDebugDesc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFAllocator *v4;
  CFIndex v5;
  CFStringRef v6;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v3 = 0;
    do
    {
      ++v3;
      v2 = *(_QWORD *)(v2 + 16);
    }
    while (v2);
  }
  else
  {
    v3 = 0;
  }
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFGetRetainCount((CFTypeRef)a1);
  v6 = CFStringCreateWithFormat(v4, 0, CFSTR("[FigCustomURLWorkQueue %p (%d) { %zu jobs enqueued; state = %d }]"),
         a1,
         v5,
         v3,
         *(unsigned int *)(a1 + 40));
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v6;
}

CFStringRef FigCustomURLLoaderCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCustomURLLoader %p]"), a1);
}

uint64_t curll_invalidate(const void *a1)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  uint64_t v8;
  CFIndex v9;
  const void *ValueAtIndex;
  __CFNotificationCenter *DefaultLocalCenter;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  os_log_type_t type;
  int v18[2];
  const char *v19;
  __int16 v20;
  const void *v21;
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (!*(_BYTE *)(DerivedStorage + 24))
  {
    *(_BYTE *)(DerivedStorage + 24) = 1;
    if (dword_1ECDA8458)
    {
      v18[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, v18, &type);
      v4 = v18[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v6 = v4;
      else
        v6 = v4 & 0xFFFFFFFE;
      if (v6)
      {
        v18[1] = 136315394;
        v19 = "curll_invalidate";
        v20 = 2048;
        v21 = a1;
        v7 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v4) = v18[0];
      }
      else
      {
        v7 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v7, v7 != &v22, v4, 0, v5);
    }
    v8 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    if (CFArrayGetCount(*(CFArrayRef *)(v8 + 48)) >= 1)
    {
      v9 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v8 + 48), v9);
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        if (FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)curll_requestCompletedNote, CFSTR("CURLHNotification_RequestCompleted"), ValueAtIndex))break;
        ++v9;
      }
      while (v9 < CFArrayGetCount(*(CFArrayRef *)(v8 + 48)));
    }
    v12 = *(const void **)(DerivedStorage + 16);
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(DerivedStorage + 16) = 0;
    }
    v13 = *(const void **)(DerivedStorage + 40);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(DerivedStorage + 40) = 0;
    }
    v14 = *(const void **)(DerivedStorage + 48);
    if (v14)
    {
      CFRelease(v14);
      *(_QWORD *)(DerivedStorage + 48) = 0;
    }
    v15 = *(const void **)(DerivedStorage + 56);
    if (v15)
    {
      CFRelease(v15);
      *(_QWORD *)(DerivedStorage + 56) = 0;
    }
    if (*(_QWORD *)DerivedStorage)
    {
      CFRelease(*(CFTypeRef *)DerivedStorage);
      *(_QWORD *)DerivedStorage = 0;
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return 0;
}

uint64_t curll_finalize(const void *a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  curll_invalidate(a1);
  return FigReentrantMutexDestroy(*(_QWORD *)(DerivedStorage + 8));
}

uint64_t curll_copyDebugDescription()
{
  return 0;
}

uint64_t curll_copyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFNumberRef *a4)
{
  uint64_t DerivedStorage;
  CFNumberRef UInt64;
  uint64_t v9;
  uint64_t v11;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v11 = 4294949915;
LABEL_11:
    v9 = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  if (!a4)
  {
    v11 = 4294949916;
    goto LABEL_11;
  }
  if (!FigCFEqual(CFSTR("CURLLProperty_AllowedCommonMediaClientDataKeys"), a2))
  {
    v9 = 4294954512;
    goto LABEL_7;
  }
  UInt64 = FigCFNumberCreateUInt64(a3, *(_QWORD *)(DerivedStorage + 32));
  *a4 = UInt64;
  if (!UInt64)
  {
    v11 = 4294954510;
    goto LABEL_11;
  }
  v9 = 0;
LABEL_7:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v9;
}

uint64_t curll_setProperty(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  CFTypeID v6;
  uint64_t v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v8 = 4294949915;
LABEL_11:
    a3 = FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  if (!FigCFEqual(CFSTR("CURLLProperty_AllowedCommonMediaClientDataKeys"), a2))
  {
    a3 = 4294954512;
    goto LABEL_8;
  }
  if (!a3)
  {
    *(_QWORD *)(DerivedStorage + 32) = 0;
    goto LABEL_8;
  }
  v6 = CFGetTypeID((CFTypeRef)a3);
  if (v6 != CFNumberGetTypeID())
  {
    v8 = 4294949916;
    goto LABEL_11;
  }
  *(_QWORD *)(DerivedStorage + 32) = 0;
  CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, (void *)(DerivedStorage + 32));
  a3 = 0;
LABEL_8:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return a3;
}

void curll_requestCompletedNote(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  void *v8;
  uint64_t v9;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a2);
  v13 = 0;
  if (!FigCFDictionaryGetInt64IfPresent(a5, CFSTR("CURLHRequestCompletedNotificationKey_RequestID"), &v13))return;
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v12 = 4294949915;
LABEL_14:
    FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    return;
  }
  v8 = malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
  if (!v8)
  {
    v12 = 4294954510;
    goto LABEL_14;
  }
  v9 = (uint64_t)v8;
  if (a2)
    v10 = CFRetain(a2);
  else
    v10 = 0;
  v11 = v13;
  *(_QWORD *)v9 = v10;
  *(_QWORD *)(v9 + 8) = v11;
  if (figCustomURLWorkQueueEnqueue(*(_QWORD *)DerivedStorage, (uint64_t)curll_unregisterHandlerForRequestDispatch, v9))
  {
    if (*(_QWORD *)v9)
      CFRelease(*(CFTypeRef *)v9);
    free((void *)v9);
  }
}

void curll_unregisterHandlerForRequestDispatch(uint64_t *a1)
{
  curll_unregisterHandlerForRequestOnQueue(*a1, a1[1]);
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  free(a1);
}

uint64_t curll_unregisterHandlerForRequestOnQueue(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  uint64_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
    v4 = FigSignalErrorAt(4294954511, 0, 0, 0, 0, 0, 0);
  else
    v4 = FigCFWeakReferenceTableRemoveValue(*(_QWORD *)(DerivedStorage + 56), a2);
  v5 = v4;
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v5;
}

uint64_t curll_installHandler(void *a1, const void *a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  const __CFArray *v13;
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v15;
  uint64_t v17;
  os_log_type_t type;
  int v19[2];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  const void *v24;
  __int16 v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  CFRange v29;

  v28 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v17 = 4294949915;
LABEL_16:
    v12 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 40), a2))
  {
    v17 = 4294949914;
    goto LABEL_16;
  }
  if (dword_1ECDA8458)
  {
    v19[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, v19, &type);
    v8 = v19[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v10 = v8;
    else
      v10 = v8 & 0xFFFFFFFE;
    if (v10)
    {
      v19[1] = 136315906;
      v20 = "curll_installHandler";
      v21 = 2048;
      v22 = DerivedStorage;
      v23 = 2048;
      v24 = a2;
      v25 = 2048;
      v26 = a3;
      v11 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v8) = v19[0];
    }
    else
    {
      v11 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v11, v11 != &v27, v8, 0, v9);
  }
  v12 = FigCFDictionarySetCFIndex(*(void **)(DerivedStorage + 40), a2, a3);
  if (!(_DWORD)v12)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 48), a2);
    v13 = *(const __CFArray **)(DerivedStorage + 48);
    v29.length = CFArrayGetCount(v13);
    v29.location = 0;
    CFArraySortValues(v13, v29, (CFComparatorFunction)curll_compareHandlersByPriority, (void *)DerivedStorage);
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    v12 = FigNotificationCenterAddWeakListener(DefaultLocalCenter, a1, (CFNotificationCallback)curll_requestCompletedNote, CFSTR("CURLHNotification_RequestCompleted"), (unint64_t)a2, 0, 0);
  }
LABEL_13:
  v15 = v12;
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v15;
}

uint64_t curll_createAndInstallHandler(void *a1, uint64_t a2, const char *a3, uint64_t a4, NSObject *a5, __int128 *a6, uint64_t a7, _QWORD *a8)
{
  uint64_t DerivedStorage;
  uint64_t v17;
  CFTypeRef v18;
  CFTypeRef v19;
  uint64_t v20;
  CFTypeRef cf;

  cf = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v20 = FigSignalErrorAt(4294949915, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v17 = FigCustomURLHandlerCreate(*(const void **)(DerivedStorage + 16), a3, a4, a5, a6, a7, &cf);
  v18 = cf;
  if ((_DWORD)v17 || (v17 = curll_installHandler(a1, cf, a2), v18 = cf, (_DWORD)v17))
  {
    v20 = v17;
    if (!v18)
      goto LABEL_9;
    goto LABEL_8;
  }
  if (cf)
  {
    v19 = CFRetain(cf);
    v18 = cf;
  }
  else
  {
    v19 = 0;
  }
  v20 = 0;
  *a8 = v19;
  if (v18)
LABEL_8:
    CFRelease(v18);
LABEL_9:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  return v20;
}

uint64_t curll_getURL(const void *a1, const void *a2, const void *a3, NSObject *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t DerivedStorage;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  const void *v22;
  const void *v23;
  NSObject *v24;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1 || !a2 || !a3 || !a4 || !a5 || !a6)
  {
    v21 = 4294949916;
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
  v13 = (uint64_t *)DerivedStorage;
  v14 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v15 = FigAtomicIncrement32((unsigned int *)(v14 + 28));
  v16 = malloc_type_calloc(1uLL, 0x30uLL, 0x10E004085FF1568uLL);
  if (!v16)
  {
    v21 = 4294954510;
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
  v17 = (uint64_t)v16;
  v18 = 2 * v15;
  *v16 = CFRetain(a1);
  *(_QWORD *)(v17 + 16) = CFRetain(a2);
  *(_QWORD *)(v17 + 8) = CFRetain(a3);
  dispatch_retain(a4);
  *(_QWORD *)(v17 + 24) = a4;
  *(_QWORD *)(v17 + 32) = a5;
  *(_QWORD *)(v17 + 40) = v18;
  v19 = figCustomURLWorkQueueEnqueue(*v13, (uint64_t)curll_getURLDispatch, v17);
  if ((_DWORD)v19)
  {
    if (*(_QWORD *)v17)
      CFRelease(*(CFTypeRef *)v17);
    v22 = *(const void **)(v17 + 16);
    if (v22)
      CFRelease(v22);
    v23 = *(const void **)(v17 + 8);
    if (v23)
      CFRelease(v23);
    v24 = *(NSObject **)(v17 + 24);
    if (v24)
      dispatch_release(v24);
    free((void *)v17);
  }
  else
  {
    *a6 = v18;
  }
  return v19;
}

uint64_t curll_cancelRequest(const void *a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1)
  {
    v10 = 4294949916;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v5 = (uint64_t *)DerivedStorage;
  v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
  if (!v6)
  {
    v10 = 4294954510;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v7 = (uint64_t)v6;
  *v6 = CFRetain(a1);
  *(_QWORD *)(v7 + 8) = a2;
  v8 = figCustomURLWorkQueueEnqueue(*v5, (uint64_t)curll_cancelRequestDispatch, v7);
  if ((_DWORD)v8)
  {
    if (*(_QWORD *)v7)
      CFRelease(*(CFTypeRef *)v7);
    free((void *)v7);
  }
  return v8;
}

uint64_t curll_requestSetDormant(const void *a1, uint64_t a2, char a3)
{
  uint64_t DerivedStorage;
  uint64_t *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1)
  {
    v12 = 4294949916;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v7 = (uint64_t *)DerivedStorage;
  v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x10600407BD382EDuLL);
  if (!v8)
  {
    v12 = 4294954510;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v9 = (uint64_t)v8;
  *v8 = CFRetain(a1);
  *(_QWORD *)(v9 + 8) = a2;
  *(_BYTE *)(v9 + 16) = a3;
  v10 = figCustomURLWorkQueueEnqueue(*v7, (uint64_t)curll_requestSetDormantDispatch, v9);
  if ((_DWORD)v10)
  {
    if (*(_QWORD *)v9)
      CFRelease(*(CFTypeRef *)v9);
    free((void *)v9);
  }
  return v10;
}

uint64_t curll_transferHandlingOfRequest(const void *a1, const void *a2, const void *a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t *v9;
  const __CFAllocator *v10;
  const UInt8 *v11;
  _QWORD *v12;
  CFDataRef v13;
  CFDataRef v14;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  CFTypeRef v23;
  uint64_t v24;
  uint64_t v26;
  os_log_type_t type;
  int v28[2];
  const char *v29;
  __int16 v30;
  uint64_t *v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  char v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a1 && a2 && a3)
  {
    v9 = (uint64_t *)DerivedStorage;
    if (transferHandlingOfRequestRec_getCFAllocator_sOnceToken != -1)
      dispatch_once_f(&transferHandlingOfRequestRec_getCFAllocator_sOnceToken, &transferHandlingOfRequestRec_getCFAllocator_sAllocator, (dispatch_function_t)transferHandlingOfRequestRec_initializeCFAllocatorOnce);
    v10 = (const __CFAllocator *)transferHandlingOfRequestRec_getCFAllocator_sAllocator;
    if (!transferHandlingOfRequestRec_getCFAllocator_sAllocator)
    {
      v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      if ((_DWORD)v24)
        return v24;
    }
    v11 = (const UInt8 *)malloc_type_calloc(1uLL, 0x48uLL, 0x10E004078E2DE95uLL);
    if (v11)
    {
      v12 = v11;
      v13 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v11, 72, v10);
      if (v13)
      {
        v14 = v13;
        *v12 = CFRetain(a1);
        v12[1] = CFRetain(a2);
        v12[2] = CFRetain(a3);
        v12[3] = a4;
        if (dword_1ECDA8458)
        {
          v28[0] = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, v28, &type);
          v16 = v28[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v18 = v16;
          else
            v18 = v16 & 0xFFFFFFFE;
          if (v18)
          {
            v19 = v12[3];
            v20 = v12[1];
            v28[1] = 136316162;
            v29 = "curll_transferHandlingOfRequest";
            v30 = 2048;
            v31 = v9;
            v32 = 2048;
            v33 = v19;
            v34 = 2048;
            v35 = v20;
            v36 = 2048;
            v37 = v20;
            v21 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v16) = v28[0];
          }
          else
          {
            v21 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v21, v21 != &v38, v16, 0, v17);
        }
        v22 = *v9;
        v23 = CFRetain(v14);
        v24 = figCustomURLWorkQueueEnqueue(v22, (uint64_t)curll_transferHandlingOfRequestDispatch, (uint64_t)v23);
        if ((_DWORD)v24)
          CFRelease(v14);
        CFRelease(v14);
        return v24;
      }
      free(v12);
    }
    v26 = 4294954510;
  }
  else
  {
    v26 = 4294949916;
  }
  return FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
}

uint64_t curll_compareHandlersByPriority(void *key, const void *a2, uint64_t a3)
{
  const __CFNumber *Value;
  const __CFNumber *v6;
  CFComparisonResult v7;
  uint64_t v8;

  Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 40), key);
  v6 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 40), a2);
  v7 = CFNumberCompare(Value, v6, 0);
  if (v7 == kCFCompareGreaterThan)
    v8 = -1;
  else
    v8 = v7;
  if (v7 == kCFCompareLessThan)
    return 1;
  else
    return v8;
}

void curll_getURLDispatch(uint64_t *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t DerivedStorage;
  const void *ValueAtIndex;
  int v10;
  int v11;
  const void *v12;
  const void *v13;
  NSObject *v14;
  uint64_t v15;
  CFTypeRef cf;

  v3 = (const void *)*a1;
  v2 = (const void *)a1[1];
  v4 = (const void *)a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  cf = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v15 = 4294949915;
LABEL_18:
    v10 = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
    goto LABEL_4;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 48)) <= 0)
  {
    v15 = 4294949913;
    goto LABEL_18;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 48), 0);
  v10 = curll_handlerHandleRequestOnLoaderQueue(v3, ValueAtIndex, v4, v7, v2, v5, v6, (uint64_t)curll_respondToHandleRequestCompletionOnQueue);
LABEL_4:
  v11 = v10;
  if (v10)
  {
    FigCustomURLResponseInfoCreateMutable(*(const __CFAllocator **)(DerivedStorage + 16), v4, &cf);
    curl_dispatchDataCallbackWithError(v5, v2, v6, v7, v4, cf, v11);
    if (cf)
      CFRelease(cf);
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  v12 = (const void *)a1[2];
  if (v12)
    CFRelease(v12);
  v13 = (const void *)a1[1];
  if (v13)
    CFRelease(v13);
  v14 = a1[3];
  if (v14)
    dispatch_release(v14);
  free(a1);
}

uint64_t curll_handlerHandleRequestOnLoaderQueue(const void *a1, const void *a2, const void *a3, uint64_t a4, const void *a5, NSObject *a6, uint64_t a7, uint64_t a8)
{
  uint64_t DerivedStorage;
  uint64_t CFAllocator;
  const UInt8 *v17;
  UInt8 *v18;
  CFDataRef v19;
  CFDataRef v20;
  CFTypeRef v21;
  void *v22;
  CFTypeRef v23;
  CFTypeRef v24;
  CFTypeRef v25;
  CFTypeRef v26;
  NSObject *v27;
  dispatch_time_t v28;
  uint64_t v29;
  uint64_t (*v30)(const void *, const void *, uint64_t, const void *, NSObject *, uint64_t, void (*)(const __CFData *, unsigned int, unsigned int), CFDataRef);
  uint64_t v31;
  uint64_t *v33;
  CFAllocatorRef bytesDeallocator;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  bytesDeallocator = 0;
  CFAllocator = handlerHandleRequestRec_getCFAllocator(&bytesDeallocator);
  if ((_DWORD)CFAllocator)
    return CFAllocator;
  v33 = (uint64_t *)DerivedStorage;
  v17 = (const UInt8 *)malloc_type_calloc(1uLL, 0x58uLL, 0x10E0040CF94696AuLL);
  if (v17)
  {
    v18 = (UInt8 *)v17;
    v19 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v17, 88, bytesDeallocator);
    if (v19)
    {
      v20 = v19;
      v21 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v19);
      if (!v21)
      {
        v31 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        CFRelease(v20);
        return v31;
      }
      v22 = (void *)v21;
      if (a1)
        v23 = CFRetain(a1);
      else
        v23 = 0;
      *(_QWORD *)v18 = v23;
      if (a2)
        v24 = CFRetain(a2);
      else
        v24 = 0;
      *((_QWORD *)v18 + 1) = v24;
      if (a3)
        v25 = CFRetain(a3);
      else
        v25 = 0;
      *((_QWORD *)v18 + 2) = v25;
      *((_QWORD *)v18 + 3) = a4;
      if (a5)
        v26 = CFRetain(a5);
      else
        v26 = 0;
      *((_QWORD *)v18 + 4) = v26;
      if (a6)
        dispatch_retain(a6);
      *((_QWORD *)v18 + 5) = a6;
      *((_QWORD *)v18 + 6) = a7;
      *((_QWORD *)v18 + 7) = 0x4024000000000000;
      *((_QWORD *)v18 + 8) = a8;
      v18[84] = 1;
      if (curl_getLowPriorityBackgroundQueue_sOnceToken != -1)
        dispatch_once_f(&curl_getLowPriorityBackgroundQueue_sOnceToken, 0, (dispatch_function_t)curl_getLowPriorityBackgroundQueueOnce);
      v27 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, (dispatch_queue_t)gLowPriorityBackgroundQueue);
      *((_QWORD *)v18 + 9) = v27;
      v28 = dispatch_time(0, 10000000000);
      v29 = dispatch_time(0, 10000000000);
      dispatch_source_set_timer(v27, v28, v29, 0);
      dispatch_set_context(*((dispatch_object_t *)v18 + 9), v22);
      dispatch_source_set_event_handler_f(*((dispatch_source_t *)v18 + 9), (dispatch_function_t)curll_handlerHandleRequestTimerTimeoutCallback);
      dispatch_source_set_cancel_handler_f(*((dispatch_source_t *)v18 + 9), (dispatch_function_t)curll_handlerHandleRequestTimerCancellationCallback);
      dispatch_resume(*((dispatch_object_t *)v18 + 9));
      figCustomURLWorkQueueSuspendDraining(*v33);
      v30 = *(uint64_t (**)(const void *, const void *, uint64_t, const void *, NSObject *, uint64_t, void (*)(const __CFData *, unsigned int, unsigned int), CFDataRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a2) + 16) + 32);
      if (v30)
      {
        v31 = v30(a2, a3, a4, a5, a6, a7, curll_handlerHandleRequestCompletionHandler, v20);
        if (!(_DWORD)v31)
          return v31;
      }
      else
      {
        v31 = 4294954514;
      }
      figCustomURLWorkQueueResumeDraining(*v33);
      return v31;
    }
    free(v18);
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t curll_respondToHandleRequestCompletionOnQueue(const __CFData *a1, int a2, int a3)
{
  const UInt8 *BytePtr;
  const void *v7;
  uint64_t v8;
  uint64_t DerivedStorage;
  const __CFArray *v10;
  CFIndex FirstIndexOfValue;
  CFIndex v12;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  CFAllocatorRef *v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  CFAllocatorRef *v24;
  int v25;
  _BOOL4 v26;
  CFIndex Count;
  const void *ValueAtIndex;
  const UInt8 *v29;
  const UInt8 *v30;
  int CFAllocator;
  _OWORD *v32;
  _OWORD *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  CFDataRef v38;
  const __CFData *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  NSObject *v43;
  NSObject *v44;
  const UInt8 *v45;
  CFTypeRef v46;
  void *v47;
  const void *v48;
  NSObject *v49;
  NSObject *v50;
  dispatch_time_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t (*v58)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void (*)(const __CFData *, unsigned int, unsigned int), const __CFData *, int *, int);
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  int *v64;
  int v65;
  os_log_type_t type;
  int v67;
  int v68;
  const char *v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  uint64_t v73;
  __int16 v74;
  const void *v75;
  __int16 v76;
  int v77;
  CFAllocatorRef bytesDeallocator[18];
  CFRange v79;

  bytesDeallocator[16] = *(CFAllocatorRef *)MEMORY[0x1E0C80C00];
  BytePtr = CFDataGetBytePtr(a1);
  v8 = *(_QWORD *)BytePtr;
  v7 = (const void *)*((_QWORD *)BytePtr + 1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)BytePtr);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v62 = 4294954511;
    goto LABEL_57;
  }
  v10 = *(const __CFArray **)(DerivedStorage + 48);
  v79.length = CFArrayGetCount(v10);
  v79.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v10, v79, v7);
  if (FirstIndexOfValue == -1)
  {
    v62 = 4294949914;
    goto LABEL_57;
  }
  v12 = FirstIndexOfValue;
  if (a3 == -17377)
  {
    if (dword_1ECDA8458)
    {
      v67 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v67, &type);
      v14 = v67;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v16 = v14;
      else
        v16 = v14 & 0xFFFFFFFE;
      if (v16)
      {
        v17 = *((_QWORD *)BytePtr + 3);
        v68 = 136315906;
        v69 = "curll_respondToHandleRequestCompletionOnQueue";
        v70 = 2048;
        v71 = DerivedStorage;
        v72 = 2048;
        v73 = v17;
        v74 = 2048;
        v75 = v7;
        v65 = 42;
        v64 = &v68;
        v18 = (CFAllocatorRef *)_os_log_send_and_compose_impl();
        LOBYTE(v14) = v67;
      }
      else
      {
        v18 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v18, v18 != bytesDeallocator, v14, 0, v15);
    }
    v26 = 0;
    v25 = -17377;
  }
  else if (a3)
  {
    if (dword_1ECDA8458)
    {
      v67 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, &v67, &type);
      v20 = v67;
      if (os_log_type_enabled(v19, type))
        v22 = v20;
      else
        v22 = v20 & 0xFFFFFFFE;
      if (v22)
      {
        v23 = *((_QWORD *)BytePtr + 3);
        v68 = 136316162;
        v69 = "curll_respondToHandleRequestCompletionOnQueue";
        v70 = 2048;
        v71 = DerivedStorage;
        v72 = 2048;
        v73 = v23;
        v74 = 2048;
        v75 = v7;
        v76 = 1024;
        v77 = a3;
        v65 = 48;
        v64 = &v68;
        v24 = (CFAllocatorRef *)_os_log_send_and_compose_impl();
        LOBYTE(v20) = v67;
      }
      else
      {
        v24 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v24, v24 != bytesDeallocator, v20, 0, v21);
    }
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(DerivedStorage + 48), v12);
    v25 = 0;
    --v12;
    v26 = 1;
  }
  else
  {
    v25 = 0;
    v26 = a2 == 0;
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 48));
  if (!v26 || v12 == Count - 1)
  {
    if (a2)
    {
      v59 = *((_QWORD *)BytePtr + 3);
      v60 = CMBaseObjectGetDerivedStorage(v8);
      v61 = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(_QWORD *)(v60 + 56), (uint64_t)v7, v59);
LABEL_58:
      v25 = v61;
      goto LABEL_59;
    }
    if (a3 == -17377)
      goto LABEL_59;
    v62 = 4294949913;
LABEL_57:
    v61 = FigSignalErrorAt(v62, 0, 0, 0, 0, 0, 0);
    goto LABEL_58;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(DerivedStorage + 48), v12 + 1);
  v29 = CFDataGetBytePtr(a1);
  bytesDeallocator[0] = 0;
  v30 = CFDataGetBytePtr(a1);
  CFAllocator = handlerHandleRequestRec_getCFAllocator(bytesDeallocator);
  if (CFAllocator)
    goto LABEL_71;
  v32 = malloc_type_calloc(1uLL, 0x58uLL, 0x10E0040CF94696AuLL);
  if (v32)
  {
    v33 = v32;
    v34 = *((_OWORD *)v30 + 1);
    *v32 = *(_OWORD *)v30;
    v32[1] = v34;
    v35 = *((_OWORD *)v30 + 2);
    v36 = *((_OWORD *)v30 + 3);
    v37 = *((_OWORD *)v30 + 4);
    *((_QWORD *)v32 + 10) = *((_QWORD *)v30 + 10);
    v32[3] = v36;
    v32[4] = v37;
    v32[2] = v35;
    v38 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v32, 88, bytesDeallocator[0]);
    if (v38)
    {
      v39 = v38;
      if (*(_QWORD *)v33)
        CFRetain(*(CFTypeRef *)v33);
      v40 = (const void *)*((_QWORD *)v33 + 1);
      if (v40)
        CFRetain(v40);
      v41 = (const void *)*((_QWORD *)v33 + 2);
      if (v41)
        CFRetain(v41);
      v42 = (const void *)*((_QWORD *)v33 + 4);
      if (v42)
        CFRetain(v42);
      v43 = *((_QWORD *)v33 + 5);
      if (v43)
        dispatch_retain(v43);
      v44 = *((_QWORD *)v33 + 9);
      if (v44)
        dispatch_retain(v44);
      goto LABEL_41;
    }
    free(v33);
  }
  CFAllocator = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  v39 = 0;
  if (CFAllocator)
    goto LABEL_71;
LABEL_41:
  v45 = CFDataGetBytePtr(v39);
  v46 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v39);
  if (!v46)
  {
    v25 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if (v39)
      CFRelease(v39);
LABEL_59:
    if (!v25)
      return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
    goto LABEL_62;
  }
  v47 = (void *)v46;
  *((_DWORD *)v45 + 20) = 0;
  v48 = (const void *)*((_QWORD *)v45 + 1);
  *((_QWORD *)v45 + 1) = ValueAtIndex;
  if (ValueAtIndex)
    CFRetain(ValueAtIndex);
  if (v48)
    CFRelease(v48);
  *((_BYTE *)v45 + 84) = 1;
  v49 = *((_QWORD *)v45 + 9);
  if (v49)
    dispatch_release(v49);
  if (curl_getLowPriorityBackgroundQueue_sOnceToken != -1)
    dispatch_once_f(&curl_getLowPriorityBackgroundQueue_sOnceToken, 0, (dispatch_function_t)curl_getLowPriorityBackgroundQueueOnce);
  v50 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, (dispatch_queue_t)gLowPriorityBackgroundQueue);
  *((_QWORD *)v45 + 9) = v50;
  v51 = dispatch_time(0, (uint64_t)(*((double *)v45 + 7) * 1000000000.0));
  v52 = dispatch_time(0, (uint64_t)(*((double *)v45 + 7) * 1000000000.0));
  dispatch_source_set_timer(v50, v51, v52, 0);
  dispatch_set_context(*((dispatch_object_t *)v45 + 9), v47);
  dispatch_source_set_event_handler_f(*((dispatch_source_t *)v45 + 9), (dispatch_function_t)curll_handlerHandleRequestTimerTimeoutCallback);
  dispatch_source_set_cancel_handler_f(*((dispatch_source_t *)v45 + 9), (dispatch_function_t)curll_handlerHandleRequestTimerCancellationCallback);
  dispatch_resume(*((dispatch_object_t *)v45 + 9));
  v53 = *((_QWORD *)v45 + 2);
  v54 = *((_QWORD *)v45 + 3);
  v55 = *((_QWORD *)v45 + 4);
  v56 = *((_QWORD *)v45 + 5);
  v57 = *((_QWORD *)v45 + 6);
  v58 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void (*)(const __CFData *, unsigned int, unsigned int), const __CFData *, int *, int))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)ValueAtIndex) + 16) + 32);
  if (!v58)
  {
    v25 = -12782;
    goto LABEL_62;
  }
  CFAllocator = v58(ValueAtIndex, v53, v54, v55, v56, v57, curll_handlerHandleRequestCompletionHandler, v39, v64, v65);
  if (!CFAllocator)
  {
    *((_BYTE *)v29 + 84) = 0;
    return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  }
LABEL_71:
  v25 = CFAllocator;
LABEL_62:
  bytesDeallocator[0] = 0;
  FigCustomURLResponseInfoCreateMutable(*(const __CFAllocator **)(DerivedStorage + 16), *((const void **)BytePtr + 2), (CFTypeRef *)bytesDeallocator);
  curl_dispatchDataCallbackWithError(*((NSObject **)BytePtr + 5), *((const void **)BytePtr + 4), *((_QWORD *)BytePtr + 6), *((_QWORD *)BytePtr + 3), *((const void **)BytePtr + 2), bytesDeallocator[0], v25);
  if (bytesDeallocator[0])
    CFRelease(bytesDeallocator[0]);
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
}

uint64_t handlerHandleRequestRec_getCFAllocator(_QWORD *a1)
{
  if (handlerHandleRequestRec_getCFAllocator_sOnceToken != -1)
    dispatch_once_f(&handlerHandleRequestRec_getCFAllocator_sOnceToken, &handlerHandleRequestRec_getCFAllocator_sAllocator, (dispatch_function_t)handlerHandleRequestRec_initializeCFAllocatorOnce);
  if (!handlerHandleRequestRec_getCFAllocator_sAllocator)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  *a1 = handlerHandleRequestRec_getCFAllocator_sAllocator;
  return 0;
}

void curll_handlerHandleRequestTimerTimeoutCallback(id *a1)
{
  id *v1;
  id *v2;

  v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    v2 = v1;
    curll_handlerHandleRequestCompletionHandlerCommon((const __CFData *)v1, 0, 1, 0xFFFFBC1F);
    CFRelease(v2);
  }
}

void curll_handlerHandleRequestTimerCancellationCallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void curll_handlerHandleRequestCompletionHandler(const __CFData *a1, unsigned int a2, unsigned int a3)
{
  curll_handlerHandleRequestCompletionHandlerCommon(a1, a2, 0, a3);
  if (a1)
    CFRelease(a1);
}

uint64_t handlerHandleRequestRec_initializeCFAllocatorOnce(_QWORD *a1)
{
  uint64_t result;
  CFTypeRef v3;

  v3 = 0;
  result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))handlerHandleRequestRec_dealloc, &v3);
  if (!(_DWORD)result)
    *a1 = v3;
  return result;
}

void handlerHandleRequestRec_dealloc(const void **a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  NSObject *v6;
  NSObject *v7;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  v3 = a1[1];
  if (v3)
    CFRelease(v3);
  v4 = a1[2];
  if (v4)
    CFRelease(v4);
  v5 = a1[4];
  if (v5)
    CFRelease(v5);
  v6 = a1[5];
  if (v6)
    dispatch_release(v6);
  v7 = a1[9];
  if (v7)
    dispatch_release(v7);
  free(a1);
}

dispatch_queue_t curl_getLowPriorityBackgroundQueueOnce()
{
  dispatch_queue_t result;

  result = FigDispatchQueueCreateWithPriority("com.apple.coremedia.customurl.bg", 0, 0x19u);
  gLowPriorityBackgroundQueue = (uint64_t)result;
  return result;
}

void curll_handlerHandleRequestCompletionHandlerCommon(const __CFData *a1, unsigned int a2, int a3, unsigned int a4)
{
  const UInt8 *BytePtr;
  uint64_t v9;
  uint64_t v10;
  uint64_t DerivedStorage;

  BytePtr = CFDataGetBytePtr(a1);
  if (FigAtomicCompareAndSwap32(0, 1u, (unsigned int *)BytePtr + 20))
  {
    if (a3)
      v9 = 0;
    else
      v9 = a2;
    if (a3)
      v10 = 4294949919;
    else
      v10 = a4;
    (*((void (**)(const __CFData *, uint64_t, uint64_t))BytePtr + 8))(a1, v9, v10);
    if (BytePtr[84])
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)BytePtr);
      FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
      if (!*(_BYTE *)(DerivedStorage + 24))
        figCustomURLWorkQueueResumeDraining(*(_QWORD *)DerivedStorage);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
    }
    dispatch_source_cancel(*((dispatch_source_t *)BytePtr + 9));
  }
}

void curll_cancelRequestDispatch(uint64_t *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v6;
  uint64_t v7;
  unsigned int v8;
  char *v9;
  uint64_t v10;
  id v11;
  const void *v12;
  void (*v13)(const void *, void *);
  os_log_type_t type;
  int v15[2];
  const char *v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  void *v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  v2 = (void *)a1[1];
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    FigSignalErrorAt(4294949915, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    if (dword_1ECDA8458)
    {
      v15[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, v15, &type);
      v6 = v15[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v8 = v6;
      else
        v8 = v6 & 0xFFFFFFFE;
      if (v8)
      {
        v15[1] = 136315650;
        v16 = "curll_cancelRequestOnQueue";
        v17 = 2048;
        v18 = DerivedStorage;
        v19 = 2048;
        v20 = v2;
        v9 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v6) = v15[0];
      }
      else
      {
        v9 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v9, v9 != &v21, v6, 0, v7);
    }
    v10 = CMBaseObjectGetDerivedStorage(v3);
    v11 = FigCFWeakReferenceTableCopyValue(*(_QWORD *)(v10 + 56), v2);
    if (v11)
    {
      v12 = v11;
      v13 = *(void (**)(const void *, void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v11) + 16) + 40);
      if (v13)
        v13(v12, v2);
      CFRelease(v12);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  free(a1);
}

void curll_requestSetDormantDispatch(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v7;
  uint64_t v8;
  unsigned int v9;
  char *v10;
  uint64_t v11;
  id v12;
  const void *v13;
  void (*v14)(const void *, void *, uint64_t);
  os_log_type_t type;
  int v16[2];
  const char *v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  void *v21;
  __int16 v22;
  int v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)a1;
  v2 = *(void **)(a1 + 8);
  v4 = *(unsigned __int8 *)(a1 + 16);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)a1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    FigSignalErrorAt(4294949915, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    if (dword_1ECDA8458)
    {
      v16[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, v16, &type);
      v7 = v16[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v9 = v7;
      else
        v9 = v7 & 0xFFFFFFFE;
      if (v9)
      {
        v16[1] = 136315906;
        v17 = "curll_requestSetDormantOnQueue";
        v18 = 2048;
        v19 = DerivedStorage;
        v20 = 2048;
        v21 = v2;
        v22 = 1024;
        v23 = v4;
        v10 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v7) = v16[0];
      }
      else
      {
        v10 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v10, v10 != &v24, v7, 0, v8);
    }
    v11 = CMBaseObjectGetDerivedStorage(v3);
    v12 = FigCFWeakReferenceTableCopyValue(*(_QWORD *)(v11 + 56), v2);
    if (v12)
    {
      v13 = v12;
      v14 = *(void (**)(const void *, void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v12) + 16)
                                                                 + 48);
      if (v14)
        v14(v13, v2, v4);
      CFRelease(v13);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  free((void *)a1);
}

uint64_t curll_transferHandlingOfRequestDispatch(const __CFData *a1)
{
  const UInt8 *BytePtr;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t (*v6)(uint64_t, uint64_t, void (*)(int, int, CFDataRef, int, const void *, const void *, const void *, NSObject *, uint64_t, const void *), const __CFData *);

  BytePtr = CFDataGetBytePtr(a1);
  v3 = *((_QWORD *)BytePtr + 1);
  v4 = *((_QWORD *)BytePtr + 3);
  result = CMBaseObjectGetVTable(v3);
  v6 = *(uint64_t (**)(uint64_t, uint64_t, void (*)(int, int, CFDataRef, int, const void *, const void *, const void *, NSObject *, uint64_t, const void *), const __CFData *))(*(_QWORD *)(result + 16) + 56);
  if (v6)
    return v6(v3, v4, curll_handlerLookupRegisteredInfoCallbackForHandlerTransfer, a1);
  return result;
}

uint64_t transferHandlingOfRequestRec_initializeCFAllocatorOnce(_QWORD *a1)
{
  uint64_t result;
  CFTypeRef v3;

  v3 = 0;
  result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))transferHandlingOfRequestRec_dealloc, &v3);
  if (!(_DWORD)result)
    *a1 = v3;
  return result;
}

void transferHandlingOfRequestRec_dealloc(const void **a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  NSObject *v8;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  v3 = a1[1];
  if (v3)
    CFRelease(v3);
  v4 = a1[2];
  if (v4)
    CFRelease(v4);
  v5 = a1[4];
  if (v5)
    CFRelease(v5);
  v6 = a1[5];
  if (v6)
    CFRelease(v6);
  v7 = a1[6];
  if (v7)
    CFRelease(v7);
  v8 = a1[7];
  if (v8)
    dispatch_release(v8);
  free(a1);
}

void curll_handlerLookupRegisteredInfoCallbackForHandlerTransfer(int a1, int a2, CFDataRef theData, int a4, const void *a5, const void *a6, const void *a7, NSObject *a8, uint64_t a9, const void *a10)
{
  uint64_t *BytePtr;
  uint64_t DerivedStorage;
  CFTypeRef v18;
  CFTypeRef v19;
  CFTypeRef v20;
  uint64_t v21;
  CFTypeRef v22;
  uint64_t v23;

  BytePtr = (uint64_t *)CFDataGetBytePtr(theData);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*BytePtr);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v23 = 4294954511;
  }
  else
  {
    if (a4)
      goto LABEL_37;
    if (!BytePtr[4] && !BytePtr[5] && !BytePtr[6] && !BytePtr[7] && !BytePtr[8])
    {
      if (a5)
        v18 = CFRetain(a5);
      else
        v18 = 0;
      BytePtr[4] = (uint64_t)v18;
      if (a6)
        v19 = CFRetain(a6);
      else
        v19 = 0;
      BytePtr[5] = (uint64_t)v19;
      if (a7)
        v20 = CFRetain(a7);
      else
        v20 = 0;
      BytePtr[6] = (uint64_t)v20;
      BytePtr[8] = a9;
      if (a8)
        dispatch_retain(a8);
      BytePtr[7] = (uint64_t)a8;
      v21 = *(_QWORD *)DerivedStorage;
      if (theData)
      {
        v22 = CFRetain(theData);
        if (figCustomURLWorkQueueEnqueue(v21, (uint64_t)curll_transferHandlingOfRequestWithRegisteredInfoDispatch, (uint64_t)v22))CFRelease(theData);
        goto LABEL_22;
      }
      figCustomURLWorkQueueEnqueue(*(_QWORD *)DerivedStorage, (uint64_t)curll_transferHandlingOfRequestWithRegisteredInfoDispatch, 0);
      goto LABEL_24;
    }
    v23 = 4294949914;
  }
  FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
LABEL_37:
  if (theData)
LABEL_22:
    CFRelease(theData);
LABEL_24:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (a5)
    CFRelease(a5);
  if (a6)
    CFRelease(a6);
  if (a7)
    CFRelease(a7);
  if (a8)
    dispatch_release(a8);
  if (a10)
    CFRelease(a10);
}

void curll_transferHandlingOfRequestWithRegisteredInfoDispatch(const __CFData *a1)
{
  const __CFData *v1;
  const UInt8 *BytePtr;
  const void *v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  uint64_t DerivedStorage;
  CFTypeRef v11;
  const void *v12;
  uint64_t v13;
  const __CFData *v14;
  const __CFArray *v15;
  const __CFArray *v16;
  int v17;
  uint64_t v18;
  int v19;
  int64x2_t v20;
  uint64_t v21;
  CFTypeRef v22;
  int64x2_t v23;
  CFTypeRef v24;
  CFRange v25;
  CFRange v26;

  v1 = a1;
  BytePtr = CFDataGetBytePtr(a1);
  v4 = *(const void **)BytePtr;
  v3 = (const void *)*((_QWORD *)BytePtr + 1);
  v6 = (const void *)*((_QWORD *)BytePtr + 2);
  v5 = *((_QWORD *)BytePtr + 3);
  v7 = (const void *)*((_QWORD *)BytePtr + 4);
  v8 = (const void *)*((_QWORD *)BytePtr + 5);
  v9 = (const void *)*((_QWORD *)BytePtr + 6);
  v23 = *(int64x2_t *)(BytePtr + 56);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)BytePtr);
  if (v8)
    v11 = CFRetain(v8);
  else
    v11 = 0;
  v24 = v11;
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v21 = 4294949915;
    goto LABEL_28;
  }
  v22 = v11;
  v12 = v9;
  v13 = v5;
  v14 = v1;
  v15 = *(const __CFArray **)(DerivedStorage + 48);
  v25.length = CFArrayGetCount(v15);
  v25.location = 0;
  if (!CFArrayContainsValue(v15, v25, v3))
  {
    v19 = FigSignalErrorAt(4294949912, 0, 0, 0, 0, 0, 0);
    v1 = v14;
LABEL_31:
    v5 = v13;
LABEL_33:
    v9 = v12;
LABEL_35:
    v11 = v22;
    goto LABEL_16;
  }
  v16 = *(const __CFArray **)(DerivedStorage + 48);
  v26.length = CFArrayGetCount(v16);
  v26.location = 0;
  v1 = v14;
  if (!CFArrayContainsValue(v16, v26, v6))
  {
    v19 = FigSignalErrorAt(4294949912, 0, 0, 0, 0, 0, 0);
    goto LABEL_31;
  }
  v5 = v13;
  if (!v7)
  {
    v19 = FigSignalErrorAt(4294949912, 0, 0, 0, 0, 0, 0);
    goto LABEL_33;
  }
  v9 = v12;
  if (v8)
  {
    v19 = FigSignalErrorAt(4294949912, 0, 0, 0, 0, 0, 0);
    goto LABEL_35;
  }
  v11 = v22;
  if (v9 && v23.i64[0] && v23.i64[1])
  {
    v17 = curll_unregisterHandlerForRequestOnQueue((uint64_t)v4, v5);
    if (!v17)
    {
      v18 = CMBaseObjectGetDerivedStorage((uint64_t)v4);
      v17 = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(_QWORD *)(v18 + 56), (uint64_t)v6, v5);
      if (!v17)
        v17 = curll_handlerHandleRequestOnLoaderQueue(v4, v6, v7, v5, v9, v23.i64[0], v23.i64[1], (uint64_t)curll_respondToHandleRequestCompletionForTransferOnQueue);
    }
    goto LABEL_15;
  }
  v21 = 4294949914;
LABEL_28:
  v17 = FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
LABEL_15:
  v19 = v17;
LABEL_16:
  v20.i64[0] = (uint64_t)v7;
  v20.i64[1] = (uint64_t)v9;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32(vuzp1q_s32((int32x4_t)vceqzq_s64(v20), (int32x4_t)vceqzq_s64(v23)))) & 1) == 0
    && v19)
  {
    if (!v11)
    {
      FigCustomURLResponseInfoCreate(*(const __CFAllocator **)(DerivedStorage + 16), v7, &v24);
      v11 = v24;
    }
    curl_dispatchDataCallbackWithError(v23.i64[0], v9, v23.i64[1], v5, v7, v11, v19);
    v11 = v24;
  }
  if (v11)
    CFRelease(v11);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (v1)
    CFRelease(v1);
}

uint64_t curll_respondToHandleRequestCompletionForTransferOnQueue(const __CFData *a1, int a2, int a3)
{
  const UInt8 *BytePtr;
  uint64_t DerivedStorage;
  uint64_t v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  CFTypeRef *v13;
  uint64_t v14;
  os_log_type_t type;
  int v17[2];
  const char *v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  CFTypeRef cf[17];

  cf[16] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  BytePtr = CFDataGetBytePtr(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)BytePtr);
  v7 = *((_QWORD *)BytePtr + 1);
  FigReentrantMutexLock(*(pthread_mutex_t **)(DerivedStorage + 8));
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v14 = 4294954511;
    goto LABEL_12;
  }
  if (a3 != -17377 || !dword_1ECDA8458)
  {
    if (a2 || a3)
    {
LABEL_13:
      if (!a3)
        return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
      goto LABEL_17;
    }
    v14 = 4294949912;
LABEL_12:
    a3 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  v17[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8450, 1, v17, &type);
  v9 = v17[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v11 = v9;
  else
    v11 = v9 & 0xFFFFFFFE;
  if (v11)
  {
    v12 = *((_QWORD *)BytePtr + 3);
    v17[1] = 136315906;
    v18 = "curll_respondToHandleRequestCompletionForTransferOnQueue";
    v19 = 2048;
    v20 = DerivedStorage;
    v21 = 2048;
    v22 = v12;
    v23 = 2048;
    v24 = v7;
    v13 = (CFTypeRef *)_os_log_send_and_compose_impl();
    LOBYTE(v9) = v17[0];
  }
  else
  {
    v13 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8450, 1u, 1, v13, v13 != cf, v9, 0, v10);
  a3 = -17377;
LABEL_17:
  cf[0] = 0;
  FigCustomURLResponseInfoCreate(*(const __CFAllocator **)(DerivedStorage + 16), *((const void **)BytePtr + 2), cf);
  curl_dispatchDataCallbackWithError(*((NSObject **)BytePtr + 5), *((const void **)BytePtr + 4), *((_QWORD *)BytePtr + 6), *((_QWORD *)BytePtr + 3), *((const void **)BytePtr + 2), cf[0], a3);
  if (cf[0])
    CFRelease(cf[0]);
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 8));
}

id FigCFWeakReferenceStore(id *location, id obj)
{
  if (wr_initializeOnceToken != -1)
    dispatch_once_f(&wr_initializeOnceToken, 0, (dispatch_function_t)wr_initialize);
  return objc_storeWeak(location, obj);
}

id FigCFWeakReferenceInit(id *location, id val)
{
  if (wr_initializeOnceToken != -1)
    dispatch_once_f(&wr_initializeOnceToken, 0, (dispatch_function_t)wr_initialize);
  return objc_initWeak(location, val);
}

uint64_t FigCaptionRegionGetClassID()
{
  FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType);
  return sFigCaptionRegionClassID;
}

uint64_t RegisterFigCaptionRegionBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigCaptionRegionClassDesc, ClassID, 1, &sFigCaptionRegionClassID);
}

uint64_t FigCaptionRegionGetTypeID()
{
  FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigCaptionRegionClassID);
}

uint64_t FigCaptionRegionCreate(const __CFAllocator *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5;
  CFTypeRef v6;
  uint64_t (*v7)(CFTypeRef, const __CFString *, uint64_t);
  uint64_t v8;
  CFTypeRef cf;

  cf = 0;
  v5 = FigCaptionRegionCreateMutable(a1, &cf);
  if ((_DWORD)v5)
  {
    v8 = v5;
  }
  else
  {
    v6 = cf;
    v7 = *(uint64_t (**)(CFTypeRef, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf)
                                                                                      + 8)
                                                                          + 56);
    if (v7)
    {
      v8 = v7(v6, CFSTR("CMCaptionRegionIdentifier"), a2);
      if (!(_DWORD)v8)
      {
        *a3 = cf;
        return v8;
      }
    }
    else
    {
      v8 = 4294954514;
    }
  }
  if (cf)
    CFRelease(cf);
  return v8;
}

uint64_t FigCaptionRegionCreateMutable(const __CFAllocator *a1, CFTypeRef *a2)
{
  uint64_t v4;
  CFTypeRef v5;
  _QWORD *DerivedStorage;
  CFMutableDictionaryRef Mutable;
  CFTypeRef cf;

  cf = 0;
  if (a2)
  {
    FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType);
    v4 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigCaptionRegionVTable, (_QWORD *)sFigCaptionRegionClassID, &cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (cf)
        DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      else
        DerivedStorage = 0;
      Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      *DerivedStorage = Mutable;
      if (Mutable)
      {
        v4 = 0;
        *a2 = cf;
        return v4;
      }
      v4 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v5 = cf;
    }
    if (v5)
      CFRelease(v5);
    return v4;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionRegionCreateMutableCopy(const __CFAllocator *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v6;
  CFMutableDictionaryRef *DerivedStorage;
  CFMutableDictionaryRef Mutable;
  uint64_t i;
  __CFString *v10;
  void (*v11)(uint64_t, __CFString *, const __CFAllocator *, void **);
  uint64_t v12;
  uint64_t v14;
  void *value;
  CFTypeRef cf;

  cf = 0;
  if (a3)
  {
    if (a2)
    {
      FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType);
      v6 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigCaptionRegionVTable, (_QWORD *)sFigCaptionRegionClassID, &cf);
      if ((_DWORD)v6)
        goto LABEL_19;
      if (!cf)
      {
        v14 = 4294954510;
        goto LABEL_18;
      }
      DerivedStorage = (CFMutableDictionaryRef *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      *DerivedStorage = Mutable;
      if (Mutable)
      {
        for (i = 0; i != 22; ++i)
        {
          value = 0;
          v10 = off_1E28DB9E8[i];
          v11 = *(void (**)(uint64_t, __CFString *, const __CFAllocator *, void **))(*(_QWORD *)(CMBaseObjectGetVTable(a2) + 8)
                                                                                             + 48);
          if (v11)
            v11(a2, v10, a1, &value);
          if (value)
          {
            CFDictionarySetValue(*DerivedStorage, v10, value);
            if (value)
              CFRelease(value);
          }
        }
        v12 = 0;
        *a3 = cf;
        return v12;
      }
    }
    v14 = 4294954516;
LABEL_18:
    v6 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
LABEL_19:
    v12 = v6;
    if (cf)
      CFRelease(cf);
    return v12;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

CFStringRef FigCaptionRegionCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionRegion %p]"), a1);
}

uint64_t fmcregion_Equal(char *a1, char *a2)
{
  uint64_t result;
  CFDictionaryRef *DerivedStorage;
  CFDictionaryRef *v6;
  unint64_t Value;
  unint64_t v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;

  if (a1
    && (FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType), !CMBaseObjectIsMemberOfClass(a1, (_QWORD *)sFigCaptionRegionClassID))|| a2&& (FigThreadRunOnce(&FigCaptionRegionGetClassID_sRegisterFigCaptionRegionBaseTypeOnce, (void (*)(void))RegisterFigCaptionRegionBaseType), !CMBaseObjectIsMemberOfClass(a2, (_QWORD *)sFigCaptionRegionClassID)))
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else if (a1 == a2)
  {
    return 1;
  }
  else
  {
    result = 0;
    if (a1 && a2)
    {
      DerivedStorage = (CFDictionaryRef *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
      v6 = (CFDictionaryRef *)CMBaseObjectGetDerivedStorage((uint64_t)a2);
      Value = (unint64_t)CFDictionaryGetValue(*DerivedStorage, CFSTR("CMCaptionRegionIdentifier"));
      v8 = (unint64_t)CFDictionaryGetValue(*v6, CFSTR("CMCaptionRegionIdentifier"));
      if (Value | v8)
      {
        return FigCFEqual((CFTypeRef)Value, (CFTypeRef)v8);
      }
      else
      {
        v9 = CFDictionaryGetValue(*DerivedStorage, CFSTR("CMCaptionRegionPosition"));
        v10 = CFDictionaryGetValue(*v6, CFSTR("CMCaptionRegionPosition"));
        result = FigCFEqual(v9, v10);
        if ((_DWORD)result)
        {
          v11 = CFDictionaryGetValue(*DerivedStorage, CFSTR("CMCaptionRegionAbstractPosition"));
          v12 = CFDictionaryGetValue(*v6, CFSTR("CMCaptionRegionAbstractPosition"));
          result = FigCFEqual(v11, v12);
          if ((_DWORD)result)
          {
            v13 = CFDictionaryGetValue(*DerivedStorage, CFSTR("CMCaptionRegionHeight"));
            v14 = CFDictionaryGetValue(*v6, CFSTR("CMCaptionRegionHeight"));
            result = FigCFEqual(v13, v14);
            if ((_DWORD)result)
            {
              v15 = CFDictionaryGetValue(*DerivedStorage, CFSTR("CMCaptionRegionAnchor"));
              v16 = CFDictionaryGetValue(*v6, CFSTR("CMCaptionRegionAnchor"));
              result = FigCFEqual(v15, v16);
              if ((_DWORD)result)
              {
                v17 = CFDictionaryGetValue(*DerivedStorage, CFSTR("CMCaptionRegionLuminanceGain"));
                v18 = CFDictionaryGetValue(*v6, CFSTR("CMCaptionRegionLuminanceGain"));
                result = FigCFEqual(v17, v18);
                if ((_DWORD)result)
                {
                  v19 = CFDictionaryGetValue(*DerivedStorage, CFSTR("CMCaptionRegionStereoDisparity"));
                  v20 = CFDictionaryGetValue(*v6, CFSTR("CMCaptionRegionStereoDisparity"));
                  result = FigCFEqual(v19, v20);
                  if ((_DWORD)result)
                  {
                    v21 = (const __CFString *)CFDictionaryGetValue(*DerivedStorage, CFSTR("CMCaptionRegionAnimation"));
                    if (v21)
                      v22 = v21;
                    else
                      v22 = CFSTR("CMCaptionRegionAnimationType_None");
                    v23 = (const __CFString *)CFDictionaryGetValue(*v6, CFSTR("CMCaptionRegionAnimation"));
                    if (v23)
                      v24 = v23;
                    else
                      v24 = CFSTR("CMCaptionRegionAnimationType_None");
                    return CFEqual(v22, v24) != 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void fmcregion_Finalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)CMBaseObjectGetDerivedStorage(a1);
  if (v1)
    CFRelease(v1);
}

__CFString *fmcregion_CopyDebugDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  _QWORD *DerivedStorage;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("\tCaptionRegion: %p %@"), a1, *DerivedStorage);
  return Mutable;
}

uint64_t fmcregion_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFArrayRef *a4)
{
  CFDictionaryRef *DerivedStorage;
  int v8;
  const __CFDictionary *v9;
  unint64_t Count;
  CFIndex v11;
  size_t v12;
  const void **v13;
  const __CFArray *Value;
  CFArrayRef v15;
  uint64_t v17;

  if (!a2)
  {
    v17 = 4294954516;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  if (!a4)
  {
    v17 = 4294954516;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  if (a1)
    DerivedStorage = (CFDictionaryRef *)CMBaseObjectGetDerivedStorage(a1);
  else
    DerivedStorage = 0;
  v8 = FigCFEqual(a2, CFSTR("CMCaptionRegionPropertyKeysInUse"));
  v9 = *DerivedStorage;
  if (!v8)
  {
    Value = (const __CFArray *)CFDictionaryGetValue(v9, a2);
    v15 = Value;
    if (Value)
      CFRetain(Value);
    goto LABEL_16;
  }
  Count = CFDictionaryGetCount(v9);
  v11 = Count;
  if (Count)
  {
    if (Count >> 61)
      goto LABEL_17;
    v12 = 8 * Count;
    if (!(8 * v11))
      goto LABEL_17;
    v13 = (const void **)malloc_type_malloc(v12, 0xD1AAB5CuLL);
    if (!v13)
      goto LABEL_17;
  }
  else
  {
    v13 = 0;
  }
  CFDictionaryGetKeysAndValues(*DerivedStorage, v13, 0);
  v15 = CFArrayCreate(a3, v13, v11, MEMORY[0x1E0C9B378]);
  free(v13);
  if (v15)
  {
LABEL_16:
    *a4 = v15;
    return 0;
  }
LABEL_17:
  v17 = 4294954510;
  return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
}

uint64_t fmcregion_SetProperty(uint64_t a1, const void *a2, void *a3)
{
  CFMutableDictionaryRef *DerivedStorage;
  CFMutableDictionaryRef *v6;
  CFTypeID v7;
  CFTypeID TypeID;
  CFDictionaryRef *v9;
  CFTypeID v10;
  CFDictionaryRef *v11;
  CFTypeID v12;
  CFDictionaryRef *InitialValue;
  CFTypeID v15;
  const __CFString *v16;
  CFDictionaryRef *v17;
  CFTypeID v18;
  CFTypeID v19;
  CFDictionaryRef *v20;
  CFTypeID v21;
  CFDictionaryRef *v22;
  CFTypeID v23;
  CFDictionaryRef *v24;
  CFTypeID v25;
  CFDictionaryRef *v26;
  CFTypeID v27;
  CFDictionaryRef *v28;
  CFTypeID v29;
  CFDictionaryRef *v30;
  CFTypeID v31;
  CFTypeID v32;
  CFDictionaryRef *v33;
  CFTypeID v34;
  CFDictionaryRef *v35;
  CFTypeID v36;
  CFDictionaryRef *v37;
  CFTypeID v38;
  CFDictionaryRef *v39;
  float valuePtr;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DerivedStorage = (CFMutableDictionaryRef *)CMBaseObjectGetDerivedStorage(a1);
  if (!a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v6 = DerivedStorage;
  if (!DerivedStorage)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!a3)
  {
    CFDictionaryRemoveValue(*DerivedStorage, a2);
    return 0;
  }
  if (CFEqual(a2, CFSTR("CMCaptionRegionIdentifier")))
  {
    v7 = CFGetTypeID(a3);
    TypeID = CFStringGetTypeID();
    goto LABEL_20;
  }
  if (CFEqual(a2, CFSTR("CMCaptionRegionExplicitRegion")))
  {
    v9 = (CFDictionaryRef *)a3;
LABEL_10:
    v7 = CFGetTypeID(v9);
    TypeID = CFBooleanGetTypeID();
    goto LABEL_20;
  }
  if (CFEqual(a2, CFSTR("CMCaptionRegionPosition")))
    goto LABEL_12;
  if (CFEqual(a2, CFSTR("CMCaptionRegionAbstractPosition")))
  {
    v12 = CFGetTypeID(a3);
    if (v12 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    InitialValue = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    v7 = CFGetTypeID(InitialValue);
    TypeID = FigCaptionPositionGetTypeID();
LABEL_20:
    if (v7 == TypeID)
    {
LABEL_21:
      CFDictionarySetValue(*v6, a2, a3);
      return 0;
    }
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (CFEqual(a2, CFSTR("CMCaptionRegionWidth")) || CFEqual(a2, CFSTR("CMCaptionRegionHeight")))
    goto LABEL_12;
  if (CFEqual(a2, CFSTR("CMCaptionRegionDisplayAspectRatio")) || CFEqual(a2, CFSTR("CMCaptionRegionActiveArea")))
    goto LABEL_27;
  if (CFEqual(a2, CFSTR("CMCaptionRegionAnimation")))
  {
    v15 = CFGetTypeID(a3);
    if (v15 != CFStringGetTypeID())
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    if (CFEqual(a3, CFSTR("CMCaptionRegionAnimationType_Rollup")))
      goto LABEL_21;
    v16 = CFSTR("CMCaptionRegionAnimationType_None");
    v17 = (CFDictionaryRef *)a3;
LABEL_32:
    if (CFEqual(v17, v16))
      goto LABEL_21;
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (CFEqual(a2, CFSTR("CMCaptionRegionContainerRegion")))
  {
    v7 = CFGetTypeID(a3);
    TypeID = FigCaptionRegionGetTypeID();
    goto LABEL_20;
  }
  if (CFEqual(a2, CFSTR("CMCaptionRegionClipOverflow"))
    || CFEqual(a2, CFSTR("CMCaptionRegionInvisible"))
    || CFEqual(a2, CFSTR("CMCaptionRegionForcedDisplay"))
    || CFEqual(a2, CFSTR("CMCaptionRegionHidden")))
  {
    v18 = CFGetTypeID(a3);
    if (v18 == FigCaptionDynamicStyleGetTypeID() && FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
    {
      v9 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      goto LABEL_10;
    }
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (CFEqual(a2, CFSTR("CMCaptionRegionShowbackground")))
  {
    v19 = CFGetTypeID(a3);
    if (v19 != FigCaptionDynamicStyleGetTypeID())
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v20 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    if (CFEqual(v20, CFSTR("CMCaptionRegionShowbackground_Always")))
      goto LABEL_21;
    v17 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
    v16 = CFSTR("CMCaptionRegionShowbackground_WhenActive");
    goto LABEL_32;
  }
  if (!CFEqual(a2, CFSTR("CMCaptionRegionOpacity")))
  {
    if (CFEqual(a2, CFSTR("CMCaptionRegionWritingMode")))
    {
      v25 = CFGetTypeID(a3);
      if (v25 != FigCaptionDynamicStyleGetTypeID())
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      if (!FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v26 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      v27 = CFGetTypeID(v26);
      if (v27 != CFStringGetTypeID())
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v28 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      if (CFEqual(v28, CFSTR("CMCaptionRegionWritingMode_TopToBottomAndLeftToRight"))
        || CFEqual(v28, CFSTR("CMCaptionRegionWritingMode_TopToButtomAndRightToLeft"))
        || CFEqual(v28, CFSTR("CMCaptionRegionWritingMode_RightToLeftAndTopToBottom")))
      {
        goto LABEL_21;
      }
      v16 = CFSTR("CMCaptionRegionWritingMode_LeftToRightAndTopToBottom");
      goto LABEL_69;
    }
    if (CFEqual(a2, CFSTR("CMCaptionRegionDisplayAlign")))
    {
      v29 = CFGetTypeID(a3);
      if (v29 != FigCaptionDynamicStyleGetTypeID())
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      if (!FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v30 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      v31 = CFGetTypeID(v30);
      if (v31 != CFStringGetTypeID())
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v28 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      if (CFEqual(v28, CFSTR("CMCaptionRegionDisplayAlign_Before"))
        || CFEqual(v28, CFSTR("CMCaptionRegionDisplayAlign_After")))
      {
        goto LABEL_21;
      }
      v16 = CFSTR("CMCaptionRegionDisplayAlign_Center");
LABEL_69:
      v17 = v28;
      goto LABEL_32;
    }
    if (CFEqual(a2, CFSTR("CMCaptionRegionPadding")))
    {
      v32 = CFGetTypeID(a3);
      if (v32 == FigCaptionDynamicStyleGetTypeID())
      {
        if (FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
        {
          v33 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
          v34 = CFGetTypeID(v33);
          if (v34 == CFDictionaryGetTypeID())
          {
            v35 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
            if (CFDictionaryContainsKey((CFDictionaryRef)v35, CFSTR("CMCaptionRegionPadding_Before")))
            {
              if (CFDictionaryContainsKey((CFDictionaryRef)v35, CFSTR("CMCaptionRegionPadding_After"))
                && CFDictionaryContainsKey((CFDictionaryRef)v35, CFSTR("CMCaptionRegionPadding_Start"))
                && CFDictionaryContainsKey((CFDictionaryRef)v35, CFSTR("CMCaptionRegionPadding_End")))
              {
                goto LABEL_21;
              }
            }
          }
        }
      }
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    if (!CFEqual(a2, CFSTR("CMCaptionRegionAnchor")))
    {
      if (CFEqual(a2, CFSTR("CMCaptionRegionZIndex")))
        goto LABEL_81;
      if (CFEqual(a2, CFSTR("CMCaptionRegionBackgroundColor")))
      {
        v38 = CFGetTypeID(a3);
        if (v38 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
          return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        v39 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        v7 = CFGetTypeID(v39);
        TypeID = CGColorGetTypeID();
        goto LABEL_20;
      }
      if (CFEqual(a2, CFSTR("CMCaptionRegionCellResolution")))
      {
LABEL_27:
        v11 = (CFDictionaryRef *)a3;
        goto LABEL_15;
      }
      if (CFEqual(a2, CFSTR("CMCaptionRegionLuminanceGain")))
      {
LABEL_81:
        v36 = CFGetTypeID(a3);
        if (v36 != FigCaptionDynamicStyleGetTypeID() || !FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
          return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        v37 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        v7 = CFGetTypeID(v37);
        TypeID = CFNumberGetTypeID();
        goto LABEL_20;
      }
      if (!CFEqual(a2, CFSTR("CMCaptionRegionStereoDisparity")))
        return 4294954512;
    }
LABEL_12:
    v10 = CFGetTypeID(a3);
    if (v10 == FigCaptionDynamicStyleGetTypeID() && FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
    {
      v11 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
LABEL_15:
      v7 = CFGetTypeID(v11);
      TypeID = CFDictionaryGetTypeID();
      goto LABEL_20;
    }
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  valuePtr = -1.0;
  v21 = CFGetTypeID(a3);
  if (v21 == FigCaptionDynamicStyleGetTypeID())
  {
    if (FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3))
    {
      v22 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
      v23 = CFGetTypeID(v22);
      if (v23 == CFNumberGetTypeID())
      {
        v24 = FigCaptionDynamicStyleGetInitialValue((CFDictionaryRef *)a3);
        CFNumberGetValue((CFNumberRef)v24, kCFNumberFloatType, &valuePtr);
        if (valuePtr >= 0.0 && valuePtr <= 1.0)
          goto LABEL_21;
      }
    }
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointRemoteControlSessionGetClassID()
{
  if (FigEndpointRemoteControlSessionGetClassID_sRegisterFigEndpointRemoteControlSessionBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointRemoteControlSessionGetClassID_sRegisterFigEndpointRemoteControlSessionBaseTypeOnce, &FigEndpointRemoteControlSessionGetClassID_sFigEndpointRemoteControlSessionClassID, (dispatch_function_t)remoteControlSession_getClassID);
  return FigEndpointRemoteControlSessionGetClassID_sFigEndpointRemoteControlSessionClassID;
}

uint64_t remoteControlSession_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&remoteControlSession_getClassID_sFigEndpointRemoteControlSessionClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointRemoteControlSessionGetTypeID()
{
  if (FigEndpointRemoteControlSessionGetClassID_sRegisterFigEndpointRemoteControlSessionBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointRemoteControlSessionGetClassID_sRegisterFigEndpointRemoteControlSessionBaseTypeOnce, &FigEndpointRemoteControlSessionGetClassID_sFigEndpointRemoteControlSessionClassID, (dispatch_function_t)remoteControlSession_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigEndpointRemoteControlSessionGetClassID_sFigEndpointRemoteControlSessionClassID);
}

CFStringRef remoteControlSession_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointRemoteControlSession %p]"), a1);
}

uint64_t FigGraphGetTypeID()
{
  FigThreadRunOnce(&FigGraphGetTypeID_sRegisterFigGraphOnce, (void (*)(void))RegisterFigGraph);
  return sFigGraphID;
}

uint64_t RegisterFigGraph()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigGraphID = result;
  return result;
}

uint64_t FigGraphCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t Instance;
  _QWORD *v14;
  CFDictionaryCopyDescriptionCallBack copyDescription;
  CFDictionaryEqualCallBack equal;
  CFMutableDictionaryRef v17;
  uint64_t result;
  CFDictionaryValueCallBacks v19;
  CFDictionaryKeyCallBacks keyCallBacks;

  memset(&keyCallBacks, 0, sizeof(keyCallBacks));
  if (!a7 || !a6)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  *(_OWORD *)&v19.version = xmmword_1E28DBBF8;
  *(_OWORD *)&v19.release = *(_OWORD *)&off_1E28DBC08;
  v19.equal = (CFDictionaryEqualCallBack)nodeInfoCFDictionaryEqualCallBack;
  FigThreadRunOnce(&FigGraphGetTypeID_sRegisterFigGraphOnce, (void (*)(void))RegisterFigGraph);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v14 = (_QWORD *)Instance;
    *(_QWORD *)(Instance + 24) = 0;
    if (a3)
    {
      keyCallBacks.copyDescription = *(CFDictionaryCopyDescriptionCallBack *)(a3 + 24);
      copyDescription = keyCallBacks.copyDescription;
      *(_OWORD *)&keyCallBacks.equal = *(_OWORD *)(a3 + 32);
      equal = keyCallBacks.equal;
      *(_QWORD *)(Instance + 32) = a2;
      *(_OWORD *)(Instance + 40) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(Instance + 56) = equal;
      *(_QWORD *)(Instance + 64) = copyDescription;
      *(_QWORD *)(Instance + 72) = a4;
      *(_OWORD *)(Instance + 80) = *(_OWORD *)(a5 + 8);
      *(_QWORD *)(Instance + 96) = *(_QWORD *)(a5 + 24);
    }
    *(_QWORD *)(Instance + 104) = a6;
    v17 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &keyCallBacks, &v19);
    v14[2] = v17;
    if (v17)
    {
      result = 0;
      *a7 = v14;
      return result;
    }
    CFRelease(v14);
  }
  return 4294954305;
}

uint64_t nodeInfoCFDictionaryRetainCallBack(uint64_t a1, uint64_t a2)
{
  return a2;
}

void nodeInfoCFDictionaryReleaseCallBack(CFAllocatorRef allocator, _QWORD *ptr)
{
  _QWORD *v4;
  void (*v5)(_QWORD, _QWORD);
  const void *v6;
  const void *v7;

  v4 = (_QWORD *)ptr[1];
  v5 = (void (*)(_QWORD, _QWORD))v4[2];
  if (v5)
    v5(*v4, *ptr);
  v6 = (const void *)ptr[2];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)ptr[6];
  if (v7)
    CFRelease(v7);
  CFAllocatorDeallocate(allocator, ptr);
}

BOOL nodeInfoCFDictionaryEqualCallBack(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t FigGraphAppendEdge(uint64_t a1, const void *a2, const void *a3, uint64_t a4)
{
  const __CFDictionary *v5;
  uint64_t result;
  uint64_t v9;
  CFAllocatorRef *v10;
  CFMutableArrayRef v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t (*v16)(_QWORD, uint64_t);
  uint64_t v17;
  uint64_t v18;
  CFArrayCallBacks callBacks;

  *(_OWORD *)&callBacks.version = xmmword_1E28DBC20;
  *(_OWORD *)&callBacks.release = *(_OWORD *)&off_1E28DBC30;
  callBacks.equal = 0;
  if (!a1)
    return 4294954306;
  v5 = *(const __CFDictionary **)(a1 + 16);
  if (!v5)
    return 4294954305;
  v18 = 0;
  result = figGraphCreateNodeInfoAddToDictionary(v5, a2, a1 + 32, &v18);
  if ((_DWORD)result)
    return result;
  v9 = v18;
  if (!v18)
    return 4294954305;
  v10 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (!*(_QWORD *)(v18 + 16))
  {
    v11 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callBacks);
    *(_QWORD *)(v9 + 16) = v11;
    if (!v11)
      return 4294954305;
  }
  v17 = 0;
  result = figGraphCreateNodeInfoAddToDictionary(*(const __CFDictionary **)(a1 + 16), a3, a1 + 32, &v17);
  if ((_DWORD)result)
    return result;
  v12 = v17;
  if (!v17)
    return 4294954305;
  v13 = (uint64_t *)CFAllocatorAllocate(*v10, 24, 0);
  if (!v13)
    return 4294954305;
  v14 = v13;
  v13[2] = v12;
  v15 = (_QWORD *)(a1 + 72);
  v16 = *(uint64_t (**)(_QWORD, uint64_t))(a1 + 80);
  if (v16)
    a4 = v16(*v15, a4);
  *v14 = a4;
  v14[1] = (uint64_t)v15;
  CFArrayAppendValue(*(CFMutableArrayRef *)(v9 + 16), v14);
  result = 0;
  ++*(_QWORD *)(a1 + 24);
  return result;
}

void EdgeInfoCFArrayReleaseCallBack(CFAllocatorRef allocator, _QWORD *ptr)
{
  _QWORD *v4;
  void (*v5)(_QWORD, _QWORD);

  v4 = (_QWORD *)ptr[1];
  v5 = (void (*)(_QWORD, _QWORD))v4[2];
  if (v5)
    v5(*v4, *ptr);
  CFAllocatorDeallocate(allocator, ptr);
}

uint64_t figGraphCreateNodeInfoAddToDictionary(const __CFDictionary *a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  const void *v6;
  _QWORD *Value;
  _QWORD *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, const void *);
  uint64_t result;

  v6 = a2;
  Value = CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    v9 = Value;
  }
  else
  {
    v10 = *MEMORY[0x1E0C9AE00];
    v9 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 56, 0);
    if (!v9)
    {
      result = 4294954305;
      goto LABEL_9;
    }
    if (a3)
    {
      v11 = *(uint64_t (**)(uint64_t, const void *))(a3 + 8);
      if (v11)
        v6 = (const void *)v11(v10, v6);
    }
    *v9 = v6;
    v9[1] = a3;
    v9[5] = 0;
    v9[6] = 0;
    v9[3] = -1;
    v9[4] = 0;
    v9[2] = 0;
    CFDictionarySetValue(a1, v6, v9);
  }
  result = 0;
LABEL_9:
  *a4 = v9;
  return result;
}

uint64_t FigGraphFindOptimalEdges(uint64_t a1, const void *a2, const void *a3, uint64_t (*a4)(_QWORD, _QWORD, _QWORD, uint64_t), uint64_t a5)
{
  const __CFDictionary *v6;
  uint64_t Value;
  _QWORD *v12;
  _QWORD *v13;
  char v14;
  _QWORD *v15;
  const __CFArray *v16;
  CFIndex Count;
  CFIndex v18;
  CFIndex i;
  _QWORD *ValueAtIndex;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  BOOL v27;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  const void *v39;
  const __CFAllocator *allocator;
  _QWORD *v41;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
    return 4294954306;
  v6 = *(const __CFDictionary **)(a1 + 16);
  if (!v6 || !*(_QWORD *)(a1 + 104))
    return 4294954305;
  Value = (uint64_t)CFDictionaryGetValue(v6, a2);
  v41 = (_QWORD *)Value;
  if (!Value)
    return Value;
  v12 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a3);
  if (!v12)
    return 0;
  v13 = v12;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  FigPriorityQueueCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 0, 0, (uint64_t)nodeInfoCompare, 0, &cf);
  if (!cf)
    return 4294954305;
  v39 = a2;
  v14 = 0;
  v15 = v41;
  v41[3] = -1;
  do
  {
    v16 = (const __CFArray *)v15[2];
    if (v16)
    {
      Count = CFArrayGetCount(v16);
      if (Count >= 1)
      {
        v18 = Count;
        for (i = 0; i != v18; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v41[2], i);
          v21 = (_QWORD *)ValueAtIndex[2];
          v22 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(a1 + 104))(*v41, *v21, *ValueAtIndex, a5);
          if ((v14 & 1) != 0)
          {
            v23 = v41[3];
            v24 = v23 + v22;
            if (__CFADD__(v23, v22))
              v24 = -1;
            if (__CFADD__(v22, v23))
              v22 = -1;
            else
              v22 = v24;
          }
          if (v22 < v21[3])
          {
            v25 = (_QWORD *)v21[6];
            v21[3] = v22;
            v26 = v41;
            v21[4] = *ValueAtIndex;
            v21[5] = v26;
            if (v25)
              FigPriorityQueueTokenUpdatePriority(v25);
            else
              FigPriorityQueueInsertItemAndCreateUpdateToken((uint64_t)cf, (uint64_t)v21, v21 + 6);
          }
        }
      }
    }
    FigPriorityQueueGetItem((uint64_t)cf, &v41);
    if (v41)
      v27 = v41 == v13;
    else
      v27 = 1;
    if (v27)
      break;
    v28 = (const void *)v41[6];
    if (v28)
    {
      CFRelease(v28);
      v41[6] = 0;
    }
    FigPriorityQueueRemoveItem((uint64_t)cf);
    v15 = v41;
    v14 = 1;
  }
  while (v41);
  if (v13[5])
  {
    v29 = 1;
    v30 = 1;
    v31 = v13;
    do
    {
      v31 = (_QWORD *)v31[5];
      ++v29;
      v30 += 2;
    }
    while (v31 != (_QWORD *)Value);
    v32 = CFAllocatorAllocate(allocator, v30 * 8 + 8, 0);
    v33 = v32;
    if (v32)
    {
      *v32 = v39;
      v32[v30] = 0;
      v34 = (int)v29 - 1;
      do
      {
        v32[2 * v34--] = *v13;
        v32[2 * v34 + 1] = v13[4];
        v13 = (_QWORD *)v13[5];
      }
      while (v13 != (_QWORD *)Value);
      v35 = v32 + 2;
      while (--v29)
      {
        v36 = v35 + 2;
        v37 = a4(*(v35 - 2), *v35, *(v35 - 1), a5);
        v35 = v36;
        if ((_DWORD)v37)
        {
          Value = v37;
          goto LABEL_42;
        }
      }
      Value = 0;
    }
    else
    {
      Value = 4294954305;
    }
  }
  else
  {
    Value = 0;
    v33 = 0;
  }
LABEL_42:
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)CFDictionaryApplierCleanupNodes, 0);
  if (cf)
    CFRelease(cf);
  if (v33)
    CFAllocatorDeallocate(allocator, v33);
  return Value;
}

uint64_t nodeInfoCompare(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL8 v5;

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *(_QWORD *)(a2 + 24);
  v4 = v2 >= v3;
  v5 = v2 > v3;
  if (v4)
    return v5;
  else
    return -1;
}

void CFDictionaryApplierCleanupNodes(uint64_t a1, _QWORD *a2)
{
  const void *v3;

  if (a2)
  {
    a2[4] = 0;
    a2[5] = 0;
    a2[3] = -1;
    v3 = (const void *)a2[6];
    if (v3)
    {
      CFRelease(v3);
      a2[6] = 0;
    }
  }
}

double FigGraphInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void FigGraphFinalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 16);
  if (v1)
    CFRelease(v1);
}

__CFString *FigGraphCopyFormattingDesc(CFDictionaryRef *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  __CFString *Mutable;
  CFAllocatorRef v6;

  v4 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v4, 0);
  if (Mutable)
  {
    v6 = CFGetAllocator(a1);
    CFStringAppendFormat(Mutable, a2, CFSTR("<FigGraph %p [%p]>{\n"), a1, v6);
    CFDictionaryApplyFunction(a1[2], (CFDictionaryApplierFunction)graphDataDescriptionApplier, Mutable);
    CFStringAppendFormat(Mutable, a2, CFSTR("}"));
  }
  return Mutable;
}

__CFString *FigGraphCopyDebugDesc(CFDictionaryRef *a1)
{
  return FigGraphCopyFormattingDesc(a1, 0);
}

void graphDataDescriptionApplier(uint64_t a1, uint64_t a2, __CFString *a3)
{
  uint64_t v4;
  uint64_t (*v5)(void);
  uint64_t v7;
  const void *v8;
  CFIndex i;
  _QWORD *ValueAtIndex;
  uint64_t v11;
  _QWORD *v12;
  uint64_t (*v13)(_QWORD);
  const void *v14;
  uint64_t v15;
  uint64_t (*v16)(void);
  uint64_t v17;
  const void *v18;

  if (*(_QWORD *)(a2 + 16))
  {
    if (*(_QWORD *)a2)
    {
      v4 = *(_QWORD *)(a2 + 8);
      if (v4)
      {
        v5 = *(uint64_t (**)(void))(v4 + 32);
        if (v5)
        {
          v7 = v5();
          if (v7)
          {
            v8 = (const void *)v7;
            if (CFArrayGetCount(*(CFArrayRef *)(a2 + 16)) >= 1)
            {
              for (i = 0; CFArrayGetCount(*(CFArrayRef *)(a2 + 16)) > i; ++i)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 16), i);
                v11 = ValueAtIndex[1];
                v12 = (_QWORD *)ValueAtIndex[2];
                if (v11 && (v13 = *(uint64_t (**)(_QWORD))(v11 + 24)) != 0)
                {
                  v14 = (const void *)v13(*ValueAtIndex);
                  if (!v12)
                    goto LABEL_19;
                }
                else
                {
                  v14 = 0;
                  if (!v12)
                    goto LABEL_19;
                }
                if (*v12)
                {
                  v15 = v12[1];
                  if (v15)
                  {
                    v16 = *(uint64_t (**)(void))(v15 + 32);
                    if (v16)
                    {
                      v17 = v16();
                      v18 = (const void *)v17;
                      if (v14 && v17)
                      {
                        CFStringAppendFormat(a3, 0, CFSTR("\t%@ %@ %@\n"), v8, v17, v14);
                        CFRelease(v14);
                        v14 = v18;
                      }
                      else
                      {
                        if (v14)
                          CFRelease(v14);
                        v14 = v18;
                        if (!v18)
                          continue;
                      }
LABEL_20:
                      CFRelease(v14);
                      continue;
                    }
                  }
                }
LABEL_19:
                if (v14)
                  goto LABEL_20;
              }
            }
            CFRelease(v8);
          }
        }
      }
    }
  }
}

uint64_t VEXUBridge_ConvertVideoExtendedUsageDescriptionExtensions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, const void *a7)
{
  const __CFAllocator *v11;
  const __CFArray *Mutable;
  CFArrayRef v13;
  const __CFArray *v14;
  const __CFArray *v15;
  uint64_t v16;
  CFIndex Count;
  _QWORD v19[2];
  uint64_t v20;
  CFArrayRef theArray[2];
  CFTypeRef cf[2];
  _OWORD v23[7];

  v19[0] = a2;
  v19[1] = a3;
  v20 = *a4;
  *(_OWORD *)theArray = 0u;
  *(_OWORD *)cf = 0u;
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  theArray[1] = Mutable;
  if (!Mutable)
  {
    a6 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  v13 = Mutable;
  v14 = CFArrayCreateMutable(v11, 0, MEMORY[0x1E0C9B378]);
  theArray[0] = v14;
  if (!v14
    || (v15 = v14, (cf[0] = CFDictionaryCreateMutable(v11, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) == 0))
  {
    v16 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  cf[1] = a7;
  FigCFArrayAppendInt32(v15, 1986361461);
  if (!a6)
  {
LABEL_12:
    CFRelease(v13);
    goto LABEL_13;
  }
  memset(v23, 0, sizeof(v23));
  v16 = FigAtomStreamInitWithMemoryBlock(a5, a6, 0, 0, (uint64_t)v23);
  if ((_DWORD)v16)
  {
LABEL_19:
    a6 = v16;
    goto LABEL_12;
  }
  a6 = parseVideoExtendedUsageExtensionChildAtoms(v23, (uint64_t)"tsum", 6, (uint64_t)v19);
  v13 = theArray[1];
  if (!(_DWORD)a6)
  {
    if (theArray[1])
    {
      Count = CFArrayGetCount(theArray[1]);
      v13 = theArray[1];
      if (Count >= 1)
      {
        vexuReader_appendKeyAndValue(v19, CFSTR("RequiredButUnrecognizedFormatAtoms"), theArray[1]);
        v13 = theArray[1];
      }
    }
    *a4 = v20;
  }
  if (v13)
    goto LABEL_12;
LABEL_13:
  if (theArray[0])
    CFRelease(theArray[0]);
  if (cf[0])
    CFRelease(cf[0]);
  return a6;
}

_QWORD *vexuReader_appendKeyAndValue(_QWORD *result, CFTypeRef cf, CFTypeRef a3)
{
  _QWORD *v4;
  uint64_t v5;

  v4 = result;
  if (*result)
  {
    result = CFRetain(cf);
    *(_QWORD *)(*v4 + 8 * v4[2]) = result;
  }
  if (v4[1])
  {
    result = CFRetain(a3);
    v5 = v4[2];
    *(_QWORD *)(v4[1] + 8 * v5) = result;
  }
  else
  {
    v5 = v4[2];
  }
  v4[2] = v5 + 1;
  return result;
}

uint64_t VEXUBridge_ConvertVideoExtendedUsageExtensionToAtom(const opaqueCMFormatDescription *a1, size_t *a2, void *a3)
{
  uint64_t DataPointer;
  const __CFBoolean *Extension;
  const __CFBoolean *v8;
  CFTypeID v9;
  int v10;
  char v11;
  const __CFBoolean *v12;
  const __CFBoolean *v13;
  CFTypeID v14;
  const __CFBoolean *v15;
  const __CFBoolean *v16;
  CFTypeID v17;
  const __CFBoolean *v18;
  const __CFBoolean *v19;
  CFTypeID v20;
  CFPropertyListRef v21;
  const void *v22;
  CFTypeID v23;
  char v24;
  const __CFNumber *v25;
  const __CFNumber *v26;
  CFTypeID v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  CFTypeID v30;
  const __CFNumber *v31;
  const __CFNumber *v32;
  CFTypeID v33;
  CFPropertyListRef v34;
  const void *v35;
  CFTypeID v36;
  unsigned int v37;
  CFPropertyListRef v38;
  const void *v39;
  CFTypeID v40;
  unsigned int v41;
  CFPropertyListRef v42;
  const void *v43;
  CFTypeID v44;
  size_t DataLength;
  uint64_t v46;
  size_t v47;
  void *__dst;
  size_t *v50;
  char *dataPointerOut;
  CMBlockBufferRef blockBufferOut;
  _OWORD v53[3];
  uint64_t v54;
  _OWORD v55[3];
  uint64_t v56;
  unsigned int v57;
  unsigned int valuePtr;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  unsigned int v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;

  v56 = 0;
  memset(v55, 0, sizeof(v55));
  v54 = 0;
  memset(v53, 0, sizeof(v53));
  dataPointerOut = 0;
  blockBufferOut = 0;
  DataPointer = CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 8u, 0, &blockBufferOut);
  if ((_DWORD)DataPointer)
    goto LABEL_144;
  DataPointer = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v55);
  if ((_DWORD)DataPointer)
    goto LABEL_144;
  DataPointer = FigAtomWriterBeginAtom((uint64_t)v55, 0x76657875u, 0);
  if ((_DWORD)DataPointer)
    goto LABEL_144;
  __dst = a3;
  if (a1)
  {
    if (!CMFormatDescriptionGetExtension(a1, CFSTR("HasLeftStereoEyeView"))
      && !CMFormatDescriptionGetExtension(a1, CFSTR("HasRightStereoEyeView"))
      && !CMFormatDescriptionGetExtension(a1, CFSTR("HasEyeViewsReversed"))
      && !CMFormatDescriptionGetExtension(a1, CFSTR("HasAdditionalViews"))
      && !CMFormatDescriptionGetExtension(a1, CFSTR("HeroEye"))
      && !CMFormatDescriptionGetExtension(a1, CFSTR("StereoCameraBaseline"))
      && !CMFormatDescriptionGetExtension(a1, CFSTR("HorizontalDisparityAdjustment")))
    {
      goto LABEL_71;
    }
    DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
    if ((_DWORD)DataPointer)
      goto LABEL_144;
    DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x65796573u, 0);
    if ((_DWORD)DataPointer)
      goto LABEL_144;
    v67 = 0;
    v65 = 0u;
    v66 = 0u;
    v64 = 0u;
    LODWORD(v59) = 0;
    LOBYTE(v63) = 0;
    Extension = (const __CFBoolean *)CMFormatDescriptionGetExtension(a1, CFSTR("HasLeftStereoEyeView"));
    v50 = a2;
    if (Extension && (v8 = Extension, v9 = CFGetTypeID(Extension), v9 == CFBooleanGetTypeID()))
    {
      v10 = 1;
      if (CFBooleanGetValue(v8))
      {
        LOBYTE(v63) = 1;
        v11 = 1;
      }
      else
      {
        v11 = 0;
      }
    }
    else
    {
      v11 = 0;
      v10 = 0;
    }
    v12 = (const __CFBoolean *)CMFormatDescriptionGetExtension(a1, CFSTR("HasRightStereoEyeView"));
    if (v12)
    {
      v13 = v12;
      v14 = CFGetTypeID(v12);
      if (v14 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v13))
        {
          v11 |= 2u;
          LOBYTE(v63) = v11;
        }
        v10 = 1;
      }
    }
    v15 = (const __CFBoolean *)CMFormatDescriptionGetExtension(a1, CFSTR("HasAdditionalViews"));
    if (v15)
    {
      v16 = v15;
      v17 = CFGetTypeID(v15);
      if (v17 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v16))
        {
          v11 |= 4u;
          LOBYTE(v63) = v11;
        }
        v10 = 1;
      }
    }
    v18 = (const __CFBoolean *)CMFormatDescriptionGetExtension(a1, CFSTR("HasEyeViewsReversed"));
    if (v18 && (v19 = v18, v20 = CFGetTypeID(v18), v20 == CFBooleanGetTypeID()))
    {
      if (CFBooleanGetValue(v19))
        LOBYTE(v63) = v11 | 8;
    }
    else if (!v10)
    {
      goto LABEL_39;
    }
    if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
      && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x73747269u, 0))
    {
      LODWORD(v59) = 0;
      if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4)
        && !FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v63, 1))
      {
        FigAtomWriterEndAtom((uint64_t)&v64);
      }
    }
LABEL_39:
    v67 = 0;
    v65 = 0u;
    v66 = 0u;
    v64 = 0u;
    v21 = CMFormatDescriptionGetExtension(a1, CFSTR("HeroEye"));
    a2 = v50;
    if (v21)
    {
      v22 = v21;
      v23 = CFGetTypeID(v21);
      if (v23 == CFStringGetTypeID())
      {
        if (CFEqual(CFSTR("Left"), v22))
        {
          v24 = 1;
        }
        else
        {
          if (!CFEqual(CFSTR("Right"), v22))
          {
            FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
            goto LABEL_50;
          }
          v24 = 2;
        }
        LOBYTE(v63) = v24;
        if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
          && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x6865726Fu, 0))
        {
          LODWORD(v59) = 0;
          if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4)
            && !FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v63, 1))
          {
            FigAtomWriterEndAtom((uint64_t)&v64);
          }
        }
      }
    }
LABEL_50:
    v67 = 0;
    v65 = 0u;
    v66 = 0u;
    v64 = 0u;
    v62 = 0;
    v60 = 0u;
    v61 = 0u;
    v59 = 0u;
    valuePtr = 0;
    v25 = (const __CFNumber *)CMFormatDescriptionGetExtension(a1, CFSTR("StereoCameraBaseline"));
    if (v25)
    {
      v26 = v25;
      v27 = CFGetTypeID(v25);
      if (v27 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v26, kCFNumberSInt32Type, &valuePtr);
        if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
          && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x63616D73u, 0)
          && !FigAtomWriterInitWithParent((uint64_t)&v64, (uint64_t)&v59)
          && !FigAtomWriterBeginAtom((uint64_t)&v59, 0x626C696Eu, 0))
        {
          v63 = 0;
          if (!FigAtomWriterAppendData((uint64_t)&v59, (uint64_t)&v63, 4))
          {
            v63 = bswap32(valuePtr);
            if (!FigAtomWriterAppendData((uint64_t)&v59, (uint64_t)&v63, 4)
              && !FigAtomWriterEndAtom((uint64_t)&v59))
            {
              FigAtomWriterEndAtom((uint64_t)&v64);
            }
          }
        }
      }
    }
    v67 = 0;
    v65 = 0u;
    v66 = 0u;
    v64 = 0u;
    v62 = 0;
    v60 = 0u;
    v61 = 0u;
    v59 = 0u;
    v57 = 0;
    v28 = (const __CFNumber *)CMFormatDescriptionGetExtension(a1, CFSTR("HorizontalDisparityAdjustment"));
    if (v28)
    {
      v29 = v28;
      v30 = CFGetTypeID(v28);
      if (v30 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v29, kCFNumberSInt32Type, &v57);
        if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
          && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x636D6679u, 0)
          && !FigAtomWriterInitWithParent((uint64_t)&v64, (uint64_t)&v59)
          && !FigAtomWriterBeginAtom((uint64_t)&v59, 0x6461646Au, 0))
        {
          v63 = 0;
          if (!FigAtomWriterAppendData((uint64_t)&v59, (uint64_t)&v63, 4))
          {
            valuePtr = bswap32(v57);
            if (!FigAtomWriterAppendData((uint64_t)&v59, (uint64_t)&valuePtr, 4)
              && !FigAtomWriterEndAtom((uint64_t)&v59))
            {
              FigAtomWriterEndAtom((uint64_t)&v64);
            }
          }
        }
      }
    }
    DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
    if ((_DWORD)DataPointer)
      goto LABEL_144;
LABEL_71:
    if (CMFormatDescriptionGetExtension(a1, CFSTR("TransportIdentifier")))
    {
      DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
      if ((_DWORD)DataPointer)
        goto LABEL_144;
      DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x636D7261u, 0);
      if ((_DWORD)DataPointer)
        goto LABEL_144;
      v67 = 0;
      v65 = 0u;
      v66 = 0u;
      v64 = 0u;
      v63 = 0;
      v31 = (const __CFNumber *)CMFormatDescriptionGetExtension(a1, CFSTR("TransportIdentifier"));
      if (v31)
      {
        v32 = v31;
        v33 = CFGetTypeID(v31);
        if (v33 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v32, kCFNumberSInt32Type, &v63);
          if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
            && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x74696E79u, 0))
          {
            LODWORD(v59) = 0;
            if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
            {
              LODWORD(v59) = bswap32(v63);
              if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
                FigAtomWriterEndAtom((uint64_t)&v64);
            }
          }
        }
      }
      DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
      if ((_DWORD)DataPointer)
        goto LABEL_144;
    }
    if (!CMFormatDescriptionGetExtension(a1, CFSTR("ProjectionKind")))
      goto LABEL_103;
    DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
    if ((_DWORD)DataPointer)
      goto LABEL_144;
    DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x70726F6Au, 0);
    if ((_DWORD)DataPointer)
      goto LABEL_144;
    v67 = 0;
    v65 = 0u;
    v66 = 0u;
    v64 = 0u;
    v34 = CMFormatDescriptionGetExtension(a1, CFSTR("ProjectionKind"));
    if (v34)
    {
      v35 = v34;
      v36 = CFGetTypeID(v34);
      if (v36 == CFStringGetTypeID())
      {
        if (CFEqual(CFSTR("Rectilinear"), v35))
        {
          v37 = 1919247220;
        }
        else if (CFEqual(CFSTR("Equirectangular"), v35))
        {
          v37 = 1701934441;
        }
        else if (CFEqual(CFSTR("HalfEquirectangular"), v35))
        {
          v37 = 1751478645;
        }
        else
        {
          if (!CFEqual(CFSTR("Fisheye"), v35))
          {
            FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
            goto LABEL_102;
          }
          v37 = 1718186856;
        }
        if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
          && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x70726A69u, 0))
        {
          LODWORD(v59) = 0;
          if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
          {
            LODWORD(v59) = bswap32(v37);
            if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
              FigAtomWriterEndAtom((uint64_t)&v64);
          }
        }
      }
    }
LABEL_102:
    DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
    if ((_DWORD)DataPointer)
      goto LABEL_144;
LABEL_103:
    if (!CMFormatDescriptionGetExtension(a1, CFSTR("ViewPackingKind")))
    {
LABEL_118:
      if (CMFormatDescriptionGetExtension(a1, CFSTR("WarpKind")))
      {
        DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
        if ((_DWORD)DataPointer)
          goto LABEL_144;
        DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x77617270u, 0);
        if ((_DWORD)DataPointer)
          goto LABEL_144;
        v67 = 0;
        v65 = 0u;
        v66 = 0u;
        v64 = 0u;
        v42 = CMFormatDescriptionGetExtension(a1, CFSTR("WarpKind"));
        if (v42)
        {
          v43 = v42;
          v44 = CFGetTypeID(v42);
          if (v44 == CFStringGetTypeID())
          {
            if (CFEqual(CFSTR("ApplicationDefined"), v43))
            {
              if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
                && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x77727069u, 0))
              {
                LODWORD(v59) = 0;
                if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
                {
                  LODWORD(v59) = 1953723747;
                  if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
                    FigAtomWriterEndAtom((uint64_t)&v64);
                }
              }
            }
            else
            {
              FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
            }
          }
        }
        DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
        if ((_DWORD)DataPointer)
          goto LABEL_144;
      }
      goto LABEL_131;
    }
    DataPointer = FigAtomWriterInitWithParent((uint64_t)v55, (uint64_t)v53);
    if ((_DWORD)DataPointer)
      goto LABEL_144;
    DataPointer = FigAtomWriterBeginAtom((uint64_t)v53, 0x7061636Bu, 0);
    if ((_DWORD)DataPointer)
      goto LABEL_144;
    v67 = 0;
    v65 = 0u;
    v66 = 0u;
    v64 = 0u;
    v38 = CMFormatDescriptionGetExtension(a1, CFSTR("ViewPackingKind"));
    if (!v38)
      goto LABEL_117;
    v39 = v38;
    v40 = CFGetTypeID(v38);
    if (v40 != CFStringGetTypeID())
      goto LABEL_117;
    if (CFEqual(CFSTR("SideBySide"), v39))
    {
      v41 = 1936286821;
    }
    else
    {
      if (!CFEqual(CFSTR("OverUnder"), v39))
      {
        FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
        goto LABEL_117;
      }
      v41 = 1870030194;
    }
    if (!FigAtomWriterInitWithParent((uint64_t)v53, (uint64_t)&v64)
      && !FigAtomWriterBeginAtom((uint64_t)&v64, 0x706B696Eu, 0))
    {
      LODWORD(v59) = 0;
      if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
      {
        LODWORD(v59) = bswap32(v41);
        if (!FigAtomWriterAppendData((uint64_t)&v64, (uint64_t)&v59, 4))
          FigAtomWriterEndAtom((uint64_t)&v64);
      }
    }
LABEL_117:
    DataPointer = FigAtomWriterEndAtom((uint64_t)v53);
    if (!(_DWORD)DataPointer)
      goto LABEL_118;
LABEL_144:
    v46 = DataPointer;
    goto LABEL_135;
  }
LABEL_131:
  DataPointer = FigAtomWriterEndAtom((uint64_t)v55);
  if ((_DWORD)DataPointer)
    goto LABEL_144;
  DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_144;
  DataLength = CMBlockBufferGetDataLength(blockBufferOut);
  if (DataLength == 8)
  {
    v46 = 0;
LABEL_135:
    v47 = 0;
    goto LABEL_139;
  }
  v47 = DataLength;
  if (__dst)
    memcpy(__dst, dataPointerOut, DataLength);
  v46 = 0;
LABEL_139:
  *a2 = v47;
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v46;
}

uint64_t parseRequiredBoxTypesAtom(uint64_t a1, uint64_t a2)
{
  const __CFArray *v3;
  CFIndex Count;
  const void *ValueAtIndex;
  const void *v7;
  uint64_t CurrentAtomTypeAndDataLength;
  UInt8 *v9;
  uint64_t CurrentAtomData;
  CFDataRef v11;
  CFDataRef v12;
  uint64_t v13;
  uint64_t v14;
  size_t size;
  int v17;

  v17 = 0;
  size = 0;
  v3 = *(const __CFArray **)(a2 + 24);
  if (!v3
    || (Count = CFArrayGetCount(v3), Count <= 0)
    || (ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 24), Count - 2)) == 0)
  {
    v14 = 4294954516;
LABEL_11:
    CurrentAtomTypeAndDataLength = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  v7 = ValueAtIndex;
  CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v17, &size);
  if ((_DWORD)CurrentAtomTypeAndDataLength)
  {
LABEL_12:
    v13 = CurrentAtomTypeAndDataLength;
    v9 = 0;
LABEL_13:
    free(v9);
    return v13;
  }
  if ((size & 3) != 0)
  {
    v14 = 4294954584;
    goto LABEL_11;
  }
  v9 = (UInt8 *)malloc_type_malloc(size, 0x29CAD75FuLL);
  if (!v9)
    goto LABEL_15;
  CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1, 0, size, (uint64_t)v9);
  if ((_DWORD)CurrentAtomData)
  {
LABEL_16:
    v13 = CurrentAtomData;
    goto LABEL_13;
  }
  v11 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9 + 4, size - 4);
  if (!v11)
  {
LABEL_15:
    CurrentAtomData = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  v12 = v11;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 40), v7, v11);
  free(v9);
  CFRelease(v12);
  return 0;
}

uint64_t parseStereoViewAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v5[7];
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!(_DWORD)result)
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)"tsum", 5, a2);
  }
  return result;
}

uint64_t parseCameraIdentifierAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v5[7];
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!(_DWORD)result)
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)"tsum", 2, a2);
  }
  return result;
}

uint64_t parseProjectionAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v5[7];
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!(_DWORD)result)
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)"tsum", 2, a2);
  }
  return result;
}

uint64_t parsePackingAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v5[7];
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!(_DWORD)result)
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)"tsum", 2, a2);
  }
  return result;
}

uint64_t parseWarpAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v5[7];
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!(_DWORD)result)
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)"tsum", 2, a2);
  }
  return result;
}

uint64_t parseVideoExtendedUsageExtensionChildAtoms(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const __CFAllocator *v8;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v10;
  _DWORD *v11;
  uint64_t CurrentAtomTypeAndDataLength;
  _DWORD *v13;
  uint64_t v14;
  __CFArray *v15;
  CFIndex Count;
  uint64_t Atom;
  uint64_t v18;
  const __CFArray *v19;
  CFIndex v20;
  void *ValueAtIndex;
  void *v22;
  const __CFData *Value;
  const __CFData *v24;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v27;
  const UInt8 *v28;
  uint64_t v29;
  unsigned int v30;
  CFMutableArrayRef v31;
  CFMutableArrayRef v32;
  CFMutableStringRef v33;
  __CFString *v34;
  CFIndex i;
  const __CFArray *v36;
  const char *v37;
  char *CStringPtrAndBufferToFree;
  uint64_t v39;
  CFMutableDictionaryRef v40;
  CFMutableDictionaryRef v41;
  __CFString *v42;
  __CFString *v43;
  uint64_t v44;
  void *v46;
  const UInt8 *v47;
  __CFArray *v48;
  uint64_t v49;
  const __CFAllocator *allocator;
  uint64_t v51;
  int v52;
  void *v53;
  char __str[4];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  v10 = Mutable;
  v52 = 0;
  v11 = (_DWORD *)(a2 + 8);
  do
  {
    CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)a1, &v52, 0);
    if ((_DWORD)CurrentAtomTypeAndDataLength)
    {
LABEL_47:
      v18 = CurrentAtomTypeAndDataLength;
      goto LABEL_46;
    }
    if (a3 >= 1)
    {
      v13 = v11;
      v14 = a3;
      while (v52 != *(v13 - 2))
      {
        v13 += 4;
        if (!--v14)
          goto LABEL_14;
      }
      FigCFArrayAppendInt32(*(void **)(a4 + 24), v52);
      CurrentAtomTypeAndDataLength = (*(uint64_t (**)(_QWORD *, uint64_t))v13)(a1, a4);
      if ((_DWORD)CurrentAtomTypeAndDataLength)
        goto LABEL_47;
      FigCFArrayAppendInt32(v10, v52);
      v15 = *(__CFArray **)(a4 + 24);
      if (v15)
        Count = CFArrayGetCount(*(CFArrayRef *)(a4 + 24));
      else
        Count = 0;
      CFArrayRemoveValueAtIndex(v15, Count - 1);
    }
LABEL_14:
    Atom = FigAtomStreamAdvanceToNextAtom(a1);
  }
  while (!(_DWORD)Atom);
  v18 = Atom;
  if ((_DWORD)Atom == -12890)
    v18 = 0;
  v19 = *(const __CFArray **)(a4 + 24);
  if (v19)
  {
    v20 = CFArrayGetCount(v19);
    if (v20 > 0)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 24), v20 - 1);
      if (ValueAtIndex)
      {
        v22 = ValueAtIndex;
        Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 40), ValueAtIndex);
        if (!Value)
          goto LABEL_46;
        v24 = Value;
        v46 = v22;
        Length = CFDataGetLength(Value);
        BytePtr = CFDataGetBytePtr(v24);
        v27 = Length + 3;
        if (Length >= 0)
          v27 = Length;
        if (Length < 4)
        {
LABEL_43:
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a4 + 40), v46);
          goto LABEL_46;
        }
        v28 = BytePtr;
        v29 = 0;
        v51 = v27 >> 2;
        v47 = BytePtr;
        v48 = v10;
        allocator = v8;
        while (1)
        {
          v30 = bswap32(*(_DWORD *)&v28[4 * v29]);
          if (!FigCFArrayContainsInt32(v10, v30))
          {
            v53 = 0;
            v31 = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
            if (!v31)
            {
              v44 = 4294954510;
              goto LABEL_45;
            }
            v32 = v31;
            v33 = CFStringCreateMutable(v8, 0);
            if (!v33)
            {
              FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
              CFRelease(v32);
              goto LABEL_46;
            }
            v34 = v33;
            for (i = 0; ; ++i)
            {
              v36 = *(const __CFArray **)(a4 + 24);
              if (v36)
                v36 = (const __CFArray *)CFArrayGetCount(v36);
              if (i >= (uint64_t)v36)
                break;
              *(_DWORD *)__str = 0;
              FigCFArrayGetInt32AtIndex(*(const void **)(a4 + 24), i, __str);
              FigCFArrayAppendInt32(v32, *(int *)__str);
              if (i)
                v37 = "/";
              else
                v37 = "";
              CFStringAppendFormat(v34, 0, CFSTR("%s%c%c%c%c"), v37, __str[3], __str[2], __str[1], __str[0], v46);
            }
            FigCFArrayAppendInt32(v32, v30);
            CFArrayAppendValue(*(CFMutableArrayRef *)(a4 + 32), v32);
            CFStringAppendFormat(v34, 0, CFSTR("/%c%c%c%c"), HIBYTE(v30), BYTE2(v30), BYTE1(v30), v30);
            CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(v34, 0x8000100u, (char **)&v53);
            snprintf(__str, 0x100uLL, "The video extensibility usability box indicates that the content requires that readers successfully parse the '%s' box, which this reader can not do.", CStringPtrAndBufferToFree);
            FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
            v39 = *(_QWORD *)(a4 + 48);
            if (v39)
            {
              v40 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              if (v40)
              {
                v41 = v40;
                v49 = v39;
                v42 = CFStringCreateMutable(allocator, 0);
                if (v42)
                {
                  v43 = v42;
                  CFStringAppendFormat(v42, 0, CFSTR(" %s."), __str);
                  FigCFDictionarySetInt64(v41, CFSTR("MessageType"), 4);
                  CFDictionarySetValue(v41, CFSTR("DiagnosticInformation"), v43);
                  FigCFDictionarySetInt32(v41, CFSTR("AnalysisType"), 1836019574);
                  FigAssetAnalysisReporterAddMessage(v49, v41);
                  CFRelease(v43);
                }
                CFRelease(v41);
              }
            }
            free(v53);
            CFRelease(v32);
            CFRelease(v34);
            v28 = v47;
            v10 = v48;
            v8 = allocator;
          }
          if (++v29 == v51)
            goto LABEL_43;
        }
      }
    }
  }
  v44 = 4294954516;
LABEL_45:
  FigSignalErrorAt(v44, 0, 0, 0, 0, 0, 0);
LABEL_46:
  CFRelease(v10);
  return v18;
}

uint64_t parseStereoViewInformationAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  char v5;
  CFTypeRef *v6;
  int v7;
  char v8;
  uint64_t v9;
  int v10;

  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!(_DWORD)result)
  {
    if (v9 != 5)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    result = FigAtomStreamReadCurrentAtomData(a1, 0, 5, (uint64_t)&v7);
    if (!(_DWORD)result)
    {
      v5 = v8;
      v6 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
      if ((v8 & 1) != 0)
      {
        vexuReader_appendKeyAndValue(a2, CFSTR("HasLeftStereoEyeView"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
        v5 = v8;
        if ((v8 & 2) == 0)
        {
LABEL_6:
          if ((v5 & 4) == 0)
            goto LABEL_7;
          goto LABEL_13;
        }
      }
      else if ((v8 & 2) == 0)
      {
        goto LABEL_6;
      }
      vexuReader_appendKeyAndValue(a2, CFSTR("HasRightStereoEyeView"), *v6);
      v5 = v8;
      if ((v8 & 4) == 0)
      {
LABEL_7:
        if ((v5 & 8) == 0)
          return 0;
LABEL_8:
        vexuReader_appendKeyAndValue(a2, CFSTR("HasEyeViewsReversed"), *v6);
        return 0;
      }
LABEL_13:
      vexuReader_appendKeyAndValue(a2, CFSTR("HasAdditionalViews"), *v6);
      if ((v8 & 8) == 0)
        return 0;
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t parseHeroStereoEyeAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  __CFString **v5;
  uint64_t v6;
  int v7;
  unsigned __int8 v8;
  uint64_t v9;
  int v10;

  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!(_DWORD)result)
  {
    if (v9 != 5)
    {
      v6 = 4294954584;
      return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
    }
    result = FigAtomStreamReadCurrentAtomData(a1, 0, 5, (uint64_t)&v7);
    if (!(_DWORD)result)
    {
      result = v8;
      if (v8)
      {
        if (v8 == 2)
        {
          v5 = kFigFormatDescriptionHeroEye_Right;
          goto LABEL_9;
        }
        if (v8 == 1)
        {
          v5 = kFigFormatDescriptionHeroEye_Left;
LABEL_9:
          vexuReader_appendKeyAndValue(a2, CFSTR("HeroEye"), *v5);
          return 0;
        }
        v6 = 4294954580;
        return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return result;
}

uint64_t parseStereoCameraSystemAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v5[7];
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!(_DWORD)result)
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)"tsum", 2, a2);
  }
  return result;
}

uint64_t parseStereoComfortAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v5[7];
  uint64_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v7, &v6);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!(_DWORD)result)
      return parseVideoExtendedUsageExtensionChildAtoms(v5, (uint64_t)"tsum", 2, a2);
  }
  return result;
}

uint64_t parseStereoCameraSystemBaselineAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  CFNumberRef UInt32;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v10 = 0;
  v8 = 0;
  v9 = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!(_DWORD)result)
  {
    if (v9 == 8)
    {
      result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if ((_DWORD)result)
        return result;
      UInt32 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], bswap32(HIDWORD(v8)));
      if (UInt32)
      {
        v6 = UInt32;
        vexuReader_appendKeyAndValue(a2, CFSTR("StereoCameraBaseline"), UInt32);
        CFRelease(v6);
        return 0;
      }
      v7 = 4294954583;
    }
    else
    {
      v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseStereoComfortDisparityAdjustmentAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  CFNumberRef SInt32;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v10 = 0;
  v8 = 0;
  v9 = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!(_DWORD)result)
  {
    if (v9 == 8)
    {
      result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if ((_DWORD)result)
        return result;
      SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], bswap32(HIDWORD(v8)));
      if (SInt32)
      {
        v6 = SInt32;
        vexuReader_appendKeyAndValue(a2, CFSTR("HorizontalDisparityAdjustment"), SInt32);
        CFRelease(v6);
        return 0;
      }
      v7 = 4294954583;
    }
    else
    {
      v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseTransportIdentifierAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  CFNumberRef UInt32;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v10 = 0;
  v8 = 0;
  v9 = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!(_DWORD)result)
  {
    if (v9 == 8)
    {
      result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if ((_DWORD)result)
        return result;
      UInt32 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], bswap32(HIDWORD(v8)));
      if (UInt32)
      {
        v6 = UInt32;
        vexuReader_appendKeyAndValue(a2, CFSTR("TransportIdentifier"), UInt32);
        CFRelease(v6);
        return 0;
      }
      v7 = 4294954583;
    }
    else
    {
      v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseProjectionInformationAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  int v5;
  __CFString **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v10 = 0;
  v8 = 0;
  v9 = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!(_DWORD)result)
  {
    if (v9 == 8)
    {
      result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if ((_DWORD)result)
        return result;
      v5 = bswap32(HIDWORD(v8));
      HIDWORD(v8) = v5;
      if (v5 > 1751478644)
      {
        if (v5 == 1751478645)
        {
          v6 = kFigFormatDescriptionProjectionKind_HalfEquirectangular;
          goto LABEL_13;
        }
        if (v5 == 1919247220)
        {
          v6 = kFigFormatDescriptionProjectionKind_Rectilinear;
          goto LABEL_13;
        }
      }
      else
      {
        if (v5 == 1701934441)
        {
          v6 = kFigFormatDescriptionProjectionKind_Equirectangular;
          goto LABEL_13;
        }
        if (v5 == 1718186856)
        {
          v6 = kFigFormatDescriptionProjectionKind_Fisheye;
LABEL_13:
          vexuReader_appendKeyAndValue(a2, CFSTR("ProjectionKind"), *v6);
          return 0;
        }
      }
      v7 = 4294954580;
    }
    else
    {
      v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseViewPackingInformationAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  unsigned int v5;
  __CFString **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v10 = 0;
  v8 = 0;
  v9 = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v10, &v9);
  if (!(_DWORD)result)
  {
    if (v9 == 8)
    {
      result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v8);
      if ((_DWORD)result)
        return result;
      v5 = bswap32(HIDWORD(v8));
      HIDWORD(v8) = v5;
      if (v5 == 1870030194)
      {
        v6 = kFigFormatDescriptionViewPackingKind_OverUnder;
        goto LABEL_8;
      }
      if (v5 == 1936286821)
      {
        v6 = kFigFormatDescriptionViewPackingKind_SideBySide;
LABEL_8:
        vexuReader_appendKeyAndValue(a2, CFSTR("ViewPackingKind"), *v6);
        return 0;
      }
      v7 = 4294954580;
    }
    else
    {
      v7 = 4294954584;
    }
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t parseWarpInformationAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  v9 = 0;
  v7 = 0;
  v8 = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v9, &v8);
  if (!(_DWORD)result)
  {
    if (v8 == 8)
    {
      result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)&v7);
      if ((_DWORD)result)
        return result;
      v5 = HIDWORD(v7);
      HIDWORD(v7) = bswap32(HIDWORD(v7));
      if (v5 == 1953723747)
      {
        vexuReader_appendKeyAndValue(a2, CFSTR("WarpKind"), CFSTR("ApplicationDefined"));
        return 0;
      }
      v6 = 4294954580;
    }
    else
    {
      v6 = 4294954584;
    }
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigEndpointMessengerGetClassID()
{
  if (FigEndpointMessengerGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigEndpointMessengerGetClassID_sRegisterOnce, &FigEndpointMessengerGetClassID_sClassID, (dispatch_function_t)messenger_getClassID);
  return FigEndpointMessengerGetClassID_sClassID;
}

uint64_t messenger_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&messenger_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointMessengerGetTypeID()
{
  if (FigEndpointMessengerGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigEndpointMessengerGetClassID_sRegisterOnce, &FigEndpointMessengerGetClassID_sClassID, (dispatch_function_t)messenger_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigEndpointMessengerGetClassID_sClassID);
}

CFStringRef messenger_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointMessenger %p]"), a1);
}

uint64_t FigCaptionTextShadowGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType);
  return sFigCaptionTextShadowID;
}

uint64_t RegisterFigCaptionTextShadowType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionTextShadowID = result;
  return result;
}

uint64_t FigCaptionTextShadowGetColor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t FigCaptionTextShadowGetHorizontalAxisOffset(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t FigCaptionTextShadowGetVerticalAxisOffset(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t FigCaptionTextShadowGetBlurRadius(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t FigCaptionTextShadowCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CGColor *a8, _QWORD *a9)
{
  uint64_t Instance;
  _QWORD *v17;
  CGColorRef v18;

  if (!a9)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v17 = (_QWORD *)Instance;
    v18 = CGColorRetain(a8);
    v17[7] = a7;
    v17[8] = v18;
    v17[2] = a2;
    v17[3] = a3;
    v17[4] = a4;
    v17[5] = a5;
    v17[6] = a6;
    *a9 = v17;
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigCaptionTextShadowCreateNone(uint64_t a1, _QWORD *a2)
{
  return FigCaptionTextShadowCreate(a1, 0, 0x100000000, 0, 0x100000000, 0, 0x100000000, 0, a2);
}

uint64_t FigCaptionTextShadowListGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType);
  return sFigCaptionTextShadowListID;
}

uint64_t RegisterFigCaptionTextShadowListType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionTextShadowListID = result;
  return result;
}

uint64_t FigCaptionTextShadowListGetTextShadowArray(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t FigCaptionTextShadowListCreate(const __CFAllocator *a1, const __CFArray *a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v7;
  CFArrayRef Copy;

  if (!a3)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v7 = Instance;
    if (a2)
      Copy = CFArrayCreateCopy(a1, a2);
    else
      Copy = 0;
    *(_QWORD *)(v7 + 16) = Copy;
    *a3 = v7;
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigCaptionTextShadowListCreateNone(const __CFAllocator *a1, uint64_t *a2)
{
  return FigCaptionTextShadowListCreate(a1, 0, a2);
}

double fcts_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 64) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void fcts_Finalize(uint64_t a1)
{
  CGColorRelease(*(CGColorRef *)(a1 + 64));
}

BOOL fcts_Equal(_BOOL8 result, uint64_t a2)
{
  uint64_t v3;
  CFTypeID v4;
  CFTypeID v5;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType);
    result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionTextShadowID)
      {
        v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType);
        if (v5 == sFigCaptionTextShadowID)
        {
          result = CGColorEqualToColor(*(CGColorRef *)(v3 + 64), *(CGColorRef *)(a2 + 64));
          if (result)
          {
            result = FigGeometryDimensionEqualToDimension(*(_QWORD *)(v3 + 16), *(_QWORD *)(v3 + 24), *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
            if (result)
            {
              result = FigGeometryDimensionEqualToDimension(*(_QWORD *)(v3 + 32), *(_QWORD *)(v3 + 40), *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40));
              if (result)
                return FigGeometryDimensionEqualToDimension(*(_QWORD *)(v3 + 48), *(_QWORD *)(v3 + 56), *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56));
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFHashCode fcts_Hash(CFTypeRef *a1)
{
  CFTypeID v2;

  if (a1
    && (v2 = CFGetTypeID(a1),
        FigThreadRunOnce(&sRegisterFigCaptionTextShadowTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowType),
        v2 == sFigCaptionTextShadowID))
  {
    return CFHash(a1[8]);
  }
  else
  {
    return 0;
  }
}

CFStringRef fcts_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionTextShadow %p]"), a1);
}

CFStringRef fcts_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionTextShadow %p]"), a1);
}

uint64_t fctslist_Init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

void fctslist_Finalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 16);
  if (v1)
    CFRelease(v1);
}

uint64_t fctslist_Equal(uint64_t result, CFArrayRef *a2)
{
  uint64_t v3;
  CFTypeID v4;
  CFTypeID v5;
  const __CFArray *v6;
  CFIndex v7;
  const __CFArray *Count;
  CFIndex v9;
  const void *ValueAtIndex;
  const void *v11;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType);
    result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionTextShadowListID)
      {
        v5 = CFGetTypeID(a2);
        FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType);
        if (v5 != sFigCaptionTextShadowListID)
          return 0;
        v6 = *(const __CFArray **)(v3 + 16);
        v7 = v6 ? CFArrayGetCount(v6) : 0;
        Count = a2[2];
        if (Count)
          Count = (const __CFArray *)CFArrayGetCount(Count);
        if ((const __CFArray *)v7 == Count)
        {
          if (v7 < 1)
          {
            return 1;
          }
          else
          {
            v9 = 0;
            while (1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 16), v9);
              v11 = CFArrayGetValueAtIndex(a2[2], v9);
              result = FigCFEqual(ValueAtIndex, v11);
              if (!(_DWORD)result)
                break;
              if (v7 == ++v9)
                return 1;
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFHashCode fctslist_Hash(CFTypeRef *a1)
{
  CFTypeID v2;

  if (a1
    && (v2 = CFGetTypeID(a1),
        FigThreadRunOnce(&sRegisterFigCaptionTextShadowListTypeOnce, (void (*)(void))RegisterFigCaptionTextShadowListType), v2 == sFigCaptionTextShadowListID))
  {
    return CFHash(a1[2]);
  }
  else
  {
    return 0;
  }
}

CFStringRef fctslist_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionTextShadowList %p]"), a1);
}

CFStringRef fctslist_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionTextShadowList %p]"), a1);
}

uint64_t flipPointCloudDescriptionData(int8x8_t *a1, unint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;

  if (a2 <= 0xF)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v2 = bswap32(a1[1].u32[0]);
  v3 = bswap32(a1[1].u16[2]) >> 16;
  v4 = bswap32(a1[1].u16[3]) >> 16;
  *a1 = vrev32_s8(*a1);
  a1[1].i32[0] = v2;
  a1[1].i16[2] = v3;
  a1[1].i16[3] = v4;
  return 0;
}

uint64_t CMPointCloudFormatDescriptionCreateFromBigEndianPointCloudDescriptionData(CFAllocatorRef alloc, unsigned int *a2, unint64_t a3, CMMediaType a4, CMFormatDescriptionRef *a5)
{
  signed int v5;
  unint64_t v8;
  __CFDictionary *Mutable;
  int v10;
  unsigned int *v11;
  signed int v12;
  uint64_t v13;
  unsigned int v15;
  unsigned int v16;
  CFStringRef v18;
  CFStringRef v19;
  CFDataRef v20;
  CFDataRef v21;
  CFMutableDictionaryRef v22;
  __CFDictionary *v23;
  uint64_t v24;
  __CFDictionary *v25;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  UInt8 bytes[4];

  if (!a2)
  {
    v28 = 4294954584;
    return FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
  }
  if (a3 <= 0xF)
  {
    v28 = 4294954584;
    return FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
  }
  if (!a5)
  {
    v28 = 4294954584;
    return FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
  }
  v5 = bswap32(*a2);
  if (v5 < 0x10 || v5 > a3)
  {
    v28 = 4294954582;
    return FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
  }
  v29 = a2[1];
  v8 = v5 - 16;
  *(_DWORD *)bytes = 0;
  if (v8 >= 8)
  {
    Mutable = 0;
    v10 = 0;
    v11 = a2 + 4;
    while (1)
    {
      v12 = bswap32(*v11);
      v13 = v12;
      if (v12 < 8 || v8 < v12)
        goto LABEL_42;
      v15 = v11[1];
      v16 = bswap32(v15);
      if (v16 != 1718773093 && v16 != 1936419184)
      {
        if (v16 == 1852863603)
        {
          if (*v11 != 201326592)
            goto LABEL_42;
          v10 = bswap32(v11[2]);
        }
        else
        {
          if (!Mutable)
          {
            Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (!Mutable)
            {
              v24 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              v25 = 0;
              goto LABEL_35;
            }
          }
          *(_DWORD *)bytes = v15;
          v18 = CFStringCreateWithBytes(alloc, bytes, 4, 0, 0);
          if (!v18)
          {
            v24 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_47:
            v23 = 0;
            goto LABEL_34;
          }
          v19 = v18;
          v20 = CFDataCreate(alloc, (const UInt8 *)v11 + 8, v13 - 8);
          if (!v20)
          {
            v24 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            CFRelease(v19);
            goto LABEL_47;
          }
          v21 = v20;
          CFDictionarySetValue(Mutable, v19, v20);
          CFRelease(v21);
          CFRelease(v19);
        }
      }
      v11 = (unsigned int *)((char *)v11 + v13);
      v8 -= v13;
      if (v8 <= 7)
        goto LABEL_30;
    }
  }
  v10 = 0;
  Mutable = 0;
LABEL_30:
  if (v8)
  {
LABEL_42:
    v27 = 4294954582;
    goto LABEL_43;
  }
  v22 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v22)
  {
    v27 = 4294954583;
LABEL_43:
    v24 = FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
    v23 = 0;
    v25 = 0;
    if (Mutable)
      goto LABEL_34;
LABEL_35:
    v23 = v25;
    if ((_DWORD)v24)
      goto LABEL_39;
    goto LABEL_38;
  }
  v23 = v22;
  FigCFDictionarySetInt32(v22, CFSTR("NumberOfPointsPerSample"), v10);
  if (Mutable)
  {
    CFDictionarySetValue(v23, CFSTR("SampleDescriptionExtensionAtoms"), Mutable);
    v24 = 0;
LABEL_34:
    CFRelease(Mutable);
    v25 = v23;
    goto LABEL_35;
  }
  v25 = v23;
LABEL_38:
  v24 = CMFormatDescriptionCreate(alloc, a4, bswap32(v29), v23, a5);
LABEL_39:
  if (v25)
    CFRelease(v25);
  return v24;
}

uint64_t CMPointCloudFormatDescriptionCreateFromBigEndianPointCloudDescriptionBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, uint64_t a3, CMMediaType a4, CMFormatDescriptionRef *a5)
{
  OpaqueCMBlockBuffer *v7;
  size_t DataLength;
  uint64_t DataPointer;
  uint64_t v11;
  char *v13;
  CMBlockBufferRef blockBufferOut;

  v13 = 0;
  blockBufferOut = 0;
  if (theBuffer && a5)
  {
    v7 = theBuffer;
    DataLength = CMBlockBufferGetDataLength(theBuffer);
    if (!CMBlockBufferIsRangeContiguous(v7, 0, 0))
    {
      DataPointer = CMBlockBufferCreateContiguous(a1, v7, a1, 0, 0, 0, 0, &blockBufferOut);
      if ((_DWORD)DataPointer)
        goto LABEL_8;
      v7 = blockBufferOut;
    }
    DataPointer = CMBlockBufferGetDataPointer(v7, 0, 0, 0, &v13);
    if (!(_DWORD)DataPointer)
      DataPointer = CMPointCloudFormatDescriptionCreateFromBigEndianPointCloudDescriptionData(a1, (unsigned int *)v13, DataLength, a4, a5);
  }
  else
  {
    DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
LABEL_8:
  v11 = DataPointer;
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v11;
}

uint64_t CMPointCloudFormatDescriptionCopyAsBigEndianPointCloudDescriptionBlockBuffer(const __CFAllocator *a1, CFTypeRef cf, uint64_t a3, CMBlockBufferRef *a4)
{
  CFTypeID v7;
  CFDictionaryRef Extensions;
  const __CFDictionary *v9;
  uint64_t appended;
  OpaqueCMBlockBuffer *v11;
  size_t DataLength;
  size_t v13;
  const __CFDictionary *Value;
  uint64_t v15;
  size_t v16;
  int v17;
  size_t v18;
  uint64_t DataPointer;
  uint64_t v20;
  uint64_t v22;
  CMBlockBufferRef destinationBuffer;
  unint64_t sourceBytes;
  unint64_t v25;
  uint64_t v26;
  __int128 context;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  CMBlockBufferRef blockBufferOut;

  sourceBytes = 0;
  v25 = 0;
  destinationBuffer = 0;
  if (!cf)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!a4)
  {
    v22 = 4294954584;
    goto LABEL_40;
  }
  v7 = CFGetTypeID(cf);
  if (v7 != CMFormatDescriptionGetTypeID() || CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)cf) != 1885564004)
  {
    v22 = 4294954581;
LABEL_40:
    v20 = FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
    v11 = 0;
    goto LABEL_41;
  }
  Extensions = CMFormatDescriptionGetExtensions((CMFormatDescriptionRef)cf);
  v9 = Extensions;
  if (!Extensions)
  {
    v11 = 0;
    Value = 0;
    v13 = 0;
    v17 = 0;
    goto LABEL_21;
  }
  v26 = 0;
  v30 = 0;
  v28 = 0u;
  v29 = 0u;
  context = 0u;
  blockBufferOut = 0;
  if (FigCFDictionaryGetInt32IfPresent((uint64_t)Extensions, CFSTR("NumberOfPointsPerSample"), (char *)&v26 + 4))
  {
    appended = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
    if (!(_DWORD)appended)
    {
      appended = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)&context);
      if (!(_DWORD)appended)
      {
        appended = FigAtomWriterBeginAtom((uint64_t)&context, 0x6E707473u, 0);
        if (!(_DWORD)appended)
        {
          LODWORD(v26) = bswap32(HIDWORD(v26));
          appended = FigAtomWriterAppendData((uint64_t)&context, (uint64_t)&v26, 4);
          if (!(_DWORD)appended)
          {
            appended = FigAtomWriterEndAtom((uint64_t)&context);
            if (!(_DWORD)appended)
            {
              v11 = blockBufferOut;
              goto LABEL_13;
            }
          }
        }
      }
    }
  }
  else
  {
    appended = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
  }
  v20 = appended;
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  v11 = 0;
  Value = 0;
  if ((_DWORD)v20)
    goto LABEL_52;
LABEL_13:
  DataLength = CMBlockBufferGetDataLength(v11);
  if (DataLength > 0x7FFFFFEF)
  {
    v20 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
    goto LABEL_41;
  }
  v13 = DataLength;
  blockBufferOut = 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(v9, CFSTR("SampleDescriptionExtensionAtoms"));
  if (Value)
  {
    v30 = 0;
    v28 = 0u;
    v29 = 0u;
    context = 0u;
    v15 = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
    if (!(_DWORD)v15)
    {
      v15 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)&context);
      if (!(_DWORD)v15)
      {
        CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)PointCloudBridgeAppendExtensionsFunc, &context);
        Value = blockBufferOut;
        goto LABEL_18;
      }
    }
    v20 = v15;
    if (blockBufferOut)
      CFRelease(blockBufferOut);
LABEL_41:
    Value = 0;
    goto LABEL_52;
  }
LABEL_18:
  v16 = CMBlockBufferGetDataLength(Value);
  v17 = v16 + v13;
  if (v16 + v13 > 0x7FFFFFEF)
  {
    DataPointer = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_51:
    v20 = DataPointer;
LABEL_52:
    if (destinationBuffer)
      CFRelease(destinationBuffer);
    goto LABEL_32;
  }
  v9 = (const __CFDictionary *)v16;
LABEL_21:
  v18 = (v17 + 16);
  sourceBytes = _byteswap_uint64(__PAIR64__(v18, CMFormatDescriptionGetMediaSubType((CMFormatDescriptionRef)cf)));
  v25 = 0xFFFF000000000000;
  DataPointer = CMBlockBufferCreateWithMemoryBlock(a1, 0, v18, a1, 0, 0, v18, 1u, &destinationBuffer);
  if ((_DWORD)DataPointer)
    goto LABEL_51;
  DataPointer = CMBlockBufferReplaceDataBytes(&sourceBytes, destinationBuffer, 0, 0x10uLL);
  if ((_DWORD)DataPointer)
    goto LABEL_51;
  if (v11)
  {
    if (v13)
    {
      *(_QWORD *)&context = 0;
      DataPointer = CMBlockBufferGetDataPointer(destinationBuffer, 0x10uLL, 0, 0, (char **)&context);
      if ((_DWORD)DataPointer)
        goto LABEL_51;
      DataPointer = CMBlockBufferCopyDataBytes(v11, 0, v13, (void *)context);
      if ((_DWORD)DataPointer)
        goto LABEL_51;
    }
  }
  if (Value)
  {
    if (v9)
    {
      *(_QWORD *)&context = 0;
      DataPointer = CMBlockBufferGetDataPointer(destinationBuffer, v13 + 16, 0, 0, (char **)&context);
      if ((_DWORD)DataPointer)
        goto LABEL_51;
      DataPointer = CMBlockBufferCopyDataBytes(Value, 0, (size_t)v9, (void *)context);
      if ((_DWORD)DataPointer)
        goto LABEL_51;
    }
  }
  v20 = 0;
  *a4 = destinationBuffer;
  destinationBuffer = 0;
LABEL_32:
  if (v11)
    CFRelease(v11);
  if (Value)
    CFRelease(Value);
  return v20;
}

uint64_t PointCloudBridgeAppendExtensionsFunc(const __CFString *a1, const __CFData *a2, uint64_t a3)
{
  CFTypeID v6;
  CFTypeID v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  unsigned int v11;

  v11 = 0;
  if (a1
    && (v6 = CFGetTypeID(a1), v6 == CFStringGetTypeID())
    && a2
    && (v7 = CFGetTypeID(a2), v7 == CFDataGetTypeID())
    && FigCFStringGetOSTypeValue(a1, (int *)&v11))
  {
    if (!FigAtomWriterBeginAtom(a3, v11, 0))
    {
      BytePtr = CFDataGetBytePtr(a2);
      Length = CFDataGetLength(a2);
      FigAtomWriterAppendData(a3, (uint64_t)BytePtr, Length);
    }
  }
  else
  {
    FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
  }
  return FigAtomWriterEndAtom(a3);
}

uint64_t FigGetTimeOfDayClock()
{
  if (FigGetTimeOfDayClock_onceToken != -1)
    dispatch_once_f(&FigGetTimeOfDayClock_onceToken, &FigGetTimeOfDayClock_gClock, (dispatch_function_t)figTimeOfDayClock_creationOnceFunction);
  return FigGetTimeOfDayClock_gClock;
}

uint64_t figTimeOfDayClock_creationOnceFunction(uint64_t *a1)
{
  CMClockRef HostTimeClock;
  CMTime v4;

  HostTimeClock = CMClockGetHostTimeClock();
  CMTimeMake(&v4, 1, 10);
  return FigDerivedClockCreateWithGetTimeCallback(0, gFigTimeOfDayClockCallbacks, HostTimeClock, (__int128 *)&v4.value, 0, a1);
}

CFStringRef figTimeOfDayClock_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<FigTimeOfDayClock %p>"), a1);
}

void figTimeOfDayClock_Finalize()
{
  MEMORY[0x123] = 3;
}

BOOL figTimeOfDayClock_MightDrift(uint64_t a1, uint64_t a2)
{
  return a1 != a2;
}

double figTimeOfDayClock_GetRate()
{
  return 1.0;
}

uint64_t figTimeOfDayClock_GetAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  uint64_t UpTime;
  int64_t v6;
  CMTime v8;
  CMTime v9;
  timeval v10;

  v10.tv_sec = 0;
  *(_QWORD *)&v10.tv_usec = 0;
  gettimeofday(&v10, 0);
  UpTime = FigGetUpTime();
  CMTimeMake(&v9, (uint64_t)(((double)v10.tv_usec / 1000000.0 + (double)v10.tv_sec) * 100000.0), 100000);
  v6 = FigHostTimeToNanoseconds(UpTime);
  CMTimeMake(&v8, v6, 1000000000);
  *a2 = v9;
  *a3 = v8;
  return 0;
}

uint64_t FigFileGetFileInfo(const __CFURL *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t DarwinFileDesc;
  uint64_t v5;
  off_t st_size;
  uint64_t st_dev;
  __darwin_time_t tv_sec;
  unsigned int *v10;
  stat v11;

  v10 = 0;
  v3 = FigFileForkOpenMainByCFURL(a1, 0, (int **)&v10);
  if ((_DWORD)v3)
    return v3;
  DarwinFileDesc = FigFileGetDarwinFileDesc(v10);
  if ((_DWORD)DarwinFileDesc != -1)
  {
    memset(&v11, 0, sizeof(v11));
    if (!fstat(DarwinFileDesc, &v11))
    {
      v5 = 0;
      st_size = v11.st_size;
      *(_DWORD *)(a2 + 32) = v11.st_mtimespec.tv_nsec;
      st_dev = v11.st_dev;
      *(_QWORD *)a2 = st_size;
      *(_QWORD *)(a2 + 8) = st_dev;
      tv_sec = v11.st_mtimespec.tv_sec;
      *(_QWORD *)(a2 + 16) = v11.st_ino;
      *(_QWORD *)(a2 + 24) = tv_sec;
      goto LABEL_7;
    }
    DarwinFileDesc = *__error();
  }
  v5 = FigSignalErrorAt(DarwinFileDesc, 0, 0, 0, 0, 0, 0);
LABEL_7:
  FigFileForkClose((int *)v10);
  return v5;
}

BOOL FigFileInfoEqual(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16)
      && *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8)
      && *(_QWORD *)a1 == *(_QWORD *)a2
      && *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24)
      && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32);
}

uint64_t FigFileDeleteFile(const __CFURL *a1)
{
  uint64_t result;
  UInt8 buffer[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  result = FigFileDoesFileExist(a1);
  if ((_DWORD)result)
  {
    CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024);
    return unlink((const char *)buffer);
  }
  return result;
}

uint64_t FigFileDeleteDirectory(const __CFURL *a1)
{
  uint64_t result;
  UInt8 buffer[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  result = FigFileDoesFileExist(a1);
  if ((_DWORD)result)
  {
    CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024);
    return removefile((const char *)buffer, 0, 1u);
  }
  return result;
}

uint64_t FigFileReadURLAndCreateCFData(const __CFURL *a1, CFDataRef *a2)
{
  uint64_t LengthAtOffset;
  const __CFAllocator *v4;
  const __CFAllocator *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  CFDataRef v9;
  uint64_t v10;
  uint64_t v12;
  CFIndex size;
  int *v14;

  size = 0;
  v14 = 0;
  v12 = 0;
  LengthAtOffset = FigFileForkOpenMainByCFURL(a1, 0, &v14);
  if ((_DWORD)LengthAtOffset)
    goto LABEL_16;
  LengthAtOffset = FigFileForkGetLengthAtOffset(v14, 0, &size);
  if ((_DWORD)LengthAtOffset)
    goto LABEL_16;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (size >= 1)
  {
    v6 = CFAllocatorAllocate(v5, size, 0);
    if (v6)
    {
      v7 = v6;
      v8 = FigFileForkRead(v14, v6, size, 0, &v12);
      if ((_DWORD)v8)
      {
        v10 = v8;
LABEL_14:
        CFAllocatorDeallocate(v4, v7);
        goto LABEL_8;
      }
      v9 = CFDataCreateWithBytesNoCopy(v4, (const UInt8 *)v7, size, v4);
      if (v9)
      {
LABEL_7:
        v10 = 0;
        *a2 = v9;
        goto LABEL_8;
      }
      goto LABEL_12;
    }
    LengthAtOffset = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
LABEL_16:
    v10 = LengthAtOffset;
    goto LABEL_8;
  }
  v9 = CFDataCreate(v5, 0, 0);
  v7 = 0;
  if (v9)
    goto LABEL_7;
LABEL_12:
  v10 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v10 && v7)
    goto LABEL_14;
LABEL_8:
  if (v14)
    FigFileForkClose(v14);
  return v10;
}

uint64_t FigFileValidateFileNameIsWithinParentDirectory(CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  const __CFAllocator *v4;
  const __CFURL *v5;
  const __CFURL *v6;
  CFURLRef v7;
  CFURLRef v8;
  CFURLRef v9;
  CFURLRef v10;
  CFURLRef v11;
  CFURLRef v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!url)
  {
    v15 = 4294954516;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  if (!pathComponent)
  {
    v15 = 4294954516;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], url, pathComponent, isDirectory);
  if (!v5)
  {
    v15 = 4294955095;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  v6 = v5;
  v7 = CFURLCopyAbsoluteURL(v5);
  if (!v7)
  {
    v16 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
    CFRelease(v6);
    return v16;
  }
  v8 = v7;
  v9 = CFURLCopyAbsoluteURL(url);
  if (!v9)
  {
    v17 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
    CFRelease(v8);
    CFRelease(v6);
    return v17;
  }
  v10 = v9;
  v11 = CFURLCreateCopyDeletingLastPathComponent(v4, v8);
  v12 = v11;
  if (!v11)
  {
    v18 = 4294955095;
LABEL_20:
    v13 = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  if (CFEqual(v11, v10) != 1)
  {
    v18 = 4294955087;
    goto LABEL_20;
  }
  v13 = 0;
LABEL_9:
  CFRelease(v8);
  CFRelease(v10);
  CFRelease(v6);
  if (v12)
    CFRelease(v12);
  return v13;
}

uint64_t FigFileConvertURLToAbsoluteAndMarkAsDirectory(const void *a1, _QWORD *a2)
{
  uint64_t v4;
  const __CFURL *v5;
  const __CFURL *v6;
  const __CFString *v7;
  const __CFString *v8;
  CFURLRef v9;
  uint64_t v11;
  uint64_t v12;

  if (!a1 || !a2)
  {
    v11 = 4294955096;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  if (CFURLHasDirectoryPath((CFURLRef)a1))
  {
    v4 = 0;
    *a2 = CFRetain(a1);
    return v4;
  }
  v5 = CFURLCopyAbsoluteURL((CFURLRef)a1);
  if (!v5)
  {
    v11 = 4294955095;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  v6 = v5;
  v7 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  if (v7)
  {
    v8 = v7;
    v9 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, kCFURLPOSIXPathStyle, 1u);
    if (v9)
    {
      v4 = 0;
      *a2 = v9;
    }
    else
    {
      v4 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v6);
    CFRelease(v8);
    return v4;
  }
  v12 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
  CFRelease(v6);
  return v12;
}

uint64_t FigThreadLockAbortList()
{
  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  return FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
}

uint64_t FigThreadUnlockAbortList()
{
  return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
}

void FigThreadRemoveFromAbortListAndCleanup(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;

  v1 = gAbortActionList;
  if (gAbortActionList)
  {
    while (1)
    {
      while (1)
      {
        v3 = v1;
        v1 = *(_QWORD *)(v1 + 32);
        if (*(uint64_t (**)())(v3 + 16) == kSpecialAction_ThreadWasAbortedForTeardown
          && (*(_QWORD *)v3 == a1 || !*(_QWORD *)(v3 + 8) && !FigThreadIsValid(*(_opaque_pthread_t **)v3)))
        {
          break;
        }
        if (!v1)
          return;
      }
      v4 = gAbortActionList;
      if (gAbortActionList != v3)
        break;
      gAbortActionList = *(_QWORD *)(v3 + 32);
      if (!gAbortActionList)
      {
        v7 = &gAbortActionList;
LABEL_14:
        qword_1ECDA85D8 = (uint64_t)v7;
      }
LABEL_15:
      free((void *)v3);
      if (!v1)
        return;
    }
    do
    {
      v5 = v4;
      v4 = *(_QWORD *)(v4 + 32);
    }
    while (v4 != v3);
    v6 = *(_QWORD *)(v3 + 32);
    *(_QWORD *)(v5 + 32) = v6;
    v7 = (uint64_t *)(v5 + 32);
    if (v6)
      goto LABEL_15;
    goto LABEL_14;
  }
}

void FigThreadMakeDispatchQueueAbortable(NSObject *a1)
{
  void *v2;

  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  if (a1 == MEMORY[0x1E0C80D38] || dispatch_get_global_queue(0, 0) == a1)
  {
    FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  }
  else if (a1)
  {
    v2 = (void *)FigAtomicIncrement64(&gNextAbortableQueueID);
    dispatch_queue_set_specific(a1, &kFigThreadDispatchQueueAbortabilityKey, v2, (dispatch_function_t)removeDispatchQueueFromAbortListAndCleanup);
  }
}

uint64_t removeDispatchQueueFromAbortListAndCleanup(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;

  if (result)
  {
    v1 = result;
    FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
    result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
    if (!(_DWORD)result)
    {
      v2 = gAbortActionList;
      if (!gAbortActionList)
        return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
      while (1)
      {
        v3 = v2;
        v2 = *(_QWORD *)(v2 + 32);
        if (*(uint64_t (**)())(v3 + 16) != kSpecialAction_ThreadWasAbortedForTeardown
          || *(_QWORD *)(v3 + 8) != v1)
        {
          goto LABEL_15;
        }
        v4 = gAbortActionList;
        if (gAbortActionList != v3)
          break;
        gAbortActionList = v2;
        if (!v2)
        {
          v6 = &gAbortActionList;
LABEL_13:
          qword_1ECDA85D8 = (uint64_t)v6;
        }
LABEL_14:
        free((void *)v3);
LABEL_15:
        if (!v2)
          return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
      }
      do
      {
        v5 = v4;
        v4 = *(_QWORD *)(v4 + 32);
      }
      while (v4 != v3);
      *(_QWORD *)(v5 + 32) = v2;
      v6 = (uint64_t *)(v5 + 32);
      if (v2)
        goto LABEL_14;
      goto LABEL_13;
    }
  }
  return result;
}

void *FigThreadGetAbortableDispatchQueueID(NSObject *a1)
{
  if (a1)
    return dispatch_queue_get_specific(a1, &kFigThreadDispatchQueueAbortabilityKey);
  else
    return dispatch_get_specific(&kFigThreadDispatchQueueAbortabilityKey);
}

uint64_t FigThreadAbortForTeardown(uint64_t a1)
{
  uint64_t result;
  _QWORD *v3;
  int v4;
  uint64_t (*v5)();
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)();
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;

  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (!(_DWORD)result)
  {
    if ((gAbortingNow & 1) == 0)
    {
      gAbortingNow = 1;
      v3 = (_QWORD *)gAbortActionList;
      if (gAbortActionList)
      {
        v4 = 1;
        do
        {
          if (*v3 == a1)
          {
            v5 = (uint64_t (*)())v3[2];
            if (v5 == kSpecialAction_ThreadWasAbortedForTeardown)
              v4 = 0;
            if (v5)
              ((void (*)(_QWORD))v5)(v3[3]);
          }
          v3 = (_QWORD *)v3[4];
        }
        while (v3);
        if (!v4)
          goto LABEL_14;
      }
      v6 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040D3751E5BuLL);
      if (v6)
      {
        *v6 = a1;
        v6[1] = 0;
        v6[2] = kSpecialAction_ThreadWasAbortedForTeardown;
        v6[3] = 0;
        v6[4] = 0;
        *(_QWORD *)qword_1ECDA85D8 = v6;
        qword_1ECDA85D8 = (uint64_t)(v6 + 4);
LABEL_14:
        v7 = gAbortActionList;
        if (gAbortActionList)
        {
          while (1)
          {
            v8 = v7;
            v7 = *(_QWORD *)(v7 + 32);
            v9 = *(uint64_t (**)())(v8 + 16);
            if (v9 == kSpecialAction_ThreadWasAbortedForTeardown)
            {
              if (*(_QWORD *)(v8 + 8)
                || FigThreadIsValid(*(_opaque_pthread_t **)v8) && *(_QWORD *)(v8 + 16))
              {
                goto LABEL_24;
              }
LABEL_17:
              v10 = gAbortActionList;
              if (gAbortActionList != v8)
              {
                do
                {
                  v11 = v10;
                  v10 = *(_QWORD *)(v10 + 32);
                }
                while (v10 != v8);
                v12 = *(_QWORD *)(v8 + 32);
                *(_QWORD *)(v11 + 32) = v12;
                v13 = (uint64_t *)(v11 + 32);
                if (v12)
                  goto LABEL_29;
                goto LABEL_28;
              }
              gAbortActionList = *(_QWORD *)(v8 + 32);
              if (!gAbortActionList)
              {
                v13 = &gAbortActionList;
LABEL_28:
                qword_1ECDA85D8 = (uint64_t)v13;
              }
LABEL_29:
              free((void *)v8);
              if (!v7)
                break;
            }
            else
            {
              if (!v9)
                goto LABEL_17;
LABEL_24:
              if (!v7)
                break;
            }
          }
        }
        gAbortingNow = 0;
        return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
      }
      FigSignalErrorAt(4294954497, 0, 0, 0, 0, 0, 0);
    }
    return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
  }
  return result;
}

uint64_t FigThreadAbortQueue(NSObject *a1)
{
  uint64_t result;
  void *AbortableDispatchQueueID;
  _QWORD *v4;
  void *v5;
  void (*v6)(_QWORD);
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;

  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (!(_DWORD)result)
  {
    if ((gAbortingNow & 1) == 0)
    {
      AbortableDispatchQueueID = FigThreadGetAbortableDispatchQueueID(a1);
      if (AbortableDispatchQueueID)
      {
        gAbortingNow = 1;
        v4 = (_QWORD *)gAbortActionList;
        if (gAbortActionList)
        {
          v5 = AbortableDispatchQueueID;
          do
          {
            if ((void *)v4[1] == v5)
            {
              v6 = (void (*)(_QWORD))v4[2];
              if (v6)
                v6(v4[3]);
            }
            v4 = (_QWORD *)v4[4];
          }
          while (v4);
          v7 = (_QWORD *)gAbortActionList;
          if (gAbortActionList)
          {
            while (1)
            {
              v8 = (_QWORD *)v7[4];
              if (!v7[2])
                break;
LABEL_20:
              v7 = v8;
              if (!v8)
                goto LABEL_21;
            }
            v9 = gAbortActionList;
            if ((_QWORD *)gAbortActionList == v7)
            {
              gAbortActionList = v7[4];
              if (v8)
              {
LABEL_19:
                free(v7);
                goto LABEL_20;
              }
              v11 = &gAbortActionList;
            }
            else
            {
              do
              {
                v10 = v9;
                v9 = *(_QWORD *)(v9 + 32);
              }
              while ((_QWORD *)v9 != v7);
              *(_QWORD *)(v10 + 32) = v8;
              v11 = (uint64_t *)(v10 + 32);
              if (v8)
                goto LABEL_19;
            }
            qword_1ECDA85D8 = (uint64_t)v11;
            goto LABEL_19;
          }
        }
LABEL_21:
        gAbortingNow = 0;
      }
      else
      {
        FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
      }
    }
    return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
  }
  return result;
}

uint64_t FigThreadAbortQueueForTeardown(NSObject *a1)
{
  uint64_t result;
  void *AbortableDispatchQueueID;
  void *v4;
  _QWORD *v5;
  int v6;
  uint64_t (*v7)();
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;

  FigThreadRunOnce(&gAbortActionInitOnce, (void (*)(void))abortActionInitOnce);
  result = FigReentrantMutexLock((pthread_mutex_t *)gAbortActionLock);
  if (!(_DWORD)result)
  {
    if ((gAbortingNow & 1) == 0)
    {
      AbortableDispatchQueueID = FigThreadGetAbortableDispatchQueueID(a1);
      if (AbortableDispatchQueueID)
      {
        v4 = AbortableDispatchQueueID;
        gAbortingNow = 1;
        v5 = (_QWORD *)gAbortActionList;
        if (gAbortActionList)
        {
          v6 = 1;
          do
          {
            if ((void *)v5[1] == v4)
            {
              v7 = (uint64_t (*)())v5[2];
              if (v7 == kSpecialAction_ThreadWasAbortedForTeardown)
                v6 = 0;
              if (v7)
                ((void (*)(_QWORD))v7)(v5[3]);
            }
            v5 = (_QWORD *)v5[4];
          }
          while (v5);
          if (!v6)
            goto LABEL_15;
        }
        v8 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040D3751E5BuLL);
        if (v8)
        {
          *v8 = 0;
          v8[1] = v4;
          v8[2] = kSpecialAction_ThreadWasAbortedForTeardown;
          v8[3] = 0;
          v8[4] = 0;
          *(_QWORD *)qword_1ECDA85D8 = v8;
          qword_1ECDA85D8 = (uint64_t)(v8 + 4);
LABEL_15:
          v9 = (_QWORD *)gAbortActionList;
          if (gAbortActionList)
          {
            while (1)
            {
              v10 = (_QWORD *)v9[4];
              if (!v9[2])
                break;
LABEL_25:
              v9 = v10;
              if (!v10)
                goto LABEL_26;
            }
            v11 = gAbortActionList;
            if ((_QWORD *)gAbortActionList == v9)
            {
              gAbortActionList = v9[4];
              if (v10)
              {
LABEL_24:
                free(v9);
                goto LABEL_25;
              }
              v13 = &gAbortActionList;
            }
            else
            {
              do
              {
                v12 = v11;
                v11 = *(_QWORD *)(v11 + 32);
              }
              while ((_QWORD *)v11 != v9);
              *(_QWORD *)(v12 + 32) = v10;
              v13 = (uint64_t *)(v12 + 32);
              if (v10)
                goto LABEL_24;
            }
            qword_1ECDA85D8 = (uint64_t)v13;
            goto LABEL_24;
          }
LABEL_26:
          gAbortingNow = 0;
          return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
        }
        v14 = 4294954497;
      }
      else
      {
        v14 = 4294954503;
      }
      FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    }
    return FigReentrantMutexUnlock((pthread_mutex_t *)gAbortActionLock);
  }
  return result;
}

uint64_t FigThreadGetGlobalNetworkBufferingLowPriorityRunloop()
{
  FigThreadRunOnce(&sNetworkThreadLowPriorityInitOnce, (void (*)(void))networkThreadLowPriorityInitOnce);
  return sNetworkLowPriorityRunLoop;
}

_QWORD *networkThreadLowPriorityInitOnce()
{
  return networkThreadCommonInit(CFSTR("com.apple.coremedia.networkbufferinglowpriority"), (uint64_t)FigThreadGlobalNetworkBufferingLowPriorityRunloop, 0x19u, &sNetworkLowPriorityThread);
}

uint64_t FigThreadGetGlobalNetworkBufferingBackgroundThrottledRunloop()
{
  FigThreadRunOnce(&sNetworkThreadBackgroundThrottledInitOnce, (void (*)(void))networkThreadBackgroundThrottledInitOnce);
  return sNetworkBackgroundThrottledRunLoop;
}

_QWORD *networkThreadBackgroundThrottledInitOnce()
{
  return networkThreadCommonInit(CFSTR("com.apple.coremedia.networkbufferingbackgroundthrottled"), (uint64_t)FigThreadGlobalNetworkBufferingBackgroundThrottledRunloop, 0x10u, &sNetworkBackgroundThrottledThread);
}

uint64_t FigThreadGetGlobalNetworkBufferingQueue()
{
  FigThreadRunOnce(&sNetworkQueueInitOnce, (void (*)(void))networkQueueInitOnce);
  return sNetworkQueue;
}

dispatch_queue_t networkQueueInitOnce()
{
  dispatch_queue_t result;

  result = FigDispatchQueueCreateTargetingWorkloopWithPriority("com.apple.coremedia.networkbuffering", 0, 7u);
  sNetworkQueue = (uint64_t)result;
  return result;
}

uint64_t FigThreadGetGlobalNetworkBufferingLowPriorityQueue()
{
  FigThreadRunOnce(&sNetworkLowPriorityQueueInitOnce, (void (*)(void))networkLowPriorityQueueInitOnce);
  return sNetworkLowPriorityQueue;
}

dispatch_queue_t networkLowPriorityQueueInitOnce()
{
  dispatch_queue_t result;

  result = FigDispatchQueueCreateWithPriority("com.apple.coremedia.networkbufferinglowpriority", 0, 0x19u);
  sNetworkLowPriorityQueue = (uint64_t)result;
  return result;
}

_QWORD *networkThreadCommonInit(const void *a1, uint64_t a2, unsigned int a3, pthread_t *a4)
{
  _QWORD *result;
  uint64_t v9;
  __CFDictionary *Mutable;
  int v11;

  result = FigSemaphoreCreate(0, 1);
  if (result)
  {
    v9 = (uint64_t)result;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("com.apple.fig.ThreadCreateKey_Identifier"), a1);
    CFDictionarySetValue(Mutable, CFSTR("com.apple.fig.ThreadCreateKey_AdoptVoucher"), (const void *)*MEMORY[0x1E0C9AE40]);
    v11 = FigThreadCreate(a2, v9, a3, 0, Mutable, a4);
    if (Mutable)
      CFRelease(Mutable);
    if (!v11)
      FigSemaphoreWaitRelative(v9, -1);
    return (_QWORD *)FigSemaphoreDestroy(v9);
  }
  return result;
}

void FigThreadGlobalNetworkBufferingCommonSetupRunloop(uint64_t a1, CFRunLoopRef *a2, __CFRunLoopTimer **a3)
{
  __CFRunLoopTimer *v6;
  __CFRunLoopTimer *v7;

  *a2 = CFRunLoopGetCurrent();
  FigSemaphoreSignal(a1);
  v6 = CFRunLoopTimerCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 3.1536e13, 3.1536e13, 0, 0, (CFRunLoopTimerCallBack)dummyRunLoopTimer, 0);
  if (v6)
  {
    v7 = v6;
    CFRunLoopAddTimer(*a2, v6, (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
    if (a3)
      *a3 = v7;
    else
      CFRelease(v7);
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigThreadGlobalNetworkBufferingLowPriorityRunloop(uint64_t a1)
{
  FigThreadGlobalNetworkBufferingCommonSetupRunloop(a1, (CFRunLoopRef *)&sNetworkLowPriorityRunLoop, (__CFRunLoopTimer **)&sNetworkLowPriorityRunLoopTimer);
  CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E0C9B280], 1.79769313e308, 0);
  if (sNetworkLowPriorityRunLoopTimer)
  {
    CFRelease((CFTypeRef)sNetworkLowPriorityRunLoopTimer);
    sNetworkLowPriorityRunLoopTimer = 0;
  }
  return 0;
}

uint64_t FigThreadGlobalNetworkBufferingBackgroundThrottledRunloop(uint64_t a1)
{
  FigThreadGlobalNetworkBufferingCommonSetupRunloop(a1, (CFRunLoopRef *)&sNetworkBackgroundThrottledRunLoop, (__CFRunLoopTimer **)&sNetworkBackgroundThrottledRunLoopTimer);
  CFRunLoopRunInMode((CFRunLoopMode)*MEMORY[0x1E0C9B280], 1.79769313e308, 0);
  if (sNetworkBackgroundThrottledRunLoopTimer)
  {
    CFRelease((CFTypeRef)sNetworkBackgroundThrottledRunLoopTimer);
    sNetworkBackgroundThrottledRunLoopTimer = 0;
  }
  return 0;
}

uint64_t FigUInt32NearestPowerOfTwo(unsigned int a1)
{
  unsigned int v1;
  unsigned int v2;

  v1 = a1 | (a1 >> 1) | ((a1 | (a1 >> 1)) >> 2);
  v2 = v1 | (v1 >> 4) | ((v1 | (v1 >> 4)) >> 8);
  return ((v2 | HIWORD(v2)) + 1) >> ((a1 & (((v2 | HIWORD(v2)) + 1) >> 2)) == 0);
}

uint64_t FigFloat32ConvertToFloat16(float a1)
{
  int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned __int16 v4;
  __int16 v5;
  unsigned __int16 v6;

  v1 = HIWORD(LODWORD(a1)) & 0x8000;
  v2 = (LODWORD(a1) >> 23);
  v3 = ((((LODWORD(a1) & 0x7FFFFFu) >> 13) | (v2 << 10)) + 0x4000) | v1;
  if (v2 < 0x71)
    LOWORD(v3) = HIWORD(a1) & 0x8000;
  v4 = v1 | 0x7C00;
  if (v2 >= 0x8F)
    LOWORD(v3) = v4;
  v5 = LOWORD(a1) & 0x3FF;
  if ((LOWORD(a1) & 0x3FF) == 0)
    v5 = 512;
  v6 = v4 | v5;
  if ((LODWORD(a1) & 0x7FFFFF) == 0)
    v6 = v4;
  if (v2 != 255)
    return (unsigned __int16)v3;
  return v6;
}

float FigFloat16ConvertToFloat32(unsigned int a1)
{
  unsigned int v1;
  int v2;
  float result;
  float v4;

  v1 = (a1 >> 10) & 0x1F;
  v2 = a1 & 0x3FF;
  if (v1 == 31)
  {
    LODWORD(result) = v2 | 0x7F800000;
  }
  else if (v1)
  {
    if (v1 > 0xE)
      v4 = (float)(1 << (v1 - 15));
    else
      v4 = 1.0 / (double)(1 << (15 - v1));
    result = (float)((float)((float)v2 * 0.00097656) + 1.0) * v4;
  }
  else if ((a1 & 0x3FF) != 0)
  {
    result = (float)v2 * 0.000000059605;
  }
  else
  {
    result = 0.0;
  }
  if ((a1 & 0x8000u) != 0)
    return -result;
  return result;
}

uint64_t FigGzipCreate(_QWORD *a1)
{
  _DWORD *v2;
  uint64_t v4;

  if (a1)
  {
    v2 = malloc_type_calloc(1uLL, 0x78uLL, 0x10B00409B971CB9uLL);
    if (v2)
    {
      v2[29] = 1736075632;
      *((_QWORD *)v2 + 9) = 0;
      *((_QWORD *)v2 + 10) = 0;
      *((_QWORD *)v2 + 8) = 0;
      *a1 = v2;
      return 0;
    }
    v4 = 4294954905;
  }
  else
  {
    v4 = 4294954906;
  }
  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigGzipCreate_zlib(_QWORD *a1)
{
  _DWORD *v2;
  uint64_t v4;

  if (a1)
  {
    v2 = malloc_type_calloc(1uLL, 0x78uLL, 0x10B00409B971CB9uLL);
    if (v2)
    {
      v2[29] = 2053925218;
      *((_QWORD *)v2 + 9) = 0;
      *((_QWORD *)v2 + 10) = 0;
      *((_QWORD *)v2 + 8) = 0;
      *a1 = v2;
      return 0;
    }
    v4 = 4294954905;
  }
  else
  {
    v4 = 4294954906;
  }
  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigGzipDecompressMemory(z_streamp strm, Bytef *a2, uInt a3, _QWORD *a4, BOOL *a5, Bytef *a6, uInt a7, _QWORD *a8, BOOL *a9, _BYTE *a10)
{
  uLong total_out;
  uLong total_in;
  int next_in_high;
  unsigned int v17;
  int v18;
  BOOL v19;
  uint64_t result;
  uint64_t v21;

  if (!a4 || !a8 || !a5 || !a9 || !a10)
  {
    v21 = 4294954906;
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
  if (((uint64_t)strm[1].next_in & 0xFFFFFFFD) != 0)
  {
    v21 = 4294954902;
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
  *a10 = 0;
  if (a2)
  {
    strm->next_in = a2;
    strm->avail_in = a3;
    strm->total_in = 0;
  }
  if (a6)
  {
    total_out = 0;
    strm->next_out = a6;
    strm->avail_out = a7;
    strm->total_out = 0;
  }
  else
  {
    total_out = strm->total_out;
  }
  total_in = strm->total_in;
  if (LODWORD(strm[1].next_in))
    goto LABEL_19;
  next_in_high = HIDWORD(strm[1].next_in);
  if (next_in_high == 2053925218)
  {
    v17 = inflateInit_(strm, "1.2.12", 112);
    goto LABEL_17;
  }
  if (next_in_high == 1736075632)
  {
    v17 = inflateInit2_(strm, 47, "1.2.12", 112);
LABEL_17:
    if (v17 < 2)
      goto LABEL_18;
    if (v17 == -4)
      v21 = 4294954905;
    else
      v21 = 4294954904;
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
LABEL_18:
  LODWORD(strm[1].next_in) = 2;
LABEL_19:
  v18 = inflate(strm, 0);
  switch(v18)
  {
    case -4:
      return 4294954905;
    case 0:
      *a10 = 0;
      *a5 = strm->avail_in == 0;
      v19 = strm->avail_out == 0;
      goto LABEL_25;
    case 1:
      v19 = 0;
      *a10 = 1;
      *a5 = 0;
LABEL_25:
      result = 0;
      *a9 = v19;
      *a4 = strm->total_in - total_in;
      *a8 = strm->total_out - total_out;
      return result;
  }
  return 4294954904;
}

uint64_t FigGzipCompressMemory(z_streamp strm, Bytef *a2, uInt a3, _QWORD *a4, BOOL *a5, Bytef *a6, uInt a7, _QWORD *a8, BOOL *a9, char a10)
{
  unsigned int next_in;
  uLong total_out;
  uLong total_in;
  int next_in_high;
  unsigned int v18;
  BOOL v19;
  uint64_t result;
  uint64_t v21;

  if (a4 && a8 && a5 && a9)
  {
    next_in = strm[1].next_in;
    if (next_in < 2)
    {
      if (a2)
      {
        strm->next_in = a2;
        strm->avail_in = a3;
        strm->total_in = 0;
      }
      if (a6)
      {
        total_out = 0;
        strm->next_out = a6;
        strm->avail_out = a7;
        strm->total_out = 0;
      }
      else
      {
        total_out = strm->total_out;
      }
      total_in = strm->total_in;
      if (next_in)
      {
LABEL_18:
        v18 = deflate(strm, 0);
        if (v18 < 2)
        {
          if (a10)
          {
            if (strm->avail_out)
              v18 = deflate(strm, 4);
          }
          if (v18 != -4)
          {
            if (!v18)
            {
              *a5 = strm->avail_in == 0;
              v19 = strm->avail_out == 0;
              goto LABEL_30;
            }
            if (v18 == 1)
            {
              v19 = 0;
              *a5 = 0;
LABEL_30:
              result = 0;
              *a9 = v19;
              *a4 = strm->total_in - total_in;
              *a8 = strm->total_out - total_out;
              return result;
            }
            return 4294954903;
          }
          return 4294954905;
        }
LABEL_26:
        if (v18 != -4)
          return 4294954903;
        return 4294954905;
      }
      next_in_high = HIDWORD(strm[1].next_in);
      if (next_in_high == 2053925218)
      {
        v18 = deflateInit_(strm, -1, "1.2.12", 112);
      }
      else
      {
        if (next_in_high != 1736075632)
        {
LABEL_17:
          LODWORD(strm[1].next_in) = 1;
          goto LABEL_18;
        }
        v18 = deflateInit2_(strm, -1, 8, 31, 4, 0, "1.2.12", 112);
      }
      if (v18 >= 2)
        goto LABEL_26;
      goto LABEL_17;
    }
    v21 = 4294954902;
  }
  else
  {
    v21 = 4294954906;
  }
  return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
}

void FigGzipDispose(void *a1)
{
  if (a1)
  {
    FigGzipReset((uint64_t)a1);
    free(a1);
  }
}

uint64_t FigGzipReset(uint64_t strm)
{
  uint64_t v1;
  int v2;

  if (strm)
  {
    v1 = strm;
    v2 = *(_DWORD *)(strm + 112);
    if (v2 == 1)
    {
      strm = deflateEnd((z_streamp)strm);
    }
    else
    {
      if (v2 != 2)
        return strm;
      strm = inflateEnd((z_streamp)strm);
    }
    *(_DWORD *)(v1 + 112) = 0;
  }
  return strm;
}

CFStringRef FigFilePathCopyFormattingDesc(char *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;

  v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, CFSTR("[%s]"), a1 + 16);
}

CFStringRef FigFilePathCopyDebugDesc(char *a1)
{
  const __CFAllocator *v2;
  CFAllocatorRef v3;

  v2 = CFGetAllocator(a1);
  v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<FigFilePathRef %p [%p]>{path:%s}"), a1, v3, a1 + 16);
}

uint64_t convertPOSIXErrorToFigFileError(uint64_t result, char a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  int v5;

  if ((int)result <= 12)
  {
    if ((_DWORD)result == 1)
    {
LABEL_20:
      if ((a2 & 3) != 0)
        return 4294955092;
      else
        return 4294955093;
    }
    v2 = -17913;
    if ((_DWORD)result == 5)
      v3 = -17915;
    else
      v3 = result;
    v4 = (_DWORD)result == 2;
    goto LABEL_17;
  }
  if ((int)result > 44)
  {
    v2 = -17916;
    if ((_DWORD)result == 63)
      v5 = -17912;
    else
      v5 = result;
    if ((_DWORD)result == 62)
      v3 = -17914;
    else
      v3 = v5;
    v4 = (_DWORD)result == 45;
LABEL_17:
    if (v4)
      return v2;
    else
      return v3;
  }
  switch((int)result)
  {
    case 13:
      goto LABEL_20;
    case 14:
    case 22:
      result = 4294955096;
      break;
    case 20:
      result = 4294949385;
      break;
    default:
      return result;
  }
  return result;
}

BOOL FigFileDoesFileExist(const __CFURL *a1)
{
  stat v2;
  UInt8 buffer[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  memset(&v2, 0, sizeof(v2));
  if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    return stat((const char *)buffer, &v2) == 0;
  FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  return 0;
}

BOOL FigFileIsFileOnExternalStorageDevice(const __CFURL *a1)
{
  CFStringRef v1;
  const __CFString *v2;
  _BOOL8 v3;

  if (!a1)
    return 0;
  v1 = CFURLCopyFileSystemPath(a1, kCFURLPOSIXPathStyle);
  if (!v1)
    return 0;
  v2 = v1;
  if (FigFileIsFileOnExternalStorageDevice_fileOnExternalStorageDevice != -1)
    dispatch_once(&FigFileIsFileOnExternalStorageDevice_fileOnExternalStorageDevice, &__block_literal_global_15);
  v3 = 0;
  if (FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare
    && FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate)
  {
    if (CFStringHasPrefix(v2, (CFStringRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToCompare))
      v3 = 1;
    else
      v3 = CFStringHasPrefix(v2, (CFStringRef)FigFileIsFileOnExternalStorageDevice_sMultiUserPathToComparePrivate) != 0;
  }
  CFRelease(v2);
  return v3;
}

uint64_t FigFileForkOpenMainByCFURL(const __CFURL *a1, unsigned int a2, int **a3)
{
  int v6;
  unsigned int v7;
  int *v8;
  int *v9;
  int v10;
  int v11;
  const __CFURL *SecurityScopedFileURLForPersistentURL;
  const __CFURL *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  int *v19;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  UInt8 buffer[1024];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v6 = a2 & 3;
  bzero(buffer, 0x400uLL);
  v7 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigFileTrace[1], CFSTR("figfile_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v7, 0, gFigFileTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1ECDA8478, CFSTR("figfile_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1ECDA8470);
  if (!a1)
  {
    v22 = FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
    v9 = 0;
    goto LABEL_29;
  }
  v8 = (int *)malloc_type_malloc(4uLL, 0x100004052888210uLL);
  v9 = v8;
  if (!v8)
  {
    v21 = 4294955095;
LABEL_28:
    v22 = FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
LABEL_29:
    v15 = convertPOSIXErrorToFigFileError(v22, v6);
    goto LABEL_26;
  }
  *v8 = -1;
  if ((a2 & 0x20) != 0)
    v10 = 16778240;
  else
    v10 = 0x1000000;
  v11 = (32 * a2) & 0x200;
  if ((a2 & 0x200) != 0)
    v11 = 2560;
  v6 |= (a2 >> 2) & 0x20 | ((unsigned __int16)(a2 & 0x400) >> 8) | v10 | v11;
  if (!FigIsPersistentURL(a1))
  {
    if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    {
      v13 = 0;
      goto LABEL_14;
    }
    v21 = 4294955096;
    goto LABEL_28;
  }
  SecurityScopedFileURLForPersistentURL = (const __CFURL *)FigCreateSecurityScopedFileURLForPersistentURL(a1);
  if (!SecurityScopedFileURLForPersistentURL)
  {
    v21 = 4294955087;
    goto LABEL_28;
  }
  v13 = SecurityScopedFileURLForPersistentURL;
  CFURLStartAccessingSecurityScopedResource(SecurityScopedFileURLForPersistentURL);
  if (!CFURLGetFileSystemRepresentation(v13, 1u, buffer, 1024))
  {
    v14 = FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
    v15 = convertPOSIXErrorToFigFileError(v14, v6);
LABEL_25:
    MEMORY[0x193FFB3BC](v13);
    CFRelease(v13);
    goto LABEL_26;
  }
LABEL_14:
  v16 = open((const char *)buffer, v6, 420);
  *v9 = v16;
  if (v16 == -1)
  {
    v19 = __error();
    v18 = FigSignalErrorAt(*v19, 0, 0, 0, 0, 0, 0);
    if (!FigIsItOKToLogURLs())
      __strlcpy_chk();
  }
  else if ((a2 & 0x400) != 0 && (v17 = fcntl(v16, 3), fcntl(*v9, 4, v17 & 0xFFFFFFFB) == -1)
         || (a2 & 0x40) != 0 && fcntl(*v9, 48, 1) == -1
         || (a2 & 0x100) != 0 && fcntl(*v9, 68, 1) == -1)
  {
    v23 = __error();
    v18 = FigSignalErrorAt(*v23, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v18 = 0;
    *a3 = v9;
    v9 = 0;
  }
  v15 = convertPOSIXErrorToFigFileError(v18, v6);
  if (v13)
    goto LABEL_25;
LABEL_26:
  FigFileForkClose(v9);
  return v15;
}

uint64_t FigFileForkRead(int *a1, void *__buf, size_t __nbyte, off_t a4, uint64_t *a5)
{
  ssize_t v10;
  ssize_t v11;
  uint64_t v12;
  uint64_t v14;
  int *v15;

  if (gGMFigKTraceEnabled == 1)
    kdebug_trace();
  v10 = pread(*a1, __buf, __nbyte, a4);
  v11 = v10;
  v12 = v10 & ~(v10 >> 63);
  if (gGMFigKTraceEnabled == 1)
  {
    if (v10 < 0)
      __error();
    kdebug_trace();
    if (__nbyte != v11 && gGMFigKTraceEnabled == 1)
      kdebug_trace();
  }
  if (v11 == -1)
  {
    v15 = __error();
    v14 = FigSignalErrorAt(*v15, 0, 0, 0, 0, 0, 0);
    if (gGMFigKTraceEnabled == 1)
    {
      __error();
      kdebug_trace();
    }
  }
  else
  {
    v14 = 0;
  }
  if (a5)
    *a5 = v12;
  return v14;
}

uint64_t FigFileForkWrite(int *a1, void *__buf, size_t __nbyte, off_t a4, uint64_t *a5)
{
  ssize_t v10;
  ssize_t v11;
  uint64_t v12;
  uint64_t v14;
  int *v15;

  if (gGMFigKTraceEnabled == 1)
    kdebug_trace();
  v10 = pwrite(*a1, __buf, __nbyte, a4);
  v11 = v10;
  v12 = v10 & ~(v10 >> 63);
  if (gGMFigKTraceEnabled == 1)
  {
    if (v10 < 0)
      __error();
    kdebug_trace();
    if (__nbyte != v11 && gGMFigKTraceEnabled == 1)
      kdebug_trace();
  }
  if (v11 == -1)
  {
    v15 = __error();
    v14 = FigSignalErrorAt(*v15, 0, 0, 0, 0, 0, 0);
    if (gGMFigKTraceEnabled == 1)
    {
      __error();
      kdebug_trace();
    }
  }
  else
  {
    v14 = 0;
  }
  if (a5)
    *a5 = v12;
  return v14;
}

uint64_t FigFileForkReadWithIOPolicy(int *a1, int a2, void *a3, size_t a4, off_t a5, uint64_t *a6)
{
  _BOOL4 IsDifferentFromCurrentIOPolicy;
  uint64_t v12;
  int v14;

  v14 = 0;
  IsDifferentFromCurrentIOPolicy = FigFileSetIOPolicyIfItIsDifferentFromCurrentIOPolicy("FigFileR", a2, &v14);
  v12 = FigFileForkRead(a1, a3, a4, a5, a6);
  if (IsDifferentFromCurrentIOPolicy)
    FigFileSetIOPolicy("FigFileR", v14);
  return v12;
}

BOOL FigFileSetIOPolicyIfItIsDifferentFromCurrentIOPolicy(const char *a1, int a2, int *a3)
{
  int v4;
  int v6;
  const char *v7;
  _BOOL8 result;
  int *v9;
  char __dst[8];

  if (a2 < 0)
  {
    result = 0;
    v4 = 0;
  }
  else
  {
    v4 = a2;
    v6 = getiopolicy_np(0, 1);
    if (gGMFigKTraceEnabled == 1)
    {
      strncpy(__dst, a1, 8uLL);
      if ((v6 + 1) > 6)
        v7 = "UNKNOWN";
      else
        v7 = off_1E28DBFD0[v6 + 1];
      strncpy(__dst, v7, 8uLL);
      kdebug_trace();
    }
    if (v6 == -1)
    {
      v9 = __error();
      FigSignalErrorAt(*v9, 0, 0, 0, 0, 0, 0);
      result = 0;
      v4 = -1;
    }
    else if (v6 == v4)
    {
      result = 0;
    }
    else
    {
      result = FigFileSetIOPolicy(a1, v4) != -1;
      v4 = v6;
    }
  }
  *a3 = v4;
  return result;
}

uint64_t FigFileSetIOPolicy(const char *a1, int a2)
{
  uint64_t v4;
  const char *v5;
  int *v6;
  char __dst[8];

  v4 = setiopolicy_np(0, 1, a2);
  if (gGMFigKTraceEnabled == 1)
  {
    strncpy(__dst, a1, 8uLL);
    if ((a2 + 1) > 6)
      v5 = "UNKNOWN";
    else
      v5 = off_1E28DBFD0[a2 + 1];
    strncpy(__dst, v5, 8uLL);
    kdebug_trace();
  }
  if ((_DWORD)v4 == -1)
  {
    v6 = __error();
    FigSignalErrorAt(*v6, 0, 0, 0, 0, 0, 0);
  }
  return v4;
}

uint64_t FigFileForkWriteWithIOPolicy(int *a1, int a2, void *a3, size_t a4, off_t a5, uint64_t *a6)
{
  _BOOL4 IsDifferentFromCurrentIOPolicy;
  uint64_t v12;
  int v14;

  v14 = 0;
  IsDifferentFromCurrentIOPolicy = FigFileSetIOPolicyIfItIsDifferentFromCurrentIOPolicy("FigFileW", a2, &v14);
  v12 = FigFileForkWrite(a1, a3, a4, a5, a6);
  if (IsDifferentFromCurrentIOPolicy)
    FigFileSetIOPolicy("FigFileW", v14);
  return v12;
}

uint64_t FigFileForkWriteIOVecArray(int *a1, int a2, uint64_t a3, int a4, off_t a5, _QWORD *a6)
{
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  ssize_t v20;
  ssize_t v21;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  _BOOL4 IsDifferentFromCurrentIOPolicy;
  uint64_t v28;
  int v29;
  int v30;

  v30 = 0;
  IsDifferentFromCurrentIOPolicy = FigFileSetIOPolicyIfItIsDifferentFromCurrentIOPolicy("FigFileV", a2, &v30);
  if (a4 >= 1)
  {
    v10 = 0;
    v11 = 0;
    v28 = a3 + 8;
    v29 = a4;
    while (1)
    {
      v12 = a4 - v11;
      if (a4 - v11 >= 1024)
        v13 = 1024;
      else
        v13 = v12;
      v14 = v11;
      if (v12 < 1)
      {
        v15 = 0;
      }
      else
      {
        v15 = 0;
        v16 = (uint64_t *)(v28 + 16 * v11);
        v17 = v13;
        do
        {
          v18 = *v16;
          v16 += 2;
          v15 += v18;
          --v17;
        }
        while (v17);
      }
      if (gGMFigKTraceEnabled == 1)
        kdebug_trace();
      v19 = a3;
      v20 = pwritev(*a1, (const iovec *)(a3 + 16 * v11), v13, a5);
      v21 = v20;
      v22 = v20 & ~(v20 >> 63);
      if (gGMFigKTraceEnabled == 1)
      {
        if (v20 < 0)
          __error();
        kdebug_trace();
        if (v15 != v21 && gGMFigKTraceEnabled == 1)
          kdebug_trace();
      }
      if (v21 == -1)
      {
        v23 = __error();
        v24 = FigSignalErrorAt(*v23, 0, 0, 0, 0, 0, 0);
        if (gGMFigKTraceEnabled == 1)
        {
          __error();
          kdebug_trace();
        }
        if ((_DWORD)v24)
          goto LABEL_30;
        a3 = v19;
        v22 = 0;
      }
      else
      {
        a3 = v19;
      }
      a4 = v29;
      v11 += v13;
      a5 += v22;
      v10 += v22;
      if ((int)v13 + v14 >= v29)
        goto LABEL_28;
    }
  }
  v10 = 0;
LABEL_28:
  v24 = 0;
  if (a6)
    *a6 = v10;
LABEL_30:
  if (IsDifferentFromCurrentIOPolicy)
    FigFileSetIOPolicy("FigFileV", v30);
  return v24;
}

uint64_t FigFileForkPreallocateStorageSpace(int *a1, uint64_t a2, char a3, _QWORD *a4)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  _BYTE *v12;
  int v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  _BYTE *v19;
  uint64_t result;
  int *v21;
  int v22;
  os_log_type_t type;
  int v24;
  _DWORD v25[2];
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  const char *v30;
  __int16 v31;
  int *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  _BYTE v37[128];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v25[0] = a3 & 2;
  v25[1] = 3;
  v26 = 0;
  v27 = a2;
  v28 = 0;
  if (dword_1ECDA8478)
  {
    v24 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8470, 1, &v24, &type);
    v8 = v24;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v10 = v8;
    else
      v10 = v8 & 0xFFFFFFFE;
    if (v10)
    {
      v11 = *a1;
      v29 = 136315906;
      v30 = "FigFileForkPreallocateStorageSpace";
      v31 = 2048;
      v32 = a1;
      v33 = 1024;
      v34 = v11;
      v35 = 2048;
      v36 = a2;
      v22 = 38;
      v12 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v8) = v24;
    }
    else
    {
      v12 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8470, 1u, 1, v12, v12 != v37, v8, 0, v9);
  }
  v13 = fcntl(*a1, 42, v25, v22);
  if (dword_1ECDA8478)
  {
    v24 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8470, 1, &v24, &type);
    v15 = v24;
    if (os_log_type_enabled(v14, type))
      v17 = v15;
    else
      v17 = v15 & 0xFFFFFFFE;
    if (v17)
    {
      v18 = *a1;
      v29 = 136315906;
      v30 = "FigFileForkPreallocateStorageSpace";
      v31 = 2048;
      v32 = a1;
      v33 = 1024;
      v34 = v18;
      v35 = 2048;
      v36 = v28;
      v19 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v15) = v24;
    }
    else
    {
      v19 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8470, 1u, 1, v19, v19 != v37, v15, 0, v16);
  }
  if (v13 == -1)
  {
    v21 = __error();
    return FigSignalErrorAt(*v21, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = 0;
    if (a4)
      *a4 = v28;
  }
  return result;
}

uint64_t FigFileForkGetAllocatedStorageSpaceLength(int *a1, _QWORD *a2)
{
  uint64_t result;
  int *v4;
  stat v5;

  memset(&v5, 0, sizeof(v5));
  if (!a2)
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  if (fstat(*a1, &v5) == -1)
  {
    v4 = __error();
    return FigSignalErrorAt(*v4, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = 0;
    *a2 = v5.st_blocks << 9;
  }
  return result;
}

uint64_t FigFileForkGetLengthAtOffset(int *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  int *v6;
  stat v7;

  memset(&v7, 0, sizeof(v7));
  if (!a3)
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  if (fstat(*a1, &v7) == -1)
  {
    v6 = __error();
    return FigSignalErrorAt(*v6, 0, 0, 0, 0, 0, 0);
  }
  else if (a2 < 0 || v7.st_size <= a2)
  {
    result = 0;
    *a3 = 0;
  }
  else
  {
    result = 0;
    *a3 = v7.st_size - a2;
  }
  return result;
}

uint64_t FigFileForkTruncate(int *a1, off_t a2)
{
  int *v3;

  if (ftruncate(*a1, a2) != -1)
    return 0;
  v3 = __error();
  return FigSignalErrorAt(*v3, 0, 0, 0, 0, 0, 0);
}

uint64_t FigFileForkSynchronize(int *a1, char a2)
{
  NSObject *v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  _BYTE *v8;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  _BYTE *v14;
  int v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  NSObject *v20;
  unsigned int v21;
  int v22;
  _BYTE *v23;
  int *v25;
  int *v26;
  int v27;
  os_log_type_t type;
  int v29;
  int v30;
  const char *v31;
  __int16 v32;
  int *v33;
  __int16 v34;
  int v35;
  _BYTE v36[128];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if ((a2 & 1) != 0)
  {
    if (dword_1ECDA8478)
    {
      v29 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8470, 1, &v29, &type);
      v10 = v29;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v12 = v10;
      else
        v12 = v10 & 0xFFFFFFFE;
      if (v12)
      {
        v13 = *a1;
        v30 = 136315650;
        v31 = "FigFileForkSynchronize";
        v32 = 2048;
        v33 = a1;
        v34 = 1024;
        v35 = v13;
        v27 = 28;
        v26 = &v30;
        v14 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v10) = v29;
      }
      else
      {
        v14 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8470, 1u, 1, v14, v14 != v36, v10, 0, v11);
    }
    v15 = fcntl(*a1, 51, v26, v27);
    if (dword_1ECDA8478)
    {
      v29 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8470, 1, &v29, &type);
      v17 = v29;
      if (os_log_type_enabled(v20, type))
        v21 = v17;
      else
        v21 = v17 & 0xFFFFFFFE;
      if (v21)
        goto LABEL_29;
      goto LABEL_30;
    }
  }
  else
  {
    if (dword_1ECDA8478)
    {
      v29 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v3 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8470, 1, &v29, &type);
      v4 = v29;
      if (os_log_type_enabled(v3, type))
        v6 = v4;
      else
        v6 = v4 & 0xFFFFFFFE;
      if (v6)
      {
        v7 = *a1;
        v30 = 136315650;
        v31 = "FigFileForkSynchronize";
        v32 = 2048;
        v33 = a1;
        v34 = 1024;
        v35 = v7;
        v8 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v4) = v29;
      }
      else
      {
        v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8470, 1u, 1, v8, v8 != v36, v4, 0, v5);
    }
    v15 = fsync(*a1);
    if (dword_1ECDA8478)
    {
      v29 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8470, 1, &v29, &type);
      v17 = v29;
      if (os_log_type_enabled(v16, type))
        v19 = v17;
      else
        v19 = v17 & 0xFFFFFFFE;
      if (v19)
      {
LABEL_29:
        v22 = *a1;
        v30 = 136315650;
        v31 = "FigFileForkSynchronize";
        v32 = 2048;
        v33 = a1;
        v34 = 1024;
        v35 = v22;
        v23 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v17) = v29;
LABEL_31:
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8470, 1u, 1, v23, v23 != v36, v17, 0, v18);
        goto LABEL_32;
      }
LABEL_30:
      v23 = 0;
      goto LABEL_31;
    }
  }
LABEL_32:
  if (v15 != -1)
    return 0;
  v25 = __error();
  return FigSignalErrorAt(*v25, 0, 0, 0, 0, 0, 0);
}

uint64_t FigFileCreateTempFileAtURL(const __CFURL *a1, __CFString *a2, CFURLRef *a3, _QWORD *a4)
{
  const __CFAllocator **v8;
  uint64_t Path;
  const __CFAllocator *v10;
  UInt8 *BytesFromCFString;
  int v12;
  uint64_t v13;
  size_t v14;
  CFURLRef v15;
  uint64_t v16;
  uint64_t v18;
  int *v19;
  void *ptr;
  char __str[1024];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  ptr = 0;
  bzero(__str, 0x400uLL);
  v19 = 0;
  v8 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
  if (!a1)
    goto LABEL_16;
  if (!a2)
  {
    v18 = 4294955096;
    goto LABEL_21;
  }
  if (!a3 || !a4)
  {
LABEL_16:
    Path = FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }
  Path = FigFileGetPath(a1, (UInt8 **)&ptr);
  if ((_DWORD)Path)
  {
LABEL_17:
    v16 = Path;
    a2 = 0;
    goto LABEL_11;
  }
  v10 = *v8;
  BytesFromCFString = FigCreateBytesFromCFString(*v8, a2, 0x8000100u, 1, 0);
  a2 = (__CFString *)BytesFromCFString;
  if (!BytesFromCFString)
  {
LABEL_18:
    v18 = 4294955095;
LABEL_21:
    v13 = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  snprintf(__str, 0x400uLL, "%s/%s.XXXXXX", (const char *)ptr, (const char *)BytesFromCFString);
  v12 = mkstemp(__str);
  if (v12 == -1)
  {
    v18 = 4294955091;
    goto LABEL_21;
  }
  v13 = FigFileWrapDarwinFileDesc(v12, &v19);
  if (!(_DWORD)v13)
  {
    v14 = strlen(__str);
    v15 = CFURLCreateFromFileSystemRepresentation(v10, (const UInt8 *)__str, v14, 0);
    if (v15)
    {
      v16 = 0;
      *a3 = v15;
      *a4 = v19;
      v19 = 0;
      goto LABEL_11;
    }
    goto LABEL_18;
  }
LABEL_22:
  v16 = v13;
LABEL_11:
  if (ptr)
    CFAllocatorDeallocate(*v8, ptr);
  if (a2)
    CFAllocatorDeallocate(*v8, a2);
  FigFileForkClose(v19);
  return v16;
}

uint64_t FigFileGetPath(const __CFURL *a1, UInt8 **a2)
{
  const __CFURL *v3;
  const __CFURL *v4;
  const __CFString *v5;
  const __CFString *v6;
  UInt8 *BytesFromCFString;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;

  if (!a1 || !a2)
  {
    v10 = 4294955096;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v3 = CFURLCopyAbsoluteURL(a1);
  if (!v3)
  {
    v10 = 4294955095;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v4 = v3;
  v5 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  if (v5)
  {
    v6 = v5;
    BytesFromCFString = FigCreateBytesFromCFString((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v5, 0x8000100u, 1, 0);
    if (BytesFromCFString)
    {
      v8 = 0;
      *a2 = BytesFromCFString;
    }
    else
    {
      v8 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v4);
    CFRelease(v6);
    return v8;
  }
  else
  {
    v11 = FigSignalErrorAt(4294955095, 0, 0, 0, 0, 0, 0);
    CFRelease(v4);
    return v11;
  }
}

uint64_t FigFileCreateTempDirectory(const char *a1, CFURLRef *a2)
{
  const char *CStringPtrMaybeUsingPreallocatedBuffer;
  const char *v5;
  char *v6;
  const UInt8 *v7;
  size_t v8;
  CFURLRef v9;
  CFURLRef v10;
  uint64_t result;
  uint64_t v12;
  char v13[1024];
  char v14[1024];
  char __str[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  bzero(v14, 0x400uLL);
  if (!a1 || !a2)
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  CStringPtrMaybeUsingPreallocatedBuffer = FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer(a1, v13, 1024, 0x8000100u);
  confstr(65537, v14, 0x400uLL);
  v5 = "";
  if (CStringPtrMaybeUsingPreallocatedBuffer)
    v5 = CStringPtrMaybeUsingPreallocatedBuffer;
  snprintf(__str, 0x400uLL, "%s/%s.XXXXXX", v14, v5);
  v6 = mkdtemp(__str);
  if (!v6)
  {
    v12 = *__error();
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v7 = (const UInt8 *)v6;
  v8 = strlen(v6);
  v9 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, v8, 1u);
  if (!v9)
  {
    v12 = 4294955091;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v10 = v9;
  result = 0;
  *a2 = v10;
  return result;
}

uint64_t FigFileRename(const __CFURL *a1, const __CFURL *a2)
{
  uint64_t Path;
  std::error_code *v4;
  int v5;
  uint64_t v6;
  CFAllocatorRef *v7;
  uint64_t v9;
  void *v10;
  void *ptr;

  v10 = 0;
  ptr = 0;
  if (a1 && a2)
  {
    Path = FigFileGetPath(a1, (UInt8 **)&ptr);
    if ((_DWORD)Path)
      goto LABEL_15;
    Path = FigFileGetPath(a2, (UInt8 **)&v10);
    if ((_DWORD)Path)
      goto LABEL_15;
    rename((const std::__fs::filesystem::path *)ptr, (const std::__fs::filesystem::path *)v10, v4);
    if (!v5)
    {
      v6 = 0;
      goto LABEL_7;
    }
    v9 = *__error();
  }
  else
  {
    v9 = 4294955096;
  }
  Path = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
LABEL_15:
  v6 = Path;
LABEL_7:
  v7 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (ptr)
    CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ptr);
  if (v10)
    CFAllocatorDeallocate(*v7, v10);
  return v6;
}

uint64_t FigFileLock(int *a1, char a2)
{
  uint64_t result;

  if (!a1)
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  result = flock(*a1, a2 & 7);
  if ((_DWORD)result)
  {
    if (*__error() == 35)
      return 4294955090;
    else
      return *__error();
  }
  return result;
}

uint64_t FigFileUnlock(int *a1)
{
  uint64_t result;

  if (!a1)
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  result = flock(*a1, 8);
  if ((_DWORD)result)
    return *__error();
  return result;
}

uint64_t FigFileDeleteRecursive(const __CFURL *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *path;

  path = 0;
  if (a1)
  {
    if (!FigFileDoesFileExist(a1))
      return 0;
    v2 = FigFileGetPath(a1, (UInt8 **)&path);
    if (!(_DWORD)v2)
    {
      v3 = removefile(path, 0, 1u);
      if (!(_DWORD)v3)
      {
        v4 = 0;
        goto LABEL_6;
      }
      v2 = FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    }
    v4 = v2;
LABEL_6:
    if (path)
      CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], path);
    return v4;
  }
  return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
}

uint64_t FigDirectoryEnableDirStatsTracking(const __CFURL *a1)
{
  int v1;
  uint64_t result;
  int *v3;
  uint64_t v4;
  UInt8 buffer[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  if (!CFURLGetFileSystemRepresentation(a1, 0, buffer, 1024))
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  v1 = fsctl((const char *)buffer, 0x80084A02uLL, &v4, 0);
  result = 0;
  if (v1 < 0)
  {
    v3 = __error();
    return convertPOSIXErrorToFigFileError(*v3, 0);
  }
  return result;
}

uint64_t FigFileMarkPurgeable(const __CFURL *a1, int a2)
{
  uint64_t v3;
  int v4;
  uint64_t result;
  int *v6;
  uint64_t v7;
  UInt8 buffer[1024];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!CFURLGetFileSystemRepresentation(a1, 0, buffer, 1024))
    return FigSignalErrorAt(4294955096, 0, 0, 0, 0, 0, 0);
  v3 = 66568;
  if (!a2)
    v3 = 0;
  v7 = v3;
  v4 = fsctl((const char *)buffer, 0xC0084A44uLL, &v7, 0);
  result = 0;
  if (v4 < 0)
  {
    v6 = __error();
    return convertPOSIXErrorToFigFileError(*v6, 0);
  }
  return result;
}

uint64_t FigDirectoryIsDirStatsTrackingEnabled(const __CFURL *a1)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  UInt8 buffer[1024];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = 0u;
  v5 = 0u;
  v4 = 1;
  if (CFURLGetFileSystemRepresentation(a1, 0, buffer, 1024))
  {
    if ((fsctl((const char *)buffer, 0xC0284A20uLL, &v4, 0) & 0x80000000) == 0)
      return 1;
    if (*__error() == 45)
      return 2;
    v2 = __error();
    v3 = convertPOSIXErrorToFigFileError(*v2, 0);
  }
  else
  {
    v3 = 4294955096;
  }
  FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  return 0;
}

OSStatus CMMetadataCreateIdentifierForKeyAndKeySpace(CFAllocatorRef allocator, CFTypeRef key, CFStringRef keySpace, CFStringRef *identifierOut)
{
  CFIndex Length;
  const __CFString *v9;
  uint64_t v10;
  CFTypeID v11;
  _BOOL4 HasOSTypeValues;
  CFTypeID TypeID;
  uint64_t v14;
  OSStatus v15;
  CFStringRef v16;
  const __CFString *v17;
  UInt8 *v18;
  const __CFString *v19;
  const __CFString *v20;
  UInt8 buffer[4];
  unint64_t valuePtr;
  unsigned int v24;
  CFIndex usedBufLen;
  CFRange v26;
  CFRange v27;

  if (!identifierOut)
  {
    v10 = 4294950995;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  *identifierOut = 0;
  if (!keySpace)
    goto LABEL_58;
  if (CFStringCompare(keySpace, CFSTR("anon"), 0) == kCFCompareEqualTo)
  {
    if (!key)
    {
      v15 = 0;
      *identifierOut = (CFStringRef)CFRetain(CFSTR("anon"));
      return v15;
    }
LABEL_58:
    v10 = 4294950995;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  if (!key)
  {
    v10 = 4294950994;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  if (CFStringCompare(keySpace, CFSTR("org.id3"), 0) == kCFCompareEqualTo
    || CFStringCompare(keySpace, CFSTR("id3 "), 0) == kCFCompareEqualTo)
  {
    v9 = CFSTR("id3");
    goto LABEL_15;
  }
  if (CFStringCompare(keySpace, CFSTR("icy "), 0) == kCFCompareEqualTo)
  {
    v9 = CFSTR("icy");
    goto LABEL_15;
  }
  if (CFStringCompare(keySpace, CFSTR("org.avchd-info"), 0) == kCFCompareEqualTo)
  {
    v9 = CFSTR("avch");
    goto LABEL_15;
  }
  if (CFStringCompare(keySpace, CFSTR("comn"), 0) == kCFCompareEqualTo)
  {
    v9 = CFSTR("common");
    goto LABEL_15;
  }
  Length = CFStringGetLength(keySpace);
  if (Length)
  {
    if (Length < 5)
    {
      v9 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], keySpace, 0, CFSTR("/"), 0);
      if (v9)
      {
LABEL_15:
        usedBufLen = 0;
        v24 = 0;
        valuePtr = 0;
        v11 = CFGetTypeID(key);
        HasOSTypeValues = keyNamespaceHasOSTypeValues(v9);
        TypeID = CFStringGetTypeID();
        if (HasOSTypeValues)
        {
          if (TypeID == v11)
          {
            if (CFStringGetLength((CFStringRef)key) == 4)
            {
              v26.location = 0;
              v26.length = 4;
              CFStringGetBytes((CFStringRef)key, v26, 0, 0, 0, buffer, 4, &usedBufLen);
              if (usedBufLen != 4)
              {
                v14 = 4294950994;
LABEL_65:
                v15 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
                v17 = 0;
                goto LABEL_66;
              }
              goto LABEL_37;
            }
            goto LABEL_64;
          }
          if (CFNumberGetTypeID() == v11)
          {
            CFNumberGetValue((CFNumberRef)key, kCFNumberSInt64Type, &valuePtr);
            CFNumberGetValue((CFNumberRef)key, kCFNumberSInt32Type, &v24);
            if (HIDWORD(valuePtr) && valuePtr != v24)
            {
              v14 = 4294950991;
              goto LABEL_65;
            }
            v24 = bswap32(v24);
            if (keyNamespaceHasAtSymbolOSTypeValues(v9) && v24 == 64)
              LOBYTE(v24) = -87;
            v18 = (UInt8 *)&v24;
            goto LABEL_41;
          }
          if (CFDataGetTypeID() == v11)
          {
            if (CFDataGetLength((CFDataRef)key) == 4)
            {
              v27.location = 0;
              v27.length = 4;
              CFDataGetBytes((CFDataRef)key, v27, buffer);
LABEL_37:
              if (keyNamespaceHasAtSymbolOSTypeValues(v9) && buffer[0] == 64)
                buffer[0] = -87;
              v18 = buffer;
LABEL_41:
              v19 = CFStringCreateWithBytes(allocator, v18, 4, 0, 0);
              goto LABEL_42;
            }
LABEL_64:
            v14 = 4294950993;
            goto LABEL_65;
          }
        }
        else
        {
          if (TypeID == v11)
          {
            if (CFStringGetLength((CFStringRef)key) > 0)
            {
              v16 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFStringRef)key, 0, CFSTR("/"), 0);
              v17 = 0;
              goto LABEL_44;
            }
            goto LABEL_64;
          }
          if (CFDataGetTypeID() == v11)
          {
            v19 = CFStringCreateFromExternalRepresentation(allocator, (CFDataRef)key, 0);
LABEL_42:
            v17 = v19;
            if (!v19)
            {
              v15 = FigSignalErrorAt(4294950994, 0, 0, 0, 0, 0, 0);
LABEL_66:
              v16 = 0;
              goto LABEL_47;
            }
            v16 = CFURLCreateStringByAddingPercentEscapes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v19, 0, CFSTR("/"), 0);
LABEL_44:
            if (v16
              && (v20 = CFStringCreateWithFormat(allocator, 0, CFSTR("%@/%@"), v9, v16), (*identifierOut = v20) != 0))
            {
              v15 = 0;
            }
            else
            {
              v15 = FigSignalErrorAt(4294950996, 0, 0, 0, 0, 0, 0);
            }
            goto LABEL_47;
          }
        }
        v17 = 0;
        v16 = 0;
        v15 = -16304;
LABEL_47:
        if (v9)
          CFRelease(v9);
        if (v16)
          CFRelease(v16);
        if (v17)
          CFRelease(v17);
        return v15;
      }
    }
  }
  v10 = 4294950990;
  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

BOOL keyNamespaceHasOSTypeValues(const __CFString *a1)
{
  return CFStringCompare(a1, CFSTR("udta"), 0) == kCFCompareEqualTo
      || CFStringCompare(a1, CFSTR("itsk"), 0) == kCFCompareEqualTo
      || CFStringCompare(a1, CFSTR("uiso"), 0) == kCFCompareEqualTo
      || CFStringCompare(a1, CFSTR("id3"), 0) == kCFCompareEqualTo;
}

BOOL keyNamespaceHasAtSymbolOSTypeValues(const __CFString *a1)
{
  return CFStringCompare(a1, CFSTR("udta"), 0) == kCFCompareEqualTo
      || CFStringCompare(a1, CFSTR("itsk"), 0) == kCFCompareEqualTo;
}

uint64_t FigMetadataCreateIdentifierForKeyAndOSTypeKeySpace(const __CFAllocator *a1, const void *a2, unsigned int a3, CFStringRef *a4)
{
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  uint64_t IdentifierForKeyAndKeySpace;
  int v12;
  unsigned int v13;
  char v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char cStr[5];
  unsigned int v22;

  if (a3 == 1768126752)
  {
    v7 = CFSTR("icy");
LABEL_5:
    v8 = (const __CFString *)CFRetain(v7);
LABEL_6:
    v9 = v8;
    goto LABEL_7;
  }
  if (a3 == 1768174368)
  {
    v7 = CFSTR("id3");
    goto LABEL_5;
  }
  v12 = 0;
  v13 = bswap32(a3);
  v14 = 1;
  v15 = 4;
  v16 = v13;
  IdentifierForKeyAndKeySpace = 4294950990;
  do
  {
    if (HIBYTE(v16))
    {
      if (v12 || !(v16 >> 29) || (v16 & 0xFF000000) == 0x7F000000)
        return IdentifierForKeyAndKeySpace;
      v12 = 0;
    }
    else
    {
      if ((v14 & 1) != 0)
        return 4294950990;
      v12 = 1;
    }
    v14 = 0;
    v16 <<= 8;
    --v15;
  }
  while (v15);
  v17 = 3;
  if (HIBYTE(a3))
    v17 = 4;
  v18 = v17 - (a3 < 0x10000) - (a3 < 0x100);
  v19 = a3 == 0;
  v20 = v18 - v19;
  if (v18 != v19)
  {
    v22 = v13;
    __strncpy_chk();
    cStr[v20] = 0;
    v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0);
    goto LABEL_6;
  }
  v9 = 0;
LABEL_7:
  IdentifierForKeyAndKeySpace = CMMetadataCreateIdentifierForKeyAndKeySpace(a1, a2, v9, a4);
  if (v9)
    CFRelease(v9);
  return IdentifierForKeyAndKeySpace;
}

OSStatus CMMetadataCreateKeyFromIdentifierAsCFData(CFAllocatorRef allocator, CFStringRef identifier, CFDataRef *keyOut)
{
  OSStatus EncodedPartsOfIdentifier;
  CFTypeRef v6;
  OSStatus v7;
  CFTypeRef v9;
  CFTypeRef cf;

  v9 = 0;
  cf = 0;
  if (!keyOut)
    return FigSignalErrorAt(4294950995, 0, 0, 0, 0, 0, 0);
  *keyOut = 0;
  EncodedPartsOfIdentifier = getEncodedPartsOfIdentifier(allocator, identifier, (CFStringRef *)&cf, (CFStringRef *)&v9);
  v6 = cf;
  if (!EncodedPartsOfIdentifier)
    EncodedPartsOfIdentifier = createKeyAsCFData(allocator, (const __CFString *)cf, (CFStringRef)v9, keyOut);
  v7 = EncodedPartsOfIdentifier;
  if (v6)
    CFRelease(v6);
  if (v9)
    CFRelease(v9);
  return v7;
}

uint64_t getEncodedPartsOfIdentifier(const __CFAllocator *a1, CFStringRef theString1, CFStringRef *a3, CFStringRef *a4)
{
  CFIndex Length;
  CFRange v9;
  CFStringRef v10;
  uint64_t result;
  uint64_t v12;
  CFRange v13;
  CFRange v14;

  if (theString1)
  {
    if (CFStringCompare(theString1, CFSTR("anon"), 0) == kCFCompareEqualTo)
      return 4294950988;
    Length = CFStringGetLength(theString1);
    v9 = CFStringFind(theString1, CFSTR("/"), 0);
    if (v9.length)
    {
      if (v9.location && Length - 1 > v9.location)
      {
        v13.location = 0;
        v13.length = v9.location;
        *a3 = CFStringCreateWithSubstring(a1, theString1, v13);
        v14.location = v9.location + 1;
        v14.length = Length - (v9.location + 1);
        v10 = CFStringCreateWithSubstring(a1, theString1, v14);
        result = 0;
        *a4 = v10;
        return result;
      }
      v12 = 4294950989;
    }
    else
    {
      v12 = 4294950989;
    }
  }
  else
  {
    v12 = 4294950995;
  }
  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t createKeyAsCFData(const __CFAllocator *a1, const __CFString *a2, CFStringRef origString, CFDataRef *a4)
{
  CFStringRef v7;
  const __CFString *v8;
  CFDataRef v9;
  uint64_t v10;
  CFDataRef ExternalRepresentation;
  uint64_t v13;
  UInt8 buffer[4];
  CFIndex usedBufLen;
  CFRange v16;

  v7 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding((CFAllocatorRef)*MEMORY[0x1E0C9AE00], origString, &stru_1E28E82E0, 0);
  if (v7)
  {
    v8 = v7;
    usedBufLen = 0;
    if (keyNamespaceHasOSTypeValues(a2))
    {
      if (CFStringGetLength(v8) == 4)
      {
        v16.location = 0;
        v16.length = 4;
        CFStringGetBytes(v8, v16, 0, 0, 0, buffer, 4, &usedBufLen);
        if (usedBufLen == 4)
        {
          v9 = CFDataCreate(a1, buffer, 4);
          *a4 = v9;
          if (v9)
          {
            v10 = 0;
LABEL_8:
            CFRelease(v8);
            return v10;
          }
        }
        v13 = 4294950994;
      }
      else
      {
        v13 = 4294950993;
      }
      v10 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
      goto LABEL_8;
    }
    ExternalRepresentation = CFStringCreateExternalRepresentation(a1, v8, 0, 0);
    v10 = 0;
    *a4 = ExternalRepresentation;
    goto LABEL_8;
  }
  return FigSignalErrorAt(4294950994, 0, 0, 0, 0, 0, 0);
}

OSStatus CMMetadataCreateKeyFromIdentifier(CFAllocatorRef allocator, CFStringRef identifier, CFTypeRef *keyOut)
{
  OSStatus EncodedPartsOfIdentifier;
  const __CFString *v6;
  const __CFAllocator *v7;
  CFStringRef v8;
  const __CFString *v9;
  uint64_t v10;
  int v11;
  CFNumberRef v12;
  OSStatus v13;
  CFStringRef v14;
  const __CFString *v15;
  CFStringRef v16;
  uint64_t v17;
  const __CFString *v18;
  uint64_t v20;
  CFStringRef origString;
  CFTypeRef cf;
  int valuePtr;
  UInt8 buffer[4];
  CFIndex usedBufLen;
  CFRange v26;
  CFRange v27;

  origString = 0;
  cf = 0;
  if (!keyOut)
    return FigSignalErrorAt(4294950995, 0, 0, 0, 0, 0, 0);
  *keyOut = 0;
  EncodedPartsOfIdentifier = getEncodedPartsOfIdentifier(allocator, identifier, (CFStringRef *)&cf, &origString);
  v6 = (const __CFString *)cf;
  if (EncodedPartsOfIdentifier)
  {
LABEL_20:
    v13 = EncodedPartsOfIdentifier;
    if (!v6)
      goto LABEL_37;
    goto LABEL_36;
  }
  if (keyNamespaceHasOSTypeValues((const __CFString *)cf))
  {
    valuePtr = 0;
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding((CFAllocatorRef)*MEMORY[0x1E0C9AE00], origString, &stru_1E28E82E0, 0);
    if (v8)
    {
      v9 = v8;
      usedBufLen = 0;
      if (keyNamespaceHasOSTypeValues(v6))
      {
        if (CFStringGetLength(v9) == 4)
        {
          v26.location = 0;
          v26.length = 4;
          CFStringGetBytes(v9, v26, 0, 0, 0, buffer, 4, &usedBufLen);
          if (usedBufLen == 4)
          {
            v10 = 0;
            v11 = 0;
            do
              v11 = buffer[v10++] | (v11 << 8);
            while (v10 != 4);
            usedBufLen = 4;
            valuePtr = v11;
            v12 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
            *keyOut = v12;
            if (v12)
            {
              v13 = 0;
LABEL_32:
              v18 = v9;
              goto LABEL_35;
            }
          }
          v20 = 4294950994;
        }
        else
        {
          v20 = 4294950993;
        }
        v13 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
        goto LABEL_32;
      }
      v13 = -16304;
      goto LABEL_32;
    }
LABEL_41:
    EncodedPartsOfIdentifier = FigSignalErrorAt(4294950994, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
  if (CFStringCompare(v6, CFSTR("mdta"), 0)
    && CFStringCompare(v6, CFSTR("fiel"), 0)
    && CFStringCompare(v6, CFSTR("comn"), 0)
    && CFStringCompare(v6, CFSTR("common"), 0)
    && CFStringCompare(v6, CFSTR("itlk"), 0)
    && CFStringCompare(v6, CFSTR("icy"), 0)
    && CFStringCompare(v6, CFSTR("lsdr"), 0))
  {
    EncodedPartsOfIdentifier = createKeyAsCFData(allocator, v6, origString, (CFDataRef *)keyOut);
    goto LABEL_20;
  }
  v14 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding((CFAllocatorRef)*MEMORY[0x1E0C9AE00], origString, &stru_1E28E82E0, 0);
  if (!v14)
    goto LABEL_41;
  v15 = v14;
  usedBufLen = 0;
  if (keyNamespaceHasOSTypeValues(v6))
  {
    if (CFStringGetLength(v15) == 4)
    {
      v27.location = 0;
      v27.length = 4;
      CFStringGetBytes(v15, v27, 0, 0, 0, buffer, 4, &usedBufLen);
      if (usedBufLen == 4)
      {
        if (keyNamespaceHasAtSymbolOSTypeValues(v6) && buffer[0] == 169)
          buffer[0] = 64;
        v16 = CFStringCreateWithBytes(allocator, buffer, 4, 0, 0);
        v13 = 0;
        *keyOut = v16;
        if (v16)
          goto LABEL_34;
      }
      v17 = 4294950994;
    }
    else
    {
      v17 = 4294950993;
    }
    v13 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v13 = 0;
    *keyOut = CFRetain(v15);
  }
LABEL_34:
  v18 = v15;
LABEL_35:
  CFRelease(v18);
  if (v6)
LABEL_36:
    CFRelease(v6);
LABEL_37:
  if (origString)
    CFRelease(origString);
  return v13;
}

OSStatus CMMetadataCreateKeySpaceFromIdentifier(CFAllocatorRef allocator, CFStringRef identifier, CFStringRef *keySpaceOut)
{
  OSStatus EncodedPartsOfIdentifier;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  OSStatus v10;
  const __CFString *v11;
  CFTypeRef cf;
  CFStringRef theString1;

  cf = 0;
  theString1 = 0;
  if (!keySpaceOut)
    return FigSignalErrorAt(4294950995, 0, 0, 0, 0, 0, 0);
  *keySpaceOut = 0;
  if (!identifier)
  {
    v10 = FigSignalErrorAt(4294950995, 0, 0, 0, 0, 0, 0);
    v9 = 0;
    goto LABEL_20;
  }
  if (CFStringCompare(identifier, CFSTR("anon"), 0))
  {
    EncodedPartsOfIdentifier = getEncodedPartsOfIdentifier(allocator, identifier, &theString1, (CFStringRef *)&cf);
    v7 = theString1;
    if (EncodedPartsOfIdentifier)
    {
      v10 = EncodedPartsOfIdentifier;
LABEL_12:
      v9 = 0;
      if (!v7)
        goto LABEL_20;
      goto LABEL_19;
    }
    if (CFStringCompare(theString1, CFSTR("common"), 0))
    {
      if (CFStringCompare(v7, CFSTR("id3"), 0))
      {
        if (CFStringCompare(v7, CFSTR("avch"), 0))
        {
          v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, &stru_1E28E82E0, 0);
          v9 = v8;
          if (v8 && CFStringGetLength(v8) && CFStringGetLength(v9) < 5)
          {
            v10 = 0;
            *keySpaceOut = v9;
            goto LABEL_12;
          }
          v10 = FigSignalErrorAt(4294950989, 0, 0, 0, 0, 0, 0);
          if (!v7)
            goto LABEL_20;
LABEL_19:
          CFRelease(v7);
          goto LABEL_20;
        }
        v11 = CFSTR("org.avchd-info");
      }
      else
      {
        v11 = CFSTR("org.id3");
      }
    }
    else
    {
      v11 = CFSTR("comn");
    }
    v9 = 0;
    v10 = 0;
    *keySpaceOut = (CFStringRef)CFRetain(v11);
    if (v7)
      goto LABEL_19;
  }
  else
  {
    v10 = 0;
    v9 = 0;
    *keySpaceOut = (CFStringRef)CFRetain(identifier);
  }
LABEL_20:
  if (cf)
    CFRelease(cf);
  if (v9)
    CFRelease(v9);
  return v10;
}

uint64_t FigMetadataGetKeySpaceAsOSTypeFromIdentifier(CFStringRef identifier)
{
  uint64_t v1;
  const __CFString *v2;
  CFIndex Length;
  CFStringRef keySpaceOut;
  CFIndex usedBufLen;
  UInt8 buffer[4];
  unsigned int v8;
  CFRange v9;

  keySpaceOut = 0;
  if (CMMetadataCreateKeySpaceFromIdentifier((CFAllocatorRef)*MEMORY[0x1E0C9AE00], identifier, &keySpaceOut))
  {
    v1 = 0;
  }
  else
  {
    v1 = 1768174368;
    v2 = keySpaceOut;
    v8 = 0;
    if (CFStringCompare(keySpaceOut, CFSTR("id3"), 0) && CFStringCompare(v2, CFSTR("org.id3"), 0))
    {
      if (CFStringCompare(v2, CFSTR("icy"), 0))
      {
        if (CFStringCompare(v2, CFSTR("org.avchd-info"), 0))
        {
          if (CFStringCompare(v2, CFSTR("common"), 0))
          {
            usedBufLen = 0;
            Length = CFStringGetLength(v2);
            v9.location = 0;
            v9.length = Length;
            CFStringGetBytes(v2, v9, 0, 0, 0, buffer, 4, &usedBufLen);
            memcpy((char *)&v8 - Length + 4, buffer, Length);
            v1 = bswap32(v8);
          }
          else
          {
            v1 = 1668246894;
          }
        }
        else
        {
          v1 = 1635148648;
        }
      }
      else
      {
        v1 = 1768126752;
      }
    }
  }
  if (keySpaceOut)
    CFRelease(keySpaceOut);
  return v1;
}

OSStatus CMMetadataDataTypeRegistryRegisterDataType(CFStringRef dataType, CFStringRef description, CFArrayRef conformingDataTypes)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  return doFigMetadataDataTypeRegistryRegisterDataType(gfigMetadataDataTypeRegistryStorage, dataType, description, conformingDataTypes);
}

uint64_t doFigMetadataDataTypeRegistryRegisterDataType(uint64_t a1, const __CFString *a2, const void *a3, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const __CFString *v11;
  const __CFString *ValueAtIndex;
  const __CFString *v13;
  CFTypeID TypeID;
  const __CFArray *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *Value;
  const __CFDictionary *v19;
  const __CFArray *v20;
  uint64_t v21;
  const __CFArray *v22;
  CFIndex v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex v26;
  const void *v27;
  const __CFArray *v28;
  int v29;
  __CFDictionary *Mutable;
  __CFDictionary *v32;
  uint64_t v33;
  CFRange v34;
  CFRange v35;
  CFRange v36;

  if (!a1)
  {
    v33 = 4294950986;
    return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
  }
  if (!a2)
  {
    v33 = 4294950985;
    return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
  }
  if (!theArray)
  {
    v28 = *(const __CFArray **)(a1 + 40);
    v36.length = CFArrayGetCount(v28);
    v36.location = 0;
    v29 = CFArrayContainsValue(v28, v36, a2);
    v11 = a2;
    if (v29)
      goto LABEL_20;
    goto LABEL_31;
  }
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
LABEL_31:
    v33 = 4294950982;
    return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
  }
  v9 = Count;
  v10 = 0;
  v11 = 0;
  do
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v10);
    if (!ValueAtIndex || (v13 = ValueAtIndex, TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v13)))
    {
      v33 = 4294950984;
      return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
    }
    v15 = *(const __CFArray **)(a1 + 40);
    v34.length = CFArrayGetCount(v15);
    v34.location = 0;
    if (CFArrayContainsValue(v15, v34, v13))
    {
      if (!v11)
      {
        v11 = v13;
        goto LABEL_18;
      }
      v16 = v11;
      v17 = v13;
    }
    else
    {
      Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v13);
      if (!Value)
        goto LABEL_18;
      v17 = Value;
      if (!v11)
      {
        v11 = Value;
        goto LABEL_18;
      }
      v16 = v11;
    }
    if (CFStringCompare(v16, v17, 0))
    {
      v33 = 4294950981;
      return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
    }
LABEL_18:
    ++v10;
  }
  while (v9 != v10);
  if (!v11)
    goto LABEL_31;
LABEL_20:
  FigReentrantMutexLock(*(pthread_mutex_t **)a1);
  v19 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), a2);
  if (v19)
  {
    v20 = (const __CFArray *)CFDictionaryGetValue(v19, CFSTR("ConformingDataTypes"));
    if (!((unint64_t)theArray | (unint64_t)v20))
      goto LABEL_29;
    v21 = 4294950983;
    if (!theArray)
      goto LABEL_40;
    v22 = v20;
    if (!v20)
      goto LABEL_40;
    v23 = CFArrayGetCount(theArray);
    v24 = CFArrayGetCount(v22);
    if (v23 != v24)
      goto LABEL_39;
    if (v23 < 1)
    {
LABEL_29:
      v21 = 0;
      goto LABEL_40;
    }
    v25 = v24;
    v26 = 0;
    while (1)
    {
      v27 = CFArrayGetValueAtIndex(theArray, v26);
      v35.location = 0;
      v35.length = v25;
      if (!CFArrayContainsValue(v22, v35, v27))
        break;
      if (v23 == ++v26)
        goto LABEL_29;
    }
LABEL_39:
    v21 = 4294950983;
LABEL_40:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)a1);
  }
  else
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
    {
      v21 = 4294950986;
      goto LABEL_40;
    }
    v32 = Mutable;
    if (a3)
      CFDictionarySetValue(Mutable, CFSTR("Description"), a3);
    if (theArray)
      CFDictionarySetValue(v32, CFSTR("ConformingDataTypes"), theArray);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 8), a2, v32);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), a2, v11);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)a1);
    CFRelease(v32);
    return 0;
  }
  return v21;
}

CFArrayRef CMMetadataDataTypeRegistryGetBaseDataTypes(void)
{
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  if (gfigMetadataDataTypeRegistryStorage)
    return *(CFArrayRef *)(gfigMetadataDataTypeRegistryStorage + 48);
  else
    return 0;
}

Boolean CMMetadataDataTypeRegistryDataTypeIsBaseDataType(CFStringRef dataType)
{
  uint64_t v2;
  Boolean result;
  const void *Value;
  Boolean v5;

  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  v2 = gfigMetadataDataTypeRegistryStorage;
  if (!gfigMetadataDataTypeRegistryStorage)
    return 0;
  result = 0;
  if (dataType && *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 16))
  {
    if (FigMetadataDataTypeIsDynamicBaseDataType(dataType))
    {
      return 1;
    }
    else
    {
      FigReentrantMutexLock(*(pthread_mutex_t **)v2);
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 16), dataType);
      v5 = FigCFEqual(dataType, Value);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
      return v5;
    }
  }
  return result;
}

uint64_t FigMetadataDataTypeIsDynamicBaseDataType(const void *a1)
{
  uint64_t v2;
  uint64_t v3;

  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  v2 = gfigMetadataDataTypeRegistryStorage;
  FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage);
  v3 = CFDictionaryContainsKey(*(CFDictionaryRef *)(v2 + 24), a1);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
  return v3;
}

Boolean CMMetadataDataTypeRegistryDataTypeIsRegistered(CFStringRef dataType)
{
  uint64_t v2;
  Boolean v3;

  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  v2 = gfigMetadataDataTypeRegistryStorage;
  if (!gfigMetadataDataTypeRegistryStorage || !dataType || !*(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 8))
    return 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage);
  v3 = CFDictionaryContainsKey(*(CFDictionaryRef *)(v2 + 8), dataType);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
  return v3;
}

CFStringRef CMMetadataDataTypeRegistryGetDataTypeDescription(CFStringRef dataType)
{
  uint64_t v2;
  const __CFDictionary *Value;

  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  v2 = gfigMetadataDataTypeRegistryStorage;
  if (gfigMetadataDataTypeRegistryStorage
    && dataType
    && *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 8)
    && (FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage),
        Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 8), dataType),
        FigReentrantMutexUnlock(*(pthread_mutex_t **)v2),
        Value))
  {
    return (CFStringRef)CFDictionaryGetValue(Value, CFSTR("Description"));
  }
  else
  {
    return 0;
  }
}

CFArrayRef CMMetadataDataTypeRegistryGetConformingDataTypes(CFStringRef dataType)
{
  uint64_t v2;
  const __CFDictionary *Value;

  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  v2 = gfigMetadataDataTypeRegistryStorage;
  if (gfigMetadataDataTypeRegistryStorage
    && dataType
    && *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 8)
    && (FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage),
        Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 8), dataType),
        FigReentrantMutexUnlock(*(pthread_mutex_t **)v2),
        Value))
  {
    return (CFArrayRef)CFDictionaryGetValue(Value, CFSTR("ConformingDataTypes"));
  }
  else
  {
    return 0;
  }
}

CFStringRef CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(CFStringRef dataType)
{
  CFStringRef result;
  uint64_t v3;

  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  result = 0;
  if (dataType)
  {
    v3 = gfigMetadataDataTypeRegistryStorage;
    if (gfigMetadataDataTypeRegistryStorage)
    {
      if (*(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 16))
      {
        if (!FigMetadataDataTypeIsDynamicBaseDataType(dataType))
        {
          FigReentrantMutexLock(*(pthread_mutex_t **)v3);
          dataType = (CFStringRef)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 16), dataType);
          FigReentrantMutexUnlock(*(pthread_mutex_t **)v3);
        }
        return dataType;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

Boolean CMMetadataDataTypeRegistryDataTypeConformsToDataType(CFStringRef dataType, CFStringRef conformsToDataType)
{
  uint64_t v4;
  Boolean v5;
  __CFArray *Mutable;
  const __CFArray *v8;
  char v9;

  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  v4 = gfigMetadataDataTypeRegistryStorage;
  if (FigCFEqual(dataType, conformsToDataType))
    return 1;
  v5 = 0;
  if (dataType && conformsToDataType && v4)
  {
    if (*(_QWORD *)(v4 + 16)
      && (FigReentrantMutexLock(*(pthread_mutex_t **)v4),
          (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0)) != 0))
    {
      v8 = Mutable;
      CFArrayAppendValue(Mutable, dataType);
      v9 = 0;
      v5 = doDataTypeRegistryDatatypeConformsToDatatype(dataType, conformsToDataType, v8, v4, &v9);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)v4);
      CFRelease(v8);
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

uint64_t doDataTypeRegistryDatatypeConformsToDatatype(const void *a1, const void *a2, const __CFArray *a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  const void *ValueAtIndex;
  CFIndex v15;
  const void *v16;
  CFRange v17;

  if (*a5)
    return 0;
  result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 8), a1);
  if (!result)
  {
    *a5 = 1;
    return result;
  }
  result = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("ConformingDataTypes"));
  if (result)
  {
    v10 = (const __CFArray *)result;
    Count = CFArrayGetCount((CFArrayRef)result);
    if (Count < 1)
      return 0;
    v12 = Count;
    v13 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v10, v13);
      if (FigCFEqual(ValueAtIndex, a2))
        break;
      if (v12 == ++v13)
      {
        v15 = 0;
        while (1)
        {
          v16 = CFArrayGetValueAtIndex(v10, v15);
          v17.length = CFArrayGetCount(a3);
          v17.location = 0;
          if (CFArrayContainsValue(a3, v17, v16))
          {
            result = 0;
          }
          else
          {
            CFArrayAppendValue(a3, v16);
            result = doDataTypeRegistryDatatypeConformsToDatatype(v16, a2, a3, a4, a5);
            if ((_DWORD)result)
              return 1;
            if (*a5)
              return result;
          }
          if (++v15 >= v12)
            return result;
        }
      }
    }
    return 1;
  }
  return result;
}

CFStringRef FigMetadataCreateDynamicBaseDataType(const __CFAllocator *a1, int a2)
{
  uint64_t v3;
  CFNumberRef v4;
  CFNumberRef v5;
  const __CFString *Value;
  CFStringRef v7;
  const __CFUUID *v8;
  const __CFUUID *v9;
  CFStringRef v10;
  CFStringRef v11;
  int valuePtr;

  valuePtr = a2;
  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  v3 = gfigMetadataDataTypeRegistryStorage;
  v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  if (!v4)
  {
    FigSignalErrorAt(4294950986, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v5 = v4;
  FigReentrantMutexLock(*(pthread_mutex_t **)v3);
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v3 + 32), v5);
  if (Value)
  {
    v7 = Value;
    CFRetain(Value);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)v3);
  }
  else
  {
    v8 = CFUUIDCreate(a1);
    if (v8)
    {
      v9 = v8;
      v10 = CFUUIDCreateString(a1, v8);
      if (v10)
      {
        v11 = v10;
        v7 = CFStringCreateWithFormat(a1, 0, CFSTR("dyn.%@"), v10);
        if (v7)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 32), v5, v7);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 24), v7, v5);
          FigReentrantMutexUnlock(*(pthread_mutex_t **)v3);
        }
        else
        {
          FigSignalErrorAt(4294950986, 0, 0, 0, 0, 0, 0);
        }
        CFRelease(v9);
        CFRelease(v11);
        goto LABEL_9;
      }
      FigSignalErrorAt(4294950986, 0, 0, 0, 0, 0, 0);
      CFRelease(v9);
    }
    else
    {
      FigSignalErrorAt(4294950986, 0, 0, 0, 0, 0, 0);
    }
    v7 = 0;
  }
LABEL_9:
  CFRelease(v5);
  return v7;
}

uint64_t FigMetadataGetQTWellKnownTypeFromDynamicBaseDataType(const void *a1)
{
  uint64_t v2;
  const __CFNumber *Value;
  unsigned int valuePtr;

  FigThreadRunOnce(&getDataTypeRegistryStorage_sCreateDataTypeRegistryGlobalsOnce, createDataTypeRegistryGlobalsOnce);
  FigThreadRunOnce(&getDataTypeRegistryStorage_sRegisterKnownDataTypesOnce, registerKnownDataTypesOnce);
  v2 = gfigMetadataDataTypeRegistryStorage;
  valuePtr = 0;
  FigReentrantMutexLock(*(pthread_mutex_t **)gfigMetadataDataTypeRegistryStorage);
  Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 24), a1);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)v2);
  if (!Value)
    return 0;
  CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
  return valuePtr;
}

const __CFNumber *FigMetadataKeyGetUInt32(const __CFNumber *result)
{
  const __CFNumber *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (CFNumberGetTypeID() == v2)
    {
      return FigCFNumberGetUInt32(v1);
    }
    else if (CFStringGetTypeID() == v2)
    {
      return (const __CFNumber *)CFStringGetDoubleValue((CFStringRef)v1);
    }
    else if (CFDataGetTypeID() == v2)
    {
      return (const __CFNumber *)bswap32(*(_DWORD *)CFDataGetBytePtr(v1));
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFNumber *FigMetadataKeyGetLocalIDUInt32(const __CFDictionary *a1)
{
  const __CFNumber *Value;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("MetadataKeyLocalID"));
  return FigMetadataKeyGetUInt32(Value);
}

unint64_t FigMetadataKeyGetDatatypeUInt32(const __CFDictionary *a1)
{
  const __CFNumber *Value;
  const __CFNumber *v2;
  CFTypeID TypeID;
  CFTypeID v4;
  CFTypeID v5;
  CFIndex Length;
  UInt8 v8[4];
  UInt8 v9[2];
  UInt8 buffer;
  CFRange v11;
  CFRange v12;
  CFRange v13;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("MetadataKeyDataType"));
  if (Value)
  {
    v2 = Value;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v2) || (v4 = CFDataGetTypeID(), v4 == CFGetTypeID(v2)))
    {
      v5 = CFNumberGetTypeID();
      if (v5 == CFGetTypeID(v2))
        return (unint64_t)FigMetadataKeyGetUInt32(v2);
      Length = CFDataGetLength(v2);
      switch(Length)
      {
        case 4:
          *(_DWORD *)v8 = 0;
          v12.location = 0;
          v12.length = 4;
          CFDataGetBytes(v2, v12, v8);
          return bswap32(*(unsigned int *)v8);
        case 2:
          *(_WORD *)v9 = 0;
          v13.location = 0;
          v13.length = 2;
          CFDataGetBytes(v2, v13, v9);
          return bswap32(*(unsigned __int16 *)v9) >> 16;
        case 1:
          buffer = 0;
          v11.location = 0;
          v11.length = 1;
          CFDataGetBytes(v2, v11, &buffer);
          return buffer;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

const __CFNumber *FigMetadataKeyGetDatatypeNamespaceUInt32(const __CFDictionary *a1)
{
  const __CFNumber *Value;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("MetadataKeyDataTypeNameSpace"));
  return FigMetadataKeyGetUInt32(Value);
}

const __CFNumber *FigMetadataKeyGetKeyNamespaceUInt32(const __CFDictionary *a1)
{
  const __CFNumber *Value;

  Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("MetadataKeyNamespace"));
  return FigMetadataKeyGetUInt32(Value);
}

uint64_t FigBoxedMetadataGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigBoxedMetadataTypeOnce, (void (*)(void))registerFigBoxedMetadataType);
  return sFigBoxedMetadataID;
}

uint64_t registerFigBoxedMetadataType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigBoxedMetadataID = result;
  return result;
}

CFTypeRef FigBoxedMetadataRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void FigBoxedMetadataRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t FigBoxedMetadataCreateFromBlockBuffer(int a1, OpaqueCMBlockBuffer *a2, CMFormatDescriptionRef desc, _QWORD *a4)
{
  uint64_t Instance;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v11;

  if (!a4)
  {
    v11 = 4294950976;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  *a4 = 0;
  if (!a2
    || !desc
    || CMFormatDescriptionGetMediaType(desc) != 1835365473
    || CMFormatDescriptionGetMediaSubType(desc) != 1835360888)
  {
    v11 = 4294950976;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  FigThreadRunOnce(&sRegisterFigBoxedMetadataTypeOnce, (void (*)(void))registerFigBoxedMetadataType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v11 = 4294950974;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  v8 = (_QWORD *)Instance;
  v9 = FigAtomStreamInitWithBBuf(a2, 0, 1, Instance + 32);
  if ((_DWORD)v9)
  {
    CFRelease(v8);
  }
  else
  {
    v8[2] = a2;
    CFRetain(a2);
    v8[3] = desc;
    CFRetain(desc);
    v8[25] = -1;
    *a4 = v8;
  }
  return v9;
}

uint64_t FigBoxedMetadataCreateForConstruction(int a1, const __CFAllocator *a2, CMFormatDescriptionRef desc, uint64_t *a4)
{
  uint64_t Instance;
  uint64_t v8;
  uint64_t v9;
  CMBlockBufferRef v10;
  uint64_t v12;
  CMBlockBufferRef blockBufferOut;

  blockBufferOut = 0;
  if (!a4)
  {
    v12 = 4294950976;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  *a4 = 0;
  if (!desc
    || CMFormatDescriptionGetMediaType(desc) != 1835365473
    || CMFormatDescriptionGetMediaSubType(desc) != 1835360888)
  {
    v12 = 4294950976;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  FigThreadRunOnce(&sRegisterFigBoxedMetadataTypeOnce, (void (*)(void))registerFigBoxedMetadataType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v12 = 4294950974;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v8 = Instance;
  v9 = CMBlockBufferCreateEmpty(a2, 0, 1u, &blockBufferOut);
  v10 = blockBufferOut;
  if (!(_DWORD)v9)
  {
    v9 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, v8 + 144);
    v10 = blockBufferOut;
    if (!(_DWORD)v9)
    {
      *(_QWORD *)(v8 + 16) = blockBufferOut;
      if (v10)
        CFRetain(v10);
      *(_QWORD *)(v8 + 24) = desc;
      CFRetain(desc);
      v9 = 0;
      *(_BYTE *)(v8 + 216) = 1;
      *(_QWORD *)(v8 + 200) = -1;
      *a4 = v8;
      v10 = blockBufferOut;
      v8 = 0;
    }
  }
  if (v10)
    CFRelease(v10);
  if (v8)
    CFRelease((CFTypeRef)v8);
  return v9;
}

uint64_t FigBoxedMetadataGetBlockBuffer(uint64_t result)
{
  if (result)
  {
    if (*(_BYTE *)(result + 216))
      return 0;
    else
      return *(_QWORD *)(result + 16);
  }
  return result;
}

uint64_t FigBoxedMetadataGetFormatDescription(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t FigBoxedMetadataIsUnderConstruction(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 216);
  return result;
}

uint64_t FigBoxedMetadataGetNumberOfItems(uint64_t result)
{
  _QWORD *v1;
  int Atom;

  if (result)
  {
    v1 = (_QWORD *)result;
    if (*(_BYTE *)(result + 216))
    {
      return 0;
    }
    else
    {
      result = *(_QWORD *)(result + 200);
      if (result == -1)
      {
        while (1)
        {
          Atom = FigAtomStreamAdvanceToNextAtom(v1 + 4);
          if (Atom)
            break;
          ++v1[26];
        }
        if (Atom == -12890)
          result = v1[26] + 1;
        else
          result = 0;
        v1[25] = result;
      }
    }
  }
  return result;
}

uint64_t FigBoxedMetadataGetSizeOfItemAtIndex(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v3 = 0;
  if (result)
  {
    v2 = result;
    if (*(_BYTE *)(result + 216) || goToIndex(result, a2))
    {
      return 0;
    }
    else
    {
      FigAtomStreamGetCurrentAtomTypeAndDataLength(v2 + 32, 0, &v3);
      return v3;
    }
  }
  return result;
}

uint64_t goToIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 208);
  if (v2 == a2)
    return 0;
  if (v2 <= a2)
  {
LABEL_5:
    if (v2 != a2)
    {
      while (!FigAtomStreamAdvanceToNextAtom((_QWORD *)(a1 + 32)))
      {
        v5 = *(_QWORD *)(a1 + 208) + 1;
        *(_QWORD *)(a1 + 208) = v5;
        if (v5 == a2)
          return 0;
      }
      return 4294950973;
    }
    return 0;
  }
  if (!FigAtomStreamInitWithBBuf(*(OpaqueCMBlockBuffer **)(a1 + 16), 0, 1, a1 + 32))
  {
    v2 = 0;
    *(_QWORD *)(a1 + 208) = 0;
    goto LABEL_5;
  }
  return 4294950973;
}

uint64_t FigBoxedMetadataGetLocalIDOfItemAtIndex(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;

  v3 = 0;
  if (result)
  {
    v2 = result;
    if (*(_BYTE *)(result + 216) || goToIndex(result, a2))
    {
      return 0;
    }
    else
    {
      FigAtomStreamGetCurrentAtomTypeAndDataLength(v2 + 32, &v3, 0);
      return v3;
    }
  }
  return result;
}

uint64_t FigBoxedMetadataCreateBlockBufferForIndex(const __CFAllocator *a1, uint64_t a2, uint64_t a3, CMBlockBufferRef *a4)
{
  uint64_t result;
  uint64_t v9;
  char *dataPointerOut;
  uint64_t v11;
  uint64_t v12;

  if (!a4)
  {
    v9 = 4294950976;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  *a4 = 0;
  if (!a2)
  {
    v9 = 4294950976;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  if (*(_BYTE *)(a2 + 216))
  {
    v9 = 4294950971;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  if (a3 < 0 || FigBoxedMetadataGetNumberOfItems(a2) <= a3)
  {
    v9 = 4294950973;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  result = goToIndex(a2, a3);
  if (!(_DWORD)result)
  {
    v11 = 0;
    v12 = 0;
    dataPointerOut = 0;
    result = FigAtomStreamGetCurrentAtomDataGlobalOffset(a2 + 32, 0, &v12);
    if (!(_DWORD)result)
    {
      if (v12 <= 7)
      {
        return FigSignalErrorAt(4294950973, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a2 + 32, 0, &v11);
        if (!(_DWORD)result)
        {
          result = CMBlockBufferCreateWithMemoryBlock(a1, 0, v11 + 8, a1, 0, 0, v11 + 8, 1u, a4);
          if (!(_DWORD)result)
          {
            result = CMBlockBufferGetDataPointer(*a4, 0, 0, 0, &dataPointerOut);
            if (!(_DWORD)result)
              return CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a2 + 16), v12 - 8, v11 + 8, dataPointerOut);
          }
        }
      }
    }
  }
  return result;
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int8x16_t *a5)
{
  int8x16_t *v5;
  uint64_t result;
  uint64_t v10;
  int QuickTimeWellKnownTypeForLocalID;
  uint64_t v12;
  unint64_t WellKnownTypeDataSize;
  _BOOL4 v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  unsigned int v21;

  v5 = a5;
  v19 = 0;
  if (a4)
    *a4 = 0;
  if (!a1)
    goto LABEL_40;
  if (a2 < 0)
  {
    v18 = 4294950973;
    goto LABEL_44;
  }
  if (!a3 || !a5)
  {
LABEL_40:
    v18 = 4294950976;
LABEL_44:
    LODWORD(result) = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
LABEL_45:
    v14 = 0;
    goto LABEL_34;
  }
  if (*(_BYTE *)(a1 + 216))
  {
    v18 = 4294950971;
    goto LABEL_44;
  }
  LODWORD(result) = goToIndex(a1, a2);
  if ((_DWORD)result)
    goto LABEL_45;
  v21 = 0;
  v20 = 0;
  v10 = a1 + 32;
  LODWORD(result) = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1 + 32, &v21, &v20);
  if ((_DWORD)result)
    goto LABEL_45;
  QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), v21);
  v12 = v20;
  WellKnownTypeDataSize = getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, v20, &v19);
  if (WellKnownTypeDataSize)
  {
    if (WellKnownTypeDataSize == a3)
    {
      v14 = 0;
      goto LABEL_14;
    }
    v18 = 4294950969;
    goto LABEL_44;
  }
  v14 = v12 > a3;
LABEL_14:
  LODWORD(result) = FigAtomStreamReadCurrentAtomData(v10, 0, a3, (uint64_t)v5);
  if (!(_DWORD)result)
  {
    if (a4)
      *a4 = a3;
    if (v19)
    {
      LODWORD(result) = -16328;
      if (QuickTimeWellKnownTypeForLocalID <= 65)
      {
        switch(QuickTimeWellKnownTypeForLocalID)
        {
          case 23:
LABEL_27:
            LODWORD(result) = 0;
            v5->i32[0] = bswap32(v5->i32[0]);
            break;
          case 24:
LABEL_28:
            LODWORD(result) = 0;
            v5->i64[0] = bswap64(v5->i64[0]);
            break;
          case 30:
LABEL_26:
            LODWORD(result) = 0;
            *v5 = vrev32q_s8(*v5);
            break;
        }
      }
      else
      {
        switch(QuickTimeWellKnownTypeForLocalID)
        {
          case 'B':
          case 'L':
            LODWORD(result) = 0;
            v5->i16[0] = bswap32(v5->u16[0]) >> 16;
            break;
          case 'C':
          case 'M':
            goto LABEL_27;
          case 'F':
          case 'G':
            LODWORD(result) = 0;
            *(int8x8_t *)v5->i8 = vrev32_s8(*(int8x8_t *)v5->i8);
            break;
          case 'H':
            goto LABEL_26;
          case 'J':
          case 'N':
            goto LABEL_28;
          case 'O':
          case 'S':
            v15 = 0;
            do
            {
              v5->i64[v15] = bswap64(v5->u64[v15]);
              ++v15;
            }
            while ((_DWORD)(v15 * 8) != 72);
            goto LABEL_33;
          case 'P':
          case 'Q':
            v16 = (unint64_t)(int)a3 >> 2;
            if ((int)v16 >= 1)
            {
              do
              {
                v5->i32[0] = bswap32(v5->i32[0]);
                v5 = (int8x16_t *)((char *)v5 + 4);
                LODWORD(v16) = v16 - 1;
              }
              while ((_DWORD)v16);
            }
            goto LABEL_33;
          default:
            break;
        }
      }
    }
    else
    {
LABEL_33:
      LODWORD(result) = 0;
    }
  }
LABEL_34:
  if ((_DWORD)result)
    v17 = 1;
  else
    v17 = !v14;
  if (v17)
    return result;
  else
    return 4294950972;
}

unint64_t getWellKnownTypeDataSize(int a1, uint64_t a2, _BYTE *a3)
{
  int v3;
  unint64_t result;

  if (a1 <= 64)
  {
    switch(a1)
    {
      case 23:
LABEL_9:
        *a3 = 1;
        return 4;
      case 24:
LABEL_8:
        *a3 = 1;
        return 8;
      case 30:
LABEL_7:
        *a3 = 1;
        return 16;
      default:
        return 0;
    }
  }
  else
  {
    v3 = a1 - 65;
    result = 1;
    switch(v3)
    {
      case 0:
      case 10:
        return result;
      case 1:
      case 11:
        *a3 = 1;
        result = 2;
        break;
      case 2:
      case 12:
        goto LABEL_9;
      case 5:
      case 6:
      case 9:
      case 13:
        goto LABEL_8;
      case 7:
        goto LABEL_7;
      case 14:
      case 18:
        *a3 = 1;
        result = 72;
        break;
      case 15:
        *a3 = 1;
        if ((a2 & 0xFFFFFFFFFFFFFFF8) < 0x18)
          result = -1;
        else
          result = a2 & 0xFFFFFFFFFFFFFFF8;
        break;
      case 16:
        *a3 = 1;
        if ((a2 & 0xFFFFFFFFFFFFFFF0) != 0)
          result = a2 & 0xFFFFFFFFFFFFFFF8;
        else
          result = -1;
        break;
      default:
        return 0;
    }
  }
  return result;
}

uint64_t FigBoxedMetadataCopyValueOfItemAtIndexAsCFType(const __CFAllocator *a1, uint64_t a2, uint64_t a3, __CFArray **a4)
{
  CMBlockBufferRef *v5;
  uint64_t CurrentAtomTypeAndDataLength;
  uint64_t v8;
  int QuickTimeWellKnownTypeForLocalID;
  CFIndex v10;
  unint64_t WellKnownTypeDataSize;
  int v12;
  __CFData *v13;
  __CFArray *v14;
  __CFData *v15;
  CFIndex v16;
  UInt8 *MutableBytePtr;
  uint64_t v18;
  const UInt8 *BytePtr;
  CFIndex v20;
  const __CFAllocator *v21;
  CFStringEncoding v22;
  __CFArray *SInt8;
  CFMutableArrayRef v24;
  uint64_t v25;
  const __CFAllocator *v26;
  CFNumberRef v27;
  CFMutableArrayRef Mutable;
  uint64_t v29;
  const __CFAllocator *v30;
  CFNumberRef v31;
  uint64_t CurrentAtomData;
  unint64_t v33;
  uint64_t v34;
  CGPoint v35;
  CGFloat v36;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v38;
  __CFData *v39;
  CFIndex v40;
  UInt8 *v41;
  uint64_t v42;
  CGPoint v43;
  CGFloat y;
  CGSize v45;
  CGFloat height;
  unsigned int v47;
  uint64_t v49;
  char *dataPointerOut;
  size_t dataLength;
  size_t v52;
  _OWORD valuePtr[7];
  CMBlockBufferRef theBuffer;
  char v55;
  CFIndex length;
  unsigned int v57;
  int8x8_t v58[16];
  CGRect v59;

  v58[15] = *(int8x8_t *)MEMORY[0x1E0C80C00];
  v57 = 0;
  length = 0;
  v55 = 0;
  theBuffer = 0;
  if (!a4)
  {
    v42 = FigSignalErrorAt(4294950976, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    goto LABEL_94;
  }
  v5 = (CMBlockBufferRef *)a2;
  *a4 = 0;
  if (!a2)
  {
    CurrentAtomData = FigSignalErrorAt(4294950976, 0, 0, 0, 0, 0, 0);
LABEL_97:
    v42 = CurrentAtomData;
    goto LABEL_89;
  }
  if (*(_BYTE *)(a2 + 216))
  {
    v49 = 4294950971;
LABEL_102:
    CurrentAtomTypeAndDataLength = FigSignalErrorAt(v49, 0, 0, 0, 0, 0, 0);
    goto LABEL_103;
  }
  CurrentAtomTypeAndDataLength = goToIndex(a2, a3);
  if ((_DWORD)CurrentAtomTypeAndDataLength)
    goto LABEL_103;
  v8 = (uint64_t)(v5 + 4);
  CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)(v5 + 4), &v57, &length);
  if ((_DWORD)CurrentAtomTypeAndDataLength)
    goto LABEL_103;
  QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(v5[3], v57);
  v10 = length;
  WellKnownTypeDataSize = getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, length, &v55);
  if (WellKnownTypeDataSize && v10 != WellKnownTypeDataSize)
  {
    v49 = 4294950969;
    goto LABEL_102;
  }
  if (QuickTimeWellKnownTypeForLocalID > 23)
  {
    switch(QuickTimeWellKnownTypeForLocalID)
    {
      case 'A':
        v58[0].i8[0] = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 1, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        SInt8 = FigCFNumberCreateSInt8((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v58[0].i8[0]);
        goto LABEL_84;
      case 'B':
        v58[0].i16[0] = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 2, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v58[0].i16[0] = bswap32(v58[0].u16[0]) >> 16;
        SInt8 = FigCFNumberCreateSInt16((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v58[0].i16[0]);
        goto LABEL_84;
      case 'C':
        v58[0].i32[0] = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 4, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v58[0].i32[0] = bswap32(v58[0].u32[0]);
        SInt8 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v58[0].i32[0]);
        goto LABEL_84;
      case 'D':
      case 'E':
        memset(v58, 0, 112);
        memset(valuePtr, 0, sizeof(valuePtr));
        dataLength = 0;
        v52 = 0;
        dataPointerOut = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamInitWithParent((uint64_t)(v5 + 4), 0, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v12 = QuickTimeWellKnownTypeForLocalID == 68 ? 1667330681 : 1668441443;
        CurrentAtomTypeAndDataLength = FigAtomStreamPositionAtFirstAtomWithType((uint64_t)v58, v12);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        CurrentAtomTypeAndDataLength = FigAtomStreamInitWithParent((uint64_t)v58, 0, (uint64_t)valuePtr);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        CurrentAtomTypeAndDataLength = FigAtomStreamPositionAtFirstAtomWithType((uint64_t)valuePtr, 1667855475);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomDataGlobalOffset((uint64_t)valuePtr, 0, &v52);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)valuePtr, 0, &dataLength);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        CurrentAtomTypeAndDataLength = CMBlockBufferCreateWithMemoryBlock(a1, 0, dataLength, a1, 0, 0, dataLength, 1u, &theBuffer);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        CurrentAtomTypeAndDataLength = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        CurrentAtomTypeAndDataLength = CMBlockBufferCopyDataBytes(v5[2], v52, dataLength, dataPointerOut);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        CurrentAtomTypeAndDataLength = FigBoxedMetadataCreateFromBlockBuffer((int)a1, theBuffer, v5[3], a4);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v13 = 0;
        v5 = 0;
        v14 = *a4;
        goto LABEL_86;
      case 'F':
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v43 = (CGPoint)vcvtq_f64_f32((float32x2_t)vrev32_s8(v58[0]));
        y = v43.y;
        SInt8 = CGPointCreateDictionaryRepresentation(v43);
        goto LABEL_84;
      case 'G':
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v45 = (CGSize)vcvtq_f64_f32((float32x2_t)vrev32_s8(v58[0]));
        height = v45.height;
        SInt8 = CGSizeCreateDictionaryRepresentation(v45);
        goto LABEL_84;
      case 'H':
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 16, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v59.origin.x = COERCE_FLOAT(bswap32(v58[0].u32[0]));
        v59.origin.y = COERCE_FLOAT(bswap32(v58[0].u32[1]));
        v59.size.width = COERCE_FLOAT(bswap32(v58[1].u32[0]));
        v59.size.height = COERCE_FLOAT(bswap32(v58[1].u32[1]));
        SInt8 = CGRectCreateDictionaryRepresentation(v59);
        goto LABEL_84;
      case 'I':
      case 'R':
        goto LABEL_57;
      case 'J':
        v58[0] = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v58[0] = (int8x8_t)bswap64(*(_QWORD *)v58);
        SInt8 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_QWORD *)v58);
        goto LABEL_84;
      case 'K':
        v58[0].i8[0] = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 1, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        SInt8 = FigCFNumberCreateUInt8((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v58[0].u8[0]);
        goto LABEL_84;
      case 'L':
        v58[0].i16[0] = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 2, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v47 = bswap32(v58[0].u16[0]);
        v58[0].i16[0] = HIWORD(v47);
        SInt8 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E0C9AE00], HIWORD(v47));
        goto LABEL_84;
      case 'M':
        v58[0].i32[0] = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 4, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v58[0].i32[0] = bswap32(v58[0].u32[0]);
        SInt8 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v58[0].u32[0]);
        goto LABEL_84;
      case 'N':
        v58[0] = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v58[0] = (int8x8_t)bswap64(*(_QWORD *)v58);
        SInt8 = FigCFNumberCreateUInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_QWORD *)v58);
        goto LABEL_84;
      case 'O':
      case 'S':
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 72, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        Mutable = CFArrayCreateMutable(a1, 9, MEMORY[0x1E0C9B378]);
        if (!Mutable)
          goto LABEL_110;
        v14 = Mutable;
        v29 = 0;
        v30 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        do
        {
          *(_QWORD *)&valuePtr[0] = bswap64(*(_QWORD *)&v58[v29]);
          v31 = CFNumberCreate(v30, kCFNumberFloat64Type, valuePtr);
          CFArrayAppendValue(v14, v31);
          CFRelease(v31);
          ++v29;
        }
        while (v29 != 9);
        goto LABEL_47;
      case 'P':
      case 'Q':
        v5 = (CMBlockBufferRef *)malloc_type_malloc(v10, 0xACE648F5uLL);
        if (!v5)
          goto LABEL_106;
        CurrentAtomData = FigAtomStreamReadCurrentAtomData(v8, 0, length, (uint64_t)v5);
        if ((_DWORD)CurrentAtomData)
          goto LABEL_97;
        v33 = (unint64_t)(int)v10 >> 3;
        v14 = CFArrayCreateMutable(a1, (int)v33, MEMORY[0x1E0C9B378]);
        if (!v14)
          goto LABEL_107;
        if ((int)v33 < 1)
          goto LABEL_55;
        v34 = 0;
        break;
      default:
        if (QuickTimeWellKnownTypeForLocalID == 24)
        {
          v58[0] = 0;
          CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 8, (uint64_t)v58);
          if ((_DWORD)CurrentAtomTypeAndDataLength)
            goto LABEL_103;
          v58[0] = (int8x8_t)bswap64(*(_QWORD *)v58);
          SInt8 = FigCFNumberCreateFloat64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(double *)v58);
          goto LABEL_84;
        }
        if (QuickTimeWellKnownTypeForLocalID != 30)
          goto LABEL_57;
        CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 16, (uint64_t)v58);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_103;
        v24 = CFArrayCreateMutable(a1, 4, MEMORY[0x1E0C9B378]);
        if (!v24)
        {
LABEL_110:
          v42 = 4294950974;
          goto LABEL_104;
        }
        v14 = v24;
        v25 = 0;
        v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        do
        {
          LODWORD(valuePtr[0]) = bswap32(v58[0].u32[v25]);
          v27 = CFNumberCreate(v26, kCFNumberSInt32Type, valuePtr);
          CFArrayAppendValue(v14, v27);
          CFRelease(v27);
          ++v25;
        }
        while (v25 != 4);
LABEL_47:
        v13 = 0;
        v5 = 0;
        goto LABEL_56;
    }
    while (1)
    {
      v35 = (CGPoint)vcvtq_f64_f32((float32x2_t)vrev32_s8((int8x8_t)v5[v34]));
      v36 = v35.y;
      DictionaryRepresentation = CGPointCreateDictionaryRepresentation(v35);
      if (!DictionaryRepresentation)
        goto LABEL_107;
      v38 = DictionaryRepresentation;
      CFArrayAppendValue(v14, DictionaryRepresentation);
      CFRelease(v38);
      if ((_DWORD)v33 == (_DWORD)++v34)
      {
LABEL_55:
        v13 = 0;
LABEL_56:
        *a4 = v14;
        goto LABEL_86;
      }
    }
  }
  if ((QuickTimeWellKnownTypeForLocalID - 1) < 2
    || (QuickTimeWellKnownTypeForLocalID - 4) < 2)
  {
    v15 = CFDataCreateMutable(a1, v10);
    if (v15)
    {
      v13 = v15;
      CFDataSetLength(v15, length);
      v16 = length;
      MutableBytePtr = CFDataGetMutableBytePtr(v13);
      v18 = FigAtomStreamReadCurrentAtomData(v8, 0, v16, (uint64_t)MutableBytePtr);
      if (!(_DWORD)v18)
      {
        if (QuickTimeWellKnownTypeForLocalID == 4 || QuickTimeWellKnownTypeForLocalID == 1)
        {
          BytePtr = CFDataGetBytePtr(v13);
          v20 = length;
          v21 = a1;
          v22 = 134217984;
        }
        else
        {
          BytePtr = CFDataGetBytePtr(v13);
          v20 = length;
          v21 = a1;
          v22 = 268435712;
        }
        SInt8 = (__CFArray *)CFStringCreateWithBytes(v21, BytePtr, v20, v22, 0);
        v14 = SInt8;
LABEL_85:
        v5 = 0;
        *a4 = SInt8;
LABEL_86:
        if (v14)
        {
          v42 = 0;
          if (!v13)
          {
LABEL_89:
            v14 = 0;
            goto LABEL_90;
          }
        }
        else
        {
          v42 = FigSignalErrorAt(4294950974, 0, 0, 0, 0, 0, 0);
          if (!v13)
            goto LABEL_89;
        }
LABEL_88:
        CFRelease(v13);
        goto LABEL_89;
      }
      v42 = v18;
LABEL_109:
      v5 = 0;
      goto LABEL_88;
    }
LABEL_105:
    v5 = 0;
LABEL_106:
    v14 = 0;
LABEL_107:
    v42 = 4294950974;
    goto LABEL_90;
  }
  if (QuickTimeWellKnownTypeForLocalID == 23)
  {
    v58[0].i32[0] = 0;
    CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)(v5 + 4), 0, 4, (uint64_t)v58);
    if (!(_DWORD)CurrentAtomTypeAndDataLength)
    {
      v58[0].i32[0] = bswap32(v58[0].u32[0]);
      SInt8 = FigCFNumberCreateFloat32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(float *)v58[0].i32);
LABEL_84:
      v14 = SInt8;
      v13 = 0;
      goto LABEL_85;
    }
LABEL_103:
    v42 = CurrentAtomTypeAndDataLength;
LABEL_104:
    v5 = 0;
    goto LABEL_89;
  }
LABEL_57:
  v39 = CFDataCreateMutable(a1, v10);
  if (!v39)
    goto LABEL_105;
  v13 = v39;
  CFDataSetLength(v39, length);
  v40 = length;
  v41 = CFDataGetMutableBytePtr(v13);
  v42 = FigAtomStreamReadCurrentAtomData(v8, 0, v40, (uint64_t)v41);
  if ((_DWORD)v42)
    goto LABEL_109;
  v5 = 0;
  v14 = 0;
  *a4 = v13;
LABEL_90:
  if (theBuffer)
    CFRelease(theBuffer);
  if (v14)
    CFRelease(v14);
LABEL_94:
  free(v5);
  return v42;
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndexAsSInt8(uint64_t a1, uint64_t a2)
{
  return (char)getValueOfItemAtIndexAsSInt64(a1, a2);
}

unint64_t getValueOfItemAtIndexAsSInt64(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  int CurrentAtomData;
  uint64_t v5;
  int v6;
  signed int v7;
  int v8;
  unint64_t v9;
  int v10;
  unsigned int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;

  v14 = 0;
  v13 = 0;
  if (scalarReadSetup(a1, a2, &v13))
    return 0;
  result = 0;
  switch(v13)
  {
    case 'A':
      LOBYTE(v12) = 0;
      CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 1, (uint64_t)&v12);
      v5 = (char)v12;
      goto LABEL_21;
    case 'B':
      LOWORD(v12) = 0;
      CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 2, (uint64_t)&v12);
      v5 = (__int16)(bswap32((unsigned __int16)v12) >> 16);
      goto LABEL_21;
    case 'C':
      LODWORD(v12) = 0;
      v6 = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v12);
      v7 = bswap32(v12);
      if (v6)
        return 0;
      return v7;
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
      return result;
    case 'J':
      v8 = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v14);
      v9 = bswap64(v14);
      if (v8)
        return v14;
      else
        return v9;
    case 'K':
      LOBYTE(v12) = 0;
      CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 1, (uint64_t)&v12);
      v5 = v12;
      goto LABEL_21;
    case 'L':
      LOWORD(v12) = 0;
      CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 2, (uint64_t)&v12);
      v5 = bswap32((unsigned __int16)v12) >> 16;
      goto LABEL_21;
    case 'M':
      LODWORD(v12) = 0;
      v10 = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v12);
      v11 = bswap32(v12);
      if (v10)
        return 0;
      else
        return v11;
    case 'N':
      v12 = 0;
      CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v12);
      v5 = bswap64(v12);
      goto LABEL_21;
    default:
      if (v13 == 23)
      {
        LODWORD(v12) = 0;
        CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v12);
        v5 = (uint64_t)COERCE_FLOAT(bswap32(v12));
      }
      else
      {
        if (v13 != 24)
          return result;
        v12 = 0;
        CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v12);
        v5 = (uint64_t)COERCE_DOUBLE(bswap64(v12));
      }
LABEL_21:
      if (CurrentAtomData)
        result = 0;
      else
        result = v5;
      break;
  }
  return result;
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndexAsUInt8(uint64_t a1, uint64_t a2)
{
  return getValueOfItemAtIndexAsSInt64(a1, a2);
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndexAsSInt16(uint64_t a1, uint64_t a2)
{
  return (__int16)getValueOfItemAtIndexAsSInt64(a1, a2);
}

uint64_t FigBoxedMetadataGetValueOfItemAtIndexAsUInt16(uint64_t a1, uint64_t a2)
{
  return (unsigned __int16)getValueOfItemAtIndexAsSInt64(a1, a2);
}

unint64_t FigBoxedMetadataGetValueOfItemAtIndexAsSInt32(uint64_t a1, uint64_t a2)
{
  return getValueOfItemAtIndexAsSInt64(a1, a2);
}

unint64_t FigBoxedMetadataGetValueOfItemAtIndexAsUInt32(uint64_t a1, uint64_t a2)
{
  return getValueOfItemAtIndexAsSInt64(a1, a2);
}

float FigBoxedMetadataGetValueOfItemAtIndexAsFloat32(uint64_t a1, uint64_t a2)
{
  int Setup;
  float result;
  uint64_t v6;
  int CurrentAtomData;
  unint64_t v8;
  uint64_t v9;

  v9 = 0;
  Setup = scalarReadSetup(a1, a2, (int *)&v9);
  result = 0.0;
  if (!Setup)
  {
    v6 = (v9 - 23);
    if (v6 <= 0x37)
    {
      if (((1 << (v9 - 23)) & 0xF81C0000000000) != 0)
      {
        return (float)(uint64_t)getValueOfItemAtIndexAsSInt64(a1, a2);
      }
      else if ((_DWORD)v9 == 23)
      {
        if (FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v9 + 4))
          return *((float *)&v9 + 1);
        else
          return COERCE_FLOAT(bswap32(HIDWORD(v9)));
      }
      else if (v6 == 1)
      {
        v8 = 0;
        CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v8);
        result = COERCE_DOUBLE(bswap64(v8));
        if (CurrentAtomData)
          return 0.0;
      }
    }
  }
  return result;
}

uint64_t scalarReadSetup(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t result;
  int QuickTimeWellKnownTypeForLocalID;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  unsigned int v11;

  if (!a1)
  {
    v8 = 4294950976;
    return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  if (*(_BYTE *)(a1 + 216))
  {
    v8 = 4294950971;
    return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  result = goToIndex(a1, a2);
  if (!(_DWORD)result)
  {
    v11 = 0;
    v10 = 0;
    result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1 + 32, &v11, &v10);
    if (!(_DWORD)result)
    {
      QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), v11);
      *a3 = QuickTimeWellKnownTypeForLocalID;
      v7 = v10;
      if (v7 == getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, v10, &v9))
        return 0;
      else
        return FigSignalErrorAt(4294950969, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

double FigBoxedMetadataGetValueOfItemAtIndexAsFloat64(uint64_t a1, uint64_t a2)
{
  int v4;
  double result;
  uint64_t v6;
  int CurrentAtomData;
  unsigned int v8;
  int v9;
  double v10;

  v10 = 0.0;
  v9 = 0;
  v4 = scalarReadSetup(a1, a2, &v9);
  result = 0.0;
  if (!v4)
  {
    v6 = (v9 - 23);
    if (v6 <= 0x37)
    {
      if (((1 << (v9 - 23)) & 0xF81C0000000000) != 0)
      {
        return (double)(uint64_t)getValueOfItemAtIndexAsSInt64(a1, a2);
      }
      else if (v9 == 23)
      {
        v8 = 0;
        CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 4, (uint64_t)&v8);
        result = COERCE_FLOAT(bswap32(v8));
        if (CurrentAtomData)
          return 0.0;
      }
      else if (v6 == 1)
      {
        if (FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)&v10))
          return v10;
        else
          return COERCE_DOUBLE(bswap64(*(unint64_t *)&v10));
      }
    }
  }
  return result;
}

float64x2_t FigBoxedMetadataGetValueOfItemAtIndexAsCGPoint(uint64_t a1, uint64_t a2)
{
  int v3;
  float64x2_t result;
  int CurrentAtomData;
  int v6;
  int8x8_t v7[2];

  v7[1] = *(int8x8_t *)MEMORY[0x1E0C80C00];
  v6 = 0;
  v3 = scalarReadSetup(a1, a2, &v6);
  result = 0uLL;
  if (!v3 && v6 == 70)
  {
    CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)v7);
    result = 0uLL;
    if (!CurrentAtomData)
      return vcvtq_f64_f32((float32x2_t)vrev32_s8(v7[0]));
  }
  return result;
}

float64x2_t FigBoxedMetadataGetValueOfItemAtIndexAsCGSize(uint64_t a1, uint64_t a2)
{
  int v3;
  float64x2_t result;
  int CurrentAtomData;
  int v6;
  int8x8_t v7[2];

  v7[1] = *(int8x8_t *)MEMORY[0x1E0C80C00];
  v6 = 0;
  v3 = scalarReadSetup(a1, a2, &v6);
  result = 0uLL;
  if (!v3 && v6 == 71)
  {
    CurrentAtomData = FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 8, (uint64_t)v7);
    result = 0uLL;
    if (!CurrentAtomData)
      return vcvtq_f64_f32((float32x2_t)vrev32_s8(v7[0]));
  }
  return result;
}

float64x2_t FigBoxedMetadataGetValueOfItemAtIndexAsCGRect(uint64_t a1, uint64_t a2)
{
  int v3;
  float64x2_t result;
  int v5;
  int8x16_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v3 = scalarReadSetup(a1, a2, &v5);
  result = 0uLL;
  if (!v3 && v5 == 72)
  {
    if (FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 16, (uint64_t)&v6))
      return (float64x2_t)0;
    else
      return vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vrev32q_s8(v6));
  }
  return result;
}

int8x16_t FigBoxedMetadataGetValueOfItemAtIndexAsCGAffineTransform@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  int8x16_t result;
  int8x16_t v6;
  int v7;
  int8x16_t v8[4];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  v7 = 0;
  if (!scalarReadSetup(a1, a2, &v7)
    && v7 == 79
    && !FigAtomStreamReadCurrentAtomData(a1 + 32, 0, 72, (uint64_t)v8))
  {
    v6 = vrev64q_s8(*(int8x16_t *)((char *)&v8[1] + 8));
    *a3 = vrev64q_s8(v8[0]);
    a3[1] = v6;
    result = vrev64q_s8(v8[3]);
    a3[2] = result;
  }
  return result;
}

uint64_t FigBoxedMetadataEndConstruction(uint64_t a1)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 216))
    {
      *(_BYTE *)(a1 + 216) = 0;
      if (CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(a1 + 16))
        || !FigAtomWriterBeginAtom(a1 + 144, 0, 0) && !FigAtomWriterEndAtom(a1 + 144))
      {
        FigAtomStreamInitWithBBuf(*(OpaqueCMBlockBuffer **)(a1 + 16), 0, 1, a1 + 32);
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294950976, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigBoxedMetadataAppendValue(uint64_t a1, unsigned int a2, uint64_t a3, int8x16_t *a4)
{
  int8x16_t *v6;
  int QuickTimeWellKnownTypeForLocalID;
  unint64_t WellKnownTypeDataSize;
  int8x16_t *v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  uint64_t appended;
  int8x16_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v20[4];
  uint64_t v21;
  char v22;

  v22 = 0;
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  if (!a1 || !a2 || a3 <= 0 || (v6 = a4) == 0)
  {
    v19 = 4294950976;
LABEL_35:
    v11 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    v10 = 0;
    goto LABEL_28;
  }
  if (!*(_BYTE *)(a1 + 216))
  {
    v19 = 4294950970;
    goto LABEL_35;
  }
  QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), a2);
  WellKnownTypeDataSize = getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, a3, &v22);
  if (!WellKnownTypeDataSize)
  {
LABEL_14:
    v10 = 0;
    goto LABEL_24;
  }
  if (WellKnownTypeDataSize != a3)
  {
    v19 = 4294950969;
    goto LABEL_35;
  }
  if (!v22)
    goto LABEL_14;
  v10 = 0;
  v11 = 4294950968;
  if (QuickTimeWellKnownTypeForLocalID <= 65)
  {
    switch(QuickTimeWellKnownTypeForLocalID)
    {
      case 23:
LABEL_19:
        v10 = 0;
        LODWORD(v20[0]) = bswap32(v6->i32[0]);
        break;
      case 24:
LABEL_20:
        v10 = 0;
        *(_QWORD *)&v20[0] = bswap64(v6->i64[0]);
        break;
      case 30:
LABEL_18:
        v10 = 0;
        v20[0] = vrev32q_s8(*v6);
        break;
      default:
        goto LABEL_28;
    }
LABEL_23:
    v6 = (int8x16_t *)v20;
  }
  else
  {
    switch(QuickTimeWellKnownTypeForLocalID)
    {
      case 'B':
      case 'L':
        v10 = 0;
        LOWORD(v20[0]) = bswap32(v6->u16[0]) >> 16;
        goto LABEL_23;
      case 'C':
      case 'M':
        goto LABEL_19;
      case 'F':
      case 'G':
        v10 = 0;
        *(int8x8_t *)&v20[0] = vrev32_s8(*(int8x8_t *)v6->i8);
        goto LABEL_23;
      case 'H':
        goto LABEL_18;
      case 'J':
      case 'N':
        goto LABEL_20;
      case 'O':
      case 'S':
        for (i = 0; i != 9; ++i)
          *(_QWORD *)((char *)v20 + i * 8) = bswap64(v6->u64[i]);
        v10 = 0;
        goto LABEL_23;
      case 'P':
      case 'Q':
        v16 = (int8x16_t *)malloc_type_malloc(a3, 0xAA4FA245uLL);
        v10 = v16;
        if (!v16)
        {
          v11 = 4294950974;
          goto LABEL_28;
        }
        v17 = (unint64_t)(int)a3 >> 2;
        if ((int)v17 >= 1)
        {
          v18 = 0;
          do
          {
            v16->i32[v18] = bswap32(v6->u32[v18]);
            ++v18;
          }
          while ((_DWORD)v17 != (_DWORD)v18);
        }
        v6 = v16;
        break;
      default:
        goto LABEL_28;
    }
  }
LABEL_24:
  v13 = a1 + 144;
  appended = FigAtomWriterBeginAtom(v13, a2, 0);
  if (!(_DWORD)appended)
  {
    appended = FigAtomWriterAppendData(v13, (uint64_t)v6, a3);
    if (!(_DWORD)appended)
      appended = FigAtomWriterEndAtom(v13);
  }
  v11 = appended;
LABEL_28:
  free(v10);
  return v11;
}

uint64_t FigBoxedMetadataAppendCFTypedValue(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int QuickTimeWellKnownTypeForLocalID;
  int v7;
  CFTypeID v8;
  CFIndex Length;
  const UInt8 *BytePtr;
  CFTypeID v11;
  CFStringEncoding v13;
  const __CFAllocator *v14;
  const __CFData *ExternalRepresentation;
  const __CFData *v16;
  CFTypeID TypeID;
  const __CFNumber *v18;
  CFNumberType v19;
  CFTypeID v20;
  CFIndex v21;
  _DWORD *v22;
  const void *v23;
  CFTypeID v24;
  CFTypeID v25;
  int8x8_t *v26;
  CFTypeID v27;
  unsigned int v28;
  uint64_t v29;
  OpaqueCMBlockBuffer *v30;
  size_t DataLength;
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  CFTypeID v36;
  const __CFNumber *v37;
  CFNumberType v38;
  CFTypeID v39;
  CFIndex v40;
  _QWORD *v41;
  const void *ValueAtIndex;
  CFTypeID v43;
  CFTypeID v44;
  int Count;
  unsigned int v46;
  CFTypeID v47;
  CFTypeID v48;
  CFTypeID v49;
  CFTypeID v50;
  CFIndex v51;
  uint64_t v52;
  const void *v53;
  CFTypeID v54;
  CFTypeID v55;
  uint64_t v56;
  uint64_t appended;
  uint64_t v59;
  _OWORD v60[3];
  uint64_t v61;
  CGRect point;
  __int128 v63;
  uint64_t v64;
  _OWORD valuePtr[4];
  uint64_t v66;

  v66 = 0;
  memset(valuePtr, 0, sizeof(valuePtr));
  if (!a1 || !a2 || !a3)
  {
    v59 = 4294950976;
    goto LABEL_102;
  }
  if (!*(_BYTE *)(a1 + 216))
  {
    v59 = 4294950970;
    goto LABEL_102;
  }
  QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), a2);
  v7 = QuickTimeWellKnownTypeForLocalID;
  if (QuickTimeWellKnownTypeForLocalID <= 23)
  {
    if ((QuickTimeWellKnownTypeForLocalID - 1) >= 2
      && (QuickTimeWellKnownTypeForLocalID - 4) >= 2)
    {
      if (QuickTimeWellKnownTypeForLocalID == 23)
      {
        TypeID = CFNumberGetTypeID();
        if (TypeID == CFGetTypeID((CFTypeRef)a3))
        {
          BytePtr = (const UInt8 *)valuePtr;
          v18 = (const __CFNumber *)a3;
          v19 = kCFNumberFloat32Type;
LABEL_35:
          CFNumberGetValue(v18, v19, valuePtr);
          v16 = 0;
          v26 = 0;
          LODWORD(valuePtr[0]) = bswap32(valuePtr[0]);
          Length = 4;
          goto LABEL_90;
        }
      }
      else
      {
LABEL_66:
        v47 = CFDataGetTypeID();
        if (v47 == CFGetTypeID((CFTypeRef)a3))
        {
          BytePtr = CFDataGetBytePtr((CFDataRef)a3);
          Length = CFDataGetLength((CFDataRef)a3);
LABEL_68:
          v16 = 0;
LABEL_69:
          v26 = 0;
LABEL_90:
          if (BytePtr && Length)
          {
            v56 = a1 + 144;
            appended = FigAtomWriterBeginAtom(v56, a2, 0);
            if (!(_DWORD)appended)
            {
              appended = FigAtomWriterAppendData(v56, (uint64_t)BytePtr, Length);
              if (!(_DWORD)appended)
                appended = FigAtomWriterEndAtom(v56);
            }
          }
          else
          {
            appended = FigSignalErrorAt(4294950974, 0, 0, 0, 0, 0, 0);
          }
          v35 = appended;
          if (v16)
            CFRelease(v16);
          goto LABEL_97;
        }
      }
    }
    else
    {
      v11 = CFStringGetTypeID();
      if (v11 == CFGetTypeID((CFTypeRef)a3))
      {
        if (v7 == 1 || v7 == 4)
          v13 = 134217984;
        else
          v13 = 268435712;
        v14 = CFGetAllocator((CFTypeRef)a1);
        ExternalRepresentation = CFStringCreateExternalRepresentation(v14, (CFStringRef)a3, v13, 0);
        if (!ExternalRepresentation)
        {
          v26 = 0;
LABEL_105:
          v35 = 4294950974;
          goto LABEL_97;
        }
        v16 = ExternalRepresentation;
        BytePtr = CFDataGetBytePtr(ExternalRepresentation);
        Length = CFDataGetLength(v16);
        goto LABEL_69;
      }
    }
LABEL_98:
    v59 = 4294950968;
LABEL_102:
    v34 = FigSignalErrorAt(v59, 0, 0, 0, 0, 0, 0);
LABEL_53:
    v35 = v34;
    v26 = 0;
    goto LABEL_97;
  }
  switch(QuickTimeWellKnownTypeForLocalID)
  {
    case 'A':
    case 'K':
      v8 = CFNumberGetTypeID();
      if (v8 != CFGetTypeID((CFTypeRef)a3))
        goto LABEL_98;
      Length = 1;
      BytePtr = (const UInt8 *)valuePtr;
      CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt8Type, valuePtr);
      goto LABEL_68;
    case 'B':
    case 'L':
      v25 = CFNumberGetTypeID();
      if (v25 != CFGetTypeID((CFTypeRef)a3))
        goto LABEL_98;
      Length = 2;
      BytePtr = (const UInt8 *)valuePtr;
      CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt16Type, valuePtr);
      v16 = 0;
      v26 = 0;
      LOWORD(valuePtr[0]) = bswap32(LOWORD(valuePtr[0])) >> 16;
      goto LABEL_90;
    case 'C':
    case 'M':
      v27 = CFNumberGetTypeID();
      if (v27 != CFGetTypeID((CFTypeRef)a3))
        goto LABEL_98;
      BytePtr = (const UInt8 *)valuePtr;
      v18 = (const __CFNumber *)a3;
      v19 = kCFNumberSInt32Type;
      goto LABEL_35;
    case 'D':
    case 'E':
      v64 = 0;
      v63 = 0u;
      memset(&point, 0, sizeof(point));
      v61 = 0;
      memset(&v60[1], 0, 32);
      if (QuickTimeWellKnownTypeForLocalID == 68)
        v28 = 1667330681;
      else
        v28 = 1668441443;
      v60[0] = 0uLL;
      FigThreadRunOnce(&sRegisterFigBoxedMetadataTypeOnce, (void (*)(void))registerFigBoxedMetadataType);
      v29 = sFigBoxedMetadataID;
      if (v29 != CFGetTypeID((CFTypeRef)a3))
        goto LABEL_98;
      if (!FigCFEqual(*(CFTypeRef *)(a3 + 24), *(CFTypeRef *)(a1 + 24)))
      {
        v59 = 4294950975;
        goto LABEL_102;
      }
      if (*(_BYTE *)(a3 + 216))
      {
        v59 = 4294950971;
        goto LABEL_102;
      }
      v30 = *(OpaqueCMBlockBuffer **)(a3 + 16);
      if (!v30 || (DataLength = CMBlockBufferGetDataLength(v30)) == 0)
      {
        v59 = 4294950969;
        goto LABEL_102;
      }
      v32 = DataLength;
      v33 = a1 + 144;
      v34 = FigAtomWriterBeginAtom(v33, a2, 0);
      if (!(_DWORD)v34)
      {
        v34 = FigAtomWriterInitWithParent(v33, (uint64_t)&point);
        if (!(_DWORD)v34)
        {
          v34 = FigAtomWriterBeginAtom((uint64_t)&point, v28, 0);
          if (!(_DWORD)v34)
          {
            v34 = FigAtomWriterInitWithParent((uint64_t)&point, (uint64_t)v60);
            if (!(_DWORD)v34)
            {
              v34 = FigAtomWriterBeginAtom((uint64_t)v60, 0x63697473u, 0);
              if (!(_DWORD)v34)
              {
                v34 = FigAtomWriterAppendBlockBufferData((uint64_t)v60, v30, 0, v32);
                if (!(_DWORD)v34)
                {
                  v34 = FigAtomWriterEndAtom((uint64_t)v60);
                  if (!(_DWORD)v34)
                  {
                    v34 = FigAtomWriterEndAtom((uint64_t)&point);
                    if (!(_DWORD)v34)
                      v34 = FigAtomWriterEndAtom(v33);
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_53;
    case 'F':
      point.origin.x = 0.0;
      point.origin.y = 0.0;
      v48 = CFDictionaryGetTypeID();
      if (v48 != CFGetTypeID((CFTypeRef)a3)
        || !CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)a3, &point.origin))
      {
        goto LABEL_98;
      }
      goto LABEL_75;
    case 'G':
      point.origin.x = 0.0;
      point.origin.y = 0.0;
      v49 = CFDictionaryGetTypeID();
      if (v49 != CFGetTypeID((CFTypeRef)a3)
        || !CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)a3, (CGSize *)&point))
      {
        goto LABEL_98;
      }
LABEL_75:
      v16 = 0;
      v26 = 0;
      *(int8x8_t *)&valuePtr[0] = vrev32_s8((int8x8_t)vcvt_f32_f64((float64x2_t)point.origin));
      BytePtr = (const UInt8 *)valuePtr;
      goto LABEL_89;
    case 'H':
      memset(&point, 0, sizeof(point));
      v50 = CFDictionaryGetTypeID();
      if (v50 != CFGetTypeID((CFTypeRef)a3) || !CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)a3, &point))
        goto LABEL_98;
      v16 = 0;
      v26 = 0;
      valuePtr[0] = vrev32q_s8((int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)point.origin), (float64x2_t)point.size));
      BytePtr = (const UInt8 *)valuePtr;
      Length = 16;
      goto LABEL_90;
    case 'I':
    case 'R':
      goto LABEL_66;
    case 'J':
    case 'N':
      v36 = CFNumberGetTypeID();
      if (v36 != CFGetTypeID((CFTypeRef)a3))
        goto LABEL_98;
      BytePtr = (const UInt8 *)valuePtr;
      v37 = (const __CFNumber *)a3;
      v38 = kCFNumberSInt64Type;
      goto LABEL_88;
    case 'O':
    case 'S':
      v39 = CFArrayGetTypeID();
      if (v39 != CFGetTypeID((CFTypeRef)a3) || CFArrayGetCount((CFArrayRef)a3) != 9)
        goto LABEL_98;
      v40 = 0;
      v41 = valuePtr;
      Length = 72;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, v40);
        v43 = CFNumberGetTypeID();
        if (v43 != CFGetTypeID(ValueAtIndex))
          goto LABEL_98;
        CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberDoubleType, v41);
        *v41 = bswap64(*v41);
        ++v41;
        if (++v40 == 9)
        {
LABEL_61:
          v16 = 0;
          v26 = 0;
          BytePtr = (const UInt8 *)valuePtr;
          goto LABEL_90;
        }
      }
    case 'P':
    case 'Q':
      point.origin.x = 0.0;
      point.origin.y = 0.0;
      v44 = CFArrayGetTypeID();
      if (v44 != CFGetTypeID((CFTypeRef)a3))
        goto LABEL_98;
      Count = CFArrayGetCount((CFArrayRef)a3);
      v46 = Count;
      if (v7 == 80)
      {
        if (Count <= 2)
          goto LABEL_98;
      }
      else if (Count <= 1)
      {
        goto LABEL_98;
      }
      Length = 8 * (Count & 0x7FFFFFFF);
      v26 = (int8x8_t *)malloc_type_malloc(Length, 0xCEE59F88uLL);
      if (!v26)
        goto LABEL_105;
      v51 = 0;
      v52 = v46;
      break;
    default:
      if (QuickTimeWellKnownTypeForLocalID == 24)
      {
        v55 = CFNumberGetTypeID();
        if (v55 != CFGetTypeID((CFTypeRef)a3))
          goto LABEL_98;
        BytePtr = (const UInt8 *)valuePtr;
        v37 = (const __CFNumber *)a3;
        v38 = kCFNumberFloat64Type;
LABEL_88:
        CFNumberGetValue(v37, v38, valuePtr);
        v16 = 0;
        v26 = 0;
        *(_QWORD *)&valuePtr[0] = bswap64(*(unint64_t *)&valuePtr[0]);
LABEL_89:
        Length = 8;
        goto LABEL_90;
      }
      if (QuickTimeWellKnownTypeForLocalID != 30)
        goto LABEL_66;
      v20 = CFArrayGetTypeID();
      if (v20 != CFGetTypeID((CFTypeRef)a3) || CFArrayGetCount((CFArrayRef)a3) != 4)
        goto LABEL_98;
      v21 = 0;
      v22 = valuePtr;
      Length = 16;
      do
      {
        v23 = CFArrayGetValueAtIndex((CFArrayRef)a3, v21);
        v24 = CFNumberGetTypeID();
        if (v24 != CFGetTypeID(v23))
          goto LABEL_98;
        CFNumberGetValue((CFNumberRef)v23, kCFNumberSInt32Type, v22);
        *v22 = bswap32(*v22);
        ++v22;
        ++v21;
      }
      while (v21 != 4);
      goto LABEL_61;
  }
  while (1)
  {
    v53 = CFArrayGetValueAtIndex((CFArrayRef)a3, v51);
    v54 = CFDictionaryGetTypeID();
    if (v54 != CFGetTypeID(v53) || !CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)v53, &point.origin))
      break;
    v26[v51++] = vrev32_s8((int8x8_t)vcvt_f32_f64((float64x2_t)point.origin));
    if (v52 == v51)
    {
      v16 = 0;
      BytePtr = (const UInt8 *)v26;
      goto LABEL_90;
    }
  }
  v35 = FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
LABEL_97:
  free(v26);
  return v35;
}

uint64_t FigBoxedMetadataAppendSInt8(uint64_t a1, unsigned int a2, int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t setupAndNormalizeAndAppendScalarValue(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t result;
  int v7;

  v7 = 0;
  result = scalarWriteSetup(a1, a2, 0, &v7);
  if (!(_DWORD)result)
    return normalizeAndAppendScalarValue(a1, a2, a3, v7);
  return result;
}

uint64_t FigBoxedMetadataAppendUInt8(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendSInt16(uint64_t a1, unsigned int a2, int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendUInt16(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendSInt32(uint64_t a1, unsigned int a2, int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendUInt32(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return setupAndNormalizeAndAppendScalarValue(a1, a2, a3);
}

uint64_t FigBoxedMetadataAppendFloat32(uint64_t a1, unsigned int a2, float a3)
{
  uint64_t result;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  unsigned int v14;

  v13 = 0;
  result = scalarWriteSetup(a1, a2, 0, &v13);
  if (!(_DWORD)result)
  {
    v7 = (v13 - 23);
    if (v7 <= 0x37)
    {
      if (((1 << (v13 - 23)) & 0xF81C0000000000) != 0)
        return normalizeAndAppendScalarValue(a1, a2, (uint64_t)a3, v13);
      if (v13 == 23)
      {
        v14 = bswap32(LODWORD(a3));
        v8 = (unint64_t *)&v14;
        v9 = a1;
        v10 = a2;
        v11 = 4;
        return appendScalarValue(v9, v10, (uint64_t)v8, v11);
      }
      if (v7 == 1)
      {
        v12 = bswap64(COERCE_UNSIGNED_INT64(a3));
        v8 = &v12;
        v9 = a1;
        v10 = a2;
        v11 = 8;
        return appendScalarValue(v9, v10, (uint64_t)v8, v11);
      }
    }
    return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t scalarWriteSetup(uint64_t a1, unsigned int a2, uint64_t a3, int *a4)
{
  int QuickTimeWellKnownTypeForLocalID;
  unint64_t WellKnownTypeDataSize;
  uint64_t v9;
  char v10;

  if (a1)
  {
    if (*(_BYTE *)(a1 + 216))
    {
      QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(*(const opaqueCMFormatDescription **)(a1 + 24), a2);
      *a4 = QuickTimeWellKnownTypeForLocalID;
      WellKnownTypeDataSize = getWellKnownTypeDataSize(QuickTimeWellKnownTypeForLocalID, a3, &v10);
      if (!a3 || WellKnownTypeDataSize == a3)
        return 0;
      v9 = 4294950969;
    }
    else
    {
      v9 = 4294950970;
    }
  }
  else
  {
    v9 = 4294950976;
  }
  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t normalizeAndAppendScalarValue(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  _OWORD v6[4];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  switch(a4)
  {
    case 'A':
    case 'B':
      LOBYTE(v6[0]) = a3;
      v4 = 1;
      return appendScalarValue(a1, a2, (uint64_t)v6, v4);
    case 'C':
    case 'M':
      LODWORD(v6[0]) = bswap32(a3);
      goto LABEL_12;
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'K':
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    case 'J':
    case 'N':
      *(_QWORD *)&v6[0] = bswap64(a3);
      goto LABEL_8;
    case 'L':
      LOWORD(v6[0]) = bswap32(a3) >> 16;
      v4 = 2;
      return appendScalarValue(a1, a2, (uint64_t)v6, v4);
    default:
      if (a4 == 23)
      {
        *(float *)v6 = (float)bswap32((float)a3);
LABEL_12:
        v4 = 4;
      }
      else
      {
        if (a4 != 24)
          return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
        *(double *)v6 = (double)bswap32(a3);
LABEL_8:
        v4 = 8;
      }
      return appendScalarValue(a1, a2, (uint64_t)v6, v4);
  }
}

uint64_t appendScalarValue(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t result;

  v6 = a1 + 144;
  result = FigAtomWriterBeginAtom(a1 + 144, a2, 0);
  if (!(_DWORD)result)
  {
    result = FigAtomWriterAppendData(v6, a3, a4);
    if (!(_DWORD)result)
      return FigAtomWriterEndAtom(v6);
  }
  return result;
}

uint64_t FigBoxedMetadataAppendFloat64(uint64_t a1, unsigned int a2, double a3)
{
  uint64_t result;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unint64_t v15;

  v14 = 0;
  result = scalarWriteSetup(a1, a2, 0, &v14);
  if (!(_DWORD)result)
  {
    v7 = (v14 - 23);
    if (v7 <= 0x37)
    {
      if (((1 << (v14 - 23)) & 0xF81C0000000000) != 0)
        return normalizeAndAppendScalarValue(a1, a2, (uint64_t)a3, v14);
      if (v14 == 23)
      {
        *(float *)&v12 = a3;
        v13 = bswap32(v12);
        v8 = (unint64_t *)&v13;
        v9 = a1;
        v10 = a2;
        v11 = 4;
        return appendScalarValue(v9, v10, (uint64_t)v8, v11);
      }
      if (v7 == 1)
      {
        v15 = bswap64(*(unint64_t *)&a3);
        v8 = &v15;
        v9 = a1;
        v10 = a2;
        v11 = 8;
        return appendScalarValue(v9, v10, (uint64_t)v8, v11);
      }
    }
    return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigBoxedMetadataAppendCGPoint(uint64_t a1, unsigned int a2, float64_t a3, float64_t a4)
{
  uint64_t result;
  float64x2_t v7;
  int v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v10 = 0;
  result = scalarWriteSetup(a1, a2, 8, &v10);
  if (!(_DWORD)result)
  {
    if (v10 == 70)
    {
      v7.f64[0] = a3;
      v7.f64[1] = a4;
      v11[0] = vrev32_s8((int8x8_t)vcvt_f32_f64(v7));
      return appendScalarValue(a1, a2, (uint64_t)v11, 8);
    }
    else
    {
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t FigBoxedMetadataAppendCGSize(uint64_t a1, unsigned int a2, float64_t a3, float64_t a4)
{
  uint64_t result;
  float64x2_t v7;
  int v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v10 = 0;
  result = scalarWriteSetup(a1, a2, 8, &v10);
  if (!(_DWORD)result)
  {
    if (v10 == 71)
    {
      v7.f64[0] = a3;
      v7.f64[1] = a4;
      v11[0] = vrev32_s8((int8x8_t)vcvt_f32_f64(v7));
      return appendScalarValue(a1, a2, (uint64_t)v11, 8);
    }
    else
    {
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t FigBoxedMetadataAppendCGRect(uint64_t a1, unsigned int a2, float64_t a3, float64_t a4, float64_t a5, float64_t a6)
{
  uint64_t result;
  float64x2_t v9;
  float64x2_t v10;
  int v15;
  int8x16_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  result = scalarWriteSetup(a1, a2, 16, &v15);
  if (!(_DWORD)result)
  {
    if (v15 == 72)
    {
      v9.f64[0] = a5;
      v10.f64[0] = a3;
      v9.f64[1] = a6;
      v10.f64[1] = a4;
      v16 = vrev32q_s8((int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v10), v9));
      return appendScalarValue(a1, a2, (uint64_t)&v16, 16);
    }
    else
    {
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t FigBoxedMetadataAppendCGAffineTransform(uint64_t a1, unsigned int a2, int8x16_t *a3)
{
  uint64_t result;
  int8x16_t v7;
  int v8;
  int8x16_t v9;
  uint64_t v10;
  int8x16_t v11;
  uint64_t v12;
  int8x16_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  result = scalarWriteSetup(a1, a2, 72, &v8);
  if (!(_DWORD)result)
  {
    if (v8 == 79)
    {
      v7 = a3[1];
      v9 = vrev64q_s8(*a3);
      v10 = 0;
      v11 = vrev64q_s8(v7);
      v12 = 0;
      v13 = vrev64q_s8(a3[2]);
      v14 = 61503;
      return appendScalarValue(a1, a2, (uint64_t)&v9, 72);
    }
    else
    {
      return FigSignalErrorAt(4294950968, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

void createDataTypeRegistryGlobalsOnce()
{
  const __CFAllocator *v0;
  const CFDictionaryKeyCallBacks *v1;
  const CFDictionaryValueCallBacks *v2;
  const CFArrayCallBacks *v3;
  const __CFArray *v4;
  __CFArray *Mutable;
  __CFArray *v6;
  const __CFArray *v7;
  CFArrayRef Copy;
  CFTypeRef *v9;
  _OWORD v10[4];
  void *v11[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  void *v15[2];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  const __CFString *v27;
  void *values[2];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  const __CFString *v40;
  uint64_t v41;
  CFRange v42;
  CFRange v43;

  v41 = *MEMORY[0x1E0C80C00];
  gfigMetadataDataTypeRegistryStorage = (uint64_t)malloc_type_calloc(1uLL, 0x38uLL, 0x60040CEC3798AuLL);
  if (gfigMetadataDataTypeRegistryStorage)
  {
    v38 = xmmword_1E28DC428;
    v39 = *(_OWORD *)&off_1E28DC438;
    v40 = CFSTR("com.apple.metadata.perspective-transform-float64");
    v34 = xmmword_1E28DC3E8;
    v35 = *(_OWORD *)&off_1E28DC3F8;
    v36 = xmmword_1E28DC408;
    v37 = *(_OWORD *)&off_1E28DC418;
    v30 = xmmword_1E28DC3A8;
    v31 = *(_OWORD *)&off_1E28DC3B8;
    v32 = xmmword_1E28DC3C8;
    v33 = *(_OWORD *)&off_1E28DC3D8;
    *(_OWORD *)values = xmmword_1E28DC388;
    v29 = *(_OWORD *)&off_1E28DC398;
    v25 = xmmword_1E28DC4F0;
    v26 = *(_OWORD *)&off_1E28DC500;
    v27 = CFSTR("3x3 perspective transform using 64-bit big endian floats");
    v21 = xmmword_1E28DC4B0;
    v22 = *(_OWORD *)&off_1E28DC4C0;
    v23 = xmmword_1E28DC4D0;
    v24 = *(_OWORD *)&off_1E28DC4E0;
    v17 = xmmword_1E28DC470;
    v18 = *(_OWORD *)&off_1E28DC480;
    v19 = xmmword_1E28DC490;
    v20 = *(_OWORD *)&off_1E28DC4A0;
    *(_OWORD *)v15 = xmmword_1E28DC450;
    v16 = *(_OWORD *)&off_1E28DC460;
    *(_OWORD *)v11 = xmmword_1E28DC518;
    v12 = *(_OWORD *)&off_1E28DC528;
    v13 = xmmword_1E28DC538;
    v14 = *(_OWORD *)&off_1E28DC548;
    v10[0] = xmmword_1E28DC558;
    v10[1] = *(_OWORD *)&off_1E28DC568;
    v10[2] = xmmword_1E28DC578;
    v10[3] = *(_OWORD *)off_1E28DC588;
    *(_QWORD *)gfigMetadataDataTypeRegistryStorage = FigReentrantMutexCreate();
    v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 8) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 16) = CFDictionaryCreateMutable(v0, 0, v1, v2);
    *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 24) = CFDictionaryCreateMutable(v0, 0, v1, v2);
    *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 32) = CFDictionaryCreateMutable(v0, 0, v1, v2);
    v3 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 48) = CFArrayCreate(v0, (const void **)values, 25, MEMORY[0x1E0C9B378]);
    v4 = CFArrayCreate(v0, (const void **)v11, 8, v3);
    Mutable = CFArrayCreateMutable(v0, 33, v3);
    v6 = Mutable;
    if (*(_QWORD *)gfigMetadataDataTypeRegistryStorage)
    {
      if (*(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 8))
      {
        if (*(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 16))
        {
          v7 = *(const __CFArray **)(gfigMetadataDataTypeRegistryStorage + 48);
          if (v7)
          {
            if (v4)
            {
              if (Mutable)
              {
                v42.location = 0;
                v42.length = 25;
                CFArrayAppendArray(Mutable, v7, v42);
                v43.location = 0;
                v43.length = 8;
                CFArrayAppendArray(v6, v4, v43);
                Copy = CFArrayCreateCopy(v0, v6);
                *(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 40) = Copy;
                if (Copy)
                {
                  if (createBaseDataTypes((const void **)values, (const void **)v15, 25)
                    && createBaseDataTypes((const void **)v11, (const void **)v10, 8))
                  {
                    goto LABEL_20;
                  }
                }
              }
            }
          }
        }
      }
    }
    FigReentrantMutexDestroy(*(_QWORD *)gfigMetadataDataTypeRegistryStorage);
    v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    if (*(_QWORD *)(gfigMetadataDataTypeRegistryStorage + 8))
    {
      CFRelease(*(CFTypeRef *)(gfigMetadataDataTypeRegistryStorage + 8));
      v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    }
    if (v9[2])
    {
      CFRelease(v9[2]);
      v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    }
    if (v9[6])
    {
      CFRelease(v9[6]);
      v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    }
    if (v9[5])
    {
      CFRelease(v9[5]);
      v9 = (CFTypeRef *)gfigMetadataDataTypeRegistryStorage;
    }
    free(v9);
    gfigMetadataDataTypeRegistryStorage = 0;
    if (v4)
LABEL_20:
      CFRelease(v4);
    if (v6)
      CFRelease(v6);
  }
}

void registerKnownDataTypesOnce()
{
  if (gfigMetadataDataTypeRegistryStorage)
  {
    registerKnownDataType(CFSTR("com.apple.quicktime.detected-face"), CFSTR("detected face"), CFSTR("com.apple.metadata.datatype.record-collection"));
    registerKnownDataType(CFSTR("com.apple.quicktime.detected-human-body"), CFSTR("detected human body"), CFSTR("com.apple.metadata.datatype.record-collection"));
    registerKnownDataType(CFSTR("com.apple.quicktime.detected-cat-body"), CFSTR("detected cat body"), CFSTR("com.apple.metadata.datatype.record-collection"));
    registerKnownDataType(CFSTR("com.apple.quicktime.detected-dog-body"), CFSTR("detected dog body"), CFSTR("com.apple.metadata.datatype.record-collection"));
    registerKnownDataType(CFSTR("com.apple.quicktime.detected-salient-object"), CFSTR("detected salient object"), CFSTR("com.apple.metadata.datatype.record-collection"));
    registerKnownDataType(CFSTR("com.apple.quicktime.location.ISO6709"), CFSTR("location in ISO 6709 format"), CFSTR("com.apple.metadata.datatype.UTF-8"));
    registerKnownDataType(CFSTR("com.apple.quicktime.direction"), CFSTR("direction"), CFSTR("com.apple.metadata.datatype.UTF-8"));
    registerKnownDataType(CFSTR("com.apple.quicktime.uuid"), CFSTR("UUID"), CFSTR("com.apple.metadata.datatype.UTF-8"));
    registerKnownDataType(CFSTR("com.apple.quicktime.milli-lux"), CFSTR("1/1000th of a Lux"), CFSTR("com.apple.metadata.datatype.uint32"));
  }
}

uint64_t createBaseDataTypes(const void **a1, const void **values, uint64_t a3)
{
  uint64_t v3;
  const __CFAllocator *v6;
  const CFDictionaryKeyCallBacks *v7;
  const CFDictionaryValueCallBacks *v8;
  uint64_t result;
  const void *v10;
  const void *v11;

  if (a3 < 1)
    return 1;
  v3 = a3;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  while (1)
  {
    result = (uint64_t)CFDictionaryCreate(v6, (const void **)&kFigMetadata_DataTypeRegistry_RegistrySpecification_Description, values, 1, v7, v8);
    if (!result)
      break;
    v10 = (const void *)result;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(gfigMetadataDataTypeRegistryStorage + 8), *a1, (const void *)result);
    CFRelease(v10);
    v11 = *a1++;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(gfigMetadataDataTypeRegistryStorage + 16), v11, v11);
    ++values;
    if (!--v3)
      return 1;
  }
  return result;
}

void registerKnownDataType(const __CFString *a1, const void *a2, void *a3)
{
  const __CFArray *v5;
  const __CFArray *v6;
  void *values;

  values = a3;
  v5 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  if (v5)
  {
    v6 = v5;
    doFigMetadataDataTypeRegistryRegisterDataType(gfigMetadataDataTypeRegistryStorage, a1, a2, v5);
    CFRelease(v6);
  }
  else
  {
    FigSignalErrorAt(4294950996, 0, 0, 0, 0, 0, 0);
  }
}

double boxedMetadataInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

double boxedMetadataFinalize(uint64_t a1)
{
  const void *v2;
  _OWORD *v3;
  const void *v4;
  double result;

  v3 = (_OWORD *)(a1 + 16);
  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  v4 = *(const void **)(a1 + 24);
  if (v4)
    CFRelease(v4);
  result = 0.0;
  v3[11] = 0u;
  v3[12] = 0u;
  v3[9] = 0u;
  v3[10] = 0u;
  v3[7] = 0u;
  v3[8] = 0u;
  v3[5] = 0u;
  v3[6] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  *v3 = 0u;
  return result;
}

uint64_t boxedMetadataEqual(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = FigCFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if ((_DWORD)result)
    return FigCFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24)) != 0;
  return result;
}

__CFString *boxedMetadataCopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  CFIndex v3;
  CFAllocatorRef v4;
  uint64_t v5;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = CFGetRetainCount((CFTypeRef)a1);
  v4 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("CMBoxedMetadata %p retainCount: %ld allocator: %p\n"), a1, v3, v4);
  v5 = 84;
  if (!*(_BYTE *)(a1 + 216))
    v5 = 70;
  CFStringAppendFormat(Mutable, 0, CFSTR("\tbbuf %p\n\tisUnderConstruction = %c\n"), *(_QWORD *)(a1 + 16), v5);
  return Mutable;
}

uint64_t FigInMemorySerializerAppendBlockBuffer(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, CMBlockBufferRef theBuffer)
{
  OpaqueCMBlockBuffer *v6;
  unint64_t DataLength;
  vm_address_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t DataPointer;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *destination;
  vm_address_t v23;
  vm_address_t v24;
  CMBlockBufferRef theBuffera;

  v6 = theBuffer;
  theBuffera = 0;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  v13 = DataLength;
  v24 = DataLength;
  if (!a1)
  {
    if (DataLength >= 0x401 && FigMemoryOriginIsBlockBufferSendable(a5, v6))
    {
      DataPointer = FigMemoryOriginSetBlockBufferInIPCMessageData(a5, v6, 0, 0, &v24);
      if ((_DWORD)DataPointer)
        goto LABEL_29;
      v13 = v24;
    }
    v18 = 0;
    v19 = 1024;
    if (v13 < 0x400)
      v19 = v13;
    v20 = v19 + 9;
    goto LABEL_24;
  }
  if (a2 <= 8)
  {
    DataPointer = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v14 = a2 - 9;
    v15 = 1024;
    if (v14 < 0x400)
      v15 = v14;
    if (DataLength <= v15)
    {
      v18 = CMBlockBufferCopyDataBytes(v6, 0, DataLength, (void *)(a1 + 9));
      if ((_DWORD)v18)
        goto LABEL_25;
      *(_BYTE *)a1 = 0;
      goto LABEL_23;
    }
    v23 = 0;
    if (FigMemoryOriginIsBlockBufferSendable(a5, v6))
    {
LABEL_13:
      v18 = FigMemoryOriginSetBlockBufferInIPCMessageData(a5, v6, a1 + 9, v14, &v23);
      *(_BYTE *)a1 = 1;
      v13 = v23;
LABEL_23:
      *(_QWORD *)(a1 + 1) = v13;
      v20 = v13 + 9;
LABEL_24:
      *a3 = v20;
      goto LABEL_25;
    }
    destination = 0;
    DataPointer = (uint64_t)FigMemoryPoolCreateBlockBuffer(a4, v13, &theBuffera, v16);
    if (!(_DWORD)DataPointer)
    {
      DataPointer = CMBlockBufferGetDataPointer(theBuffera, 0, 0, 0, (char **)&destination);
      if (!(_DWORD)DataPointer)
      {
        DataPointer = CMBlockBufferCopyDataBytes(v6, 0, v13, destination);
        if (!(_DWORD)DataPointer)
        {
          if (gGMFigKTraceEnabled == 1)
            kdebug_trace();
          v6 = theBuffera;
          goto LABEL_13;
        }
      }
    }
  }
LABEL_29:
  v18 = DataPointer;
LABEL_25:
  if (theBuffera)
    CFRelease(theBuffera);
  return v18;
}

uint64_t FigInMemoryDeserializerCopyBlockBuffer(CFAllocatorRef blockAllocator, uint64_t a2, unint64_t a3, int a4, uint64_t a5, CMBlockBufferRef *blockBufferOut)
{
  unint64_t v7;
  uint64_t result;
  CMBlockBufferRef v10;
  uint64_t v11;
  CMBlockBufferRef destinationBuffer;

  destinationBuffer = 0;
  if (a3 <= 8)
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  v7 = *(_QWORD *)(a2 + 1);
  if (v7 >= 0xFFFFFFFFFFFFFFF7 || v7 + 9 > a3)
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  if (*(_BYTE *)a2 == 1)
    return FigMemoryRecipientCopyBlockBufferFromIPCMessageData(blockAllocator, a5, a2 + 9, v7, blockBufferOut);
  if (*(_BYTE *)a2)
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  if (a4)
    return CMBlockBufferCreateWithMemoryBlock(blockAllocator, (void *)(a2 + 9), v7, (CFAllocatorRef)*MEMORY[0x1E0C9AE20], 0, 0, v7, 0, blockBufferOut);
  result = CMBlockBufferCreateWithMemoryBlock(blockAllocator, 0, v7, blockAllocator, 0, 0, v7, 1u, &destinationBuffer);
  v10 = destinationBuffer;
  if ((_DWORD)result
    || (result = CMBlockBufferReplaceDataBytes((const void *)(a2 + 9), destinationBuffer, 0, *(_QWORD *)(a2 + 1)),
        v10 = destinationBuffer,
        (_DWORD)result))
  {
    if (v10)
    {
      v11 = result;
      CFRelease(v10);
      return v11;
    }
  }
  else
  {
    *blockBufferOut = destinationBuffer;
  }
  return result;
}

uint64_t FigInMemorySerializerAppendCMSampleBuffer(uint64_t *a1, unint64_t a2, _QWORD *a3, CMSampleBufferRef sbuf, const __CFArray *a5, unsigned int a6, uint64_t a7, uint64_t a8, const opaqueCMFormatDescription **a9, int a10)
{
  const opaqueCMFormatDescription *v11;
  char v17;
  CFTypeRef v18;
  uint64_t CopyWithNoData;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  opaqueCMSampleBuffer *v26;
  unint64_t v27;
  const opaqueCMFormatDescription *v28;
  CFTypeRef v29;
  uint64_t v30;
  uint64_t v33;
  unint64_t v34;
  CFTypeRef v35;
  CFTypeRef cf;
  CMBlockBufferRef theBuffer;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  CFTypeRef v40;
  uint64_t v41;
  CFTypeRef v42;

  v11 = *a9;
  v42 = 0;
  v40 = 0;
  v41 = 0;
  dataPointerOut = 0;
  lengthAtOffsetOut = 0;
  cf = 0;
  theBuffer = 0;
  v35 = 0;
  if (a2 <= 0x17)
    goto LABEL_45;
  v34 = a2 - 24;
  v33 = (uint64_t)(a1 + 3);
  dataPointerOut = (char *)(a1 + 3);
  lengthAtOffsetOut = a2 - 24;
  if (!sbuf)
    goto LABEL_45;
  v17 = a6;
  if (CMSampleBufferDataIsReady(sbuf))
  {
    v18 = CFRetain(sbuf);
    v40 = v18;
    goto LABEL_9;
  }
  if ((a6 & 1) == 0 || (v17 & 2) == 0)
  {
LABEL_45:
    CopyWithNoData = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
    goto LABEL_24;
  }
  CopyWithNoData = FigSampleBufferCreateCopyWithNoData((const __CFAllocator *)*MEMORY[0x1E0C9AE00], sbuf, (CMSampleBufferRef *)&v40);
  if ((_DWORD)CopyWithNoData)
  {
LABEL_24:
    v23 = CopyWithNoData;
    goto LABEL_30;
  }
  v18 = v40;
LABEL_9:
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  CopyWithNoData = FigRemote_CopyReplacementAttachmentsForSampleBuffer(v18, a5, (__CFDictionary **)&cf, (__CFDictionary **)&v35);
  if ((_DWORD)CopyWithNoData)
    goto LABEL_24;
  v20 = (a6 >> 2) & 1;
  while (1)
  {
    while (1)
    {
      v21 = FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID((opaqueCMSampleBuffer *)v40, (const __CFDictionary *)cf, (const __CFDictionary *)v35, v20, (uint64_t)dataPointerOut, lengthAtOffsetOut, &v41, v11, &v42, a10);
      if ((_DWORD)v21 != -12572)
        break;
      dataPointerOut = 0;
      lengthAtOffsetOut = 0;
    }
    v23 = v21;
    if ((_DWORD)v21)
      break;
    v24 = v41;
    a1[1] = v41;
    if ((v17 & 2) == 0)
    {
      if (dataPointerOut)
      {
        v25 = &dataPointerOut[v24];
        v26 = (opaqueCMSampleBuffer *)v40;
        v27 = lengthAtOffsetOut - v24;
      }
      else
      {
        v26 = (opaqueCMSampleBuffer *)v40;
        v25 = 0;
        v27 = 0;
      }
      CopyWithNoData = (uint64_t)FigInMemorySerializationAddDataBufferFromCMSampleBuffer((uint64_t)v25, v27, &v41, a7, a8, v26);
      if ((_DWORD)CopyWithNoData)
        goto LABEL_24;
      a1[2] = v41;
    }
    if (dataPointerOut)
    {
      v28 = *a9;
      v29 = v42;
      *a9 = (const opaqueCMFormatDescription *)v42;
      if (v29)
        CFRetain(v29);
      if (v28)
        CFRelease(v28);
      v23 = 0;
      break;
    }
    CopyWithNoData = (uint64_t)FigMemoryPoolCreateBlockBuffer(a7, a1[2] + a1[1], &theBuffer, v22);
    if (!(_DWORD)CopyWithNoData)
    {
      CopyWithNoData = FigMemoryOriginSetBlockBufferInIPCMessageData(a8, theBuffer, v33, v34, (unint64_t *)&v41);
      if (!(_DWORD)CopyWithNoData)
      {
        *a1 = v41;
        CopyWithNoData = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
        if (!(_DWORD)CopyWithNoData)
          continue;
      }
    }
    goto LABEL_24;
  }
LABEL_30:
  if (a3)
  {
    v30 = *a1;
    if (!*a1)
      v30 = a1[1] + a1[2];
    *a3 = v30 + 24;
  }
  if (cf)
    CFRelease(cf);
  if (v35)
    CFRelease(v35);
  if (v42)
    CFRelease(v42);
  if (v40)
    CFRelease(v40);
  if (theBuffer)
    CFRelease(theBuffer);
  return v23;
}

OpaqueCMBlockBuffer *FigInMemorySerializationAddDataBufferFromCMSampleBuffer(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, CMSampleBufferRef sbuf)
{
  OpaqueCMBlockBuffer *result;

  if (!sbuf || CMSampleBufferDataIsReady(sbuf) != 1)
    return (OpaqueCMBlockBuffer *)FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
  result = CMSampleBufferGetDataBuffer(sbuf);
  if (result)
    return (OpaqueCMBlockBuffer *)FigInMemorySerializerAppendBlockBuffer(a1, a2, a3, a4, a5, result);
  *a3 = 0;
  return result;
}

uint64_t FigInMemoryDeserializerCopyCMSampleBuffer(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, char a5, const opaqueCMFormatDescription **a6, CFTypeRef *a7, CMSampleBufferRef *a8)
{
  unint64_t v16;
  uint64_t DataPointer;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  OpaqueCMBlockBuffer *v22;
  uint64_t SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor;
  size_t v25;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;
  CFTypeRef cf;

  theBuffer = 0;
  cf = 0;
  dataPointerOut = 0;
  if (a3 <= 0x17)
    goto LABEL_22;
  v16 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
  {
    v19 = *(_QWORD *)(a2 + 16);
    if (v19 < 0xFFFFFFFFFFFFFFE8)
    {
      v18 = *(_QWORD *)(a2 + 8);
      if (-25 - v19 >= v18 && v19 + v18 + 24 <= a3)
      {
        v20 = (char *)(a2 + 24);
        dataPointerOut = (char *)(a2 + 24);
        if (v19)
          goto LABEL_10;
LABEL_16:
        v22 = 0;
LABEL_17:
        SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor(a1, (uint64_t)v20, v18, (a5 & 1) == 0, v22, a6, a7, a8);
        v22 = (OpaqueCMBlockBuffer *)cf;
        if (!cf)
          goto LABEL_19;
        goto LABEL_18;
      }
    }
    goto LABEL_22;
  }
  v25 = 0;
  if (v16 >= 0xFFFFFFFFFFFFFFE8 || v16 + 24 > a3)
    goto LABEL_22;
  DataPointer = FigMemoryRecipientCopyBlockBufferFromIPCMessageData(a1, a4, a2 + 24, v16, &theBuffer);
  if ((_DWORD)DataPointer)
    goto LABEL_23;
  DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &v25, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_23;
  v18 = *(_QWORD *)(a2 + 8);
  v19 = *(_QWORD *)(a2 + 16);
  if (__CFADD__(v18, v19) || v25 < v19 + v18)
  {
LABEL_22:
    DataPointer = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
LABEL_23:
    SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = DataPointer;
    goto LABEL_19;
  }
  v20 = dataPointerOut;
  if (!v19)
    goto LABEL_16;
LABEL_10:
  v21 = FigInMemoryDeserializerCopyBlockBuffer(a1, (uint64_t)&v20[v18], v19, 0, a4, (CMBlockBufferRef *)&cf);
  v22 = (OpaqueCMBlockBuffer *)cf;
  if (!(_DWORD)v21)
  {
    v20 = dataPointerOut;
    v18 = *(_QWORD *)(a2 + 8);
    goto LABEL_17;
  }
  SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = v21;
  if (cf)
LABEL_18:
    CFRelease(v22);
LABEL_19:
  if (theBuffer)
    CFRelease(theBuffer);
  return SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor;
}

CFIndex FigInMemorySerializerAppendCFType(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *a4, char a5, uint64_t a6, uint64_t a7)
{
  unint64_t v12;
  _BOOL8 v13;
  size_t v14;
  char *v15;
  CFIndex v16;
  uint64_t v17;
  CFIndex v18;
  vm_address_t v19;
  uint64_t DataPointer;
  uint64_t v21;
  CMBlockBufferRef theBuffer;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  vm_address_t v26;

  lengthAtOffsetOut = 0;
  v26 = 0;
  theBuffer = 0;
  dataPointerOut = 0;
  if (a3)
    *a3 = 0;
  if (a4)
  {
    if (a1 && a2 > 0xF)
    {
      v12 = a2 - 16;
      dataPointerOut = (char *)(a1 + 16);
      lengthAtOffsetOut = a2 - 16;
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      v13 = (a5 & 1) == 0;
      v14 = a2 - 16;
      v15 = (char *)(a1 + 16);
      while (1)
      {
        while (1)
        {
          v16 = FigRemote_WriteSerializedAtomDataForCFType(a4, v13, (uint64_t)v15, v14, &v26);
          if ((_DWORD)v16 != -12572)
            break;
          v14 = 0;
          v15 = 0;
          dataPointerOut = 0;
          lengthAtOffsetOut = 0;
        }
        v18 = v16;
        if ((_DWORD)v16)
          break;
        v19 = v26;
        *(_QWORD *)(a1 + 8) = v26;
        if (dataPointerOut)
        {
          if (!a3)
            goto LABEL_19;
          if (v19)
          {
            v18 = 0;
            if (*(_QWORD *)a1)
              v21 = *(_QWORD *)a1 + 16;
            else
              v21 = v19 + 16;
            *a3 = v21;
          }
          else
          {
            v18 = 0;
            *a3 = 0;
          }
          break;
        }
        DataPointer = (uint64_t)FigMemoryPoolCreateBlockBuffer(a6, v19, &theBuffer, v17);
        if ((_DWORD)DataPointer)
          goto LABEL_27;
        DataPointer = FigMemoryOriginSetBlockBufferInIPCMessageData(a7, theBuffer, a1 + 16, v12, &v26);
        if ((_DWORD)DataPointer)
          goto LABEL_27;
        *(_QWORD *)a1 = v26;
        DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
        if ((_DWORD)DataPointer)
          goto LABEL_27;
        v15 = dataPointerOut;
        v14 = lengthAtOffsetOut;
      }
    }
    else
    {
      DataPointer = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
LABEL_27:
      v18 = DataPointer;
    }
  }
  else
  {
LABEL_19:
    v18 = 0;
  }
  if (theBuffer)
    CFRelease(theBuffer);
  return v18;
}

CFIndex FigInMemorySerializerAppendCFDictionary(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *cf, char a5, uint64_t a6, uint64_t a7)
{
  CFTypeID v14;

  if (a3)
    *a3 = 0;
  if (!cf)
    return 0;
  v14 = CFGetTypeID(cf);
  if (v14 == CFDictionaryGetTypeID())
    return FigInMemorySerializerAppendCFType(a1, a2, a3, cf, a5, a6, a7);
  else
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
}

CFIndex FigInMemorySerializerAppendCFURL(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *cf, char a5, uint64_t a6, uint64_t a7)
{
  CFTypeID v14;

  if (!cf)
    return 0;
  v14 = CFGetTypeID(cf);
  if (v14 == CFURLGetTypeID())
    return FigInMemorySerializerAppendCFType(a1, a2, a3, cf, a5, a6, a7);
  else
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
}

CFIndex FigInMemorySerializerAppendCFString(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *cf, char a5, uint64_t a6, uint64_t a7)
{
  CFTypeID v14;

  if (!cf)
    return 0;
  v14 = CFGetTypeID(cf);
  if (v14 == CFStringGetTypeID())
    return FigInMemorySerializerAppendCFType(a1, a2, a3, cf, a5, a6, a7);
  else
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
}

CFIndex FigInMemorySerializerAppendCMFormatDescription(uint64_t a1, unint64_t a2, uint64_t *a3, __CFString *cf, char a5, uint64_t a6, uint64_t a7)
{
  CFTypeID v14;

  if (!cf)
    return 0;
  v14 = CFGetTypeID(cf);
  if (v14 == CMFormatDescriptionGetTypeID())
    return FigInMemorySerializerAppendCFType(a1, a2, a3, cf, a5, a6, a7);
  else
    return FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
}

uint64_t FigInMemoryDeserializerCopyCFType(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  unint64_t v8;
  uint64_t DataPointer;
  size_t v10;
  char *v11;
  uint64_t v12;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;

  dataPointerOut = 0;
  theBuffer = 0;
  if (!a3)
    return 0;
  if (a3 <= 0xF || !a2 || !a5)
    goto LABEL_19;
  v8 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
  {
    v10 = *(_QWORD *)(a2 + 8);
    if (v10 < 0xFFFFFFFFFFFFFFF0 && v10 + 16 <= a3)
    {
      v11 = (char *)(a2 + 16);
      dataPointerOut = (char *)(a2 + 16);
      goto LABEL_15;
    }
    goto LABEL_19;
  }
  lengthAtOffsetOut = 0;
  if (v8 >= 0xFFFFFFFFFFFFFFF0 || v8 + 16 > a3)
  {
LABEL_19:
    DataPointer = FigSignalErrorAt(4294947916, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  DataPointer = FigMemoryRecipientCopyBlockBufferFromIPCMessageData(a1, a4, a2 + 16, v8, &theBuffer);
  if (!(_DWORD)DataPointer)
  {
    DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if (!(_DWORD)DataPointer)
    {
      v10 = *(_QWORD *)(a2 + 8);
      if (lengthAtOffsetOut >= v10)
      {
        v11 = dataPointerOut;
LABEL_15:
        DataPointer = FigRemote_CreateCFTypeFromSerializedAtomData(a1, (uint64_t)v11, v10, a5);
        goto LABEL_16;
      }
      goto LABEL_19;
    }
  }
LABEL_16:
  v12 = DataPointer;
  if (theBuffer)
    CFRelease(theBuffer);
  return v12;
}

uint64_t FigInMemoryDeserializerCopyCFDictionary(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v6;
  CFTypeID v7;
  CFTypeRef v8;
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  v6 = FigInMemoryDeserializerCopyCFType(a1, a2, a3, a4, &cf);
  if (!(_DWORD)v6)
  {
    if (!cf)
    {
      v8 = 0;
      goto LABEL_6;
    }
    v7 = CFGetTypeID(cf);
    if (v7 == CFDictionaryGetTypeID())
    {
      v8 = cf;
LABEL_6:
      v9 = 0;
      *a5 = v8;
      return v9;
    }
    v6 = FigSignalErrorAt(4294947914, 0, 0, 0, 0, 0, 0);
  }
  v9 = v6;
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t FigInMemoryDeserializerCopyCFURL(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v6;
  CFTypeID v7;
  CFTypeRef v8;
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  v6 = FigInMemoryDeserializerCopyCFType(a1, a2, a3, a4, &cf);
  if (!(_DWORD)v6)
  {
    if (!cf)
    {
      v8 = 0;
      goto LABEL_6;
    }
    v7 = CFGetTypeID(cf);
    if (v7 == CFURLGetTypeID())
    {
      v8 = cf;
LABEL_6:
      v9 = 0;
      *a5 = v8;
      return v9;
    }
    v6 = FigSignalErrorAt(4294947914, 0, 0, 0, 0, 0, 0);
  }
  v9 = v6;
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t FigInMemoryDeserializerCopyCFString(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v6;
  CFTypeID v7;
  CFTypeRef v8;
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  v6 = FigInMemoryDeserializerCopyCFType(a1, a2, a3, a4, &cf);
  if (!(_DWORD)v6)
  {
    if (!cf)
    {
      v8 = 0;
      goto LABEL_6;
    }
    v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      v8 = cf;
LABEL_6:
      v9 = 0;
      *a5 = v8;
      return v9;
    }
    v6 = FigSignalErrorAt(4294947914, 0, 0, 0, 0, 0, 0);
  }
  v9 = v6;
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t FigInMemoryDeserializerCopyCMFormatDescription(const __CFAllocator *a1, uint64_t a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v6;
  CFTypeID v7;
  CFTypeRef v8;
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  v6 = FigInMemoryDeserializerCopyCFType(a1, a2, a3, a4, &cf);
  if (!(_DWORD)v6)
  {
    if (!cf)
    {
      v8 = 0;
      goto LABEL_6;
    }
    v7 = CFGetTypeID(cf);
    if (v7 == CMFormatDescriptionGetTypeID())
    {
      v8 = cf;
LABEL_6:
      v9 = 0;
      *a5 = v8;
      return v9;
    }
    v6 = FigSignalErrorAt(4294947914, 0, 0, 0, 0, 0, 0);
  }
  v9 = v6;
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t FigTraceLoggingStart()
{
  char *v1;
  const char *v2;
  __int128 v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = "/tmp/qttrace";
  v3 = unk_1E28DC948;
  printf("clear kernel trace buffer, reset defaults");
  v2 = "-r";
  FigTraceCommandWithArguments("/tmp/qttrace", (uint64_t)&v1);
  printf("disable kernel trace wraparound");
  v2 = "-n";
  FigTraceCommandWithArguments("/tmp/qttrace", (uint64_t)&v1);
  return FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTraceCommandWithArguments(const char *a1, uint64_t a2)
{
  stat v5;

  memset(&v5, 0, sizeof(v5));
  if (stat("/tmp/qttrace", &v5))
  {
    puts("Error, must create /tmp/qttrace before enabling trace logging.");
    puts("  Try the following:");
    puts("      cp /usr/local/bin/trace /tmp/qttrace");
    puts("      sudo chown root:admin \"/tmp/qttrace\"");
    puts("      sudo chmod 4750 \"/tmp/qttrace\"");
    printf("Error %d creating /tmp/qttrace.\n", -1);
    return unlink("/tmp/qttrace");
  }
  else
  {
    printf(" : system( %s", a1);
    printf(" %s", *(const char **)(a2 + 8));
    puts(")");
    return fflush((FILE *)*MEMORY[0x1E0C80C20]);
  }
}

uint64_t FigTraceLoggingEnd()
{
  return FigSignalErrorAt(4294954499, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTraceLoggingDumpToFile()
{
  return FigSignalErrorAt(4294954499, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionTextEmphasisGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
  return sFigCaptionTextEmphasisID;
}

uint64_t RegisterFigCaptionTextEmphasisType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionTextEmphasisID = result;
  return result;
}

uint64_t FigCaptionTextEmphasisGetEmphasisStyle(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t FigCaptionTextEmphasisGetMarkingStyle(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t FigCaptionTextEmphasisGetPredefinedMark(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t FigCaptionTextEmphasisGetCustomMark(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t FigCaptionTextEmphasisGetColor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t FigCaptionTextEmphasisGetRubyPosition(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t FigCaptionTextEmphasisCreate(uint64_t a1, int a2, int a3, int a4, const void *a5, CGColor *a6, const void *a7, _QWORD *a8)
{
  _DWORD *Instance;
  _QWORD *v16;
  CFTypeRef v17;
  CFTypeRef v18;

  if (!a8)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
  Instance = (_DWORD *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    v16 = Instance;
    Instance[4] = a2;
    Instance[5] = a3;
    Instance[6] = a4;
    if (a5)
      v17 = CFRetain(a5);
    else
      v17 = 0;
    v16[4] = v17;
    v16[5] = CGColorRetain(a6);
    if (a7)
      v18 = CFRetain(a7);
    else
      v18 = 0;
    v16[6] = v18;
    *a8 = v16;
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigCaptionTextEmphasisCreateNone(uint64_t a1, CGColor *a2, const void *a3, _QWORD *a4)
{
  return FigCaptionTextEmphasisCreate(a1, 0, 0, 0, 0, a2, a3, a4);
}

uint64_t FigCaptionTextEmphasisCreateAuto(uint64_t a1, CGColor *a2, const void *a3, _QWORD *a4)
{
  return FigCaptionTextEmphasisCreate(a1, 1, 0, 0, 0, a2, a3, a4);
}

double fcte_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void fcte_Finalize(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
  CGColorRelease(*(CGColorRef *)(a1 + 40));
  v3 = *(const void **)(a1 + 48);
  if (v3)
    CFRelease(v3);
}

const void *fcte_Equal(const void *result, uint64_t a2)
{
  const void *v3;
  CFTypeID v4;
  CFTypeID v5;
  const void *v6;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID(result);
    FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
    result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionTextEmphasisID)
      {
        v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
        if (v5 != sFigCaptionTextEmphasisID
          || *((_DWORD *)v3 + 4) != *(_DWORD *)(a2 + 16)
          || *((_DWORD *)v3 + 5) != *(_DWORD *)(a2 + 20)
          || *((_DWORD *)v3 + 6) != *(_DWORD *)(a2 + 24))
        {
          return 0;
        }
        result = (const void *)FigCFEqual(*((CFTypeRef *)v3 + 4), *(CFTypeRef *)(a2 + 32));
        if (!(_DWORD)result)
          return result;
        if (FigCFEqual(*((CFTypeRef *)v3 + 6), *(CFTypeRef *)(a2 + 48)))
          return (const void *)CGColorEqualToColor(*((CGColorRef *)v3 + 5), *(CGColorRef *)(a2 + 40));
        v6 = (const void *)*((_QWORD *)v3 + 6);
        if (v6)
        {
          if (*(_QWORD *)(a2 + 48))
            return 0;
        }
        else
        {
          if (FigCFEqual(*(CFTypeRef *)(a2 + 48), CFSTR("RubyPositionNone")))
            return (const void *)CGColorEqualToColor(*((CGColorRef *)v3 + 5), *(CGColorRef *)(a2 + 40));
          if (*(_QWORD *)(a2 + 48))
            return 0;
          v6 = (const void *)*((_QWORD *)v3 + 6);
        }
        result = (const void *)FigCFEqual(v6, CFSTR("RubyPositionNone"));
        if ((_DWORD)result)
          return (const void *)CGColorEqualToColor(*((CGColorRef *)v3 + 5), *(CGColorRef *)(a2 + 40));
      }
    }
  }
  return result;
}

CFHashCode fcte_Hash(_QWORD *a1)
{
  CFTypeID v2;
  const void *v3;
  CFHashCode v4;
  const void *v5;
  const void *v6;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&sRegisterFigCaptionTextEmphasisTypeOnce, (void (*)(void))RegisterFigCaptionTextEmphasisType);
  if (v2 != sFigCaptionTextEmphasisID)
    return 0;
  v3 = (const void *)a1[6];
  if (v3)
    v4 = CFHash(v3);
  else
    v4 = 0;
  v5 = (const void *)a1[4];
  if (v5)
    v4 ^= CFHash(v5);
  v6 = (const void *)a1[5];
  if (v6)
    v4 ^= CFHash(v6);
  return v4;
}

CFStringRef fcte_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionTextEmphasis %p]"), a1);
}

CFStringRef fcte_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionTextEmphasis %p]"), a1);
}

OSStatus CMAudioClockCreate(CFAllocatorRef allocator, CMClockRef *clockOut)
{
  void *v4;
  void *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;

  if (!FigPreferAudioSessionClock())
    return CMAudioDeviceClockCreate(allocator, 0, clockOut);
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v4 = getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr;
  v10 = getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr;
  if (!getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr)
  {
    v5 = (void *)MediaToolboxLibrary();
    v4 = dlsym(v5, "FigAudioSessionClockCreateForSharedAudioSession");
    v8[3] = (uint64_t)v4;
    getFigAudioSessionClockCreateForSharedAudioSessionSymbolLoc_ptr = v4;
  }
  _Block_object_dispose(&v7, 8);
  if (!v4)
    CMAudioClockCreate_cold_1();
  return ((uint64_t (*)(CFAllocatorRef, _QWORD, CMClockRef *))v4)(allocator, 0, clockOut);
}

void sub_18ECFACF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t CMAudioClockCreateForAudioSession(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  void *v9;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  void *v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v8 = getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr;
  v14 = getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr;
  if (!getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr)
  {
    v9 = (void *)MediaToolboxLibrary();
    v8 = dlsym(v9, "FigAudioSessionClockCreateForAVAudioSession");
    v12[3] = (uint64_t)v8;
    getFigAudioSessionClockCreateForAVAudioSessionSymbolLoc_ptr = v8;
  }
  _Block_object_dispose(&v11, 8);
  if (!v8)
    CMAudioClockCreateForAudioSession_cold_1();
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8)(a1, a2, a3, a4);
}

void sub_18ECFADB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t MediaToolboxLibrary()
{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!MediaToolboxLibraryCore_frameworkLibrary_0)
  {
    v2 = xmmword_1E28DC9B8;
    v3 = 0;
    MediaToolboxLibraryCore_frameworkLibrary_0 = _sl_dlopen();
  }
  if (!MediaToolboxLibraryCore_frameworkLibrary_0)
    MediaToolboxLibrary_cold_1(&v1);
  return MediaToolboxLibraryCore_frameworkLibrary_0;
}

void FigDebugAssert(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  figDebugAssertCommon(a1, a2, a3, a4, a5, a6, a7, 0);
}

void figDebugAssertCommon(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char v9;
  const char *v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  char v32[1024];
  uint64_t v33;

  v8 = a8;
  v9 = a7;
  v33 = *MEMORY[0x1E0C80C00];
  v14 = "(Fig)";
  if (a1)
    LOBYTE(v14) = a1;
  v15 = safe_snprintf(v32, 0x400uLL, "%s ", a4, a5, a6, a7, a8, (char)v14);
  v21 = v15;
  if (a2)
    v21 = safe_snprintf(&v32[v15], 1024 - v15, "assert: \"%s\" ", v16, v17, v18, v19, v20, a2) + v15;
  if (a3 | a5)
  {
    v21 += safe_snprintf(&v32[v21], 1024 - v21, "at ", v16, v17, v18, v19, v20, v31);
    if (a3)
      v21 += safe_snprintf(&v32[v21], 1024 - v21, "%s ", v16, v17, v18, v19, v20, a3);
    if (a5)
      v21 += safe_snprintf(&v32[v21], 1024 - v21, "(%s line %d) ", v16, v17, v18, v19, v20, a5);
  }
  v27 = safe_snprintf(&v32[v21], 1024 - v21, "- ", v16, v17, v18, v19, v20, v31) + v21;
  if (a4)
    v27 += safe_snprintf(&v32[v27], 1024 - v27, "%s ", v22, v23, v24, v25, v26, a4);
  safe_snprintf(&v32[v27], 1024 - v27, "(err=%d)", v22, v23, v24, v25, v26, v9);
  if (v8)
    syslog(3, "%s", v32);
  else
    fig_log(2u, 1, 0, 0, "%s", v28, v29, v30, (uint64_t)v32);
}

void FigDebugAssertSyslog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  figDebugAssertCommon(a1, a2, a3, a4, a5, a6, a7, 1);
}

void FigDebugAssert2(const char *a1, const char *a2)
{
  uint64_t v2;
  const char *v4;
  uint64_t v5;
  const char *v6;

  v4 = fmtcheck(a1, "%s assert: \"%s\" at %s (%s:%d) - %s (err=%d)");
  v6 = "(Fig)";
  if (a2)
    v6 = a2;
  fig_log_with_return_address(0, 2u, 1, 0, 0, v2, v4, v5, (uint64_t)v6);
}

void FigDebugAssert3(const char *a1, uint64_t *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  const char *v12;
  uint64_t v13;
  const char *v14;

  v12 = fmtcheck(a1, "%s assert: \"%s\" at %s (%s:%d) - %s%s(err=%d)");
  v14 = "(Fig)";
  if (a3)
    v14 = a3;
  fig_log_with_return_address(a2, 2u, 1, 0, 0, a10, v12, v13, (uint64_t)v14);
}

uint64_t FigDebugAssertSyslog2()
{
  return CallOSLogWithArgs();
}

uint64_t CallOSLogWithArgs()
{
  return os_log_with_args();
}

void FigUserCrashWithMessage(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  const __CFAllocator *v10;
  const __CFString *SignaledErrorInfo;
  const __CFString *v12;
  char buffer[1024];
  va_list v14;

  v14 = 0;
  bzero(buffer, 0x400uLL);
  v14 = (va_list)&a9;
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  SignaledErrorInfo = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x8000100u);
  if (!SignaledErrorInfo)
  {
    FigAtomicIncrement32((unsigned int *)&gErrorCount);
    SignaledErrorInfo = (const __CFString *)figRecordLastSignaledErrorInfo(-12786, 0, 0, 0, 0, 0, 0);
    __break(1u);
  }
  v12 = CFStringCreateWithFormatAndArguments(v10, 0, SignaledErrorInfo, v14);
  CFStringGetCString(v12, buffer, 1024, 0x8000100u);
  qword_1EE140448 = (uint64_t)buffer;
  if (v12)
    CFRelease(v12);
  __break(1u);
}

uint64_t FigUserFaultWithMessage(uint64_t a1, uint64_t a2)
{
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    FigUserFaultWithMessage_cold_1(a2, a1);
  return 1;
}

uint64_t FigUserStackshotWithMessage()
{
  if (FigUserStackshotWithMessage_nonce != -1)
    dispatch_once(&FigUserStackshotWithMessage_nonce, &__block_literal_global_16);
  if (!FigUserStackshotWithMessage_stackshotsEnabled)
    return 0;
  getpid();
  return WriteStackshotReportWithPID();
}

uint64_t FigUserTailspinWithMessage()
{
  return 0;
}

void FigUserBreak()
{
  int v0;
  char *v1;

  v0 = FigUserBreak_userbreak;
  if (FigUserBreak_userbreak == 85)
  {
    v1 = getenv("USERBREAK");
    v0 = v1 && !strcmp(v1, "1");
    FigUserBreak_userbreak = v0;
  }
  if (v0)
    __break(1u);
}

uint64_t FigCopyBacktrace(const __CFAllocator *a1, CFArrayRef *a2, __CFArray **a3)
{
  int v6;
  CFIndex v7;
  const void **v8;
  char **v9;
  __CFArray *Mutable;
  CFIndex v11;
  char **v12;
  const void *v13;
  CFStringRef v14;
  Dl_info v16;
  void *v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v42 = 0;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  *(_OWORD *)v17 = 0u;
  v6 = backtrace(v17, 51);
  v7 = v6 - (v6 > 0);
  if (a2 && (int)v7 >= 1)
    *a2 = CFArrayCreate(a1, (const void **)&v17[1], v7, 0);
  if (a3 && (int)v7 >= 1)
  {
    v8 = (const void **)&v17[1];
    v9 = backtrace_symbols(&v17[1], v7);
    Mutable = CFArrayCreateMutable(a1, v7, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v11 = v7;
      v12 = v9;
      do
      {
        v13 = *v8;
        memset(&v16, 0, sizeof(v16));
        dladdr(v13, &v16);
        v14 = CFStringCreateWithFormat(a1, 0, CFSTR("%s    [%p + %td]"), *v12, v16.dli_fbase, (_BYTE *)v13 - (char *)v16.dli_fbase);
        CFArrayAppendValue(Mutable, v14);
        if (v14)
          CFRelease(v14);
        ++v12;
        ++v8;
        --v11;
      }
      while (v11);
    }
    free(v9);
    *a3 = Mutable;
  }
  return (int)v7;
}

void FigLogBacktraceFrames()
{
  uint64_t v0;
  _BYTE *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFArray *v7;
  size_t v8;
  char *v9;
  size_t v10;
  const char *v11;
  CFIndex Count;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char **v19;
  char **v20;
  void **v21;
  char **v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  Dl_info v32;
  void *values[2];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  char v58[4070];
  _BYTE v59[42];
  CFRange v60;

  v0 = MEMORY[0x1E0C80A78]();
  v7 = (const __CFArray *)v0;
  *(_QWORD *)&v59[26] = *MEMORY[0x1E0C80C00];
  if (v1 && *v1)
  {
    v8 = safe_snprintf(v58, 0x1000uLL, "%s\n", v2, v3, v4, v5, v6, (char)v1);
    if (!v7)
    {
LABEL_4:
      v9 = &v58[v8];
      v10 = 4096 - v8;
      v11 = "FigLogBacktrace passed NULL backtrace";
LABEL_18:
      safe_snprintf(v9, v10, v11, v2, v3, v4, v5, v6, (char)v31);
      goto LABEL_19;
    }
  }
  else
  {
    v8 = 0;
    if (!v0)
      goto LABEL_4;
  }
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  *(_OWORD *)values = 0u;
  Count = CFArrayGetCount(v7);
  if (Count < 50)
  {
    v18 = Count;
  }
  else
  {
    v8 += safe_snprintf(&v58[v8], 4096 - v8, "Too many frames\n", v13, v14, v15, v16, v17, (char)v31);
    v18 = 50;
  }
  v60.location = 0;
  v60.length = v18;
  CFArrayGetValues(v7, v60, (const void **)values);
  v19 = backtrace_symbols(values, v18);
  if (v19)
  {
    v20 = v19;
    if (v18 >= 1)
    {
      v21 = values;
      v22 = v19;
      v23 = v18;
      do
      {
        v24 = *v21++;
        memset(&v32, 0, sizeof(v32));
        dladdr(v24, &v32);
        v25 = (uint64_t)*v22++;
        v8 += safe_snprintf(&v58[v8], 4096 - v8, "%s    [%p + %td]\n", v26, v27, v28, v29, v30, v25);
        --v23;
      }
      while (v23);
    }
    free(v20);
  }
  if (v8 == 4096 || v18 >= 50 && v8 - 4074 <= 0x16)
  {
    v9 = v59;
    v31 = "FigBacktrace Truncated";
    v11 = " - %s";
    v10 = 26;
    goto LABEL_18;
  }
  if (v18 >= 50)
    safe_snprintf(&v58[v8], 4096 - v8, "%s", v2, v3, v4, v5, v6, (char)"FigBacktrace Truncated");
LABEL_19:
  fig_log(1u, 1, 0, 0, "%s", v4, v5, v6, (uint64_t)v58);
}

size_t safe_snprintf(char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t result;

  LODWORD(result) = vsnprintf(a1, a2, a3, &a9);
  if (a2 - 1 >= (int)result)
    return (int)result;
  else
    return a2 - 1;
}

void FigLogBacktrace()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  char **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *excessive_emitter_for_subsystem;
  uint64_t v24;
  char v25;
  Dl_info v26;
  char v27[4071];
  char v28[25];
  __int128 v29;
  _OWORD v30[24];
  uint64_t v31;
  uint64_t v32;

  MEMORY[0x1E0C80A78]();
  v1 = v0;
  v32 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  memset(v30, 0, sizeof(v30));
  v29 = 0u;
  v27[0] = 0;
  v2 = backtrace((void **)&v29, 51);
  v8 = v2 - 2;
  if (v2 > 2)
  {
    v9 = backtrace_symbols((void *const *)v30, v8);
    v10 = 0;
    v11 = 0;
    do
    {
      memset(&v26, 0, sizeof(v26));
      dladdr(*(const void **)((char *)v30 + v10 * 8), &v26);
      if (v9)
        v17 = v9[v10];
      else
        v17 = "?";
      v11 += safe_snprintf(&v27[v11], 4096 - v11, "%s    [%p + %td]\n", v12, v13, v14, v15, v16, (char)v17);
      ++v10;
    }
    while (v8 != v10);
    if (v11 == 4096)
      safe_snprintf(v28, 0x19uLL, "%s", v18, v19, v20, v21, v22, (char)" - FigBacktrace Truncated");
    v1 = v0;
  }
  else
  {
    safe_snprintf(v27, 0x1000uLL, "Not enough frames to display", v3, v4, v5, v6, v7, v25);
    v9 = 0;
  }
  excessive_emitter_for_subsystem = fig_log_get_excessive_emitter_for_subsystem("com.apple.coremedia");
  fig_log_with_return_address(excessive_emitter_for_subsystem, 1u, 1, 0, 0, v1, "%s", v24, (uint64_t)v27);
  free(v9);
}

uint64_t FigCopyLastSignaledErrorInfo(_DWORD *a1, CFStringRef *a2, CFStringRef *a3, CFStringRef *a4, CFStringRef *a5, CFStringRef *a6, _QWORD *a7, _OWORD *a8)
{
  CFAllocatorRef *v16;

  if (figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce != -1)
    dispatch_once(&figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce, &__block_literal_global_37);
  FigSimpleMutexLock((pthread_mutex_t *)figGetSignalErrorLatchLock_sListLock);
  if (a1)
    *a1 = sLastError;
  v16 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (a2)
    *a2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], byte_1ECDA8614, 0);
  if (a3)
    *a3 = CFStringCreateWithCString(*v16, byte_1ECDA8634, 0);
  if (a4)
    *a4 = CFStringCreateWithCString(*v16, byte_1ECDA86B4, 0);
  if (a5)
    *a5 = CFStringCreateWithCString(*v16, byte_1ECDA86D4, 0);
  if (a6)
    *a6 = CFStringCreateWithCString(*v16, byte_1ECDA8714, 0);
  if (a7)
    *a7 = qword_1ECDA8758;
  if (a8)
    *a8 = xmmword_1ECDA8760;
  if (figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce != -1)
    dispatch_once(&figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce, &__block_literal_global_37);
  return FigSimpleMutexUnlock((pthread_mutex_t *)figGetSignalErrorLatchLock_sListLock);
}

uint64_t figRecordLastSignaledErrorInfo(int a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7)
{
  const char *v9;
  const char *v10;
  size_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;

  if (a5)
    v9 = a5;
  else
    v9 = "";
  if (a6)
    v10 = a6;
  else
    v10 = "";
  if (figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce != -1)
    dispatch_once(&figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce, &__block_literal_global_37);
  FigSimpleMutexLock((pthread_mutex_t *)figGetSignalErrorLatchLock_sListLock);
  sLastError = a1;
  __strlcpy_chk();
  __strlcpy_chk();
  __strlcpy_chk();
  v11 = strlen(v9);
  if (v11 >= 0x3F)
    v12 = 63;
  else
    v12 = v11;
  __memcpy_chk();
  byte_1ECDA86D4[v12] = 0;
  v13 = strlen(v10);
  if (v13 >= 0x3F)
    v14 = 63;
  else
    v14 = v13;
  __memcpy_chk();
  byte_1ECDA8714[v14] = 0;
  qword_1ECDA8758 = a7;
  gettimeofday((timeval *)&xmmword_1ECDA8760, 0);
  if (figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce != -1)
    dispatch_once(&figGetSignalErrorLatchLock_sInitSignalErrorLatchOnce, &__block_literal_global_37);
  return FigSimpleMutexUnlock((pthread_mutex_t *)figGetSignalErrorLatchLock_sListLock);
}

uint64_t FigSignalErrorAt2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, const char *a7, uint64_t a8)
{
  FigAtomicIncrement32((unsigned int *)&gErrorCount);
  figRecordLastSignaledErrorInfo(a2, a3, a4, a5, a6, a7, a8);
  return a2;
}

uint64_t FigSignalErrorAt3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7, const char *a8, uint64_t a9)
{
  FigAtomicIncrement32((unsigned int *)&gErrorCount);
  figRecordLastSignaledErrorInfo(a3, a4, a5, a6, a7, a8, a9);
  return a3;
}

uint64_t FigGetErrorCount()
{
  return gErrorCount;
}

_QWORD *FigDebugGetDefaultLogEmitter(const char *a1)
{
  return fig_log_get_emitter(a1, 0);
}

uint64_t FigDebugSettingGetKeyAsBoolean(const __CFString *a1, Boolean *a2, Boolean a3)
{
  Boolean AppBooleanValue;
  uint64_t v6;
  Boolean v7;
  Boolean keyExistsAndHasValidFormat;

  keyExistsAndHasValidFormat = 0;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(a1, CFSTR("com.apple.coremedia"), &keyExistsAndHasValidFormat);
  v6 = keyExistsAndHasValidFormat;
  if (keyExistsAndHasValidFormat)
    v7 = AppBooleanValue;
  else
    v7 = a3;
  *a2 = v7;
  return v6;
}

uint64_t FigDebugGetAdoptedVoucherProcessIDAndUUIDString(char *a1)
{
  uint64_t v2;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uuid_t uu;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  uuid_unparse_lower(uu, a1);
  v5 = 0u;
  v6 = 0u;
  v4 = 0u;
  if (proc_pidoriginatorinfo() != 48)
    return 0xFFFFFFFFLL;
  v2 = v5;
  uuid_copy(uu, (const unsigned __int8 *)&v4);
  uuid_unparse_lower(uu, a1);
  return v2;
}

uint64_t FigSysdiagnoseBlock_OneTimeInitializationForMediaserverd()
{
  if (InitializeSysdiagnoseBlockRegistry_sInitSysdiagnoseBlockRegistryOnce != -1)
    dispatch_once(&InitializeSysdiagnoseBlockRegistry_sInitSysdiagnoseBlockRegistryOnce, &__block_literal_global_39);
  return os_state_add_handler();
}

void FigInstallSysdiagnoseBlock(uint64_t a1, uint64_t a2)
{
  _QWORD v4[6];

  if (InitializeSysdiagnoseBlockRegistry_sInitSysdiagnoseBlockRegistryOnce != -1)
    dispatch_once(&InitializeSysdiagnoseBlockRegistry_sInitSysdiagnoseBlockRegistryOnce, &__block_literal_global_39);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __FigInstallSysdiagnoseBlock_block_invoke;
  v4[3] = &unk_1E28DCA58;
  v4[4] = a2;
  v4[5] = a1;
  dispatch_sync((dispatch_queue_t)gFigSysdiagnoseBlockRegistry_0, v4);
}

uint64_t FigIsItOKToLogURLs()
{
  if (sOKToLogURLs_DetermineInitialValueOnce != -1)
    dispatch_once_f(&sOKToLogURLs_DetermineInitialValueOnce, 0, (dispatch_function_t)DetermineInitialValueForOKToLogURLs);
  return sOKToLogURLs;
}

uint64_t DetermineInitialValueForOKToLogURLs()
{
  uint64_t result;

  if (FigDebugIsInternalBuild_onceToken != -1)
    dispatch_once(&FigDebugIsInternalBuild_onceToken, &__block_literal_global_25_0);
  result = FigGetCFPreferenceNumberWithDefault(CFSTR("logurls"), CFSTR("com.apple.coremedia"), FigDebugIsInternalBuild_isInternalBuild);
  sOKToLogURLs = result;
  return result;
}

uint64_t FigDebugIsInternalBuild()
{
  if (FigDebugIsInternalBuild_onceToken != -1)
    dispatch_once(&FigDebugIsInternalBuild_onceToken, &__block_literal_global_25_0);
  return FigDebugIsInternalBuild_isInternalBuild;
}

uint64_t FigIsCompiledForLightweightAssetRuntime()
{
  return 0;
}

pthread_mutex_t *__figGetSignalErrorLatchLock_block_invoke()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  pthread_mutex_t *result;

  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  figGetSignalErrorLatchLock_sListLock = (uint64_t)result;
  return result;
}

void *SysdiagnoseBlockDictionaryRetain(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

void SysdiagnoseBlockDictionaryRelease(int a1, void *aBlock)
{
  _Block_release(aBlock);
}

uint64_t SysdiagnoseBlockDictionaryApplierFunction(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  return result;
}

uint64_t CMTimeSyncClockCreateForSystemDomainClockIdentifier(uint64_t a1, CFTypeRef *a2)
{
  CMClockRef HostTimeClock;
  uint64_t v5;
  uint64_t TimeCallback;
  uint64_t v7;
  CFTypeRef v8;
  uint64_t DerivedStorage;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v16;
  uint64_t v17;
  unsigned int v18;
  char *v19;
  os_log_type_t type;
  int v21;
  CMTime v22;
  CFTypeRef cf;
  int v24;
  const char *v25;
  __int16 v26;
  CFTypeRef v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  cf = 0;
  HostTimeClock = CMClockGetHostTimeClock();
  if (sTimeSyncFunctionsLoadedOnce != -1)
  {
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce, 0, (dispatch_function_t)LoadTimeSyncFunctions);
    if (a2)
      goto LABEL_3;
LABEL_21:
    v5 = 4294954551;
    goto LABEL_22;
  }
  if (!a2)
    goto LABEL_21;
LABEL_3:
  if (!CM8021ASClockEnsureTimeSyncServices())
  {
    CMTimeMake(&v22, 1, 10);
    TimeCallback = FigDerivedClockCreateWithGetTimeCallback(a1, gFigTimeSyncClockCallbacks, HostTimeClock, (__int128 *)&v22.value, 1, (uint64_t *)&cf);
    if ((_DWORD)TimeCallback)
    {
      v7 = TimeCallback;
      v8 = 0;
      goto LABEL_23;
    }
    v8 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)cf);
    if (!v8)
      goto LABEL_19;
    DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)cf);
    *(_QWORD *)DerivedStorage = FigSimpleMutexCreate();
    if (HostTimeClock)
      v10 = CFRetain(HostTimeClock);
    else
      v10 = 0;
    *(_QWORD *)(DerivedStorage + 8) = v10;
    *(_QWORD *)(DerivedStorage + 40) = *(_QWORD *)sTSNullgPTPClockIdentity;
    *(_QWORD *)(DerivedStorage + 112) = 0;
    *(_OWORD *)(DerivedStorage + 96) = *(_OWORD *)&kCMTimeZero.value;
    *(_QWORD *)(DerivedStorage + 88) = 0;
    *(_OWORD *)(DerivedStorage + 72) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(DerivedStorage + 64) = 0;
    *(_OWORD *)(DerivedStorage + 48) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(DerivedStorage + 24) = CFRetain(v8);
    *(_BYTE *)(DerivedStorage + 120) = 0;
    v11 = sTimeSyncSystemDomainClockIdentifier();
    *(_QWORD *)(DerivedStorage + 32) = v11;
    if (v11 == *(_QWORD *)sTSNullClockIdentifier)
    {
      v7 = 4294954540;
      goto LABEL_23;
    }
    v12 = sTimeSyncClockCreateWithClockIdentifer();
    *(_QWORD *)(DerivedStorage + 16) = v12;
    if (!v12)
    {
LABEL_19:
      v7 = 4294954549;
      goto LABEL_23;
    }
    sTimeSyncClockSetLockStateChangeCallback(v12, figTimeSyncClock_LockStateDidChange, *(_QWORD *)(DerivedStorage + 24));
    sTimeSyncClockSetgPTPGrandmasterAndPortChangeCallback(*(_QWORD *)(DerivedStorage + 16), figTimeSyncClock_MasterAndPortDidChange, *(_QWORD *)(DerivedStorage + 24));
    sTimeSyncClockSetTimeSyncTimeChangeCallback(*(_QWORD *)(DerivedStorage + 16), figTimeSyncClock_TimeSyncTimeDidChange, *(_QWORD *)(DerivedStorage + 24));
    v13 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)cf);
    if (figTimeSyncClock_periodicTasksInit_onceToken != -1)
      dispatch_once_f(&figTimeSyncClock_periodicTasksInit_onceToken, 0, (dispatch_function_t)figTimeSyncClock_periodicTasksInitOnce);
    dispatch_async_f((dispatch_queue_t)gPeriodicTasksQueue, v13, (dispatch_function_t)figTimeSyncClock_addClockToPeriodicTasksInternal);
    if (sLogCreatedOnce != -1)
      dispatch_once(&sLogCreatedOnce, &__block_literal_global_17);
    *(_QWORD *)(DerivedStorage + 128) = os_signpost_id_generate((os_log_t)sLog);
LABEL_28:
    if (dword_1EE141F48)
    {
      v21 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F40, 1, &v21, &type);
      v16 = v21;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v18 = v16;
      else
        v18 = v16 & 0xFFFFFFFE;
      if (v18)
      {
        v24 = 136315394;
        v25 = "CMTimeSyncClockCreateForSystemDomainClockIdentifier";
        v26 = 2048;
        v27 = cf;
        v19 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v16) = v21;
      }
      else
      {
        v19 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F40, 1u, 1, v19, v19 != &v28, v16, 0, v17);
    }
    v7 = 0;
    *a2 = cf;
    cf = 0;
    if (v8)
      goto LABEL_26;
    return v7;
  }
  v5 = 4294951236;
LABEL_22:
  v7 = FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  v8 = 0;
  if (!(_DWORD)v7)
    goto LABEL_28;
LABEL_23:
  if (cf)
    CFRelease(cf);
  if (v8)
LABEL_26:
    CFRelease(v8);
  return v7;
}

void *LoadTimeSyncFunctions()
{
  unsigned int v0;
  void *v1;
  void *v2;
  void *result;

  v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimeSyncClockTrace[1], CFSTR("timesync_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFigTimeSyncClockTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EE141F48, CFSTR("timesync_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EE141F40);
  v1 = dlopen("/System/Library/PrivateFrameworks/TimeSync.framework/TimeSync", 4);
  if (!v1)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  v2 = v1;
  sTSNullClockIdentifier = (uint64_t)dlsym(v1, "TSNullClockIdentifier");
  if (!sTSNullClockIdentifier)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTSNullgPTPClockIdentity = (uint64_t)dlsym(v2, "TSNullgPTPClockIdentity");
  if (!sTSNullgPTPClockIdentity)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncAddgPTPServicesSync = (uint64_t)dlsym(v2, "TimeSyncAddgPTPServicesSync");
  if (!sTimeSyncAddgPTPServicesSync)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncRemovegPTPServices = (uint64_t)dlsym(v2, "TimeSyncRemovegPTPServices");
  if (!sTimeSyncRemovegPTPServices)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockCreateWithClockIdentifer = dlsym(v2, "TimeSyncClockCreateWithClockIdentifer");
  if (!sTimeSyncClockCreateWithClockIdentifer)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockDispose = dlsym(v2, "TimeSyncClockDispose");
  if (!sTimeSyncClockDispose)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockGetHostTimeAndGrandmasterIdentityForClockTime = (uint64_t)dlsym(v2, "TimeSyncClockGetHostTimeAndGrandmasterIdentityForClockTime");
  if (!sTimeSyncClockGetHostTimeAndGrandmasterIdentityForClockTime)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime = dlsym(v2, "TimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime");
  if (!sTimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockGetClockRate = dlsym(v2, "TimeSyncClockGetClockRate");
  if (!sTimeSyncClockGetClockRate)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockGetLockState = (uint64_t)dlsym(v2, "TimeSyncClockGetLockState");
  if (!sTimeSyncClockGetLockState)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockGetgPTPGrandmasterIdentity = dlsym(v2, "TimeSyncClockGetgPTPGrandmasterIdentity");
  if (!sTimeSyncClockGetgPTPGrandmasterIdentity)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncSystemDomainClockIdentifier = dlsym(v2, "TimeSyncSystemDomainClockIdentifier");
  if (!sTimeSyncSystemDomainClockIdentifier)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockSetLockStateChangeCallback = dlsym(v2, "TimeSyncClockSetLockStateChangeCallback");
  if (!sTimeSyncClockSetLockStateChangeCallback)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockSetgPTPGrandmasterChangeCallback = (uint64_t)dlsym(v2, "TimeSyncClockSetgPTPGrandmasterChangeCallback");
  if (!sTimeSyncClockSetgPTPGrandmasterChangeCallback)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockSetgPTPGrandmasterAndPortChangeCallback = dlsym(v2, "TimeSyncClockSetgPTPGrandmasterAndPortChangeCallback");
  if (!sTimeSyncClockSetgPTPGrandmasterAndPortChangeCallback)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockSetTimeSyncTimeChangeCallback = dlsym(v2, "TimeSyncClockSetTimeSyncTimeChangeCallback");
  if (!sTimeSyncClockSetTimeSyncTimeChangeCallback)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockAddUDPv4EndToEndPort = (uint64_t)dlsym(v2, "TimeSyncClockAddUDPv4EndToEndPort");
  if (!sTimeSyncClockAddUDPv4EndToEndPort)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockRemoveUDPv4EndToEndPort = (uint64_t)dlsym(v2, "TimeSyncClockRemoveUDPv4EndToEndPort");
  if (!sTimeSyncClockRemoveUDPv4EndToEndPort)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockAddUDPv6EndToEndPort = (uint64_t)dlsym(v2, "TimeSyncClockAddUDPv6EndToEndPort");
  if (!sTimeSyncClockAddUDPv6EndToEndPort)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockRemoveUDPv6EndToEndPort = (uint64_t)dlsym(v2, "TimeSyncClockRemoveUDPv6EndToEndPort");
  if (!sTimeSyncClockRemoveUDPv6EndToEndPort)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockAddAWDLPort = (uint64_t)dlsym(v2, "TimeSyncClockAddAWDLPort");
  if (!sTimeSyncClockAddAWDLPort)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  result = dlsym(v2, "TimeSyncClockRemoveAWDLPort");
  sTimeSyncClockRemoveAWDLPort = (uint64_t)result;
  if (!result)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  return result;
}

void figTimeSyncClock_LockStateDidChange(uint64_t a1, id *a2, int a3)
{
  id *v4;
  uint64_t v5;
  uint64_t DerivedStorage;
  uint64_t v7;
  int v8;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v10;
  uint64_t v11;
  unsigned int v12;
  char *v13;
  NSObject *global_queue;
  _QWORD block[5];
  os_log_type_t type;
  int v17[2];
  const char *v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  v5 = (uint64_t)v4;
  if (v4)
  {
    DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)v4);
    if (a3 == 2)
    {
      v7 = DerivedStorage;
      v8 = *(unsigned __int8 *)(DerivedStorage + 120);
      if (dword_1EE141F48)
      {
        v17[0] = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F40, 1, v17, &type);
        v10 = v17[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v12 = v10;
        else
          v12 = v10 & 0xFFFFFFFE;
        if (v12)
        {
          v17[1] = 136315650;
          v18 = "figTimeSyncClock_LockStateDidChange";
          v19 = 2048;
          v20 = v5;
          v21 = 1024;
          v22 = v8;
          v13 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v10) = v17[0];
        }
        else
        {
          v13 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F40, 1u, 1, v13, v13 != &v23, v10, 0, v11);
      }
      figTimeSyncClock_getAnchorTimeWithResync(v5, v8, 0, 0);
      *(_BYTE *)(v7 + 120) = 0;
    }
  }
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figTimeSyncClock_LockStateDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_34;
  block[4] = v5;
  dispatch_async(global_queue, block);
}

void figTimeSyncClock_MasterAndPortDidChange(uint64_t a1, id *a2, uint64_t a3, int a4)
{
  id *v6;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  char *v11;
  NSObject *global_queue;
  _QWORD block[5];
  os_log_type_t type;
  int v15[2];
  const char *v16;
  __int16 v17;
  id *v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  if (v6)
  {
    if (dword_1EE141F48)
    {
      v15[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F40, 1, v15, &type);
      v8 = v15[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v10 = v8;
      else
        v10 = v8 & 0xFFFFFFFE;
      if (v10)
      {
        v15[1] = 136315906;
        v16 = "figTimeSyncClock_MasterAndPortDidChange";
        v17 = 2048;
        v18 = v6;
        v19 = 2048;
        v20 = a3;
        v21 = 1024;
        v22 = a4;
        v11 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v8) = v15[0];
      }
      else
      {
        v11 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F40, 1u, 1, v11, v11 != &v23, v8, 0, v9);
    }
    figTimeSyncClock_getAnchorTimeWithResync((uint64_t)v6, 1, 0, 0);
  }
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figTimeSyncClock_MasterAndPortDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_35;
  block[4] = v6;
  dispatch_async(global_queue, block);
}

void figTimeSyncClock_TimeSyncTimeDidChange(uint64_t a1, id *a2)
{
  id *v2;
  id *v3;
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v6;
  uint64_t v7;
  unsigned int v8;
  char *v9;
  NSObject *global_queue;
  _QWORD block[5];
  os_log_type_t type;
  int v13[2];
  const char *v14;
  __int16 v15;
  id *v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  v3 = v2;
  if (v2)
  {
    DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)v2);
    if (dword_1EE141F48)
    {
      v13[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F40, 1, v13, &type);
      v6 = v13[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v8 = v6;
      else
        v8 = v6 & 0xFFFFFFFE;
      if (v8)
      {
        v13[1] = 136315394;
        v14 = "figTimeSyncClock_TimeSyncTimeDidChange";
        v15 = 2048;
        v16 = v3;
        v9 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v6) = v13[0];
      }
      else
      {
        v9 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F40, 1u, 1, v9, v9 != &v17, v6, 0, v7);
    }
    *(_BYTE *)(DerivedStorage + 120) = 1;
  }
  global_queue = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figTimeSyncClock_TimeSyncTimeDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_36_0;
  block[4] = v3;
  dispatch_async(global_queue, block);
}

CFStringRef figTimeSyncClock_CopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  const __CFAllocator *v5;
  uint64_t v6;
  const char *v7;
  CFStringRef v8;

  DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  v3 = *(_QWORD *)(DerivedStorage + 40);
  v4 = *(_QWORD *)sTSNullgPTPClockIdentity;
  v5 = CFGetAllocator(a1);
  if (v3 == v4)
  {
    v6 = 0;
    v7 = "not locked";
  }
  else
  {
    v6 = *(_QWORD *)(DerivedStorage + 40);
    v7 = "locked";
  }
  v8 = CFStringCreateWithFormat(v5, 0, CFSTR("CMTimeSyncClock %s, GM=0x%016llx)"), v7, v6);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v8;
}

pthread_mutex_t **figTimeSyncClock_Finalize(uint64_t a1)
{
  pthread_mutex_t **result;
  pthread_mutex_t *v2;
  pthread_mutex_t **v3;
  pthread_mutex_t *v4;
  pthread_mutex_t *v5;
  pthread_mutex_t *v6;

  result = (pthread_mutex_t **)FigDerivedClockGetDerivedStorage(a1);
  v2 = *result;
  if (*result)
  {
    v3 = result;
    FigSimpleMutexLock(*result);
    v4 = v3[1];
    if (v4)
      CFRelease(v4);
    v5 = v3[2];
    if (v5)
    {
      sTimeSyncClockSetgPTPGrandmasterAndPortChangeCallback(v5, 0, 0);
      sTimeSyncClockSetLockStateChangeCallback(v3[2], 0, 0);
      sTimeSyncClockSetTimeSyncTimeChangeCallback(v3[2], 0, 0);
      sTimeSyncClockDispose(v3[2]);
    }
    v6 = v3[3];
    if (v6)
      CFRelease(v6);
    *v3 = 0;
    FigSimpleMutexUnlock(v2);
    return (pthread_mutex_t **)FigSimpleMutexDestroy((uint64_t)v2);
  }
  return result;
}

BOOL figTimeSyncClock_MightDrift(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t v6;

  if (!FigDerivedClockVerifyCallbacksMatch(a1, (uint64_t)gFigTimeSyncClockCallbacks)
    || !FigDerivedClockVerifyCallbacksMatch(a2, (uint64_t)gFigTimeSyncClockCallbacks))
  {
    return 1;
  }
  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v5 = FigDerivedClockGetDerivedStorage(a2);
  v6 = sTimeSyncClockGetgPTPGrandmasterIdentity(*(_QWORD *)(DerivedStorage + 16));
  return v6 != sTimeSyncClockGetgPTPGrandmasterIdentity(*(_QWORD *)(v5 + 16));
}

uint64_t figTimeSyncClock_GetRate(uint64_t a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  return sTimeSyncClockGetClockRate(*(_QWORD *)(DerivedStorage + 16));
}

uint64_t figTimeSyncClock_GetAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  return figTimeSyncClock_getAnchorTimeWithResync(a1, 0, a2, a3);
}

uint64_t figTimeSyncClock_getAnchorTimeWithResync(uint64_t a1, int a2, CMTime *a3, CMTime *a4)
{
  uint64_t v6;
  uint64_t DerivedStorage;
  double v8;
  uint64_t v9;
  CMTimeFlags flags;
  CMTimeEpoch epoch;
  CMTime *v12;
  double v13;
  int v14;
  double *v15;
  int v16;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  double v21;
  CMTime *v22;
  CMTimeFlags v23;
  CMTimeEpoch v24;
  double v25;
  CMTimeEpoch v26;
  uint64_t v27;
  NSObject *v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  Float64 Seconds;
  Float64 v33;
  uint64_t v34;
  Float64 v35;
  Float64 v36;
  Float64 v37;
  CMTime *v38;
  CMTime *v40;
  CMTime *v41;
  CMTime *v42;
  CMTime *v44;
  CMTime *v45;
  double *v46;
  CMTime *v47;
  CMTime v48;
  os_log_type_t type;
  double v50;
  CMTime v51;
  CMTime v52;
  CMTime rhs;
  Float64 v54;
  __int16 v55;
  Float64 v56;
  __int16 v57;
  _BYTE v58[10];
  Float64 v59;
  __int16 v60;
  Float64 v61;
  __int16 v62;
  Float64 v63;
  __int16 v64;
  double v65;
  CMTime lhs;
  CMTimeValue v67;
  CMTimeScale v68;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v71;

  v6 = a1;
  v71 = *MEMORY[0x1E0C80C00];
  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  memset(&v52, 0, sizeof(v52));
  memset(&v51, 0, sizeof(v51));
  v50 = 0.0;
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  CMClockGetTime(&v51, *(CMClockRef *)(DerivedStorage + 8));
  rhs = v51;
  figTimeSyncClockGetClockTimeForHostTime(v6, &rhs, &v50, &lhs);
  value = lhs.value;
  timescale = lhs.timescale;
  v8 = v50;
  v9 = 4294949326;
  if (*(_QWORD *)&v50 != *(_QWORD *)sTSNullgPTPClockIdentity)
  {
    flags = lhs.flags;
    if ((lhs.flags & 1) != 0)
    {
      v40 = a3;
      v41 = a4;
      epoch = lhs.epoch;
      v12 = (CMTime *)(DerivedStorage + 72);
      v42 = (CMTime *)DerivedStorage;
      if ((*(_BYTE *)(DerivedStorage + 84) & 1) != 0)
      {
        v13 = *(double *)(DerivedStorage + 40);
      }
      else
      {
        *(CMTime *)(DerivedStorage + 48) = v51;
        v12->value = value;
        *(_DWORD *)(DerivedStorage + 80) = timescale;
        *(_DWORD *)(DerivedStorage + 84) = flags;
        *(_QWORD *)(DerivedStorage + 88) = epoch;
        v13 = v8;
        *(double *)(DerivedStorage + 40) = v8;
      }
      if (a2 || *(_QWORD *)&v8 != *(_QWORD *)&v13)
      {
        v14 = 0;
        v15 = (double *)(DerivedStorage + 40);
        v45 = (CMTime *)(DerivedStorage + 48);
        v47 = (CMTime *)(DerivedStorage + 96);
        v16 = dword_1EE141F48;
        v44 = (CMTime *)(DerivedStorage + 72);
        v46 = (double *)(DerivedStorage + 40);
        while (1)
        {
          if (v16)
          {
            LODWORD(v48.value) = 0;
            type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F40, 1, (int *)&v48, &type);
            v18 = v48.value;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
              v20 = v18;
            else
              v20 = v18 & 0xFFFFFFFE;
            if (v20)
            {
              v21 = *v15;
              LODWORD(rhs.value) = 136316418;
              *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"figTimeSyncClock_getAnchorTimeWithResync";
              LOWORD(rhs.flags) = 2048;
              *(_QWORD *)((char *)&rhs.flags + 2) = v6;
              HIWORD(rhs.epoch) = 2048;
              v54 = v21;
              v55 = 2048;
              v56 = v50;
              v57 = 1024;
              *(_DWORD *)v58 = a2;
              *(_WORD *)&v58[4] = 1024;
              *(_DWORD *)&v58[6] = v14;
              v22 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v18) = v48.value;
            }
            else
            {
              v22 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F40, 1u, 1, v22, v22 != &lhs, v18, 0, v19);
          }
          rhs = *v45;
          figTimeSyncClockGetClockTimeForHostTime(v6, &rhs, v15, &lhs);
          v67 = lhs.value;
          v23 = lhs.flags;
          v68 = lhs.timescale;
          if ((lhs.flags & 1) == 0)
            break;
          if (*(_QWORD *)v15 == *(_QWORD *)sTSNullgPTPClockIdentity)
            break;
          v24 = lhs.epoch;
          rhs = *v12;
          v48.value = v67;
          v48.timescale = v68;
          v48.flags = lhs.flags;
          v48.epoch = lhs.epoch;
          CMTimeSubtract(&lhs, &rhs, &v48);
          *v47 = lhs;
          rhs = v51;
          figTimeSyncClockGetClockTimeForHostTime(v6, &rhs, &v50, &lhs);
          value = lhs.value;
          flags = lhs.flags;
          timescale = lhs.timescale;
          if ((lhs.flags & 1) == 0)
            break;
          v25 = v50;
          if (*(_QWORD *)&v50 == *(_QWORD *)sTSNullgPTPClockIdentity)
            break;
          v26 = lhs.epoch;
          v16 = dword_1EE141F48;
          if (dword_1EE141F48)
          {
            v27 = v6;
            LODWORD(v48.value) = 0;
            type = OS_LOG_TYPE_DEFAULT;
            v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F40, 1, (int *)&v48, &type);
            v29 = v48.value;
            if (os_log_type_enabled(v28, type))
              v31 = v29;
            else
              v31 = v29 & 0xFFFFFFFE;
            if (v31)
            {
              lhs = *v44;
              Seconds = CMTimeGetSeconds(&lhs);
              lhs.value = v67;
              lhs.timescale = v68;
              lhs.flags = v23;
              lhs.epoch = v24;
              v33 = CMTimeGetSeconds(&lhs);
              v34 = *(_QWORD *)v46;
              lhs = *v47;
              v35 = CMTimeGetSeconds(&lhs);
              lhs = v51;
              v36 = CMTimeGetSeconds(&lhs);
              lhs.value = value;
              lhs.timescale = timescale;
              lhs.flags = flags;
              epoch = v26;
              lhs.epoch = v26;
              v37 = CMTimeGetSeconds(&lhs);
              LODWORD(rhs.value) = 136317186;
              *(CMTimeValue *)((char *)&rhs.value + 4) = (CMTimeValue)"figTimeSyncClock_getAnchorTimeWithResync";
              LOWORD(rhs.flags) = 2048;
              *(_QWORD *)((char *)&rhs.flags + 2) = v27;
              HIWORD(rhs.epoch) = 2048;
              v54 = Seconds;
              v55 = 2048;
              v56 = v33;
              v57 = 2048;
              *(_QWORD *)v58 = v34;
              *(_WORD *)&v58[8] = 2048;
              v59 = v35;
              v60 = 2048;
              v61 = v36;
              v62 = 2048;
              v63 = v37;
              v64 = 2048;
              v65 = v50;
              v38 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v29) = v48.value;
            }
            else
            {
              v38 = 0;
              epoch = v26;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F40, 1u, 1, v38, v38 != &lhs, v29, 0, v30);
            v16 = dword_1EE141F48;
            v25 = v50;
            v6 = v27;
            v12 = v44;
          }
          else
          {
            epoch = lhs.epoch;
          }
          v15 = v46;
          ++v14;
          if (*(_QWORD *)&v25 == *(_QWORD *)v46)
            goto LABEL_8;
        }
        v9 = 4294949326;
        DerivedStorage = (uint64_t)v42;
      }
      else
      {
LABEL_8:
        lhs.value = value;
        lhs.timescale = timescale;
        lhs.flags = flags;
        lhs.epoch = epoch;
        DerivedStorage = (uint64_t)v42;
        rhs = v42[4];
        CMTimeAdd(&v52, &lhs, &rhs);
        if (v40)
          *v40 = v52;
        if (v41)
          *v41 = v51;
        v9 = 0;
        v42[2] = v51;
        *v12 = v52;
      }
    }
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v9;
}

void figTimeSyncClockGetClockTimeForHostTime(uint64_t a1@<X0>, CMTime *a2@<X1>, _QWORD *a3@<X2>, CMTime *a4@<X8>)
{
  uint64_t DerivedStorage;
  uint64_t v9;
  uint64_t v10;
  int64_t ClockTimeAndGrandmasterIdentityForHostTime;
  int64_t v12;
  os_signpost_id_t v13;
  NSObject *v14;
  Float64 Seconds;
  Float64 v16;
  uint64_t v17;
  CMTime hostTime;
  uint64_t v19;
  __int16 v20;
  int64_t v21;
  __int16 v22;
  Float64 v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v17 = *(_QWORD *)sTSNullgPTPClockIdentity;
  *(_OWORD *)&a4->value = *(_OWORD *)&kCMTimeInvalid.value;
  a4->epoch = 0;
  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v9 = *(_QWORD *)(DerivedStorage + 16);
  hostTime = *a2;
  v10 = CMClockConvertHostTimeToSystemUnits(&hostTime);
  ClockTimeAndGrandmasterIdentityForHostTime = sTimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime(v9, v10, &v17);
  v12 = ClockTimeAndGrandmasterIdentityForHostTime;
  if (ClockTimeAndGrandmasterIdentityForHostTime != -1)
  {
    CMTimeMake(a4, ClockTimeAndGrandmasterIdentityForHostTime, 1000000000);
    if (a3)
      *a3 = v17;
  }
  v13 = *(_QWORD *)(DerivedStorage + 128);
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v14 = sLog;
    if (os_signpost_enabled((os_log_t)sLog))
    {
      hostTime = *a2;
      Seconds = CMTimeGetSeconds(&hostTime);
      hostTime = *a4;
      v16 = CMTimeGetSeconds(&hostTime);
      LODWORD(hostTime.value) = 134219264;
      *(CMTimeValue *)((char *)&hostTime.value + 4) = a1;
      LOWORD(hostTime.flags) = 2048;
      *(Float64 *)((char *)&hostTime.flags + 2) = Seconds;
      HIWORD(hostTime.epoch) = 2048;
      v19 = v10;
      v20 = 2048;
      v21 = v12;
      v22 = 2048;
      v23 = v16;
      v24 = 2048;
      v25 = v17;
      _os_signpost_emit_with_name_impl(&dword_18EC8D000, v14, OS_SIGNPOST_EVENT, v13, "TimeSyncConvertTime", "clock <%p> converted hosttime %g (in system units %llu) to clocktime %llu networktime %g using GM 0x%016llx", (uint8_t *)&hostTime, 0x3Eu);
    }
  }
}

void figTimeSyncClock_addClockToPeriodicTasksInternal(void *value)
{
  CFArrayAppendValue((CFMutableArrayRef)gPeriodicTaskClocksArray, value);
  CFRelease(value);
  figTimeSyncClock_updatePeriodicTasksTimerSourceInternal();
}

CFMutableArrayRef figTimeSyncClock_periodicTasksInitOnce()
{
  CFMutableArrayRef result;

  gPeriodicTasksQueue = (uint64_t)FigDispatchQueueCreateWithPriority("com.apple.coremedia.cmtimesyncclockperiodictasks", 0, 0x10u);
  gPeriodicTasksSource = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, (dispatch_queue_t)gPeriodicTasksQueue);
  dispatch_source_set_timer((dispatch_source_t)gPeriodicTasksSource, 0, 0x3B9ACA00uLL, 0x1DCD6500uLL);
  dispatch_source_set_event_handler_f((dispatch_source_t)gPeriodicTasksSource, (dispatch_function_t)figTimeSyncClock_performPeriodicTasksInternal);
  gPeriodicTasksIsArmed = 0;
  result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  gPeriodicTaskClocksArray = (uint64_t)result;
  return result;
}

void figTimeSyncClock_performPeriodicTasksInternal()
{
  CFIndex v0;
  id *ValueAtIndex;
  id *v2;
  id *v3;

  if (CFArrayGetCount((CFArrayRef)gPeriodicTaskClocksArray) >= 1)
  {
    v0 = 0;
    do
    {
      ValueAtIndex = (id *)CFArrayGetValueAtIndex((CFArrayRef)gPeriodicTaskClocksArray, v0);
      v2 = FigCFWeakReferenceHolderCopyReferencedObject(ValueAtIndex);
      if (v2)
      {
        v3 = v2;
        figTimeSyncClock_getAnchorTimeWithResync((uint64_t)v2, 0, 0, 0);
        CFRelease(v3);
      }
      else
      {
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)gPeriodicTaskClocksArray, v0--);
      }
      ++v0;
    }
    while (v0 < CFArrayGetCount((CFArrayRef)gPeriodicTaskClocksArray));
  }
  figTimeSyncClock_updatePeriodicTasksTimerSourceInternal();
}

void figTimeSyncClock_updatePeriodicTasksTimerSourceInternal()
{
  CFIndex Count;

  Count = CFArrayGetCount((CFArrayRef)gPeriodicTaskClocksArray);
  if (Count)
  {
    if ((gPeriodicTasksIsArmed & 1) != 0)
      return;
    dispatch_resume((dispatch_object_t)gPeriodicTasksSource);
  }
  else
  {
    if (!gPeriodicTasksIsArmed)
      return;
    dispatch_suspend((dispatch_object_t)gPeriodicTasksSource);
  }
  gPeriodicTasksIsArmed = Count != 0;
}

uint64_t FigAssetAnalysisReporterGetTypeID()
{
  if (FigAssetAnalysisReporterGetTypeID_sRegisterFigAssetAnalysisReporterTypeOnce != -1)
    dispatch_once_f(&FigAssetAnalysisReporterGetTypeID_sRegisterFigAssetAnalysisReporterTypeOnce, &FigAssetAnalysisReporterGetTypeID_sFigAssetAnalysisReporterID, (dispatch_function_t)RegisterFigAssetAnalysisReporterType);
  return FigAssetAnalysisReporterGetTypeID_sFigAssetAnalysisReporterID;
}

uint64_t RegisterFigAssetAnalysisReporterType(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigAssetAnalysisReporterCreate(const __CFAllocator *a1, _QWORD *a2)
{
  uint64_t Instance;
  _QWORD *v5;
  CFMutableArrayRef Mutable;
  uint64_t v8;
  uint64_t v9;

  if (!a2)
  {
    v8 = 4294949545;
    return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  if (FigAssetAnalysisReporterGetTypeID_sRegisterFigAssetAnalysisReporterTypeOnce != -1)
    dispatch_once_f(&FigAssetAnalysisReporterGetTypeID_sRegisterFigAssetAnalysisReporterTypeOnce, &FigAssetAnalysisReporterGetTypeID_sFigAssetAnalysisReporterID, (dispatch_function_t)RegisterFigAssetAnalysisReporterType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v8 = 4294949546;
    return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  v5 = (_QWORD *)Instance;
  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  v5[2] = Mutable;
  if (Mutable)
  {
    *a2 = v5;
    return 0;
  }
  else
  {
    v9 = FigSignalErrorAt(4294949546, 0, 0, 0, 0, 0, 0);
    CFRelease(v5);
    return v9;
  }
}

uint64_t FigAssetAnalysisReporterAddMessage(uint64_t a1, CFDictionaryRef theDict)
{
  if (!a1 || !theDict || CFDictionaryGetCount(theDict) <= 1 || !CFDictionaryGetValue(theDict, CFSTR("AnalysisType")))
    return FigSignalErrorAt(4294949545, 0, 0, 0, 0, 0, 0);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), theDict);
  return 0;
}

uint64_t FigAssetAnalysisReporterEditAndAppendMessage(uint64_t a1, CFDictionaryRef theDict, int a3)
{
  CFIndex Count;
  CFIndex v7;
  const __CFDictionary *ValueAtIndex;
  const __CFAllocator *v9;
  CFMutableDictionaryRef MutableCopy;
  const __CFDictionary *v11;
  __CFArray *Value;
  __CFArray *Mutable;
  __CFArray *v15;

  if (a1 && theDict && CFDictionaryGetCount(theDict) > 1 && CFDictionaryGetValue(theDict, CFSTR("AnalysisType")))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
    if (!Count)
      return FigAssetAnalysisReporterAddMessage(a1, theDict);
    v7 = Count - 1;
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), Count - 1);
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], ValueAtIndex);
    if (!MutableCopy)
      return 0;
    v11 = MutableCopy;
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 16), v7);
    if (CFDictionaryGetValue(v11, CFSTR("AtomContainer")))
    {
      Value = (__CFArray *)CFDictionaryGetValue(v11, CFSTR("AtomContainer"));
      CFArrayAppendValue(Value, theDict);
    }
    else
    {
      Mutable = CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]);
      if (!Mutable)
      {
LABEL_13:
        CFRelease(v11);
        return 0;
      }
      v15 = Mutable;
      CFArrayAppendValue(Mutable, theDict);
      CFDictionarySetValue(v11, CFSTR("AtomContainer"), v15);
      CFRelease(v15);
    }
    FigCFDictionarySetInt64(v11, CFSTR("MessageType"), a3);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), v11);
    goto LABEL_13;
  }
  return FigSignalErrorAt(4294949545, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAssetAnalysisReporterEditAndCombineMessage(uint64_t a1, CFDictionaryRef theDict)
{
  CFIndex Count;
  CFIndex v5;
  const __CFDictionary *ValueAtIndex;
  const __CFAllocator *v7;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v9;
  CFMutableStringRef Mutable;
  __CFString *v11;
  const __CFString *Value;
  const __CFString *v13;
  int v15;
  int v16;

  if (!a1 || !theDict || CFDictionaryGetCount(theDict) <= 1 || !CFDictionaryGetValue(theDict, CFSTR("AnalysisType")))
    return FigSignalErrorAt(4294949545, 0, 0, 0, 0, 0, 0);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  if (!Count)
    return FigAssetAnalysisReporterAddMessage(a1, theDict);
  v5 = Count - 1;
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), Count - 1);
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], ValueAtIndex);
  if (MutableCopy)
  {
    v9 = MutableCopy;
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 16), v5);
    v16 = 0;
    if (FigCFDictionaryGetInt32IfPresent((uint64_t)theDict, CFSTR("TrackID"), &v16))
      FigCFDictionarySetInt32(v9, CFSTR("TrackID"), v16);
    v15 = 0;
    if (FigCFDictionaryGetInt32IfPresent((uint64_t)theDict, CFSTR("TrackType"), &v15))
      FigCFDictionarySetInt32(v9, CFSTR("TrackType"), v15);
    Mutable = CFStringCreateMutable(v7, 0);
    if (Mutable)
    {
      v11 = Mutable;
      Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("DiagnosticInformation"));
      if (Value)
        CFStringAppend(v11, Value);
      v13 = (const __CFString *)CFDictionaryGetValue(v9, CFSTR("DiagnosticInformation"));
      if (v13)
        CFStringAppend(v11, v13);
      CFDictionaryRemoveValue(v9, CFSTR("DiagnosticInformation"));
      CFDictionarySetValue(v9, CFSTR("DiagnosticInformation"), v11);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), v9);
      CFRelease(v11);
    }
    CFRelease(v9);
  }
  return 0;
}

uint64_t FigAssetAnalysisReporterCopyMessages(CFArrayRef *a1, CFArrayRef *a2)
{
  const __CFAllocator *v4;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294949545, 0, 0, 0, 0, 0, 0);
  v4 = CFGetAllocator(a1);
  *a2 = CFArrayCreateCopy(v4, a1[2]);
  return 0;
}

uint64_t AssetAnalysisReporter_Init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

void AssetAnalysisReporter_Finalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

__CFString *AssetAnalysisReporter_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  const __CFArray *Count;

  Mutable = CFStringCreateMutable(0, 0);
  Count = *(const __CFArray **)(a1 + 16);
  if (Count)
    Count = (const __CFArray *)CFArrayGetCount(Count);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigAssetAnalysisReporter %d messages"), Count);
  return Mutable;
}

unint64_t FigAtomicIncrement64(unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  do
  {
    v1 = __ldxr(a1);
    v2 = v1 + 1;
  }
  while (__stxr(v2, a1));
  return v2;
}

unint64_t FigAtomicDecrement64(unint64_t *a1)
{
  unint64_t v1;
  unint64_t v2;

  do
  {
    v1 = __ldxr(a1);
    v2 = v1 - 1;
  }
  while (__stxr(v2, a1));
  return v2;
}

uint64_t FigAtomicBitOr32(int a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;

  do
  {
    v2 = __ldxr(a2);
    v3 = v2 | a1;
  }
  while (__stxr(v3, a2));
  return v3;
}

uint64_t FigAtomicBitOr32Orig(int a1, unsigned int *a2)
{
  uint64_t v2;

  do
    v2 = __ldxr(a2);
  while (__stxr(v2 | a1, a2));
  return v2;
}

uint64_t FigAtomicBitXor32(int a1, unsigned int *a2)
{
  unsigned int v2;
  uint64_t v3;

  do
  {
    v2 = __ldxr(a2);
    v3 = v2 ^ a1;
  }
  while (__stxr(v3, a2));
  return v3;
}

uint64_t FigAtomicBitXor32Orig(int a1, unsigned int *a2)
{
  uint64_t v2;

  do
    v2 = __ldxr(a2);
  while (__stxr(v2 ^ a1, a2));
  return v2;
}

uint64_t FigAtomicCompareAndSwapPtr(uint64_t a1, unint64_t a2, unint64_t *a3)
{
  unint64_t v3;
  uint64_t result;

  while (1)
  {
    v3 = __ldxr(a3);
    if (v3 != a1)
      break;
    if (!__stxr(a2, a3))
      return 1;
  }
  result = 0;
  __clrex();
  return result;
}

pthread_mutex_t *FigSimpleMutexCreateWithFlags(const __CFAllocator *a1)
{
  return FigSimpleMutexCreateWithAttr(a1, 0);
}

pthread_mutex_t *FigReentrantMutexCreateWithFlags(const __CFAllocator *a1)
{
  pthread_mutex_t *v2;
  pthread_mutexattr_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4.__sig = 0;
  *(_QWORD *)v4.__opaque = 0;
  v2 = 0;
  if (!pthread_mutexattr_init(&v4))
  {
    if (pthread_mutexattr_settype(&v4, 2))
      v2 = 0;
    else
      v2 = FigSimpleMutexCreateWithAttr(a1, &v4);
    pthread_mutexattr_destroy(&v4);
  }
  return v2;
}

_QWORD *FigSemaphoreCreateWithFlags(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  pthread_mutex_t *v7;
  CFTypeRef v8;

  v6 = CFAllocatorAllocate(a1, 96, 0);
  if (!v6)
    return v6;
  v7 = FigReentrantMutexCreateWithFlags(a1);
  *v6 = v7;
  if (!v7)
  {
LABEL_10:
    CFAllocatorDeallocate(a1, v6);
    return 0;
  }
  if (pthread_cond_init((pthread_cond_t *)(v6 + 1), 0))
  {
    FigSimpleMutexDestroy(*v6);
    goto LABEL_10;
  }
  v6[7] = a2;
  v6[8] = a3;
  v6[9] = 0;
  *((_BYTE *)v6 + 80) = 0;
  if (a1)
    v8 = CFRetain(a1);
  else
    v8 = 0;
  v6[11] = v8;
  return v6;
}

pthread_cond_t *FigConditionVariableCreateWithFlags(const __CFAllocator *a1)
{
  pthread_cond_t *v2;
  pthread_cond_t *v3;
  CFTypeRef v4;

  v2 = (pthread_cond_t *)CFAllocatorAllocate(a1, 56, 0);
  v3 = v2;
  if (!v2 || pthread_cond_init(v2, 0))
  {
    CFAllocatorDeallocate(a1, v3);
    return 0;
  }
  else
  {
    if (a1)
      v4 = CFRetain(a1);
    else
      v4 = 0;
    v3[1].__sig = (uint64_t)v4;
  }
  return v3;
}

pthread_cond_t *FigConditionVariableCreate()
{
  return FigConditionVariableCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
}

uint64_t FigConditionVariableWaitRelative(pthread_cond_t *a1, pthread_mutex_t *a2, unint64_t a3)
{
  uint64_t result;

  LODWORD(result) = WaitOnConditionTimedRelative(a1, a2, a3);
  if ((_DWORD)result == 60)
    return 4294954504;
  else
    return result;
}

uint64_t WaitOnConditionTimedRelative(pthread_cond_t *a1, pthread_mutex_t *a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  __darwin_time_t v5;
  uint64_t v7;
  uint64_t v8;
  timespec v9;
  uint64_t v10;
  uint64_t v11;

  if ((a3 & 0x8000000000000000) != 0)
    return WaitOnCondition(a1, a2);
  if (a3 <= 0x3B9AC9FF)
  {
    v5 = 0;
  }
  else
  {
    v5 = a3 / 0x3B9ACA00;
    a3 %= 0x3B9ACA00uLL;
  }
  v10 = v3;
  v11 = v4;
  v9.tv_sec = v5;
  v9.tv_nsec = a3;
  v7 = pthread_cond_timedwait_relative_np(a1, a2, &v9);
  v8 = v7;
  if ((_DWORD)v7)
  {
    if ((_DWORD)v7 != 60)
      FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  return v8;
}

const __CFAllocator *FigConditionVariableDestroy(uint64_t a1)
{
  uint64_t v2;
  const __CFAllocator *v3;

  if (!a1)
    return 0;
  v2 = pthread_cond_destroy((pthread_cond_t *)a1);
  if (!(_DWORD)v2)
  {
    v3 = *(const __CFAllocator **)(a1 + 48);
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_QWORD *)(a1 + 48) = 0;
    CFAllocatorDeallocate(v3, (void *)a1);
    if (!v3)
      return v3;
    CFRelease(v3);
    return 0;
  }
  v3 = (const __CFAllocator *)v2;
  FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  return v3;
}

char *FigEventCreate(char a1, char a2)
{
  char *v4;
  pthread_mutex_t *v5;

  v4 = (char *)malloc_type_calloc(1uLL, 0x48uLL, 0x1020040989DC6A3uLL);
  if (v4)
  {
    v5 = FigReentrantMutexCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
    *(_QWORD *)v4 = v5;
    if (v5)
    {
      if (!pthread_cond_init((pthread_cond_t *)(v4 + 8), 0))
      {
        *((_QWORD *)v4 + 7) = 0;
        v4[64] = a2;
        v4[66] = a1;
        v4[67] = 0;
        return v4;
      }
      FigSimpleMutexDestroy(*(_QWORD *)v4);
    }
    free(v4);
    return 0;
  }
  return v4;
}

pthread_mutex_t **FigEventDestroy(pthread_mutex_t **result)
{
  pthread_mutex_t **v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    result = (pthread_mutex_t **)pthread_mutex_lock(*result);
    if (!(_DWORD)result)
    {
      *((_BYTE *)v1 + 67) = 1;
      if (!pthread_cond_broadcast((pthread_cond_t *)(v1 + 1)))
      {
        while ((*((_BYTE *)v1 + 65) || v1[7]) && !WaitOnCondition((pthread_cond_t *)(v1 + 1), *v1))
          ;
      }
      pthread_mutex_unlock(*v1);
      FigSimpleMutexDestroy((uint64_t)*v1);
      v2 = pthread_cond_destroy((pthread_cond_t *)(v1 + 1));
      *(_OWORD *)v1 = 0u;
      *((_OWORD *)v1 + 1) = 0u;
      *((_OWORD *)v1 + 2) = 0u;
      *((_OWORD *)v1 + 3) = 0u;
      v1[8] = 0;
      free(v1);
      return (pthread_mutex_t **)v2;
    }
  }
  return result;
}

uint64_t FigEventSet(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if ((_DWORD)v2)
    return v2;
  if (*(_BYTE *)(a1 + 67))
  {
    v3 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
LABEL_5:
    v4 = v3;
    goto LABEL_20;
  }
  while (*(_BYTE *)(a1 + 65))
  {
    v3 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
    if ((_DWORD)v3)
      goto LABEL_5;
  }
  if (!*(_BYTE *)(a1 + 64))
  {
    *(_WORD *)(a1 + 64) = 257;
    v5 = pthread_cond_broadcast((pthread_cond_t *)(a1 + 8));
    v4 = v5;
    if (*(_BYTE *)(a1 + 66))
    {
      if ((_DWORD)v5)
      {
LABEL_19:
        *(_BYTE *)(a1 + 65) = 0;
        pthread_cond_broadcast((pthread_cond_t *)(a1 + 8));
        goto LABEL_20;
      }
      while (*(uint64_t *)(a1 + 56) >= 1)
      {
        v6 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
        if ((_DWORD)v6)
          goto LABEL_18;
      }
    }
    else
    {
      if (*(uint64_t *)(a1 + 56) < 1 || (_DWORD)v5)
        goto LABEL_19;
      while (*(_BYTE *)(a1 + 64))
      {
        v6 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
        if ((_DWORD)v6)
        {
LABEL_18:
          v4 = v6;
          goto LABEL_19;
        }
      }
    }
    v4 = 0;
    goto LABEL_19;
  }
  v4 = 0;
LABEL_20:
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v4;
}

uint64_t FigEventReset(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if ((_DWORD)v2)
    return v2;
  if (*(_BYTE *)(a1 + 67))
  {
    v3 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
LABEL_5:
    v4 = v3;
  }
  else
  {
    while (*(_BYTE *)(a1 + 65))
    {
      v3 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
      if ((_DWORD)v3)
        goto LABEL_5;
    }
    v4 = 0;
    *(_BYTE *)(a1 + 64) = 0;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v4;
}

uint64_t FigEventWaitRelative(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  pthread_mutex_t *v11;
  pthread_cond_t *v12;
  uint64_t v14;

  v2 = a2;
  if (a2 < 0)
  {
    v5 = 1;
  }
  else
  {
    v14 = 0;
    v4 = RelativeTimeToAbsoluteTime(a2, &v14);
    if (v4)
      v2 = v14;
    v5 = v4 ^ 1;
  }
  v6 = pthread_mutex_lock(*(pthread_mutex_t **)a1);
  if ((_DWORD)v6)
    return v6;
  while (*(_BYTE *)(a1 + 65))
  {
    v7 = WaitOnCondition((pthread_cond_t *)(a1 + 8), *(pthread_mutex_t **)a1);
    if ((_DWORD)v7)
      goto LABEL_9;
  }
  if (*(_BYTE *)(a1 + 67))
    goto LABEL_33;
  v9 = 0;
  ++*(_QWORD *)(a1 + 56);
  do
  {
    if (*(_BYTE *)(a1 + 64))
      v10 = 0;
    else
      v10 = v9 == 0;
    if (!v10)
      break;
    v11 = *(pthread_mutex_t **)a1;
    v12 = (pthread_cond_t *)(a1 + 8);
    if (v2 < 0)
      v9 = WaitOnCondition(v12, v11);
    else
      v9 = v5 ? WaitOnConditionTimedRelative(v12, v11, v2) : WaitOnConditionTimed(v12, v11, v2);
  }
  while (!*(_BYTE *)(a1 + 67));
  --*(_QWORD *)(a1 + 56);
  if (v9)
  {
    v8 = v9 == 60 ? 4294954504 : v9;
  }
  else
  {
    v8 = 0;
    if (!*(_BYTE *)(a1 + 66))
      *(_BYTE *)(a1 + 64) = 0;
  }
  pthread_cond_broadcast((pthread_cond_t *)(a1 + 8));
  if (*(_BYTE *)(a1 + 67))
  {
LABEL_33:
    v7 = FigSignalErrorAt(4294954506, 0, 0, 0, 0, 0, 0);
LABEL_9:
    v8 = v7;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)a1);
  return v8;
}

uint64_t RelativeTimeToAbsoluteTime(uint64_t a1, uint64_t *a2)
{
  uint64_t result;
  unint64_t tv_sec;
  __darwin_time_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  BOOL v10;
  BOOL v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  BOOL v19;
  int v20;
  timeval v21;

  v21.tv_sec = 0;
  *(_QWORD *)&v21.tv_usec = 0;
  gettimeofday(&v21, 0);
  result = 0;
  tv_sec = v21.tv_sec;
  if (v21.tv_sec >= 0)
    v6 = v21.tv_sec;
  else
    v6 = -v21.tv_sec;
  v7 = ((unint64_t)v6 * (unsigned __int128)0xF4240uLL) >> 64;
  v8 = 1000000 * v6;
  if (v21.tv_sec >= 0)
    v9 = 1000000 * v6;
  else
    v9 = -1000000 * v6;
  v10 = v7 != 0;
  v11 = __OFADD__(v21.tv_usec, v9);
  v12 = v21.tv_usec + v9;
  v13 = v11;
  *a2 = v12;
  if (!v10 && v8 <= (tv_sec >> 63) + 0x7FFFFFFFFFFFFFFFLL && (v13 & 1) == 0)
  {
    if (v12 >= 0)
      v14 = v12;
    else
      v14 = -v12;
    v15 = ((unint64_t)v14 * (unsigned __int128)0x3E8uLL) >> 64;
    v16 = 1000 * v14;
    if (v12 >= 0)
      v17 = v16;
    else
      v17 = -(uint64_t)v16;
    v18 = ((unint64_t)v12 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
    if (v15)
      v19 = 1;
    else
      v19 = v16 > v18;
    v20 = v19;
    *a2 = a1 + v17;
    if (__OFADD__(a1, v17))
      v20 = 1;
    return v20 ^ 1u;
  }
  return result;
}

uint64_t WaitOnConditionTimed(pthread_cond_t *a1, pthread_mutex_t *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  __darwin_time_t v5;
  uint64_t v6;
  uint64_t v7;
  timespec v9;
  uint64_t v10;
  uint64_t v11;

  if (a3 <= 999999999)
  {
    v5 = 0;
  }
  else
  {
    v5 = a3 / 0x3B9ACA00uLL;
    a3 %= 0x3B9ACA00uLL;
  }
  v10 = v3;
  v11 = v4;
  v9.tv_sec = v5;
  v9.tv_nsec = a3;
  v6 = pthread_cond_timedwait(a1, a2, &v9);
  v7 = v6;
  if ((_DWORD)v6 && (_DWORD)v6 != 60)
    FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  return v7;
}

uint64_t figThreadMain(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t);
  const __CFString *v3;
  const __CFDictionary *v4;
  int v5;
  void *v6;
  const __CFBoolean *Value;
  const __CFBoolean *v8;
  CFTypeID v9;
  _opaque_pthread_t *v10;
  integer_t v11;
  uint64_t v12;
  pthread_t v13;
  char buffer[256];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(uint64_t (**)(uint64_t))a1;
  v1 = *((_QWORD *)a1 + 1);
  v3 = (const __CFString *)*((_QWORD *)a1 + 2);
  v4 = (const __CFDictionary *)*((_QWORD *)a1 + 4);
  v5 = a1[40];
  free(a1);
  if (v5)
  {
    v6 = (void *)voucher_adopt();
    os_release(v6);
  }
  if (v3)
  {
    if (CFStringGetCString(v3, buffer, 256, 0x600u))
      pthread_setname_np(buffer);
    CFRelease(v3);
  }
  if (v4)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v4, CFSTR("com.apple.fig.ThreadCreateKey_MachTimeSharePolicy"));
    if (Value)
    {
      v8 = Value;
      v9 = CFGetTypeID(Value);
      if (v9 == CFBooleanGetTypeID())
      {
        v10 = pthread_self();
        v11 = CFBooleanGetValue(v8);
        figSetPThreadTimesharePolicy(v10, v11);
      }
    }
    CFRelease(v4);
  }
  v12 = v2(v1);
  if (!FigThreadLockAbortList())
  {
    v13 = pthread_self();
    FigThreadRemoveFromAbortListAndCleanup((uint64_t)v13);
    FigThreadUnlockAbortList();
  }
  if (gGMFigKTraceEnabled == 1)
  {
    pthread_self();
    kdebug_trace();
  }
  return v12;
}

uint64_t figSetPThreadBackground(_opaque_pthread_t *a1, int a2)
{
  uint64_t result;
  integer_t v3;

  v3 = (a2 != 0) << 12;
  result = figSetPThreadPolicy(a1, 5u, &v3);
  if ((_DWORD)result)
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t figSetPThreadPriority(_opaque_pthread_t *a1, int a2)
{
  pid_t v4;
  uint64_t result;
  integer_t v6;
  _OWORD buffer[14];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  memset(buffer, 0, sizeof(buffer));
  v4 = getpid();
  if (proc_pidinfo(v4, 2, 0, buffer, 232) < 1)
  {
    result = 0xFFFFFFFFLL;
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  v6 = a2 - HIDWORD(v8);
  result = figSetPThreadPolicy(a1, 3u, &v6);
  if ((_DWORD)result)
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t FigThreadGetMachThreadPriorityValue(unsigned int a1)
{
  if (a1 <= 0x30)
    return kNativePriorityMap[a1];
  FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  return 47;
}

void FigThreadExit(void *a1)
{
  pthread_t v2;

  if (!FigThreadLockAbortList())
  {
    v2 = pthread_self();
    FigThreadRemoveFromAbortListAndCleanup((uint64_t)v2);
    FigThreadUnlockAbortList();
  }
  pthread_exit(a1);
}

_opaque_pthread_t *FigThreadIsValid(_opaque_pthread_t *result)
{
  if (result)
    return (_opaque_pthread_t *)(pthread_kill(result, 0) != 3);
  return result;
}

uint64_t figThreadBindToPID(_opaque_pthread_t *a1)
{
  uint64_t result;
  __uint64_t v2;

  v2 = 0;
  result = pthread_threadid_np(a1, &v2);
  if (!(_DWORD)result)
  {
    gAnyFigThreadIsPidBound = 1;
    return proc_pidbind();
  }
  return result;
}

uint64_t FigThreadSetProperty(_opaque_pthread_t *a1, CFTypeRef cf1, const __CFNumber *a3)
{
  CFTypeID TypeID;
  uint64_t v7;
  uint64_t result;
  CFTypeID v9;
  int SInt32;
  CFTypeID v11;
  integer_t Value;
  CFTypeID v13;
  int v14;
  unsigned int valuePtr;

  if (!cf1)
    return 4294954501;
  if (CFEqual(cf1, CFSTR("com.apple.fig.ThreadPropKey_Priority")))
  {
    if (a3)
    {
      TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(a3))
      {
        valuePtr = 0;
        CFNumberGetValue(a3, kCFNumberIntType, &valuePtr);
        v7 = valuePtr;
        if (gGMFigKTraceEnabled == 1)
        {
          FigThreadGetMachThreadPriorityValue(valuePtr);
          kdebug_trace();
        }
        if ((_DWORD)v7 == 16)
        {
          result = figSetPThreadBackground(a1, 1);
          if ((_DWORD)result)
            return result;
        }
        else
        {
          figSetPThreadBackground(a1, 0);
          result = figSetPThreadPriority(a1, kNativePriorityMap[v7]);
          if ((_DWORD)result)
            return result;
        }
        return 0;
      }
    }
    return FigSignalErrorAt(4294954501, 0, 0, 0, 0, 0, 0);
  }
  if (!CFEqual(cf1, CFSTR("com.apple.fig.ThreadPropKey_MachThreadPriority")))
  {
    if (CFEqual(cf1, CFSTR("com.apple.fig.ThreadPropKey_MachTimeSharePolicy")))
    {
      if (a3)
      {
        v11 = CFBooleanGetTypeID();
        if (v11 == CFGetTypeID(a3))
        {
          Value = CFBooleanGetValue(a3);
          return figSetPThreadTimesharePolicy(a1, Value);
        }
      }
      return FigSignalErrorAt(4294954501, 0, 0, 0, 0, 0, 0);
    }
    if (CFEqual(cf1, CFSTR("com.apple.fig.ThreadPropKey_ClientPID")))
    {
      if (a3)
      {
        v13 = CFNumberGetTypeID();
        if (v13 == CFGetTypeID(a3))
        {
          v14 = 0;
          CFNumberGetValue(a3, kCFNumberSInt32Type, &v14);
          return figThreadBindToPID(a1);
        }
      }
      return FigSignalErrorAt(4294954501, 0, 0, 0, 0, 0, 0);
    }
    return 4294954501;
  }
  if (!a3)
    return FigSignalErrorAt(4294954501, 0, 0, 0, 0, 0, 0);
  v9 = CFNumberGetTypeID();
  if (v9 != CFGetTypeID(a3))
    return FigSignalErrorAt(4294954501, 0, 0, 0, 0, 0, 0);
  SInt32 = FigCFNumberGetSInt32(a3);
  if (gGMFigKTraceEnabled == 1)
    kdebug_trace();
  figSetPThreadBackground(a1, 0);
  return figSetPThreadPriority(a1, SInt32);
}

uint64_t figSetPThreadTimesharePolicy(_opaque_pthread_t *a1, integer_t a2)
{
  uint64_t result;
  integer_t v3;

  v3 = a2;
  result = figSetPThreadPolicy(a1, 1u, &v3);
  if ((_DWORD)result)
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t FigThreadCopyProperty(_opaque_pthread_t *a1, CFTypeRef cf1, uint64_t a3, _QWORD *a4)
{
  thread_inspect_t v7;
  uint64_t MachThreadPriority;
  uint64_t v9;
  CFNumberRef SInt32;
  thread_inspect_t v12;
  thread_inspect_t v13;
  const void **v14;
  const void *v15;
  char v16;
  int v17;
  int v18;
  int valuePtr;

  if (!a4)
    return FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  if (!cf1)
    return 4294954501;
  if (CFEqual(cf1, CFSTR("com.apple.fig.ThreadPropKey_Priority")))
  {
    v18 = 0;
    v7 = pthread_mach_thread_np(a1);
    MachThreadPriority = figGetMachThreadPriority(v7, &v18);
    if (!(_DWORD)MachThreadPriority)
    {
      v9 = 1;
      while (kNativePriorityMap[v9] != v18)
      {
        if (++v9 == 49)
        {
          LODWORD(v9) = 5;
          break;
        }
      }
      valuePtr = v9;
      SInt32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
      goto LABEL_14;
    }
    return MachThreadPriority;
  }
  if (!CFEqual(cf1, CFSTR("com.apple.fig.ThreadPropKey_MachThreadPriority")))
  {
    if (CFEqual(cf1, CFSTR("com.apple.fig.ThreadPropKey_MachTimeSharePolicy")))
    {
      v16 = 1;
      v13 = pthread_mach_thread_np(a1);
      MachThreadPriority = figGetMachThreadTimesharePolicy(v13, &v16);
      if (!(_DWORD)MachThreadPriority)
      {
        if (v16)
          v14 = (const void **)MEMORY[0x1E0C9AE50];
        else
          v14 = (const void **)MEMORY[0x1E0C9AE40];
        v15 = *v14;
        *a4 = *v14;
        CFRetain(v15);
      }
      return MachThreadPriority;
    }
    return 4294954501;
  }
  v17 = 0;
  v12 = pthread_mach_thread_np(a1);
  MachThreadPriority = figGetMachThreadPriority(v12, &v17);
  if (!(_DWORD)MachThreadPriority)
  {
    SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v17);
LABEL_14:
    *a4 = SInt32;
  }
  return MachThreadPriority;
}

uint64_t figGetMachThreadTimesharePolicy(thread_inspect_t a1, _BYTE *a2)
{
  uint64_t v3;
  uint64_t result;
  BOOLean_t get_default;
  mach_msg_type_number_t policy_infoCnt;
  integer_t policy_info;

  policy_infoCnt = 1;
  policy_info = 0;
  get_default = 0;
  v3 = thread_policy_get(a1, 1u, &policy_info, &policy_infoCnt, &get_default);
  if ((_DWORD)v3)
    return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  result = 0;
  if (a2)
    *a2 = policy_info;
  return result;
}

uint64_t FigThreadAllocKey(uint64_t a1, pthread_key_t *a2)
{
  uint64_t result;
  pthread_key_t v4;

  v4 = 0;
  result = pthread_key_create(&v4, 0);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t FigThreadGetMaxLogicalCoreCount()
{
  pthread_once(&sGetLogicalCoreCountOnce, (void (*)(void))figGetMaxLogicalCoreCountOnce);
  return sLogicalCoreCount;
}

uint64_t figGetMaxLogicalCoreCountOnce()
{
  uint64_t result;
  size_t v1;
  unsigned int v2;

  v2 = 0;
  v1 = 4;
  result = sysctlbyname("hw.logicalcpu_max", &v2, &v1, 0, 0);
  if (!(_DWORD)result)
    sLogicalCoreCount = v2;
  return result;
}

uint64_t FigThreadGetIOPolicy(int *a1)
{
  int v2;
  int v3;
  const char *v4;
  uint64_t result;
  char __dst[8];

  if (!a1)
    return FigSignalErrorAt(4294954503, 0, 0, 0, 0, 0, 0);
  v2 = getiopolicy_np(0, 1);
  v3 = v2;
  if (gGMFigKTraceEnabled == 1)
  {
    if ((v2 + 1) > 6)
      v4 = "UNKNOWN";
    else
      v4 = off_1E28DCD38[v2 + 1];
    strncpy(__dst, v4, 8uLL);
    kdebug_trace();
  }
  if (v3 == -1)
    return FigSignalErrorAt(4294949734, 0, 0, 0, 0, 0, 0);
  result = 0;
  *a1 = v3;
  return result;
}

uint64_t FigThreadSetIOPolicy(int a1)
{
  uint64_t v2;
  const char *v3;
  char __dst[8];

  v2 = setiopolicy_np(0, 1, a1);
  if (gGMFigKTraceEnabled == 1)
  {
    if ((a1 + 1) > 6)
      v3 = "UNKNOWN";
    else
      v3 = off_1E28DCD38[a1 + 1];
    strncpy(__dst, v3, 8uLL);
    kdebug_trace();
  }
  if ((_DWORD)v2 == -1)
    return FigSignalErrorAt(4294949734, 0, 0, 0, 0, 0, 0);
  return v2;
}

uint64_t figSetPThreadPolicy(_opaque_pthread_t *a1, thread_policy_flavor_t a2, integer_t *a3)
{
  thread_act_t v6;
  uint64_t result;
  qos_class_t __qos_class;

  v6 = pthread_mach_thread_np(a1);
  __qos_class = QOS_CLASS_UNSPECIFIED;
  result = pthread_get_qos_class_np(a1, &__qos_class, 0);
  if ((_DWORD)result)
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  if (__qos_class)
    return 0;
  result = thread_policy_set(v6, a2, a3, 1u);
  if ((_DWORD)result)
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  return result;
}

unint64_t FigNanosecondsToHostTime(int64_t a1)
{
  unint64_t result;
  uint64_t v4;
  uint64_t v5;

  v4 = 0;
  v5 = 0;
  FigGetHostTimeToNanosecondsScale(&v5, &v4);
  result = a1;
  if (v5 != 1 || v4 != 1)
    return FigInt64MulDiv(a1, v4, v5, 0);
  return result;
}

unint64_t FigGetContinuousUpTimeNanoseconds()
{
  uint64_t v0;

  v0 = mach_continuous_time();
  return FigHostTimeToNanoseconds(v0);
}

uint64_t FigCFEqual(CFTypeRef cf1, CFTypeRef a2)
{
  uint64_t result;

  if (cf1 == a2)
    return 1;
  result = 0;
  if (cf1)
  {
    if (a2)
      return CFEqual(cf1, a2);
  }
  return result;
}

CFMutableDictionaryRef FigCFDictionaryCreateMutableCopy(const __CFAllocator *a1, CFDictionaryRef theDict)
{
  if (theDict)
    return CFDictionaryCreateMutableCopy(a1, 0, theDict);
  else
    return CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
}

CFMutableDictionaryRef FigCFDictionaryCreateMutableCopyWithCFTypeCallbacks(const __CFAllocator *a1, const __CFDictionary *a2)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v4;

  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = Mutable;
  if (a2 && Mutable)
    CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)setKeyInDictionaryApply, Mutable);
  return v4;
}

void FigCFDictionarySetAllValuesFromDictionary(void *context, CFDictionaryRef theDict)
{
  if (context)
  {
    if (theDict)
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)setKeyInDictionaryApply, context);
  }
}

CFMutableArrayRef FigCFArrayCreateMutableCopy(const __CFAllocator *a1, CFArrayRef theArray)
{
  if (theArray)
    return CFArrayCreateMutableCopy(a1, 0, theArray);
  else
    return CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
}

CFArrayRef FigCFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  if (theArray)
    return CFArrayCreateCopy(allocator, theArray);
  else
    return CFArrayCreate(allocator, 0, 0, MEMORY[0x1E0C9B378]);
}

CFArrayRef FigCFArrayCreateConcatenationOfTwoArrays(unint64_t cf, CFTypeRef a2)
{
  const __CFAllocator *v4;
  CFIndex Count;
  CFIndex v6;
  __CFArray *MutableCopy;
  const __CFAllocator *v9;
  const __CFArray *v10;
  CFRange v11;

  if (!(cf | (unint64_t)a2))
    return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B378]);
  if (a2)
  {
    if (cf)
    {
      v4 = CFGetAllocator((CFTypeRef)cf);
      Count = CFArrayGetCount((CFArrayRef)cf);
      v6 = CFArrayGetCount((CFArrayRef)a2);
      MutableCopy = CFArrayCreateMutableCopy(v4, v6 + Count, (CFArrayRef)cf);
      v11.length = CFArrayGetCount((CFArrayRef)a2);
      v11.location = 0;
      CFArrayAppendArray(MutableCopy, (CFArrayRef)a2, v11);
      return MutableCopy;
    }
    v9 = CFGetAllocator(a2);
    v10 = (const __CFArray *)a2;
  }
  else
  {
    v9 = CFGetAllocator((CFTypeRef)cf);
    v10 = (const __CFArray *)cf;
  }
  return CFArrayCreateCopy(v9, v10);
}

__CFArray *FigCFArrayCopySubarrayWithRange(const __CFAllocator *a1, CFArrayRef theArray, uint64_t a3, CFIndex a4)
{
  CFIndex Count;
  uint64_t v9;
  __CFArray *Mutable;
  uint64_t v11;
  BOOL v12;
  uint64_t v14;
  uint64_t v15;
  const void *ValueAtIndex;

  if (theArray)
    Count = CFArrayGetCount(theArray);
  else
    Count = 0;
  v9 = (a3 & (a3 >> 63)) + a4;
  Mutable = CFArrayCreateMutable(a1, a4, MEMORY[0x1E0C9B378]);
  v11 = a3 & ~(a3 >> 63);
  if (Mutable)
    v12 = v11 < Count;
  else
    v12 = 0;
  if (v12 && v9 >= 1)
  {
    v14 = 0;
    do
    {
      v15 = v11 + v14;
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v11 + v14);
      CFArrayAppendValue(Mutable, ValueAtIndex);
      ++v14;
    }
    while (v15 + 1 < Count && v14 < v9);
  }
  return Mutable;
}

void FigCFArrayAppendArray(__CFArray *a1, CFArrayRef theArray)
{
  CFRange v4;

  if (a1)
  {
    if (theArray)
    {
      v4.length = CFArrayGetCount(theArray);
      v4.location = 0;
      CFArrayAppendArray(a1, theArray, v4);
    }
  }
}

uint64_t FigCFArrayContainsValue(const __CFArray *a1, const void *a2)
{
  CFRange v5;

  if (!a1 || !a2)
    return 0;
  v5.length = CFArrayGetCount(a1);
  v5.location = 0;
  return CFArrayContainsValue(a1, v5, a2);
}

CFIndex FigCFArrayGetFirstIndexOfValue(const __CFArray *a1, const void *a2)
{
  uint64_t Count;
  CFRange v6;

  if (!a1)
    return -1;
  if (!a2)
    return -1;
  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return -1;
  v6.length = Count;
  v6.location = 0;
  return CFArrayGetFirstIndexOfValue(a1, v6, a2);
}

CFIndex FigCFArrayGetLastIndexOfValue(const __CFArray *a1, const void *a2)
{
  uint64_t Count;
  CFRange v6;

  if (!a1)
    return -1;
  if (!a2)
    return -1;
  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return -1;
  v6.length = Count;
  v6.location = 0;
  return CFArrayGetLastIndexOfValue(a1, v6, a2);
}

uint64_t FigCFArrayGetFirstIndexOfInt32(const __CFArray *a1, int a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  int v8;

  v8 = 0;
  if (!a1)
    return -1;
  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return -1;
  v5 = Count;
  v6 = 0;
  while (1)
  {
    figCFArrayGetNumberAtIndex(a1, v6, kCFNumberSInt32Type, &v8);
    if (v8 == a2)
      break;
    if (v5 == ++v6)
      return -1;
  }
  return v6;
}

uint64_t FigCFArrayGetInt32AtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberSInt32Type, a3);
}

uint64_t FigCFArrayGetLastIndexOfInt32(const __CFArray *a1, int a2)
{
  CFIndex Count;
  CFIndex v5;
  int v8;

  v8 = 0;
  if (a1)
  {
    Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      v5 = Count;
      while (v5-- >= 1)
      {
        figCFArrayGetNumberAtIndex(a1, v5, kCFNumberSInt32Type, &v8);
        if (v8 == a2)
          return v5;
      }
    }
  }
  return -1;
}

BOOL FigCFArrayRemoveLastElementOfValue(const __CFArray *a1, const void *a2)
{
  CFIndex LastIndexOfValue;

  LastIndexOfValue = FigCFArrayGetLastIndexOfValue(a1, a2);
  if (LastIndexOfValue != -1)
    CFArrayRemoveValueAtIndex(a1, LastIndexOfValue);
  return LastIndexOfValue != -1;
}

const void *FigCFArrayGetValueAtIndex(const __CFArray *a1, CFIndex a2)
{
  if (!a1 || a2 < 0 || CFArrayGetCount(a1) <= a2)
    return 0;
  else
    return CFArrayGetValueAtIndex(a1, a2);
}

const void *FigCFArrayGetLastValue(const __CFArray *a1)
{
  CFIndex v2;

  if (!a1 || CFArrayGetCount(a1) < 1)
    return 0;
  v2 = CFArrayGetCount(a1) - 1;
  return CFArrayGetValueAtIndex(a1, v2);
}

const void *FigCFArrayGetFirstValue(const __CFArray *a1)
{
  if (a1 && CFArrayGetCount(a1) >= 1)
    return CFArrayGetValueAtIndex(a1, 0);
  else
    return 0;
}

uint64_t FigCFArrayContainsInt(const __CFArray *a1, int a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  uint64_t v5;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = FigCFArrayContainsValue(a1, v3);
  CFRelease(v4);
  return v5;
}

uint64_t FigCFArrayContainsInt16(const __CFArray *a1, __int16 a2)
{
  const __CFAllocator *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t v6;
  __int16 valuePtr;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  valuePtr = a2;
  v4 = CFNumberCreate(v3, kCFNumberSInt16Type, &valuePtr);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = FigCFArrayContainsValue(a1, v4);
  CFRelease(v5);
  return v6;
}

CFNumberRef FigCFNumberCreateSInt16(const __CFAllocator *a1, __int16 a2)
{
  __int16 valuePtr;

  valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberSInt16Type, &valuePtr);
}

uint64_t FigCFArrayContainsInt32(const __CFArray *a1, int a2)
{
  const __CFAllocator *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t v6;
  int valuePtr;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  valuePtr = a2;
  v4 = CFNumberCreate(v3, kCFNumberSInt32Type, &valuePtr);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = FigCFArrayContainsValue(a1, v4);
  CFRelease(v5);
  return v6;
}

CFNumberRef FigCFNumberCreateSInt32(const __CFAllocator *a1, int a2)
{
  int valuePtr;

  valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberSInt32Type, &valuePtr);
}

uint64_t FigCFArrayContainsInt64(const __CFArray *a1, uint64_t a2)
{
  const __CFAllocator *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t v6;
  uint64_t valuePtr;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  valuePtr = a2;
  v4 = CFNumberCreate(v3, kCFNumberSInt64Type, &valuePtr);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = FigCFArrayContainsValue(a1, v4);
  CFRelease(v5);
  return v6;
}

CFNumberRef FigCFNumberCreateSInt64(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t valuePtr;

  valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberSInt64Type, &valuePtr);
}

CFArrayRef FigCFDictionaryCopyArrayOfValues(const void *a1)
{
  size_t Count;
  CFIndex v3;
  malloc_type_id_t v4;
  const __CFAllocator *v5;
  const void **v7;
  const __CFAllocator *v8;
  CFArrayRef v9;

  if (!a1)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    return CFArrayCreate(v5, 0, 0, MEMORY[0x1E0C9B378]);
  }
  if (CFDictionaryGetCount((CFDictionaryRef)a1) < 1)
  {
    v5 = CFGetAllocator(a1);
    return CFArrayCreate(v5, 0, 0, MEMORY[0x1E0C9B378]);
  }
  Count = CFDictionaryGetCount((CFDictionaryRef)a1);
  v3 = Count;
  if (Count)
  {
    if (Count >> 61)
      return 0;
    Count *= 8;
    if (!(8 * v3))
      return 0;
    v4 = 219851612;
  }
  else
  {
    v4 = 754892075;
  }
  v7 = (const void **)malloc_type_malloc(Count, v4);
  if (v7)
  {
    CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, 0, v7);
    v8 = CFGetAllocator(a1);
    v9 = CFArrayCreate(v8, v7, v3, MEMORY[0x1E0C9B378]);
    free(v7);
    return v9;
  }
  return 0;
}

CFArrayRef FigCFDictionaryCopyArrayOfKeys(const void *a1)
{
  size_t Count;
  CFIndex v3;
  malloc_type_id_t v4;
  const __CFAllocator *v5;
  const void **v7;
  const __CFAllocator *v8;
  CFArrayRef v9;

  if (!a1)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    return CFArrayCreate(v5, 0, 0, MEMORY[0x1E0C9B378]);
  }
  if (CFDictionaryGetCount((CFDictionaryRef)a1) < 1)
  {
    v5 = CFGetAllocator(a1);
    return CFArrayCreate(v5, 0, 0, MEMORY[0x1E0C9B378]);
  }
  Count = CFDictionaryGetCount((CFDictionaryRef)a1);
  v3 = Count;
  if (Count)
  {
    if (Count >> 61)
      return 0;
    Count *= 8;
    if (!(8 * v3))
      return 0;
    v4 = 219851612;
  }
  else
  {
    v4 = 754892075;
  }
  v7 = (const void **)malloc_type_malloc(Count, v4);
  if (v7)
  {
    CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v7, 0);
    v8 = CFGetAllocator(a1);
    v9 = CFArrayCreate(v8, v7, v3, MEMORY[0x1E0C9B378]);
    free(v7);
    return v9;
  }
  return 0;
}

CFMutableArrayRef FigCFDictionaryCreateMappedArray(const __CFDictionary *a1, CFArrayRef theArray)
{
  uint64_t Count;
  const __CFAllocator *v5;
  __CFArray *Mutable;
  CFIndex v7;
  const void *v8;
  const void *ValueAtIndex;
  const void *Value;
  const void *v11;

  if (!theArray)
    return CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  Count = CFArrayGetCount(theArray);
  v5 = CFGetAllocator(theArray);
  Mutable = CFArrayCreateMutable(v5, Count, MEMORY[0x1E0C9B378]);
  if (Count >= 1)
  {
    v7 = 0;
    v8 = (const void *)*MEMORY[0x1E0C9B0D0];
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
      Value = v8;
      if (a1)
        Value = CFDictionaryGetValue(a1, ValueAtIndex);
      if (Value)
        v11 = Value;
      else
        v11 = v8;
      CFArrayAppendValue(Mutable, v11);
      ++v7;
    }
    while (Count != v7);
  }
  return Mutable;
}

void FigCFDictionaryApplyBlock(const __CFDictionary *a1, void *context)
{
  if (a1)
  {
    if (context)
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)dictionaryBlockApplier, context);
  }
}

uint64_t dictionaryBlockApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void FigCFSetApplyBlock(const __CFSet *a1, void *context)
{
  if (a1)
  {
    if (context)
      CFSetApplyFunction(a1, (CFSetApplierFunction)setBlockApplier, context);
  }
}

uint64_t setBlockApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

const __CFArray *FigCFArrayForEach2(const __CFArray *theArray, const __CFArray *a2, uint64_t (*a3)(const void *, const void *, uint64_t), uint64_t a4)
{
  const __CFArray *v7;
  uint64_t v8;
  const __CFArray *v9;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v12;

  v7 = theArray;
  if (!theArray)
  {
    v8 = 0;
    if (a2)
      goto LABEL_3;
LABEL_5:
    v9 = 0;
    goto LABEL_6;
  }
  theArray = (const __CFArray *)CFArrayGetCount(theArray);
  v8 = (uint64_t)theArray;
  if (!a2)
    goto LABEL_5;
LABEL_3:
  theArray = (const __CFArray *)CFArrayGetCount(a2);
  v9 = theArray;
LABEL_6:
  if ((const __CFArray *)v8 != v9)
  {
    theArray = (const __CFArray *)FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    if (v8 >= (uint64_t)v9)
      v8 = (uint64_t)v9;
  }
  if (v8 >= 1)
  {
    for (i = 0; i != v8; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
      v12 = CFArrayGetValueAtIndex(a2, i);
      theArray = (const __CFArray *)a3(ValueAtIndex, v12, a4);
    }
  }
  return theArray;
}

void FigCFArrayApplyFunction(const __CFArray *a1, void (__cdecl *a2)(const void *, void *), void *a3)
{
  CFRange v6;

  if (a1)
  {
    v6.length = CFArrayGetCount(a1);
    v6.location = 0;
    CFArrayApplyFunction(a1, v6, a2, a3);
  }
}

void FigCFArrayApplyBlock(const __CFArray *a1, void *a2)
{
  CFRange v4;

  if (a1)
  {
    if (a2)
    {
      v4.length = CFArrayGetCount(a1);
      v4.location = 0;
      CFArrayApplyFunction(a1, v4, (CFArrayApplierFunction)arrayBlockApplier, a2);
    }
  }
}

uint64_t arrayBlockApplier(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFDictionaryRef FigCFDictionaryGetCount(CFDictionaryRef theDict)
{
  if (theDict)
    return (CFDictionaryRef)CFDictionaryGetCount(theDict);
  return theDict;
}

CFDictionaryRef FigCFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  if (theDict)
    return (CFDictionaryRef)CFDictionaryGetCountOfKey(theDict, key);
  return theDict;
}

void FigCFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  if (theDict)
    CFDictionaryRemoveAllValues(theDict);
}

void FigCFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  if (theArray)
    CFArrayRemoveAllValues(theArray);
}

uint64_t FigCFDictionaryGetValueForCaseInsensitiveKeyIfPresent(CFDictionaryRef theDict, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  result = 0;
  v6 = a2;
  v7 = 0;
  if (theDict && a2 && a3)
  {
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)figCFDictionaryCaseInsensitiveKeySearch, &v6);
    if (v7)
    {
      *a3 = v7;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFComparisonResult figCFDictionaryCaseInsensitiveKeySearch(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  const __CFString *v6;
  CFComparisonResult result;
  CFRange v8;

  v6 = *(const __CFString **)a3;
  v8.length = CFStringGetLength(*(CFStringRef *)a3);
  v8.location = 0;
  result = CFStringCompareWithOptions(v6, a1, v8, 1uLL);
  if (result == kCFCompareEqualTo && !*(_QWORD *)(a3 + 8))
    *(_QWORD *)(a3 + 8) = a2;
  return result;
}

void FigCFDictionarySetValue(void *a1, const void *a2, const void *a3)
{
  CFTypeID v6;
  CFTypeID TypeID;

  if (a1)
  {
    v6 = CFGetTypeID(a1);
    TypeID = CFDictionaryGetTypeID();
    if (a3)
    {
      if (a2)
      {
        if (v6 == TypeID)
          CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, a3);
      }
    }
  }
}

const void *FigCFDictionaryGetValue(const __CFDictionary *a1, const void *a2)
{
  CFTypeID v4;

  if (a1 && (v4 = CFGetTypeID(a1), v4 == CFDictionaryGetTypeID()))
    return CFDictionaryGetValue(a1, a2);
  else
    return 0;
}

const void *FigCFDictionaryGetStringValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;
  CFTypeID v4;

  Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value)
    return 0;
  v3 = Value;
  v4 = CFGetTypeID(Value);
  if (v4 != CFStringGetTypeID())
    return 0;
  return v3;
}

const void *FigCFDictionaryGetURLValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;
  CFTypeID v4;

  Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value)
    return 0;
  v3 = Value;
  v4 = CFGetTypeID(Value);
  if (v4 != CFURLGetTypeID())
    return 0;
  return v3;
}

const void *FigCFDictionaryGetDictionaryValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;
  CFTypeID v4;

  Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value)
    return 0;
  v3 = Value;
  v4 = CFGetTypeID(Value);
  if (v4 != CFDictionaryGetTypeID())
    return 0;
  return v3;
}

const void *FigCFDictionaryGetArrayValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;
  CFTypeID v4;

  Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value)
    return 0;
  v3 = Value;
  v4 = CFGetTypeID(Value);
  if (v4 != CFArrayGetTypeID())
    return 0;
  return v3;
}

const void *FigCFDictionaryGetDataValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;
  CFTypeID v4;

  Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value)
    return 0;
  v3 = Value;
  v4 = CFGetTypeID(Value);
  if (v4 != CFDataGetTypeID())
    return 0;
  return v3;
}

const void *FigCFDictionaryGetBooleanValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;
  CFTypeID v4;

  Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value)
    return 0;
  v3 = Value;
  v4 = CFGetTypeID(Value);
  if (v4 != CFBooleanGetTypeID())
    return 0;
  return v3;
}

const void *FigCFDictionaryGetNumberValue(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;
  CFTypeID v4;

  Value = FigCFDictionaryGetValue(a1, a2);
  if (!Value)
    return 0;
  v3 = Value;
  v4 = CFGetTypeID(Value);
  if (v4 != CFNumberGetTypeID())
    return 0;
  return v3;
}

void FigCFDictionaryAddEntriesToDictionaryWithRecursion(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  const void **v3;
  const void **v5;
  CFTypeID v8;
  CFTypeID v9;
  CFIndex Count;
  uint64_t v11;
  const void *v12;
  const void *v13;
  const void *Value;
  const void *v15;
  CFTypeID v16;
  CFTypeID v17;

  v3 = 0;
  if (a1)
  {
    v5 = 0;
    if (a2)
    {
      v8 = CFGetTypeID(a1);
      if (v8 == CFDictionaryGetTypeID() && (v9 = CFGetTypeID(a2), v9 == CFDictionaryGetTypeID()))
      {
        Count = CFDictionaryGetCount((CFDictionaryRef)a1);
        v3 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
        v5 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v3, v5);
        if (Count >= 1)
        {
          v11 = 0;
          while (1)
          {
            v12 = v3[v11];
            v13 = v5[v11];
            Value = CFDictionaryGetValue(a2, v12);
            if (!Value)
              break;
            if (v13
              && (v15 = Value, v16 = CFGetTypeID(v13), v16 == CFDictionaryGetTypeID())
              && (v17 = CFGetTypeID(v15), v17 == CFDictionaryGetTypeID()))
            {
              FigCFDictionaryAddEntriesToDictionaryWithRecursion(v13, v15, a3);
            }
            else if ((_DWORD)a3)
            {
              break;
            }
LABEL_14:
            if (Count == ++v11)
              goto LABEL_15;
          }
          CFDictionarySetValue(a2, v12, v13);
          goto LABEL_14;
        }
      }
      else
      {
        v3 = 0;
        v5 = 0;
      }
    }
  }
  else
  {
    v5 = 0;
  }
LABEL_15:
  free(v3);
  free(v5);
}

uint64_t FigCFDictionaryGetValueIfPresent(const __CFDictionary *a1, const void *a2, const void **a3)
{
  if (!a1 || !a2 || !a3)
    return 0;
  *a3 = 0;
  return CFDictionaryGetValueIfPresent(a1, a2, a3);
}

__CFDictionary *FigCFDictionaryCreateCopyRemovingKeys(CFDictionaryRef theDict, const void **a2, int a3)
{
  uint64_t v3;
  __CFDictionary *MutableCopy;
  const void *v6;

  LODWORD(v3) = a3;
  MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], theDict);
  if (a2 && (int)v3 >= 1)
  {
    v3 = v3;
    do
    {
      v6 = *a2++;
      CFDictionaryRemoveValue(MutableCopy, v6);
      --v3;
    }
    while (v3);
  }
  return MutableCopy;
}

uint64_t FigCFDictionaryGetCGFloatIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberCGFloatType, a3);
}

uint64_t figCFDictionaryGetNumberIfPresent(uint64_t result, const void *a2, CFNumberType a3, void *a4)
{
  const __CFDictionary *v7;
  CFTypeID v8;
  CFTypeID TypeID;
  void *value;

  value = 0;
  if (result)
  {
    v7 = (const __CFDictionary *)result;
    v8 = CFGetTypeID((CFTypeRef)result);
    if (v8 == CFDictionaryGetTypeID() && a2 && a4)
    {
      result = CFDictionaryGetValueIfPresent(v7, a2, (const void **)&value);
      if (!(_DWORD)result)
        return result;
      TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(value))
      {
        CFNumberGetValue((CFNumberRef)value, a3, a4);
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

uint64_t FigCFDictionarySetCGFloat(void *a1, const void *a2, double a3)
{
  double v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberCGFloatType, &v4);
}

uint64_t figCFDictionarySetNumber(void *a1, const void *a2, CFNumberType a3, const void *a4)
{
  CFTypeID v8;
  CFNumberRef v9;
  CFNumberRef v10;
  uint64_t v12;

  if (!a1)
    goto LABEL_7;
  v8 = CFGetTypeID(a1);
  if (v8 != CFDictionaryGetTypeID())
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (a2)
  {
    v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a3, a4);
    if (v9)
    {
      v10 = v9;
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, v9);
      CFRelease(v10);
      return 0;
    }
    v12 = 4294954305;
  }
  else
  {
LABEL_7:
    v12 = 4294954306;
  }
  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayGetCGFloatAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberCGFloatType, a3);
}

uint64_t figCFArrayGetNumberAtIndex(const void *a1, CFIndex a2, CFNumberType a3, void *a4)
{
  CFTypeID v8;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v10;
  CFTypeID v11;

  if (a1
    && (v8 = CFGetTypeID(a1), v8 == CFArrayGetTypeID())
    && a4
    && (a2 & 0x8000000000000000) == 0
    && CFArrayGetCount((CFArrayRef)a1) > a2
    && (ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, a2)) != 0
    && (v10 = ValueAtIndex, v11 = CFGetTypeID(ValueAtIndex), v11 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(v10, a3, a4);
    return 1;
  }
  else
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t FigCFArrayAppendCGFloat(void *a1, double a2)
{
  double v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberCGFloatType, &v3);
}

uint64_t figCFArrayAppendNumber(void *a1, CFNumberType a2, const void *a3)
{
  CFTypeID v6;
  CFNumberRef v7;
  CFNumberRef v8;
  uint64_t v10;

  if (a1)
  {
    v6 = CFGetTypeID(a1);
    if (v6 != CFArrayGetTypeID())
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3);
    if (v7)
    {
      v8 = v7;
      CFArrayAppendValue((CFMutableArrayRef)a1, v7);
      CFRelease(v8);
      return 0;
    }
    v10 = 4294954305;
  }
  else
  {
    v10 = 4294954306;
  }
  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFDictionaryGetFloatIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberFloatType, a3);
}

uint64_t FigCFDictionarySetFloat(void *a1, const void *a2, float a3)
{
  float v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberFloatType, &v4);
}

uint64_t FigCFArrayGetFloatAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberFloatType, a3);
}

uint64_t FigCFArrayAppendFloat(void *a1, float a2)
{
  float v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberFloatType, &v3);
}

uint64_t FigCFDictionaryGetFloat32IfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberFloat32Type, a3);
}

uint64_t FigCFDictionarySetFloat32(void *a1, const void *a2, float a3)
{
  float v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberFloat32Type, &v4);
}

uint64_t FigCFArrayGetFloat32AtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberFloat32Type, a3);
}

uint64_t FigCFArrayAppendFloat32(void *a1, float a2)
{
  float v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberFloat32Type, &v3);
}

uint64_t FigCFDictionaryGetDoubleIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberDoubleType, a3);
}

uint64_t FigCFDictionarySetDouble(void *a1, const void *a2, double a3)
{
  double v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberDoubleType, &v4);
}

uint64_t FigCFArrayGetDoubleAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberDoubleType, a3);
}

uint64_t FigCFArrayAppendDouble(void *a1, double a2)
{
  double v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberDoubleType, &v3);
}

uint64_t FigCFDictionaryGetInt16IfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberSInt16Type, a3);
}

uint64_t FigCFDictionarySetInt16(void *a1, const void *a2, __int16 a3)
{
  __int16 v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberSInt16Type, &v4);
}

uint64_t FigCFArrayGetInt16AtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberSInt16Type, a3);
}

uint64_t FigCFArrayAppendInt16(void *a1, __int16 a2)
{
  __int16 v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberSInt16Type, &v3);
}

uint64_t FigCFDictionaryGetIntIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberIntType, a3);
}

uint64_t FigCFDictionarySetInt(void *a1, const void *a2, int a3)
{
  int v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberIntType, &v4);
}

uint64_t FigCFArrayGetIntAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberIntType, a3);
}

uint64_t FigCFArrayAppendInt(void *a1, int a2)
{
  int v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberIntType, &v3);
}

uint64_t FigCFDictionaryGetInt32IfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberSInt32Type, a3);
}

uint64_t FigCFDictionarySetInt32(void *a1, const void *a2, int a3)
{
  int v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberSInt32Type, &v4);
}

uint64_t FigCFArrayAppendInt32(void *a1, int a2)
{
  int v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberSInt32Type, &v3);
}

uint64_t FigCFDictionarySetUInt32(void *a1, const void *a2, unsigned int a3)
{
  uint64_t *v3;
  CFNumberType v4;
  uint64_t v6;
  unsigned int v7;

  v7 = a3;
  if ((a3 & 0x80000000) != 0)
  {
    v6 = a3;
    v3 = &v6;
    v4 = kCFNumberSInt64Type;
  }
  else
  {
    v3 = (uint64_t *)&v7;
    v4 = kCFNumberSInt32Type;
  }
  return figCFDictionarySetNumber(a1, a2, v4, v3);
}

uint64_t FigCFDictionarySetUInt64(void *a1, const void *a2, uint64_t a3)
{
  CFNumberRef UInt64;
  CFNumberRef v6;

  UInt64 = FigCFNumberCreateUInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3);
  if (!UInt64)
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  v6 = UInt64;
  FigCFDictionarySetValue(a1, a2, UInt64);
  CFRelease(v6);
  return 0;
}

CFNumberRef FigCFNumberCreateUInt64(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t *v2;
  CFNumberType v3;
  _QWORD valuePtr[2];
  uint64_t v6;

  v6 = a2;
  if (a2 < 0)
  {
    valuePtr[0] = 0;
    valuePtr[1] = a2;
    v2 = valuePtr;
    v3 = kCFNumberMaxType|kCFNumberSInt8Type;
  }
  else
  {
    v2 = &v6;
    v3 = kCFNumberSInt64Type;
  }
  return CFNumberCreate(a1, v3, v2);
}

uint64_t FigCFDictionaryGetInt64IfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberSInt64Type, a3);
}

uint64_t FigCFDictionarySetInt64(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberSInt64Type, &v4);
}

uint64_t FigCFArrayGetInt64AtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberSInt64Type, a3);
}

uint64_t FigCFArrayAppendInt64(void *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberSInt64Type, &v3);
}

uint64_t FigCFDictionaryGetCFIndexIfPresent(uint64_t a1, const void *a2, void *a3)
{
  return figCFDictionaryGetNumberIfPresent(a1, a2, kCFNumberCFIndexType, a3);
}

uint64_t FigCFDictionarySetCFIndex(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a3;
  return figCFDictionarySetNumber(a1, a2, kCFNumberCFIndexType, &v4);
}

uint64_t FigCFArrayGetCFIndexAtIndex(const void *a1, CFIndex a2, void *a3)
{
  return figCFArrayGetNumberAtIndex(a1, a2, kCFNumberCFIndexType, a3);
}

uint64_t FigCFArrayAppendCFIndex(void *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return figCFArrayAppendNumber(a1, kCFNumberCFIndexType, &v3);
}

const __CFData *FigCFDictionarySetBase64Data(void *a1, const void *a2, const __CFData *Base64EncodedStringFromBytes)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  void *v10;
  void *value;

  value = 0;
  if (!a1)
    return 0;
  v6 = CFGetTypeID(a1);
  if (v6 != CFDictionaryGetTypeID() || !a2)
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (Base64EncodedStringFromBytes)
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    BytePtr = CFDataGetBytePtr(Base64EncodedStringFromBytes);
    Length = CFDataGetLength(Base64EncodedStringFromBytes);
    Base64EncodedStringFromBytes = (const __CFData *)FigCreateBase64EncodedStringFromBytes(v7, (uint64_t)BytePtr, Length, 0, (CFStringRef *)&value);
    v10 = value;
    if (!(_DWORD)Base64EncodedStringFromBytes)
    {
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, value);
      v10 = value;
    }
    if (v10)
      CFRelease(v10);
  }
  else
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
  return Base64EncodedStringFromBytes;
}

uint64_t FigCFDictionaryFindAnyKeyForValue(const __CFDictionary *a1, const void *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v5;
  _QWORD context[2];
  uint64_t v8;

  v3 = 0;
  v8 = 0;
  if (!a1 || !a2)
    return v3;
  if (a3)
  {
    context[0] = &v8;
    context[1] = a2;
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)findAnyKeyForValueApplier, context);
    v5 = v8;
    *a3 = v8;
    return v5 != 0;
  }
  return CFDictionaryContainsValue(a1, a2);
}

uint64_t findAnyKeyForValueApplier(uint64_t a1, CFTypeRef cf1, uint64_t a3)
{
  uint64_t result;

  result = CFEqual(cf1, *(CFTypeRef *)(a3 + 8));
  if ((_DWORD)result)
    **(_QWORD **)a3 = a1;
  return result;
}

uint64_t FigCFDictionarySetValueFromKeyInDict(__CFDictionary *a1, const void *a2, CFDictionaryRef theDict, void *key)
{
  uint64_t result;

  result = 0;
  if (a1 && a2 && theDict && key)
  {
    result = (uint64_t)CFDictionaryGetValue(theDict, key);
    if (result)
    {
      CFDictionarySetValue(a1, a2, (const void *)result);
      return 1;
    }
  }
  return result;
}

void setKeyInDictionaryApply(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

void FigCFDictionarySetBoolean(__CFDictionary *a1, const void *a2, int a3)
{
  const void **v3;

  if (a1 && a2)
  {
    v3 = (const void **)MEMORY[0x1E0C9AE50];
    if (!a3)
      v3 = (const void **)MEMORY[0x1E0C9AE40];
    CFDictionarySetValue(a1, a2, *v3);
  }
}

uint64_t FigCFDictionaryGetBooleanIfPresent(uint64_t result, const void *a2, Boolean *a3)
{
  const __CFDictionary *v5;
  CFTypeID v6;
  CFTypeID TypeID;
  void *value;

  value = 0;
  if (result)
  {
    v5 = (const __CFDictionary *)result;
    v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!(_DWORD)result)
        return result;
      TypeID = CFBooleanGetTypeID();
      if (TypeID == CFGetTypeID(value))
      {
        *a3 = CFBooleanGetValue((CFBooleanRef)value);
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

CFDictionaryRef FigCFRangeCopyAsDictionary(uint64_t a1, uint64_t a2, CFAllocatorRef allocator)
{
  CFNumberRef v5;
  CFNumberRef v6;
  CFDictionaryRef v7;
  const void *v9[2];
  __int128 valuePtr;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&valuePtr = a1;
  v5 = CFNumberCreate(allocator, kCFNumberSInt64Type, &valuePtr);
  *(_QWORD *)&valuePtr = a2;
  v6 = CFNumberCreate(allocator, kCFNumberSInt64Type, &valuePtr);
  valuePtr = xmmword_1E28DCDA0;
  v9[0] = v5;
  v9[1] = v6;
  v7 = CFDictionaryCreate(allocator, (const void **)&valuePtr, v9, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v5)
    CFRelease(v5);
  if (v6)
    CFRelease(v6);
  return v7;
}

uint64_t FigCFRangeMakeFromDictionary(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  if (!figCFDictionaryGetNumberIfPresent(a1, CFSTR("Location"), kCFNumberSInt64Type, &v7)
    || !figCFDictionaryGetNumberIfPresent(a1, CFSTR("Length"), kCFNumberSInt64Type, &v6))
  {
    return FigSignalErrorAt(4294954302, 0, 0, 0, 0, 0, 0);
  }
  result = 0;
  v5 = v6;
  *a2 = v7;
  a2[1] = v5;
  return result;
}

uint64_t FigCFDictionarySetRange(__CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  CFDictionaryRef v6;
  CFDictionaryRef v7;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  v6 = FigCFRangeCopyAsDictionary(a3, a4, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (v6)
  {
    v7 = v6;
    CFDictionarySetValue(a1, a2, v6);
    CFRelease(v7);
  }
  else
  {
    FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigCFDictionaryGetRangeIfPresent(CFDictionaryRef theDict, const void *a2, _OWORD *a3)
{
  uint64_t result;
  __int128 v6;
  void *value;

  if (!a3)
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  result = 0;
  if (theDict)
  {
    if (a2)
    {
      value = 0;
      result = CFDictionaryGetValueIfPresent(theDict, a2, (const void **)&value);
      if ((_DWORD)result)
      {
        v6 = 0uLL;
        if (!FigCFRangeMakeFromDictionary((uint64_t)value, &v6))
        {
          *a3 = v6;
          return 1;
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t FigCFDictionaryGetCMTimeIfPresent(uint64_t result, const void *a2, CMTime *a3)
{
  const __CFDictionary *v5;
  CFTypeID v6;
  CFTypeID TypeID;
  CMTime v8;
  void *value;

  value = 0;
  if (result)
  {
    v5 = (const __CFDictionary *)result;
    v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!(_DWORD)result)
        return result;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(value))
      {
        CMTimeMakeFromDictionary(&v8, (CFDictionaryRef)value);
        *a3 = v8;
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

uint64_t FigCFDictionarySetCMTime(void *a1, const void *a2, CMTime *a3)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  CMTime v11;

  if (!a1)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(a1);
  if (v6 != CFDictionaryGetTypeID())
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (!a2)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v11 = *a3;
  v8 = CMTimeCopyAsDictionary(&v11, v7);
  if (!v8)
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  v9 = v8;
  CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, v8);
  CFRelease(v9);
  return 0;
}

uint64_t FigCFDictionarySetCMTimeRange(void *a1, const void *a2, _OWORD *a3)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  __int128 v8;
  CFDictionaryRef v9;
  CFDictionaryRef v10;
  CMTimeRange v12;

  if (!a1)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(a1);
  if (v6 != CFDictionaryGetTypeID())
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (!a2)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = a3[1];
  *(_OWORD *)&v12.start.value = *a3;
  *(_OWORD *)&v12.start.epoch = v8;
  *(_OWORD *)&v12.duration.timescale = a3[2];
  v9 = CMTimeRangeCopyAsDictionary(&v12, v7);
  if (!v9)
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  v10 = v9;
  CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, v9);
  CFRelease(v10);
  return 0;
}

uint64_t FigCFDictionaryGetCMTimeRangeIfPresent(uint64_t result, const void *a2, _OWORD *a3)
{
  const __CFDictionary *v5;
  CFTypeID v6;
  CFTypeID TypeID;
  __int128 v8;
  CMTimeRange v9;
  void *value;

  value = 0;
  if (result)
  {
    v5 = (const __CFDictionary *)result;
    v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!(_DWORD)result)
        return result;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(value))
      {
        CMTimeRangeMakeFromDictionary(&v9, (CFDictionaryRef)value);
        v8 = *(_OWORD *)&v9.start.epoch;
        *a3 = *(_OWORD *)&v9.start.value;
        a3[1] = v8;
        a3[2] = *(_OWORD *)&v9.duration.timescale;
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

uint64_t FigCFArrayAppendCMTime(void *a1, CMTime *a2)
{
  CFTypeID v4;
  const __CFAllocator *v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  CMTime v9;

  if (!a1)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  v4 = CFGetTypeID(a1);
  if (v4 == CFArrayGetTypeID())
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = *a2;
    v6 = CMTimeCopyAsDictionary(&v9, v5);
    if (!v6)
      return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    v7 = v6;
    CFArrayAppendValue((CFMutableArrayRef)a1, v6);
    CFRelease(v7);
  }
  else
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigCFArrayGetCMTimeAtIndex(const void *a1, CFIndex a2, CMTime *a3)
{
  CFTypeID v6;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v8;
  CFTypeID v9;
  CMTime v11;

  if (a1
    && (v6 = CFGetTypeID(a1), v6 == CFArrayGetTypeID())
    && a3
    && (a2 & 0x8000000000000000) == 0
    && CFArrayGetCount((CFArrayRef)a1) > a2
    && (ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, a2)) != 0
    && (v8 = ValueAtIndex, v9 = CFGetTypeID(ValueAtIndex), v9 == CFDictionaryGetTypeID()))
  {
    CMTimeMakeFromDictionary(&v11, v8);
    *a3 = v11;
    return 1;
  }
  else
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

__CFString *FigCFCopyCompactDescription(const __CFSet *a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  figCFAppendCompactDescription(Mutable, a1);
  return Mutable;
}

void figCFAppendCompactDescription(CFMutableStringRef theString, const __CFSet *a2)
{
  CFTypeID TypeID;
  const __CFString *v5;
  const __CFString *v6;
  CFTypeID v7;
  CFTypeID v8;
  Float64 Seconds;
  CMTime context;
  CMTime v11;

  if (!a2)
  {
    v6 = CFSTR("NULL");
    goto LABEL_8;
  }
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    v7 = CFArrayGetTypeID();
    if (v7 != CFGetTypeID(a2))
    {
      v8 = CFSetGetTypeID();
      if (v8 == CFGetTypeID(a2))
      {
        v11.value = 0;
        FigCFSetCopyValuesAsCFArray(a2, (CFArrayRef *)&v11);
        CFStringAppend(theString, CFSTR("{"));
        figCFAppendArrayToCompactDescription(theString, (CFArrayRef)v11.value);
        CFStringAppend(theString, CFSTR("}"));
        if (v11.value)
          CFRelease((CFTypeRef)v11.value);
      }
      else
      {
        CFStringAppendFormat(theString, 0, CFSTR("%@"), a2);
      }
      return;
    }
    CFStringAppend(theString, CFSTR("["));
    figCFAppendArrayToCompactDescription(theString, a2);
    v6 = CFSTR("]");
LABEL_8:
    CFStringAppend(theString, v6);
    return;
  }
  memset(&v11, 0, sizeof(v11));
  CMTimeMakeFromDictionary(&v11, a2);
  if ((v11.flags & 1) != 0)
  {
    if ((v11.flags & 4) != 0)
    {
      v5 = CFSTR("+inf");
    }
    else if ((v11.flags & 8) != 0)
    {
      v5 = CFSTR("-inf");
    }
    else
    {
      if ((v11.flags & 0x10) == 0)
      {
        context = v11;
        Seconds = CMTimeGetSeconds(&context);
        CFStringAppendFormat(theString, 0, CFSTR("%1.3f"), *(_QWORD *)&Seconds);
        return;
      }
      v5 = CFSTR("indef");
    }
  }
  else
  {
    *(_OWORD *)&context.value = (unint64_t)theString;
    CFStringAppend(theString, CFSTR("["));
    CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)figCFAppendCompactDictionaryDescription, &context);
    v5 = CFSTR("]");
  }
  CFStringAppend(theString, v5);
}

CFArrayRef FigCreateCFArrayFromColorValues(const __CFAllocator *a1, double a2, double a3, double a4, double a5)
{
  const __CFAllocator *v6;
  CFNumberRef v7;
  void *v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFTypeRef v12;
  CFArrayRef v13;
  double v15;
  double v16;
  double v17;
  double valuePtr;
  void *values;
  CFNumberRef v20;
  CFTypeRef v21;
  CFTypeRef cf;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v17 = a3;
  valuePtr = a2;
  v15 = a5;
  v16 = a4;
  v21 = 0;
  cf = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCGFloatType, &valuePtr);
  values = v7;
  if (!v7)
    return 0;
  v8 = v7;
  v9 = CFNumberCreate(v6, kCFNumberCGFloatType, &v17);
  v20 = v9;
  if (v9)
  {
    v10 = v9;
    v11 = CFNumberCreate(v6, kCFNumberCGFloatType, &v16);
    v21 = v11;
    if (v11)
    {
      v12 = v11;
      cf = CFNumberCreate(v6, kCFNumberCGFloatType, &v15);
      if (cf)
      {
        v13 = CFArrayCreate(a1, (const void **)&values, 4, MEMORY[0x1E0C9B378]);
        CFRelease(cf);
        v12 = v21;
      }
      else
      {
        v13 = 0;
      }
      CFRelease(v12);
      v10 = v20;
    }
    else
    {
      v13 = 0;
    }
    CFRelease(v10);
    v8 = values;
  }
  else
  {
    v13 = 0;
  }
  CFRelease(v8);
  return v13;
}

char *FigCFGetLocalTimeString(char *a1, size_t a2)
{
  CFAbsoluteTime Current;
  unsigned int v5;
  unsigned int v6;
  uint64_t v8;
  long double __y;
  int v10;

  v10 = 0;
  v8 = 0;
  Current = CFAbsoluteTimeGetCurrent();
  v5 = llround(modf(Current, &__y) * 1000.0);
  if (v5 == 1000)
    v6 = 0;
  else
    v6 = v5;
  if (v5 == 1000)
    Current = Current + 1.0;
  FigThreadRunOnce(&sCFCalendarStuffOnce, (void (*)(void))figCreateCalendarStuffOnce);
  FigSimpleMutexLock((pthread_mutex_t *)sCFCalendarMutex);
  CFCalendarDecomposeAbsoluteTime((CFCalendarRef)sCFGregorianCalendar, Current, "Hms", (char *)&v8 + 4, &v8, &v10);
  FigSimpleMutexUnlock((pthread_mutex_t *)sCFCalendarMutex);
  snprintf(a1, a2, "%02d:%02d:%02d.%03d", HIDWORD(v8), v8, v10, v6);
  return a1;
}

CFTimeZoneRef figCreateCalendarStuffOnce()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  const __CFAllocator *v1;
  CFTimeZoneRef result;

  sCFGregorianCalendar = (uint64_t)CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFCalendarIdentifier)*MEMORY[0x1E0C9B008]);
  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  sCFCalendarMutex = (uint64_t)FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  v1 = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  result = CFTimeZoneCreateWithTimeIntervalFromGMT(v1, 0.0);
  sCFTimeZoneGMT = (uint64_t)result;
  return result;
}

uint64_t FigCFIOKitObjectGetTypeID()
{
  if (FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectInitOnce != -1)
    dispatch_once(&FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectInitOnce, &__block_literal_global_18);
  return FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectTypeID;
}

uint64_t FigCFIOKitObjectCreate(uint64_t *a1, io_object_t a2)
{
  uint64_t Instance;
  uint64_t v5;
  uint64_t result;

  if (FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectInitOnce != -1)
    dispatch_once(&FigCFIOKitObjectGetTypeID_sFigCFIOKitObjectInitOnce, &__block_literal_global_18);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return 4294954305;
  v5 = Instance;
  IOObjectRetain(a2);
  result = 0;
  *(_DWORD *)(v5 + 16) = a2;
  *a1 = v5;
  return result;
}

uint64_t FigCFIOKitObjectGetIOKitObject(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

CFIndex FigCreateCFDataFromCFPropertyList(CFPropertyListRef propertyList, CFAllocatorRef allocator, CFDataRef *a3)
{
  CFDataRef v4;
  CFIndex Code;
  CFStringRef v6;
  CFErrorRef error;

  if (propertyList)
  {
    error = 0;
    v4 = CFPropertyListCreateData(allocator, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, &error);
    *a3 = v4;
    if (v4)
    {
      return 0;
    }
    else if (error)
    {
      Code = CFErrorGetCode(error);
      v6 = CFErrorCopyFailureReason(error);
      if (v6)
        CFRelease(v6);
      CFRelease(error);
    }
    else
    {
      return 4294954302;
    }
  }
  else
  {
    Code = 0;
    *a3 = CFDataCreate(allocator, 0, 0);
  }
  return Code;
}

CFIndex FigCreateCFPropertyListFromData(UInt8 *bytes, CFIndex length, CFAllocatorRef allocator, CFPropertyListRef *a4)
{
  const __CFData *v6;
  const __CFData *v7;
  CFIndex Code;
  CFStringRef v9;
  CFErrorRef error;

  if (length)
  {
    error = 0;
    v6 = CFDataCreateWithBytesNoCopy(allocator, bytes, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    if (v6)
    {
      v7 = v6;
      *a4 = CFPropertyListCreateWithData(allocator, v6, 0, 0, &error);
      CFRelease(v7);
      if (*a4)
      {
        return 0;
      }
      else if (error)
      {
        Code = CFErrorGetCode(error);
        v9 = CFErrorCopyFailureReason(error);
        if (v9)
          CFRelease(v9);
        CFRelease(error);
      }
      else
      {
        return 4294954302;
      }
    }
    else
    {
      return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    Code = 0;
    *a4 = 0;
  }
  return Code;
}

uint64_t FigCFTypeIsPListSerializable(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  CFTypeID v3;
  CFTypeID v4;
  CFIndex Count;
  CFIndex v6;
  size_t v7;
  const void **v8;
  const void **v9;
  uint64_t v10;
  const void *v11;
  const void *Value;
  CFTypeID v13;
  CFTypeID v14;
  CFIndex v15;
  CFIndex v16;
  CFIndex v17;
  const void *ValueAtIndex;
  uint64_t v20;
  uint64_t v21;
  CFTypeID TypeID;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v21 = 4294954305;
    goto LABEL_26;
  }
  TypeID = CFArrayGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  TypeID = CFBooleanGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  TypeID = CFDataGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  TypeID = CFDateGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  TypeID = CFDictionaryGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  TypeID = CFNumberGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  TypeID = CFStringGetTypeID();
  figCFArrayAppendNumber(Mutable, kCFNumberSInt64Type, &TypeID);
  if (!a1)
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    v9 = 0;
    goto LABEL_20;
  }
  v3 = CFGetTypeID((CFTypeRef)a1);
  if (!FigCFArrayContainsInt64(Mutable, v3))
  {
LABEL_25:
    v21 = 4294954306;
LABEL_26:
    FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    goto LABEL_27;
  }
  v4 = CFGetTypeID((CFTypeRef)a1);
  if (v4 == CFDictionaryGetTypeID())
  {
    Count = CFDictionaryGetCount((CFDictionaryRef)a1);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 8 * Count;
      v8 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      if (v8)
      {
        v9 = (const void **)malloc_type_malloc(v7, 0xC0040B8AA526DuLL);
        if (v9)
        {
          CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v8, v9);
          v10 = 0;
          while (1)
          {
            v11 = v8[v10];
            Value = CFDictionaryGetValue((CFDictionaryRef)a1, v11);
            v13 = CFGetTypeID(v11);
            if (v13 != CFStringGetTypeID() || !FigCFTypeIsPListSerializable(Value))
              break;
            if (v6 == ++v10)
              goto LABEL_19;
          }
          v20 = 4294954306;
        }
        else
        {
          v20 = 4294954305;
        }
        FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
        goto LABEL_28;
      }
      FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
LABEL_27:
      v9 = 0;
LABEL_28:
      a1 = 0;
      goto LABEL_20;
    }
    goto LABEL_18;
  }
  v14 = CFGetTypeID((CFTypeRef)a1);
  if (v14 == CFArrayGetTypeID())
  {
    v15 = CFArrayGetCount((CFArrayRef)a1);
    if (v15 >= 1)
    {
      v16 = v15;
      v17 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v17);
        if (!FigCFTypeIsPListSerializable(ValueAtIndex))
          goto LABEL_25;
      }
      while (v16 != ++v17);
    }
  }
LABEL_18:
  v8 = 0;
  v9 = 0;
LABEL_19:
  a1 = 1;
LABEL_20:
  free(v8);
  free(v9);
  if (Mutable)
    CFRelease(Mutable);
  return a1;
}

double FigGetCFPreferenceSizeWithDefault(const __CFString *a1, const __CFString *a2, double a3)
{
  const __CFString *v4;
  const __CFString *v5;
  CFTypeID TypeID;
  CFIndex v7;
  const __CFAllocator *v8;
  const __CFString *v9;
  CFStringRef v10;
  const __CFString *v11;
  BOOL v12;
  double v14;
  CFRange range;
  CFRange v16;
  CFRange v17;
  CFRange v18;

  v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  if (v4)
  {
    v5 = v4;
    TypeID = CFStringGetTypeID();
    if (TypeID != CFGetTypeID(v5))
      goto LABEL_12;
    range.location = 0;
    range.length = 0;
    v7 = CFStringGetLength(v5) - 1;
    v16.location = 0;
    v16.length = v7;
    if (!CFStringFindWithOptions(v5, CFSTR("x"), v16, 1uLL, &range))
      goto LABEL_12;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v17.length = range.location;
    v17.location = 0;
    v9 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5, v17);
    v18.location = range.location + 1;
    v18.length = v7 - range.location;
    v10 = CFStringCreateWithSubstring(v8, v5, v18);
    v11 = v10;
    if (v9)
      v12 = v10 == 0;
    else
      v12 = 1;
    if (v12)
    {
      if (!v9)
      {
        if (!v10)
        {
LABEL_12:
          CFRelease(v5);
          return a3;
        }
LABEL_11:
        CFRelease(v11);
        goto LABEL_12;
      }
    }
    else
    {
      FigGetDoubleFromCFTypeWithDefault(v9);
      a3 = v14;
      FigGetDoubleFromCFTypeWithDefault(v11);
    }
    CFRelease(v9);
    if (!v11)
      goto LABEL_12;
    goto LABEL_11;
  }
  return a3;
}

void FigGetDoubleFromCFTypeWithDefault(const __CFString *a1)
{
  CFTypeID v2;
  CFTypeID v3;
  uint64_t valuePtr;

  if (a1)
  {
    v2 = CFGetTypeID(a1);
    if (v2 == CFStringGetTypeID())
    {
      if (CFStringGetDoubleValue(a1) == 0.0)
      {
        if (CFStringCompare(a1, CFSTR("0"), 1uLL))
          CFStringCompare(a1, CFSTR("0.0"), 1uLL);
      }
    }
    else
    {
      v3 = CFGetTypeID(a1);
      if (v3 == CFNumberGetTypeID())
      {
        valuePtr = 0;
        CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &valuePtr);
      }
    }
  }
}

uint64_t FigCFDictionaryGetCGRectIfPresent(uint64_t result, const void *a2, CGRect *a3)
{
  const __CFDictionary *v5;
  CFTypeID v6;
  CFTypeID TypeID;
  void *value;

  value = 0;
  if (result)
  {
    v5 = (const __CFDictionary *)result;
    v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!(_DWORD)result)
        return result;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(value))
        return 0;
      if (CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)value, a3))
        return 1;
    }
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

uint64_t FigCFDictionarySetCGRect(void *a1, const void *a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  CFTypeID v12;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v14;
  uint64_t v16;
  CGRect v17;

  if (!a1)
    goto LABEL_7;
  v12 = CFGetTypeID(a1);
  if (v12 != CFDictionaryGetTypeID())
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (a2)
  {
    v17.origin.x = a3;
    v17.origin.y = a4;
    v17.size.width = a5;
    v17.size.height = a6;
    DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v17);
    if (DictionaryRepresentation)
    {
      v14 = DictionaryRepresentation;
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, DictionaryRepresentation);
      CFRelease(v14);
      return 0;
    }
    v16 = 4294954305;
  }
  else
  {
LABEL_7:
    v16 = 4294954306;
  }
  return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayAppendCGRect(void *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  CFTypeID v10;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v12;
  uint64_t v14;
  CGRect v15;

  if (a1)
  {
    v10 = CFGetTypeID(a1);
    if (v10 != CFArrayGetTypeID())
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    v15.origin.x = a2;
    v15.origin.y = a3;
    v15.size.width = a4;
    v15.size.height = a5;
    DictionaryRepresentation = CGRectCreateDictionaryRepresentation(v15);
    if (DictionaryRepresentation)
    {
      v12 = DictionaryRepresentation;
      CFArrayAppendValue((CFMutableArrayRef)a1, DictionaryRepresentation);
      CFRelease(v12);
      return 0;
    }
    v14 = 4294954305;
  }
  else
  {
    v14 = 4294954306;
  }
  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayGetCGRectAtIndex(const void *a1, CFIndex a2, CGRect *a3)
{
  CFTypeID v6;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v8;
  CFTypeID v9;

  if (a1)
  {
    v6 = CFGetTypeID(a1);
    if (v6 == CFArrayGetTypeID())
    {
      if (a3)
      {
        if ((a2 & 0x8000000000000000) == 0 && CFArrayGetCount((CFArrayRef)a1) > a2)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, a2);
          if (ValueAtIndex)
          {
            v8 = ValueAtIndex;
            v9 = CFGetTypeID(ValueAtIndex);
            if (v9 == CFDictionaryGetTypeID() && CGRectMakeWithDictionaryRepresentation(v8, a3))
              return 1;
          }
        }
      }
    }
  }
  FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigCFDictionaryGetCGSizeIfPresent(uint64_t result, const void *a2, CGSize *a3)
{
  const __CFDictionary *v5;
  CFTypeID v6;
  CFTypeID TypeID;
  void *value;

  value = 0;
  if (result)
  {
    v5 = (const __CFDictionary *)result;
    v6 = CFGetTypeID((CFTypeRef)result);
    if (v6 == CFDictionaryGetTypeID() && a2 && a3)
    {
      result = CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value);
      if (!(_DWORD)result)
        return result;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(value))
        return 0;
      if (CGSizeMakeWithDictionaryRepresentation((CFDictionaryRef)value, a3))
        return 1;
    }
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

uint64_t FigCFDictionarySetCGSize(void *a1, const void *a2, CGFloat a3, CGFloat a4)
{
  CFTypeID v8;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v10;
  uint64_t v12;
  CGSize v13;

  if (!a1)
    goto LABEL_7;
  v8 = CFGetTypeID(a1);
  if (v8 != CFDictionaryGetTypeID())
  {
    FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (a2)
  {
    v13.width = a3;
    v13.height = a4;
    DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(v13);
    if (DictionaryRepresentation)
    {
      v10 = DictionaryRepresentation;
      CFDictionarySetValue((CFMutableDictionaryRef)a1, a2, DictionaryRepresentation);
      CFRelease(v10);
      return 0;
    }
    v12 = 4294954305;
  }
  else
  {
LABEL_7:
    v12 = 4294954306;
  }
  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayAppendCGSize(void *a1, CGFloat a2, CGFloat a3)
{
  CFTypeID v6;
  CFDictionaryRef DictionaryRepresentation;
  CFDictionaryRef v8;
  uint64_t v10;
  CGSize v11;

  if (a1)
  {
    v6 = CFGetTypeID(a1);
    if (v6 != CFArrayGetTypeID())
    {
      FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    v11.width = a2;
    v11.height = a3;
    DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(v11);
    if (DictionaryRepresentation)
    {
      v8 = DictionaryRepresentation;
      CFArrayAppendValue((CFMutableArrayRef)a1, DictionaryRepresentation);
      CFRelease(v8);
      return 0;
    }
    v10 = 4294954305;
  }
  else
  {
    v10 = 4294954306;
  }
  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFArrayGetCGSizeAtIndex(const void *a1, CFIndex a2, CGSize *a3)
{
  CFTypeID v6;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v8;
  CFTypeID v9;

  if (a1)
  {
    v6 = CFGetTypeID(a1);
    if (v6 == CFArrayGetTypeID())
    {
      if (a3)
      {
        if ((a2 & 0x8000000000000000) == 0 && CFArrayGetCount((CFArrayRef)a1) > a2)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, a2);
          if (ValueAtIndex)
          {
            v8 = ValueAtIndex;
            v9 = CFGetTypeID(ValueAtIndex);
            if (v9 == CFDictionaryGetTypeID() && CGSizeMakeWithDictionaryRepresentation(v8, a3))
              return 1;
          }
        }
      }
    }
  }
  FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  return 0;
}

CFTypeRef FigCFTypeCollectionRetain(int a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

void FigCFTypeCollectionRelease(int a1, CFTypeRef cf)
{
  CFRelease(cf);
}

uint64_t FigASCIICFStringCaseInsensitiveEqualCallback(const __CFString *cf, const __CFString *cf2)
{
  CFTypeID v4;
  CFTypeID TypeID;
  CFTypeID v6;

  if (cf
    && (v4 = CFGetTypeID(cf), TypeID = CFStringGetTypeID(), cf2)
    && v4 == TypeID
    && (v6 = CFGetTypeID(cf2), v6 == CFStringGetTypeID()))
  {
    return CFStringCompare(cf, cf2, 1uLL) == kCFCompareEqualTo;
  }
  else
  {
    return CFEqual(cf, cf2);
  }
}

CFHashCode FigASCIICFStringCaseInsensitiveHashCallback(const __CFString *cf)
{
  CFTypeID v2;
  const __CFCharacterSet *Predefined;
  const __CFAllocator *v4;
  __CFString *MutableCopy;
  __CFString *v6;
  CFHashCode v7;
  CFRange v9;

  if (!cf)
    return CFHash(cf);
  v2 = CFGetTypeID(cf);
  if (v2 != CFStringGetTypeID())
    return CFHash(cf);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  v9.length = CFStringGetLength(cf);
  v9.location = 0;
  if (!CFStringFindCharacterFromSet(cf, Predefined, v9, 0, 0))
    return CFHash(cf);
  v4 = CFGetAllocator(cf);
  MutableCopy = CFStringCreateMutableCopy(v4, 0, cf);
  if (!MutableCopy)
    return CFHash(cf);
  v6 = MutableCopy;
  CFStringLowercase(MutableCopy, 0);
  v7 = CFHash(v6);
  CFRelease(v6);
  return v7;
}

CFPropertyListRef FigCreatePropertyListFromBundleIdentifier(const __CFAllocator *a1, CFStringRef bundleID, const __CFString *a3, const __CFString *a4)
{
  __CFBundle *BundleWithIdentifier;
  const __CFURL *v8;
  const __CFURL *v9;
  __CFReadStream *v10;
  __CFReadStream *v11;
  CFPropertyListRef v12;
  CFPropertyListFormat format;

  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(bundleID);
  if (!BundleWithIdentifier)
  {
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v8 = CFBundleCopyResourceURL(BundleWithIdentifier, a3, 0, a4);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = CFReadStreamCreateWithFile((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8);
  if (!v10)
  {
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    CFRelease(v9);
    return 0;
  }
  v11 = v10;
  format = 0;
  if (CFReadStreamOpen(v10))
  {
    v12 = CFPropertyListCreateWithStream(a1, v11, 0, 0, &format, 0);
    if (!v12)
      FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    v12 = 0;
  }
  CFRelease(v9);
  CFRelease(v11);
  return v12;
}

CFPropertyListRef FigCFCreatePropertyListFromBundleIdentifierOnPlatform(CFStringRef bundleID, const __CFString *a2)
{
  return FigCreateModelSpecificPropertyListFromBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E0C9AE00], bundleID, a2);
}

BOOL FigCFBundleIDResourceSubdirExists(const __CFString *a1, const __CFString *a2)
{
  __CFBundle *BundleWithIdentifier;
  const __CFURL *v4;
  const __CFURL *v5;
  const __CFURL *v6;
  const __CFURL *v7;
  _BOOL8 DoesFileExist;

  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(a1);
  if (BundleWithIdentifier && (v4 = CFBundleCopyResourcesDirectoryURL(BundleWithIdentifier)) != 0)
  {
    v5 = v4;
    v6 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, a2, 1u);
    if (v6)
    {
      v7 = v6;
      DoesFileExist = FigFileDoesFileExist(v6);
      CFRelease(v5);
      CFRelease(v7);
      return DoesFileExist;
    }
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
    CFRelease(v5);
  }
  else
  {
    FigSignalErrorAt(4294954304, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

UInt8 *FigCreateBytesFromCFString(const __CFAllocator *a1, CFStringRef theString, CFStringEncoding a3, int a4, _QWORD *a5)
{
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  UInt8 *v13;
  uint64_t v14;
  UInt8 *v15;
  CFIndex maxBufLen;
  CFRange v18;
  CFRange v19;

  maxBufLen = 0;
  if (a4)
  {
    HIDWORD(v11) = a3 - 256;
    LODWORD(v11) = a3 - 256;
    v10 = v11 >> 26;
    if (v10 > 7)
      v12 = 1;
    else
      v12 = qword_18EDDD180[v10];
  }
  else
  {
    v12 = 0;
  }
  v18.length = CFStringGetLength(theString);
  v18.location = 0;
  CFStringGetBytes(theString, v18, a3, 0, 0, 0, 0, &maxBufLen);
  v13 = (UInt8 *)CFAllocatorAllocate(a1, maxBufLen + v12, 0);
  v19.length = CFStringGetLength(theString);
  v19.location = 0;
  CFStringGetBytes(theString, v19, a3, 0, 0, v13, maxBufLen, 0);
  if (a4)
  {
    if (v12 <= 1)
      v14 = 1;
    else
      v14 = v12;
    v15 = v13;
    do
    {
      v15[maxBufLen] = 0;
      ++v15;
      --v14;
    }
    while (v14);
  }
  if (a5)
    *a5 = maxBufLen + v12;
  return v13;
}

UInt8 *FigCreateBytesFromCFStringAndMovieLangCode(const __CFAllocator *a1, const __CFString *a2, unsigned int a3, int a4, _QWORD *a5)
{
  CFStringEncoding v5;

  if (a3 > 0x97)
  {
    if (a3 != 0x7FFF && a3 >= 0x400)
      v5 = 134217984;
    else
      v5 = 0;
  }
  else
  {
    v5 = langCodeToStringEncoding[a3];
  }
  return FigCreateBytesFromCFString(a1, a2, v5, a4, a5);
}

uint64_t FigCFStringCreateWithBytesAndMovieLangCode(const __CFAllocator *a1, const UInt8 *a2, unint64_t a3, unsigned int a4, CFStringEncoding *a5, CFStringRef *a6)
{
  Boolean v7;
  CFStringEncoding v8;
  int v9;
  CFStringRef v10;
  uint64_t v12;

  if (!a2)
  {
    v12 = 4294954306;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (!a6)
  {
    v12 = 4294954306;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (a4 <= 0x97)
  {
    v7 = 0;
    v8 = langCodeToStringEncoding[a4];
    if (!a5)
      goto LABEL_16;
    goto LABEL_15;
  }
  if (a4 == 0x7FFF)
  {
    v8 = 0;
    v7 = 0;
    if (!a5)
      goto LABEL_16;
    goto LABEL_15;
  }
  if (a4 < 0x400)
  {
    v12 = 4294954303;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (a3 >= 2)
  {
    v9 = *a2;
    if (v9 == 255)
    {
      if (a2[1] != 254)
        goto LABEL_14;
    }
    else if (v9 != 254 || a2[1] != 255)
    {
      goto LABEL_14;
    }
    v7 = 1;
    v8 = 256;
    if (!a5)
      goto LABEL_16;
    goto LABEL_15;
  }
LABEL_14:
  v7 = 0;
  v8 = 134217984;
  if (a5)
LABEL_15:
    *a5 = v8;
LABEL_16:
  v10 = CFStringCreateWithBytes(a1, a2, a3, v8, v7);
  if (v10)
  {
    *a6 = v10;
    return 0;
  }
  v12 = 4294954302;
  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

const __CFString *FigCFStringFind(const __CFString *result, const __CFString *a2, CFStringCompareFlags a3)
{
  const __CFString *v5;
  CFTypeID v6;
  CFTypeID TypeID;
  CFTypeID v8;

  if (result)
  {
    v5 = result;
    v6 = CFGetTypeID(result);
    TypeID = CFStringGetTypeID();
    result = 0;
    if (a2)
    {
      if (v6 == TypeID)
      {
        v8 = CFGetTypeID(a2);
        if (v8 == CFStringGetTypeID())
          return (const __CFString *)(CFStringFind(v5, a2, a3).location != -1);
        else
          return 0;
      }
    }
  }
  return result;
}

CFStringRef FigCFStringGetIntAfterString(CFStringRef result, const __CFString *a2, SInt32 *a3)
{
  const __CFString *v5;
  CFTypeID v6;
  CFTypeID TypeID;
  CFTypeID v8;
  CFRange v9;
  const __CFAllocator *v10;
  const __CFString *v11;
  SInt32 IntValue;
  CFRange v13;

  if (result)
  {
    v5 = result;
    v6 = CFGetTypeID(result);
    TypeID = CFStringGetTypeID();
    result = 0;
    if (a2)
    {
      if (v6 == TypeID)
      {
        v8 = CFGetTypeID(a2);
        if (v8 != CFStringGetTypeID())
          return 0;
        v9 = CFStringFind(v5, a2, 0);
        if (v9.location == -1)
          return 0;
        v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v13.length = CFStringGetLength(v5) - v9.length;
        v13.location = v9.length;
        result = CFStringCreateWithSubstring(v10, v5, v13);
        if (!result)
          return result;
        v11 = result;
        IntValue = CFStringGetIntValue(result);
        if (!IntValue && CFStringCompare(v11, CFSTR("0"), 1uLL))
        {
          CFRelease(v11);
          return 0;
        }
        CFRelease(v11);
        if (a3)
          *a3 = IntValue;
        return (CFStringRef)1;
      }
    }
  }
  return result;
}

CFStringRef FigCFStringCreateLoggingIdentifierOfLength(const __CFAllocator *a1, uint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  CFStringRef v8;

  v4 = (char *)malloc_type_malloc(a2 + 1, 0x15522148uLL);
  v5 = v4;
  if (v4)
  {
    if (a2)
    {
      v6 = v4;
      v7 = a2;
      do
      {
        *v6++ = FigCFStringCreateLoggingIdentifierOfLength_charSet[arc4random_uniform(0x1Au)];
        --v7;
      }
      while (v7);
    }
    v5[a2] = 0;
    v8 = CFStringCreateWithCString(a1, v5, 0x600u);
  }
  else
  {
    v8 = 0;
  }
  free(v5);
  return v8;
}

CFLocaleRef FigCFLocaleCreateWithMovieLangCode(CFAllocatorRef alloc, unsigned int a2)
{
  const __CFString *CanonicalLocaleIdentifierFromScriptManagerCodes;
  const __CFString *v4;
  CFLocaleRef v5;
  UInt8 bytes[4];

  if (a2 == 0x7FFF)
    return 0;
  if (a2 > 0x3FF)
  {
    *(_DWORD *)bytes = (a2 >> 10) | 0x60;
    *(_WORD *)&bytes[1] = (a2 >> 5) & 0x1F | 0x60;
    bytes[2] = a2 & 0x1F | 0x60;
    CanonicalLocaleIdentifierFromScriptManagerCodes = CFStringCreateWithBytes(alloc, bytes, 4, 0x600u, 0);
  }
  else
  {
    CanonicalLocaleIdentifierFromScriptManagerCodes = CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(alloc, a2, -1);
  }
  v4 = CanonicalLocaleIdentifierFromScriptManagerCodes;
  if (!CanonicalLocaleIdentifierFromScriptManagerCodes)
    return 0;
  v5 = CFLocaleCreate(alloc, CanonicalLocaleIdentifierFromScriptManagerCodes);
  CFRelease(v4);
  return v5;
}

__CFArray *FigCopyRankedLanguagesAccordingToPreferredLanguages2(const __CFArray *a1, const __CFArray *a2, int a3)
{
  const __CFAllocator *v5;
  CFMutableArrayRef MutableCopy;
  __CFArray *v7;
  BOOL v8;
  CFIndex FirstIndexOfValue;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  CFIndex v13;
  CFIndex v14;
  __CFArray *Mutable;
  const __CFArray *v16;
  const __CFArray *v17;
  CFIndex Count;
  CFIndex v19;
  CFIndex v20;
  __CFString *ValueAtIndex;
  CFIndex v22;
  CFIndex v23;
  CFIndex v24;
  CFRange v26;
  CFRange v27;
  CFRange v28;
  CFRange v29;

  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = FigCFArrayCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
  v7 = FigCFArrayCreateMutableCopy(v5, a1);
  if (v7)
    v8 = MutableCopy == 0;
  else
    v8 = 1;
  if (v8)
  {
    Mutable = 0;
    if (!MutableCopy)
      goto LABEL_38;
LABEL_37:
    CFRelease(MutableCopy);
    goto LABEL_38;
  }
  v26.length = CFArrayGetCount(MutableCopy);
  v26.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(MutableCopy, v26, CFSTR("zh-Hant-HK"));
  v27.length = CFArrayGetCount(MutableCopy);
  v27.location = 0;
  v10 = CFArrayGetFirstIndexOfValue(MutableCopy, v27, CFSTR("zh-HK"));
  v11 = v10;
  if ((FirstIndexOfValue & 0x8000000000000000) == 0 || (v10 & 0x8000000000000000) == 0)
  {
    v28.length = CFArrayGetCount(MutableCopy);
    v28.location = 0;
    if (!CFArrayContainsValue(MutableCopy, v28, CFSTR("yue-Hant")))
    {
      if (FirstIndexOfValue >= v11)
        v12 = v11;
      else
        v12 = FirstIndexOfValue;
      if (FirstIndexOfValue <= v11)
        v13 = v11;
      else
        v13 = FirstIndexOfValue;
      if ((FirstIndexOfValue | v11) < 0)
        v14 = v13;
      else
        v14 = v12;
      CFArrayInsertValueAtIndex(MutableCopy, v14, CFSTR("yue-Hant"));
    }
  }
  CFArrayInsertValueAtIndex(v7, 0, CFSTR("ULTIMATUM"));
  CFArrayAppendValue(MutableCopy, CFSTR("ULTIMATUM"));
  Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E0C9B378]);
  if (CFArrayGetCount(v7) < 1)
    goto LABEL_37;
  do
  {
    v16 = CFBundleCopyLocalizationsForPreferences(v7, MutableCopy);
    if (!v16)
      continue;
    v17 = v16;
    Count = CFArrayGetCount(v16);
    if (Count < 1)
      goto LABEL_34;
    v19 = Count;
    v20 = 0;
    while (1)
    {
      ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v17, v20);
      v29.length = CFArrayGetCount(v7);
      v29.location = 0;
      v22 = CFArrayGetFirstIndexOfValue(v7, v29, ValueAtIndex);
      if (ValueAtIndex != CFSTR("ULTIMATUM"))
      {
        v23 = v22;
        if (!ValueAtIndex || !CFEqual(ValueAtIndex, CFSTR("ULTIMATUM")))
        {
          if ((v23 & 0x8000000000000000) == 0)
          {
            CFArrayRemoveValueAtIndex(v7, v23);
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
          goto LABEL_31;
        }
      }
      if (a3 || Mutable && CFArrayGetCount(Mutable))
        break;
      CFArrayRemoveValueAtIndex(v7, 0);
      v24 = CFArrayGetCount(MutableCopy);
      CFArrayRemoveValueAtIndex(MutableCopy, v24 - 1);
LABEL_31:
      if (v19 == ++v20)
        goto LABEL_34;
    }
    CFArrayRemoveAllValues(v7);
LABEL_34:
    CFRelease(v17);
  }
  while (CFArrayGetCount(v7) > 0);
  if (MutableCopy)
    goto LABEL_37;
LABEL_38:
  if (v7)
    CFRelease(v7);
  return Mutable;
}

__CFArray *FigCopyRankedLanguagesAccordingToPreferredLanguages(const __CFArray *a1, const __CFArray *a2)
{
  return FigCopyRankedLanguagesAccordingToPreferredLanguages2(a1, a2, 1);
}

const __CFString *FigCFDateCreateFromString(const __CFAllocator *a1, const __CFString *cf, const void *a3)
{
  const __CFString *v3;
  CFTypeID v6;
  const __CFLocale *v7;
  const __CFLocale *v8;
  UInt8 *BytesFromCFString;
  UInt8 *v10;
  const __CFString *v11;
  const void *v12;
  CFDateFormatterStyle v13;
  CFDateFormatterStyle v14;
  __CFDateFormatter *v15;
  __CFDateFormatter *v16;
  int AbsoluteTimeFromString;
  CFDateFormatterStyle v18;
  __CFDateFormatter *v19;
  __CFDateFormatter *v20;
  int v21;
  __CFCalendar *v22;
  CFAbsoluteTime Current;
  UInt8 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFAbsoluteTime atp;

  v3 = cf;
  if (!cf)
    return v3;
  v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID())
    return 0;
  if (a3)
    v7 = (const __CFLocale *)CFRetain(a3);
  else
    v7 = CFLocaleCopyCurrent();
  v8 = v7;
  atp = 0.0;
  BytesFromCFString = FigCreateBytesFromCFString(a1, v3, 0, 1, 0);
  if (!BytesFromCFString)
  {
    v3 = 0;
    if (!v8)
      return v3;
    goto LABEL_33;
  }
  v10 = BytesFromCFString;
  if (!FigCFParseISO8601Date((const char *)BytesFromCFString, &atp))
    goto LABEL_30;
  v25 = v10;
  v11 = (const __CFString *)*MEMORY[0x1E0C9AEF8];
  v12 = (const void *)*MEMORY[0x1E0C9AE50];
  v13 = kCFDateFormatterFullStyle;
  while (1)
  {
    v14 = v13;
    if (v13 == kCFDateFormatterNoStyle)
      break;
    v15 = CFDateFormatterCreate(0, v8, v13, kCFDateFormatterNoStyle);
    if (v15)
    {
      v16 = v15;
      CFDateFormatterSetProperty(v15, v11, v12);
      AbsoluteTimeFromString = CFDateFormatterGetAbsoluteTimeFromString(v16, v3, 0, &atp);
      CFRelease(v16);
    }
    else
    {
      AbsoluteTimeFromString = 0;
    }
    v13 = v14 - 1;
    if (AbsoluteTimeFromString)
      goto LABEL_19;
  }
  AbsoluteTimeFromString = 0;
LABEL_19:
  v18 = kCFDateFormatterFullStyle;
  while (v18)
  {
    v19 = CFDateFormatterCreate(0, v8, v14, v18);
    if (v19)
    {
      v20 = v19;
      CFDateFormatterSetProperty(v19, v11, v12);
      v21 = CFDateFormatterGetAbsoluteTimeFromString(v20, v3, 0, &atp);
      CFRelease(v20);
    }
    else
    {
      v21 = 0;
    }
    --v18;
    if (v21)
      goto LABEL_27;
  }
  v21 = 0;
LABEL_27:
  if (v21 | AbsoluteTimeFromString)
  {
    v10 = v25;
    if (v14 == kCFDateFormatterNoStyle)
    {
      v27 = 0;
      v28 = 0;
      v26 = 0;
      FigSimpleMutexLock((pthread_mutex_t *)sCFCalendarMutex);
      CFCalendarDecomposeAbsoluteTime((CFCalendarRef)sCFGregorianCalendar, atp, "Hms", (char *)&v28 + 4, &v28, (char *)&v27 + 4);
      v22 = (__CFCalendar *)sCFGregorianCalendar;
      Current = CFAbsoluteTimeGetCurrent();
      CFCalendarDecomposeAbsoluteTime(v22, Current, "Mdy", &v27, (char *)&v26 + 4, &v26);
      CFCalendarComposeAbsoluteTime((CFCalendarRef)sCFGregorianCalendar, &atp, "HmsMdy", HIDWORD(v28), v28, HIDWORD(v27), v27, HIDWORD(v26), v26);
      FigSimpleMutexUnlock((pthread_mutex_t *)sCFCalendarMutex);
    }
LABEL_30:
    v3 = (const __CFString *)CFDateCreate(a1, atp);
    goto LABEL_32;
  }
  v3 = 0;
  v10 = v25;
LABEL_32:
  CFAllocatorDeallocate(a1, v10);
  if (v8)
LABEL_33:
    CFRelease(v8);
  return v3;
}

uint64_t FigCFParseISO8601Date(const char *a1, CFAbsoluteTime *a2)
{
  char *v4;
  const __CFTimeZone *v5;
  int v6;
  int v7;
  unsigned int v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const char *v13;
  int v14;
  double v15;
  char *v16;
  __CFCalendar *v18;
  CFAbsoluteTime Current;
  tm v20;
  uint64_t v21;
  tm v22;

  memset(&v22, 0, sizeof(v22));
  FigThreadRunOnce(&sCFCalendarStuffOnce, (void (*)(void))figCreateCalendarStuffOnce);
  v4 = strptime(a1, "%FT%T", &v22);
  if (v4 || (v4 = strptime(a1, "%Y%m%dT%H%M%S", &v22)) != 0)
  {
    *(int32x2_t *)&v22.tm_mon = vadd_s32(*(int32x2_t *)&v22.tm_mon, (int32x2_t)0x76C00000001);
  }
  else
  {
    v4 = strptime(a1, "%T", &v22);
    if (!v4)
    {
      v4 = strptime(a1, "%H%M%S", &v22);
      if (!v4)
        goto LABEL_20;
    }
    v20.tm_sec = 0;
    v21 = 0;
    FigSimpleMutexLock((pthread_mutex_t *)sCFCalendarMutex);
    v18 = (__CFCalendar *)sCFGregorianCalendar;
    Current = CFAbsoluteTimeGetCurrent();
    CFCalendarDecomposeAbsoluteTime(v18, Current, "Mdy", &v20, (char *)&v21 + 4, &v21);
    FigSimpleMutexUnlock((pthread_mutex_t *)sCFCalendarMutex);
    v22.tm_mday = HIDWORD(v21);
    v22.tm_mon = v20.tm_sec;
    v22.tm_year = v21;
  }
  FigSimpleMutexLock((pthread_mutex_t *)sCFCalendarMutex);
  v5 = CFCalendarCopyTimeZone((CFCalendarRef)sCFGregorianCalendar);
  CFCalendarSetTimeZone((CFCalendarRef)sCFGregorianCalendar, (CFTimeZoneRef)sCFTimeZoneGMT);
  CFCalendarComposeAbsoluteTime((CFCalendarRef)sCFGregorianCalendar, a2, "HmsMdy", v22.tm_hour, v22.tm_min, v22.tm_sec, v22.tm_mon, v22.tm_mday, v22.tm_year);
  CFCalendarSetTimeZone((CFCalendarRef)sCFGregorianCalendar, v5);
  FigSimpleMutexUnlock((pthread_mutex_t *)sCFCalendarMutex);
  CFRelease(v5);
  v6 = *v4;
  if ((v6 | 2) == 0x2E)
  {
    v7 = *++v4;
    v8 = v7 - 48;
    v9 = 0.0;
    if ((v7 - 48) <= 9)
    {
      v10 = 0;
      v11 = 1;
      do
      {
        v10 = 10 * v10 + v8;
        v11 *= 10;
        v12 = *++v4;
        v8 = v12 - 48;
      }
      while ((v12 - 48) < 0xA);
      v9 = (double)v10 / (double)v11;
    }
    *a2 = v9 + *a2;
    v6 = *v4;
  }
  if (v6 == 45 || v6 == 43)
  {
    memset(&v20, 0, sizeof(v20));
    v14 = *v4;
    v13 = v4 + 1;
    if (v14 == 45)
      v15 = 1.0;
    else
      v15 = -1.0;
    v16 = strptime(v13, "%H%M", &v20);
    if (v16 || (v16 = strptime(v13, "%H:%M", &v20)) != 0 || (v16 = strptime(v13, "%H", &v20)) != 0)
      *a2 = *a2 + v15 * (double)(3600 * v20.tm_hour + 60 * v20.tm_min);
    v4 = v16;
  }
LABEL_20:
  if (v4)
    return 0;
  else
    return 4294954302;
}

uint64_t FigCFURLIsLocalResource(const __CFURL *a1)
{
  const __CFString *v2;
  const __CFString *v3;
  uint64_t IsPersistentURL;

  if (!a1)
    return 0;
  v2 = CFURLCopyScheme(a1);
  if (v2)
  {
    v3 = v2;
    IsPersistentURL = 1;
    if (CFStringCompare(CFSTR("file"), v2, 1uLL))
      IsPersistentURL = FigIsPersistentURL(a1);
    CFRelease(v3);
    return IsPersistentURL;
  }
  return FigIsPersistentURL(a1);
}

const __CFURL *FigCFURLCreateCacheKey(const __CFURL *result, char a2)
{
  const __CFURL *v3;
  const __CFString *v4;
  const __CFString *v5;
  CFIndex location;
  uint64_t v7;
  CFRange v8;

  if (!result)
    return result;
  v3 = result;
  v4 = CFURLGetString(result);
  if (!v4)
  {
LABEL_11:
    v7 = 4294954305;
    goto LABEL_12;
  }
  if ((a2 & 1) != 0)
  {
    result = (const __CFURL *)CFURLCopyPath(v3);
    if (result)
      return result;
    goto LABEL_11;
  }
  v5 = v4;
  if ((a2 & 2) == 0)
    return (const __CFURL *)CFRetain(v5);
  location = CFStringFind(v4, CFSTR("?"), 0).location;
  if (location == -1)
    return (const __CFURL *)CFRetain(v5);
  v8.length = location;
  v8.location = 0;
  result = (const __CFURL *)CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5, v8);
  if (!result)
  {
    v7 = 4294967188;
LABEL_12:
    FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

const __CFURL *FigCFStringCreateCacheKeyFromURLString(CFStringRef URLString, char a2)
{
  const __CFURL *v3;
  const __CFURL *v4;
  const __CFURL *v5;
  uint64_t v7;

  if (URLString)
  {
    v3 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], URLString, 0);
    if (v3)
    {
      v4 = v3;
      v5 = FigCFURLCreateCacheKey(v3, a2);
      CFRelease(v4);
      return v5;
    }
    v7 = 4294954305;
  }
  else
  {
    v7 = 4294954306;
  }
  FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigCFStringInsertIndent(__CFString *a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  CFMutableStringRef Mutable;
  __CFString *v10;
  const __CFString *v11;
  CFRange v13;

  v8 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v8, 0);
  v10 = CFStringCreateMutable(v8, 0);
  if (a4 >= 1)
  {
    do
    {
      CFStringAppend(Mutable, a2);
      CFStringAppend(v10, a3);
      --a4;
    }
    while (a4);
  }
  v11 = CFStringCreateWithFormat(v8, 0, CFSTR("\n%@"), v10);
  if (v11)
  {
    CFStringInsert(a1, 0, Mutable);
    v13.length = CFStringGetLength(a1);
    v13.location = 0;
    CFStringFindAndReplace(a1, CFSTR("\n"), v11, v13, 0);
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v10)
    CFRelease(v10);
  if (v11)
    CFRelease(v11);
  return 0;
}

__CFString *FigCFStringCopyWithIndent(const __CFString *a1, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  const __CFAllocator *v8;
  __CFString *result;
  const __CFString *v10;
  CFStringRef Copy;

  v8 = CFGetAllocator(a1);
  result = CFStringCreateMutableCopy(v8, 0, a1);
  if (result)
  {
    v10 = result;
    FigCFStringInsertIndent(result, a2, a3, a4);
    Copy = CFStringCreateCopy(v8, v10);
    CFRelease(v10);
    return (__CFString *)Copy;
  }
  return result;
}

BOOL FigCFURLDoesDirectoryExist(const __CFURL *a1)
{
  uint64_t v3;
  stat v4;
  UInt8 buffer[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v3 = 4294954306;
LABEL_11:
    FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    v3 = 4294967246;
    goto LABEL_11;
  }
  memset(&v4, 0, sizeof(v4));
  return stat((const char *)buffer, &v4) != -1 && (v4.st_mode & 0xF000) == 0x4000;
}

uint64_t FigCFURLCreateDirectory(const __CFURL *a1)
{
  uint64_t result;
  uint64_t v3;
  UInt8 buffer[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (FigCFURLDoesDirectoryExist(a1))
    return 0;
  if (a1)
  {
    if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    {
      result = mkdir((const char *)buffer, 0x1C0u);
      if (!(_DWORD)result)
        return result;
      v3 = 4294954301;
    }
    else
    {
      v3 = 4294967246;
    }
  }
  else
  {
    v3 = 4294954306;
  }
  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFURLCreateRelativeURLWithURLAndBaseURL(const void *a1, const void *a2, const void *a3, CFURLRef *a4)
{
  CFTypeID TypeID;
  CFTypeID v9;
  CFTypeID v10;
  const __CFURL *v11;
  const __CFURL *v12;
  CFStringRef v13;
  const __CFURL *v14;
  const __CFURL *v15;
  CFStringRef v16;
  const __CFURL *PathComponent;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  CFIndex Length;
  CFURLRef v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  CFRange v30;

  if (a1 && (TypeID = CFAllocatorGetTypeID(), TypeID != CFGetTypeID(a1))
    || !a2
    || (v9 = CFURLGetTypeID(), v9 != CFGetTypeID(a2))
    || !CFURLCanBeDecomposed((CFURLRef)a2)
    || !a3
    || (v10 = CFURLGetTypeID(), v10 != CFGetTypeID(a3))
    || !CFURLCanBeDecomposed((CFURLRef)a3)
    || !a4)
  {
    v26 = 4294954306;
    return FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
  }
  v11 = CFURLCopyAbsoluteURL((CFURLRef)a2);
  if (!v11)
  {
    v26 = 4294954305;
    return FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
  }
  v12 = v11;
  v13 = CFURLCopyScheme(v11);
  if (!v13 || (CFRelease(v13), (v14 = CFURLCopyAbsoluteURL((CFURLRef)a3)) == 0))
  {
    v27 = FigSignalErrorAt(4294954300, 0, 0, 0, 0, 0, 0);
    CFRelease(v12);
    return v27;
  }
  v15 = v14;
  v16 = CFURLCopyScheme(v14);
  if (!v16)
  {
    v29 = 4294954300;
LABEL_41:
    v23 = FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
    v18 = 0;
    goto LABEL_27;
  }
  CFRelease(v16);
  if (CFURLHasDirectoryPath(v15))
  {
    PathComponent = (const __CFURL *)CFRetain(v15);
    goto LABEL_17;
  }
  PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)a1, v15);
  if (!PathComponent)
  {
    v29 = 4294954305;
    goto LABEL_41;
  }
LABEL_17:
  v18 = CFURLGetString(v12);
  if (!v18)
  {
    v28 = 4294954306;
LABEL_37:
    v23 = FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
    if (!PathComponent)
      goto LABEL_27;
    goto LABEL_26;
  }
  v19 = CFURLGetString(PathComponent);
  if (v19)
  {
    v20 = v19;
    if (CFStringHasPrefix(v18, v19))
    {
      Length = CFStringGetLength(v20);
      v30.length = CFStringGetLength(v18) - Length;
      v30.location = Length;
      v18 = CFStringCreateWithSubstring((CFAllocatorRef)a1, v18, v30);
      if (v18)
      {
        v22 = CFURLCreateWithString((CFAllocatorRef)a1, v18, PathComponent);
        if (v22)
        {
          v23 = 0;
          *a4 = v22;
          if (!PathComponent)
            goto LABEL_27;
          goto LABEL_26;
        }
      }
      v28 = 4294954305;
      goto LABEL_37;
    }
    v24 = 4294954300;
  }
  else
  {
    v24 = 4294954306;
  }
  v23 = FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
  v18 = 0;
  if (PathComponent)
LABEL_26:
    CFRelease(PathComponent);
LABEL_27:
  CFRelease(v15);
  CFRelease(v12);
  if (v18)
    CFRelease(v18);
  return v23;
}

uint64_t FigCFURLCreateWithSuffixedExtension(const __CFAllocator *a1, CFURLRef url, const __CFString *a3, _QWORD *a4)
{
  CFStringRef v8;
  CFStringRef v9;
  void *v10;
  void *v11;
  uint64_t v12;

  v8 = CFURLCopyPathExtension(url);
  v9 = v8;
  if (v8 == a3 || a3 && v8 && CFEqual(a3, v8))
    v10 = (void *)CFRetain(url);
  else
    v10 = CFURLCreateCopyAppendingPathExtension(a1, url, a3);
  v11 = v10;
  if (v10 || (v12 = FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0), !(_DWORD)v12))
  {
    v12 = 0;
    *a4 = v11;
  }
  if (v9)
    CFRelease(v9);
  return v12;
}

uint64_t FigCFURLCopyCanonicalPath(const __CFURL *a1, _QWORD *a2)
{
  uint64_t v4;
  CFTypeRef propertyValueTypeRefPtr;

  propertyValueTypeRefPtr = 0;
  if (!a1 || !_CFURLIsFileURL() || !a2)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  CFURLCopyResourcePropertyForKey(a1, (CFStringRef)*MEMORY[0x1E0C9B3F0], &propertyValueTypeRefPtr, 0);
  if (propertyValueTypeRefPtr)
  {
    v4 = 0;
    *a2 = propertyValueTypeRefPtr;
  }
  else
  {
    v4 = FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    if (propertyValueTypeRefPtr)
      CFRelease(propertyValueTypeRefPtr);
  }
  return v4;
}

uint64_t FigCFURLGetFileStats(const __CFURL *a1, off_t *a2, _QWORD *a3, timespec *a4, BOOL *a5)
{
  uint64_t result;
  stat v10;
  UInt8 buffer[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  memset(&v10, 0, sizeof(v10));
  if (!a1 || !a2 && !a3 && !a4 && !a5)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  if (stat((const char *)buffer, &v10) == -1)
    return *__error();
  if (a2)
    *a2 = v10.st_size;
  if (a3)
    *a3 = v10.st_blocks << 9;
  if (a4)
    *a4 = v10.st_mtimespec;
  result = 0;
  if (a5)
    *a5 = (v10.st_mode & 0x4000) != 0;
  return result;
}

uint64_t FigCFURLIdentifiesSameFileResourceAsCFURL(const __CFURL *a1, const __CFURL *a2)
{
  uint64_t result;
  stat v6;
  stat v7;
  UInt8 v8[1024];
  UInt8 buffer[1024];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  bzero(v8, 0x400uLL);
  if (a1 == a2)
    return 1;
  result = 0;
  if (a1)
  {
    if (a2)
    {
      memset(&v7, 0, sizeof(v7));
      memset(&v6, 0, sizeof(v6));
      result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024);
      if ((_DWORD)result)
      {
        result = CFURLGetFileSystemRepresentation(a2, 1u, v8, 1024);
        if ((_DWORD)result)
          return stat((const char *)buffer, &v7) != -1
              && stat((const char *)v8, &v6) != -1
              && v7.st_ino == v6.st_ino
              && v7.st_dev == v6.st_dev
              && v7.st_size == v6.st_size
              && v7.st_mtimespec.tv_sec == v6.st_mtimespec.tv_sec
              && v7.st_mtimespec.tv_nsec == v6.st_mtimespec.tv_nsec;
      }
    }
  }
  return result;
}

char *FigCFStringGetCStringPtrAndBufferToFree(CFStringRef theString, CFStringEncoding encoding, char **a3)
{
  const char *CStringPtr;
  char *v7;
  CFIndex Length;
  size_t MaximumSizeForEncoding;
  CFIndex v10;

  if (a3)
    *a3 = 0;
  if (!theString)
    return 0;
  CStringPtr = CFStringGetCStringPtr(theString, encoding);
  v7 = (char *)CStringPtr;
  if (a3 && !CStringPtr)
  {
    Length = CFStringGetLength(theString);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, encoding);
    if (MaximumSizeForEncoding == -1)
      return 0;
    v10 = MaximumSizeForEncoding;
    v7 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0xCA5B27BDuLL);
    if (v7)
    {
      if (CFStringGetCString(theString, v7, v10, encoding))
      {
        *a3 = v7;
        return v7;
      }
      free(v7);
      return 0;
    }
  }
  return v7;
}

const char *FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer(const char *result, char *a2, CFIndex a3, CFStringEncoding encoding)
{
  const __CFString *v7;

  if (result)
  {
    v7 = (const __CFString *)result;
    result = CFStringGetCStringPtr((CFStringRef)result, encoding);
    if (!result && a2 && a3)
    {
      if (CFStringGetCString(v7, a2, a3, encoding))
        return a2;
      else
        return 0;
    }
  }
  return result;
}

uint64_t FigCFStringGetOSTypeValue(CFStringRef theString, int *a2)
{
  uint64_t result;
  char buffer[4];
  char v6;

  result = 0;
  v6 = 0;
  *(_DWORD *)buffer = 0;
  if (theString && a2)
  {
    if (CFStringGetLength(theString) == 4)
    {
      result = CFStringGetCString(theString, buffer, 5, 0);
      if ((_DWORD)result)
      {
        *a2 = (buffer[1] << 16) | (buffer[0] << 24) | (buffer[2] << 8) | buffer[3];
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFString *FigGetCFStringForOSTypeValue(unsigned int a1)
{
  const void *Value;
  UInt8 bytes[4];

  *(_DWORD *)bytes = a1;
  if (a1 == 1936684398)
    return CFSTR("soun");
  if (a1 == 1986618469)
    return CFSTR("vide");
  FigThreadRunOnce(&sLoadFourCharCodeStringOnce, (void (*)(void))figCreateFourCharCodeStuffOnce);
  FigSimpleMutexLock((pthread_mutex_t *)sFourCharCodeStringMutex);
  Value = CFDictionaryGetValue((CFDictionaryRef)sCFStringsForFourCharCodes, (const void *)a1);
  if (!Value)
  {
    *(_DWORD *)bytes = bswap32(a1);
    Value = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 4, 0x600u, 0);
    if (Value)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)sCFStringsForFourCharCodes, (const void *)a1, Value);
      CFRelease(Value);
    }
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)sFourCharCodeStringMutex);
  return (const __CFString *)Value;
}

pthread_mutex_t *figCreateFourCharCodeStuffOnce()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  pthread_mutex_t *result;

  sCFStringsForFourCharCodes = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  sFourCharCodeStringMutex = (uint64_t)result;
  return result;
}

const void *FigGetCFStringFor3CCValue(unsigned int a1)
{
  const void *Value;
  unsigned int v4;

  v4 = a1;
  FigThreadRunOnce(&sLoadThreeCharCodeStringOnce, (void (*)(void))figCreateThreeCharCodeStuffOnce);
  FigSimpleMutexLock((pthread_mutex_t *)sThreeCharCodeStringMutex);
  Value = CFDictionaryGetValue((CFDictionaryRef)sCFStringsForThreeCharCodes, (const void *)a1);
  if (!Value)
  {
    v4 = bswap32(a1);
    Value = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)&v4 + 1, 3, 0x600u, 0);
    if (Value)
    {
      CFDictionaryAddValue((CFMutableDictionaryRef)sCFStringsForThreeCharCodes, (const void *)a1, Value);
      CFRelease(Value);
    }
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)sThreeCharCodeStringMutex);
  return Value;
}

pthread_mutex_t *figCreateThreeCharCodeStuffOnce()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  pthread_mutex_t *result;

  sCFStringsForThreeCharCodes = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  sThreeCharCodeStringMutex = (uint64_t)result;
  return result;
}

CFPropertyListRef FigCFPropertyListCreateFromFigFileFork(const __CFAllocator *a1, int *a2, CFOptionFlags a3, CFPropertyListFormat *a4, CFErrorRef *a5)
{
  UInt8 *v10;
  CFPropertyListRef v11;
  const __CFData *v12;
  const __CFData *v13;
  size_t size;

  size = 0;
  if (!a2)
  {
    v10 = 0;
    goto LABEL_11;
  }
  v10 = 0;
  if (FigFileForkGetLengthAtOffset(a2, 0, &size))
  {
    v11 = 0;
    goto LABEL_8;
  }
  v11 = 0;
  if ((uint64_t)size >= 1)
  {
    v10 = (UInt8 *)malloc_type_malloc(size, 0xADA22D5uLL);
    if (!FigFileForkRead(a2, v10, size, 0, 0))
    {
      v12 = CFDataCreate(a1, v10, size);
      if (v12)
      {
        v13 = v12;
        v11 = CFPropertyListCreateWithData(a1, v12, a3, a4, a5);
        CFRelease(v13);
        goto LABEL_8;
      }
      FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    }
LABEL_11:
    v11 = 0;
  }
LABEL_8:
  free(v10);
  return v11;
}

CFDataRef FigCFPropertyListWriteToFigFileFork(CFPropertyListRef propertyList, int *a2, CFPropertyListFormat a3, CFOptionFlags a4, CFErrorRef *a5)
{
  CFDataRef result;
  const __CFData *v7;
  CFIndex Length;
  size_t v9;
  UInt8 *BytePtr;
  uint64_t v11;

  v11 = 0;
  result = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], propertyList, a3, a4, a5);
  if (result)
  {
    v7 = result;
    if (!FigFileForkTruncate(a2, 0))
    {
      Length = CFDataGetLength(v7);
      if (Length >= 1)
      {
        v9 = Length;
        BytePtr = (UInt8 *)CFDataGetBytePtr(v7);
        if (BytePtr)
          FigFileForkWrite(a2, BytePtr, v9, 0, &v11);
      }
    }
    CFRelease(v7);
    return (CFDataRef)v11;
  }
  return result;
}

uint64_t FigGetNumberFromCFTypeWithDefault(const __CFString *a1, uint64_t a2)
{
  CFTypeID v4;
  uint64_t IntValue;
  CFTypeID v6;
  CFTypeID v7;
  unsigned int valuePtr;

  if (!a1)
    return a2;
  v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    IntValue = CFStringGetIntValue(a1);
    if (!(_DWORD)IntValue)
    {
      IntValue = 1;
      if (CFStringCompare(a1, CFSTR("true"), 1uLL))
      {
        IntValue = 1;
        if (CFStringCompare(a1, CFSTR("yes"), 1uLL))
        {
          if (CFStringCompare(a1, CFSTR("false"), 1uLL) == kCFCompareEqualTo)
            return 0;
          if (CFStringCompare(a1, CFSTR("no"), 1uLL) == kCFCompareEqualTo)
            return 0;
          IntValue = a2;
          if (CFStringCompare(a1, CFSTR("0"), 1uLL) == kCFCompareEqualTo)
            return 0;
        }
      }
    }
  }
  else
  {
    v6 = CFGetTypeID(a1);
    if (v6 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr))
        return valuePtr;
      else
        return a2;
    }
    else
    {
      v7 = CFGetTypeID(a1);
      IntValue = a2;
      if (v7 == CFBooleanGetTypeID())
        return CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    }
  }
  return IntValue;
}

unint64_t FigGetLongNumberFromCFTypeWithDefault(const __CFString *a1, uint64_t a2)
{
  CFTypeID v3;
  const __CFAllocator *v4;
  const __CFLocale *v5;
  __CFNumberFormatter *v6;
  CFTypeID v7;
  CFTypeID v9;
  uint64_t valuePtr;

  valuePtr = a2;
  if (!a1)
    return valuePtr;
  v3 = CFGetTypeID(a1);
  if (v3 != CFStringGetTypeID())
  {
    v7 = CFGetTypeID(a1);
    if (v7 == CFNumberGetTypeID())
      return (unint64_t)FigCFNumberGetSInt64((const __CFNumber *)a1);
    v9 = CFGetTypeID(a1);
    if (v9 != CFBooleanGetTypeID())
      return valuePtr;
    return CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
  }
  if (CFStringCompare(a1, CFSTR("true"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, CFSTR("yes"), 1uLL) == kCFCompareEqualTo)
  {
    return 1;
  }
  if (CFStringCompare(a1, CFSTR("false"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, CFSTR("no"), 1uLL) == kCFCompareEqualTo)
  {
    return 0;
  }
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("en_US_POSIX"));
  v6 = CFNumberFormatterCreate(v4, v5, kCFNumberFormatterNoStyle);
  CFNumberFormatterGetValueFromString(v6, a1, 0, kCFNumberLongLongType, &valuePtr);
  if (v5)
    CFRelease(v5);
  if (v6)
    CFRelease(v6);
  return valuePtr;
}

const __CFNumber *FigCFNumberGetSInt64(const __CFNumber *result)
{
  const __CFNumber *v1;
  CFTypeID v2;
  uint64_t valuePtr;

  valuePtr = 0;
  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v1, kCFNumberSInt64Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t FigGetCFPreferenceNumberWithDefault(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  const __CFString *v4;
  uint64_t NumberFromCFTypeWithDefault;

  v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  NumberFromCFTypeWithDefault = FigGetNumberFromCFTypeWithDefault(v4, a3);
  if (v4)
    CFRelease(v4);
  return NumberFromCFTypeWithDefault;
}

unint64_t FigGetCFPreferenceLongNumberWithDefault(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  const __CFString *v4;
  unint64_t LongNumberFromCFTypeWithDefault;

  v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  LongNumberFromCFTypeWithDefault = FigGetLongNumberFromCFTypeWithDefault(v4, a3);
  if (v4)
    CFRelease(v4);
  return LongNumberFromCFTypeWithDefault;
}

double FigGetCFPreferenceDoubleWithDefault(const __CFString *a1, const __CFString *a2)
{
  const __CFString *v2;
  double v3;
  double v4;

  v2 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  FigGetDoubleFromCFTypeWithDefault(v2);
  v4 = v3;
  if (v2)
    CFRelease(v2);
  return v4;
}

uint64_t FigGetBooleanFromCFTypeWithDefault(const __CFString *a1, uint64_t a2)
{
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  int valuePtr;

  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFBooleanGetTypeID())
    {
      return *MEMORY[0x1E0C9AE50] == (_QWORD)a1;
    }
    else
    {
      v5 = CFGetTypeID(a1);
      if (v5 == CFNumberGetTypeID())
      {
        valuePtr = 0;
        CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr);
        return valuePtr != 0;
      }
      else
      {
        v6 = CFGetTypeID(a1);
        if (v6 == CFStringGetTypeID())
        {
          if (CFStringCompare(a1, CFSTR("true"), 1uLL)
            && CFStringCompare(a1, CFSTR("yes"), 1uLL)
            && CFStringCompare(a1, CFSTR("1"), 1uLL))
          {
            if (CFStringCompare(a1, CFSTR("false"), 1uLL) == kCFCompareEqualTo
              || CFStringCompare(a1, CFSTR("no"), 1uLL) == kCFCompareEqualTo
              || CFStringCompare(a1, CFSTR("0"), 1uLL) == kCFCompareEqualTo)
            {
              return 0;
            }
          }
          else
          {
            return 1;
          }
        }
      }
    }
  }
  return a2;
}

uint64_t FigGetCFPreferenceBooleanWithDefault(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  const __CFString *v4;
  uint64_t BooleanFromCFTypeWithDefault;

  v4 = (const __CFString *)CFPreferencesCopyAppValue(a1, a2);
  BooleanFromCFTypeWithDefault = FigGetBooleanFromCFTypeWithDefault(v4, a3);
  if (v4)
    CFRelease(v4);
  return BooleanFromCFTypeWithDefault;
}

uint64_t FigReplaceURLWithString(__CFDictionary *a1, const void *a2, const void *a3, CFURLRef relativeURL)
{
  const __CFURL *v7;
  const __CFURL *v8;
  CFStringRef v9;

  v7 = CFURLCopyAbsoluteURL(relativeURL);
  if (!v7)
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  v8 = v7;
  v9 = CFURLGetString(v7);
  CFDictionaryRemoveValue(a1, a2);
  CFDictionarySetValue(a1, a3, v9);
  CFRelease(v8);
  return 0;
}

uint64_t FigReplaceStringWithURL(__CFDictionary *a1, const void *a2, const void *a3, CFStringRef URLString)
{
  CFURLRef v7;
  CFURLRef v8;

  v7 = CFURLCreateWithString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], URLString, 0);
  if (!v7)
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  v8 = v7;
  CFDictionaryRemoveValue(a1, a2);
  CFDictionarySetValue(a1, a3, v8);
  CFRelease(v8);
  return 0;
}

CFURLRef FigCFURLCreateFromSystemTemporaryDirectory(const __CFAllocator *a1)
{
  CFIndex v2;
  CFURLRef result;
  UInt8 buffer[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  v2 = confstr(65537, (char *)buffer, 0x400uLL) - 1;
  if (v2 < 1 || (result = CFURLCreateFromFileSystemRepresentation(a1, buffer, v2, 1u)) == 0)
  {
    FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

CFURLRef FigCFURLCreateFromTemporaryFileWithDirectoryAndSuffix(const __CFAllocator *a1, const __CFURL *a2, const char *a3, const char *a4)
{
  int v8;
  int64_t v9;
  char __str[1024];
  UInt8 buffer[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  bzero(__str, 0x400uLL);
  if (a2)
  {
    if (!FigCFURLDoesDirectoryExist(a2) || !CFURLGetFileSystemRepresentation(a2, 1u, buffer, 1024))
      goto LABEL_11;
  }
  else if ((uint64_t)(confstr(65537, (char *)buffer, 0x400uLL) - 1) <= 0)
  {
    goto LABEL_11;
  }
  if (a4)
  {
    snprintf(__str, 0x400uLL, "%s/%sXXXXXX%s", (const char *)buffer, a3, a4);
    v8 = strlen(a4);
    mkstemps(__str, v8);
  }
  else
  {
    snprintf(__str, 0x400uLL, "%s/%sXXXXXX", (const char *)buffer, a3);
    mkstemp(__str);
  }
  v9 = strlen(__str);
  if (v9 > 0)
    return CFURLCreateFromFileSystemRepresentation(a1, (const UInt8 *)__str, v9, 0);
LABEL_11:
  FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  return 0;
}

CFURLRef FigCFURLCreateFromTemporaryFileWithDirectory(const __CFAllocator *a1, const __CFURL *a2, const char *a3)
{
  return FigCFURLCreateFromTemporaryFileWithDirectoryAndSuffix(a1, a2, a3, 0);
}

uint64_t FigCFAttributedStringSetDouble(__CFAttributedString *a1, CFIndex a2, CFIndex a3, const __CFString *a4, double a5)
{
  CFNumberRef v9;
  CFNumberRef v10;
  double valuePtr;
  CFRange v13;

  valuePtr = a5;
  if (!a1 || !a4)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
  if (!v9)
    return FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  v10 = v9;
  v13.location = a2;
  v13.length = a3;
  CFAttributedStringSetAttribute(a1, v13, a4, v9);
  CFRelease(v10);
  return 0;
}

BOOL FigCFRangeEqual(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 == a3 && a2 == a4;
}

uint64_t FigCFRangeGetLimit(uint64_t a1, uint64_t a2)
{
  return a1 + a2;
}

uint64_t FigCFIntersectionRange(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  if (a3 > result || result >= a3 + a4)
  {
    if (a3 < result + a2)
      v4 = a3;
    else
      v4 = 0;
    if (result <= a3)
      return v4;
    else
      return 0;
  }
  return result;
}

BOOL FigCFIntersectsRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a1 < a3 + a4 && a3 < a1 + a2;
}

CFTypeRef FigCopyCFPreferenceAppValueOrOptionCFTypeWithDefault(const __CFDictionary *a1, CFStringRef key, CFStringRef applicationID, const void *a4)
{
  CFTypeRef result;
  const void *Value;

  result = CFPreferencesCopyAppValue(key, applicationID);
  if (!a1 || result)
  {
LABEL_5:
    if (result)
      return result;
    goto LABEL_6;
  }
  Value = CFDictionaryGetValue(a1, key);
  if (Value)
  {
    result = CFRetain(Value);
    goto LABEL_5;
  }
LABEL_6:
  if (a4)
    return CFRetain(a4);
  else
    return 0;
}

uint64_t FigGetCFPreferenceOrOptionNumberWithDefault(const __CFDictionary *a1, const __CFString *key, const __CFString *a3, uint64_t a4)
{
  uint64_t v4;
  const __CFNumber *Value;
  unsigned int valuePtr;

  v4 = a4;
  valuePtr = a4;
  if (a1)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a1, key);
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      v4 = valuePtr;
    }
  }
  return FigGetCFPreferenceNumberWithDefault(key, a3, v4);
}

void FigGetCFPreferenceOrOptionDoubleWithDefault(const __CFDictionary *a1, const __CFString *key, const __CFString *a3, double a4)
{
  const __CFNumber *Value;
  double valuePtr;

  valuePtr = a4;
  if (a1)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a1, key);
    if (Value)
      CFNumberGetValue(Value, kCFNumberDoubleType, &valuePtr);
  }
  FigGetCFPreferenceDoubleWithDefault(key, a3);
}

uint64_t FigGetGlobalCFAllocatorFigMalloc()
{
  if (FigGetGlobalCFAllocatorFigMalloc_sOnceToken != -1)
    dispatch_once_f(&FigGetGlobalCFAllocatorFigMalloc_sOnceToken, &FigGetGlobalCFAllocatorFigMalloc_sFigCFAllocatorFigMalloc, (dispatch_function_t)figCreateFigCFAllocatorFigMallocOnceFunc);
  return FigGetGlobalCFAllocatorFigMalloc_sFigCFAllocatorFigMalloc;
}

CFAllocatorRef figCreateFigCFAllocatorFigMallocOnceFunc(CFAllocatorRef *a1)
{
  CFAllocatorRef result;

  result = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &sFigCFAllocatorFigMallocContext);
  *a1 = result;
  return result;
}

uint64_t FigCreateCFAllocatorFigMallocWithDeallocCallback(void (__cdecl *a1)(void *, void *), CFTypeRef *a2)
{
  CFAllocatorRef v4;
  CFAllocatorRef v5;
  CFAllocatorContext v7;

  memset(&v7, 0, sizeof(v7));
  if (FigGetGlobalCFAllocatorFigMalloc_sOnceToken != -1)
    dispatch_once_f(&FigGetGlobalCFAllocatorFigMalloc_sOnceToken, &FigGetGlobalCFAllocatorFigMalloc_sFigCFAllocatorFigMalloc, (dispatch_function_t)figCreateFigCFAllocatorFigMallocOnceFunc);
  CFAllocatorGetContext((CFAllocatorRef)FigGetGlobalCFAllocatorFigMalloc_sFigCFAllocatorFigMalloc, &v7);
  v7.deallocate = a1;
  v4 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &v7);
  if (!v4)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  v5 = v4;
  *a2 = CFRetain(v4);
  CFRelease(v5);
  return 0;
}

dispatch_object_t figDispatchCFCollectionRetainCallBack(int a1, dispatch_object_t object)
{
  dispatch_retain(object);
  return object;
}

void figDispatchCFCollectionReleaseCallBack(int a1, dispatch_object_t object)
{
  dispatch_release(object);
}

CFStringRef figDispatchQueueCFCollectionCopyDescriptionCallBack(NSObject *a1)
{
  const char *label;
  size_t v2;

  label = dispatch_queue_get_label(a1);
  v2 = strlen(label);
  return CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)label, v2, 0x8000100u, 0);
}

void *figBlockCFCollectionRetainCallBack(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

void figBlockCFCollectionReleaseCallBack(int a1, void *aBlock)
{
  _Block_release(aBlock);
}

CFNumberRef FigCFNumberCreateUInt8(const __CFAllocator *a1, __int16 a2)
{
  __int16 *p_valuePtr;
  CFNumberType v3;
  __int16 valuePtr;
  char v6;

  v6 = a2;
  if ((a2 & 0x80) != 0)
  {
    valuePtr = a2;
    p_valuePtr = &valuePtr;
    v3 = kCFNumberSInt16Type;
  }
  else
  {
    p_valuePtr = (__int16 *)&v6;
    v3 = kCFNumberSInt8Type;
  }
  return CFNumberCreate(a1, v3, p_valuePtr);
}

CFNumberRef FigCFNumberCreateUInt16(const __CFAllocator *a1, int a2)
{
  __int16 *p_valuePtr;
  CFNumberType v3;
  int valuePtr;
  __int16 v6;

  v6 = a2;
  if ((a2 & 0x8000) != 0)
  {
    valuePtr = a2;
    p_valuePtr = (__int16 *)&valuePtr;
    v3 = kCFNumberSInt32Type;
  }
  else
  {
    p_valuePtr = &v6;
    v3 = kCFNumberSInt16Type;
  }
  return CFNumberCreate(a1, v3, p_valuePtr);
}

CFNumberRef FigCFNumberCreateUInt32(const __CFAllocator *a1, unsigned int a2)
{
  uint64_t *v2;
  CFNumberType v3;
  uint64_t v5;
  unsigned int v6;

  v6 = a2;
  if ((a2 & 0x80000000) != 0)
  {
    v5 = a2;
    v2 = &v5;
    v3 = kCFNumberSInt64Type;
  }
  else
  {
    v2 = (uint64_t *)&v6;
    v3 = kCFNumberSInt32Type;
  }
  return CFNumberCreate(a1, v3, v2);
}

uint64_t FigCFNumberGetUInt8(const __CFNumber *a1)
{
  CFTypeID v2;
  __int16 valuePtr;

  valuePtr = 0;
  if (a1 && (v2 = CFGetTypeID(a1), v2 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(a1, kCFNumberSInt16Type, &valuePtr);
    return valuePtr;
  }
  else
  {
    return 0;
  }
}

uint64_t FigCFNumberGetUInt16(const __CFNumber *a1)
{
  CFTypeID v2;
  int valuePtr;

  valuePtr = 0;
  if (a1 && (v2 = CFGetTypeID(a1), v2 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
    return (unsigned __int16)valuePtr;
  }
  else
  {
    return 0;
  }
}

const __CFNumber *FigCFNumberGetUInt32(const __CFNumber *result)
{
  const __CFNumber *v1;
  CFTypeID v2;
  uint64_t valuePtr;

  valuePtr = 0;
  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v1, kCFNumberSInt64Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFNumber *FigCFNumberGetUInt64(const __CFNumber *result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = 0;
  v2 = 0;
  if (result)
  {
    CFNumberGetValue(result, kCFNumberMaxType|kCFNumberSInt8Type, &v1);
    return (const __CFNumber *)v2;
  }
  return result;
}

CFNumberRef FigCFNumberCreateSInt8(const __CFAllocator *a1, char a2)
{
  char valuePtr;

  valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberSInt8Type, &valuePtr);
}

uint64_t FigCFNumberGetSInt8(const __CFNumber *a1)
{
  CFTypeID v2;
  char valuePtr;

  valuePtr = 0;
  if (a1 && (v2 = CFGetTypeID(a1), v2 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(a1, kCFNumberSInt8Type, &valuePtr);
    return valuePtr;
  }
  else
  {
    return 0;
  }
}

uint64_t FigCFNumberGetSInt16(const __CFNumber *a1)
{
  CFTypeID v2;
  __int16 valuePtr;

  valuePtr = 0;
  if (a1 && (v2 = CFGetTypeID(a1), v2 == CFNumberGetTypeID()))
  {
    CFNumberGetValue(a1, kCFNumberSInt16Type, &valuePtr);
    return valuePtr;
  }
  else
  {
    return 0;
  }
}

const __CFNumber *FigCFNumberGetSInt32(const __CFNumber *result)
{
  const __CFNumber *v1;
  CFTypeID v2;
  unsigned int valuePtr;

  valuePtr = 0;
  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFNumberRef FigCFNumberCreateFloat32(const __CFAllocator *a1, float a2)
{
  float valuePtr;

  valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberFloat32Type, &valuePtr);
}

CFNumberRef FigCFNumberCreateFloat64(const __CFAllocator *a1, double a2)
{
  double valuePtr;

  valuePtr = a2;
  return CFNumberCreate(a1, kCFNumberFloat64Type, &valuePtr);
}

float FigCFNumberGetFloat32(const void *a1)
{
  float v1;
  CFTypeID v3;
  float valuePtr;

  valuePtr = 0.0;
  v1 = 0.0;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)a1, kCFNumberFloat32Type, &valuePtr);
      return valuePtr;
    }
  }
  return v1;
}

double FigCFNumberGetFloat64(const void *a1)
{
  double v1;
  CFTypeID v3;
  double valuePtr;

  valuePtr = 0.0;
  v1 = 0.0;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)a1, kCFNumberFloat64Type, &valuePtr);
      return valuePtr;
    }
  }
  return v1;
}

__CFDictionary *FigCFCopyCFErrorAsPropertyList(__CFError *a1)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  CFNumberRef v4;
  CFNumberRef v5;
  __CFString *Domain;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  CFStringRef v9;
  const void *v10;
  const void *v11;
  void *value;
  CFIndex valuePtr;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
    return 0;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    valuePtr = CFErrorGetCode(a1);
    v4 = CFNumberCreate(v2, kCFNumberCFIndexType, &valuePtr);
    if (v4)
    {
      v5 = v4;
      CFDictionarySetValue(Mutable, CFSTR("CFError_Code"), v4);
      CFRelease(v5);
    }
    Domain = (__CFString *)CFErrorGetDomain(a1);
    value = Domain;
    if (Domain)
      CFDictionarySetValue(Mutable, CFSTR("CFError_Domain"), Domain);
    v7 = CFErrorCopyUserInfo(a1);
    if (v7)
    {
      v8 = v7;
      if (CFDictionaryGetValueIfPresent(v7, (const void *)*MEMORY[0x1E0C9AFE0], (const void **)&value))
        CFDictionarySetValue(Mutable, CFSTR("CFError_LocalizedDescription"), value);
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E0C9AFE8], (const void **)&value))
        CFDictionarySetValue(Mutable, CFSTR("CFError_LocalizedFailureReason"), value);
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E0C9AFF0], (const void **)&value))
        CFDictionarySetValue(Mutable, CFSTR("CFError_LocalizedRecoverySuggestion"), value);
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E0C9AFB0], (const void **)&value))
        CFDictionarySetValue(Mutable, CFSTR("CFError_Description"), value);
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E0C9AFF8], (const void **)&value))
      {
        v9 = CFURLGetString((CFURLRef)value);
        CFDictionarySetValue(Mutable, CFSTR("CFError_URL"), v9);
      }
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E0C9AFD8], (const void **)&value))
        CFDictionarySetValue(Mutable, CFSTR("CFError_FilePath"), value);
      if (CFDictionaryGetValueIfPresent(v8, (const void *)*MEMORY[0x1E0C9B000], (const void **)&value))
      {
        v10 = (const void *)FigCFCopyCFErrorAsPropertyList(value);
        if (v10)
        {
          v11 = v10;
          CFDictionarySetValue(Mutable, CFSTR("CFError_UnderlyingError"), v10);
          CFRelease(v11);
        }
      }
      if (!FigCreateSerializedDictionaryFromNSErrorUserInfo(v8, (__CFDictionary **)&cf))
        FigCFDictionaryAddEntriesToDictionaryWithRecursion(cf, Mutable, 1);
      if (cf)
        CFRelease(cf);
      CFRelease(v8);
    }
  }
  return Mutable;
}

const __CFDictionary *FigCFErrorCreateFromPropertyList(const __CFDictionary *a1)
{
  const __CFDictionary *v1;
  const __CFAllocator *v2;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v4;
  CFURLRef v5;
  CFURLRef v6;
  const void *v7;
  const void *v8;
  CFDictionaryRef theDict;
  CFTypeRef cf;
  void *value;
  CFIndex valuePtr;

  v1 = a1;
  value = 0;
  valuePtr = 0;
  theDict = 0;
  cf = 0;
  if (a1)
  {
    if (CFDictionaryGetValueIfPresent(a1, CFSTR("CFError_Code"), (const void **)&theDict)
      && (CFNumberGetValue(theDict, kCFNumberCFIndexType, &valuePtr),
          CFDictionaryGetValueIfPresent(v1, CFSTR("CFError_Domain"), (const void **)&value))
      && (v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00],
          (Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) != 0))
    {
      v4 = Mutable;
      if (CFDictionaryGetValueIfPresent(v1, CFSTR("CFError_LocalizedDescription"), (const void **)&theDict))
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0C9AFE0], theDict);
      if (CFDictionaryGetValueIfPresent(v1, CFSTR("CFError_LocalizedFailureReason"), (const void **)&theDict))
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0C9AFE8], theDict);
      if (CFDictionaryGetValueIfPresent(v1, CFSTR("CFError_LocalizedRecoverySuggestion"), (const void **)&theDict))
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0C9AFF0], theDict);
      if (CFDictionaryGetValueIfPresent(v1, CFSTR("CFError_Description"), (const void **)&theDict))
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0C9AFB0], theDict);
      if (CFDictionaryGetValueIfPresent(v1, CFSTR("CFError_URL"), (const void **)&theDict))
      {
        v5 = CFURLCreateWithString(v2, (CFStringRef)theDict, 0);
        if (v5)
        {
          v6 = v5;
          CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0C9AFF8], v5);
          CFRelease(v6);
        }
      }
      if (CFDictionaryGetValueIfPresent(v1, CFSTR("CFError_FilePath"), (const void **)&theDict))
        CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0C9AFD8], theDict);
      if (CFDictionaryGetValueIfPresent(v1, CFSTR("CFError_UnderlyingError"), (const void **)&theDict))
      {
        v7 = (const void *)FigCFErrorCreateFromPropertyList(theDict);
        if (v7)
        {
          v8 = v7;
          CFDictionarySetValue(v4, (const void *)*MEMORY[0x1E0C9B000], v7);
          CFRelease(v8);
        }
      }
      if (!FigCreateNSErrorUserInfoFromSerializedDictionary(v1, (__CFDictionary **)&cf))
        FigCFDictionaryAddEntriesToDictionaryWithRecursion(cf, v4, 1);
      if (cf)
        CFRelease(cf);
      v1 = CFErrorCreate(v2, (CFErrorDomain)value, valuePtr, v4);
      CFRelease(v4);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t FigCFCopyPropertyAsTime(uint64_t a1, uint64_t a2, uint64_t a3, CMTime *a4)
{
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, CFDictionaryRef *);
  uint64_t v9;
  CFDictionaryRef v10;
  BOOL v11;
  CMTime v13;
  CFDictionaryRef dictionaryRepresentation;

  dictionaryRepresentation = 0;
  memset(&v13, 0, sizeof(v13));
  v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFDictionaryRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 8)
                                                                              + 48);
  if (v8)
  {
    v9 = v8(a1, a2, a3, &dictionaryRepresentation);
    v10 = dictionaryRepresentation;
    if ((_DWORD)v9)
      v11 = 1;
    else
      v11 = dictionaryRepresentation == 0;
    if (!v11)
    {
      CMTimeMakeFromDictionary(&v13, dictionaryRepresentation);
      v10 = dictionaryRepresentation;
    }
    if (v10)
      CFRelease(v10);
  }
  else
  {
    v9 = 4294954514;
  }
  *a4 = v13;
  return v9;
}

uint64_t FigCFSetPropertyToTime(uint64_t a1, uint64_t a2, CMTime *a3)
{
  const __CFAllocator *v5;
  CFDictionaryRef v6;
  uint64_t (*v7)(uint64_t, uint64_t, CFDictionaryRef);
  uint64_t v8;
  CMTime v10;

  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v10 = *a3;
  v6 = CMTimeCopyAsDictionary(&v10, v5);
  v7 = *(uint64_t (**)(uint64_t, uint64_t, CFDictionaryRef))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 8) + 56);
  if (!v7)
  {
    v8 = 4294954514;
    if (!v6)
      return v8;
    goto LABEL_3;
  }
  v8 = v7(a1, a2, v6);
  if (v6)
LABEL_3:
    CFRelease(v6);
  return v8;
}

uint64_t FigCFSetCopyValuesAsCFArray(const __CFSet *a1, CFArrayRef *a2)
{
  size_t Count;
  CFIndex v5;
  const void **v6;
  CFArrayRef v7;
  uint64_t v8;

  Count = CFSetGetCount(a1);
  if (!a1)
  {
    v8 = 0;
LABEL_10:
    v6 = 0;
    goto LABEL_6;
  }
  if (!a2)
  {
    v8 = FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  v5 = Count;
  v6 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  if (v6
    && (CFSetGetValues(a1, v6),
        (v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, v5, MEMORY[0x1E0C9B378])) != 0))
  {
    v8 = 0;
    *a2 = v7;
  }
  else
  {
    v8 = FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
  }
LABEL_6:
  free(v6);
  return v8;
}

uint64_t FigCFArrayCopyValuesAsCFSet(const __CFArray *a1, CFSetRef *a2)
{
  size_t Count;
  CFIndex v5;
  const void **v6;
  CFSetRef v7;
  uint64_t v8;
  CFRange v10;

  if (a1)
  {
    Count = CFArrayGetCount(a1);
    if (a2)
    {
      v5 = Count;
      v6 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
      if (v6
        && (v10.location = 0,
            v10.length = v5,
            CFArrayGetValues(a1, v10, v6),
            (v7 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, v5, MEMORY[0x1E0C9B3B0])) != 0))
      {
        v8 = 0;
        *a2 = v7;
      }
      else
      {
        v8 = FigSignalErrorAt(4294954305, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      v8 = FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
      v6 = 0;
    }
  }
  else
  {
    v6 = 0;
    v8 = 0;
  }
  free(v6);
  return v8;
}

__CFSet *FigCFSetCreateFromArray(const __CFAllocator *a1, CFArrayRef theArray)
{
  CFIndex Count;
  __CFSet *Mutable;
  BOOL v6;
  CFIndex v7;
  const void *ValueAtIndex;

  if (theArray)
    Count = CFArrayGetCount(theArray);
  else
    Count = 0;
  Mutable = CFSetCreateMutable(a1, Count, MEMORY[0x1E0C9B3B0]);
  if (Mutable)
    v6 = Count < 1;
  else
    v6 = 1;
  if (!v6)
  {
    v7 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
      CFSetAddValue(Mutable, ValueAtIndex);
      ++v7;
    }
    while (Count != v7);
  }
  return Mutable;
}

BOOL FigCFSetContainsValue(CFSetRef theSet, const void *a2)
{
  _BOOL8 result;

  result = 0;
  if (theSet)
  {
    if (a2)
      return CFSetContainsValue(theSet, a2) != 0;
  }
  return result;
}

CGColorRef FigCreateCGColorSRGB(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGColorSpace *v4;
  CGColorSpace *v5;
  CGColorRef v6;
  CGFloat components[5];

  components[4] = *(CGFloat *)MEMORY[0x1E0C80C00];
  components[0] = a1;
  components[1] = a2;
  components[2] = a3;
  components[3] = a4;
  v4 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  v5 = v4;
  if (v4)
    v6 = CGColorCreate(v4, components);
  else
    v6 = 0;
  CGColorSpaceRelease(v5);
  return v6;
}

CFMutableArrayRef FigCopyCGColorSRGBAsArray(void *a1)
{
  CFTypeID v2;
  CFMutableArrayRef Mutable;
  const CGFloat *Components;
  const CGFloat *v5;
  uint64_t v6;
  float v7;
  float v10;

  if (!a1 || (v2 = CFGetTypeID(a1), v2 != CGColorGetTypeID()))
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (CGColorGetNumberOfComponents((CGColorRef)a1) != 4)
    return 0;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    Components = CGColorGetComponents((CGColorRef)a1);
    if (Components)
    {
      v5 = Components;
      v6 = 0;
      do
      {
        v7 = v5[v6];
        v10 = v7;
        if (figCFArrayAppendNumber(Mutable, kCFNumberFloatType, &v10))
          break;
      }
      while (v6++ != 3);
    }
  }
  return Mutable;
}

CGColorRef FigCreateCGColorSRGBFromArray(const void *a1)
{
  CFTypeID v2;
  CFIndex v3;
  uint64_t *i;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v7 = 0;
  if (a1 && (v2 = CFGetTypeID(a1), v2 == CFArrayGetTypeID()) && CFArrayGetCount((CFArrayRef)a1) == 4)
  {
    v3 = 0;
    for (i = &v6; figCFArrayGetNumberAtIndex(a1, v3, kCFNumberFloatType, i); i = (uint64_t *)((char *)i + 4))
    {
      if (++v3 == 4)
        return FigCreateCGColorSRGB(*(float *)&v6, *((float *)&v6 + 1), *(float *)&v7, *((float *)&v7 + 1));
    }
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigGetMedianValueOfCArray(uint64_t a1, uint64_t a2, uint64_t (*a3)(_QWORD, uint64_t, _QWORD), uint64_t (*a4)(const void *, uint64_t), size_t a5)
{
  void *v5;
  uint64_t v6;
  unint64_t v10;
  unint64_t v11;
  const void *v12;
  void *v13;
  uint64_t v15;

  v5 = 0;
  if (!a1)
    return (uint64_t)v5;
  v6 = a2 - 1;
  if (a2 < 1)
    return (uint64_t)v5;
  v10 = a2 & 0x8000000000000001;
  v11 = (unint64_t)a2 >> 1;
  v12 = *(const void **)(a1 + 8 * figGetIndexOfNthSmallestValue(a1, 0, v6, a3, (unint64_t)a2 >> 1));
  if (v10 == 1)
  {
    v13 = malloc_type_malloc(a5, 0x6B167077uLL);
    v5 = v13;
    if (v13)
      memcpy(v13, v12, a5);
    return (uint64_t)v5;
  }
  v15 = *(_QWORD *)(a1 + 8 * figGetIndexOfNthSmallestValue(a1, 0, v6, a3, v11 - 1));
  return a4(v12, v15);
}

uint64_t figGetIndexOfNthSmallestValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(_QWORD, uint64_t, _QWORD), uint64_t a5)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t SubMedian;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v28;

  if (a2 != a3)
  {
    v6 = a3;
    v8 = a2;
    while (1)
    {
      v28 = a2;
      if (v6 - v8 < 5)
      {
        SubMedian = figFindSubMedian(a1, v8, v6, a4);
      }
      else
      {
        if (v6 >= v8)
        {
          v9 = 0;
          do
          {
            v10 = v9 / 5 + v8;
            if (v8 + v9 + 4 >= v6)
              v11 = v6;
            else
              v11 = v8 + v9 + 4;
            v12 = figFindSubMedian(a1, v8 + v9, v11, a4);
            v13 = *(_QWORD *)(a1 + 8 * v12);
            *(_QWORD *)(a1 + 8 * v12) = *(_QWORD *)(a1 + 8 * v10);
            *(_QWORD *)(a1 + 8 * v10) = v13;
            v9 += 5;
          }
          while (v8 + v9 <= v6);
        }
        SubMedian = figGetIndexOfNthSmallestValue(a1, v8, (v6 - v8) / 5 + v8, a4, v8 + (v6 - v8) / 10 + 1);
      }
      v15 = *(_QWORD *)(a1 + 8 * SubMedian);
      *(_QWORD *)(a1 + 8 * SubMedian) = *(_QWORD *)(a1 + 8 * v6);
      *(_QWORD *)(a1 + 8 * v6) = v15;
      v16 = v8;
      v17 = v6 - v8;
      if (v6 > v8)
      {
        v18 = (_QWORD *)(a1 + 8 * v8);
        v16 = v8;
        do
        {
          if (a4(*v18, v15, 0) == -1)
          {
            v19 = *(_QWORD *)(a1 + 8 * v16);
            *(_QWORD *)(a1 + 8 * v16) = *v18;
            *v18 = v19;
            ++v16;
          }
          ++v18;
          --v17;
        }
        while (v17);
      }
      v20 = v16;
      v21 = v6 - v16;
      if (v6 > v16)
      {
        v22 = (_QWORD *)(a1 + 8 * v16);
        v20 = v16;
        do
        {
          if (!a4(*v22, v15, 0))
          {
            v23 = *(_QWORD *)(a1 + 8 * v20);
            *(_QWORD *)(a1 + 8 * v20) = *v22;
            *v22 = v23;
            ++v20;
          }
          ++v22;
          --v21;
        }
        while (v21);
      }
      v24 = *(_QWORD *)(a1 + 8 * v6);
      *(_QWORD *)(a1 + 8 * v6) = *(_QWORD *)(a1 + 8 * v20);
      *(_QWORD *)(a1 + 8 * v20) = v24;
      if (v20 >= a5)
        v25 = a5;
      else
        v25 = v20;
      if (v16 > a5)
        v25 = v16;
      if (v25 == a5)
        break;
      if (v16 <= a5)
        v8 = v25 + 1;
      else
        v6 = v16 - 1;
      a2 = v28;
      if (v16 <= a5)
        a2 = v25 + 1;
      if (v8 == v6)
        return a2;
    }
    return a5;
  }
  return a2;
}

CFStringRef FigCreateBase32EncodedSHA1HashFromCFString(const __CFString *a1)
{
  CC_SHA1_CTX *v2;
  const __CFAllocator *AllocatorForMedia;
  UInt8 *BytesFromCFString;
  UInt8 *v5;
  const __CFAllocator *v6;
  const __CFAllocator *v7;
  CC_LONG len[2];
  CFStringRef v10;
  unsigned __int8 md[8];
  uint64_t v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  *(_QWORD *)md = 0;
  v12 = 0;
  v13 = 0;
  *(_QWORD *)len = 0;
  v2 = FigDigestSHA1Create();
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  BytesFromCFString = FigCreateBytesFromCFString(AllocatorForMedia, a1, 0x8000100u, 0, len);
  if (BytesFromCFString)
  {
    v5 = BytesFromCFString;
    FigDigestSHA1AppendData(v2, BytesFromCFString, len[0]);
    FigDigestSHA1GetDigest(v2, md);
    v6 = (const __CFAllocator *)FigGetAllocatorForMedia();
    FigCreateBase32EncodedStringFromBytes(v6, (uint64_t)md, 20, 0, &v10);
    v7 = (const __CFAllocator *)FigGetAllocatorForMedia();
    CFAllocatorDeallocate(v7, v5);
  }
  FigDigestSHA1Destroy(v2);
  return v10;
}

uint64_t figCFAppendCompactDictionaryDescription(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (*(_BYTE *)(a3 + 8))
    CFStringAppend(*(CFMutableStringRef *)a3, CFSTR(", "));
  figCFAppendCompactDescription(*(CFMutableStringRef *)a3);
  CFStringAppend(*(CFMutableStringRef *)a3, CFSTR(" = "));
  result = figCFAppendCompactDescription(*(CFMutableStringRef *)a3);
  *(_BYTE *)(a3 + 8) = 1;
  return result;
}

CFIndex figCFAppendArrayToCompactDescription(__CFString *a1, CFArrayRef theArray)
{
  CFIndex result;
  CFIndex v5;
  CFIndex i;

  result = CFArrayGetCount(theArray);
  if (result >= 1)
  {
    v5 = result;
    for (i = 0; i != v5; ++i)
    {
      CFArrayGetValueAtIndex(theArray, i);
      if (i)
        CFStringAppend(a1, CFSTR(", "));
      result = figCFAppendCompactDescription(a1);
    }
  }
  return result;
}

uint64_t _FigCFIOKitObjectInit(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

uint64_t _FigCFIOKitObjectFinalize(uint64_t a1)
{
  uint64_t result;

  result = IOObjectRelease(*(_DWORD *)(a1 + 16));
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

void *figCFAllocatorAllocate(size_t a1)
{
  return malloc_type_malloc(a1, 0x8DE2D5E9uLL);
}

void *figCFAllocatorReallocate(void *a1, size_t a2)
{
  return malloc_type_realloc(a1, a2, 0x1EFF7818uLL);
}

uint64_t figFindSubMedian(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(_QWORD, uint64_t, _QWORD))
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;

  if (a2 < a3)
  {
    v8 = a2;
    do
    {
      v9 = v8++;
      if (v9 >= a2)
      {
        v10 = *(_QWORD *)(a1 + 8 * v8);
        do
        {
          if (a4(*(_QWORD *)(a1 + 8 * v9), v10, 0) != 1)
            break;
          v11 = (uint64_t *)(a1 + 8 * v9);
          v12 = *v11;
          v10 = v11[1];
          *v11 = v10;
          v11[1] = v12;
        }
        while (v9-- > a2);
      }
    }
    while (v8 != a3);
  }
  v14 = a3 + a2;
  if (a3 + a2 < 0 != __OFADD__(a3, a2))
    ++v14;
  return v14 >> 1;
}

uint64_t FigHALAudioDeviceGetClassID()
{
  if (FigHALAudioDeviceGetClassID_sRegisterFigHALAudioDeviceClassOnce != -1)
    dispatch_once(&FigHALAudioDeviceGetClassID_sRegisterFigHALAudioDeviceClassOnce, &__block_literal_global_19);
  return FigHALAudioDeviceGetClassID_sFigHALAudioDeviceClassID;
}

uint64_t FigAudioFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigAudioFormatDescriptionRegisterOnce, (void (*)(void))FigAudioFormatDescriptionRegisterOnce);
}

OSStatus CMAudioFormatDescriptionCreate(CFAllocatorRef allocator, const AudioStreamBasicDescription *asbd, size_t layoutSize, const AudioChannelLayout *layout, size_t magicCookieSize, const void *magicCookie, CFDictionaryRef extensions, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  uint64_t v10;
  OSStatus v11;
  uint64_t DerivedStorage;
  uint64_t v20;
  __int128 v21;
  void *v22;
  void *v23;
  CFTypeRef v24;
  uint64_t v25;
  const __CFAllocator *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  void *v30;
  void *v31;
  unsigned int v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  __int128 v36;
  __int128 v37;
  int v38;
  int v39;
  int v40;
  _DWORD *v41;
  unsigned int ChannelLayoutTagFromLayout;
  unsigned int v43;
  int v44;
  BOOL v45;
  _DWORD *v46;
  unint64_t v47;
  int v48;
  void *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _DWORD *v53;
  uint64_t v54;
  int v55;
  __int16 v56;
  CFTypeRef cf;
  _BYTE size[20];
  __int128 v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;

  cf = 0;
  if (!asbd || !formatDescriptionOut || asbd->mSampleRate == 0.0)
  {
    v10 = 4294954586;
LABEL_5:
    v11 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
LABEL_6:
    if (v11 && cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    if (formatDescriptionOut)
      goto LABEL_10;
    return v11;
  }
  FigThreadRunOnce(&sFigAudioFormatDescriptionRegisterOnce, (void (*)(void))FigAudioFormatDescriptionRegisterOnce);
  v11 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x736F756E, asbd->mFormatID, extensions, (uint64_t *)&cf);
  if (v11)
    goto LABEL_6;
  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
  v20 = *(_QWORD *)&asbd->mBitsPerChannel;
  v21 = *(_OWORD *)&asbd->mBytesPerPacket;
  *(_OWORD *)DerivedStorage = *(_OWORD *)&asbd->mSampleRate;
  *(_OWORD *)(DerivedStorage + 16) = v21;
  *(_QWORD *)(DerivedStorage + 32) = v20;
  if (layoutSize && layout)
  {
    v22 = CFAllocatorAllocate(allocator, layoutSize, 0);
    *(_QWORD *)(DerivedStorage + 64) = v22;
    if (!v22)
      goto LABEL_27;
    memcpy(v22, layout, layoutSize);
    *(_QWORD *)(DerivedStorage + 56) = layoutSize;
  }
  if (magicCookieSize && magicCookie)
  {
    v23 = CFAllocatorAllocate(allocator, magicCookieSize, 0);
    *(_QWORD *)(DerivedStorage + 48) = v23;
    if (v23)
    {
      memcpy(v23, magicCookie, magicCookieSize);
      *(_QWORD *)(DerivedStorage + 40) = magicCookieSize;
      goto LABEL_21;
    }
LABEL_27:
    v10 = 4294954585;
    goto LABEL_5;
  }
LABEL_21:
  v24 = cf;
  v25 = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
  v62 = 0;
  *(_DWORD *)size = 0;
  v26 = CFGetAllocator(v24);
  v27 = *(_QWORD *)(v25 + 32);
  v28 = *(_OWORD *)(v25 + 16);
  *(_OWORD *)&size[4] = *(_OWORD *)v25;
  v59 = v28;
  v29 = *(_QWORD *)(v25 + 48);
  v60 = v27;
  v61 = v29;
  LODWORD(v62) = *(_QWORD *)(v25 + 40);
  if (!AudioToolbox_AudioFormatGetPropertyInfo(1718383476, 56, (uint64_t)&size[4], (uint64_t)size)
    && *(_DWORD *)size >= 0x30u)
  {
    v30 = CFAllocatorAllocate(v26, *(unsigned int *)size, 0);
    if (!v30)
    {
      FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      goto LABEL_48;
    }
    v31 = v30;
    if (!AudioToolbox_AudioFormatGetProperty(1718383476, 56, (uint64_t)&size[4], (uint64_t)size, (uint64_t)v30))
    {
      v32 = *(_DWORD *)size;
      if (*(_DWORD *)size > 0x2Fu)
        goto LABEL_26;
    }
    CFAllocatorDeallocate(v26, v31);
    *(_DWORD *)size = 0;
  }
  if (v24)
  {
    v33 = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)v24);
    *(_DWORD *)size = 48;
    v34 = CFAllocatorAllocate(v26, 48, 0);
    if (v34)
    {
      v35 = v34;
      v36 = *(_OWORD *)v33;
      v37 = *(_OWORD *)(v33 + 16);
      v34[4] = *(_QWORD *)(v33 + 32);
      *(_OWORD *)v34 = v36;
      *((_OWORD *)v34 + 1) = v37;
      v38 = *(_DWORD *)(v33 + 28);
      if (v38 == 1)
        v39 = 6553601;
      else
        v39 = -65536;
      if (v38 == 2)
        v40 = 6619138;
      else
        v40 = v39;
      *((_DWORD *)v34 + 10) = v40;
      v41 = *(_DWORD **)(v33 + 64);
      if (v41)
      {
        ChannelLayoutTagFromLayout = getChannelLayoutTagFromLayout(v41, *(_QWORD *)(v33 + 56));
        v43 = *((_DWORD *)v35 + 10);
        if (v43 > 0xFFFEFFFF)
          v44 = 2;
        else
          v44 = 3;
        v45 = ChannelLayoutTagFromLayout != v43 || ChannelLayoutTagFromLayout >= 0xFFFF0000;
        *((_DWORD *)v35 + 10) = ChannelLayoutTagFromLayout;
        if (!v45)
          v44 = 1;
        *(_QWORD *)(v25 + 80) = *(unsigned int *)size;
        *(_QWORD *)(v25 + 88) = v35;
        *(_DWORD *)(v25 + 72) = v44;
      }
      else
      {
        *(_QWORD *)(v25 + 80) = *(unsigned int *)size;
        *(_QWORD *)(v25 + 88) = v35;
      }
      goto LABEL_48;
    }
    v54 = 4294954585;
  }
  else
  {
    v54 = 4294954586;
  }
  if (!FigSignalErrorAt(v54, 0, 0, 0, 0, 0, 0))
  {
    v31 = 0;
    v32 = *(_DWORD *)size;
LABEL_26:
    *(_QWORD *)(v25 + 80) = v32;
    *(_QWORD *)(v25 + 88) = v31;
  }
LABEL_48:
  figAudioFormatDescriptionEnsureRichestDecodableLayout((const opaqueCMFormatDescription *)cf);
  figAudioFormatDescriptionEnsureMostCompatibleLayout((const opaqueCMFormatDescription *)cf);
  v46 = *(_DWORD **)(DerivedStorage + 64);
  if (!v46 || (v47 = *(_QWORD *)(DerivedStorage + 56)) == 0)
  {
    v11 = 0;
LABEL_10:
    *formatDescriptionOut = (CMAudioFormatDescriptionRef)cf;
    return v11;
  }
  *(_QWORD *)size = 0xFFFF000000000000;
  v56 = 0;
  v55 = 0;
  evaluateLayoutAgainstFormatList(*(_QWORD *)(DerivedStorage + 88), *(_QWORD *)(DerivedStorage + 80), v46, v47, size, (int *)&size[4], (_BYTE *)&v56 + 1, &v56, &v55);
  v48 = *(_DWORD *)(DerivedStorage + 72);
  if ((v48 & 0xFFFFFFFE) != 2)
  {
    v48 = v55;
    *(_DWORD *)(DerivedStorage + 72) = v55;
    if (!v48)
    {
      v49 = *(void **)(DerivedStorage + 64);
      if (v49)
      {
        CFAllocatorDeallocate(allocator, v49);
        *(_QWORD *)(DerivedStorage + 64) = 0;
        v48 = *(_DWORD *)(DerivedStorage + 72);
      }
      else
      {
        v48 = 0;
      }
      *(_QWORD *)(DerivedStorage + 56) = 0;
    }
  }
  if ((v48 & 0xFFFFFFFE) == 2)
  {
    v50 = *(_QWORD *)(DerivedStorage + 88);
    if (v50)
    {
      v51 = *(_QWORD *)(DerivedStorage + 80);
      if (v51 >= 0x30)
      {
        v52 = v51 / 0x30;
        v53 = (_DWORD *)(v50 + 40);
        do
        {
          if (*(_DWORD *)size == *(v53 - 3))
            *v53 = *(_DWORD *)&size[4];
          v53 += 12;
          --v52;
        }
        while (v52);
      }
    }
  }
  if (!*(_QWORD *)(DerivedStorage + 64))
  {
    figAudioFormatDescriptionEnsureRichestDecodableLayout((const opaqueCMFormatDescription *)cf);
    figAudioFormatDescriptionEnsureMostCompatibleLayout((const opaqueCMFormatDescription *)cf);
  }
  v11 = 0;
  if (formatDescriptionOut)
    goto LABEL_10;
  return v11;
}

uint64_t figAudioFormatDescriptionEnsureRichestDecodableLayout(const opaqueCMFormatDescription *a1)
{
  uint64_t DerivedStorage;
  _QWORD *v3;
  const AudioFormatListItem *RichestDecodableFormat;
  const AudioFormatListItem *v5;
  uint64_t v6;
  uint64_t v7;
  UInt32 mChannelsPerFrame;
  const __CFAllocator *v9;
  _DWORD *v10;
  uint64_t v12;

  if (a1 && CMFormatDescriptionGetMediaType(a1) == 1936684398)
  {
    DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
    if (*(_QWORD *)(DerivedStorage + 104))
      return 0;
    v3 = (_QWORD *)DerivedStorage;
    RichestDecodableFormat = CMAudioFormatDescriptionGetRichestDecodableFormat(a1);
    if (RichestDecodableFormat)
    {
      v5 = RichestDecodableFormat;
      v6 = v3[8];
      if (v6)
      {
        v7 = v3[7];
        if (v7)
        {
          mChannelsPerFrame = v5->mASBD.mChannelsPerFrame;
          if (mChannelsPerFrame == getAudioChannelCountFromLayout(v6, v7))
            return 0;
        }
      }
      if (v5->mChannelLayoutTag > 0xFFFEFFFF)
        return 0;
      v9 = CFGetAllocator(a1);
      v10 = CFAllocatorAllocate(v9, 12, 0);
      v3[13] = v10;
      if (v10)
      {
        v10[2] = 0;
        *(_QWORD *)v10 = 0;
        *(_DWORD *)v3[13] = v5->mChannelLayoutTag;
        v3[12] = 12;
        return 0;
      }
      v12 = 4294954585;
    }
    else
    {
      v12 = 4294954578;
    }
  }
  else
  {
    v12 = 4294954586;
  }
  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t figAudioFormatDescriptionEnsureMostCompatibleLayout(const opaqueCMFormatDescription *a1)
{
  uint64_t DerivedStorage;
  _QWORD *v3;
  const AudioFormatListItem *MostCompatibleFormat;
  const AudioFormatListItem *v5;
  uint64_t v6;
  uint64_t v7;
  UInt32 mChannelsPerFrame;
  const __CFAllocator *v9;
  _DWORD *v10;
  uint64_t v12;

  if (a1 && CMFormatDescriptionGetMediaType(a1) == 1936684398)
  {
    DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
    if (*(_QWORD *)(DerivedStorage + 120))
      return 0;
    v3 = (_QWORD *)DerivedStorage;
    MostCompatibleFormat = CMAudioFormatDescriptionGetMostCompatibleFormat(a1);
    if (MostCompatibleFormat)
    {
      v5 = MostCompatibleFormat;
      v6 = v3[8];
      if (v6)
      {
        v7 = v3[7];
        if (v7)
        {
          mChannelsPerFrame = v5->mASBD.mChannelsPerFrame;
          if (mChannelsPerFrame == getAudioChannelCountFromLayout(v6, v7))
            return 0;
        }
      }
      if (v5->mChannelLayoutTag > 0xFFFEFFFF)
        return 0;
      v9 = CFGetAllocator(a1);
      v10 = CFAllocatorAllocate(v9, 12, 0);
      v3[15] = v10;
      if (v10)
      {
        v10[2] = 0;
        *(_QWORD *)v10 = 0;
        *(_DWORD *)v3[15] = v5->mChannelLayoutTag;
        v3[14] = 12;
        return 0;
      }
      v12 = 4294954585;
    }
    else
    {
      v12 = 4294954578;
    }
  }
  else
  {
    v12 = 4294954586;
  }
  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t evaluateLayoutAgainstFormatList(uint64_t result, unint64_t a2, _DWORD *a3, unint64_t a4, _DWORD *a5, int *a6, _BYTE *a7, _BYTE *a8, int *a9)
{
  int v12;
  int ChannelLayoutTagFromLayout;
  unint64_t v14;
  uint64_t v15;
  int v18;
  int v19;
  int v20;
  unsigned int v22;
  _BOOL4 v23;
  _BOOL4 v24;
  _BOOL4 v25;
  _BOOL4 v26;
  unint64_t v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int *v31;
  unsigned int v32;

  v12 = 0;
  ChannelLayoutTagFromLayout = -65536;
  v14 = a2 - 48;
  if (a2 < 0x30 || (v15 = result) == 0 || !a3)
  {
    LOBYTE(v18) = 0;
    LOBYTE(v19) = 0;
    v20 = 0;
    goto LABEL_34;
  }
  LOBYTE(v18) = 0;
  LOBYTE(v19) = 0;
  v20 = 0;
  if (a4 < 0xC)
    goto LABEL_34;
  v31 = a6;
  ChannelLayoutTagFromLayout = getChannelLayoutTagFromLayout(a3, a4);
  result = getAudioChannelCountFromLayout((uint64_t)a3, a4);
  v12 = result;
  if (!(_DWORD)result)
    goto LABEL_32;
  if (v14 > 0x2F)
  {
    v27 = a2 / 0x30 - 1;
    if (HIDWORD(v27))
    {
      result = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      goto LABEL_32;
    }
    v32 = 0;
    result = FigAudioFormatGetRichestDecodableFormatIndex(v15, a2, &v32);
    v28 = v32;
    if ((_DWORD)result)
      v28 = 0;
    if (v12 == *(_DWORD *)(v15 + 48 * v28 + 28))
    {
      v29 = *(_DWORD *)(v15 + 48 * v28 + 40);
      v23 = ChannelLayoutTagFromLayout == v29;
      v24 = v29 > 0xFFFEFFFF;
      v18 = 1;
    }
    else
    {
      v18 = 0;
      v23 = 0;
      v24 = 0;
    }
    if (v12 == *(_DWORD *)(v15 + 48 * v27 + 28))
    {
      v30 = *(_DWORD *)(v15 + 48 * v27 + 40);
      v25 = ChannelLayoutTagFromLayout == v30;
      v26 = v30 > 0xFFFEFFFF;
      v19 = 1;
      goto LABEL_20;
    }
    v19 = 0;
    v25 = 0;
  }
  else
  {
    if ((_DWORD)result == *(_DWORD *)(v15 + 28))
    {
      v22 = *(_DWORD *)(v15 + 40);
      v23 = ChannelLayoutTagFromLayout == v22;
      v24 = v22 > 0xFFFEFFFF;
      v18 = 1;
      v19 = 1;
      v25 = v23;
      v26 = v24;
      goto LABEL_20;
    }
    v18 = 0;
    v19 = 0;
    v23 = 0;
    v25 = 0;
    v24 = 0;
  }
  v26 = 0;
LABEL_20:
  if (v19 | v18)
  {
    if (v19 && v26)
    {
      v20 = 2;
      LOBYTE(v19) = 1;
    }
    else if (v18 && v24)
    {
      v20 = 2;
      LOBYTE(v18) = 1;
    }
    else if (v25 || v23)
    {
      v20 = 1;
    }
    else
    {
      v20 = 3;
    }
    goto LABEL_33;
  }
LABEL_32:
  LOBYTE(v18) = 0;
  LOBYTE(v19) = 0;
  v20 = 0;
LABEL_33:
  a6 = v31;
LABEL_34:
  if (a7)
    *a7 = v18;
  if (a8)
    *a8 = v19;
  if (a5)
    *a5 = v12;
  if (a6)
    *a6 = ChannelLayoutTagFromLayout;
  if (a9)
    *a9 = v20;
  return result;
}

const AudioStreamBasicDescription *__cdecl CMAudioFormatDescriptionGetStreamBasicDescription(CMAudioFormatDescriptionRef desc)
{
  if (desc && CMFormatDescriptionGetMediaType(desc) == 1936684398)
    return (const AudioStreamBasicDescription *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  return 0;
}

const void *__cdecl CMAudioFormatDescriptionGetMagicCookie(CMAudioFormatDescriptionRef desc, size_t *sizeOut)
{
  uint64_t DerivedStorage;
  const void *result;
  size_t v6;

  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    v6 = 0;
    result = 0;
    if (!sizeOut)
      return result;
    goto LABEL_6;
  }
  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  result = *(const void **)(DerivedStorage + 48);
  v6 = *(_QWORD *)(DerivedStorage + 40);
  if (sizeOut)
LABEL_6:
    *sizeOut = v6;
  return result;
}

const AudioChannelLayout *__cdecl CMAudioFormatDescriptionGetChannelLayout(CMAudioFormatDescriptionRef desc, size_t *sizeOut)
{
  uint64_t DerivedStorage;
  const AudioChannelLayout *result;
  size_t v6;

  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    result = 0;
LABEL_7:
    v6 = 0;
    if (!sizeOut)
      return result;
    goto LABEL_8;
  }
  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  result = *(const AudioChannelLayout **)(DerivedStorage + 64);
  if (!result)
    goto LABEL_7;
  v6 = *(_QWORD *)(DerivedStorage + 56);
  if (sizeOut)
LABEL_8:
    *sizeOut = v6;
  return result;
}

const AudioStreamBasicDescription *CMAudioFormatDescriptionGetChannelCount(const opaqueCMFormatDescription *a1)
{
  const AudioStreamBasicDescription *result;

  result = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
  if (result)
    return (const AudioStreamBasicDescription *)result->mChannelsPerFrame;
  return result;
}

uint64_t FigAudioFormatDescriptionGetCodecOutputChannelCount(const opaqueCMFormatDescription *a1)
{
  const AudioFormatListItem *RichestDecodableFormat;
  AudioFormatID mFormatID;
  char *v4;
  unsigned int *v5;
  uint64_t mChannelsPerFrame;
  unsigned int v7;
  const void *MagicCookie;
  const void *v9;
  uint64_t v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  _OWORD v20[2];
  uint64_t v21;
  const void *v22;
  int v23;
  uint64_t v24;
  int v25;
  size_t sizeOut;
  unsigned int size;
  AudioFormatID size_4;

  RichestDecodableFormat = CMAudioFormatDescriptionGetRichestDecodableFormat(a1);
  if (!RichestDecodableFormat)
  {
    RichestDecodableFormat = (const AudioFormatListItem *)CMAudioFormatDescriptionGetStreamBasicDescription(a1);
    if (!RichestDecodableFormat)
      goto LABEL_26;
  }
  mFormatID = RichestDecodableFormat->mASBD.mFormatID;
  size = 0;
  size_4 = mFormatID;
  sizeOut = 0;
  if (mFormatID != 1819304813)
  {
    if (!AudioToolbox_AudioFormatGetPropertyInfo(1635148901, 4, (uint64_t)&size_4, (uint64_t)&size)
      && size)
    {
      v4 = (char *)malloc_type_malloc(size, 0xB7AACBFEuLL);
      if (v4)
      {
        if (!AudioToolbox_AudioFormatGetProperty(1635148901, 4, (uint64_t)&size_4, (uint64_t)&size, (uint64_t)v4))
        {
          v7 = size;
          MagicCookie = CMAudioFormatDescriptionGetMagicCookie(a1, &sizeOut);
          if (v7 >= 0xC)
          {
            v9 = MagicCookie;
            v10 = 0;
            v5 = 0;
            mChannelsPerFrame = 0;
            while (1)
            {
              v11 = &v4[12 * v10];
              if (*((_DWORD *)v11 + 1) == size_4 && *(_DWORD *)v11 != 1935959395)
              {
                v12 = *(_OWORD *)&RichestDecodableFormat->mASBD.mBytesPerPacket;
                v13 = *(_QWORD *)&RichestDecodableFormat->mASBD.mBitsPerChannel;
                v20[0] = *(_OWORD *)&RichestDecodableFormat->mASBD.mSampleRate;
                v20[1] = v12;
                v21 = v13;
                v22 = v9;
                v23 = sizeOut;
                v14 = *(_QWORD *)v11;
                v25 = *((_DWORD *)v11 + 2);
                v24 = v14;
                if (AudioToolbox_AudioFormatGetPropertyInfo(1868983411, 64, (uint64_t)v20, (uint64_t)&size))goto LABEL_28;
                if (!size)
                  goto LABEL_28;
                v5 = (unsigned int *)malloc_type_malloc(size, 0x60A79353uLL);
                if (!v5
                  || AudioToolbox_AudioFormatGetProperty(1868983411, 64, (uint64_t)v20, (uint64_t)&size, (uint64_t)v5))
                {
                  goto LABEL_28;
                }
                if (size >= 0x30)
                {
                  v15 = size / 0x30uLL;
                  v16 = v5 + 7;
                  do
                  {
                    v18 = *v16;
                    v16 += 12;
                    v17 = v18;
                    if (mChannelsPerFrame <= v18)
                      mChannelsPerFrame = v17;
                    else
                      mChannelsPerFrame = mChannelsPerFrame;
                    --v15;
                  }
                  while (v15);
                }
              }
              if (++v10 == v7 / 0xCuLL)
                goto LABEL_28;
            }
          }
        }
      }
      mChannelsPerFrame = 0;
      goto LABEL_27;
    }
LABEL_26:
    mChannelsPerFrame = 0;
    v4 = 0;
LABEL_27:
    v5 = 0;
    goto LABEL_28;
  }
  v4 = 0;
  v5 = 0;
  mChannelsPerFrame = RichestDecodableFormat->mASBD.mChannelsPerFrame;
LABEL_28:
  free(v5);
  free(v4);
  return mChannelsPerFrame;
}

const AudioFormatListItem *__cdecl CMAudioFormatDescriptionGetRichestDecodableFormat(CMAudioFormatDescriptionRef desc)
{
  const AudioFormatListItem *FormatList;
  const AudioFormatListItem *result;
  int v3;
  size_t sizeOut;

  sizeOut = 0;
  FormatList = CMAudioFormatDescriptionGetFormatList(desc, &sizeOut);
  result = 0;
  v3 = 0;
  if (FormatList && sizeOut >= 0x30)
  {
    if (FigAudioFormatGetRichestDecodableFormatIndex((uint64_t)FormatList, sizeOut, &v3))
      return 0;
    else
      return &FormatList[v3];
  }
  return result;
}

const AudioFormatListItem *__cdecl CMAudioFormatDescriptionGetFormatList(CMAudioFormatDescriptionRef desc, size_t *sizeOut)
{
  uint64_t DerivedStorage;
  const AudioFormatListItem *result;
  size_t v6;

  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    result = 0;
LABEL_7:
    v6 = 0;
    if (!sizeOut)
      return result;
    goto LABEL_8;
  }
  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
  result = *(const AudioFormatListItem **)(DerivedStorage + 88);
  if (!result)
    goto LABEL_7;
  v6 = *(_QWORD *)(DerivedStorage + 80);
  if (sizeOut)
LABEL_8:
    *sizeOut = v6;
  return result;
}

uint64_t FigAudioFormatGetRichestDecodableFormatIndex(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  uint64_t result;
  int v5;
  int v6;

  v6 = 0;
  if (!a1 || a2 <= 0x2F || HIDWORD(a2) || !a3)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v5 = 4;
  result = AudioToolbox_AudioFormatGetProperty(1718642284, a2, a1, (uint64_t)&v5, (uint64_t)&v6);
  if (!(_DWORD)result)
    *a3 = v6;
  return result;
}

const AudioFormatListItem *__cdecl CMAudioFormatDescriptionGetMostCompatibleFormat(CMAudioFormatDescriptionRef desc)
{
  const AudioFormatListItem *FormatList;
  const AudioFormatListItem *result;
  size_t sizeOut;

  sizeOut = 0;
  FormatList = CMAudioFormatDescriptionGetFormatList(desc, &sizeOut);
  result = 0;
  if (FormatList)
  {
    if (sizeOut >= 0x30)
      return &FormatList[sizeOut / 0x30 - 1];
  }
  return result;
}

OSStatus CMAudioFormatDescriptionCreateSummary(CFAllocatorRef allocator, CFArrayRef formatDescriptionArray, uint32_t flags, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  CFIndex Count;
  uint64_t v8;
  __CFData *Mutable;
  __CFData *v10;
  UInt32 mChannelsPerFrame;
  CFIndex v12;
  double mSampleRate;
  const opaqueCMFormatDescription *ValueAtIndex;
  const opaqueCMFormatDescription *v15;
  const AudioStreamBasicDescription *StreamBasicDescription;
  AudioChannelLayout *ChannelLayout;
  OSStatus v18;
  uint64_t v19;
  UInt8 *MutableBytePtr;
  UInt8 *v22;
  UInt8 *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  int v28;
  int *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  size_t ChannelLayoutSize;
  size_t v37;
  AudioChannelLayout *v38;
  AudioChannelLayout *v39;
  UInt8 *v40;
  UInt32 AudioChannelCountFromLayout;
  AudioStreamBasicDescription v42;
  size_t sizeOut;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  CFRange v49;

  memset(&v42.mFormatID, 0, 32);
  if (formatDescriptionOut)
  {
    *formatDescriptionOut = 0;
    if (formatDescriptionArray && (Count = CFArrayGetCount(formatDescriptionArray)) != 0)
    {
      v8 = Count;
      v42.mSampleRate = 0.0;
      Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      if (Mutable)
      {
        v10 = Mutable;
        sizeOut = 0;
        CFDataIncreaseLength(Mutable, 12);
        if (v8 < 1)
        {
          mChannelsPerFrame = 0;
          mSampleRate = 0.0;
        }
        else
        {
          mChannelsPerFrame = 0;
          v12 = 0;
          mSampleRate = 0.0;
          do
          {
            ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(formatDescriptionArray, v12);
            if (ValueAtIndex)
            {
              v15 = ValueAtIndex;
              if (CMFormatDescriptionGetMediaType(ValueAtIndex) == 1936684398)
              {
                StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(v15);
                if (StreamBasicDescription)
                {
                  if (mSampleRate < StreamBasicDescription->mSampleRate)
                    mSampleRate = StreamBasicDescription->mSampleRate;
                  if (mChannelsPerFrame <= StreamBasicDescription->mChannelsPerFrame)
                    mChannelsPerFrame = StreamBasicDescription->mChannelsPerFrame;
                  ChannelLayout = (AudioChannelLayout *)CMAudioFormatDescriptionGetChannelLayout(v15, &sizeOut);
                  if (ChannelLayout && sizeOut)
                    appendToSummaryChannelLayout(v10, ChannelLayout);
                }
              }
            }
            ++v12;
          }
          while (v8 != v12);
        }
        cleanUpSummaryAndGetChannelLayoutSize(v10);
        MutableBytePtr = CFDataGetMutableBytePtr(v10);
        if (!*(_DWORD *)MutableBytePtr)
        {
          v23 = MutableBytePtr;
          v24 = *((unsigned int *)MutableBytePtr + 2);
          if ((_DWORD)v24)
          {
            v25 = 0;
            v26 = 0;
            v27 = 0;
            v28 = 0;
            v29 = (int *)(MutableBytePtr + 12);
            do
            {
              v31 = *v29;
              v29 += 5;
              v30 = v31;
              if ((v31 & 0xFFFF0000) == 0x10000)
                v32 = v27;
              else
                v32 = 1;
              if (v30 == 42)
                v33 = 1;
              else
                v33 = v28;
              if (v30 == 42)
              {
                v32 = v27;
                v34 = v25;
              }
              else
              {
                v34 = v26;
              }
              if (v30 != 100)
              {
                v28 = v33;
                v27 = v32;
                v26 = v34;
              }
              ++v25;
            }
            while (v24 != v25);
            if (v28 && (_BYTE)v27)
            {
              v46 = 0;
              v45 = 0;
              v48 = 0;
              v47 = 0;
              v49.location = 20 * v26 + 12;
              v49.length = 20;
              CFDataDeleteBytes(v10, v49);
              --*((_DWORD *)v23 + 2);
              v44 = 6619138;
              appendToSummaryChannelLayout(v10, &v44);
            }
          }
        }
        v22 = CFDataGetMutableBytePtr(v10);
        if (*(_DWORD *)v22)
        {
          if (*(_DWORD *)v22 != 0x10000 || *((_DWORD *)v22 + 1) || mChannelsPerFrame - 1 >= 2)
            goto LABEL_54;
        }
        else if (*((_DWORD *)v22 + 2) || mChannelsPerFrame - 1 > 1)
        {
          goto LABEL_54;
        }
        v46 = 0;
        v45 = 0;
        v48 = 0;
        v47 = 0;
        if (mChannelsPerFrame == 1)
          v35 = 6553601;
        else
          v35 = 6619138;
        v44 = v35;
        appendToSummaryChannelLayout(v10, &v44);
LABEL_54:
        ChannelLayoutSize = cleanUpSummaryAndGetChannelLayoutSize(v10);
        if (ChannelLayoutSize < 0xC)
        {
          v39 = 0;
          v37 = 0;
        }
        else
        {
          v37 = ChannelLayoutSize;
          v38 = (AudioChannelLayout *)malloc_type_malloc(ChannelLayoutSize, 0xB36AE80DuLL);
          if (!v38)
          {
            v18 = -12711;
            FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_65:
            CFRelease(v10);
            return v18;
          }
          v39 = v38;
          v40 = CFDataGetMutableBytePtr(v10);
          memcpy(v39, v40, v37);
        }
        v42.mFormatID = 1819304813;
        v42.mSampleRate = mSampleRate;
        AudioChannelCountFromLayout = getAudioChannelCountFromLayout((uint64_t)v39, v37);
        v42.mChannelsPerFrame = AudioChannelCountFromLayout;
        if (AudioChannelCountFromLayout)
        {
          mChannelsPerFrame = AudioChannelCountFromLayout;
        }
        else
        {
          v42.mChannelsPerFrame = mChannelsPerFrame;
          if (v39)
          {
            free(v39);
            v39 = 0;
            v37 = 0;
          }
        }
        v42.mBitsPerChannel = 32;
        v42.mFramesPerPacket = 1;
        v42.mBytesPerFrame = 4 * mChannelsPerFrame;
        v42.mFormatFlags = 9;
        v42.mBytesPerPacket = 4 * mChannelsPerFrame;
        v18 = CMAudioFormatDescriptionCreate(allocator, &v42, v37, v39, 0, 0, 0, formatDescriptionOut);
        if (v39)
          free(v39);
        goto LABEL_65;
      }
      v18 = -12711;
      v19 = 4294954585;
    }
    else
    {
      v18 = -12710;
      v19 = 4294954586;
    }
  }
  else
  {
    v18 = -12710;
    v19 = 4294954586;
  }
  FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
  return v18;
}

