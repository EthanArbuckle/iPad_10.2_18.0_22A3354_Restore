void sub_18F435FE4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ECEDF9F0);
  _Unwind_Resume(a1);
}

double sub_18F436034(uint64_t a1, uint64_t a2)
{
  double v3;
  CFAbsoluteTime Current;
  double result;

  sub_18F4360A8(a2);
  *(_QWORD *)(a2 + 136) = 0;
  *(_BYTE *)(a2 + 144) = 0;
  *(_QWORD *)(a2 + 124) = 0;
  *(_QWORD *)(a2 + 116) = 0;
  *(_OWORD *)(a2 + 152) = xmmword_18F5084B0;
  *(_QWORD *)(a2 + 168) = 0;
  v3 = *(double *)(a2 + 184);
  if (v3 < 5.0)
    *(double *)(a2 + 184) = v3 + 1.0;
  Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(a2 + 176) = Current;
  CFRunLoopTimerSetNextFireDate(*(CFRunLoopTimerRef *)(a2 + 192), Current + *(double *)(a2 + 184));
  return result;
}

void sub_18F4360A8(uint64_t a1)
{
  double Current;
  unsigned int v3;
  double v4;
  double v5;
  double v6;
  NSObject *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  char *v17;
  uint8_t buf[4];
  double v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  double v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v3 = *(_DWORD *)(a1 + 120);
  if (v3)
    v4 = *(double *)(a1 + 152) / (double)v3;
  else
    v4 = 0.0;
  v5 = *(double *)(a1 + 176);
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2955448);
  v6 = Current - v5;
  v7 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_DWORD *)(a1 + 116);
    v9 = *(_DWORD *)(a1 + 120);
    v10 = *(_QWORD *)(a1 + 160);
    v11 = *(_QWORD *)(a1 + 168);
    v12 = *(_DWORD *)(a1 + 124);
    v13 = *(unsigned __int16 *)(a1 + 128);
    v14 = *(_QWORD *)(a1 + 136);
    v15 = *(unsigned __int16 *)(a1 + 130);
    v16 = *(unsigned __int8 *)(a1 + 144);
    *(_DWORD *)buf = 134351616;
    v19 = v6;
    v20 = 1026;
    v21 = v8;
    v22 = 1026;
    v23 = v9;
    v24 = 2050;
    v25 = v4;
    v26 = 2050;
    v27 = v10;
    v28 = 2050;
    v29 = v11;
    v30 = 1026;
    v31 = v12;
    v32 = 1026;
    v33 = v13;
    v34 = 2050;
    v35 = v14;
    v36 = 1026;
    v37 = v15;
    v38 = 1026;
    v39 = v16;
    _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Duration,%{public}.3f,Samples,%{public}u,TimeSyncedSamples,%{public}u,MeanLatency,%{public}.6f,MinLatency,%{public}.6f,MaxLatency,%{public}.6f,TimeSyncStatus,%{public}u,Seq,%{public}u,SensorTime,%{public}llu,Status,0x%{public}04x,Version,%{public}d", buf, 0x58u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2955448);
    v17 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::Tracker::logSensorStatistics() const", "CoreLocation: %s\n", v17);
    if (v17 != (char *)buf)
      free(v17);
  }
}

uint64_t sub_18F436378(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  const char *v78;
  uint64_t v79;
  NSObject *v80;
  char *v82;
  uint8_t buf[4];
  uint64_t v84;
  _QWORD v85[21];
  _QWORD v86[22];

  v86[21] = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 40);
  v85[0] = CFSTR("precisionType");
  v7 = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], a2, *(unsigned int *)(a1 + 80), a4, a5);
  v11 = *(const __CFString **)(a1 + 32);
  if (!v11)
    v11 = CFSTR("unknown");
  v86[0] = v7;
  v86[1] = v11;
  v85[1] = CFSTR("accessoryHardwareModel");
  v85[2] = CFSTR("accessoryBudLocation");
  v86[2] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v8, *(unsigned int *)(v6 + 72), v9, v10);
  v85[3] = CFSTR("headTrackingClientMode");
  v86[3] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v12, *(unsigned int *)(v6 + 88), v13, v14);
  v85[4] = CFSTR("sessionDuration");
  v86[4] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v15, v16, v17, v18, *(double *)(a1 + 48));
  v85[5] = CFSTR("delayBTClock");
  v86[5] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v19, v20, v21, v22, *(double *)(a1 + 56));
  v85[6] = CFSTR("delayTimeSync");
  v86[6] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v23, v24, v25, v26, *(double *)(a1 + 64));
  v85[7] = CFSTR("timeSyncedSamplesPerSecond");
  v86[7] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v27, v28, v29, v30, (float)*(unsigned int *)(v6 + 96) / *(double *)(a1 + 48));
  v85[8] = CFSTR("timeSyncInvalidated");
  v86[8] = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], v31, *(_DWORD *)(v6 + 100) != 0, v32, v33);
  v85[9] = CFSTR("highLatencySamplesPerMinute");
  v86[9] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v34, v35, v36, v37, (float)((float)*(unsigned int *)(v6 + 104) * 60.0) / *(double *)(a1 + 48));
  v85[10] = CFSTR("backwardSamplesPerMinute");
  v86[10] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v38, v39, v40, v41, (float)((float)*(unsigned int *)(v6 + 108) * 60.0) / *(double *)(a1 + 48));
  v85[11] = CFSTR("repeatedSamplesPerMinute");
  v86[11] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v42, v43, v44, v45, (float)((float)*(unsigned int *)(v6 + 112) * 60.0) / *(double *)(a1 + 48));
  v85[12] = CFSTR("minLatency");
  v86[12] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v46, v47, v48, v49, *(double *)(v6 + 32));
  v85[13] = CFSTR("maxLatency");
  v86[13] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v50, v51, v52, v53, *(double *)(v6 + 40));
  v85[14] = CFSTR("averageLatency");
  v86[14] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v54, v55, v56, v57, *(double *)(a1 + 72));
  v85[15] = CFSTR("minInterval");
  v86[15] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v58, v59, v60, v61, *(double *)(v6 + 48));
  v85[16] = CFSTR("maxInterval");
  v86[16] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v62, v63, v64, v65, *(double *)(v6 + 56));
  v85[17] = CFSTR("isAccessoryServiceValid");
  v86[17] = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], v66, *(unsigned __int8 *)(v6 + 92), v67, v68);
  v85[18] = CFSTR("hasValidConfig");
  v86[18] = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], v69, *(unsigned __int8 *)(v6 + 94), v70, v71);
  v85[19] = CFSTR("isBothBudsInEar");
  v86[19] = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], v72, *(unsigned __int8 *)(v6 + 93), v73, v74);
  v85[20] = CFSTR("isIMUInvalid");
  v86[20] = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], v75, *(unsigned __int8 *)(v6 + 95), v76, v77);
  v79 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v78, (uint64_t)v86, (uint64_t)v85, 21);
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2955448);
  v80 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138477827;
    v84 = v79;
    _os_log_impl(&dword_18F1DC000, v80, OS_LOG_TYPE_DEFAULT, "[AccessoryDeviceMotion] Sending analytics: \n%{private}@", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2955448);
    v82 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLAccessoryDeviceMotion::Tracker::stop()_block_invoke", "CoreLocation: %s\n", v82);
    if (v82 != (char *)buf)
      free(v82);
  }
  return v79;
}

os_log_t sub_18F4367FC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1ECEDEE30 = (uint64_t)result;
  return result;
}

uint64_t sub_18F436828(uint64_t a1)
{
  uint64_t v1;
  double v2;
  double v3;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(double *)(v1 + 272);
  v3 = rint(v2 * 1000000.0);
  if (v2 < 0.0)
    v4 = 0;
  else
    v4 = (uint64_t)v3;
  return sub_18F203AF8(*(_QWORD *)(v1 + 32), v4);
}

uint64_t sub_18F436854(uint64_t a1)
{
  uint64_t v1;
  double v2;
  double v3;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(double *)(v1 + 272);
  v3 = rint(v2 * 1000000.0);
  if (v2 < 0.0)
    v4 = 0;
  else
    v4 = (uint64_t)v3;
  return sub_18F203AF8(*(_QWORD *)(v1 + 32), v4);
}

uint64_t sub_18F436880(uint64_t a1)
{
  return sub_18F203AF8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)rint(0.0));
}

uint64_t sub_18F436898(uint64_t a1)
{
  return sub_18F203AF8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)rint(0.0));
}

uint64_t sub_18F4368B0(uint64_t a1)
{
  uint64_t v1;
  double v2;
  double v3;
  uint64_t v4;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(double *)(v1 + 272);
  v3 = rint(v2 * 1000000.0);
  if (v2 < 0.0)
    v4 = 0;
  else
    v4 = (uint64_t)v3;
  return sub_18F203AF8(*(_QWORD *)(v1 + 32), v4);
}

uint64_t sub_18F4368DC(uint64_t a1)
{
  return sub_18F203AF8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), (uint64_t)rint(0.0));
}

os_log_t sub_18F436C78()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1EE16D6A8 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F436CA4(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_18F26F880(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_18F436D00(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_18F437AAC(_QWORD *a1)
{
  a1[32] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 35);
  a1[22] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 25);
  a1[11] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 14);
  a1[2] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 5);
  return a1;
}

void sub_18F437B04(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, unsigned int a5, unsigned int a6, unsigned int a7, _DWORD *a8, char a9)
{
  unint64_t v14;
  NSObject *v15;
  double v16;
  double v17;
  double v18;
  int v19;
  double v20;
  char *v21;
  uint8_t buf[4];
  double v23;
  __int16 v24;
  double v25;
  __int16 v26;
  double v27;
  __int16 v28;
  int v29;
  __int16 v30;
  double v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 4) = *a3;
  *(_DWORD *)(a1 + 12) = *a4;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 24) = a5;
  sub_18F1E6174((_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 96) = a6;
  sub_18F1E6174((_QWORD *)(a1 + 88));
  *(_QWORD *)(a1 + 160) = a7 / a5;
  *(_DWORD *)(a1 + 168) = *a8;
  *(_QWORD *)(a1 + 184) = a6;
  sub_18F1E6174((_QWORD *)(a1 + 176));
  *(_BYTE *)(a1 + 248) = a9;
  if (a9)
    v14 = vcvtad_u64_f64(*(float *)a1 * 0.25);
  else
    v14 = 1;
  *(_QWORD *)(a1 + 264) = v14;
  sub_18F1E6174((_QWORD *)(a1 + 256));
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953908);
  v15 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v16 = *(float *)a1;
    v17 = *(float *)(a1 + 4);
    v18 = *(float *)(a1 + 12);
    v19 = *(_DWORD *)(a1 + 160);
    v20 = *(float *)(a1 + 168);
    *(_DWORD *)buf = 134219008;
    v23 = v16;
    v24 = 2048;
    v25 = v17;
    v26 = 2048;
    v27 = v18;
    v28 = 1024;
    v29 = v19;
    v30 = 2048;
    v31 = v20;
    _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_DEBUG, "sample rate (%.3f) observation rate (%.3f) observation threshold (%.3f) deviation count threshold (%d) standard deviation threshold (%.3f)", buf, 0x30u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953908);
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLThreshold::init(const float &, const float &, const float &, const unsigned int, const unsigned int, const unsigned int, const float &, const BOOL)", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
  }
}

uint64_t sub_18F437DE0(uint64_t a1, float *a2)
{
  unint64_t v4;
  float v5;
  float v6;
  unint64_t v7;
  uint64_t result;
  unint64_t v9;
  float v10;
  float v11;
  unint64_t v12;
  float v13;
  unint64_t v14;
  float v15;
  int v16;
  int v17;
  unsigned int v18;
  NSObject *v19;
  unint64_t v20;
  double v21;
  double v22;
  double v23;
  unint64_t v24;
  float v25;
  int v26;
  unint64_t v27;
  double v28;
  double v29;
  double v30;
  unint64_t v31;
  float v32;
  int v33;
  char *v34;
  float v35[2];
  double v36;
  __int16 v37;
  double v38;
  __int16 v39;
  double v40;
  __int16 v41;
  double v42;
  __int16 v43;
  int v44;
  uint8_t buf[4];
  double v46;
  __int16 v47;
  double v48;
  __int16 v49;
  double v50;
  __int16 v51;
  double v52;
  __int16 v53;
  int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  ++*(_DWORD *)(a1 + 8);
  if (*(_BYTE *)(a1 + 248) && *(_QWORD *)(a1 + 320) < *(_QWORD *)(a1 + 264))
    sub_18F1FD65C(a1 + 256, a2);
  sub_18F1FD65C(a1 + 16, a2);
  if ((unint64_t)*(unsigned int *)(a1 + 8) % *(_QWORD *)(a1 + 24))
    return 0;
  v4 = *(_QWORD *)(a1 + 80);
  v5 = 0.0;
  v6 = 0.0;
  if (v4)
    v6 = *(float *)(a1 + 32) / (float)v4;
  *(float *)buf = v6;
  sub_18F1FD65C(a1 + 88, (float *)buf);
  v7 = *(_QWORD *)(a1 + 152);
  if (v7)
    v5 = *(float *)(a1 + 104) / (float)v7;
  v35[0] = (float)(*a2 - v5) * (float)(*a2 - v5);
  sub_18F1FD65C(a1 + 176, v35);
  if (*(_DWORD *)(a1 + 8) % (float)(*(float *)a1 / *(float *)(a1 + 4)))
    return 0;
  v9 = *(_QWORD *)(a1 + 152);
  v10 = 0.0;
  v11 = 0.0;
  if (v9)
    v11 = *(float *)(a1 + 104) / (float)v9;
  v12 = *(_QWORD *)(a1 + 320);
  if (v12)
    v10 = *(float *)(a1 + 272) / (float)v12;
  v13 = vabds_f32(v11, v10);
  v14 = *(_QWORD *)(a1 + 240);
  if (v14)
    v15 = *(float *)(a1 + 192) / (float)v14;
  else
    v15 = 0.0;
  v16 = *(_DWORD *)(a1 + 164);
  if (v13 <= *(float *)(a1 + 12))
  {
    if (!v16)
      return 0;
    v17 = -1;
  }
  else
  {
    v17 = 1;
  }
  result = 0;
  v18 = v17 + v16;
  *(_DWORD *)(a1 + 164) = v18;
  if (v18 > *(_DWORD *)(a1 + 160) && sqrtf(v15) != 0.0)
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953908);
    v19 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
    {
      v20 = *(_QWORD *)(a1 + 320);
      if (v20)
        v21 = (float)(*(float *)(a1 + 272) / (float)v20);
      else
        v21 = 0.0;
      v22 = *(float *)(a1 + 12);
      v23 = *a2;
      v24 = *(_QWORD *)(a1 + 240);
      if (v24)
        v25 = *(float *)(a1 + 192) / (float)v24;
      else
        v25 = 0.0;
      v26 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)buf = 134219008;
      v46 = v22;
      v47 = 2048;
      v48 = v23;
      v49 = 2048;
      v50 = v21;
      v51 = 2048;
      v52 = sqrtf(fabsf(v25));
      v53 = 1024;
      v54 = v26;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_DEBUG, "threshold (%f) was exceeded with observed value (%f) and base value (%f) and standard deviation (%f) and count of (%d)", buf, 0x30u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953908);
      v27 = *(_QWORD *)(a1 + 320);
      if (v27)
        v28 = (float)(*(float *)(a1 + 272) / (float)v27);
      else
        v28 = 0.0;
      v29 = *(float *)(a1 + 12);
      v30 = *a2;
      v31 = *(_QWORD *)(a1 + 240);
      if (v31)
        v32 = *(float *)(a1 + 192) / (float)v31;
      else
        v32 = 0.0;
      v33 = *(_DWORD *)(a1 + 164);
      v35[1] = 3.8524e-34;
      v36 = v29;
      v37 = 2048;
      v38 = v30;
      v39 = 2048;
      v40 = v28;
      v41 = 2048;
      v42 = sqrtf(fabsf(v32));
      v43 = 1024;
      v44 = v33;
      v34 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL CLThreshold::update(const float &)", "CoreLocation: %s\n", v34);
      if (v34 != (char *)buf)
        free(v34);
    }
    return 1;
  }
  return result;
}

float sub_18F438204(uint64_t a1, int a2)
{
  unint64_t v3;
  float v4;
  float result;
  float v6;

  if (a2)
  {
    v3 = *(_QWORD *)(a1 + 320);
    if (v3)
      v4 = *(float *)(a1 + 272) / (float)v3;
    else
      v4 = 0.0;
    v6 = v4;
    *(_DWORD *)(a1 + 8) = 0;
    sub_18F1E6174((_QWORD *)(a1 + 16));
    sub_18F1E6174((_QWORD *)(a1 + 88));
    *(_DWORD *)(a1 + 164) = 0;
    sub_18F1E6174((_QWORD *)(a1 + 176));
    return sub_18F4382AC((_QWORD *)a1, &v6);
  }
  else
  {
    *(_DWORD *)(a1 + 8) = 0;
    sub_18F1E6174((_QWORD *)(a1 + 16));
    sub_18F1E6174((_QWORD *)(a1 + 88));
    *(_DWORD *)(a1 + 164) = 0;
    sub_18F1E6174((_QWORD *)(a1 + 176));
    sub_18F1E6174((_QWORD *)(a1 + 256));
  }
  return result;
}

float sub_18F4382AC(_QWORD *a1, float *a2)
{
  uint64_t v4;
  float result;

  v4 = (uint64_t)(a1 + 32);
  sub_18F1E6174(a1 + 32);
  while (a1[40] < a1[33])
    result = sub_18F1FD65C(v4, a2);
  return result;
}

uint64_t sub_18F43850C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float a5, float a6)
{
  NSObject *v10;
  double v11;
  double v12;
  char *v14;
  uint8_t buf[4];
  double v16;
  __int16 v17;
  double v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a1 = -1082130432;
  *(_BYTE *)(a1 + 4) = 0;
  *(float *)(a1 + 8) = a5;
  *(float *)(a1 + 12) = a6;
  *(_DWORD *)(a1 + 16) = 5;
  *(_QWORD *)(a1 + 24) = &off_1E294AC98;
  *(_QWORD *)(a1 + 32) = a2;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = &off_1E294A7A8;
  *(_QWORD *)(a1 + 104) = a3;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_QWORD *)(a1 + 184) = &off_1E294AC98;
  *(_QWORD *)(a1 + 192) = a2;
  *(_QWORD *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_BYTE *)(a1 + 256) = a4;
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953928);
  v10 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v11 = *(float *)(a1 + 8);
    v12 = *(float *)(a1 + 12);
    *(_DWORD *)buf = 134219008;
    v16 = v11;
    v17 = 2048;
    v18 = v12;
    v19 = 2048;
    v20 = a2;
    v21 = 2048;
    v22 = a3;
    v23 = 1024;
    v24 = a4;
    _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEBUG, "mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd), coverAttached (%d)", buf, 0x30u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953928);
    v14 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLCompassAccuracy::CLCompassAccuracy(const float, const float, const size_t, const size_t, const BOOL)", "CoreLocation: %s\n", v14);
    if (v14 != (char *)buf)
      free(v14);
  }
  return a1;
}

void sub_18F4387B4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v1[23] = v3;
  sub_18F3CBA50(v1 + 26);
  v1[12] = v4;
  sub_18F3CBA50(v2);
  v1[3] = v3;
  sub_18F3CBA50(v1 + 6);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4387E8(_QWORD *a1)
{
  *a1 = &off_1E294A7A8;
  sub_18F3CBA50(a1 + 5);
  return a1;
}

_QWORD *sub_18F438818(_QWORD *a1)
{
  a1[23] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 26);
  a1[12] = &off_1E294A7A8;
  sub_18F3CBA50(a1 + 17);
  a1[3] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 6);
  return a1;
}

void sub_18F43886C(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  NSObject *v8;
  double v9;
  double v10;
  char *v11;
  uint8_t buf[4];
  double v13;
  __int16 v14;
  double v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a1 = -1082130432;
  *(float *)(a1 + 8) = a4;
  *(float *)(a1 + 12) = a5;
  *(_QWORD *)(a1 + 32) = a2;
  sub_18F1E6174((_QWORD *)(a1 + 24));
  *(_QWORD *)(a1 + 104) = a3;
  *(_DWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953928);
  v8 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v9 = *(float *)(a1 + 8);
    v10 = *(float *)(a1 + 12);
    *(_DWORD *)buf = 134218752;
    v13 = v9;
    v14 = 2048;
    v15 = v10;
    v16 = 2048;
    v17 = a2;
    v18 = 2048;
    v19 = a3;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEBUG, "mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd)", buf, 0x2Au);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953928);
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLCompassAccuracy::init(const float, const float, const size_t, const size_t)", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
  }
}

float sub_18F438A9C(uint64_t a1, float a2, float a3)
{
  unint64_t v4;
  float v5;
  float v7;
  float v8;
  float v9;

  v9 = a3;
  if (*(_BYTE *)(a1 + 4))
  {
    v8 = (float)(a2 - *(float *)(a1 + 8)) * (float)(a2 - *(float *)(a1 + 8));
    sub_18F1FD65C(a1 + 24, &v8);
    v4 = *(_QWORD *)(a1 + 88);
    if (v4)
      v5 = *(float *)(a1 + 40) / (float)v4;
    else
      v5 = 0.0;
    v7 = v5;
    sub_18F438B20(a1 + 96, &v7);
  }
  return sub_18F1FD65C(a1 + 184, &v9);
}

void sub_18F438B20(uint64_t a1, float *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v4 = a1 + 40;
  sub_18F1FD700((_QWORD *)(a1 + 40), a2);
  v5 = *(_QWORD *)(a1 + 80);
  if (v5 > *(_QWORD *)(a1 + 8))
  {
    ++*(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 80) = v5 - 1;
    sub_18F3CBAE4(v4, 1);
  }
  if (*a2 <= *(float *)(a1 + 16))
  {
    v6 = *(_QWORD *)(a1 + 24) + 1;
    *(_QWORD *)(a1 + 24) = v6;
    if (v6 >= *(_QWORD *)(a1 + 8))
      sub_18F438EE8(a1);
  }
  else
  {
    *(float *)(a1 + 16) = *a2;
    *(_QWORD *)(a1 + 24) = 0;
  }
}

float sub_18F438BC8(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float result;

  v2 = *(void ***)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 80) = 0;
  v4 = v3 - (_QWORD)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v5 = *(_QWORD *)(a1 + 56);
      v2 = (void **)(*(_QWORD *)(a1 + 48) + 8);
      *(_QWORD *)(a1 + 48) = v2;
      v4 = v5 - (_QWORD)v2;
    }
    while (v4 > 0x10);
  }
  if (v4 >> 3 == 1)
  {
    v6 = 512;
    goto LABEL_7;
  }
  if (v4 >> 3 == 2)
  {
    v6 = 1024;
LABEL_7:
    *(_QWORD *)(a1 + 72) = v6;
  }
  result = *(float *)(a1 + 32);
  *(float *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 24) = 0;
  return result;
}

float sub_18F438C48(uint64_t a1, int a2)
{
  unsigned int v3;
  float v4;
  float v5;
  float v6;
  float v7;

  if (a2 < 1)
    return *(float *)a1;
  v3 = *(_DWORD *)(a1 + 16) - a2;
  if (v3 > 4)
    v4 = 40.0;
  else
    v4 = flt_18F5085A8[v3];
  if (*(_BYTE *)(a1 + 4))
  {
    v5 = sub_18F438D50(a1);
    if (*(float *)(a1 + 8) >= 70.0)
      v6 = v4 + 10.0;
    else
      v6 = v4;
    if (v5 < v6)
      v4 = v6;
    else
      v4 = v5;
  }
  if (*(_BYTE *)(a1 + 256))
  {
    v7 = v4 + sub_18F438E04(a1);
    v4 = -1.0;
    if (v7 > 0.0)
    {
      v4 = 10.0;
      if (v7 > 10.0)
      {
        v4 = 15.0;
        if (v7 > 15.0)
        {
          v4 = 20.0;
          if (v7 > 20.0)
          {
            v4 = 25.0;
            if (v7 > 25.0)
            {
              v4 = 30.0;
              if (v7 > 30.0)
              {
                if (v7 <= 35.0)
                  return 35.0;
                else
                  return 40.0;
              }
            }
          }
        }
      }
    }
  }
  return v4;
}

float sub_18F438D50(uint64_t a1)
{
  unint64_t v1;
  float v2;
  float v3;
  float result;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    v2 = sqrtf(*(float *)(a1 + 112)) / sqrt((double)v1);
  else
    v2 = 0.0;
  v3 = v2 * *(float *)(a1 + 12);
  result = 10.0;
  if (v3 >= 15.0)
  {
    result = 15.0;
    if (v3 >= 30.0)
    {
      result = 20.0;
      if (v3 >= 45.0)
      {
        result = 25.0;
        if (v3 >= 60.0)
        {
          result = 30.0;
          if (v3 >= 75.0)
          {
            if (v3 >= 90.0)
              return 40.0;
            else
              return 35.0;
          }
        }
      }
    }
  }
  return result;
}

float sub_18F438E04(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;

  v1 = *(_QWORD *)(a1 + 192);
  if (v1 && (v2 = *(_QWORD *)(a1 + 248), v2 >= v1))
    return sub_18F438E34(*(float *)(a1 + 200) / (float)v2, 5.0);
  else
    return 0.0;
}

float sub_18F438E34(float a1, float a2)
{
  float v5;
  float v6;
  float v7;

  if (a2 > a1)
    return 180.0;
  v5 = (float)-a2 / a1;
  v6 = acosf(v5);
  v7 = sinf(v6);
  return fabsf(atan2f(v7 * a2, a1 + (float)(a2 * v5))) * 57.2957795;
}

void sub_18F438EA8(_QWORD *a1)
{
  *a1 = &off_1E294A7A8;
  sub_18F3CBA50(a1 + 5);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F438EE8(uint64_t result)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  float v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;
  float *v13;
  unint64_t v14;
  _BOOL4 v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v1 = *(_QWORD *)(result + 72);
  v2 = *(_QWORD *)(result + 48);
  v3 = *(_QWORD *)(result + 56);
  v4 = (char *)(v2 + 8 * (v1 >> 10));
  if (v3 == v2)
  {
    v6 = 0;
    v5 = *(_QWORD *)(result + 72) & 0x3FFLL;
  }
  else
  {
    v5 = *(_QWORD *)(result + 72) & 0x3FFLL;
    v6 = *(_QWORD *)v4 + 4 * v5;
  }
  v7 = *(float *)(result + 32);
  *(float *)(result + 16) = v7;
  v8 = *(_QWORD *)(result + 80);
  *(_QWORD *)(result + 24) = v8 - 1;
  v9 = v8 + v1;
  v10 = (char *)(v2 + 8 * (v9 >> 10));
  v11 = v9 & 0x3FF;
  v12 = v4;
LABEL_5:
  v13 = (float *)v6;
  while (1)
  {
    v14 = v3 == v2 ? 0 : *(_QWORD *)v10 + 4 * v11;
    v15 = (unint64_t)v13 < v14 && v12 == v10;
    if (v12 >= v10 && !v15)
      return result;
    v16 = *v13;
    if (*v13 > v7)
    {
      *(float *)(result + 16) = v16;
      if (v3 == v2)
        v17 = 0;
      else
        v17 = *(_QWORD *)v4 + 4 * v5;
      if (v13 == (float *)v17)
        v18 = 0;
      else
        v18 = ((v12 - v4) << 7) + ((v6 - *(_QWORD *)v12) >> 2) - ((v17 - *(_QWORD *)v4) >> 2);
      *(_QWORD *)(result + 24) = v18;
      v7 = v16;
    }
    ++v13;
    v6 += 4;
    if (*(_QWORD *)v12 + 4096 == v6)
    {
      v19 = *((_QWORD *)v12 + 1);
      v12 += 8;
      v6 = v19;
      goto LABEL_5;
    }
  }
}

uint64_t sub_18F438FFC(float *a1, float *a2, float *a3)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  BOOL v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  __float2 v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v42;

  v4 = a2[4];
  v5 = fabsf(v4);
  v6 = a2[2];
  v7 = 0.0;
  if (v5 > fabsf(v6))
  {
    v8 = fabsf(a2[3]);
    v9 = v4 <= 0.0 || v5 <= v8;
    v7 = 0.0625;
    if (v9)
      v7 = 0.0;
  }
  v10 = a1[2];
  v11 = a1[3];
  v12 = a1[4];
  v13 = sqrtf((float)((float)(v11 * v11) + (float)(v10 * v10)) + (float)(v12 * v12));
  if (v13 > 0.0)
  {
    v10 = v10 / v13;
    v11 = v11 / v13;
    v12 = v12 / v13;
  }
  v14 = (float)(v11 + (float)(v10 * 0.0)) + (float)(v12 * 0.0);
  v15 = v11 * 0.0;
  v16 = (float)((float)(v11 * 0.0) - v10) + (float)(v12 * 0.0);
  v17 = v12 + (float)(v15 + (float)(v10 * 0.0));
  v18 = a2[3];
  v19 = sqrtf((float)((float)(v18 * v18) + (float)(v6 * v6)) + (float)(v4 * v4));
  if (v19 > 0.0)
  {
    v6 = v6 / v19;
    v18 = v18 / v19;
    v4 = v4 / v19;
  }
  v20 = (float)(v18 + (float)(v6 * 0.0)) + (float)(v4 * 0.0);
  v21 = v18 * 0.0;
  v22 = (float)((float)(v18 * 0.0) - v6) + (float)(v4 * 0.0);
  v23 = v4 + (float)(v21 + (float)(v6 * 0.0));
  v24 = (float)(v16 * v23) - (float)(v17 * v22);
  v25 = (float)(v17 * v20) - (float)(v14 * v23);
  v26 = (float)(v14 * v22) - (float)(v16 * v20);
  v27 = sqrtf((float)((float)(v25 * v25) + (float)(v24 * v24)) + (float)(v26 * v26));
  if (v27 > 0.0)
  {
    v24 = v24 / v27;
    v25 = v25 / v27;
    v26 = v26 / v27;
  }
  v28 = (float)(v22 * v26) - (float)(v23 * v25);
  v29 = (float)(v23 * v24) - (float)(v20 * v26);
  v30 = (float)(v20 * v25) - (float)(v22 * v24);
  v31 = sqrtf((float)((float)(v29 * v29) + (float)(v28 * v28)) + (float)(v30 * v30));
  if (v31 > 0.0)
  {
    v28 = v28 / v31;
    v29 = v29 / v31;
    v30 = v30 / v31;
  }
  v32 = sqrtf((float)((float)(v22 * v22) + (float)(v20 * v20)) + (float)(v23 * v23));
  if (v32 <= 0.0)
    v33 = 1.0;
  else
    v33 = v32;
  if (v7 != 0.0)
  {
    v39 = (float)((float)(v29 * 0.0) + (float)(v28 * v7)) + (float)(v30 * 0.0);
    v40 = (float)((float)(v25 * 0.0) + (float)(v24 * v7)) + (float)(v26 * 0.0);
    if (v39 != 0.0 || v40 != 0.0)
    {
      v38 = atan2f(-v40, v39) * 57.2957795;
      if (v38 >= 0.0)
      {
        for (; v38 >= 360.0; v38 = v38 + -360.0)
          ;
        goto LABEL_43;
      }
      for (; v38 < -360.0; v38 = v38 + 360.0)
        ;
      goto LABEL_37;
    }
    return 0;
  }
  if (v30 != 0.0 || (v34 = 0.0, v26 != 0.0))
    v34 = atan2f(v26, v30);
  v42 = v34;
  v35 = __sincosf_stret(v34);
  if ((float)((float)(v26 * v35.__sinval) + (float)(v35.__cosval * v30)) == 0.0 && (float)((float)-v23 / v33) == 0.0)
    return 0;
  v36 = (float)(v25 * v35.__cosval) - (float)(v35.__sinval * v29);
  v37 = (float)(v24 * v35.__cosval) - (float)(v35.__sinval * v28);
  if (v36 == 0.0 && v37 == 0.0)
    return 0;
  v38 = (float)((float)-atan2f(v37, v36) - v42) * 57.2957795;
  if (v38 >= 0.0)
  {
    for (; v38 >= 360.0; v38 = v38 + -360.0)
      ;
    goto LABEL_43;
  }
  for (; v38 < -360.0; v38 = v38 + 360.0)
    ;
LABEL_37:
  v38 = v38 + 360.0;
LABEL_43:
  *a3 = v38;
  return 1;
}

uint64_t sub_18F439368()
{
  uint64_t result;
  _QWORD *v1;

  result = sub_18F1F7BFC();
  if ((result & 0x100) != 0)
  {
    v1 = (_QWORD *)operator new();
    result = sub_18F1E61EC((uint64_t)v1, (uint64_t)"CLEclipseNotifier", 3);
    *v1 = &off_1E294A7C8;
    v1[4] = &unk_1E294A828;
    v1[7] = 0;
    v1[8] = 0;
    v1[6] = 0;
    qword_1EE16E8E8 = (uint64_t)v1;
  }
  return result;
}

void sub_18F4393DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10F1C409DD59B8BLL);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F439400(_QWORD *a1)
{
  *a1 = &off_1E294A7C8;
  a1[4] = &unk_1E294A828;
  sub_18F2A8438((uint64_t)(a1 + 7));
  return sub_18F3DB8A0(a1);
}

_QWORD *sub_18F43943C(_QWORD *a1)
{
  _QWORD *v1;

  *(a1 - 4) = &off_1E294A7C8;
  v1 = a1 - 4;
  *a1 = &unk_1E294A828;
  sub_18F2A8438((uint64_t)(a1 + 3));
  return sub_18F3DB8A0(v1);
}

void sub_18F439474(_QWORD *a1)
{
  *a1 = &off_1E294A7C8;
  a1[4] = &unk_1E294A828;
  sub_18F2A8438((uint64_t)(a1 + 7));
  sub_18F3DB8A0(a1);
  JUMPOUT(0x194001438);
}

void sub_18F4394C4(uint64_t a1)
{
  sub_18F439474((_QWORD *)(a1 - 32));
}

double sub_18F4394CC@<D0>(_QWORD *a1@<X8>)
{
  double result;
  double v3;
  char v4;

  v4 = 0;
  v3 = 0.0;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  if (qword_1EE16E8F8 != -1)
    dispatch_once(&qword_1EE16E8F8, &unk_1E29539E8);
  if (sub_18F44131C(qword_1EE16E8F0, (uint64_t)&v4, (uint64_t)&v3))
  {
    result = v3;
    *(double *)a1 = v3;
    *((_BYTE *)a1 + 8) = v4;
  }
  return result;
}

void sub_18F439550(uint64_t a1, int a2)
{
  if (qword_1EE16E8F8 != -1)
    dispatch_once(&qword_1EE16E8F8, &unk_1E29539E8);
  sub_18F441DF0(qword_1EE16E8F0, a2);
}

void sub_18F4395A0()
{
  if (qword_1EE16E8F8 != -1)
    dispatch_once(&qword_1EE16E8F8, &unk_1E29539E8);
  sub_18F4420EC(qword_1EE16E8F0);
}

void sub_18F4395E0(uint64_t a1, unsigned int a2, uint64_t a3)
{
  NSObject *v6;
  NSObject *v7;
  char *v8;
  __int16 v9;
  NSObject *v10;
  uint64_t v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  uint64_t buf;
  _QWORD v21[205];

  v21[204] = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E2954788);
  v6 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67240448;
    HIDWORD(buf) = a2;
    LOWORD(v21[0]) = 2050;
    *(_QWORD *)((char *)v21 + 2) = a3;
    _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "NumberOfSpectatorsChanged,notification,%{public}d,num,%{public}zu", (uint8_t *)&buf, 0x12u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954788);
    LODWORD(v17) = 67240448;
    HIDWORD(v17) = a2;
    v18 = 2050;
    v19 = a3;
    v16 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLEclipseNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v16);
    if (v16 != (char *)&buf)
      free(v16);
  }
  if (a2 != 2)
  {
    if (a2 >= 2)
    {
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954788);
      v7 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf) = 67240192;
        HIDWORD(buf) = a2;
        _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "Unrecognized notification,%{public}d", (uint8_t *)&buf, 8u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954788);
        LODWORD(v17) = 67240192;
        HIDWORD(v17) = a2;
        v8 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "virtual void CLEclipseNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v8);
        goto LABEL_26;
      }
    }
    else
    {
      v9 = sub_18F1F7BFC();
      if ((v9 & 0x100) != 0)
      {
        v11 = *(_QWORD *)(a1 + 56);
        if (!v11)
        {
          v12 = (_QWORD *)sub_18F1E0F30();
          v17 = 0x140000FF0CLL;
          LOBYTE(v18) = 0;
          sub_18F1E9BC8(v12, (uint64_t)&v17, &buf);
          sub_18F346DC8(a1 + 56, (__int128 *)&buf);
          v13 = (std::__shared_weak_count *)v21[0];
          if (v21[0])
          {
            v14 = (unint64_t *)(v21[0] + 8);
            do
              v15 = __ldaxr(v14);
            while (__stlxr(v15 - 1, v14));
            if (!v15)
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
          }
          sub_18F203148(*(_QWORD *)(a1 + 56), (uint64_t)sub_18F43A12C, a1);
          v11 = *(_QWORD *)(a1 + 56);
        }
        sub_18F203AF8(v11, a3 != 0);
        if (qword_1EE16E8F8 != -1)
          dispatch_once(&qword_1EE16E8F8, &unk_1E29539E8);
        sub_18F441038(qword_1EE16E8F0);
      }
      else
      {
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954788);
        v10 = off_1EE16D428;
        if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_FAULT))
        {
          LOWORD(buf) = 0;
          _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_FAULT, "Service unavailable.", (uint8_t *)&buf, 2u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_1EE16D438 != -1)
            dispatch_once(&qword_1EE16D438, &unk_1E2954788);
          v8 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "BOOL CLEclipseNotifier::openHidDevice()", "CoreLocation: %s\n", v8);
LABEL_26:
          if (v8 != (char *)&buf)
            free(v8);
        }
      }
    }
  }
}

void sub_18F439AEC(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  char *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E2954788);
  v3 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_INFO))
  {
    v4 = *(_DWORD *)(a2 + 1);
    *(_DWORD *)buf = 67240192;
    v7 = v4;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_INFO, "pong,%{public}u", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954788);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLEclipseNotifier::visitPong(const CMEclipseReport::Pong *)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
}

uint64_t sub_18F439CA0(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  double v10;
  double v11;
  int v12;
  double v13;
  uint64_t v14;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint8_t buf[8];
  uint64_t v20;
  _BYTE v21[10];
  __int16 v22;
  int v23;
  __int16 v24;
  double v25;
  __int16 v26;
  double v27;
  __int16 v28;
  int v29;
  __int16 v30;
  double v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  double v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E2954788);
  v4 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(unsigned __int8 *)(a2 + 1);
    v6 = *(unsigned __int8 *)(a2 + 2);
    v7 = *(unsigned __int8 *)(a2 + 3);
    v8 = *(unsigned __int8 *)(a2 + 4);
    v9 = *(unsigned __int8 *)(a2 + 5);
    v10 = *(float *)(a2 + 6);
    v11 = *(float *)(a2 + 10);
    v12 = *(unsigned __int8 *)(a2 + 14);
    v13 = *(float *)(a2 + 15);
    v18 = *(_QWORD *)(a1 + 48);
    v14 = mach_absolute_time();
    *(_DWORD *)buf = 67242752;
    *(_DWORD *)&buf[4] = v5;
    LOWORD(v20) = 1026;
    *(_DWORD *)((char *)&v20 + 2) = v6;
    HIWORD(v20) = 1026;
    *(_DWORD *)v21 = v7;
    *(_WORD *)&v21[4] = 1026;
    *(_DWORD *)&v21[6] = v8;
    v22 = 1026;
    v23 = v9;
    v24 = 2050;
    v25 = v10;
    v26 = 2050;
    v27 = v11;
    v28 = 1026;
    v29 = v12;
    v30 = 2050;
    v31 = v13;
    v32 = 2050;
    v33 = v18;
    v34 = 2050;
    v35 = sub_18F1FD20C(v14);
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEFAULT, "Report,shouldSuppress,%{public}u,APAwake,%{public}u,currentState,%{public}u,orientation,%{public}u,motionType,%{public}u,lux,%{public}f,pocketProbability,%{public}f,facedownStatic,%{public}u,timeSinceLastFacedownStatic,%{public}lf,timestamp,%{public}lf,now,%{public}lf", buf, 0x58u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954788);
    v16 = mach_absolute_time();
    sub_18F1FD20C(v16);
    v17 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLEclipseNotifier::visitSuppress(const CMEclipseReport::Suppress *)", "CoreLocation: %s\n", v17);
    if (v17 != (char *)buf)
      free(v17);
  }
  v20 = 0;
  *(_QWORD *)buf = *(_QWORD *)(a1 + 48);
  LOBYTE(v20) = *(_BYTE *)(a2 + 1);
  BYTE1(v20) = *(_BYTE *)(a2 + 14);
  *(double *)v21 = *(float *)(a2 + 15);
  return sub_18F1FD2C8(a1, 0, (uint64_t)buf, 24);
}

uint64_t sub_18F439FF4(uint64_t a1, uint64_t a2)
{
  return sub_18F439CA0(a1 - 32, a2);
}

uint64_t sub_18F439FFC(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v8 = 0;
  v4 = *(_QWORD *)(a1 + 48);
  v2 = a2[1];
  v5 = *a2;
  v6 = v2;
  v7 = a2[2];
  LODWORD(v8) = *((_DWORD *)a2 + 12);
  return sub_18F1FD2C8(a1, 1, (uint64_t)&v4, 64);
}

uint64_t sub_18F43A050(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v8 = 0;
  v4 = *(_QWORD *)(a1 + 16);
  v2 = a2[1];
  v5 = *a2;
  v6 = v2;
  v7 = a2[2];
  LODWORD(v8) = *((_DWORD *)a2 + 12);
  return sub_18F1FD2C8(a1 - 32, 1, (uint64_t)&v4, 64);
}

uint64_t sub_18F43A0AC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v4 = 0;
  v3 = *(_QWORD *)(a1 + 48);
  LOWORD(v4) = *(_WORD *)(a2 + 1);
  return sub_18F1E5A28(a1, 2, (uint64_t)&v3, 16);
}

uint64_t sub_18F43A0E8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v4 = 0;
  v3 = *(_QWORD *)(a1 + 16);
  LOWORD(v4) = *(_WORD *)(a2 + 1);
  return sub_18F1E5A28(a1 - 32, 2, (uint64_t)&v3, 16);
}

void sub_18F43A12C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v4;
  uint8_t *v5;
  NSObject *v6;
  uint8_t buf[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    IOHIDEventGetVendorDefinedData();
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954788);
    v4 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "Empty payload, returning", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954788);
      v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLEclipseNotifier::onIoHidEvent(IOHIDEventRef)", "CoreLocation: %s\n");
LABEL_19:
      if (v5 != buf)
        free(v5);
    }
  }
  else
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954788);
    v6 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "Event ref invalid", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954788);
      v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLEclipseNotifier::onIoHidEvent(IOHIDEventRef)", "CoreLocation: %s\n");
      goto LABEL_19;
    }
  }
}

os_log_t sub_18F43A7F8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Eclipse");
  off_1EE16D428 = result;
  return result;
}

uint64_t sub_18F43A824(int a1, uint32_t __upper_bound)
{
  return arc4random_uniform(__upper_bound);
}

void sub_18F43A834()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F43A848(uint64_t a1, _QWORD *a2, char a3, int a4)
{
  float v6;
  uint64_t v7;
  BOOL *v8;
  float v9;
  double v10;
  unint64_t v11;
  int *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  double v18;
  unint64_t v19;
  unint64_t v20;
  unsigned int v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *p_shared_owners;
  unint64_t v27;
  char v28;
  char v29;
  unint64_t *v30;
  unint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  _BOOL4 v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  float *v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  float *v47;
  float *v48;
  uint64_t v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  std::__shared_weak_count *v56;
  unint64_t *v57;
  unint64_t v58;
  int v59;
  unint64_t *v60;
  unint64_t v61;
  unint64_t *v62;
  unint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  NSObject *v68;
  double v69;
  double v70;
  double v71;
  uint64_t v72;
  _BYTE *v73;
  uint64_t v74;
  std::__shared_weak_count *v75;
  unint64_t *v76;
  unint64_t v77;
  char v78;
  char v79;
  unint64_t *v80;
  unint64_t v81;
  NSObject *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  std::__shared_weak_count *v86;
  unint64_t *v87;
  unint64_t v88;
  int v89;
  unint64_t *v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  NSObject *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  std::__shared_weak_count *v98;
  unint64_t *v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  std::__shared_weak_count *v103;
  unint64_t *v104;
  unint64_t v105;
  int v106;
  unint64_t *v107;
  unint64_t v108;
  unint64_t *v109;
  unint64_t v110;
  int v111;
  int v112;
  int v113;
  NSObject *v119;
  int v120;
  double v121;
  unsigned int v122;
  unsigned int v123;
  NSObject *v124;
  double v125;
  _BOOL4 v126;
  char *v128;
  int v129;
  char *v130;
  uint64_t v131;
  char *v132;
  int v133;
  double v134;
  char *v135;
  double v136;
  _BOOL4 v137;
  char *v138;
  char *v139;
  double v140;
  double v141;
  double v142;
  char *v143;
  float *v144;
  BOOL *v145;
  int v146;
  _QWORD v147[2];
  _BYTE v148[22];
  __int16 v149;
  double v150;
  _BYTE buf[22];
  __int16 v152;
  double v153;
  uint64_t v154;

  v154 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = *a2;
  v6 = 1.0 / *(double *)a2;
  *(float *)(a1 + 8) = v6;
  v7 = a1 + 8;
  *(_BYTE *)(a1 + 12) = 0;
  v8 = (BOOL *)(a1 + 12);
  *(_QWORD *)(a1 + 14) = 0;
  v145 = (BOOL *)(a1 + 14);
  *(_BYTE *)(a1 + 13) = a3;
  *(_QWORD *)(a1 + 30) = 0;
  *(_QWORD *)(a1 + 22) = 0;
  *(_WORD *)(a1 + 38) = 0;
  *(_QWORD *)(a1 + 40) = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 48) = &off_1E2949650;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = &off_1E2949650;
  *(_QWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  sub_18F43850C(a1 + 112, 10, 30, a4, 61.056, 2.0);
  *(_QWORD *)(v7 + 368) = 0xF00000000;
  *(_DWORD *)(v7 + 376) = 15;
  v9 = *(float *)v7;
  v10 = *(float *)v7;
  v11 = vcvtad_u64_f64(v10 * 0.125);
  *(_QWORD *)(v7 + 384) = &off_1E294A890;
  *(_QWORD *)(v7 + 392) = v11;
  *(_QWORD *)(v7 + 400) = &off_1E294AC98;
  *(_QWORD *)(v7 + 408) = v11;
  *(_OWORD *)(v7 + 416) = 0u;
  *(_OWORD *)(v7 + 432) = 0u;
  *(_OWORD *)(v7 + 448) = 0u;
  *(_QWORD *)(v7 + 464) = 0;
  *(_QWORD *)(v7 + 472) = &off_1E294AC98;
  *(_QWORD *)(v7 + 480) = v11;
  *(_OWORD *)(v7 + 488) = 0u;
  *(_OWORD *)(v7 + 504) = 0u;
  *(_OWORD *)(v7 + 520) = 0u;
  *(_QWORD *)(v7 + 536) = 0;
  *(_QWORD *)(v7 + 544) = &off_1E294AC98;
  *(_QWORD *)(v7 + 552) = v11;
  v12 = (int *)(v7 + 616);
  *(_QWORD *)(v7 + 620) = 0xBF8000003F000000;
  v144 = (float *)(v7 + 620);
  *(_OWORD *)(v7 + 604) = 0u;
  *(_OWORD *)(v7 + 576) = 0u;
  *(_OWORD *)(v7 + 592) = 0u;
  *(_OWORD *)(v7 + 560) = 0u;
  *(_DWORD *)(v7 + 628) = -1082130432;
  *(_QWORD *)(v7 + 632) = &off_1E2949B58;
  *(_DWORD *)(v7 + 640) = 0;
  *(_OWORD *)(v7 + 648) = 0u;
  *(_OWORD *)(v7 + 664) = 0u;
  *(_OWORD *)(v7 + 680) = 0u;
  *(_QWORD *)(v7 + 704) = 0;
  *(_QWORD *)(v7 + 712) = 0;
  *(_QWORD *)(v7 + 696) = v7 + 704;
  *(_QWORD *)(v7 + 720) = &off_1E2949B58;
  *(_DWORD *)(v7 + 728) = 0;
  *(_OWORD *)(v7 + 752) = 0u;
  *(_OWORD *)(v7 + 768) = 0u;
  *(_OWORD *)(v7 + 736) = 0u;
  *(_QWORD *)(v7 + 800) = 0;
  *(_QWORD *)(v7 + 792) = 0;
  *(_QWORD *)(v7 + 784) = v7 + 792;
  v13 = vcvtad_u64_f64(v10 * 0.05);
  *(_QWORD *)(v7 + 808) = &off_1E294A890;
  *(_QWORD *)(v7 + 816) = v13;
  *(_QWORD *)(v7 + 824) = &off_1E294AC98;
  *(_QWORD *)(v7 + 832) = v13;
  *(_OWORD *)(v7 + 840) = 0u;
  *(_OWORD *)(v7 + 856) = 0u;
  *(_OWORD *)(v7 + 872) = 0u;
  *(_QWORD *)(v7 + 888) = 0;
  *(_QWORD *)(v7 + 896) = &off_1E294AC98;
  *(_QWORD *)(v7 + 904) = v13;
  *(_OWORD *)(v7 + 912) = 0u;
  *(_OWORD *)(v7 + 928) = 0u;
  *(_OWORD *)(v7 + 944) = 0u;
  *(_QWORD *)(v7 + 960) = 0;
  *(_QWORD *)(v7 + 968) = &off_1E294AC98;
  *(_QWORD *)(v7 + 976) = v13;
  *(_QWORD *)(v7 + 1032) = 0;
  *(_OWORD *)(v7 + 1016) = 0u;
  *(_OWORD *)(v7 + 1000) = 0u;
  *(_OWORD *)(v7 + 984) = 0u;
  *(_QWORD *)(v7 + 1040) = &off_1E294A890;
  *(_QWORD *)(v7 + 1048) = v13;
  *(_QWORD *)(v7 + 1056) = &off_1E294AC98;
  *(_QWORD *)(v7 + 1064) = v13;
  *(_QWORD *)(v7 + 1120) = 0;
  *(_OWORD *)(v7 + 1088) = 0u;
  *(_OWORD *)(v7 + 1072) = 0u;
  *(_OWORD *)(v7 + 1104) = 0u;
  *(_QWORD *)(v7 + 1128) = &off_1E294AC98;
  *(_QWORD *)(v7 + 1136) = v13;
  *(_QWORD *)(v7 + 1192) = 0;
  *(_OWORD *)(v7 + 1176) = 0u;
  *(_OWORD *)(v7 + 1160) = 0u;
  *(_OWORD *)(v7 + 1144) = 0u;
  *(_QWORD *)(v7 + 1200) = &off_1E294AC98;
  *(_QWORD *)(v7 + 1208) = v13;
  *(_QWORD *)(v7 + 1264) = 0;
  *(_OWORD *)(v7 + 1248) = 0u;
  *(_OWORD *)(v7 + 1232) = 0u;
  *(_OWORD *)(v7 + 1216) = 0u;
  *(_QWORD *)(v7 + 1272) = &off_1E2949650;
  *(_QWORD *)(v7 + 1280) = 0;
  *(_DWORD *)(v7 + 1288) = 0;
  *(_QWORD *)(v7 + 1296) = &off_1E2949650;
  *(_QWORD *)(v7 + 1304) = 0;
  *(_DWORD *)(v7 + 1312) = 0;
  *(_QWORD *)(v7 + 1320) = &off_1E2949650;
  *(_QWORD *)(v7 + 1328) = 0;
  *(_DWORD *)(v7 + 1336) = 0;
  *(_QWORD *)(v7 + 1408) = 0;
  *(_OWORD *)(v7 + 1392) = 0u;
  *(_OWORD *)(v7 + 1376) = 0u;
  *(_OWORD *)(v7 + 1344) = 0u;
  *(_OWORD *)(v7 + 1360) = 0u;
  *(_QWORD *)(v7 + 1416) = 0xBFF0000000000000;
  v14 = vcvtad_u64_f64(v10 * 0.5);
  *(_QWORD *)(v7 + 1424) = &off_1E294AC98;
  *(_QWORD *)(v7 + 1432) = v14;
  *(_QWORD *)(v7 + 1488) = 0;
  *(_OWORD *)(v7 + 1472) = 0u;
  *(_OWORD *)(v7 + 1456) = 0u;
  *(_OWORD *)(v7 + 1440) = 0u;
  *(_QWORD *)(v7 + 1496) = &off_1E294AC98;
  *(_QWORD *)(v7 + 1504) = v14;
  *(_QWORD *)(v7 + 1560) = 0;
  *(_OWORD *)(v7 + 1544) = 0u;
  *(_OWORD *)(v7 + 1528) = 0u;
  *(_OWORD *)(v7 + 1512) = 0u;
  *(_QWORD *)(v7 + 1568) = &off_1E294AC98;
  *(_QWORD *)(v7 + 1576) = vcvtas_u32_f32(v9);
  *(_QWORD *)(v7 + 1648) = 0;
  *(_OWORD *)(v7 + 1632) = 0u;
  *(_OWORD *)(v7 + 1616) = 0u;
  *(_OWORD *)(v7 + 1600) = 0u;
  *(_OWORD *)(v7 + 1584) = 0u;
  *(_QWORD *)(v7 + 1656) = &off_1E294AC98;
  *(_OWORD *)(v7 + 1712) = 0u;
  *(_OWORD *)(v7 + 1696) = 0u;
  *(_OWORD *)(v7 + 1680) = 0u;
  *(_OWORD *)(v7 + 1664) = 0u;
  *(_QWORD *)(v7 + 1728) = &off_1E294AC98;
  *(_OWORD *)(v7 + 1796) = 0u;
  *(_OWORD *)(v7 + 1784) = 0u;
  *(_OWORD *)(v7 + 1768) = 0u;
  *(_OWORD *)(v7 + 1752) = 0u;
  *(_OWORD *)(v7 + 1736) = 0u;
  *(_QWORD *)(v7 + 1816) = &off_1E294AC98;
  *(_BYTE *)(v7 + 1888) = 0;
  *(_OWORD *)(v7 + 1856) = 0u;
  *(_OWORD *)(v7 + 1840) = 0u;
  *(_OWORD *)(v7 + 1824) = 0u;
  *(_OWORD *)(v7 + 1872) = 0u;
  *(_QWORD *)(v7 + 1896) = &off_1E294AC98;
  *(_OWORD *)(v7 + 1968) = 0u;
  *(_OWORD *)(v7 + 1952) = 0u;
  *(_OWORD *)(v7 + 1936) = 0u;
  *(_OWORD *)(v7 + 1920) = 0u;
  *(_OWORD *)(v7 + 1904) = 0u;
  *(_QWORD *)(v7 + 1984) = &off_1E294AC98;
  *(_OWORD *)(v7 + 2040) = 0u;
  *(_OWORD *)(v7 + 2024) = 0u;
  *(_OWORD *)(v7 + 2008) = 0u;
  *(_OWORD *)(v7 + 1992) = 0u;
  *(_QWORD *)(v7 + 2056) = &off_1E294AC98;
  *(_OWORD *)(v7 + 2124) = 0u;
  *(_OWORD *)(v7 + 2096) = 0u;
  *(_OWORD *)(v7 + 2080) = 0u;
  *(_OWORD *)(v7 + 2064) = 0u;
  *(_OWORD *)(v7 + 2112) = 0u;
  *(_QWORD *)(v7 + 2144) = &off_1E294AC98;
  *(_BYTE *)(v7 + 2216) = 0;
  *(_OWORD *)(v7 + 2200) = 0u;
  *(_OWORD *)(v7 + 2184) = 0u;
  *(_OWORD *)(v7 + 2168) = 0u;
  *(_OWORD *)(v7 + 2152) = 0u;
  *(_QWORD *)(v7 + 2224) = &off_1E294AC98;
  *(_BYTE *)(v7 + 2296) = 0;
  *(_OWORD *)(v7 + 2280) = 0u;
  *(_OWORD *)(v7 + 2264) = 0u;
  *(_OWORD *)(v7 + 2248) = 0u;
  *(_OWORD *)(v7 + 2232) = 0u;
  *(_QWORD *)(v7 + 2304) = &off_1E294AC98;
  *(_QWORD *)(v7 + 2312) = vcvtad_u64_f64(v10 * 0.2);
  *(_QWORD *)(v7 + 2368) = 0;
  *(_OWORD *)(v7 + 2352) = 0u;
  *(_OWORD *)(v7 + 2336) = 0u;
  *(_OWORD *)(v7 + 2320) = 0u;
  *(_QWORD *)(v7 + 2376) = 0x3F800000BF800000;
  if (*(_BYTE *)(v7 + 5))
  {
    v15 = operator new();
    sub_18F428424(v15, a2);
    *(_QWORD *)(a1 + 104) = v15;
    *(_QWORD *)(v15 + 1000) = v7 + 1568;
    *(_BYTE *)(v15 + 58) = 1;
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    v16 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_INFO, "using attitude dependent KF calibrator", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 == -1)
      {
LABEL_173:
        *(_WORD *)v148 = 0;
        v139 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)", "CoreLocation: %s\n", v139);
        if (v139 != buf)
          free(v139);
        goto LABEL_14;
      }
LABEL_179:
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
      goto LABEL_173;
    }
  }
  else
  {
    v17 = operator new();
    v18 = *(double *)a2;
    *(_QWORD *)(v17 + 8) = *a2;
    *(float *)&v18 = 1.0 / v18;
    *(_DWORD *)(v17 + 16) = LODWORD(v18);
    *(_DWORD *)(v17 + 28) = 0;
    *(_DWORD *)(v17 + 20) = 0;
    *(_DWORD *)(v17 + 23) = 0;
    *(_QWORD *)(v17 + 32) = &off_1E2949650;
    *(_QWORD *)(v17 + 40) = 0;
    *(_DWORD *)(v17 + 48) = 0;
    *(_QWORD *)v17 = &off_1E294AE40;
    bzero((void *)(v17 + 56), 0x2D8uLL);
    *(_WORD *)(v17 + 822) = 0;
    *(_DWORD *)(v17 + 818) = 0;
    *(_QWORD *)(a1 + 104) = v17;
    v19 = vcvtad_u64_f64(*(float *)(a1 + 8) * 0.25);
    *(_QWORD *)(a1 + 824) = v19;
    *(_QWORD *)(a1 + 840) = v19;
    sub_18F1E6174((_QWORD *)(v7 + 824));
    *(_QWORD *)(a1 + 912) = v19;
    sub_18F1E6174((_QWORD *)(v7 + 896));
    *(_QWORD *)(a1 + 984) = v19;
    sub_18F1E6174((_QWORD *)(v7 + 968));
    v20 = vcvtad_u64_f64(*(float *)(a1 + 8) * 0.25);
    *(_QWORD *)(a1 + 1056) = v20;
    *(_QWORD *)(a1 + 1072) = v20;
    sub_18F1E6174((_QWORD *)(v7 + 1056));
    *(_QWORD *)(a1 + 1144) = v20;
    sub_18F1E6174((_QWORD *)(v7 + 1128));
    *(_QWORD *)(a1 + 1216) = v20;
    v12 = (int *)(v7 + 616);
    sub_18F1E6174((_QWORD *)(v7 + 1200));
    v21 = llround(*(float *)(a1 + 8) * 0.5);
    *(_DWORD *)(a1 + 624) = v21;
    *(_QWORD *)v144 = 0xBF8000003F000000;
    *(_DWORD *)(a1 + 636) = -1082130432;
    *(_DWORD *)(a1 + 648) = v21;
    *(_DWORD *)(a1 + 736) = v21;
    *(_DWORD *)(a1 + 128) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 112))(*(_QWORD *)(a1 + 104));
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    v22 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_INFO, "using AKM calibrator", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 == -1)
        goto LABEL_173;
      goto LABEL_179;
    }
  }
LABEL_14:
  v23 = sub_18F204AE4();
  v24 = *(_QWORD *)(v23 + 24);
  v25 = *(std::__shared_weak_count **)(v23 + 32);
  *(_QWORD *)buf = v24;
  *(_QWORD *)&buf[8] = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldxr(p_shared_owners);
    while (__stxr(v27 + 1, p_shared_owners));
  }
  v28 = sub_18F1EE944(v24, "LogCompass", v8);
  v29 = v28;
  if (!v25)
    goto LABEL_21;
  v30 = (unint64_t *)&v25->__shared_owners_;
  do
    v31 = __ldaxr(v30);
  while (__stlxr(v31 - 1, v30));
  if (v31)
  {
LABEL_21:
    if ((v28 & 1) != 0)
      goto LABEL_23;
    goto LABEL_22;
  }
  ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
  std::__shared_weak_count::__release_weak(v25);
  if ((v29 & 1) == 0)
LABEL_22:
    *v8 = 0;
LABEL_23:
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953968);
  v32 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v32, OS_LOG_TYPE_DEBUG, "compass ignoring database (1)", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    *(_WORD *)v148 = 0;
    v128 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)", "CoreLocation: %s\n", v128);
    if (v128 != buf)
      free(v128);
  }
  v33 = sub_18F204AE4();
  v34 = *(_QWORD *)(v33 + 24);
  v35 = *(std::__shared_weak_count **)(v33 + 32);
  *(_QWORD *)buf = v34;
  *(_QWORD *)&buf[8] = v35;
  if (v35)
  {
    v36 = (unint64_t *)&v35->__shared_owners_;
    do
      v37 = __ldxr(v36);
    while (__stxr(v37 + 1, v36));
  }
  if (!sub_18F1EE944(v34, "CompassManualCalibration", v145))
  {
    if (v35)
    {
      v62 = (unint64_t *)&v35->__shared_owners_;
      do
        v63 = __ldaxr(v62);
      while (__stlxr(v63 - 1, v62));
      if (!v63)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    goto LABEL_65;
  }
  v38 = *v145;
  if (!v35)
    goto LABEL_36;
  v39 = (unint64_t *)&v35->__shared_owners_;
  do
    v40 = __ldaxr(v39);
  while (__stlxr(v40 - 1, v39));
  if (v40)
  {
LABEL_36:
    if (v38)
      goto LABEL_37;
LABEL_65:
    *v145 = 0;
    goto LABEL_83;
  }
  ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
  std::__shared_weak_count::__release_weak(v35);
  if (!v38)
    goto LABEL_65;
LABEL_37:
  v41 = sub_18F204AE4();
  v42 = (float *)(v7 + 1344);
  v43 = *(_QWORD *)(v41 + 24);
  v44 = *(std::__shared_weak_count **)(v41 + 32);
  *(_QWORD *)buf = v43;
  *(_QWORD *)&buf[8] = v44;
  if (v44)
  {
    v45 = (unint64_t *)&v44->__shared_owners_;
    do
      v46 = __ldxr(v45);
    while (__stxr(v46 + 1, v45));
  }
  v47 = (float *)(v7 + 1348);
  v48 = (float *)(v7 + 1352);
  if (sub_18F1EDFCC(v43, "CompassOffsetManualX", (float *)(v7 + 1344)))
  {
    v49 = sub_18F204AE4();
    v50 = *(_QWORD *)(v49 + 24);
    v51 = *(std::__shared_weak_count **)(v49 + 32);
    *(_QWORD *)v148 = v50;
    *(_QWORD *)&v148[8] = v51;
    if (v51)
    {
      v52 = (unint64_t *)&v51->__shared_owners_;
      do
        v53 = __ldxr(v52);
      while (__stxr(v53 + 1, v52));
    }
    if (sub_18F1EDFCC(v50, "CompassOffsetManualY", (float *)(v7 + 1348)))
    {
      v54 = sub_18F204AE4();
      v55 = *(_QWORD *)(v54 + 24);
      v56 = *(std::__shared_weak_count **)(v54 + 32);
      v147[0] = v55;
      v147[1] = v56;
      if (v56)
      {
        v57 = (unint64_t *)&v56->__shared_owners_;
        do
          v58 = __ldxr(v57);
        while (__stxr(v58 + 1, v57));
      }
      v59 = sub_18F1EDFCC(v55, "CompassOffsetManualZ", (float *)(v7 + 1352));
      if (v56)
      {
        v60 = (unint64_t *)&v56->__shared_owners_;
        do
          v61 = __ldaxr(v60);
        while (__stlxr(v61 - 1, v60));
        if (!v61)
        {
          ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
          std::__shared_weak_count::__release_weak(v56);
        }
      }
      v51 = *(std::__shared_weak_count **)&v148[8];
      if (!*(_QWORD *)&v148[8])
      {
LABEL_71:
        v44 = *(std::__shared_weak_count **)&buf[8];
        if (*(_QWORD *)&buf[8])
          goto LABEL_72;
        goto LABEL_76;
      }
    }
    else
    {
      v59 = 0;
      if (!v51)
        goto LABEL_71;
    }
    v64 = (unint64_t *)&v51->__shared_owners_;
    do
      v65 = __ldaxr(v64);
    while (__stlxr(v65 - 1, v64));
    if (!v65)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
    goto LABEL_71;
  }
  v59 = 0;
  if (v44)
  {
LABEL_72:
    v66 = (unint64_t *)&v44->__shared_owners_;
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
LABEL_76:
  if (v59)
  {
    *(_DWORD *)(a1 + 1364) = 1;
    *(_DWORD *)(a1 + 384) = 0;
  }
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953968);
  v68 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v69 = *v42;
    v70 = *v47;
    v71 = *v48;
    *(_DWORD *)buf = 134218496;
    *(double *)&buf[4] = v69;
    *(_WORD *)&buf[12] = 2048;
    *(double *)&buf[14] = v70;
    v152 = 2048;
    v153 = v71;
    _os_log_impl(&dword_18F1DC000, v68, OS_LOG_TYPE_DEBUG, "compass using manual bias (%.3f/%.3f/%.3f)", buf, 0x20u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    v140 = *v42;
    v141 = *v47;
    v142 = *v48;
    *(_DWORD *)v148 = 134218496;
    *(double *)&v148[4] = v140;
    *(_WORD *)&v148[12] = 2048;
    *(double *)&v148[14] = v141;
    v149 = 2048;
    v150 = v142;
    v143 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)", "CoreLocation: %s\n", v143);
    if (v143 != buf)
      free(v143);
  }
LABEL_83:
  v72 = sub_18F204AE4();
  v73 = (_BYTE *)(v7 + 7);
  v74 = *(_QWORD *)(v72 + 24);
  v75 = *(std::__shared_weak_count **)(v72 + 32);
  *(_QWORD *)buf = v74;
  *(_QWORD *)&buf[8] = v75;
  if (v75)
  {
    v76 = (unint64_t *)&v75->__shared_owners_;
    do
      v77 = __ldxr(v76);
    while (__stxr(v77 + 1, v76));
  }
  v78 = sub_18F1EE944(v74, "CompassIgnoreCalibration", (BOOL *)(v7 + 7));
  v79 = v78;
  if (!v75)
    goto LABEL_90;
  v80 = (unint64_t *)&v75->__shared_owners_;
  do
    v81 = __ldaxr(v80);
  while (__stlxr(v81 - 1, v80));
  if (v81)
  {
LABEL_90:
    if ((v78 & 1) != 0)
      goto LABEL_92;
    goto LABEL_91;
  }
  ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
  std::__shared_weak_count::__release_weak(v75);
  if ((v79 & 1) == 0)
LABEL_91:
    *v73 = 0;
LABEL_92:
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953968);
  v82 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v83 = *v73;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v83;
    _os_log_impl(&dword_18F1DC000, v82, OS_LOG_TYPE_DEBUG, "compass ignoring calibration (%d)", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    v129 = *v73;
    *(_DWORD *)v148 = 67109120;
    *(_DWORD *)&v148[4] = v129;
    v130 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)", "CoreLocation: %s\n", v130);
    if (v130 != buf)
      free(v130);
  }
  LODWORD(v147[0]) = 0;
  v84 = sub_18F204AE4();
  v85 = *(_QWORD *)(v84 + 24);
  v86 = *(std::__shared_weak_count **)(v84 + 32);
  *(_QWORD *)buf = v85;
  *(_QWORD *)&buf[8] = v86;
  if (v86)
  {
    v87 = (unint64_t *)&v86->__shared_owners_;
    do
      v88 = __ldxr(v87);
    while (__stxr(v88 + 1, v87));
  }
  v89 = sub_18F1E4DFC(v85, "CompassInputFilter", v147);
  if (v86)
  {
    v90 = (unint64_t *)&v86->__shared_owners_;
    do
      v91 = __ldaxr(v90);
    while (__stlxr(v91 - 1, v90));
    if (!v91)
    {
      ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
      std::__shared_weak_count::__release_weak(v86);
    }
  }
  v92 = LODWORD(v147[0]);
  if (SLODWORD(v147[0]) > 0)
    v93 = v89;
  else
    v93 = 0;
  if (v93 == 1)
  {
    *(_QWORD *)(a1 + 400) = LODWORD(v147[0]);
    *(_QWORD *)(a1 + 416) = v92;
    sub_18F1E6174((_QWORD *)(v7 + 400));
    *(_QWORD *)(a1 + 488) = v92;
    sub_18F1E6174((_QWORD *)(v7 + 472));
    *(_QWORD *)(a1 + 560) = v92;
    sub_18F1E6174((_QWORD *)(v7 + 544));
  }
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953968);
  v94 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v95 = *(_QWORD *)(a1 + 400);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v95;
    _os_log_impl(&dword_18F1DC000, v94, OS_LOG_TYPE_DEBUG, "compass input filter is using (%zuu) samples", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    v131 = *(_QWORD *)(a1 + 400);
    *(_DWORD *)v148 = 134217984;
    *(_QWORD *)&v148[4] = v131;
    v132 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)", "CoreLocation: %s\n", v132);
    if (v132 != buf)
      free(v132);
  }
  v146 = 0;
  LODWORD(v147[0]) = 0;
  v96 = sub_18F204AE4();
  v97 = *(_QWORD *)(v96 + 24);
  v98 = *(std::__shared_weak_count **)(v96 + 32);
  *(_QWORD *)buf = v97;
  *(_QWORD *)&buf[8] = v98;
  if (v98)
  {
    v99 = (unint64_t *)&v98->__shared_owners_;
    do
      v100 = __ldxr(v99);
    while (__stxr(v100 + 1, v99));
  }
  if (!sub_18F1E4DFC(v97, "CompassOutputFilterSize", v147))
  {
    v106 = 0;
    if (!v98)
      goto LABEL_134;
    goto LABEL_130;
  }
  v101 = sub_18F204AE4();
  v102 = *(_QWORD *)(v101 + 24);
  v103 = *(std::__shared_weak_count **)(v101 + 32);
  *(_QWORD *)v148 = v102;
  *(_QWORD *)&v148[8] = v103;
  if (v103)
  {
    v104 = (unint64_t *)&v103->__shared_owners_;
    do
      v105 = __ldxr(v104);
    while (__stxr(v105 + 1, v104));
  }
  v106 = sub_18F1EDFCC(v102, "CompassOutputFilterScale", (float *)&v146);
  if (v103)
  {
    v107 = (unint64_t *)&v103->__shared_owners_;
    do
      v108 = __ldaxr(v107);
    while (__stlxr(v108 - 1, v107));
    if (!v108)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }
  v98 = *(std::__shared_weak_count **)&buf[8];
  if (*(_QWORD *)&buf[8])
  {
LABEL_130:
    v109 = (unint64_t *)&v98->__shared_owners_;
    do
      v110 = __ldaxr(v109);
    while (__stlxr(v110 - 1, v109));
    if (!v110)
    {
      ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
      std::__shared_weak_count::__release_weak(v98);
    }
  }
LABEL_134:
  v111 = v147[0];
  if (SLODWORD(v147[0]) > 0)
    v112 = v106;
  else
    v112 = 0;
  if (v112 == 1)
  {
    v113 = v146;
    *(_DWORD *)(a1 + 624) = v147[0];
    *(_DWORD *)(a1 + 628) = v113;
    __asm { FMOV            V0.2S, #-1.0 }
    *(_QWORD *)(a1 + 632) = _D0;
    *(_DWORD *)(a1 + 648) = v111;
    *(_DWORD *)(a1 + 736) = v111;
  }
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953968);
  v119 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v120 = *v12;
    v121 = *v144;
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v120;
    *(_WORD *)&buf[8] = 2048;
    *(double *)&buf[10] = v121;
    _os_log_impl(&dword_18F1DC000, v119, OS_LOG_TYPE_DEBUG, "compass heading output filter samples (%d) scale (%f)", buf, 0x12u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    v133 = *v12;
    v134 = *v144;
    *(_DWORD *)v148 = 67109376;
    *(_DWORD *)&v148[4] = v133;
    *(_WORD *)&v148[8] = 2048;
    *(double *)&v148[10] = v134;
    v135 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)", "CoreLocation: %s\n", v135);
    if (v135 != buf)
      free(v135);
  }
  *(_DWORD *)buf = 1097859072;
  v122 = vcvtd_n_u64_f64(*(float *)v7, 2uLL);
  *(_DWORD *)v148 = 1061158912;
  sub_18F437B04(v7 + 1640, (_DWORD *)v7, (_DWORD *)v7, buf, 0xAu, 0xAu, v122, v148, 1);
  *(_DWORD *)buf = 1098907648;
  v123 = vcvtd_n_u64_f64(*(float *)v7, 2uLL);
  *(_DWORD *)v148 = 1067450368;
  sub_18F437B04(v7 + 1968, (_DWORD *)v7, (_DWORD *)v7, buf, 0xAu, 0xAu, v123, v148, 1);
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953968);
  v124 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    v125 = *(float *)v7;
    v126 = *v145;
    *(_DWORD *)buf = 134218240;
    *(double *)&buf[4] = v125;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v126;
    _os_log_impl(&dword_18F1DC000, v124, OS_LOG_TYPE_INFO, "apple compass calculator, sample rate (%.3f) ignoreDatabase (1) manual (%d)", buf, 0x12u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    v136 = *(float *)v7;
    v137 = *v145;
    *(_DWORD *)v148 = 134218240;
    *(double *)&v148[4] = v136;
    *(_WORD *)&v148[12] = 1024;
    *(_DWORD *)&v148[14] = v137;
    v138 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, BOOL, BOOL)", "CoreLocation: %s\n", v138);
    if (v138 != buf)
      free(v138);
  }
  return a1;
}

void sub_18F43BFC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _QWORD *a16, _QWORD *a17)
{
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;

  v17[289] = &off_1E294AC98;
  sub_18F3CBA50(v17 + 292);
  sub_18F437AAC(a16);
  sub_18F437AAC(a17);
  v17[197] = &off_1E294AC98;
  sub_18F3CBA50(v17 + 200);
  v17[188] = &off_1E294AC98;
  sub_18F3CBA50(v17 + 191);
  v17[179] = &off_1E294AC98;
  sub_18F3CBA50(v17 + 182);
  sub_18F1EB0F0((_QWORD *)(v18 + 1040));
  sub_18F1EB0F0((_QWORD *)(v18 + 808));
  sub_18F43E2A0(v21);
  sub_18F1EB0F0(v20);
  sub_18F438818(v19);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F43C140(_QWORD *a1)
{
  uint64_t v2;

  v2 = a1[13];
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    a1[13] = 0;
  }
  a1[289] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 292);
  sub_18F437AAC(a1 + 247);
  sub_18F437AAC(a1 + 206);
  a1[197] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 200);
  a1[188] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 191);
  a1[179] = &off_1E294AC98;
  sub_18F3CBA50(a1 + 182);
  sub_18F1EB0F0(a1 + 131);
  sub_18F1EB0F0(a1 + 102);
  sub_18F43E2A0((uint64_t)(a1 + 78));
  sub_18F1EB0F0(a1 + 49);
  sub_18F438818(a1 + 14);
  return a1;
}

BOOL sub_18F43C1E8(float32x2_t *a1, uint64_t *a2)
{
  __int32 v3;
  unint64_t v4;
  float v5;
  float v6;
  unint64_t v7;
  unint64_t v8;
  float v9;
  __n128 v10;
  unint64_t v11;
  float v12;
  float32x2_t v13;
  float v14;
  float32x2_t v15;
  float32x2_t *v16;
  float v17;
  NSObject *v19;
  unint64_t v20;
  double v21;
  double v22;
  double v23;
  unint64_t v24;
  int v25;
  NSObject *v26;
  double v27;
  float v28;
  float v30;
  NSObject *v31;
  unint64_t v32;
  double v33;
  double v34;
  double v35;
  unint64_t v36;
  double v37;
  char *v38;
  double v39;
  double v40;
  unint64_t v41;
  double v42;
  unint64_t v43;
  char *v44;
  double v45;
  double v46;
  unint64_t v47;
  double v48;
  unint64_t v49;
  char *v50;
  uint64_t (**v51)();
  uint64_t v52;
  int v53;
  float v54;
  double v55;
  __int16 v56;
  double v57;
  __int16 v58;
  double v59;
  _BYTE buf[12];
  __int16 v61;
  double v62;
  __int16 v63;
  double v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v51 = &off_1E2949650;
  v52 = *a2;
  v53 = *((_DWORD *)a2 + 2);
  v3 = a1[48].i32[0];
  if (v3)
  {
    a1[48].i32[0] = v3 - 1;
    if (v3 == 1)
      a1[47].i32[0] = 0;
    return v3 == 0;
  }
  sub_18F1FD65C((uint64_t)&a1[51], (float *)&v52);
  sub_18F1FD65C((uint64_t)&a1[60], (float *)&v52 + 1);
  sub_18F1FD65C((uint64_t)&a1[69], (float *)&v53);
  v4 = (unint64_t)a1[59];
  v5 = 0.0;
  v6 = 0.0;
  if (v4)
    v6 = a1[53].f32[0] / (float)v4;
  v7 = (unint64_t)a1[68];
  if (v7)
    v5 = a1[62].f32[0] / (float)v7;
  v8 = (unint64_t)a1[77];
  if (v8)
    v9 = a1[71].f32[0] / (float)v8;
  else
    v9 = 0.0;
  a1[161].f32[0] = v6;
  a1[161].f32[1] = v5;
  a1[162].f32[0] = v9;
  a1[164].f32[0] = v6;
  a1[164].f32[1] = v5;
  a1[165].f32[0] = v9;
  a1[167].f32[0] = v6;
  a1[167].f32[1] = v5;
  a1[168].f32[0] = v9;
  if (a1[1].i8[5])
  {
    *(_DWORD *)buf = sqrtf((float)((float)(a1[7].f32[1] * a1[7].f32[1]) + (float)(a1[7].f32[0] * a1[7].f32[0]))+ (float)(a1[8].f32[0] * a1[8].f32[0]));
    sub_18F1FD65C((uint64_t)&a1[197], (float *)buf);
    v10.n128_f32[0] = sub_18F1FD65C((uint64_t)&a1[289], (float *)buf);
  }
  else
  {
    *(_DWORD *)buf = sqrtf((float)((float)(a1[10].f32[1] * a1[10].f32[1]) + (float)(a1[10].f32[0] * a1[10].f32[0]))+ (float)(a1[11].f32[0] * a1[11].f32[0]));
    sub_18F1FD65C((uint64_t)&a1[179], (float *)buf);
    v11 = (unint64_t)a1[187];
    if (v11)
      v12 = a1[181].f32[0] / (float)v11;
    else
      v12 = 0.0;
    v54 = (float)(*(float *)buf - v12) * (float)(*(float *)buf - v12);
    v10.n128_f32[0] = sub_18F1FD65C((uint64_t)&a1[188], &v54);
  }
  if (a1[1].i8[6])
  {
    v13 = a1[169];
    a1[161] = vsub_f32(a1[161], v13);
    v14 = a1[170].f32[0];
    a1[162].f32[0] = a1[162].f32[0] - v14;
    a1[164] = vsub_f32(a1[164], v13);
    a1[165].f32[0] = a1[165].f32[0] - v14;
    return v3 == 0;
  }
  v16 = a1 + 13;
  v15 = a1[13];
  *(_QWORD *)buf = 0xBFF0000000000000;
  (*(void (**)(float32x2_t, uint64_t (***)(), float32x2_t *, _BYTE *, __n128))(**(_QWORD **)&v15
                                                                                                  + 32))(v15, &v51, a1 + 2, buf, v10);
  ++a1[47].i32[0];
  (*(void (**)(float32x2_t, float32x2_t *, uint64_t))(**(_QWORD **)v16 + 48))(*v16, a1 + 169, (uint64_t)&a1[170] + 4);
  (*(void (**)(float32x2_t, float32x2_t *, float32x2_t *, float32x2_t *))(**(_QWORD **)v16 + 56))(*v16, a1 + 160, a1 + 163, a1 + 2);
  (*(void (**)(float32x2_t, float32x2_t *, float32x2_t *))(**(_QWORD **)v16 + 64))(*v16, a1 + 166, a1 + 2);
  if (!(*(unsigned int (**)(float32x2_t))(**(_QWORD **)v16 + 72))(*v16))
    goto LABEL_49;
  if (a1[1].i8[5] && a1[170].i32[1] < 4)
  {
    v17 = sqrtf((float)((float)(a1[161].f32[1] * a1[161].f32[1]) + (float)(a1[161].f32[0] * a1[161].f32[0]))+ (float)(a1[162].f32[0] * a1[162].f32[0]));
    if (v17 > 500.0)
    {
LABEL_40:
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953968);
      v26 = qword_1EE16D690;
      if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
      {
        v27 = sqrtf((float)((float)(a1[161].f32[1] * a1[161].f32[1]) + (float)(a1[161].f32[0] * a1[161].f32[0]))+ (float)(a1[162].f32[0] * a1[162].f32[0]));
        *(_DWORD *)buf = 134217984;
        *(double *)&buf[4] = v27;
        _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_INFO, "magnitude max threshold exceeded (%+.3f), resetting calibration", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D698 != -1)
          dispatch_once(&qword_1EE16D698, &unk_1E2953968);
        v37 = sqrtf((float)((float)(a1[161].f32[1] * a1[161].f32[1]) + (float)(a1[161].f32[0] * a1[161].f32[0]))+ (float)(a1[162].f32[0] * a1[162].f32[0]));
        v54 = 3.852e-34;
        v55 = v37;
        v38 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLCompassCalculator::updateInterferenceChecks()", "CoreLocation: %s\n", v38);
        if (v38 != buf)
          free(v38);
      }
      (*(void (**)(_QWORD))(**(_QWORD **)&a1[13] + 24))(*(_QWORD *)&a1[13]);
      a1[48].i32[0] = a1[47].i32[1];
      v25 = -1065353216;
LABEL_46:
      a1[14].i32[0] = v25;
      goto LABEL_49;
    }
LABEL_47:
    *(float *)buf = v17;
    sub_18F437DE0((uint64_t)&a1[206], (float *)buf);
    if (sub_18F43D97C((uint64_t)a1))
    {
      v28 = sub_18F42B158((float *)&a1[160], (float *)&a1[9]) * -57.2957795 + 90.0;
      *(float *)buf = v28;
      sub_18F437DE0((uint64_t)&a1[247], (float *)buf);
    }
    goto LABEL_49;
  }
  v17 = sqrtf((float)((float)(a1[161].f32[1] * a1[161].f32[1]) + (float)(a1[161].f32[0] * a1[161].f32[0]))+ (float)(a1[162].f32[0] * a1[162].f32[0]));
  if (v17 >= 250.0 || v17 > 500.0)
    goto LABEL_40;
  if (a1[1].i8[5])
    goto LABEL_47;
  *(float *)buf = v17;
  if (sub_18F437DE0((uint64_t)&a1[206], (float *)buf))
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953968);
    v19 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      v20 = (unint64_t)a1[225];
      v21 = 0.0;
      v22 = 0.0;
      if (v20)
        v22 = (float)(a1[219].f32[0] / (float)v20);
      v23 = a1[207].f32[1];
      v24 = (unint64_t)a1[246];
      if (v24)
        v21 = (float)(a1[240].f32[0] / (float)v24);
      *(_DWORD *)buf = 134218496;
      *(double *)&buf[4] = v23;
      v61 = 2048;
      v62 = v22;
      v63 = 2048;
      v64 = v21;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_INFO, "magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration", buf, 0x20u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953968);
      v39 = 0.0;
      v40 = 0.0;
      v41 = (unint64_t)a1[225];
      if (v41)
        v40 = (float)(a1[219].f32[0] / (float)v41);
      v42 = a1[207].f32[1];
      v43 = (unint64_t)a1[246];
      if (v43)
        v39 = (float)(a1[240].f32[0] / (float)v43);
      v54 = 3.8522e-34;
      v55 = v42;
      v56 = 2048;
      v57 = v40;
      v58 = 2048;
      v59 = v39;
      v44 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLCompassCalculator::updateInterferenceChecks()", "CoreLocation: %s\n", v44);
      if (v44 != buf)
        free(v44);
    }
    (*(void (**)(_QWORD))(**(_QWORD **)&a1[13] + 24))(*(_QWORD *)&a1[13]);
    a1[48].i32[0] = a1[47].i32[1];
    v25 = -1073741824;
    goto LABEL_46;
  }
  if (sub_18F43D97C((uint64_t)a1))
  {
    v30 = sub_18F42B158((float *)&a1[160], (float *)&a1[9]) * -57.2957795 + 90.0;
    *(float *)buf = v30;
    if (sub_18F437DE0((uint64_t)&a1[247], (float *)buf))
    {
      if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)&a1[13] + 80))(*(_QWORD *)&a1[13]))
      {
        if (qword_1EE16D698 != -1)
          dispatch_once(&qword_1EE16D698, &unk_1E2953968);
        v31 = qword_1EE16D690;
        if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
        {
          v32 = (unint64_t)a1[266];
          v33 = 0.0;
          v34 = 0.0;
          if (v32)
            v34 = (float)(a1[260].f32[0] / (float)v32);
          v35 = a1[248].f32[1];
          v36 = (unint64_t)a1[287];
          if (v36)
            v33 = (float)(a1[281].f32[0] / (float)v36);
          *(_DWORD *)buf = 134218496;
          *(double *)&buf[4] = v35;
          v61 = 2048;
          v62 = v34;
          v63 = 2048;
          v64 = v33;
          _os_log_impl(&dword_18F1DC000, v31, OS_LOG_TYPE_INFO, "inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration", buf, 0x20u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2953968);
          v45 = 0.0;
          v46 = 0.0;
          v47 = (unint64_t)a1[266];
          if (v47)
            v46 = (float)(a1[260].f32[0] / (float)v47);
          v48 = a1[248].f32[1];
          v49 = (unint64_t)a1[287];
          if (v49)
            v45 = (float)(a1[281].f32[0] / (float)v49);
          v54 = 3.8522e-34;
          v55 = v48;
          v56 = 2048;
          v57 = v46;
          v58 = 2048;
          v59 = v45;
          v50 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLCompassCalculator::updateInterferenceChecks()", "CoreLocation: %s\n", v50);
          if (v50 != buf)
            free(v50);
        }
        (*(void (**)(_QWORD))(**(_QWORD **)&a1[13] + 24))(*(_QWORD *)&a1[13]);
        a1[48].i32[0] = a1[47].i32[1];
        v25 = -1069547520;
        goto LABEL_46;
      }
    }
  }
LABEL_49:
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)&a1[13] + 88))(*(_QWORD *)&a1[13]))
  {
    sub_18F438204((uint64_t)&a1[206], 0);
    sub_18F438204((uint64_t)&a1[247], 0);
  }
  return v3 == 0;
}

float sub_18F43CBE8(uint64_t a1, double *a2)
{
  _OWORD *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  float result;

  v3 = (_OWORD *)(a1 + 1368);
  if (a2[7] == -1.0)
  {
    *(_QWORD *)(a1 + 1416) = 0;
    *(_OWORD *)(a1 + 1384) = 0u;
    *(_OWORD *)(a1 + 1400) = 0u;
    *v3 = 0u;
    *(_QWORD *)(a1 + 1424) = 0xBFF0000000000000;
    *(_BYTE *)(a1 + 116) = 0;
    sub_18F1E6174((_QWORD *)(a1 + 136));
    return sub_18F438BC8(a1 + 208);
  }
  else
  {
    v4 = *(_OWORD *)a2;
    v5 = *((_OWORD *)a2 + 1);
    v6 = *((_OWORD *)a2 + 3);
    *(_OWORD *)(a1 + 1400) = *((_OWORD *)a2 + 2);
    *(_OWORD *)(a1 + 1416) = v6;
    *v3 = v4;
    *(_OWORD *)(a1 + 1384) = v5;
    *(_BYTE *)(a1 + 116) = 1;
    *(float *)&v4 = a2[6];
    sub_18F43886C(a1 + 112, 10, 30, *(float *)&v4, 2.0);
  }
  return result;
}

BOOL sub_18F43CC7C(float *a1, float *a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16)
{
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  _BOOL8 v23;
  float32x4_t v25;
  _BYTE v26[36];
  _QWORD v27[2];

  v27[1] = *MEMORY[0x1E0C80C00];
  v17 = a1[2];
  v18 = a1[3];
  v19 = a1[4];
  v20 = a2[2];
  v21 = a2[3];
  v22 = a2[4];
  v27[0] = 0x3F8000003F800000;
  v25.i64[0] = 0;
  v25.i64[1] = 0x3F80000000000000;
  v23 = sub_18F3D3C08((float *)v27, &v25, (uint64_t)v26, v17, v18, v19, v20, v21, v22, a15, a16, a4, a5, a6, a7, a8, 0x3F800000uLL, 0.0);
  if (v23)
    *a3 = sub_18F3D4D58(v25.f32);
  return v23;
}

BOOL sub_18F43CD20(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  double v18;
  _BOOL4 v19;
  float v20;
  _BOOL4 v21;
  _BOOL8 v22;
  __int128 v23;
  float v24;
  float v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  float v40;
  float v41;
  float v42;
  __float2 v43;
  float v44;
  float v45;
  float v46;
  float v47;
  unint64_t v48;
  float v49;
  float v50;
  float v51;
  unint64_t v52;
  float v53;
  float v54;
  float v55;
  double v56;
  float v57;
  float v58;
  float v59;
  NSObject *v60;
  float v61;
  double v62;
  float v63;
  double v64;
  double v65;
  double v66;
  double v67;
  float v68;
  double v69;
  float v70;
  float v71;
  float v72;
  double v73;
  double v74;
  NSObject *v75;
  double v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  double v82;
  double v83;
  float v84;
  int v85;
  float v86;
  double v88;
  double v89;
  char *v90;
  double v91;
  char *v92;
  float v93;
  double v94;
  float v95;
  float v96;
  float v97;
  float v98;
  uint64_t (**v99)();
  double v100;
  int v101;
  float v102;
  float sinval;
  double v104;
  __int16 v105;
  double v106;
  __int16 v107;
  double v108;
  __int16 v109;
  double v110;
  __int16 v111;
  double v112;
  __int16 v113;
  double v114;
  __int16 v115;
  double v116;
  __int16 v117;
  double v118;
  __int16 v119;
  double v120;
  __int16 v121;
  double v122;
  __int16 v123;
  double v124;
  __int16 v125;
  double v126;
  uint8_t buf[4];
  double v128;
  __int16 v129;
  double v130;
  __int16 v131;
  double v132;
  __int16 v133;
  double v134;
  __int16 v135;
  double v136;
  __int16 v137;
  double v138;
  __int16 v139;
  double v140;
  __int16 v141;
  double v142;
  __int16 v143;
  double v144;
  __int16 v145;
  double v146;
  __int16 v147;
  double v148;
  __int16 v149;
  double v150;
  uint64_t v151;

  v151 = *MEMORY[0x1E0C80C00];
  v102 = 0.0;
  v99 = &off_1E2949650;
  v18 = *(double *)(a1 + 1312);
  v100 = v18;
  LODWORD(v18) = *(_DWORD *)(a1 + 1320);
  v101 = LODWORD(v18);
  if (*(_BYTE *)(a1 + 13))
  {
    v18 = *(double *)(a1 + 1336);
    v100 = v18;
    LODWORD(v18) = *(_DWORD *)(a1 + 1344);
    v101 = LODWORD(v18);
  }
  v19 = sub_18F43CC7C((float *)&v99, (float *)(a1 + 72), &v102, a12, a13, a14, a15, a16, v18, a4, a5, a6, a7, a8, a9, a10);
  v20 = v102;
  v21 = v102 < 360.0 && v19;
  v22 = v102 >= 0.0 && v21;
  if (v22)
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 1288);
    *(_QWORD *)&v23 = *(_QWORD *)(a1 + 1292);
    *((_QWORD *)&v23 + 1) = *(_QWORD *)(a1 + 1312);
    *(_OWORD *)(a2 + 4) = v23;
    LODWORD(v23) = *(_DWORD *)(a1 + 1320);
    *(_DWORD *)(a2 + 20) = v23;
    *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 1364);
    *(float *)(a2 + 44) = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)(&v23 + 8), *(float32x2_t *)(&v23 + 8)).i32[1]), *((float *)&v23 + 2), *((float *)&v23 + 2))+ (float)(*(float *)&v23 * *(float *)&v23));
    *(_BYTE *)(a2 + 40) = 0;
    v24 = sub_18F42B158((float *)(a1 + 1304), (float *)(a1 + 72)) * -57.2957795 + 90.0;
    *(float *)(a2 + 48) = v24;
    v25 = *(float *)(a2 + 44);
    v26 = v24 * 0.0174532925;
    *(float *)(a2 + 52) = v25 * cosf(v26);
    *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 40);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 16);
    v39 = *(double *)(a1 + 32);
    *(double *)(a2 + 80) = v39;
    if (*(_BYTE *)(a1 + 13))
    {
      v98 = v20;
      sub_18F43CC7C((float *)(a1 + 1280), (float *)(a1 + 72), &v98, v27, v28, v29, v30, v31, v39, v32, v33, v34, v35, v36, v37, v38);
      v40 = v98;
      if (*(_BYTE *)(a1 + 2304))
      {
        v41 = *(float *)(a1 + 2384);
      }
      else
      {
        *(_BYTE *)(a1 + 2304) = 1;
        v41 = v40;
      }
      v45 = v41 - v20;
      v46 = v20;
      if (vabds_f32(v41, v20) > 270.0)
        v46 = dbl_18F5086C0[v45 > 0.0] + v20;
      v47 = v40;
      if (vabds_f32(v41, v40) > 270.0)
        v47 = dbl_18F5086C0[(float)(v41 - v40) > 0.0] + v40;
      v48 = *(_QWORD *)(a1 + 2376);
      v49 = 0.0;
      v50 = 0.0;
      if (v48 >= 2)
      {
        v51 = (float)((float)v48 * *(float *)(a1 + 2332)) - (float)(*(float *)(a1 + 2328) * *(float *)(a1 + 2328));
        v50 = v51 / (float)((v48 - 1) * v48);
        if (v51 < 0.0)
          v50 = 0.0;
      }
      v52 = *(_QWORD *)(a1 + 1640);
      if (v52)
        v49 = *(float *)(a1 + 1592) / (float)v52;
      v96 = v41 - v40;
      v53 = (float)(v49 + -0.06) * 0.55 / 2.94000006 + 0.1;
      v54 = fmaxf(fminf(v53, 0.65), 0.1);
      v95 = v50;
      v97 = v47;
      v94 = v49;
      if (v50 >= 0.0015 || v49 >= 6.28318531)
      {
        v55 = *(float *)(a1 + 2388) * 0.15 + 0.734964973;
        *(float *)(a1 + 2388) = v55;
      }
      else
      {
        v93 = v46;
        v55 = 1.0 - expf(v49 * -0.2);
        *(float *)(a1 + 2388) = v55;
        if (v49 <= 1.0)
        {
          v45 = v41 - v20;
          v47 = v97;
          v46 = v93;
          if (v49 < 0.06)
          {
            *(_DWORD *)(a1 + 2388) = 1011052224;
            v55 = 0.011928;
          }
        }
        else
        {
          v55 = 1.0 - expf(v49 * (float)(v49 * -0.2));
          *(float *)(a1 + 2388) = v55;
          v45 = v41 - v20;
          v47 = v97;
          v46 = v93;
        }
      }
      v56 = v46;
      v57 = (float)(v47 * v54) + (1.0 - v54) * v46;
      v58 = (float)(v55 * v57) + (float)((float)(1.0 - v55) * v41);
      if (v58 >= 0.0)
      {
        for (; v58 >= 360.0; v58 = v58 + -360.0)
          ;
      }
      else
      {
        for (; v58 < -360.0; v58 = v58 + 360.0)
          ;
        v58 = v58 + 360.0;
      }
      *(float *)(a1 + 2384) = v58;
      if (*(_BYTE *)(a1 + 12))
      {
        if (qword_1EE16D698 != -1)
          dispatch_once(&qword_1EE16D698, &unk_1E2953968);
        v59 = v58 - v41;
        v60 = qword_1EE16D690;
        if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
        {
          v61 = *(float *)(a1 + 2388);
          v62 = *(float *)(a1 + 2384);
          *(_DWORD *)buf = 134220800;
          v128 = v20;
          v129 = 2048;
          v130 = v40;
          v131 = 2048;
          v132 = v45;
          v133 = 2048;
          v134 = v96;
          v135 = 2048;
          v136 = v56;
          v137 = 2048;
          v138 = v97;
          v139 = 2048;
          v140 = v62;
          v141 = 2048;
          v142 = v61;
          v143 = 2048;
          v144 = v54;
          v145 = 2048;
          v146 = v95;
          v147 = 2048;
          v148 = v94;
          v149 = 2048;
          v150 = v59;
          _os_log_impl(&dword_18F1DC000, v60, OS_LOG_TYPE_DEBUG, "rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroHeadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, deltaFiltered, %.3f", buf, 0x7Au);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2953968);
          v88 = *(float *)(a1 + 2384);
          v89 = *(float *)(a1 + 2388);
          sinval = 3.8533e-34;
          v104 = v20;
          v105 = 2048;
          v106 = v40;
          v107 = 2048;
          v108 = v45;
          v109 = 2048;
          v110 = v96;
          v111 = 2048;
          v112 = v56;
          v113 = 2048;
          v114 = v97;
          v115 = 2048;
          v116 = v88;
          v117 = 2048;
          v118 = v89;
          v119 = 2048;
          v120 = v54;
          v121 = 2048;
          v122 = v95;
          v123 = 2048;
          v124 = v94;
          v125 = 2048;
          v126 = v59;
          v90 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "BOOL CLCompassCalculator::getCompassData(CLMotionTypeCompass &)", "CoreLocation: %s\n", v90);
          if (v90 != (char *)buf)
            free(v90);
        }
      }
      v44 = *(float *)(a1 + 2384);
LABEL_73:
      if ((v44 >= 360.0 || v44 < 0.0) && *(_BYTE *)(a1 + 12))
      {
        if (qword_1EE16D698 != -1)
          dispatch_once(&qword_1EE16D698, &unk_1E2953968);
        v75 = qword_1EE16D690;
        if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
        {
          v76 = *(float *)(a1 + 2384);
          *(_DWORD *)buf = 134217984;
          v128 = v76;
          _os_log_impl(&dword_18F1DC000, v75, OS_LOG_TYPE_INFO, "#Warning Heading  %.2f, is not in bound [0 360]", buf, 0xCu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2953968);
          v91 = *(float *)(a1 + 2384);
          sinval = 3.852e-34;
          v104 = v91;
          v92 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "BOOL CLCompassCalculator::getCompassData(CLMotionTypeCompass &)", "CoreLocation: %s\n", v92);
          if (v92 != (char *)buf)
            free(v92);
        }
      }
      if (sub_18F43D97C(a1)
        && (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 72))(*(_QWORD *)(a1 + 104)) & 1) != 0
         || *(_BYTE *)(a1 + 15)))
      {
        v77 = sub_18F42B158((float *)(a1 + 1280), (float *)(a1 + 72)) * -57.2957795 + 90.0;
        v78 = sqrtf((float)((float)(*(float *)(a1 + 1292) * *(float *)(a1 + 1292))+ (float)(*(float *)(a1 + 1288) * *(float *)(a1 + 1288)))+ (float)(*(float *)(a1 + 1296) * *(float *)(a1 + 1296)));
        v79 = v77 * 3.14159265 / 180.0;
        v80 = cosf(v79);
        sub_18F438A9C(a1 + 112, v77, v78 * v80);
      }
      v81 = *(float *)(a1 + 2384);
      *(float *)(a2 + 24) = v81;
      if (*(double *)(a1 + 1424) == -1.0)
      {
        v84 = -1.0;
LABEL_93:
        *(float *)(a2 + 28) = v84;
        v85 = *(_DWORD *)(a1 + 1364);
        if (v85 || !*(_BYTE *)(a1 + 15))
        {
          v86 = 20.0;
          if (*(_BYTE *)(a1 + 14))
          {
LABEL_99:
            *(float *)(a2 + 32) = v86;
            if (*(_BYTE *)(a1 + 13) && *(_BYTE *)(*(_QWORD *)(a1 + 104) + 184))
              *(float *)(a2 + 32) = v86 + 1.0;
            return v22;
          }
        }
        else
        {
          v85 = 1;
        }
        v86 = sub_18F438C48(a1 + 112, v85);
        goto LABEL_99;
      }
      v82 = *(double *)(a1 + 1408) + v81;
      v83 = 360.0;
      if (v82 >= 360.0)
      {
        v83 = -360.0;
      }
      else if (v82 >= 0.0)
      {
        goto LABEL_92;
      }
      v82 = v82 + v83;
LABEL_92:
      v84 = v82;
      goto LABEL_93;
    }
    v42 = v20 * 0.0174532925;
    v43 = __sincosf_stret(v42);
    *(float *)buf = v43.__cosval;
    sinval = v43.__sinval;
    sub_18F43DB98(a1 + 640, (float *)buf);
    sub_18F43DB98(a1 + 728, &sinval);
    sub_18F43E2F8(a1 + 640, (float *)buf);
    sub_18F43E2F8(a1 + 728, &sinval);
    v44 = atan2f(sinval, *(float *)buf) * 57.2957795;
    if (v44 >= 0.0)
    {
      for (; v44 >= 360.0; v44 = v44 + -360.0)
        ;
    }
    else
    {
      for (; v44 < -360.0; v44 = v44 + 360.0)
        ;
      v44 = v44 + 360.0;
    }
    *(float *)(a1 + 632) = v44;
    v63 = *(float *)(a1 + 636);
    if (v63 == -1.0)
    {
LABEL_72:
      *(float *)(a1 + 636) = v44;
      *(float *)(a1 + 2384) = v44;
      goto LABEL_73;
    }
    v64 = v63;
    v65 = v44;
    v66 = vabdd_f64(v44, v63);
    if (v66 > 180.0)
    {
      if (v44 >= 180.0)
        v65 = 360.0 - v65;
      v67 = 360.0 - v64;
      if (v63 < 180.0)
        v67 = v63;
      v66 = v65 + v67;
    }
    v68 = v66;
    v69 = v68;
    v70 = (cos(v68 * 0.0174532925) + 1.0) * *(float *)(a1 + 628);
    v71 = (1.2 - v70) * 0.75 * v69;
    v72 = v44 - v63;
    if ((float)(v44 - v63) >= 0.0)
    {
      for (; v72 >= 360.0; v72 = v72 + -360.0)
        ;
    }
    else
    {
      for (; v72 < -360.0; v72 = v72 + 360.0)
        ;
      v72 = v72 + 360.0;
    }
    if (v72 >= 180.0)
      v72 = v72 + -360.0;
    if (v72 < 0.0)
      v71 = -v71;
    v73 = v64 + (float)(v71 + 0.0);
    v74 = 360.0;
    if (v73 >= 360.0)
    {
      v74 = -360.0;
    }
    else if (v73 >= 0.0)
    {
      goto LABEL_71;
    }
    v73 = v73 + v74;
LABEL_71:
    v44 = v73;
    *(float *)(a1 + 632) = v44;
    goto LABEL_72;
  }
  return v22;
}

BOOL sub_18F43D97C(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  float v3;
  float v4;
  unint64_t v5;
  float v6;

  v1 = *(unsigned __int8 *)(a1 + 13);
  if (*(_BYTE *)(a1 + 13))
  {
    if (sqrtf((float)((float)(*(float *)(a1 + 60) * *(float *)(a1 + 60))+ (float)(*(float *)(a1 + 56) * *(float *)(a1 + 56)))+ (float)(*(float *)(a1 + 64) * *(float *)(a1 + 64))) > 4.71238911)return 0;
    v2 = *(_QWORD *)(a1 + 1640);
    if (v2)
    {
      v3 = *(float *)(a1 + 1592);
      if ((float)(v3 / (float)v2) > 3.1416)
        return 0;
      if (v2 >= 2)
      {
        v6 = (float)((float)v2 * *(float *)(a1 + 1596)) - (float)(v3 * v3);
        if (v6 >= 0.0)
          return (float)(v6 / (float)((v2 - 1) * v2)) <= 0.64;
      }
    }
    return 1;
  }
  v4 = sqrtf((float)((float)(*(float *)(a1 + 84) * *(float *)(a1 + 84)) + (float)(*(float *)(a1 + 80) * *(float *)(a1 + 80)))+ (float)(*(float *)(a1 + 88) * *(float *)(a1 + 88)));
  if (v4 < 1.2 && v4 > 0.8)
  {
    v5 = *(_QWORD *)(a1 + 1568);
    if (v5)
      return (float)(*(float *)(a1 + 1520) / (float)v5) < 0.09;
    return 1;
  }
  return v1;
}

uint64_t sub_18F43DA88(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E2949B58;
  sub_18F3BEA38(a1 + 64, *(_QWORD **)(a1 + 72));
  sub_18F43E1DC(a1 + 16);
  return a1;
}

void sub_18F43DAC4(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E2949B58;
  sub_18F3BEA38(a1 + 64, *(_QWORD **)(a1 + 72));
  sub_18F43E1DC(a1 + 16);
  JUMPOUT(0x194001438);
}

void sub_18F43DB10(_QWORD *a1)
{
  void **v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;

  v2 = (void **)a1[3];
  v3 = a1[4];
  a1[7] = 0;
  v4 = v3 - (_QWORD)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v5 = a1[4];
      v2 = (void **)(a1[3] + 8);
      a1[3] = v2;
      v4 = v5 - (_QWORD)v2;
    }
    while (v4 > 0x10);
  }
  if (v4 >> 3 == 1)
  {
    v6 = 256;
    goto LABEL_7;
  }
  if (v4 >> 3 == 2)
  {
    v6 = 512;
LABEL_7:
    a1[6] = v6;
  }
  v8 = (_QWORD *)a1[9];
  v7 = a1 + 9;
  sub_18F3BEA38((uint64_t)(v7 - 1), v8);
  *(v7 - 1) = v7;
  *v7 = 0;
  v7[1] = 0;
}

void sub_18F43DB98(uint64_t a1, float *a2)
{
  float v3;
  float *v4;
  float *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  int64_t v32;
  char *v33;
  uint64_t v34;
  char *v35;
  char *v36;
  void *v37;
  void *v38;
  unint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  BOOL v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  char *v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  void *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t *v65;
  _QWORD *v66;
  _QWORD *v67;
  _QWORD *v68;
  uint64_t *v69;
  int64x2_t v70;
  unint64_t v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t *v75;
  char *v76;
  uint64_t v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  void *v81;
  char *v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  int64_t v93;
  void *v94;
  uint64_t v95;
  unint64_t v96;
  char *v97;
  uint64_t v98;
  char *v99;
  uint64_t i;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  unint64_t v105;
  char *v106;
  uint64_t v107;
  char *v108;
  uint64_t v109;
  uint64_t v110;
  char *v111;
  uint64_t *v112;
  uint64_t v113;
  uint64_t v114;
  void *v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  char *v119;
  uint64_t v120;
  char *v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t v124;
  char *v125;
  uint64_t v126;
  void *v127;

  v3 = *a2;
  v4 = (float *)operator new(0x20uLL);
  v5 = v4;
  v4[7] = v3;
  v6 = (uint64_t **)(a1 + 72);
  v7 = *(uint64_t ***)(a1 + 72);
  if (v7)
  {
    do
    {
      while (1)
      {
        v6 = v7;
        if (*((float *)v7 + 7) <= v3)
          break;
        v7 = (uint64_t **)*v7;
        v8 = v6;
        if (!*v6)
          goto LABEL_8;
      }
      v7 = (uint64_t **)v7[1];
    }
    while (v7);
    v8 = v6 + 1;
  }
  else
  {
    v8 = (uint64_t **)(a1 + 72);
  }
LABEL_8:
  *(_QWORD *)v4 = 0;
  *((_QWORD *)v4 + 1) = 0;
  *((_QWORD *)v4 + 2) = v6;
  *v8 = (uint64_t *)v4;
  v9 = **(_QWORD **)(a1 + 64);
  v10 = (uint64_t *)v4;
  if (v9)
  {
    *(_QWORD *)(a1 + 64) = v9;
    v10 = *v8;
  }
  sub_18F3BE62C(*(uint64_t **)(a1 + 72), v10);
  v11 = *(char **)(a1 + 32);
  v12 = *(char **)(a1 + 24);
  v13 = v11 - v12;
  ++*(_QWORD *)(a1 + 80);
  if (v11 == v12)
    v14 = 0;
  else
    v14 = ((v11 - v12) << 6) - 1;
  v15 = *(_QWORD *)(a1 + 48);
  v16 = *(_QWORD *)(a1 + 56);
  v17 = v16 + v15;
  if (v14 == v16 + v15)
  {
    v18 = v15 >= 0x200;
    v19 = v15 - 512;
    if (v18)
    {
      *(_QWORD *)(a1 + 48) = v19;
      v22 = *(_QWORD *)v12;
      v20 = v12 + 8;
      v21 = v22;
      *(_QWORD *)(a1 + 24) = v20;
      if (v11 == *(char **)(a1 + 40))
      {
        v23 = *(_QWORD *)(a1 + 16);
        v24 = (uint64_t)&v20[-v23];
        if ((unint64_t)v20 <= v23)
        {
          v50 = (uint64_t)&v11[-v23];
          v49 = v50 == 0;
          v51 = v50 >> 2;
          if (v49)
            v52 = 1;
          else
            v52 = v51;
          v53 = (char *)sub_18F340E0C(v52);
          v55 = &v53[8 * (v52 >> 2)];
          v56 = *(uint64_t **)(a1 + 24);
          v11 = v55;
          v57 = *(_QWORD *)(a1 + 32) - (_QWORD)v56;
          if (v57)
          {
            v11 = &v55[v57 & 0xFFFFFFFFFFFFFFF8];
            v58 = 8 * (v57 >> 3);
            v59 = &v53[8 * (v52 >> 2)];
            do
            {
              v60 = *v56++;
              *(_QWORD *)v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          v61 = *(void **)(a1 + 16);
          *(_QWORD *)(a1 + 16) = v53;
          *(_QWORD *)(a1 + 24) = v55;
          *(_QWORD *)(a1 + 32) = v11;
          *(_QWORD *)(a1 + 40) = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            v11 = *(char **)(a1 + 32);
          }
        }
        else
        {
          v25 = v24 >> 3;
          v26 = v24 >> 3 < -1;
          v27 = (v24 >> 3) + 2;
          if (v26)
            v28 = v27;
          else
            v28 = v25 + 1;
          v29 = -(v28 >> 1);
          v30 = v28 >> 1;
          v31 = &v20[-8 * v30];
          v32 = v11 - v20;
          if (v11 != v20)
          {
            memmove(&v20[-8 * v30], v20, v11 - v20);
            v11 = *(char **)(a1 + 24);
          }
          v33 = &v11[8 * v29];
          v11 = &v31[v32];
          *(_QWORD *)(a1 + 24) = v33;
          *(_QWORD *)(a1 + 32) = &v31[v32];
        }
      }
      *(_QWORD *)v11 = v21;
    }
    else
    {
      v34 = v13 >> 3;
      v35 = *(char **)(a1 + 40);
      v36 = *(char **)(a1 + 16);
      if (v13 >> 3 >= (unint64_t)((v35 - v36) >> 3))
      {
        if (v35 == v36)
          v39 = 1;
        else
          v39 = (v35 - v36) >> 2;
        v40 = (char *)sub_18F340E0C(v39);
        v42 = v41;
        v43 = operator new(0x1000uLL);
        v44 = &v40[8 * v34];
        v45 = &v40[8 * v42];
        if (v34 == v42)
        {
          v46 = 8 * v34;
          if (v13 < 1)
          {
            v94 = v43;
            v95 = v46 >> 2;
            if (v11 == v12)
              v96 = 1;
            else
              v96 = v95;
            v97 = (char *)sub_18F340E0C(v96);
            v44 = &v97[8 * (v96 >> 2)];
            v45 = &v97[8 * v98];
            if (v40)
              operator delete(v40);
            v40 = v97;
            v43 = v94;
          }
          else
          {
            v47 = v46 >> 3;
            if (v47 >= -1)
              v48 = v47 + 1;
            else
              v48 = v47 + 2;
            v44 -= 8 * (v48 >> 1);
          }
        }
        *(_QWORD *)v44 = v43;
        v99 = v44 + 8;
        for (i = *(_QWORD *)(a1 + 32); i != *(_QWORD *)(a1 + 24); i -= 8)
        {
          if (v44 == v40)
          {
            if (v99 >= v45)
            {
              if (v45 == v40)
                v105 = 1;
              else
                v105 = (v45 - v40) >> 2;
              v106 = (char *)sub_18F340E0C(v105);
              v108 = v106;
              v44 = &v106[(2 * v105 + 6) & 0xFFFFFFFFFFFFFFF8];
              v109 = v99 - v40;
              v49 = v99 == v40;
              v99 = v44;
              if (!v49)
              {
                v99 = &v44[v109 & 0xFFFFFFFFFFFFFFF8];
                v110 = 8 * (v109 >> 3);
                v111 = v44;
                v112 = (uint64_t *)v40;
                do
                {
                  v113 = *v112++;
                  *(_QWORD *)v111 = v113;
                  v111 += 8;
                  v110 -= 8;
                }
                while (v110);
              }
              v45 = &v106[8 * v107];
              if (v40)
                operator delete(v40);
              v40 = v108;
            }
            else
            {
              v101 = (v45 - v99) >> 3;
              if (v101 >= -1)
                v102 = v101 + 1;
              else
                v102 = v101 + 2;
              v103 = v102 >> 1;
              v44 = &v40[8 * (v102 >> 1)];
              v104 = v40;
              if (v99 != v40)
              {
                memmove(v44, v40, v99 - v40);
                v104 = v99;
              }
              v99 = &v104[8 * v103];
            }
          }
          v114 = *(_QWORD *)(i - 8);
          *((_QWORD *)v44 - 1) = v114;
          v44 -= 8;
        }
        v115 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = v40;
        *(_QWORD *)(a1 + 24) = v44;
        *(_QWORD *)(a1 + 32) = v99;
        *(_QWORD *)(a1 + 40) = v45;
        if (v115)
          operator delete(v115);
        goto LABEL_46;
      }
      v37 = operator new(0x1000uLL);
      v38 = v37;
      if (v35 == v11)
      {
        if (v12 == v36)
        {
          if (v11 == v12)
            v71 = 1;
          else
            v71 = (v35 - v12) >> 2;
          v72 = 2 * v71;
          v73 = (char *)sub_18F340E0C(v71);
          v12 = &v73[(v72 + 6) & 0xFFFFFFFFFFFFFFF8];
          v75 = *(uint64_t **)(a1 + 24);
          v76 = v12;
          v77 = *(_QWORD *)(a1 + 32) - (_QWORD)v75;
          if (v77)
          {
            v76 = &v12[v77 & 0xFFFFFFFFFFFFFFF8];
            v78 = 8 * (v77 >> 3);
            v79 = &v73[(v72 + 6) & 0xFFFFFFFFFFFFFFF8];
            do
            {
              v80 = *v75++;
              *(_QWORD *)v79 = v80;
              v79 += 8;
              v78 -= 8;
            }
            while (v78);
          }
          v81 = *(void **)(a1 + 16);
          *(_QWORD *)(a1 + 16) = v73;
          *(_QWORD *)(a1 + 24) = v12;
          *(_QWORD *)(a1 + 32) = v76;
          *(_QWORD *)(a1 + 40) = &v73[8 * v74];
          if (v81)
          {
            operator delete(v81);
            v12 = *(char **)(a1 + 24);
          }
        }
        *((_QWORD *)v12 - 1) = v38;
        v82 = *(char **)(a1 + 24);
        v83 = *(char **)(a1 + 32);
        *(_QWORD *)(a1 + 24) = v82 - 8;
        v84 = *((_QWORD *)v82 - 1);
        *(_QWORD *)(a1 + 24) = v82;
        if (v83 == *(char **)(a1 + 40))
        {
          v85 = *(_QWORD *)(a1 + 16);
          v86 = (uint64_t)&v82[-v85];
          if ((unint64_t)v82 <= v85)
          {
            v116 = (uint64_t)&v83[-v85];
            v49 = v116 == 0;
            v117 = v116 >> 2;
            if (v49)
              v118 = 1;
            else
              v118 = v117;
            v119 = (char *)sub_18F340E0C(v118);
            v121 = &v119[8 * (v118 >> 2)];
            v122 = *(uint64_t **)(a1 + 24);
            v83 = v121;
            v123 = *(_QWORD *)(a1 + 32) - (_QWORD)v122;
            if (v123)
            {
              v83 = &v121[v123 & 0xFFFFFFFFFFFFFFF8];
              v124 = 8 * (v123 >> 3);
              v125 = &v119[8 * (v118 >> 2)];
              do
              {
                v126 = *v122++;
                *(_QWORD *)v125 = v126;
                v125 += 8;
                v124 -= 8;
              }
              while (v124);
            }
            v127 = *(void **)(a1 + 16);
            *(_QWORD *)(a1 + 16) = v119;
            *(_QWORD *)(a1 + 24) = v121;
            *(_QWORD *)(a1 + 32) = v83;
            *(_QWORD *)(a1 + 40) = &v119[8 * v120];
            if (v127)
            {
              operator delete(v127);
              v83 = *(char **)(a1 + 32);
            }
          }
          else
          {
            v87 = v86 >> 3;
            v26 = v86 >> 3 < -1;
            v88 = (v86 >> 3) + 2;
            if (v26)
              v89 = v88;
            else
              v89 = v87 + 1;
            v90 = -(v89 >> 1);
            v91 = v89 >> 1;
            v92 = &v82[-8 * v91];
            v93 = v83 - v82;
            if (v83 != v82)
            {
              memmove(&v82[-8 * v91], v82, v83 - v82);
              v82 = *(char **)(a1 + 24);
            }
            v83 = &v92[v93];
            *(_QWORD *)(a1 + 24) = &v82[8 * v90];
            *(_QWORD *)(a1 + 32) = &v92[v93];
          }
        }
        *(_QWORD *)v83 = v84;
      }
      else
      {
        *(_QWORD *)v11 = v37;
      }
    }
    *(_QWORD *)(a1 + 32) += 8;
LABEL_46:
    v12 = *(char **)(a1 + 24);
    v15 = *(_QWORD *)(a1 + 48);
    v16 = *(_QWORD *)(a1 + 56);
    v17 = v15 + v16;
  }
  *(_QWORD *)(*(_QWORD *)&v12[(v17 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v17 & 0x1FF)) = v5;
  v62 = v16 + 1;
  *(_QWORD *)(a1 + 56) = v62;
  if (v62 > *(unsigned int *)(a1 + 8))
  {
    v63 = (v15 >> 6) & 0x3FFFFFFFFFFFFF8;
    v64 = v15 & 0x1FF;
    v65 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + v63) + 8 * v64);
    v66 = (_QWORD *)v65[1];
    if (v66)
    {
      do
      {
        v67 = v66;
        v66 = (_QWORD *)*v66;
      }
      while (v66);
    }
    else
    {
      v68 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(a1 + 24) + v63) + 8 * v64);
      do
      {
        v67 = (_QWORD *)v68[2];
        v49 = *v67 == (_QWORD)v68;
        v68 = v67;
      }
      while (!v49);
    }
    if (*(uint64_t **)(a1 + 64) == v65)
      *(_QWORD *)(a1 + 64) = v67;
    v69 = *(uint64_t **)(a1 + 72);
    --*(_QWORD *)(a1 + 80);
    sub_18F3BEC40(v69, v65);
    operator delete(v65);
    v70 = vaddq_s64(*(int64x2_t *)(a1 + 48), (int64x2_t)xmmword_18F507FF0);
    *(int64x2_t *)(a1 + 48) = v70;
    if (v70.i64[0] >= 0x400uLL)
    {
      operator delete(**(void ***)(a1 + 24));
      *(_QWORD *)(a1 + 24) += 8;
      *(_QWORD *)(a1 + 48) -= 512;
    }
  }
}

void sub_18F43E1B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);
  if (v1)
    operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F43E1DC(uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 256;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    v6 = 512;
LABEL_7:
    *(_QWORD *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    v9 = *(_QWORD *)(a1 + 8);
    v8 = *(_QWORD *)(a1 + 16);
    if (v8 != v9)
      *(_QWORD *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_18F43E2A0(uint64_t a1)
{
  *(_QWORD *)(a1 + 104) = &off_1E2949B58;
  sub_18F3BEA38(a1 + 168, *(_QWORD **)(a1 + 176));
  sub_18F43E1DC(a1 + 120);
  *(_QWORD *)(a1 + 16) = &off_1E2949B58;
  sub_18F3BEA38(a1 + 80, *(_QWORD **)(a1 + 88));
  sub_18F43E1DC(a1 + 32);
  return a1;
}

float sub_18F43E2F8(uint64_t a1, float *a2)
{
  unint64_t v2;
  float v3;
  int v4;
  float *v5;
  int i;
  float *v7;
  float *v8;
  BOOL v9;
  float result;

  v2 = *(_QWORD *)(a1 + 80);
  if (v2)
  {
    v3 = (double)v2 * 0.5;
    v4 = vcvtms_s32_f32(v3);
    v5 = *(float **)(a1 + 64);
    if (v4 < 1)
    {
      v8 = *(float **)(a1 + 64);
    }
    else
    {
      for (i = 0; i != v4; ++i)
      {
        v7 = (float *)*((_QWORD *)v5 + 1);
        if (v7)
        {
          do
          {
            v8 = v7;
            v7 = *(float **)v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            v8 = (float *)*((_QWORD *)v5 + 2);
            v9 = *(_QWORD *)v8 == (_QWORD)v5;
            v5 = v8;
          }
          while (!v9);
        }
        v5 = v8;
      }
    }
    result = v8[7];
    *a2 = result;
  }
  return result;
}

void sub_18F43E374(_DWORD *a1)
{
  NSObject *v2;
  int v3;
  NSObject *v4;
  char *v5;
  char *v6;
  uint8_t buf[4];
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*a1)
  {
    if ((int)a1[78] >= 1)
    {
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953988);
      v2 = qword_1EE16D8E0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_ERROR))
      {
        v3 = a1[78];
        *(_DWORD *)buf = 67240192;
        v8 = v3;
        _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "[CMMotionContextSessionAnalyticsTracker] We've already sent analytics for this instance, was this intended? sent: %{public}d", buf, 8u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D8D8 != -1)
          dispatch_once(&qword_1EE16D8D8, &unk_1E2953988);
        v5 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CMMotionContextSessionAnalyticsTracker::send()", "CoreLocation: %s\n", v5);
        if (v5 != (char *)buf)
          free(v5);
      }
    }
    AnalyticsSendEventLazy();
    ++a1[78];
  }
  else
  {
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953988);
    v4 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_ERROR, "[CMMotionContextSessionAnalyticsTracker] Trying to send analytics but there are no recorded DistractedViewing events, not sending.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953988);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CMMotionContextSessionAnalyticsTracker::send()", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
}

void *sub_18F43E6B8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double *v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  double v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  double v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  double v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  double v64;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  double v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  const char *v74;
  uint64_t v75;
  double v76;
  uint64_t v77;
  const char *v78;
  uint64_t v79;
  const char *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  double v85;
  uint64_t v86;
  const char *v87;
  uint64_t v88;
  double v89;
  const char *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  const char *v95;
  uint64_t v96;
  double v97;
  uint64_t v98;
  const char *v99;
  uint64_t v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  double v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  double v110;
  const char *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  const char *v116;
  uint64_t v117;
  double v118;
  uint64_t v119;
  const char *v120;
  uint64_t v121;
  const char *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  int v126;
  double v127;
  uint64_t v128;
  const char *v129;
  uint64_t v130;
  double v131;
  const char *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  const char *v137;
  uint64_t v138;
  double v139;
  uint64_t v140;
  const char *v141;
  uint64_t v142;
  const char *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  double v147;
  int v148;
  uint64_t v149;
  const char *v150;
  uint64_t v151;
  double v152;
  const char *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  const char *v158;
  uint64_t v159;
  double v160;
  uint64_t v161;
  const char *v162;
  uint64_t v163;
  const char *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  double v168;
  int v169;
  uint64_t v170;
  const char *v171;
  uint64_t v172;
  double v173;
  const char *v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  const char *v179;
  uint64_t v180;
  double v181;
  uint64_t v182;
  const char *v183;
  uint64_t v184;
  const char *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  double v189;
  int v190;
  uint64_t v191;
  const char *v192;
  uint64_t v193;
  double v194;
  const char *v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  const char *v200;
  uint64_t v201;
  double v202;
  uint64_t v203;
  const char *v204;
  uint64_t v205;
  const char *v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  double v210;
  int v211;
  uint64_t v212;
  const char *v213;
  uint64_t v214;
  double v215;
  const char *v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  const char *v221;
  uint64_t v222;
  void *v223;
  void *v224;
  const char *v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  NSObject *v231;
  const char *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  const char *v236;
  const char *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  char *v241;
  uint64_t v242;
  NSObject *v243;
  char *v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  int v250;
  uint64_t v251;
  __int16 v252;
  uint64_t v253;
  uint8_t buf[4];
  uint64_t v255;
  __int16 v256;
  uint64_t v257;
  _BYTE v258[128];
  _QWORD v259[6];
  _QWORD v260[8];

  v260[6] = *MEMORY[0x1E0C80C00];
  v5 = *(double **)(a1 + 32);
  v6 = (void *)objc_msgSend_dictionary(MEMORY[0x1E0C99E08], a2, a3, a4, a5);
  v259[0] = CFSTR("trackingClientMode");
  v260[0] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v7, *((unsigned int *)v5 + 79), v8, v9);
  v259[1] = CFSTR("distractedViewingCount");
  v260[1] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v10, *(unsigned int *)v5, v11, v12);
  v259[2] = CFSTR("pdrTnbTrackingDisabledViaWalkingCount");
  v260[2] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v13, *((unsigned int *)v5 + 1), v14, v15);
  v259[3] = CFSTR("pdrTnbTrackingDisabledViaSitToStandWithWalkingCount");
  v260[3] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v16, *((unsigned int *)v5 + 2), v17, v18);
  v259[4] = CFSTR("pdrTnbTrackingReEnabledViaTouchCount");
  v260[4] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v19, *((unsigned int *)v5 + 3), v20, v21);
  v259[5] = CFSTR("pdrTnbTrackingReEnabledViaPickUpCount");
  v260[5] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v22, *((unsigned int *)v5 + 4), v23, v24);
  v26 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v25, (uint64_t)v260, (uint64_t)v259, 6);
  objc_msgSend_setDictionary_(v6, v27, v26, v28, v29);
  v34 = v5[3];
  if (v34 != 1.79769313e308)
  {
    *(float *)&v34 = v34;
    v35 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v34);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v36, v35, (uint64_t)CFSTR("minPdrTnbDisplacementMeters"), v37);
    v42 = *((_DWORD *)v5 + 12);
    if (v42 < 1)
      v43 = 0.0;
    else
      v43 = v5[5] / (double)v42;
    *(float *)&v43 = v43;
    v44 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v38, v39, v40, v41, v43);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v45, v44, (uint64_t)CFSTR("avgPdrTnbDisplacementMeters"), v46);
    v47 = v5[4];
    *(float *)&v47 = v47;
    v52 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v48, v49, v50, v51, v47);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v53, v52, (uint64_t)CFSTR("maxPdrTnbDisplacementMeters"), v54);
  }
  v55 = v5[7];
  if (v55 != 1.79769313e308)
  {
    *(float *)&v55 = v55;
    v56 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v55);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v57, v56, (uint64_t)CFSTR("minPdrDistanceTravelledMeters"), v58);
    v63 = *((_DWORD *)v5 + 20);
    if (v63 < 1)
      v64 = 0.0;
    else
      v64 = v5[9] / (double)v63;
    *(float *)&v64 = v64;
    v65 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v59, v60, v61, v62, v64);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v66, v65, (uint64_t)CFSTR("avgPdrDistanceTravelledMeters"), v67);
    v68 = v5[8];
    *(float *)&v68 = v68;
    v73 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v69, v70, v71, v72, v68);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v74, v73, (uint64_t)CFSTR("maxPdrDistanceTravelledMeters"), v75);
  }
  v76 = v5[11];
  if (v76 != 1.79769313e308)
  {
    *(float *)&v76 = v76;
    v77 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v76);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v78, v77, (uint64_t)CFSTR("minPdrTnbLoopClosure"), v79);
    v84 = *((_DWORD *)v5 + 28);
    if (v84 < 1)
      v85 = 0.0;
    else
      v85 = v5[13] / (double)v84;
    *(float *)&v85 = v85;
    v86 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v80, v81, v82, v83, v85);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v87, v86, (uint64_t)CFSTR("avgPdrTnbLoopClosure"), v88);
    v89 = v5[12];
    *(float *)&v89 = v89;
    v94 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v90, v91, v92, v93, v89);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v95, v94, (uint64_t)CFSTR("maxPdrTnbLoopClosure"), v96);
  }
  v97 = v5[15];
  if (v97 != 1.79769313e308)
  {
    *(float *)&v97 = v97;
    v98 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v97);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v99, v98, (uint64_t)CFSTR("minPdrTnbHeadingDiffDegs"), v100);
    v105 = *((_DWORD *)v5 + 36);
    if (v105 < 1)
      v106 = 0.0;
    else
      v106 = v5[17] / (double)v105;
    *(float *)&v106 = v106;
    v107 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v101, v102, v103, v104, v106);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v108, v107, (uint64_t)CFSTR("avgPdrTnbHeadingDiffDegs"), v109);
    v110 = v5[16];
    *(float *)&v110 = v110;
    v115 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v111, v112, v113, v114, v110);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v116, v115, (uint64_t)CFSTR("maxPdrTnbHeadingDiffDegs"), v117);
  }
  v118 = v5[19];
  if (v118 != 1.79769313e308)
  {
    *(float *)&v118 = v118;
    v119 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v118);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v120, v119, (uint64_t)CFSTR("minPdrTnbNumSteps"), v121);
    v126 = *((_DWORD *)v5 + 44);
    if (v126 < 1)
      v127 = 0.0;
    else
      v127 = v5[21] / (double)v126;
    *(float *)&v127 = v127;
    v128 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v122, v123, v124, v125, v127);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v129, v128, (uint64_t)CFSTR("avgPdrTnbNumSteps"), v130);
    v131 = v5[20];
    *(float *)&v131 = v131;
    v136 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v132, v133, v134, v135, v131);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v137, v136, (uint64_t)CFSTR("maxPdrTnbNumSteps"), v138);
  }
  v139 = v5[23];
  if (v139 != 1.79769313e308)
  {
    *(float *)&v139 = v139;
    v140 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v139);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v141, v140, (uint64_t)CFSTR("minPdrTnbStepCadence"), v142);
    v148 = *((_DWORD *)v5 + 52);
    if (v148 < 1)
    {
      LODWORD(v147) = 0;
    }
    else
    {
      v147 = v5[25] / (double)v148;
      *(float *)&v147 = v147;
    }
    v149 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v143, v144, v145, v146, v147);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v150, v149, (uint64_t)CFSTR("avgPdrTnbStepCadence"), v151);
    v152 = v5[24];
    *(float *)&v152 = v152;
    v157 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v153, v154, v155, v156, v152);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v158, v157, (uint64_t)CFSTR("maxPdrTnbStepCadence"), v159);
  }
  v160 = v5[27];
  if (v160 != 1.79769313e308)
  {
    *(float *)&v160 = v160;
    v161 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v160);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v162, v161, (uint64_t)CFSTR("minPdrTnbSpeedMetersPerSecond"), v163);
    v169 = *((_DWORD *)v5 + 60);
    if (v169 < 1)
    {
      LODWORD(v168) = 0;
    }
    else
    {
      v168 = v5[29] / (double)v169;
      *(float *)&v168 = v168;
    }
    v170 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v164, v165, v166, v167, v168);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v171, v170, (uint64_t)CFSTR("avgPdrTnbSpeedMetersPerSecond"), v172);
    v173 = v5[28];
    *(float *)&v173 = v173;
    v178 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v174, v175, v176, v177, v173);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v179, v178, (uint64_t)CFSTR("maxPdrTnbSpeedMetersPerSecond"), v180);
  }
  v181 = v5[31];
  if (v181 != 1.79769313e308)
  {
    *(float *)&v181 = v181;
    v182 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v181);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v183, v182, (uint64_t)CFSTR("minDistractedViewingDurationSeconds"), v184);
    v190 = *((_DWORD *)v5 + 68);
    if (v190 < 1)
    {
      LODWORD(v189) = 0;
    }
    else
    {
      v189 = v5[33] / (double)v190;
      *(float *)&v189 = v189;
    }
    v191 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v185, v186, v187, v188, v189);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v192, v191, (uint64_t)CFSTR("avgDistractedViewingDurationSeconds"), v193);
    v194 = v5[32];
    *(float *)&v194 = v194;
    v199 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v195, v196, v197, v198, v194);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v200, v199, (uint64_t)CFSTR("maxDistractedViewingDurationSeconds"), v201);
  }
  v202 = v5[35];
  if (v202 != 1.79769313e308)
  {
    *(float *)&v202 = v202;
    v203 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v30, v31, v32, v33, v202);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v204, v203, (uint64_t)CFSTR("minDistractedViewingAuxSampleIntervalSeconds"), v205);
    v211 = *((_DWORD *)v5 + 76);
    if (v211 < 1)
    {
      LODWORD(v210) = 0;
    }
    else
    {
      v210 = v5[37] / (double)v211;
      *(float *)&v210 = v210;
    }
    v212 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v206, v207, v208, v209, v210);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v213, v212, (uint64_t)CFSTR("avgDistractedViewingAuxSampleIntervalSeconds"), v214);
    v215 = v5[36];
    *(float *)&v215 = v215;
    v220 = objc_msgSend_numberWithFloat_(MEMORY[0x1E0CB37E8], v216, v217, v218, v219, v215);
    objc_msgSend_setObject_forKeyedSubscript_(v6, v221, v220, (uint64_t)CFSTR("maxDistractedViewingAuxSampleIntervalSeconds"), v222);
  }
  v248 = 0u;
  v249 = 0u;
  v246 = 0u;
  v247 = 0u;
  v223 = v6;
  v224 = (void *)objc_msgSend_allKeys(v6, v30, v31, v32, v33);
  v226 = objc_msgSend_countByEnumeratingWithState_objects_count_(v224, v225, (uint64_t)&v246, (uint64_t)v258, 16);
  if (v226)
  {
    v227 = v226;
    v228 = *(_QWORD *)v247;
    do
    {
      v229 = 0;
      do
      {
        if (*(_QWORD *)v247 != v228)
          objc_enumerationMutation(v224);
        v230 = *(_QWORD *)(*((_QWORD *)&v246 + 1) + 8 * v229);
        if (qword_1EE16D8D8 != -1)
          dispatch_once(&qword_1EE16D8D8, &unk_1E2953988);
        v231 = qword_1EE16D8E0;
        if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEFAULT))
        {
          v235 = objc_msgSend_objectForKey_(v223, v232, v230, v233, v234);
          *(_DWORD *)buf = 138478083;
          v255 = v230;
          v256 = 2113;
          v257 = v235;
          _os_log_impl(&dword_18F1DC000, v231, OS_LOG_TYPE_DEFAULT, "[CMMotionContextSessionAnalyticsTracker] %{private}@ -> %{private}@", buf, 0x16u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D8D8 != -1)
            dispatch_once(&qword_1EE16D8D8, &unk_1E2953988);
          v240 = objc_msgSend_objectForKey_(v223, v237, v230, v238, v239);
          v250 = 138478083;
          v251 = v230;
          v252 = 2113;
          v253 = v240;
          v241 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMMotionContextSessionAnalyticsTracker::send()_block_invoke", "CoreLocation: %s\n", v241);
          if (v241 != (char *)buf)
            free(v241);
        }
        ++v229;
      }
      while (v227 != v229);
      v242 = objc_msgSend_countByEnumeratingWithState_objects_count_(v224, v236, (uint64_t)&v246, (uint64_t)v258, 16);
      v227 = v242;
    }
    while (v242);
  }
  if (qword_1EE16D8D8 != -1)
    dispatch_once(&qword_1EE16D8D8, &unk_1E2953988);
  v243 = qword_1EE16D8E0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v243, OS_LOG_TYPE_DEFAULT, "[CMMotionContextSessionAnalyticsTracker] sent payload.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953988);
    LOWORD(v250) = 0;
    v245 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMMotionContextSessionAnalyticsTracker::send()_block_invoke", "CoreLocation: %s\n", v245);
    if (v245 != (char *)buf)
      free(v245);
  }
  return v223;
}

os_log_t sub_18F43F09C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1EE16D8E0 = (uint64_t)result;
  return result;
}

float sub_18F43F0C8(uint64_t a1, unint64_t a2)
{
  NSObject *v5;
  char *v6;
  uint8_t buf[4];
  unint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a2 >= 2)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E29547A8);
    v5 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      v8 = a2;
      v9 = 2048;
      v10 = 2;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMVector.h, line 271,invalid index %zu >= %zu.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E29547A8);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "T CMVector<float, 2>::operator[](const size_t) const [T = float, N = 2]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
  return *(float *)(a1 + 4 * a2);
}

uint64_t sub_18F43F2A0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char v5;
  char v6;
  uint64_t v7;
  int *v8;
  uint64_t i;
  int v10;
  uint64_t v11;
  uint64_t v12;
  float **v13;
  int v14;
  uint64_t v15;
  int *v16;
  uint64_t j;
  int v18;
  uint64_t v19;
  int v20;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0x3F80000000000000;
  *(_BYTE *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 2143289344;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  v3 = sub_18F4913D4(a1 + 72);
  *(_QWORD *)(a1 + 256) = 0x7FF8000000000000;
  *(_BYTE *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 268) = 1;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x600000000;
  *(_BYTE *)(a1 + 328) = 1;
  *(_QWORD *)(a1 + 348) = 0;
  *(_QWORD *)(a1 + 340) = 0;
  *(_QWORD *)(a1 + 356) = 0x600000000;
  *(_BYTE *)(a1 + 388) = 1;
  *(_QWORD *)(a1 + 400) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = 0x600000000;
  *(_QWORD *)(a1 + 448) = 0;
  *(_BYTE *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 476) = 0;
  *(_DWORD *)(a1 + 484) = 0;
  *(_QWORD *)(a1 + 460) = 0;
  *(_QWORD *)(a1 + 468) = 0;
  sub_18F491D70(v3);
  v4 = 0;
  v5 = 1;
  do
  {
    v6 = v5;
    v7 = operator new();
    *(_OWORD *)v7 = xmmword_18F503FB0;
    v8 = &dword_18F5086F8;
    for (i = 52; i != 32; i -= 4)
    {
      v10 = *v8++;
      *(_DWORD *)(v7 + i) = v10;
    }
    *(float *)(v7 + 40) = -*(float *)(v7 + 40);
    *(float *)(v7 + 48) = -*(float *)(v7 + 48);
    *(_OWORD *)(v7 + 56) = *(_OWORD *)(v7 + 36);
    v11 = a1 + 8 * v4;
    v12 = *(_QWORD *)(v11 + 472);
    *(_QWORD *)(v11 + 472) = v7;
    if (v12)
      MEMORY[0x194001438](v12, 0x1000C40FF89C88ELL);
    v13 = (float **)(v11 + 472);
    v14 = 4;
    do
    {
      sub_18F33F604(*v13, 0.0);
      --v14;
    }
    while (v14);
    v5 = 0;
    v4 = 1;
  }
  while ((v6 & 1) != 0);
  v15 = operator new();
  *(_OWORD *)v15 = xmmword_18F503FB0;
  v16 = &dword_18F50871C;
  for (j = 52; j != 32; j -= 4)
  {
    v18 = *v16++;
    *(_DWORD *)(v15 + j) = v18;
  }
  *(float *)(v15 + 40) = -*(float *)(v15 + 40);
  *(float *)(v15 + 48) = -*(float *)(v15 + 48);
  *(_OWORD *)(v15 + 56) = *(_OWORD *)(v15 + 36);
  v19 = *(_QWORD *)(a1 + 464);
  *(_QWORD *)(a1 + 464) = v15;
  if (v19)
    MEMORY[0x194001438](v19, 0x1000C40FF89C88ELL);
  v20 = 4;
  do
  {
    sub_18F33F604(*(float **)(a1 + 464), 0.0);
    --v20;
  }
  while (v20);
  return a1;
}

void sub_18F43F4DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = 0;
  v4 = v1 + 480;
  while (1)
  {
    v5 = *(_QWORD *)(v4 + v3);
    *(_QWORD *)(v4 + v3) = 0;
    if (v5)
      MEMORY[0x194001438](v5, 0x1000C40FF89C88ELL);
    v3 -= 8;
    if (v3 == -16)
    {
      v6 = *(_QWORD *)(v1 + 464);
      *(_QWORD *)(v1 + 464) = 0;
      if (v6)
        MEMORY[0x194001438](v6, 0x1000C40FF89C88ELL);
      v7 = 0;
      v8 = v1 + 248;
      while (1)
      {
        v9 = *(_QWORD *)(v8 + v7);
        *(_QWORD *)(v8 + v7) = 0;
        if (v9)
          MEMORY[0x194001438](v9, 0x1000C40FF89C88ELL);
        v7 -= 8;
        if (v7 == -16)
          _Unwind_Resume(exception_object);
      }
    }
  }
}

void sub_18F43F580(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  double v8;
  NSObject *v9;
  float32x4_t v10;
  int v11;
  float32x4_t v12;
  float v13;
  float v14;
  float v15;
  __float2 v16;
  unint64_t v17;
  char v18;
  char v19;
  char v20;
  float *v21;
  float v22;
  BOOL v23;
  float32x4_t v24;
  float cosval;
  float sinval;
  NSObject *v27;
  float v28;
  int v29;
  float v30;
  uint64_t v31;
  int v32;
  int v33;
  float v34;
  float32x2_t v35;
  float v36;
  NSObject *v37;
  uint64_t v38;
  float v39;
  uint64_t v40;
  float v41;
  char *v42;
  uint64_t v43;
  float v44;
  float v45;
  double v46;
  float v47;
  float *v48;
  int v49;
  float v50;
  float v51;
  float32x2_t v52;
  float v53;
  char *v54;
  float32x2_t v55;
  float32x2_t v56;
  __int32 v57;
  float32x2_t v58;
  float v59;
  float32x2_t v60;
  float32x2_t v61;
  __int32 v62;
  float v63;
  unint64_t v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  unint64_t v72;
  float v73;
  float v74;
  float v75;
  double v76;
  double v77;
  float v78;
  float v79;
  NSObject *v80;
  double v81;
  double v82;
  float v83;
  double v84;
  float v85;
  float v86;
  char *v87;
  char *v88;
  double v89;
  double v90;
  double v91;
  char *v92;
  _DWORD v93[3];
  unint64_t v94;
  float32x4_t v95;
  int v96;
  double v97;
  __int16 v98;
  double v99;
  __int16 v100;
  double v101;
  __int16 v102;
  double v103;
  __int16 v104;
  double v105;
  __int16 v106;
  double v107;
  _BYTE buf[12];
  _BYTE v109[10];
  __int16 v110;
  double v111;
  __int16 v112;
  double v113;
  __int16 v114;
  double v115;
  __int16 v116;
  double v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 24))
  {
    if (*(double *)a2 - *(double *)(a1 + 216) <= 1.5)
      v8 = *(double *)a2 - *(double *)(a1 + 216);
    else
      v8 = 1.5;
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E29539A8);
    v9 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(double *)&buf[4] = v8;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEBUG, "[CMDoTEstimator] Time since last step, %.2f\n", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E29539A8);
      v96 = 134217984;
      v97 = v8;
      v87 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "Pdr::PdrOutput CMPdrEstimatorOnHead::feedImuData(const AccessoryActivity::ImuData *const, const CMAccessoryStepDetector::Impulse *const, BOOL)", "CoreLocation: %s\n", v87);
      if (v87 != buf)
        free(v87);
    }
    *(double *)v10.i64 = sub_18F491BA0(a1 + 72, *(double *)(a3 + 8));
    v11 = *(_DWORD *)(a2 + 44);
    v10.f32[0] = -*(float *)(a2 + 40);
    *(float32x2_t *)buf = vneg_f32(*(float32x2_t *)(a2 + 32));
    *(_DWORD *)&buf[8] = v10.i32[0];
    *(_DWORD *)v109 = v11;
    v12 = sub_18F1FFE94((float32x4_t *)buf, v10);
    sub_18F3D3764((uint64_t)buf, (float *)(a1 + 8), &v95, v12);
    v13 = sub_18F3D39F4(v95.f32, 0.0, 0.0, 1.0);
    v15 = atan2f(v14, v13);
    v16 = __sincosf_stret(v15);
    v17 = 0;
    v94 = __PAIR64__(LODWORD(v16.__sinval), LODWORD(v16.__cosval));
    v18 = 1;
    v19 = 1;
    do
    {
      v20 = v18;
      v21 = *(float **)(a1 + 8 * v17 + 472);
      v22 = sub_18F43F0C8((uint64_t)&v94, v17);
      v23 = sub_18F33F604(v21, v22);
      v18 = 0;
      v19 &= v23;
      v17 = 1;
    }
    while ((v20 & 1) != 0);
    if ((v19 & 1) != 0)
    {
      cosval = *(float *)(*(_QWORD *)(a1 + 472) + 4 * *(_QWORD *)(*(_QWORD *)(a1 + 472) + 8) + 16);
      sinval = *(float *)(*(_QWORD *)(a1 + 480) + 4 * *(_QWORD *)(*(_QWORD *)(a1 + 480) + 8) + 16);
    }
    else
    {
      sinval = v16.__sinval;
      cosval = v16.__cosval;
    }
    v28 = sqrtf((float)(sinval * sinval) + (float)(cosval * cosval));
    *(float *)(a1 + 60) = cosval / v28;
    *(float *)(a1 + 64) = sinval / v28;
    if (a4)
    {
      v29 = *(_DWORD *)(a2 + 44);
      v24.f32[0] = -*(float *)(a2 + 40);
      *(float32x2_t *)buf = vneg_f32(*(float32x2_t *)(a2 + 32));
      *(_DWORD *)&buf[8] = v24.i32[0];
      *(_DWORD *)v109 = v29;
      sub_18F1FFE94((float32x4_t *)buf, v24);
      v30 = sub_18F3D39F4((float *)buf, -*(float *)(a2 + 20), -*(float *)(a2 + 24), -*(float *)(a2 + 28));
      v31 = 0;
      *(float *)v93 = v30;
      v93[1] = v32;
      v93[2] = v33;
      v34 = 0.0;
      do
      {
        v34 = v34 + (float)(*(float *)&v93[v31] * *(float *)&v93[v31]);
        ++v31;
      }
      while (v31 != 3);
      if (sqrtf(v34) > 0.02)
      {
        v35.i32[0] = LODWORD(v16.__cosval);
        *(float *)(a1 + 28) = v15;
        *(float *)(a1 + 32) = v16.__cosval;
        v36 = 0.0;
        *(float *)(a1 + 36) = v16.__sinval;
        if (v8 > 0.0)
        {
          v35.i32[1] = LODWORD(v16.__sinval);
          *(float32x2_t *)(a1 + 40) = vadd_f32(vmul_f32(v35, (float32x2_t)vdup_n_s32(0x3F49DB23u)), *(float32x2_t *)(a1 + 40));
          *(float *)(a1 + 48) = *(float *)(a1 + 48) + 0.0;
          v36 = 0.7885 / v8;
        }
        *(float *)(a1 + 52) = v36;
        if (qword_1EE16D8D8 != -1)
          dispatch_once(&qword_1EE16D8D8, &unk_1E29539A8);
        v37 = qword_1EE16D8E0;
        if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
        {
          v38 = 0;
          v39 = 0.0;
          do
          {
            v39 = v39 + (float)(*(float *)&v93[v38] * *(float *)&v93[v38]);
            ++v38;
          }
          while (v38 != 3);
          *(_DWORD *)buf = 134217984;
          *(double *)&buf[4] = sqrtf(v39);
          _os_log_impl(&dword_18F1DC000, v37, OS_LOG_TYPE_DEBUG, "[CMDoTEstimator] DoG: userAccelNorm, %f\n", buf, 0xCu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D8D8 != -1)
            dispatch_once(&qword_1EE16D8D8, &unk_1E29539A8);
          v40 = 0;
          v41 = 0.0;
          do
          {
            v41 = v41 + (float)(*(float *)&v93[v40] * *(float *)&v93[v40]);
            ++v40;
          }
          while (v40 != 3);
          v96 = 134217984;
          v97 = sqrtf(v41);
          v42 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMPdrEstimatorOnHead::directionOfGaze(const CMVector3d &, float, double)", "CoreLocation: %s\n", v42);
          if (v42 != buf)
            free(v42);
        }
      }
    }
    else
    {
      v43 = sub_18F4915E4(a1 + 72, *(_QWORD *)a1);
      v45 = v44;
      v46 = *(double *)a2;
      v47 = atan2f(*(float *)(a1 + 64), *(float *)(a1 + 60));
      v48 = *(float **)a1;
      v49 = *(unsigned __int8 *)(*(_QWORD *)a1 + 68);
      v50 = *(float *)(*(_QWORD *)a1 + 56);
      if (sub_18F33F604(*(float **)(a1 + 464), v50))
        v50 = *(float *)(*(_QWORD *)(a1 + 464) + 4 * *(_QWORD *)(*(_QWORD *)(a1 + 464) + 8) + 16);
      if (v49)
      {
        v51 = v45;
        if (*(_BYTE *)(a1 + 264))
        {
          v52.i32[0] = *(_DWORD *)(a1 + 60);
          v53 = *(float *)(a1 + 64);
          *(_DWORD *)(a1 + 32) = v52.i32[0];
          *(float *)(a1 + 36) = v53;
          v54 = "N5CMMsl22MagneticAccessoryType2E" + 6;
        }
        else
        {
          if (sub_18F49201C(a1 + 256))
          {
            *(_QWORD *)(a1 + 280) = 0;
            *(_QWORD *)(a1 + 288) = 0;
            *(_DWORD *)(a1 + 296) = 0;
            *(_BYTE *)(a1 + 268) = 1;
            *(_DWORD *)(a1 + 356) = 0;
            *(_QWORD *)(a1 + 348) = 0;
            *(_QWORD *)(a1 + 340) = 0;
            *(_BYTE *)(a1 + 328) = 1;
            *(_QWORD *)(a1 + 400) = 0;
            *(_QWORD *)(a1 + 408) = 0;
            *(_DWORD *)(a1 + 416) = 0;
            *(_BYTE *)(a1 + 388) = 1;
            *(_QWORD *)(a1 + 256) = 0x7FF8000000000000;
            *(_BYTE *)(a1 + 456) = 0;
          }
          v54 = "l22MagneticAccessoryType2E";
          if (v51 >= 0.5)
          {
            *(float *)buf = v51 * *(float *)&v43;
            *(float *)&buf[4] = v51 * *((float *)&v43 + 1);
            v52.f32[0] = sub_18F491E70(a1 + 72, (float *)buf);
            *(_DWORD *)(a1 + 32) = v52.i32[0];
            *(float *)(a1 + 36) = v53;
          }
          else
          {
            v60 = vmul_f32(*(float32x2_t *)(a1 + 60), (float32x2_t)vdup_n_s32(0x3F19999Au));
            v61.f32[0] = sub_18F491E70(a1 + 72, (float *)(a1 + 60));
            v61.i32[1] = v62;
            v52 = vadd_f32(v60, vmul_f32(v61, (float32x2_t)vdup_n_s32(0x3ECCCCCCu)));
            *(float32x2_t *)(a1 + 32) = v52;
            v53 = v52.f32[1];
          }
        }
        if (*(_DWORD *)(a1 + 56) == 1)
        {
          v63 = 0.7885;
        }
        else
        {
          v64 = 0;
          v65 = v48[15];
          v66 = v48[16];
          v67 = v65 * v48[11];
          v68 = v48[14];
          v69 = (float)((float)(v65 * v48[12]) + (float)(v66 * v48[6])) * v68;
          v70 = (float)((float)(v65 * v48[13]) + (float)(v66 * v48[7])) * v68;
          *(float *)buf = (float)(v67 + (float)(v66 * v48[5])) * v68;
          *(float *)&buf[4] = v69;
          *(float *)&buf[8] = v70;
          v71 = v50 * 24.896;
          do
          {
            v72 = v64 + 1;
            v73 = flt_18F50870C[v64 + 1];
            v71 = v71 + (float)(v73 * sub_18F3551B0((uint64_t)buf, v64));
            v64 = v72;
          }
          while (v72 != 3);
          *(float *)(a1 + 52) = v71;
          v63 = *(double *)(*(_QWORD *)a1 + 80) * (float)(v71 * v51);
          v52.i32[0] = *(_DWORD *)(a1 + 32);
          v53 = *(float *)(a1 + 36);
        }
        *(float *)(a1 + 40) = (float)(v52.f32[0] * v63) + *(float *)(a1 + 40);
        *(float32x2_t *)(a1 + 44) = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(v53 * v63), *(float32x2_t *)(a1 + 44));
        v74 = atan2f(*((float *)&v43 + 1), *(float *)&v43);
        v75 = *(float *)(a1 + 28);
        v76 = (float)(v75 - v47) + floor(((float)(v75 - v47) + 3.14159265) / 6.28318531) * -6.28318531;
        v77 = (float)(v74 - v75) + floor(((float)(v74 - v75) + 3.14159265) / 6.28318531) * -6.28318531;
        if (qword_1EE16D8D8 != -1)
          dispatch_once(&qword_1EE16D8D8, &unk_1E29539A8);
        v78 = v76;
        v79 = v77;
        v80 = qword_1EE16D8E0;
        if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
        {
          v81 = *(float *)(a1 + 40);
          v82 = *(float *)(a1 + 44);
          v83 = *((float *)v54 + 903);
          v84 = (float)(*(float *)(a1 + 28) * v83);
          *(_DWORD *)buf = 134219264;
          *(double *)&buf[4] = v81;
          *(_WORD *)v109 = 2048;
          *(double *)&v109[2] = v82;
          v110 = 2048;
          v111 = (float)(v78 * v83);
          v112 = 2048;
          v113 = v84;
          v114 = 2048;
          v115 = (float)(v47 * v83);
          v116 = 2048;
          v117 = (float)(v79 * v83);
          _os_log_impl(&dword_18F1DC000, v80, OS_LOG_TYPE_DEBUG, "[CMDoTEstimator] position [%f, %f], gazeDiffDot, %.2f, dot %.2f, gaze, %.2f, swayDelta, %.2f\n", buf, 0x3Eu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D8D8 != -1)
            dispatch_once(&qword_1EE16D8D8, &unk_1E29539A8);
          v89 = *(float *)(a1 + 40);
          v90 = *(float *)(a1 + 44);
          v91 = (float)(*(float *)(a1 + 28) * 57.296);
          v96 = 134219264;
          v97 = v89;
          v98 = 2048;
          v99 = v90;
          v100 = 2048;
          v101 = (float)(v78 * 57.296);
          v102 = 2048;
          v103 = v91;
          v104 = 2048;
          v105 = (float)(v47 * 57.296);
          v106 = 2048;
          v107 = (float)(v79 * 57.296);
          v92 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMPdrEstimatorOnHead::printDebugInfo(float, float) const", "CoreLocation: %s\n", v92);
          if (v92 != buf)
            free(v92);
        }
        v58.i32[0] = *(_DWORD *)(a1 + 32);
        v59 = *(float *)(a1 + 36);
      }
      else
      {
        v55 = vmul_f32(*(float32x2_t *)(a1 + 60), (float32x2_t)vdup_n_s32(0x3F19999Au));
        v56.f32[0] = sub_18F491E70(a1 + 72, (float *)(a1 + 60));
        v56.i32[1] = v57;
        v58 = vadd_f32(v55, vmul_f32(v56, (float32x2_t)vdup_n_s32(0x3ECCCCCCu)));
        *(float32x2_t *)(a1 + 32) = v58;
        *(_DWORD *)(a1 + 52) = 0;
        v59 = v58.f32[1];
      }
      v85 = atan2f(v59, v58.f32[0]);
      *(float *)(a1 + 28) = v85;
      v86 = 0.0;
      if (v46 - *(double *)(a1 + 216) < 1.5)
        v86 = 1.0;
      sub_18F491F28((unsigned __int16 *)(a1 + 256), v86, v47, v85, v46);
    }
  }
  else
  {
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E29539A8);
    v27 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_DEFAULT, "[CMDoTEstimator] HeadSet Orientation is not set!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E29539A8);
      LOWORD(v96) = 0;
      v88 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "Pdr::PdrOutput CMPdrEstimatorOnHead::feedImuData(const AccessoryActivity::ImuData *const, const CMAccessoryStepDetector::Impulse *const, BOOL)", "CoreLocation: %s\n", v88);
      if (v88 != buf)
        free(v88);
    }
  }
}

os_log_t sub_18F4401A4()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1EE16D8E0 = (uint64_t)result;
  return result;
}

void sub_18F4401D4()
{
  JUMPOUT(0x194001438);
}

void sub_18F4401E8(uint64_t a1, _QWORD *a2)
{
  float v3;

  *(_QWORD *)(a1 + 8) = *a2;
  v3 = 1.0 / *(double *)a2;
  *(float *)(a1 + 16) = v3;
  *(_DWORD *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 23) = 0;
  bzero((void *)(a1 + 56), 0x2D8uLL);
  *(_WORD *)(a1 + 822) = 0;
  *(_DWORD *)(a1 + 818) = 0;
}

void sub_18F44024C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 56) = 0;
  v1 = a1 + 56;
  *(_DWORD *)(a1 + 20) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 776) = 0;
  *(_WORD *)(a1 + 60) = 0;
  sub_18F210D80(a1 + 62);
  sub_18F211EBC(v1 + 208, 0, 0, 0, v1, *(_DWORD *)(v1 + 720));
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E29539C8);
  v2 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "compass calibrator has been reset", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E29539C8);
    v3 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLCompassCalibratorAKM::reset()", "CoreLocation: %s\n", v3);
    if (v3 != (char *)buf)
      free(v3);
  }
}

void sub_18F44040C(uint64_t a1, float *a2)
{
  NSObject *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  char *v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  sub_18F210E94((int)(a2[2] / 0.3 * 5.0), (int)(a2[3] / 0.3 * 5.0), (int)(a2[4] / 0.3 * 5.0), a1 + 62, (_WORD *)(a1 + 254));
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_WORD *)(a1 + 816) = 0;
  if ((int)sub_18F212220(0, 0, 0, (uint64_t *)(a1 + 264), a1 + 62, *(_WORD *)(a1 + 254), 0, 1, a1 + 56, (_DWORD *)(a1 + 776), a1 + 784) >= 1)
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E29539C8);
    v3 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
    {
      v4 = *(__int16 *)(a1 + 660);
      v5 = *(__int16 *)(a1 + 798);
      v6 = *(__int16 *)(a1 + 796);
      v7 = *(__int16 *)(a1 + 800);
      v8 = *(__int16 *)(a1 + 802);
      v9 = *(__int16 *)(a1 + 786);
      v10 = *(__int16 *)(a1 + 804);
      v11 = *(__int16 *)(a1 + 806);
      v12 = *(__int16 *)(a1 + 808);
      v13 = *(__int16 *)(a1 + 792);
      v14 = *(__int16 *)(a1 + 784);
      v15 = *(__int16 *)(a1 + 810);
      v16 = *(__int16 *)(a1 + 812);
      v17 = *(__int16 *)(a1 + 814);
      v18 = *(__int16 *)(a1 + 790);
      v19 = *(__int16 *)(a1 + 788);
      v20 = *(__int16 *)(a1 + 794);
      v21 = *(__int16 *)(a1 + 816);
      *(_DWORD *)buf = 136319746;
      v24 = "Compass-DOE";
      v25 = 1024;
      v26 = v4;
      v27 = 1024;
      v28 = v5;
      v29 = 1024;
      v30 = v6;
      v31 = 1024;
      v32 = v7;
      v33 = 1024;
      v34 = v8;
      v35 = 1024;
      v36 = v9;
      v37 = 1024;
      v38 = v10;
      v39 = 1024;
      v40 = v11;
      v41 = 1024;
      v42 = v12;
      v43 = 1024;
      v44 = v13;
      v45 = 1024;
      v46 = v14;
      v47 = 1024;
      v48 = v15;
      v49 = 1024;
      v50 = v16;
      v51 = 1024;
      v52 = v17;
      v53 = 1024;
      v54 = v18;
      v55 = 1024;
      v56 = v19;
      v57 = 1024;
      v58 = v20;
      v59 = 1024;
      v60 = v21;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEBUG, "Type,%s,radius,%d,hrmin,%d,hrmax,%d,hrvar,%d,rvar,%d,m,%d,ovar,%d,%d,%d,hovar,%d,n,%d,vvar,%d,%d,%d,hvarA,%d,hvar,%d,hdistpl,%d,dvar,%d,", buf, 0x78u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E29539C8);
      v22 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual void CLCompassCalibratorAKM::addSample(const CLVector3d<float> &, const CLClientQuaternion *, const CFTimeInterval &)", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf)
        free(v22);
    }
  }
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 776);
}

void sub_18F440834(uint64_t a1, float *a2, int *a3)
{
  int v5;
  uint64_t v6;
  NSObject *v7;
  double v8;
  double v9;
  double v10;
  int v11;
  char *v12;
  uint8_t buf[4];
  double v14;
  __int16 v15;
  double v16;
  __int16 v17;
  double v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  *(_WORD *)(a1 + 56) = (int)(a2[2] / 0.3 * 5.0);
  v6 = a1 + 56;
  *(_DWORD *)(a1 + 776) = v5;
  *(_DWORD *)(a1 + 20) = v5;
  *(_WORD *)(a1 + 58) = (int)(a2[3] / 0.3 * 5.0);
  *(_WORD *)(a1 + 60) = (int)(a2[4] / 0.3 * 5.0);
  sub_18F210D80(a1 + 62);
  sub_18F211EBC(v6 + 208, 0, 0, 0, v6, *(_DWORD *)(v6 + 720));
  *(_DWORD *)(v6 - 28) = *(_DWORD *)(v6 + 720);
  *(_DWORD *)(v6 + 762) = *(_DWORD *)v6;
  *(_WORD *)(v6 + 766) = *(_WORD *)(v6 + 4);
  *(_BYTE *)(v6 - 32) = 1;
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E29539C8);
  v7 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v8 = a2[2];
    v9 = a2[3];
    v10 = a2[4];
    v11 = *a3;
    *(_DWORD *)buf = 134218752;
    v14 = v8;
    v15 = 2048;
    v16 = v9;
    v17 = 2048;
    v18 = v10;
    v19 = 1024;
    v20 = v11;
    _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEBUG, "compass calibrator has been set with offsets (%+.3f/%+.3f/%+.3f) and calibration level (%d)", buf, 0x26u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E29539C8);
    v12 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLCompassCalibratorAKM::setBias(const CLVector3d<float> &, const CLMotionTypeCompassCalibrationLevel &, const CLVector3d<float> &, const CLClientQuaternion *)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf)
      free(v12);
  }
}

uint64_t sub_18F440AFC(uint64_t result, float *a2, _DWORD *a3)
{
  int v3;
  int v4;
  float v5;
  float v6;
  float v7;
  int v8;

  v3 = *(_DWORD *)(result + 776);
  *a3 = v3;
  v4 = *(__int16 *)(result + 56);
  *(_DWORD *)(result + 20) = v3;
  v5 = (float)((float)v4 / 5.0) * 0.3;
  *a2 = v5;
  v6 = (float)((float)*(__int16 *)(result + 58) / 5.0) * 0.3;
  a2[1] = v6;
  v7 = (float)((float)*(__int16 *)(result + 60) / 5.0) * 0.3;
  a2[2] = v7;
  v8 = *(_DWORD *)(result + 28);
  if (v8 == v3
    && *(unsigned __int16 *)(result + 818) == *(unsigned __int16 *)(result + 56)
    && *(unsigned __int16 *)(result + 820) == *(unsigned __int16 *)(result + 58)
    && *(unsigned __int16 *)(result + 822) == *(unsigned __int16 *)(result + 60))
  {
    *(_WORD *)(result + 25) = 0;
  }
  else
  {
    *(_BYTE *)(result + 26) = v8 <= v3;
    *(_WORD *)(result + 24) = 256;
    *(_DWORD *)(result + 28) = v3;
    *(_DWORD *)(result + 818) = *(_DWORD *)(result + 56);
    *(_WORD *)(result + 822) = *(_WORD *)(result + 60);
  }
  return result;
}

float32_t sub_18F440BE0(__int16 *a1, float32x2_t *a2, float32x2_t *a3)
{
  float v3;
  float32_t v4;
  int32x2_t v5;
  float32x2_t v11;
  float32_t result;

  v3 = (float)((float)a1[30] / 5.0) * 0.3;
  v4 = a2[2].f32[0] - v3;
  v5.i32[0] = a1[28];
  v5.i32[1] = a1[29];
  __asm { FMOV            V3.2S, #5.0 }
  v11 = vcvt_f32_f64(vmulq_f64(vcvtq_f64_f32(vdiv_f32(vcvt_f32_s32(v5), _D3)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL)));
  a2[1] = vsub_f32(a2[1], v11);
  a2[2].f32[0] = v4;
  result = a3[2].f32[0] - v3;
  a3[1] = vsub_f32(a3[1], v11);
  a3[2].f32[0] = result;
  return result;
}

BOOL sub_18F440C6C(uint64_t a1)
{
  return !*(_DWORD *)(a1 + 776)
      && *(_BYTE *)(a1 + 25)
      && !*(_WORD *)(a1 + 56)
      && !*(_WORD *)(a1 + 58)
      && *(_WORD *)(a1 + 60) == 0;
}

uint64_t sub_18F440CA8()
{
  return 3;
}

uint64_t sub_18F440CB0()
{
  return 0;
}

uint64_t sub_18F440CBC(uint64_t a1, uint64_t a2)
{
  if (sub_18F1EE8D4(a2, "kCLMotionTypeGeomagneticModelDataXKey", (void *)a1)
    && sub_18F1EE8D4(a2, "kCLMotionTypeGeomagneticModelDataYKey", (void *)(a1 + 8))
    && sub_18F1EE8D4(a2, "kCLMotionTypeGeomagneticModelDataZKey", (void *)(a1 + 16))
    && sub_18F1EE8D4(a2, "kCLMotionTypeGeomagneticModelDataMagnitudeKey", (void *)(a1 + 24))
    && sub_18F1EE8D4(a2, "kCLMotionTypeGeomagneticModelDataHorizontalKey", (void *)(a1 + 32))
    && sub_18F1EE8D4(a2, "kCLMotionTypeGeomagneticModelDataDeclinationKey", (void *)(a1 + 40))
    && sub_18F1EE8D4(a2, "kCLMotionTypeGeomagneticModelDataInclinationKey", (void *)(a1 + 48)))
  {
    return sub_18F1EE8D4(a2, "kCLMotionTypeGeomagneticModelDataTimestampKey", (void *)(a1 + 56));
  }
  else
  {
    return 0;
  }
}

BOOL sub_18F440DC4(const void *a1, const void *a2, const void *a3, uint64_t a4)
{
  sub_18F36C944(a4, "kCMActivityAlarmId", a1);
  sub_18F36C944(a4, "kCMActivityAlarmTrigger", a2);
  return sub_18F36CEDC(a4, "kCMActivityAlarmDuration", a3);
}

uint64_t sub_18F440E28(_DWORD *a1, _DWORD *a2, void *a3, uint64_t a4)
{
  if (sub_18F1E4DFC(a4, "kCMActivityAlarmId", a1)
    && sub_18F1E4DFC(a4, "kCMActivityAlarmTrigger", a2))
  {
    return sub_18F1EE8D4(a4, "kCMActivityAlarmDuration", a3);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_18F440FC0()
{
  uint64_t result;
  _QWORD *v1;

  result = sub_18F1F7BFC();
  if ((result & 0x100) != 0)
  {
    v1 = (_QWORD *)operator new();
    result = (uint64_t)sub_18F497D38(v1);
    *v1 = &off_1E294A9C0;
    qword_1EE16E8F0 = (uint64_t)v1;
  }
  return result;
}

void sub_18F441014(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0xA1C4030951706);
  _Unwind_Resume(a1);
}

BOOL sub_18F441038(uint64_t a1)
{
  NSObject *v2;
  _BOOL8 v3;
  NSObject *v4;
  char *v6;
  char *v7;
  char v8;
  __int16 v9;
  uint8_t buf[1640];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  sub_18F204AE4();
  sub_18F3DE6D4();
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
  v2 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "[CLSPUEclipseClient] Notifying latest suppression.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    v9 = 0;
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CLSPUEclipseClient::notifyLatestSuppression()", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf)
      free(v6);
  }
  v8 = 4;
  v3 = sub_18F498058(a1, (uint64_t)&v8, (char *)1);
  if (!v3)
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    v4 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEFAULT, "[CLSPUEclipseClient] Notify failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
      v9 = 0;
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL CLSPUEclipseClient::notifyLatestSuppression()", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }
  }
  return v3;
}

uint64_t sub_18F44131C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[8];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  v6 = sub_18F204AE4();
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = sub_18F4413D8;
  v9[3] = &unk_1E2958008;
  v9[6] = a3;
  v9[7] = a2;
  v9[4] = &v10;
  v9[5] = a1;
  sub_18F1F5E28(v6, (uint64_t)v9);
  v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_18F4413C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18F4413D8(NSObject *a1)
{
  NSObject *v1;
  Class isa;
  NSObject *v3;
  mach_error_t v4;
  mach_error_t v5;
  NSObject *v6;
  char *v7;
  char *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  char *v17;
  uint64_t v18;
  int v19;
  char *v20;
  char *v21;
  uint64_t v22;
  _BYTE v23[37];
  char v24;
  int v25;
  uint64_t v26;
  __int16 v27;
  double v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint8_t buf[4];
  _BYTE v34[24];
  __int16 v35;
  const char *v36;
  uint64_t v37;

  v1 = a1;
  v37 = *MEMORY[0x1E0C80C00];
  isa = a1[5].isa;
  if ((sub_18F1F7BFC() & 0x100) != 0)
  {
    if (qword_1EE16D438 == -1)
      goto LABEL_3;
  }
  else
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    v15 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v34 = 0;
      *(_WORD *)&v34[4] = 2082;
      *(_QWORD *)&v34[6] = "";
      *(_WORD *)&v34[14] = 2082;
      *(_QWORD *)&v34[16] = "assert";
      v35 = 2081;
      v36 = "isAvailable()";
      _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    }
    v16 = off_1EE16D428;
    if (os_signpost_enabled((os_log_t)off_1EE16D428))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v34 = 0;
      *(_WORD *)&v34[4] = 2082;
      *(_QWORD *)&v34[6] = "";
      *(_WORD *)&v34[14] = 2082;
      *(_QWORD *)&v34[16] = "assert";
      v35 = 2081;
      v36 = "isAvailable()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLSPUEclipseInterface] Service required", "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    }
    v1 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v34 = 0;
      *(_WORD *)&v34[4] = 2082;
      *(_QWORD *)&v34[6] = "";
      *(_WORD *)&v34[14] = 2082;
      *(_QWORD *)&v34[16] = "assert";
      v35 = 2081;
      v36 = "isAvailable()";
      _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
LABEL_3:
  v3 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[CLSPUEclipseClient] Sending query command.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    *(_WORD *)v23 = 0;
    v17 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CLSPUEclipseClient::querySuppressionBlocking(BOOL &, CLMotionTypeTimestamp &)_block_invoke", "CoreLocation: %s\n", v17);
    if (v17 != (char *)buf)
      free(v17);
  }
  v24 = 5;
  memset(v23, 0, sizeof(v23));
  v22 = 37;
  v4 = sub_18F4120A8(*((_QWORD *)isa + 3), (uint64_t)&v24, (char *)1, (uint64_t)v23, (uint64_t)&v22);
  if (v4)
  {
    v5 = v4;
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    v6 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      v7 = mach_error_string(v5);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)v34 = v7;
      *(_WORD *)&v34[8] = 1026;
      *(_DWORD *)&v34[10] = v5;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_ERROR, "[CLSPUEclipseClient] Query failed: %{public}s (0x%{public}x)", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
      v8 = mach_error_string(v5);
      v25 = 136446466;
      v26 = (uint64_t)v8;
      v27 = 1026;
      LODWORD(v28) = v5;
LABEL_69:
      v21 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "BOOL CLSPUEclipseClient::querySuppressionBlocking(BOOL &, CLMotionTypeTimestamp &)_block_invoke", "CoreLocation: %s\n", v21);
      if (v21 != (char *)buf)
        free(v21);
    }
  }
  else if (v22 == 37)
  {
    if (v23[1])
    {
      if (*(_QWORD *)&v23[10])
      {
        *(double *)v1[6].isa = (double)*(unint64_t *)&v23[10] * 0.000001;
        *(_BYTE *)v1[7].isa = v23[19];
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
        v9 = off_1EE16D428;
        if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
        {
          v10 = *(_QWORD *)v1[6].isa;
          v11 = *(unsigned __int8 *)v1[7].isa;
          *(_DWORD *)buf = 134349824;
          *(_QWORD *)v34 = v10;
          *(_WORD *)&v34[8] = 2050;
          *(double *)&v34[10] = (double)*(unint64_t *)&v23[2] * 0.000001;
          *(_WORD *)&v34[18] = 1026;
          *(_DWORD *)&v34[20] = v11;
          v35 = 1026;
          LODWORD(v36) = v23[20];
          _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEFAULT, "[CLSPUEclipseClient] Query reply: timestamp,%{public}f, replyTimestamp,%{public}f, suppress,%{public}d, awake,%{public}d", buf, 0x22u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D438 != -1)
            dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
          v18 = *(_QWORD *)v1[6].isa;
          v19 = *(unsigned __int8 *)v1[7].isa;
          v25 = 134349824;
          v26 = v18;
          v27 = 2050;
          v28 = (double)*(unint64_t *)&v23[2] * 0.000001;
          v29 = 1026;
          v30 = v19;
          v31 = 1026;
          v32 = v23[20];
          v20 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "BOOL CLSPUEclipseClient::querySuppressionBlocking(BOOL &, CLMotionTypeTimestamp &)_block_invoke", "CoreLocation: %s\n", v20);
          if (v20 != (char *)buf)
            free(v20);
        }
        *(_BYTE *)(*((_QWORD *)v1[4].isa + 1) + 24) = 1;
      }
      else
      {
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
        v14 = off_1EE16D428;
        if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_ERROR, "[CLSPUEclipseClient] No suppression event available yet.", buf, 2u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D438 != -1)
            dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
          LOWORD(v25) = 0;
          goto LABEL_69;
        }
      }
    }
    else
    {
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
      v13 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_ERROR, "[CLSPUEclipseClient] Service not running.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
        LOWORD(v25) = 0;
        goto LABEL_69;
      }
    }
  }
  else
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    v12 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134349056;
      *(_QWORD *)v34 = v22;
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_ERROR, "[CLSPUEclipseClient] Unexpected response size: %{public}zu", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
      v25 = 134349056;
      v26 = v22;
      goto LABEL_69;
    }
  }
}

void sub_18F441DF0(uint64_t a1, int a2)
{
  NSObject *v4;
  NSObject *v5;
  char *v6;
  char *v7;
  _BYTE v8[2];
  int v9;
  int v10;
  uint8_t buf[4];
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  sub_18F204AE4();
  sub_18F3DE6D4();
  v8[0] = 6;
  v8[1] = a2;
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
  v4 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67240192;
    v12 = a2;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "[CLSPUEclipseClient] Sending SignificantUserInteraction to AOP,simulated,%{public}u", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    v9 = 67240192;
    v10 = a2;
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLSPUEclipseClient::informSignificantUserInteraction(BOOL)", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf)
      free(v6);
  }
  if (!sub_18F498058(a1, (uint64_t)v8, (char *)2))
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    v5 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "[CLSPUEclipseClient] Informing AOP about SignificantUserInteraction failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
      LOWORD(v9) = 0;
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLSPUEclipseClient::informSignificantUserInteraction(BOOL)", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }
  }
}

void sub_18F4420EC(uint64_t a1)
{
  NSObject *v2;
  char *v3;
  char v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  sub_18F204AE4();
  sub_18F3DE6D4();
  v4 = 7;
  if (!sub_18F498058(a1, (uint64_t)&v4, (char *)1))
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
    v2 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "[CLSPUEclipseClient] Failed to release AP force wake assertion", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29549A8);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLSPUEclipseClient::releaseAPForceWakeAssertion()", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
}

uint64_t sub_18F442298(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &off_1E294AD88;
  v2 = a1 + 8;
  sub_18F3C67B0((_QWORD **)(a1 + 24), 0);
  sub_18F2A8438(v2);
  return a1;
}

void sub_18F4422DC(uint64_t a1)
{
  uint64_t v1;

  *(_QWORD *)a1 = &off_1E294AD88;
  v1 = a1 + 8;
  sub_18F3C67B0((_QWORD **)(a1 + 24), 0);
  sub_18F2A8438(v1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F442330()
{
  return 0;
}

os_log_t sub_18F442338()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Eclipse");
  off_1EE16D428 = result;
  return result;
}

CFRunLoopTimerRef *sub_18F442364()
{
  CFRunLoopTimerRef *v0;
  CFRunLoopTimerRef *result;

  v0 = (CFRunLoopTimerRef *)operator new();
  result = sub_18F1E1F84(v0, 3, 0);
  *v0 = (CFRunLoopTimerRef)&off_1E294AB58;
  qword_1ECEDFDE0 = (uint64_t)v0;
  return result;
}

void sub_18F4423B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10A1C40A8081CBALL);
  _Unwind_Resume(a1);
}

void sub_18F4423E0(uint64_t a1)
{
  sub_18F4D2930(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F442404(uint64_t result)
{
  void *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void *v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  uint8_t buf[4];
  uint64_t v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = (void *)result;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && objc_msgSend_objectForKeyedSubscript_(v1, v2, (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierTheta0"), v3, v4)
      && objc_msgSend_objectForKeyedSubscript_(v1, v5, (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierTheta1"), v6, v7)
      && objc_msgSend_objectForKeyedSubscript_(v1, v8, (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierTheta2"), v9, v10)
      && objc_msgSend_objectForKeyedSubscript_(v1, v11, (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierTheta3"), v12, v13)&& objc_msgSend_objectForKeyedSubscript_(v1, v14, (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierTheta4"), v15, v16)&& objc_msgSend_objectForKeyedSubscript_(v1, v17, (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierTheta5"), v18, v19)&& objc_msgSend_objectForKeyedSubscript_(v1,
           v20,
           (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierMinLowPower"),
           v21,
           v22)
      && objc_msgSend_objectForKeyedSubscript_(v1, v23, (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierMaxLowPower"), v24, v25)&& objc_msgSend_objectForKeyedSubscript_(v1, v26, (uint64_t)CFSTR("CMOnBodyStatusManagerClassifierMaxHighPower"), v27, v28)&& objc_msgSend_objectForKeyedSubscript_(v1, v29, (uint64_t)CFSTR("CMOnBodyStatusManagerLowBandStart"), v30, v31)&& objc_msgSend_objectForKeyedSubscript_(v1, v32, (uint64_t)CFSTR("CMOnBodyStatusManagerLowBandStop"), v33, v34)&& objc_msgSend_objectForKeyedSubscript_(v1, v35, (uint64_t)CFSTR("CMOnBodyStatusManagerHighBandStart"), v36, v37)&& objc_msgSend_objectForKeyedSubscript_(v1, v38, (uint64_t)CFSTR("CMOnBodyStatusManagerHighBandStop"), v39, v40)&& objc_msgSend_objectForKeyedSubscript_(v1, v41, (uint64_t)CFSTR("CMOnBodyStatusManagerWakeThreshold"), v42, v43)&& objc_msgSend_objectForKeyedSubscript_(v1, v44, (uint64_t)CFSTR("CMOnBodyStatusManagerOddsThreshold"), v45, v46)&& objc_msgSend_objectForKeyedSubscript_(v1,
           v47,
           (uint64_t)CFSTR("CMOnBodyStatusManagerMedianFilterSize"),
           v48,
           v49)
      && objc_msgSend_objectForKeyedSubscript_(v1, v50, (uint64_t)CFSTR("CMOnBodyStatusManagerConfidenceThreshold"), v51, v52)&& objc_msgSend_objectForKeyedSubscript_(v1, v53, (uint64_t)CFSTR("CMOnBodyStatusManagerUseHysteresis"), v54, v55)&& objc_msgSend_objectForKeyedSubscript_(v1, v56, (uint64_t)CFSTR("CMOnBodyStatusManagerUseAngleOverride"), v57, v58)&& objc_msgSend_objectForKeyedSubscript_(v1, v59, (uint64_t)CFSTR("CMOnBodyStatusManagerAngleMetricThreshold"), v60, v61))
    {
      return 1;
    }
    else
    {
      if (qword_1EE16D8C8 != -1)
        dispatch_once(&qword_1EE16D8C8, &unk_1E2945040);
      v62 = qword_1EE16D8D0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D8D0, OS_LOG_TYPE_FAULT))
      {
        v67 = (void *)objc_msgSend_description(v1, v63, v64, v65, v66);
        *(_DWORD *)buf = 136446210;
        v84 = objc_msgSend_UTF8String(v67, v68, v69, v70, v71);
        _os_log_impl(&dword_18F1DC000, v62, OS_LOG_TYPE_FAULT, "Invalid parameters received:\n%{public}s", buf, 0xCu);
      }
      v72 = sub_18F1FCA08(115, 0);
      result = 0;
      if (v72)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D8C8 != -1)
          dispatch_once(&qword_1EE16D8C8, &unk_1E2945040);
        v77 = (void *)objc_msgSend_description(v1, v73, v74, v75, v76);
        objc_msgSend_UTF8String(v77, v78, v79, v80, v81);
        v82 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "static BOOL CLOnBodyNotifier_Type::Params::isValid(NSDictionary *)", "CoreLocation: %s\n", v82);
        if (v82 != (char *)buf)
          free(v82);
        return 0;
      }
    }
  }
  return result;
}

os_log_t sub_18F4427DC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "OnBody");
  qword_1EE16D8D0 = (uint64_t)result;
  return result;
}

void sub_18F44280C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_18F449C18(a1, a2, a3, a4, a5);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F442830(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  char *v15;
  void *__p[2];
  char v17;
  const __CFString *v18;
  uint64_t v19;
  uint8_t buf[8];
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (*a2)
    return 1;
  if (!*(_QWORD *)(a1 + 112))
  {
    *(_QWORD *)(a1 + 120) = dispatch_queue_create("com.apple.CoreMotion.CLGeomagneticModelProviderClientPrivateQueue", 0);
    v5 = operator new();
    sub_18F270374(__p, "com.apple.locationd.registration");
    MEMORY[0x19400100C](v5, __p, *(_QWORD *)(a1 + 120));
    *(_QWORD *)(a1 + 112) = v5;
    if (v17 < 0)
      operator delete(__p[0]);
    sub_18F270374(buf, "kCLConnectionMessageGmm");
    CLConnectionClient::setHandlerForMessage();
    if (v21 < 0)
      operator delete(*(void **)buf);
    CLConnectionClient::setDefaultMessageHandler();
    CLConnectionClient::start(*(CLConnectionClient **)(a1 + 112));
    v18 = CFSTR("kCLConnectionMessageSubscribeKey");
    v19 = MEMORY[0x1E0C9AAB0];
    v7 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v6, (uint64_t)&v19, (uint64_t)&v18, 1);
    v8 = (std::__shared_weak_count *)operator new(0x70uLL);
    v8->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    v8->__shared_weak_owners_ = 0;
    v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E2952688;
    sub_18F270374(buf, "kCLConnectionMessageGmm");
    MEMORY[0x19400103C](&v8[1], buf, v7);
    if (v21 < 0)
      operator delete(*(void **)buf);
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    CLConnectionClient::sendMessage();
    if (v8)
    {
      v11 = (unint64_t *)&v8->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    if (v8)
    {
      v13 = (unint64_t *)&v8->__shared_owners_;
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    return 1;
  }
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2958068);
  v4 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "fLocationdConnection is not NULL", buf, 2u);
  }
  result = sub_18F1FCA08(115, 0);
  if ((_DWORD)result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2958068);
    v15 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "virtual BOOL CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf)
      free(v15);
    return 0;
  }
  return result;
}

void sub_18F442BE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  sub_18F2A8438((uint64_t)&a11);
  sub_18F2A8438((uint64_t)&a13);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F442C84(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v2;
  const __CFDictionary *Dictionary;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  NSObject *v8;
  char *v10;
  _QWORD v11[5];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int16 v16;
  _OWORD v17[4];
  _QWORD v18[2];
  uint8_t buf[1640];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  Dictionary = (const __CFDictionary *)CLConnectionMessage::getDictionary(*a2);
  sub_18F1EDCF0(v18, Dictionary);
  if ((*(int (**)(_QWORD *))(v18[0] + 856))(v18) >= 1
    && (sub_18F440CBC((uint64_t)v17, (uint64_t)v18) & 1) != 0)
  {
    v7 = *(void **)(v2 + 40);
    v11[1] = 3221225472;
    v12 = v17[0];
    v13 = v17[1];
    v11[0] = MEMORY[0x1E0C809B0];
    v11[2] = sub_18F442EC8;
    v11[3] = &unk_1E2958028;
    v11[4] = v2;
    v14 = v17[2];
    v15 = v17[3];
    objc_msgSend_async_(v7, v4, (uint64_t)v11, v5, v6);
  }
  else
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2958068);
    v8 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "Could not get geomagnetic model data for message!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2958068);
      v16 = 0;
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual BOOL CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)_block_invoke", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
  }
  return sub_18F1EDCB4(v18);
}

void sub_18F442EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  sub_18F1EDCB4(&a35);
  _Unwind_Resume(a1);
}

uint64_t sub_18F442EC8(uint64_t a1)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;
  int v5;
  _OWORD v6[4];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_OWORD *)(a1 + 56);
  v6[0] = *(_OWORD *)(a1 + 40);
  v6[1] = v2;
  v3 = *(_OWORD *)(a1 + 88);
  v6[2] = *(_OWORD *)(a1 + 72);
  v6[3] = v3;
  v5 = 0;
  return (*(uint64_t (**)(uint64_t, int *, _OWORD *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v1 + 152))(v1, &v5, v6, 1, 0xFFFFFFFFLL, 0);
}

void sub_18F442F24(uint64_t a1, CLConnectionMessage **a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2958068);
  v3 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0)
      v5 = v4;
    else
      v5 = *(_QWORD *)v4;
    *(_DWORD *)buf = 136315138;
    v8 = v5;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %s", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2958068);
    CLConnectionMessage::name(*a2);
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual BOOL CLGeomagneticModelProviderClient::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf)
      free(v6);
  }
}

uint64_t sub_18F443100(uint64_t a1, _DWORD *a2)
{
  uint64_t v3;
  uint64_t result;
  NSObject *v5;
  int v6;
  char *v7;
  uint8_t buf[1640];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*a2)
    return 1;
  if (*(_QWORD *)(a1 + 112))
  {
    v3 = MEMORY[0x194001018]();
    MEMORY[0x194001438](v3, 0xB0C40BC2CC919);
    *(_QWORD *)(a1 + 112) = 0;
    dispatch_release(*(dispatch_object_t *)(a1 + 120));
    *(_QWORD *)(a1 + 120) = 0;
    return 1;
  }
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2958068);
  v5 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_FAULT, "fLocationdConnection is NULL", buf, 2u);
  }
  v6 = sub_18F1FCA08(115, 0);
  result = 0;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2958068);
    v7 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "virtual BOOL CLGeomagneticModelProviderClient::unregisterForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf)
      free(v7);
    return 0;
  }
  return result;
}

uint64_t sub_18F4432D0(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unsigned int *v3;
  uint64_t **v4;
  _QWORD *v5;
  int *v7;
  _QWORD v8[2];
  uint64_t *v9;
  _DWORD *v10;

  if (*(_BYTE *)(a1 + 108))
    return 0xFFFFFFFFLL;
  v7 = (int *)v8;
  v8[0] = 0;
  v8[1] = 0;
  v9 = a2;
  v3 = (unsigned int *)(a1 + 104);
  ++*(_DWORD *)(a1 + 104);
  v10 = (_DWORD *)(a1 + 104);
  v4 = sub_18F3BE50C((uint64_t **)(a1 + 80), (int *)(a1 + 104), (uint64_t)&unk_18F506652, &v10);
  if (v4 + 5 != (uint64_t **)&v7)
    sub_18F3BE7C4(v4 + 5, v7, (int *)v8);
  v5 = (_QWORD *)v8[0];
  v4[8] = v9;
  v2 = *v3;
  sub_18F3BEA38((uint64_t)&v7, v5);
  return v2;
}

void sub_18F443380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10)
{
  sub_18F3BEA38((uint64_t)&a9, a10);
  _Unwind_Resume(a1);
}

void sub_18F443398(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t *v9;
  NSObject *v10;
  _QWORD *v11;
  _QWORD *v12;
  char *v13;
  int v14[2];
  _QWORD *v15;
  __int16 v16;
  int v17;
  uint8_t buf[4];
  _QWORD *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v14[0] = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    v4 = *(_QWORD *)(a1 + 88);
    if (!v4)
      goto LABEL_12;
    v5 = a1 + 80;
    v6 = a1 + 88;
    do
    {
      v7 = *(_DWORD *)(v4 + 32);
      v8 = v7 < (int)a2;
      if (v7 >= (int)a2)
        v9 = (uint64_t *)v4;
      else
        v9 = (uint64_t *)(v4 + 8);
      if (!v8)
        v6 = v4;
      v4 = *v9;
    }
    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(_QWORD *)(v6 + 56))
      {
        *(_DWORD *)buf = *(_DWORD *)(*(_QWORD *)(v6 + 40) + 28);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(_QWORD *)a1 + 112))(a1, a2, buf);
      }
      sub_18F3BEB30(v5, v14);
    }
    else
    {
LABEL_12:
      if (qword_1EE16D448 != -1)
        dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
      v10 = qword_1EE16D440;
      if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_FAULT))
      {
        v11 = (_QWORD *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0)
          v11 = (_QWORD *)*v11;
        *(_DWORD *)buf = 136446466;
        v19 = v11;
        v20 = 1026;
        v21 = a2;
        _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D448 != -1)
          dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
        v12 = (_QWORD *)(a1 + 8);
        if (*(char *)(a1 + 31) < 0)
          v12 = (_QWORD *)*v12;
        v14[1] = 136446466;
        v15 = v12;
        v16 = 1026;
        v17 = a2;
        v13 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::removeClient(int) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v13);
        if (v13 != (char *)buf)
          free(v13);
      }
    }
  }
}

uint64_t sub_18F44360C(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v7;
  int v9;
  int v10;

  v7 = sub_18F3BEFC4(a4);
  if (v7)
  {
    v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t))(*(_QWORD *)a1 + 96))(a1, a2, &v10, v7);
  }
  else
  {
    v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a1 + 88))(a1, a2, &v9);
  }
}

uint64_t sub_18F44368C(uint64_t a1, uint64_t a2, int a3)
{
  int v4;

  v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a1 + 104))(a1, a2, &v4);
}

uint64_t sub_18F4436B8(uint64_t a1, uint64_t a2, int a3)
{
  int v4;

  v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(_QWORD *)a1 + 112))(a1, a2, &v4);
}

uint64_t sub_18F4436E4(uint64_t a1, int a2)
{
  int v3;

  v3 = a2;
  return (*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)a1 + 120))(a1, &v3);
}

uint64_t sub_18F443710(uint64_t a1)
{
  uint64_t result;
  CLNotifierServiceAdapter *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;

  result = *(_QWORD *)(a1 + 48);
  if (!result)
  {
    v3 = objc_alloc_init(CLNotifierServiceAdapter);
    *(_QWORD *)(a1 + 48) = v3;
    objc_msgSend_setValid_(v3, v4, 1, v5, v6);
    objc_msgSend_setAdaptedNotifier_(*(void **)(a1 + 48), v7, a1, v8, v9);
    return *(_QWORD *)(a1 + 48);
  }
  return result;
}

uint64_t sub_18F44375C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(_QWORD *)a1 + 96))(a1, a2, a3, &unk_1EE16DFF8);
}

uint64_t sub_18F443770(uint64_t a1, int a2, int *a3, char *a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v10;
  int v11;
  BOOL v12;
  uint64_t *v13;
  NSObject *v14;
  _QWORD *v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  uint64_t *v29;
  char v30;
  uint64_t **v31;
  char v32;
  uint64_t **v33;
  uint64_t v34;
  char v35;
  void *v36;
  _QWORD *v37;
  char *v38;
  int v39;
  uint64_t v40;
  int v41;
  _BYTE v42[12];
  __int16 v43;
  int v44;
  uint8_t buf[32];
  __int128 v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v41 = a2;
  if (*(_BYTE *)(a1 + 108))
    return 0;
  v7 = *(_QWORD *)(a1 + 88);
  if (v7)
  {
    v10 = a1 + 88;
    do
    {
      v11 = *(_DWORD *)(v7 + 32);
      v12 = v11 < a2;
      if (v11 >= a2)
        v13 = (uint64_t *)v7;
      else
        v13 = (uint64_t *)(v7 + 8);
      if (!v12)
        v10 = v7;
      v7 = *v13;
    }
    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(_QWORD *)v42 = v10;
      v17 = *a3;
      v20 = *(_QWORD *)(v10 + 48);
      v19 = v10 + 48;
      v18 = v20;
      if (!v20)
        goto LABEL_31;
      v21 = v19;
      do
      {
        v22 = *(_DWORD *)(v18 + 28);
        v23 = v22 < v17;
        if (v22 >= v17)
          v24 = (uint64_t *)v18;
        else
          v24 = (uint64_t *)(v18 + 8);
        if (!v23)
          v21 = v18;
        v18 = *v24;
      }
      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28))
LABEL_31:
        v21 = v19;
      v25 = *(_QWORD *)(a1 + 64);
      if (!v25)
        goto LABEL_42;
      v26 = a1 + 64;
      do
      {
        v27 = *(_DWORD *)(v25 + 32);
        v28 = v27 < v17;
        if (v27 >= v17)
          v29 = (uint64_t *)v25;
        else
          v29 = (uint64_t *)(v25 + 8);
        if (!v28)
          v26 = v25;
        v25 = *v29;
      }
      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        v40 = v26;
        v34 = *(_QWORD *)(v26 + 56);
        v35 = *a4;
        *(_QWORD *)buf = &v41;
        *((_BYTE *)sub_18F3BFD00((uint64_t **)(v26 + 40), &v41, (uint64_t)&unk_18F506652, (_DWORD **)buf) + 32) = v35;
        v46 = 0u;
        v47 = 0u;
        memset(buf, 0, sizeof(buf));
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, uint8_t *))(*(_QWORD *)a1 + 128))(a1, a3, buf))
        {
          v36 = (void *)sub_18F446044(buf);
          sub_18F44548C(a1, (uint64_t)v42, (uint64_t)&v40, v36);
        }
        if (v34)
          goto LABEL_44;
      }
      else
      {
LABEL_42:
        v40 = a1 + 64;
        v30 = byte_1EE16DFF9;
        v39 = v17;
        *(_QWORD *)buf = &v39;
        *((_BYTE *)sub_18F3BFBA0((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_18F506652, (_DWORD **)buf) + 80) = v30;
        v39 = *a3;
        *(_QWORD *)buf = &v39;
        v31 = sub_18F3BFBA0((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_18F506652, (_DWORD **)buf);
        sub_18F3A4658(v31 + 8);
        v32 = *a4;
        v39 = *a3;
        *(_QWORD *)buf = &v39;
        v33 = sub_18F3BFBA0((uint64_t **)(a1 + 56), &v39, (uint64_t)&unk_18F506652, (_DWORD **)buf);
        *(_QWORD *)buf = &v41;
        *((_BYTE *)sub_18F3BFD00(v33 + 5, &v41, (uint64_t)&unk_18F506652, (_DWORD **)buf) + 32) = v32;
      }
      (*(void (**)(uint64_t, int *))(*(_QWORD *)a1 + 168))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        *(_DWORD *)buf = *a3;
        sub_18F3C07FC((uint64_t **)(*(_QWORD *)v42 + 40), (int *)buf, buf);
      }
      return 1;
    }
  }
  if (qword_1EE16D448 != -1)
    dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
  v14 = qword_1EE16D440;
  if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_FAULT))
  {
    v15 = (_QWORD *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0)
      v15 = (_QWORD *)*v15;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v15;
    *(_WORD *)&buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist", buf, 0x12u);
  }
  v16 = sub_18F1FCA08(115, 0);
  result = 0;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D448 != -1)
      dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
    v37 = (_QWORD *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0)
      v37 = (_QWORD *)*v37;
    *(_DWORD *)v42 = 136446466;
    *(_QWORD *)&v42[4] = v37;
    v43 = 1026;
    v44 = a2;
    v38 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v38);
    if (v38 != (char *)buf)
      free(v38);
    return 0;
  }
  return result;
}

BOOL sub_18F443BD0(uint64_t a1, int a2, int *a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t *v9;
  NSObject *v10;
  _QWORD *v11;
  int v12;
  _BOOL8 result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  uint64_t *v21;
  char *v22;
  uint8_t buf[4];
  _QWORD *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 88);
  if (!v5)
    goto LABEL_11;
  v6 = a1 + 88;
  do
  {
    v7 = *(_DWORD *)(v5 + 32);
    v8 = v7 < a2;
    if (v7 >= a2)
      v9 = (uint64_t *)v5;
    else
      v9 = (uint64_t *)(v5 + 8);
    if (!v8)
      v6 = v5;
    v5 = *v9;
  }
  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    v16 = *(_QWORD *)(v6 + 48);
    v14 = v6 + 48;
    v15 = v16;
    if (!v16)
      goto LABEL_29;
    v17 = *a3;
    v18 = v14;
    do
    {
      v19 = *(_DWORD *)(v15 + 28);
      v20 = v19 < v17;
      if (v19 >= v17)
        v21 = (uint64_t *)v15;
      else
        v21 = (uint64_t *)(v15 + 8);
      if (!v20)
        v18 = v15;
      v15 = *v21;
    }
    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28))
LABEL_29:
      v18 = v14;
    return v18 != v14;
  }
  else
  {
LABEL_11:
    if (qword_1EE16D448 != -1)
      dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
    v10 = qword_1EE16D440;
    if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_FAULT))
    {
      v11 = (_QWORD *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0)
        v11 = (_QWORD *)*v11;
      *(_DWORD *)buf = 136446466;
      v24 = v11;
      v25 = 1026;
      v26 = a2;
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_FAULT, "%{public}s; client %{public}d does not exist", buf, 0x12u);
    }
    v12 = sub_18F1FCA08(115, 0);
    result = 0;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D448 != -1)
        dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
      v22 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf)
        free(v22);
      return 0;
    }
  }
  return result;
}

BOOL sub_18F443E50(char *a1, int a2, int *a3)
{
  int v3;
  uint64_t v6;
  char *v8;
  int v9;
  BOOL v10;
  uint64_t *v11;
  char *v12;
  char *v13;
  char *v14;
  int v15;
  char *v16;
  int v17;
  BOOL v18;
  char **v19;
  uint64_t v20;
  int v21;
  char *v22;
  int v23;
  BOOL v24;
  uint64_t *v25;
  NSObject *v26;
  _QWORD *v27;
  void **v28;
  _QWORD *v29;
  _BYTE *v30;
  char *v31;
  int v32;
  _BYTE buf[12];
  __int16 v34;
  void **v35;
  char v36;
  int v37;
  _QWORD *v38;
  __int16 v39;
  _BYTE *v40;
  void *__p[2];
  char v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v32 = a2;
  v3 = a1[108];
  if (!a1[108])
  {
    v6 = *((_QWORD *)a1 + 11);
    if (v6)
    {
      v8 = a1 + 88;
      do
      {
        v9 = *(_DWORD *)(v6 + 32);
        v10 = v9 < a2;
        if (v9 >= a2)
          v11 = (uint64_t *)v6;
        else
          v11 = (uint64_t *)(v6 + 8);
        if (!v10)
          v8 = (char *)v6;
        v6 = *v11;
      }
      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        v14 = (char *)*((_QWORD *)v8 + 6);
        v12 = v8 + 48;
        v13 = v14;
        if (v14)
        {
          v15 = *a3;
          v16 = v12;
          do
          {
            v17 = *((_DWORD *)v13 + 7);
            v18 = v17 < v15;
            if (v17 >= v15)
              v19 = (char **)v13;
            else
              v19 = (char **)(v13 + 8);
            if (!v18)
              v16 = v13;
            v13 = *v19;
          }
          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_18F3C08B4((uint64_t)(v12 - 8), (int *)__p);
            v20 = *((_QWORD *)a1 + 8);
            if (!v20)
              goto LABEL_33;
            v21 = *a3;
            v22 = a1 + 64;
            do
            {
              v23 = *(_DWORD *)(v20 + 32);
              v24 = v23 < v21;
              if (v23 >= v21)
                v25 = (uint64_t *)v20;
              else
                v25 = (uint64_t *)(v20 + 8);
              if (!v24)
                v22 = (char *)v20;
              v20 = *v25;
            }
            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_18F3C08B4((uint64_t)(v22 + 40), &v32);
              if (!*((_QWORD *)v22 + 7))
                (*(void (**)(char *, int *))(*(_QWORD *)a1 + 176))(a1, a3);
            }
            else
            {
LABEL_33:
              if (qword_1EE16D448 != -1)
                dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
              v26 = qword_1EE16D440;
              if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_FAULT))
              {
                v27 = a1 + 8;
                if (a1[31] < 0)
                  v27 = (_QWORD *)*v27;
                (*(void (**)(void **__return_ptr, char *, int *))(*(_QWORD *)a1 + 160))(__p, a1, a3);
                if (v42 >= 0)
                  v28 = __p;
                else
                  v28 = (void **)__p[0];
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = v27;
                v34 = 2082;
                v35 = v28;
                _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_FAULT, "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v42 < 0)
                  operator delete(__p[0]);
              }
              if (sub_18F1FCA08(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1EE16D448 != -1)
                  dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
                v29 = a1 + 8;
                if (a1[31] < 0)
                  v29 = (_QWORD *)*v29;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(_QWORD *)a1 + 160))(buf, a1, a3);
                if (v36 >= 0)
                  v30 = buf;
                else
                  v30 = *(_BYTE **)buf;
                v37 = 136446466;
                v38 = v29;
                v39 = 2082;
                v40 = v30;
                v31 = (char *)_os_log_send_and_compose_impl();
                if (v36 < 0)
                  operator delete(*(void **)buf);
                sub_18F419700("Generic", 1, 0, 0, "virtual BOOL CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v31);
                if (v31 != (char *)__p)
                  free(v31);
              }
            }
          }
        }
      }
    }
  }
  return v3 == 0;
}

void sub_18F4441D8(uint64_t a1, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t *v9;

  v4 = *(_QWORD *)(a1 + 64);
  v2 = a1 + 64;
  v3 = v4;
  if (v4)
  {
    v5 = *a2;
    v6 = v2;
    do
    {
      v7 = *(_DWORD *)(v3 + 32);
      v8 = v7 < v5;
      if (v7 >= v5)
        v9 = (uint64_t *)v3;
      else
        v9 = (uint64_t *)(v3 + 8);
      if (!v8)
        v6 = v3;
      v3 = *v9;
    }
    while (*v9);
    if (v6 != v2 && v5 >= *(_DWORD *)(v6 + 32))
      sub_18F3A4658((_QWORD *)(v6 + 64));
  }
}

uint64_t sub_18F444224(uint64_t a1, int *a2, _OWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  BOOL v9;
  uint64_t *v10;
  __int128 *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v5 = *(_QWORD *)(a1 + 64);
  v3 = a1 + 64;
  v4 = v5;
  if (!v5)
    return 0;
  v6 = *a2;
  v7 = v3;
  do
  {
    v8 = *(_DWORD *)(v4 + 32);
    v9 = v8 < v6;
    if (v8 >= v6)
      v10 = (uint64_t *)v4;
    else
      v10 = (uint64_t *)(v4 + 8);
    if (!v9)
      v7 = v4;
    v4 = *v10;
  }
  while (*v10);
  if (v7 == v3)
    return 0;
  if (v6 < *(_DWORD *)(v7 + 32))
    return 0;
  v11 = *(__int128 **)(v7 + 64);
  if (!v11)
    return 0;
  v12 = *v11;
  v13 = v11[1];
  v14 = v11[3];
  a3[2] = v11[2];
  a3[3] = v14;
  *a3 = v12;
  a3[1] = v13;
  return 1;
}

uint64_t sub_18F44428C(uint64_t a1, int *a2, _OWORD *a3)
{
  char *v6;
  __int128 v7;
  __int128 v8;
  uint64_t **v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  int v14;
  __int128 v15;
  int *v16;

  v6 = (char *)operator new(0x58uLL);
  v7 = a3[1];
  *(_OWORD *)(v6 + 24) = *a3;
  *(_OWORD *)(v6 + 40) = v7;
  v8 = a3[3];
  *(_OWORD *)(v6 + 56) = a3[2];
  *((_QWORD *)v6 + 1) = 0;
  *((_QWORD *)v6 + 2) = 0;
  *(_QWORD *)v6 = &off_1E2952730;
  *(_OWORD *)(v6 + 72) = v8;
  *(_QWORD *)&v15 = v6 + 24;
  *((_QWORD *)&v15 + 1) = v6;
  v14 = *a2;
  v16 = &v14;
  v9 = sub_18F3BFBA0((uint64_t **)(a1 + 56), &v14, (uint64_t)&unk_18F506652, &v16);
  sub_18F346DC8((uint64_t)(v9 + 8), &v15);
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
  if (*((_QWORD *)&v15 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  return 1;
}

void sub_18F44436C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_18F444380(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _OWORD v5[4];

  memset(v5, 0, sizeof(v5));
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 152))(a1, a2, v5, a3, a4, 0);
}

void sub_18F4443C0(uint64_t a1, unsigned int *a2, _OWORD *a3, int a4, int a5)
{
  NSObject *v10;
  NSObject *v11;
  _QWORD *v12;
  std::__shared_weak_count *v13;
  __n128 *v14;
  __n128 *v15;
  signed __int32 v16;
  __n128 *v17;
  signed __int32 v18;
  BOOL v19;
  __n128 **v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  char *v27;
  __int128 v28;
  __int128 v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  BOOL v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  BOOL v44;
  uint64_t *v45;
  NSObject *v46;
  _QWORD *v47;
  _BYTE *v48;
  _QWORD *v49;
  void **v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  BOOL v58;
  uint64_t *v59;
  void *__p[2];
  char v61;
  uint64_t v62;
  uint64_t v63;
  os_activity_scope_state_s state;
  _BYTE buf[28];
  __int16 v66;
  _QWORD *v67;
  __int16 v68;
  std::__shared_weak_count *v69;
  _BYTE v70[32];
  std::__shared_weak_count *v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 108))
  {
    v10 = _os_activity_create(&dword_18F1DC000, "CL: notifyClientsWithData (Fallback)", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1EE16D448 != -1)
      dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
    v11 = qword_1EE16D440;
    if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_DEBUG))
    {
      v12 = (_QWORD *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0)
        v12 = (_QWORD *)*v12;
      v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)buf = 68289794;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = "activity";
      v66 = 2082;
      v67 = v12;
      v68 = 2050;
      v69 = v13;
      _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"notifyClientsWithData\", \"event\":%{public, location:escape_only}s, \"name\":%{public, location:escape_only}s, \"notification\":%{public}lld}", buf, 0x30u);
    }
    v15 = (__n128 *)(a1 + 64);
    v14 = *(__n128 **)(a1 + 64);
    if (!v14)
      goto LABEL_18;
    v16 = *a2;
    v17 = (__n128 *)(a1 + 64);
    do
    {
      v18 = v14[2].n128_i32[0];
      v19 = v18 < v16;
      if (v18 >= v16)
        v20 = (__n128 **)v14;
      else
        v20 = (__n128 **)&v14->n128_u64[1];
      if (!v19)
        v17 = v14;
      v14 = *v20;
    }
    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(_QWORD *)v70 = &v70[8];
      memset(&v70[8], 0, 24);
      v71 = 0;
      sub_18F3C0F58((uint64_t)buf, a2, (uint64_t)v70);
      v17 = sub_18F3C0E18((uint64_t **)(a1 + 56), (__n128 *)buf);
      v21 = v69;
      if (v69)
      {
        p_shared_owners = (unint64_t *)&v69->__shared_owners_;
        do
          v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      sub_18F3BEA38((uint64_t)&buf[8], *(_QWORD **)&buf[16]);
      v24 = v71;
      if (v71)
      {
        v25 = (unint64_t *)&v71->__shared_owners_;
        do
          v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      sub_18F3BEA38((uint64_t)v70, *(_QWORD **)&v70[8]);
    }
    if (a4)
    {
      v27 = (char *)operator new(0x58uLL);
      v28 = a3[1];
      *(_OWORD *)(v27 + 24) = *a3;
      *(_OWORD *)(v27 + 40) = v28;
      v29 = a3[3];
      *(_OWORD *)(v27 + 56) = a3[2];
      *((_QWORD *)v27 + 1) = 0;
      *((_QWORD *)v27 + 2) = 0;
      *(_QWORD *)v27 = &off_1E2952730;
      *(_OWORD *)(v27 + 72) = v29;
      *(_QWORD *)buf = v27 + 24;
      *(_QWORD *)&buf[8] = v27;
      sub_18F346DC8((uint64_t)&v17[4], (__int128 *)buf);
      v30 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v31 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
    }
    else
    {
      sub_18F3A4658((__n128 *)v17[4].n128_u64);
    }
    if (!v17[3].n128_u64[1])
      goto LABEL_83;
    v33 = (void *)sub_18F445020(a3);
    if (a5 == -1)
    {
      sub_18F4450B8(a1, (int *)a2, v33);
    }
    else
    {
      v34 = a1 + 88;
      v35 = *(_QWORD *)(a1 + 88);
      if (!v35)
        goto LABEL_48;
      v36 = a1 + 88;
      do
      {
        v37 = *(_DWORD *)(v35 + 32);
        v38 = v37 < a5;
        if (v37 >= a5)
          v39 = (uint64_t *)v35;
        else
          v39 = (uint64_t *)(v35 + 8);
        if (!v38)
          v36 = v35;
        v35 = *v39;
      }
      while (*v39);
      if (v36 == v34 || *(_DWORD *)(v36 + 32) > a5)
LABEL_48:
        v36 = a1 + 88;
      v63 = v36;
      v40 = v15->n128_u64[0];
      if (!v15->n128_u64[0])
        goto LABEL_59;
      v41 = *a2;
      v42 = a1 + 64;
      do
      {
        v43 = *(_DWORD *)(v40 + 32);
        v44 = v43 < v41;
        if (v43 >= v41)
          v45 = (uint64_t *)v40;
        else
          v45 = (uint64_t *)(v40 + 8);
        if (!v44)
          v42 = v40;
        v40 = *v45;
      }
      while (*v45);
      if ((__n128 *)v42 == v15 || v41 < *(_DWORD *)(v42 + 32))
      {
LABEL_59:
        v62 = a1 + 64;
LABEL_60:
        if (qword_1EE16D448 != -1)
          dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
        v46 = qword_1EE16D440;
        if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_DEBUG))
        {
          v47 = (_QWORD *)(a1 + 8);
          if (*(char *)(a1 + 31) < 0)
            v47 = (_QWORD *)*v47;
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(_QWORD *)a1 + 160))(v70, a1, a2);
          if (v70[23] >= 0)
            v48 = v70;
          else
            v48 = *(_BYTE **)v70;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = v47;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v48;
          _os_log_impl(&dword_18F1DC000, v46, OS_LOG_TYPE_DEBUG, "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v70[23] & 0x80000000) != 0)
            operator delete(*(void **)v70);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D448 != -1)
            dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
          v49 = (_QWORD *)(a1 + 8);
          if (*(char *)(a1 + 31) < 0)
            v49 = (_QWORD *)*v49;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(_QWORD *)a1 + 160))(__p, a1, a2);
          if (v61 >= 0)
            v50 = __p;
          else
            v50 = (void **)__p[0];
          *(_DWORD *)v70 = 136315650;
          *(_QWORD *)&v70[4] = v49;
          *(_WORD *)&v70[12] = 1024;
          *(_DWORD *)&v70[14] = a5;
          *(_WORD *)&v70[18] = 2080;
          *(_QWORD *)&v70[20] = v50;
          v51 = (char *)_os_log_send_and_compose_impl();
          if (v61 < 0)
            operator delete(__p[0]);
          sub_18F419700("Generic", 1, 0, 2, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v51);
          if (v51 != buf)
            free(v51);
        }
        goto LABEL_83;
      }
      v62 = v42;
      if (v36 == v34)
        goto LABEL_60;
      v54 = *(_QWORD *)(v42 + 48);
      v52 = v42 + 48;
      v53 = v54;
      if (!v54)
        goto LABEL_60;
      v55 = *(_DWORD *)(v36 + 32);
      v56 = v52;
      do
      {
        v57 = *(_DWORD *)(v53 + 28);
        v58 = v57 < v55;
        if (v57 >= v55)
          v59 = (uint64_t *)v53;
        else
          v59 = (uint64_t *)(v53 + 8);
        if (!v58)
          v56 = v53;
        v53 = *v59;
      }
      while (*v59);
      if (v56 == v52 || v55 < *(_DWORD *)(v56 + 28))
        goto LABEL_60;
      sub_18F44548C(a1, (uint64_t)&v63, (uint64_t)&v62, v33);
    }
LABEL_83:
    os_activity_scope_leave(&state);
  }
}

void sub_18F444A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t sub_18F444A58()
{
  return 1;
}

void sub_18F444A60(uint64_t a1)
{
  NSObject *v2;
  _QWORD *v3;
  char *v4;
  NSObject *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  NSObject *v10;
  _QWORD *v11;
  int v12;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  BOOL v16;
  char *v17;
  _QWORD *v18;
  _QWORD *v19;
  char *v20;
  uint8_t buf[4];
  _QWORD *v22;
  __int16 v23;
  _QWORD v24[204];

  *(_QWORD *)((char *)&v24[202] + 2) = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1EE16D448 != -1)
      dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
    v2 = qword_1EE16D440;
    if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_DEBUG))
    {
      v3 = (_QWORD *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0)
        v3 = (_QWORD *)*v3;
      *(_DWORD *)buf = 136315138;
      v22 = v3;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "%s; already shutdown; not listing clients", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D448 != -1)
        dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
      v4 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf)
        free(v4);
    }
  }
  else
  {
    if (qword_1EE16D448 != -1)
      dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
    v5 = qword_1EE16D440;
    if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_DEBUG))
    {
      v6 = (_QWORD *)(a1 + 8);
      if (*(char *)(a1 + 31) < 0)
        v6 = (_QWORD *)*v6;
      v7 = *(_QWORD *)(a1 + 96);
      *(_DWORD *)buf = 136315394;
      v22 = v6;
      v23 = 2048;
      v24[0] = v7;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEBUG, "%s; listing clients, num clients: %zu", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D448 != -1)
        dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
      v20 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf)
        free(v20);
    }
    v8 = *(_QWORD **)(a1 + 80);
    if (v8 != (_QWORD *)(a1 + 88))
    {
      do
      {
        v9 = (_QWORD *)v8[5];
        if (v9 != v8 + 6)
        {
          do
          {
            if (qword_1EE16D448 != -1)
              dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
            v10 = qword_1EE16D440;
            if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_DEBUG))
            {
              v11 = (_QWORD *)(a1 + 8);
              if (*(char *)(a1 + 31) < 0)
                v11 = *(_QWORD **)(a1 + 8);
              v12 = *((_DWORD *)v8 + 8);
              v13 = *((_DWORD *)v9 + 7);
              *(_DWORD *)buf = 136315650;
              v22 = v11;
              v23 = 1024;
              LODWORD(v24[0]) = v12;
              WORD2(v24[0]) = 1024;
              *(_DWORD *)((char *)v24 + 6) = v13;
              _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEBUG, "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1EE16D448 != -1)
                dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
              v17 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v17);
              if (v17 != (char *)buf)
                free(v17);
            }
            v14 = (_QWORD *)v9[1];
            if (v14)
            {
              do
              {
                v15 = v14;
                v14 = (_QWORD *)*v14;
              }
              while (v14);
            }
            else
            {
              do
              {
                v15 = (_QWORD *)v9[2];
                v16 = *v15 == (_QWORD)v9;
                v9 = v15;
              }
              while (!v16);
            }
            v9 = v15;
          }
          while (v15 != v8 + 6);
        }
        v18 = (_QWORD *)v8[1];
        if (v18)
        {
          do
          {
            v19 = v18;
            v18 = (_QWORD *)*v18;
          }
          while (v18);
        }
        else
        {
          do
          {
            v19 = (_QWORD *)v8[2];
            v16 = *v19 == (_QWORD)v8;
            v8 = v19;
          }
          while (!v16);
        }
        v8 = v19;
      }
      while (v19 != (_QWORD *)(a1 + 88));
    }
  }
}

double sub_18F445008@<D0>(uint64_t a1@<X8>)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0xBFF0000000000000;
  return result;
}

uint64_t sub_18F445020(_OWORD *a1)
{
  _OWORD *v2;
  __int128 v3;
  __int128 v4;
  const char *v5;
  _QWORD v7[5];

  v2 = (_OWORD *)operator new();
  v3 = a1[1];
  *v2 = *a1;
  v2[1] = v3;
  v4 = a1[3];
  v2[2] = a1[2];
  v2[3] = v4;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = sub_18F4455DC;
  v7[3] = &unk_1E2955738;
  v7[4] = v2;
  return objc_msgSend_containerWithObject_destructor_binaryVersion_typeSize_(MEMORY[0x1E0D44518], v5, (uint64_t)v2, (uint64_t)v7, 0, 64);
}

void sub_18F4450B8(uint64_t a1, int *a2, void *a3)
{
  uint64_t v4;
  uint64_t v5;
  int v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  uint64_t *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  uint64_t *v22;
  int v23;
  NSObject *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  BOOL v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  int v37;
  BOOL v38;
  uint64_t *v39;
  int v40;
  BOOL v41;
  uint64_t *v42;
  _QWORD *v43;
  BOOL v44;
  uint64_t v45;
  int v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  __int16 v52;
  int v53;
  uint8_t buf[4];
  uint64_t v55;
  __int16 v56;
  int v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 108))
  {
    v5 = a1 + 64;
    v4 = *(_QWORD *)(a1 + 64);
    if (v4)
    {
      v8 = *a2;
      v9 = a1 + 64;
      do
      {
        v10 = *(_DWORD *)(v4 + 32);
        v11 = v10 < v8;
        if (v10 >= v8)
          v12 = (uint64_t *)v4;
        else
          v12 = (uint64_t *)(v4 + 8);
        if (!v11)
          v9 = v4;
        v4 = *v12;
      }
      while (*v12);
      if (v9 != v5 && v8 >= *(_DWORD *)(v9 + 32))
      {
        v49 = v9;
        v13 = sub_18F4455FC(a3);
        (*(void (**)(uint64_t, int *, uint64_t, uint64_t))(*(_QWORD *)a1 + 184))(a1, a2, v13, v9 + 80);
        v14 = *(_QWORD **)(v9 + 40);
        if (v14 != (_QWORD *)(v9 + 48))
        {
          v15 = (uint64_t *)(a1 + 88);
          v16 = (uint64_t *)(a1 + 8);
          do
          {
            v17 = *v15;
            if (!*v15)
              goto LABEL_25;
            v18 = *((_DWORD *)v14 + 7);
            v19 = a1 + 88;
            do
            {
              v20 = *(_DWORD *)(v17 + 32);
              v21 = v20 < v18;
              if (v20 >= v18)
                v22 = (uint64_t *)v17;
              else
                v22 = (uint64_t *)(v17 + 8);
              if (!v21)
                v19 = v17;
              v17 = *v22;
            }
            while (*v22);
            if ((uint64_t *)v19 != v15 && (v23 = *(_DWORD *)(v19 + 32), v18 >= v23))
            {
              v48 = v19;
              sub_18F44548C(a1, (uint64_t)&v48, (uint64_t)&v49, a3);
              v27 = *(_QWORD *)(a1 + 64);
              if (!v27)
                return;
              v28 = *a2;
              v29 = v5;
              do
              {
                v30 = *(_DWORD *)(v27 + 32);
                v31 = v30 < v28;
                if (v30 >= v28)
                  v32 = (uint64_t *)v27;
                else
                  v32 = (uint64_t *)(v27 + 8);
                if (!v31)
                  v29 = v27;
                v27 = *v32;
              }
              while (*v32);
              if (v29 == v5 || v28 < *(_DWORD *)(v29 + 32))
                return;
              v49 = v29;
              v34 = *(_QWORD *)(v29 + 48);
              v14 = (_QWORD *)(v29 + 48);
              v33 = v34;
              if (v34)
              {
                v35 = v14;
                v36 = v33;
                do
                {
                  v37 = *(_DWORD *)(v36 + 28);
                  v38 = v37 < v23;
                  if (v37 >= v23)
                    v39 = (uint64_t *)v36;
                  else
                    v39 = (uint64_t *)(v36 + 8);
                  if (!v38)
                    v35 = (_QWORD *)v36;
                  v36 = *v39;
                }
                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    v40 = *(_DWORD *)(v33 + 28);
                    v41 = v23 < v40;
                    if (v23 >= v40)
                      v42 = (uint64_t *)(v33 + 8);
                    else
                      v42 = (uint64_t *)v33;
                    if (v41)
                      v14 = (_QWORD *)v33;
                    v33 = *v42;
                  }
                  while (*v42);
                }
                else
                {
                  v43 = (_QWORD *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      v14 = v43;
                      v43 = (_QWORD *)*v43;
                    }
                    while (v43);
                  }
                  else
                  {
                    do
                    {
                      v14 = (_QWORD *)v35[2];
                      v44 = *v14 == (_QWORD)v35;
                      v35 = v14;
                    }
                    while (!v44);
                  }
                }
              }
            }
            else
            {
LABEL_25:
              v48 = a1 + 88;
              if (qword_1EE16D448 != -1)
                dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
              v24 = qword_1EE16D440;
              if (os_log_type_enabled((os_log_t)qword_1EE16D440, OS_LOG_TYPE_FAULT))
              {
                v25 = a1 + 8;
                if (*(char *)(a1 + 31) < 0)
                  v25 = *v16;
                v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)buf = 136446466;
                v55 = v25;
                v56 = 1026;
                v57 = v26;
                _os_log_impl(&dword_18F1DC000, v24, OS_LOG_TYPE_FAULT, "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }
              if (sub_18F1FCA08(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1EE16D448 != -1)
                  dispatch_once(&qword_1EE16D448, &unk_1E2954C68);
                v45 = a1 + 8;
                if (*(char *)(a1 + 31) < 0)
                  v45 = *v16;
                v46 = *((_DWORD *)v14 + 7);
                v50 = 136446466;
                v51 = v45;
                v52 = 1026;
                v53 = v46;
                v47 = (char *)_os_log_send_and_compose_impl();
                sub_18F419700("Generic", 1, 0, 0, "void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]", "CoreLocation: %s\n", v47);
                if (v47 != (char *)buf)
                  free(v47);
              }
            }
          }
          while (v14 != (_QWORD *)(v49 + 48));
        }
      }
    }
  }
}

uint64_t sub_18F44548C(uint64_t result, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t **v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;

  if (!*(_BYTE *)(result + 108))
  {
    v7 = result;
    v8 = *(unsigned int *)(*(_QWORD *)a2 + 32);
    LODWORD(v15) = *(_DWORD *)(*(_QWORD *)a3 + 32);
    v9 = sub_18F4455FC(a4);
    v10 = *(_QWORD *)a3 + 80;
    v11 = (uint64_t **)(*(_QWORD *)a3 + 40);
    v16 = (int *)(*(_QWORD *)a2 + 32);
    v12 = sub_18F3BFD00(v11, v16, (uint64_t)&unk_18F506652, &v16);
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t **))(*(_QWORD *)v7 + 192))(v7, v8, &v15, v9, v10, v12 + 4);
    if ((_DWORD)result)
      return objc_msgSend_onNotification_withData_(*(void **)(*(_QWORD *)a2 + 64), v13, *(unsigned int *)(*(_QWORD *)a3 + 32), (uint64_t)a4, v14, v15);
  }
  return result;
}

os_log_t sub_18F445568()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Core", "Notifier");
  qword_1EE16D440 = (uint64_t)result;
  return result;
}

void sub_18F445594(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E2952730;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_18F4455A4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E2952730;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4455DC(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    JUMPOUT(0x194001438);
  return result;
}

uint64_t sub_18F4455FC(void *a1)
{
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return sub_18F445674(a1, v2, v3, v4, v5);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return sub_18F4459DC(a1, v7, v8, v9, v10);
  else
    return 0;
}

uint64_t sub_18F445674(void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v16;
  char *v17;
  char v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  unint64_t v24;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  unint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v6 = objc_msgSend_binaryVersion(a1, a2, a3, a4, a5);
  objc_msgSend_sizeOfType(a1, v7, v8, v9, v10);
  if (!v6)
    return sub_18F445D68((uint64_t)&v18, a1, v11, v12, v13);
  if (!getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_1EE16D7E8 != -1)
      dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
    v16 = qword_1EE16D7F0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D7F0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218498;
      v26 = v6;
      v27 = 2048;
      v28 = 0;
      v29 = 2080;
      v30 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
    }
    if (!sub_18F1FCA08(115, 0))
      return 0;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D7E8 == -1)
      goto LABEL_18;
    goto LABEL_20;
  }
  if (qword_1EE16D7E8 != -1)
    dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
  v14 = qword_1EE16D7F0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D7F0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134218498;
    v26 = v6;
    v27 = 2048;
    v28 = 0;
    v29 = 2080;
    v30 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
    _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
  }
  if (!sub_18F1FCA08(115, 0))
    return 0;
  bzero(buf, 0x65CuLL);
  if (qword_1EE16D7E8 != -1)
LABEL_20:
    dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
LABEL_18:
  v19 = 134218498;
  v20 = v6;
  v21 = 2048;
  v22 = 0;
  v23 = 2080;
  v24 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
  v17 = (char *)_os_log_send_and_compose_impl();
  sub_18F419700("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLGeomagneticModelProvider_Type::NotificationData, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Intersilo/CLCppContainer.h:241:46)]", "CoreLocation: %s\n", v17);
  if (v17 != (char *)buf)
    free(v17);
  return 0;
}

uint64_t sub_18F4459DC(void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v17;
  char *v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  unint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v6 = objc_msgSend_binaryVersion(a1, a2, a3, a4, a5);
  objc_msgSend_sizeOfType(a1, v7, v8, v9, v10);
  if (!v6)
    return objc_msgSend_cppObjectPtr(a1, v11, v12, v13, v14);
  if (!getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_1EE16D7E8 != -1)
      dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
    v17 = qword_1EE16D7F0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D7F0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218498;
      v20 = v6;
      v21 = 2048;
      v22 = 0;
      v23 = 2080;
      v24 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_FAULT, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
    }
    if (!sub_18F1FCA08(115, 0))
      return 0;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D7E8 == -1)
      goto LABEL_18;
    goto LABEL_20;
  }
  if (qword_1EE16D7E8 != -1)
    dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
  v15 = qword_1EE16D7F0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D7F0, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134218498;
    v20 = v6;
    v21 = 2048;
    v22 = 0;
    v23 = 2080;
    v24 = (unint64_t)"N31CLGeomagneticModelProvider_Type16NotificationDataE" & 0x7FFFFFFFFFFFFFFFLL;
    _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_ERROR, "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly", buf, 0x20u);
  }
  if (!sub_18F1FCA08(115, 0))
    return 0;
  bzero(buf, 0x65CuLL);
  if (qword_1EE16D7E8 != -1)
LABEL_20:
    dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
LABEL_18:
  v18 = (char *)_os_log_send_and_compose_impl();
  sub_18F419700("Generic", 1, 0, 0, "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLGeomagneticModelProvider_Type::NotificationData, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Shared/Intersilo/CLCppContainer.h:250:46)]", "CoreLocation: %s\n", v18);
  if (v18 != (char *)buf)
    free(v18);
  return 0;
}

uint64_t sub_18F445D68(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  uint8_t buf[4];
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!objc_msgSend_cppObjectPtr(a2, (const char *)a2, a3, a4, a5))
  {
    v10 = (void *)objc_msgSend_compatibilityInfo(a2, v6, v7, v8, v9);
    if (objc_msgSend_isEqual_(v10, v11, (uint64_t)&unk_1E298C440, v12, v13))
    {
      v14 = (void *)objc_msgSend_serialized(a2, v6, v7, v8, v9);
      if (objc_msgSend_length(v14, v15, v16, v17, v18) != 64)
      {
        if (qword_1EE16D7E8 != -1)
          dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
        v33 = qword_1EE16D7F0;
        if (os_log_type_enabled((os_log_t)qword_1EE16D7F0, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 68289539;
          v37 = 0;
          v38 = 2082;
          v39 = "";
          v40 = 2082;
          v41 = "assert";
          v42 = 2081;
          v43 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_log_impl(&dword_18F1DC000, v33, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          if (qword_1EE16D7E8 != -1)
            dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
        }
        v34 = qword_1EE16D7F0;
        if (os_signpost_enabled((os_log_t)qword_1EE16D7F0))
        {
          *(_DWORD *)buf = 68289539;
          v37 = 0;
          v38 = 2082;
          v39 = "";
          v40 = 2082;
          v41 = "assert";
          v42 = 2081;
          v43 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_signpost_emit_with_name_impl(&dword_18F1DC000, v34, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "The total size of the POD types on the 2 architectures is expected to be the same.", "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
          if (qword_1EE16D7E8 != -1)
            dispatch_once(&qword_1EE16D7E8, &unk_1E2954F88);
        }
        v35 = qword_1EE16D7F0;
        if (os_log_type_enabled((os_log_t)qword_1EE16D7F0, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289539;
          v37 = 0;
          v38 = 2082;
          v39 = "";
          v40 = 2082;
          v41 = "assert";
          v42 = 2081;
          v43 = "sizeof(Object_T) == podContainer.serialized.length";
          _os_log_impl(&dword_18F1DC000, v35, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"The total size of the POD types on the 2 architectures is expected to be the same.\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        }
        abort_report_np();
      }
      v23 = (void *)objc_msgSend_serialized(a2, v19, v20, v21, v22);
      v28 = objc_msgSend_bytes(v23, v24, v25, v26, v27);
      objc_msgSend_setCppObjectPtr_(a2, v29, v28, v30, v31);
    }
  }
  return objc_msgSend_cppObjectPtr(a2, v6, v7, v8, v9);
}

os_log_t sub_18F446018()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Support", "Support");
  qword_1EE16D7F0 = (uint64_t)result;
  return result;
}

uint64_t sub_18F446044(_OWORD *a1)
{
  _OWORD *v2;
  __int128 v3;
  __int128 v4;
  const char *v5;
  _QWORD v7[5];

  v2 = (_OWORD *)operator new();
  v3 = a1[1];
  *v2 = *a1;
  v2[1] = v3;
  v4 = a1[3];
  v2[2] = a1[2];
  v2[3] = v4;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = sub_18F4460DC;
  v7[3] = &unk_1E2955738;
  v7[4] = v2;
  return objc_msgSend_containerWithObject_destructor_binaryVersion_typeSize_(MEMORY[0x1E0D44518], v5, (uint64_t)v2, (uint64_t)v7, 0, 64);
}

uint64_t sub_18F4460DC(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    JUMPOUT(0x194001438);
  return result;
}

void sub_18F4463D0(uint64_t a1, mach_error_t a2)
{
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  char *v8;
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2953A48);
    v4 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      v5 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 134218242;
      v10 = v5;
      v11 = 2080;
      v12 = mach_error_string(a2);
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "[CLHidManager] setReport: id=0x%lx, failed=%s", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2953A48);
      mach_error_string(a2);
LABEL_18:
      v8 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CLHidDevice setReport:payload:length:]_block_invoke", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf)
        free(v8);
    }
  }
  else
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2953A48);
    v6 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      v7 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 134218240;
      v10 = v7;
      v11 = 1024;
      LODWORD(v12) = 1;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_INFO, "[CLHidManager] setReport: id=0x%lx, success=%d", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2953A48);
      goto LABEL_18;
    }
  }
}

uint64_t sub_18F446968(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v5 = *(_QWORD *)(result + 32);
  if (v5)
  {
    v8 = (void *)objc_msgSend_clientDevices(*(void **)(result + 32), a2, a3, a4, a5);
    result = objc_msgSend_count(v8, v9, v10, v11, v12);
    if (result)
      return MEMORY[0x1E0DE7D20](v5, sel_updateClientDeviceWithHidDevice_added_, a2, a3, v13);
  }
  return result;
}

uint64_t sub_18F446AA0(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v5 = *(void **)(result + 32);
  if (v5)
  {
    v6 = result;
    objc_msgSend_delegate(*(void **)(result + 32), a2, a3, a4, a5);
    result = objc_opt_respondsToSelector();
    if ((result & 1) != 0)
    {
      v11 = objc_msgSend_delegate(v5, v7, v8, v9, v10);
      return MEMORY[0x1E0DE7D20](v11, sel_monitorUpdateForDevice_added_, *(_QWORD *)(v6 + 40), *(unsigned __int8 *)(v6 + 48), v12);
    }
  }
  return result;
}

void sub_18F446CC4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  _QWORD block[7];

  v6 = *(_QWORD *)(a1 + 32);
  if (v6)
  {
    if (objc_msgSend_hidDevice(*(void **)(a1 + 40), a2, a3, a4, a5))
    {
      objc_msgSend_delegate(*(void **)(a1 + 48), v9, v10, v11, v12);
      if ((objc_opt_respondsToSelector() & 1) != 0)
      {
        if (objc_msgSend_delegateQueue(*(void **)(a1 + 48), v13, v14, v15, v16))
        {
          v21 = objc_msgSend_delegateQueue(*(void **)(a1 + 48), v17, v18, v19, v20);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3221225472;
          block[2] = sub_18F446D74;
          block[3] = &unk_1E2958100;
          block[4] = a6;
          block[5] = v6;
          block[6] = *(_QWORD *)(a1 + 40);
          dispatch_async(v21, block);
        }
      }
    }
  }
}

uint64_t sub_18F446D74(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  _BYTE v23[128];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = *(void **)(a1 + 32);
  v7 = objc_msgSend_length(v6, a2, a3, a4, a5);
  objc_msgSend_getBytes_length_(v6, v8, (uint64_t)v23, v7, v9);
  v14 = (void *)objc_msgSend_delegate(*(void **)(a1 + 40), v10, v11, v12, v13);
  v15 = *(_QWORD *)(a1 + 48);
  v20 = objc_msgSend_length(*(void **)(a1 + 32), v16, v17, v18, v19);
  return objc_msgSend_inputReportForDevice_report_length_(v14, v21, v15, (uint64_t)v23, v20);
}

void sub_18F447580(uint64_t a1)
{
  sub_18F4D2930(a1);
  JUMPOUT(0x194001438);
}

void sub_18F448938(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void sub_18F448A1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F448BF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F448DE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

os_log_t sub_18F449054()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Health");
  qword_1EE16D870 = (uint64_t)result;
  return result;
}

void ***sub_18F449080(void ***result, void **a2)
{
  void **v2;
  void **v3;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = v2;
    sub_18F3EEA44(&v3);
    return (void ***)MEMORY[0x194001438](v2, 0x20C40960023A9);
  }
  return result;
}

uint64_t sub_18F449C00(uint64_t result)
{
  *(_BYTE *)(result + 108) = 1;
  return result;
}

uint64_t sub_18F449C0C(uint64_t result)
{
  *(_BYTE *)(result + 108) = 1;
  return result;
}

uint64_t sub_18F449C18(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_QWORD *)a1 = off_1E2949148;
  objc_msgSend_invalidate(*(void **)(a1 + 48), a2, a3, a4, a5);

  sub_18F449DA8(a1 + 80, *(_QWORD **)(a1 + 88));
  sub_18F449DF4(a1 + 56, *(_QWORD **)(a1 + 64));
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

_QWORD *sub_18F449C88@<X0>(_DWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  char __str[32];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x20uLL, "%d", *a1);
  return sub_18F270374(a2, __str);
}

void sub_18F449D04(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_18F449E74(a1, a2, a3, a4, a5);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F449D28(uint64_t a1, int a2, void *a3)
{
  uint64_t result;
  int v6;

  result = sub_18F4455FC(a3);
  if (result)
  {
    v6 = a2;
    return (*(uint64_t (**)(_QWORD, int *, uint64_t, _QWORD))(a1 + 24))(0, &v6, result, *(_QWORD *)(a1 + 32));
  }
  return result;
}

os_log_t sub_18F449D74()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Core", "Notifier");
  qword_1EE16D440 = (uint64_t)result;
  return result;
}

void sub_18F449DA8(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_18F449DA8(a1, *a2);
    sub_18F449DA8(a1, a2[1]);
    sub_18F3BEA38((uint64_t)(a2 + 5), (_QWORD *)a2[6]);
    operator delete(a2);
  }
}

void sub_18F449DF4(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_18F449DF4(a1, *a2);
    sub_18F449DF4(a1, a2[1]);
    sub_18F2A8438((uint64_t)(a2 + 8));
    sub_18F3BEA38((uint64_t)(a2 + 5), (_QWORD *)a2[6]);
    operator delete(a2);
  }
}

void sub_18F449E50(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_18F449E74(a1, a2, a3, a4, a5);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F449E74(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void **v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)a1 = &off_1E294A780;
  v6 = (void **)(a1 + 8);
  objc_msgSend_forget_(*(void **)(a1 + 16), a2, *(_QWORD *)(a1 + 8), a4, a5);

  objc_msgSend_invalidate(*v6, v7, v8, v9, v10);
  *v6 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return a1;
}

_BYTE *sub_18F449ED0(_BYTE *__dst, unsigned __int8 *a2, size_t a3)
{
  unsigned int v4;
  uint64_t v5;

  if (a3 && ((v4 = *a2 - 1, v4 > 8) ? (v5 = 0) : (v5 = qword_18F508A00[(char)v4]), v5 == a3))
    memcpy(__dst, a2, a3);
  else
    *__dst = -1;
  return __dst;
}

unsigned __int8 *sub_18F449F38(unsigned __int8 *result, _QWORD *a2)
{
  unsigned int v2;

  v2 = *result - 1;
  if (v2 <= 8)
    return (unsigned __int8 *)(*(uint64_t (**)(_QWORD *, unsigned __int8 *))(*a2
                                                                                     + 8 * v2
                                                                                     + 16))(a2, result);
  return result;
}

BOOL sub_18F449F68()
{
  void *v0;
  _BOOL8 v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v0 = (void *)MEMORY[0x194001B4C]();
  sub_18F449FAC();
  v1 = qword_1EE16E9C8 != 0;
  objc_msgSend_showCalibrationAlert((void *)qword_1EE16E9C8, v2, v3, v4, v5);
  objc_autoreleasePoolPop(v0);
  return v1;
}

void sub_18F449FAC()
{
  NSObject *v0;
  NSObject *v1;
  char *v2;
  uint8_t buf[1640];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16E848)
    return;
  qword_1EE16E848 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/CompassUI.framework/CompassUI", 1);
  if (qword_1EE16E848)
  {
    qword_1EE16E9C8 = (uint64_t)NSClassFromString(CFSTR("CUICalibration"));
    if (!qword_1EE16E9C8)
    {
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2953AA8);
      v0 = qword_1ECEDEE50;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_FAULT, "Could not load CUICalibrationClass from CompassUI framework", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE58 == -1)
        {
LABEL_18:
          v2 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "void CLClientLoadCompassUIIfNecessary(void)", "CoreLocation: %s\n", v2);
          if (v2 != (char *)buf)
            free(v2);
          return;
        }
LABEL_20:
        dispatch_once(&qword_1ECEDEE58, &unk_1E2953AA8);
        goto LABEL_18;
      }
    }
  }
  else
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2953AA8);
    v1 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_FAULT, "Unable to load CompassUI framework", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 == -1)
        goto LABEL_18;
      goto LABEL_20;
    }
  }
}

void sub_18F44A240()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v0 = (void *)MEMORY[0x194001B4C]();
  sub_18F449FAC();
  objc_msgSend_dismissCalibrationAlert((void *)qword_1EE16E9C8, v1, v2, v3, v4);
  objc_autoreleasePoolPop(v0);
}

os_log_t sub_18F44A274()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Core", "Client");
  qword_1ECEDEE50 = (uint64_t)result;
  return result;
}

BOOL sub_18F44A5E4(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;

  v5 = 0;
  if (a1 && a2 - a3 >= a5)
  {
    if (*(_BYTE *)(a1 + a3) == 64
      && (v6 = a3 + a1, *(unsigned __int8 *)(v6 + 1) <= 0x30u)
      && *(unsigned __int8 *)(v6 + 2) == a5)
    {
      return *(unsigned __int8 *)(a3 + a1 + 3) == a4;
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

BOOL sub_18F44A644(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 35)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 19083328;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 13) = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 33);
    *(_WORD *)(a2 + 33) = v6 | ((_WORD)v5 << 8);
    *a4 = 35;
  }
  return a3 > 34;
}

BOOL sub_18F44A6EC(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 1, 35);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    v9 = a4 + 33;
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    if (a4 < -32)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_18F44A7DC(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  char v7;

  if (a3 >= 41)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = *(_BYTE *)(a1 + 49);
    if (*(_BYTE *)(a1 + 50))
      v7 |= 2u;
    *(_DWORD *)a2 = 36253760;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 13) = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a2 + 33) = *(_DWORD *)(a1 + 44);
    *(_BYTE *)(a2 + 37) = *(_BYTE *)(a1 + 48);
    *(_BYTE *)(a2 + 38) = v7;
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 39);
    *(_WORD *)(a2 + 39) = v6 | ((_WORD)v5 << 8);
    *a4 = 41;
  }
  return a3 > 40;
}

BOOL sub_18F44A8AC(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  unsigned __int8 v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;

  result = sub_18F44A5E4(a2, a3, a4, 2, 41);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(v8 + 33);
    *(_BYTE *)(a1 + 48) = v8[37];
    v9 = v8[38];
    v10 = a4 + 39;
    *(_BYTE *)(a1 + 49) = v9 & 1;
    *(_BYTE *)(a1 + 50) = (v9 & 2) != 0;
    if (a4 < -38)
    {
      v15 = 0;
    }
    else
    {
      v11 = 0;
      v12 = 0;
      v13 = v10;
      do
      {
        v14 = *v8++;
        v12 = (v12 + v14) % 0xFF;
        v11 = (v12 + v11) % 0xFF;
        --v13;
      }
      while (v13);
      v15 = (unsigned __int16)v12 | ((unsigned __int16)v11 << 8);
    }
    v16 = *(unsigned __int16 *)(v10 + a2);
    *(_WORD *)(a1 + 16) = v16;
    return v16 == v15;
  }
  return result;
}

BOOL sub_18F44A9C0(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 19)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 101920832;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a2 + 13) = *(_DWORD *)(a1 + 20);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 17);
    *(_WORD *)(a2 + 17) = v6 | ((_WORD)v5 << 8);
    *a4 = 19;
  }
  return a3 > 18;
}

BOOL sub_18F44AA50(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 6, 19);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    v9 = a4 + 17;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(v8 + 13);
    if (a4 < -16)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_18F44AB28(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 40)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 203960384;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a2 + 13) = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a2 + 17) = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 33) = *(_DWORD *)(a1 + 40);
    *(_BYTE *)(a2 + 37) = *(_BYTE *)(a1 + 44);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 38);
    *(_WORD *)(a2 + 38) = v6 | ((_WORD)v5 << 8);
    *a4 = 40;
  }
  return a3 > 39;
}

BOOL sub_18F44ABE8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 12, 40);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(v8 + 13);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(v8 + 17);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 25);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 29);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 33);
    *(_BYTE *)(a1 + 44) = v8[37];
    v9 = a4 + 38;
    if (a4 < -37)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_18F44ACF0(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 20)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 303312960;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(a2 + 13) = *(_DWORD *)(a1 + 20);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 18);
    *(_WORD *)(a2 + 18) = v6 | ((_WORD)v5 << 8);
    *a4 = 20;
  }
  return a3 > 19;
}

BOOL sub_18F44AD80(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 18, 20);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(v8 + 13);
    v9 = a4 + 18;
    if (a4 < -17)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_18F44AE58(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 35)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 52637760;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 13) = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 33);
    *(_WORD *)(a2 + 33) = v6 | ((_WORD)v5 << 8);
    *a4 = 35;
  }
  return a3 > 34;
}

BOOL sub_18F44AF00(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 3, 35);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    v9 = a4 + 33;
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    if (a4 < -32)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_18F44AFF0(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 72)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 71839808;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 13) = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a2 + 33) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a2 + 37) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a2 + 41) = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a2 + 45) = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a2 + 49) = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a2 + 53) = *(_DWORD *)(a1 + 64);
    *(_BYTE *)(a2 + 57) = *(_BYTE *)(a1 + 68);
    *(_DWORD *)(a2 + 58) = *(_DWORD *)(a1 + 72);
    *(_DWORD *)(a2 + 62) = *(_DWORD *)(a1 + 76);
    *(_DWORD *)(a2 + 66) = *(_DWORD *)(a1 + 80);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 70);
    *(_WORD *)(a2 + 70) = v6 | ((_WORD)v5 << 8);
    *a4 = 72;
  }
  return a3 > 71;
}

BOOL sub_18F44B0E8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 4, 72);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(v8 + 33);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v8 + 37);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v8 + 41);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(v8 + 45);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(v8 + 49);
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(v8 + 53);
    *(_BYTE *)(a1 + 68) = v8[57];
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(v8 + 58);
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(v8 + 62);
    v9 = a4 + 70;
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(v8 + 66);
    if (a4 < -69)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_18F44B228(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 24)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 186134592;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 13) = *(_QWORD *)(a1 + 24);
    *(_BYTE *)(a2 + 21) = *(_BYTE *)(a1 + 32);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 22);
    *(_WORD *)(a2 + 22) = v6 | ((_WORD)v5 << 8);
    *a4 = 24;
  }
  return a3 > 23;
}

BOOL sub_18F44B2C0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 11, 24);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(v8 + 13);
    *(_BYTE *)(a1 + 32) = v8[21];
    v9 = a4 + 22;
    if (a4 < -21)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_18F44B3A0(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 102)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 90583104;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 13) = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    *(_DWORD *)(a2 + 29) = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(a2 + 33) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a2 + 37) = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a2 + 41) = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a2 + 45) = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a2 + 49) = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a2 + 53) = *(_DWORD *)(a1 + 64);
    *(_DWORD *)(a2 + 57) = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(a2 + 61) = *(_DWORD *)(a1 + 72);
    *(_DWORD *)(a2 + 65) = *(_DWORD *)(a1 + 76);
    *(_DWORD *)(a2 + 69) = *(_DWORD *)(a1 + 80);
    *(_BYTE *)(a2 + 73) = *(_BYTE *)(a1 + 84);
    *(_DWORD *)(a2 + 74) = *(_DWORD *)(a1 + 88);
    *(_DWORD *)(a2 + 78) = *(_DWORD *)(a1 + 92);
    *(_DWORD *)(a2 + 82) = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a2 + 86) = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a2 + 90) = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a2 + 94) = *(_DWORD *)(a1 + 108);
    *(_WORD *)(a2 + 98) = *(_WORD *)(a1 + 112);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 100);
    *(_WORD *)(a2 + 100) = v6 | ((_WORD)v5 << 8);
    *a4 = 102;
  }
  return a3 > 101;
}

BOOL sub_18F44B4D8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 5, 102);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(v8 + 29);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(v8 + 33);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(v8 + 37);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v8 + 41);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(v8 + 45);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(v8 + 49);
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(v8 + 53);
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(v8 + 57);
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(v8 + 61);
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(v8 + 65);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(v8 + 69);
    *(_BYTE *)(a1 + 84) = v8[73];
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(v8 + 74);
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(v8 + 78);
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(v8 + 82);
    *(_DWORD *)(a1 + 100) = *(_DWORD *)(v8 + 86);
    *(_DWORD *)(a1 + 104) = *(_DWORD *)(v8 + 90);
    *(_DWORD *)(a1 + 108) = *(_DWORD *)(v8 + 94);
    *(_WORD *)(a1 + 112) = *((_WORD *)v8 + 49);
    v9 = a4 + 100;
    if (a4 < -99)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

BOOL sub_18F44B658(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (a3 >= 31)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    *(_DWORD *)a2 = 270479424;
    *(_BYTE *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 5) = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 13) = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 21) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a2 + 25) = *(_DWORD *)(a1 + 36);
    do
    {
      v6 = (v6 + *(unsigned __int8 *)(a2 + v4)) % 0xFF;
      v5 = (v6 + v5) % 0xFF;
      ++v4;
    }
    while (v4 != 29);
    *(_WORD *)(a2 + 29) = v6 | ((_WORD)v5 << 8);
    *a4 = 31;
  }
  return a3 > 30;
}

BOOL sub_18F44B6F8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _BOOL8 result;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;

  result = sub_18F44A5E4(a2, a3, a4, 16, 31);
  if (result)
  {
    v8 = (unsigned __int8 *)(a2 + a4);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v8 + 5);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(v8 + 13);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(v8 + 21);
    v9 = a4 + 29;
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(v8 + 25);
    if (a4 < -28)
    {
      v14 = 0;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = v9;
      do
      {
        v13 = *v8++;
        v11 = (v11 + v13) % 0xFF;
        v10 = (v11 + v10) % 0xFF;
        --v12;
      }
      while (v12);
      v14 = (unsigned __int16)v11 | ((unsigned __int16)v10 << 8);
    }
    v15 = *(unsigned __int16 *)(v9 + a2);
    *(_WORD *)(a1 + 16) = v15;
    return v15 == v14;
  }
  return result;
}

uint64_t sub_18F44B7E0(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,Accelerometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(double *)(a1 + 24));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44B878(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,Gyro,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,subType,%d,sampleNum%%3,%d,triggerEnabled,%d,triggerOn,%d", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(double *)(a1 + 24), *(_DWORD *)(a1 + 44), *(unsigned __int8 *)(a1 + 48), *(unsigned __int8 *)(a1 + 49), *(unsigned __int8 *)(a1 + 50));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44B928(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,GyroTemperature,temperature,%f", *(double *)(a1 + 8), *(float *)(a1 + 20));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44B9A8(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,GyroBias,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d", *(double *)(a1 + 8), *(float *)(a1 + 20), *(float *)(a1 + 24), *(float *)(a1 + 28), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(char *)(a1 + 44));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44BA58(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,GyroDt,dt,%20.20f", *(double *)(a1 + 8), *(float *)(a1 + 20));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44BAD8(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,Magnetometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(double *)(a1 + 24));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44BB70(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,Compass,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(float *)(a1 + 44), *(float *)(a1 + 48), *(float *)(a1 + 52), *(float *)(a1 + 56), *(float *)(a1 + 60), *(float *)(a1 + 64), *(char *)(a1 + 68), *(float *)(a1 + 72), *(float *)(a1 + 76), *(float *)(a1 + 80),
    *(double *)(a1 + 24));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44BC58(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,CompassAlignment,compassJustAlignedToStableField,%d,timestamp,%20.20f", *(double *)(a1 + 8), *(char *)(a1 + 32), *(double *)(a1 + 24));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44BCE0(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  char __str[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned __int16 *)(a1 + 112);
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,DeviceMotion,q.x,%20.20f,q.y,%20.20f,q.z,%20.20f,q.w,%20.20f,userAccel.x,%20.20f,userAccel.y,%20.20f,userAccel.z,%20.20f,rotationRate.x,%20.20f,rotationRate.y,%20.20f,rotationRate.z,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,magneticFieldCalibrationLevel,%d,heading,%.3f,trueheading,%.3f,accuracy,%.3f,variant,%d,mode,%d,clientID,%#02x,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,visualLocalizationCorrection,%d,initialized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,north,%d,visualLocalization,%d,timestamp,%20.20f", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), *(float *)(a1 + 44), *(float *)(a1 + 48), *(float *)(a1 + 52), *(float *)(a1 + 56), *(float *)(a1 + 60), *(float *)(a1 + 64), *(float *)(a1 + 68),
    *(float *)(a1 + 72),
    *(float *)(a1 + 76),
    *(float *)(a1 + 80),
    *(char *)(a1 + 84),
    *(float *)(a1 + 88),
    *(float *)(a1 + 92),
    *(float *)(a1 + 96),
    *(_DWORD *)(a1 + 100),
    *(_DWORD *)(a1 + 104),
    *(_DWORD *)(a1 + 108),
    (v3 >> 4) & 1,
    (v3 >> 3) & 1,
    (v3 >> 2) & 1,
    (v3 >> 5) & 1,
    (v3 >> 6) & 1,
    (v3 >> 8) & 1,
    (v3 >> 1) & 1,
    v3 & 1,
    (v3 >> 10) & 1,
    (v3 >> 9) & 1,
    (v3 >> 11) & 1,
    (v3 >> 12) & 1,
    (v3 >> 13) & 1,
    (v3 >> 14) & 1,
    *(double *)(a1 + 24));
  return MEMORY[0x1940012AC](a2, __str);
}

uint64_t sub_18F44BE54(uint64_t a1, uint64_t a2)
{
  char __str[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "STATUS,SENSOR,Time,%.3lf,Type,PressureFiltered,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf", *(double *)(a1 + 8), *(float *)(a1 + 32), *(float *)(a1 + 36), *(double *)(a1 + 24));
  return MEMORY[0x1940012AC](a2, __str);
}

void sub_18F44BEE4()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44BEF8()
{
  return 35;
}

void sub_18F44BF04()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44BF18()
{
  return 41;
}

void sub_18F44BF24()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44BF38()
{
  return 19;
}

void sub_18F44BF44()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44BF58()
{
  return 20;
}

void sub_18F44BF64()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44BF78()
{
  return 35;
}

void sub_18F44BF84()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44BF98()
{
  return 72;
}

uint64_t sub_18F44BFA0()
{
  return 31;
}

void sub_18F44BFAC()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44BFC0()
{
  return 102;
}

void sub_18F44BFCC()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44BFE0()
{
  return 40;
}

void sub_18F44BFEC()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44C000()
{
  return 24;
}

void sub_18F44C00C()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F44C020(uint64_t a1, unsigned int a2, int a3, char a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v7 = a1 + 37480;
  v8 = sub_18F3F4980(a1, a2, a3);
  *(_BYTE *)v7 = a4;
  *(_QWORD *)(v7 + 8) = 0;
  *(_QWORD *)(v7 + 16) = 0;
  *(_WORD *)(v7 + 24) = 257;
  *(_QWORD *)(v7 + 32) = 0;
  *(_QWORD *)(v7 + 40) = 0;
  sub_18F40FD34(v8 + 37528, 0.02);
  v12[0] = &off_1E29522A0;
  v12[1] = a1;
  v13 = v12;
  sub_18F3F5C38(a1, v12);
  v9 = v13;
  if (v13 == v12)
  {
    v10 = 4;
    v9 = v12;
    goto LABEL_5;
  }
  if (v13)
  {
    v10 = 5;
LABEL_5:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  sub_18F44C21C(a1, a2);
  return a1;
}

void sub_18F44C128(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *(_QWORD *)(v3 + 40);
  *(_QWORD *)(v3 + 40) = 0;
  if (v6)
  {
    *(_OWORD *)(v6 + 5928) = 0u;
    MEMORY[0x194001438]();
  }
  v7 = *v4;
  *v4 = 0;
  if (v7)
  {
    *(_OWORD *)(v7 + 7576) = 0u;
    MEMORY[0x194001438]();
  }
  sub_18F44CEA0((uint64_t *)(v1 + 37496), 0);
  v8 = *v2;
  *v2 = 0;
  if (v8)
  {
    v9 = *(_QWORD *)(v8 + 96);
    if (v9)
      *(_OWORD *)(v9 + 10912) = 0u;
    MEMORY[0x194001438]();
  }
  sub_18F44CE18(v1);
  _Unwind_Resume(a1);
}

void sub_18F44C21C(uint64_t a1, unsigned int a2)
{
  sub_18F3F4F58((unsigned int *)a1, a2);
  if (!*(_QWORD *)(a1 + 37488) || !*(_BYTE *)(a1 + 5))
    sub_18F44C400(a1);
}

uint64_t sub_18F44C264(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v2 = (uint64_t *)(a1 + 37488);
  v3 = *(_QWORD *)(a1 + 37488);
  *v2 = 0;
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 96);
    if (v4)
      *(_OWORD *)(v4 + 10912) = 0u;
    MEMORY[0x194001438]();
  }
  v5 = v2[3];
  v2[3] = 0;
  if (v5)
  {
    *(_OWORD *)(v5 + 7576) = 0u;
    MEMORY[0x194001438]();
  }
  v6 = v2[4];
  v2[4] = 0;
  if (v6)
  {
    *(_OWORD *)(v6 + 5928) = 0u;
    MEMORY[0x194001438]();
  }
  sub_18F44CEA0((uint64_t *)(a1 + 37496), 0);
  v7 = v2[4];
  v2[4] = 0;
  if (v7)
  {
    *(_OWORD *)(v7 + 5928) = 0u;
    MEMORY[0x194001438]();
  }
  v8 = v2[3];
  v2[3] = 0;
  if (v8)
  {
    *(_OWORD *)(v8 + 7576) = 0u;
    MEMORY[0x194001438]();
  }
  sub_18F44CEA0((uint64_t *)(a1 + 37496), 0);
  v9 = *v2;
  *v2 = 0;
  if (v9)
  {
    v10 = *(_QWORD *)(v9 + 96);
    if (v10)
      *(_OWORD *)(v10 + 10912) = 0u;
    MEMORY[0x194001438]();
  }
  sub_18F3FFC88((void **)(a1 + 27552));
  v11 = *(_QWORD **)(a1 + 32);
  if (v11 == (_QWORD *)(a1 + 8))
  {
    v12 = 4;
    v11 = (_QWORD *)(a1 + 8);
    goto LABEL_21;
  }
  if (v11)
  {
    v12 = 5;
LABEL_21:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  return a1;
}

void sub_18F44C400(uint64_t a1)
{
  unsigned __int8 *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  const char *v28;
  char *v29;
  char *v30;
  uint8_t buf[4];
  _BYTE v32[10];
  __int16 v33;
  _BOOL4 v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v2 = (unsigned __int8 *)(a1 + 37480);
  v3 = *(_QWORD *)(a1 + 37488);
  *((_QWORD *)v2 + 1) = 0;
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 96);
    if (v4)
      *(_OWORD *)(v4 + 10912) = 0u;
    MEMORY[0x194001438]();
  }
  if (*(_BYTE *)(a1 + 4) == 1)
  {
    v5 = *((_QWORD *)v2 + 4);
    *((_QWORD *)v2 + 4) = 0;
    if (v5)
    {
      *(_OWORD *)(v5 + 7576) = 0u;
      MEMORY[0x194001438]();
    }
    sub_18F44CEA0((uint64_t *)(a1 + 37496), 0);
    v6 = operator new();
    v7 = sub_18F354BB8(v6);
    v8 = *((_QWORD *)v2 + 5);
    *((_QWORD *)v2 + 5) = v7;
    if (v8)
    {
      *(_OWORD *)(v8 + 5928) = 0u;
      MEMORY[0x194001438](v8, 0x10E0C40F93B1391);
      v7 = *((_QWORD *)v2 + 5);
    }
    *(_QWORD *)(v7 + 5928) = sub_18F44CA74;
    v9 = (uint64_t *)(v7 + 5936);
  }
  else
  {
    v10 = *((_QWORD *)v2 + 5);
    *((_QWORD *)v2 + 5) = 0;
    if (v10)
    {
      *(_OWORD *)(v10 + 5928) = 0u;
      MEMORY[0x194001438]();
    }
    v11 = operator new();
    sub_18F3CC2D8(v11, 1.69);
    sub_18F44CEA0((uint64_t *)(a1 + 37496), v11);
    v12 = operator new();
    sub_18F3843AC(v12);
    v13 = *((_QWORD *)v2 + 4);
    *((_QWORD *)v2 + 4) = v12;
    if (v13)
    {
      *(_OWORD *)(v13 + 7576) = 0u;
      MEMORY[0x194001438]();
      v12 = *((_QWORD *)v2 + 4);
    }
    *(_QWORD *)(v12 + 7576) = sub_18F44CA94;
    v9 = (uint64_t *)(v12 + 7584);
  }
  *v9 = a1;
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953AC8);
  v14 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
  {
    v15 = *((_QWORD *)v2 + 4) != 0;
    v16 = *((_QWORD *)v2 + 5) != 0;
    v17 = *((_QWORD *)v2 + 2) != 0;
    v18 = *v2;
    v19 = *(_DWORD *)a1;
    v20 = *(unsigned __int8 *)(a1 + 4);
    *(_DWORD *)buf = 67110400;
    *(_DWORD *)v32 = v15;
    *(_WORD *)&v32[4] = 1024;
    *(_DWORD *)&v32[6] = v16;
    v33 = 1024;
    v34 = v17;
    v35 = 1024;
    v36 = v18;
    v37 = 1024;
    v38 = v19;
    v39 = 1024;
    v40 = v20;
    _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_DEFAULT, "[HeadTrackingService] Creating HeadTrackingController, fAccessoryWalkingDetector: %d, fAccessoryStepDetector: %d, fSitStandDetector: %d, controllerEnabled: %d, clientMode: %d, trackingBehavior: %d, ", buf, 0x26u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953AC8);
    v29 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingService::createHeadTrackingController()", "CoreLocation: %s\n", v29);
    if (v29 != (char *)buf)
      free(v29);
  }
  v21 = *((_QWORD *)v2 + 4);
  v22 = *((_QWORD *)v2 + 5);
  v23 = *((_QWORD *)v2 + 2);
  v24 = operator new();
  sub_18F464ED4(v24, a1, v21, v22, v23, *v2);
  v25 = *((_QWORD *)v2 + 1);
  *((_QWORD *)v2 + 1) = v24;
  if (v25)
  {
    v26 = *(_QWORD *)(v25 + 96);
    if (v26)
      *(_OWORD *)(v26 + 10912) = 0u;
    MEMORY[0x194001438]();
  }
  v2[24] = *(_BYTE *)(a1 + 4) == 0;
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953AC8);
  v27 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
  {
    if (v2[24])
      v28 = "enabled";
    else
      v28 = "disabled";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)v32 = v28;
    _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_DEFAULT, "[HeadTrackingService] Sit-stand detector status: %{public}s", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953AC8);
    v30 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingService::createHeadTrackingController()", "CoreLocation: %s\n", v30);
    if (v30 != (char *)buf)
      free(v30);
  }
}

void sub_18F44CA10(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10A0C40B2A28986);
  _Unwind_Resume(a1);
}

void sub_18F44CA74(int a1, unint64_t a2, uint64_t a3)
{
  sub_18F4667A8(*(_QWORD *)(a3 + 37488), *(unsigned __int8 *)(a3 + 37504), *(unsigned __int8 *)(a3 + 37505), a1, a2);
}

void sub_18F44CA94(int a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char v5;

  v3 = a3 + 37488;
  if (*(_QWORD *)(a3 + 37512))
  {
    v5 = a1;
    sub_18F4667A8(*(_QWORD *)v3, *(unsigned __int8 *)(a3 + 37504), *(unsigned __int8 *)(a3 + 37505), a1, a2);
    if (*(_BYTE *)(v3 + 16))
      sub_18F3CC810(*(_QWORD *)(v3 + 8), v5, a2);
  }
}

void sub_18F44CB08(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = a1 + 37488;
  v7 = (_BYTE *)(a1 + 16058);
  if (sub_18F3F6E9C(a1, a3))
    sub_18F4658E0(*(_QWORD *)v6, a3);
  if (*v7)
  {
    if (*(_DWORD *)(*(_QWORD *)v6 + 112) == 2)
      v8 = 2500000;
    else
      v8 = 5000000;
  }
  else
  {
    v8 = 7500000;
  }
  if (sub_18F3F71AC(a1, a2, a3, v8))
  {
    if (*v7)
    {
      sub_18F465AC4(*(_QWORD *)v6, a3);
    }
    else if (*(_BYTE *)(v6 + 16))
    {
      v9 = *(_QWORD *)(v6 + 8);
      if (v9)
        sub_18F3CCA08(v9, a3);
    }
  }
  if (v7[4])
  {
    if (*v7)
      sub_18F465CA0(*(_QWORD *)v6, a3);
  }
}

void sub_18F44CC08(uint64_t a1, unsigned int a2, unsigned int a3, unint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  char *v10;
  uint8_t buf[4];
  unsigned int v12;
  __int16 v13;
  unsigned int v14;
  __int16 v15;
  unint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953AC8);
  v8 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240704;
    v12 = a2;
    v13 = 1026;
    v14 = a3;
    v15 = 2050;
    v16 = a4;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEFAULT, "[HeadTrackingService] JBLMs, %{public}d, limitMs, %{public}d, timestampUs, %{public}llu", buf, 0x18u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953AC8);
    v10 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingService::feedJBLChangedEventAndThreshold(uint16_t, uint16_t, uint64_t)", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf)
      free(v10);
  }
  if (*(_BYTE *)(a1 + 4))
  {
    v9 = *(_QWORD *)(a1 + 37488);
    if (v9)
      sub_18F465E7C(v9, a2 > a3, a4);
  }
}

uint64_t sub_18F44CE18(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  sub_18F3FFC88((void **)(a1 + 27552));
  v2 = *(_QWORD **)(a1 + 32);
  if (v2 == (_QWORD *)(a1 + 8))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 8);
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

os_log_t sub_18F44CE74()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1EE16D820 = (uint64_t)result;
  return result;
}

uint64_t *sub_18F44CEA0(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = 0;
    *(_OWORD *)(v2 + 10912) = 0u;
    while (1)
    {
      v4 = *(_QWORD *)(v2 + v3 + 10904);
      *(_QWORD *)(v2 + v3 + 10904) = 0;
      if (v4)
        MEMORY[0x194001438](v4, 0x1000C40FF89C88ELL);
      v3 -= 8;
      if (v3 == -24)
        JUMPOUT(0x194001438);
    }
  }
  return result;
}

void sub_18F44CF24()
{
  JUMPOUT(0x194001438);
}

_QWORD *sub_18F44CF38(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E29522A0;
  result[1] = v3;
  return result;
}

uint64_t sub_18F44CF6C(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E29522A0;
  a2[1] = v2;
  return result;
}

void sub_18F44CF88(uint64_t a1)
{
  sub_18F44C400(*(_QWORD *)(a1 + 8));
}

uint64_t sub_18F44CF90(uint64_t a1, uint64_t a2)
{
  if (sub_18F2AB00C(a2, (uint64_t)&unk_1E2948F00))
    return a1 + 8;
  else
    return 0;
}

void *sub_18F44CFCC()
{
  return &unk_1E2948F00;
}

void sub_18F44D0DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;

  if (a19 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F44D118(uint64_t a1, CLConnectionMessage **a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSSet *v9;
  void *DictionaryOfClasses;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  char *v21;
  uint8_t buf[4];
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = (void *)MEMORY[0x1E0C99E60];
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v9 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v7, v8, v5, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) != 0
    && (v14 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, (uint64_t)CFSTR("CMErrorMessage"), v12, v13)) != 0)
  {
    v19 = objc_msgSend_intValue(v14, v15, v16, v17, v18);
  }
  else
  {
    v19 = 103;
  }
  if (qword_1EE16D6A0 != -1)
    dispatch_once(&qword_1EE16D6A0, &unk_1E29550A8);
  v20 = qword_1EE16D6A8;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67240192;
    v23 = v19;
    _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6A0 != -1)
      dispatch_once(&qword_1EE16D6A0, &unk_1E29550A8);
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMFitnessMachineInternal init]_block_invoke", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
  }
}

void sub_18F44D32C(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t ExecutablePathFromPid;
  uint64_t v7;
  NSObject *v8;
  pid_t v9;
  uint64_t v10;
  char *v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  pid_t v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = getpid();
  ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2, v4, v5);
  if (ExecutablePathFromPid)
  {
    v7 = ExecutablePathFromPid;
    if (qword_1EE16D6A0 != -1)
      dispatch_once(&qword_1EE16D6A0, &unk_1E29550A8);
    v8 = qword_1EE16D6A8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_INFO))
    {
      v9 = getpid();
      v10 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138412802;
      v13 = v7;
      v14 = 1024;
      v15 = v9;
      v16 = 2048;
      v17 = v10;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "CMFitnessMachine client connection interrupt, %@, %d, %p", buf, 0x1Cu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6A0 != -1)
        dispatch_once(&qword_1EE16D6A0, &unk_1E29550A8);
      getpid();
      v11 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMFitnessMachineInternal init]_block_invoke", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf)
        free(v11);
    }
  }
}

void sub_18F44D670(uint64_t a1, const char *a2)
{
  uint64_t v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  const __CFString *v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v14 = CFSTR("CMFitnessMachineDataRecord");
  v15[0] = v2;
  v11 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v15, (uint64_t)&v14, 1);
  sub_18F44DCB8("kCLConnectionMessageFitnessMachineData", &v11, &v12);
  v10 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v10)
  {
    v5 = (unint64_t *)&v10->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v7 = v13;
  if (v13)
  {
    v8 = (unint64_t *)&v13->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_18F44D7B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F44D7D4(uint64_t a1, CLConnectionMessage **a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSSet *v9;
  void *DictionaryOfClasses;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  char *v23;
  uint8_t buf[4];
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = (void *)MEMORY[0x1E0C99E60];
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v9 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v7, v8, v5, 0);
  if (*a2 && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) != 0)
  {
    v14 = DictionaryOfClasses;
    if (objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, (uint64_t)CFSTR("CMErrorMessage"), v12, v13))
    {
      if (qword_1EE16D6A0 != -1)
        dispatch_once(&qword_1EE16D6A0, &unk_1E29550A8);
      v15 = qword_1EE16D6A8;
      if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v25 = objc_msgSend_objectForKeyedSubscript_(v14, v16, (uint64_t)CFSTR("CMErrorMessage"), v17, v18);
        _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_ERROR, "Error feeding fitness machine data, %@", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D6A0 != -1)
          dispatch_once(&qword_1EE16D6A0, &unk_1E29550A8);
        objc_msgSend_objectForKeyedSubscript_(v14, v19, (uint64_t)CFSTR("CMErrorMessage"), v20, v21);
LABEL_20:
        v23 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMFitnessMachineInternal _feedFitnessMachineData:]_block_invoke", "CoreLocation: %s\n", v23);
        if (v23 != (char *)buf)
          free(v23);
      }
    }
  }
  else
  {
    if (qword_1EE16D6A0 != -1)
      dispatch_once(&qword_1EE16D6A0, &unk_1E29550A8);
    v22 = qword_1EE16D6A8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_ERROR, "Error feeding fitness machine data", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6A0 != -1)
        dispatch_once(&qword_1EE16D6A0, &unk_1E29550A8);
      goto LABEL_20;
    }
  }
}

uint64_t sub_18F44DBC0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_18F44DC58(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, (uint64_t)CFSTR("com.apple.locationd.activity"), a4, a5);
  qword_1ECEDFB40 = result;
  return result;
}

os_log_t sub_18F44DC8C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1EE16D6A8 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F44DCB8@<X0>(char *a1@<X1>, _QWORD *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x70uLL);
  result = sub_18F44DD18(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_18F44DD04(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F44DD18(_QWORD *a1, char *__s, _QWORD *a3)
{
  char v5;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_1E2952688;
  sub_18F44DD78((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_18F44DD64(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_18F44DD78(int a1, uint64_t a2, char *__s, _QWORD *a4)
{
  void *__p[2];
  char v7;

  sub_18F270374(__p, __s);
  MEMORY[0x19400103C](a2, __p, *a4);
  if (v7 < 0)
    operator delete(__p[0]);
}

void sub_18F44DDCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F44E070(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD block[7];

  v5 = *(void **)(a1 + 32);
  if (v5)
  {
    objc_msgSend_delegate(*(void **)(a1 + 32), a2, a3, a4, a5);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v12 = objc_msgSend_delegateQueue(v5, v8, v9, v10, v11);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = sub_18F44E104;
      block[3] = &unk_1E2958100;
      block[4] = v5;
      block[5] = a2;
      block[6] = a3;
      dispatch_async(v12, block);
    }
  }
}

uint64_t sub_18F44E104(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;

  v6 = objc_msgSend_delegate(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel_eventUpdateForDevice_event_, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), v7);
}

void sub_18F44E27C(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v5;
  double v6;
  char *v7;
  uint8_t buf[4];
  double v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!*a2)
  {
    *(double *)(a4 + 8) = *(double *)(a3 + 40) * 0.0174532924;
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
    v5 = qword_1EE16D920;
    if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_INFO))
    {
      v6 = *(double *)(a4 + 8) * 57.2957802;
      *(_DWORD *)buf = 134217984;
      v9 = v6;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "Received geomagnetic model, declination [deg],%f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D918 != -1)
        dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLInertialOdometryNotifier::GeomagneticModelClient::onGeomagneticModelNotification(int, const CLGeomagneticModelProvider_Type::Notification &, const CLGeomagneticModelProvider_Type::NotificationData &, void *)", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }
  }
}

uint64_t sub_18F44E460()
{
  if (qword_1ECEDFB58 != -1)
    dispatch_once(&qword_1ECEDFB58, &unk_1E2953B28);
  return qword_1ECEDFB50;
}

uint64_t *sub_18F44E4A0()
{
  uint64_t *result;
  NSObject *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  char *v6;
  uint8_t buf[8];
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  result = (uint64_t *)+[CMOdometryManager isAvailable]_0();
  if ((_DWORD)result)
  {
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
    v1 = qword_1EE16D920;
    if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "Creating InertialOdometry notifier", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D918 != -1)
        dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static CLInertialOdometryNotifier *CLInertialOdometryNotifier::instance()_block_invoke", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
    v2 = (_QWORD *)operator new();
    sub_18F1E61EC((uint64_t)v2, (uint64_t)"CLInertialOdometryNotifier", 1);
    sub_18F4CE95C(v2 + 4);
    *v2 = &off_1E2944238;
    v2[4] = &unk_1E2944288;
    v2[9] = 0;
    v2[10] = 0;
    v2[11] = dispatch_queue_create("com.apple.CoreMotion.CLInertialOdometryNotifierQueue", 0);
    v3 = operator new();
    sub_18F270374(buf, "com.apple.locationd.registration");
    MEMORY[0x19400100C](v3, buf, v2[11]);
    if (v8 < 0)
      operator delete(*(void **)buf);
    sub_18F331ACC(v2 + 10, v3);
    CLConnectionClient::setDefaultMessageHandler();
    CLConnectionClient::start((CLConnectionClient *)v2[10]);
    v4 = sub_18F20CA68();
    v5 = (_QWORD *)operator new();
    v5[1] = 0;
    v5[2] = 0;
    *v5 = v4;
    *(_QWORD *)buf = 0;
    sub_18F44F87C(v2 + 9, (uint64_t)v5);
    result = sub_18F44F87C((uint64_t *)buf, 0);
    qword_1ECEDFB50 = (uint64_t)v2;
  }
  return result;
}

void sub_18F44E760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _QWORD *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;

  if (a18 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v21, 0xB0C40BC2CC919);
  sub_18F331ACC(v20, 0);
  sub_18F44F87C(v19, 0);
  v18[4] = &off_1E29442B8;
  sub_18F2A8438((uint64_t)(v18 + 5));
  sub_18F3DB8A0(v18);
  MEMORY[0x194001438](v18, 0x10F1C40D4AB533BLL);
  _Unwind_Resume(a1);
}

void sub_18F44E810(uint64_t a1, CLConnectionMessage **a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D918 != -1)
    dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
  v3 = qword_1EE16D920;
  if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_DEBUG))
  {
    v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0)
      v5 = v4;
    else
      v5 = *(_QWORD *)v4;
    *(_DWORD *)buf = 136446210;
    v8 = v5;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %{public}s", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
    CLConnectionMessage::name(*a2);
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLInertialOdometryNotifier::CLInertialOdometryNotifier()_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf)
      free(v6);
  }
}

_QWORD *sub_18F44E9EC(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E2944238;
  *(_QWORD *)(a1 + 32) = &unk_1E2944288;
  dispatch_release(*(dispatch_object_t *)(a1 + 88));
  *(_QWORD *)(a1 + 88) = 0;
  sub_18F331ACC((uint64_t *)(a1 + 80), 0);
  sub_18F44F87C((uint64_t *)(a1 + 72), 0);
  *(_QWORD *)(a1 + 32) = &off_1E29442B8;
  sub_18F2A8438(a1 + 40);
  return sub_18F3DB8A0((_QWORD *)a1);
}

_QWORD *sub_18F44EA5C(uint64_t a1)
{
  return sub_18F44E9EC(a1 - 32);
}

void sub_18F44EA64(uint64_t a1)
{
  sub_18F44E9EC(a1);
  JUMPOUT(0x194001438);
}

void sub_18F44EA88(uint64_t a1)
{
  sub_18F44E9EC(a1 - 32);
  JUMPOUT(0x194001438);
}

double sub_18F44EAB0(uint64_t *a1, int a2, _QWORD *a3)
{
  NSObject *v3;
  double v4;
  char *v5;
  NSObject *v8;
  double v9;
  double v10;
  uint64_t v11;
  double v12;
  NSObject *v13;
  double v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  const char *v18;
  NSObject *v19;
  const char *v20;
  uint64_t v21;
  char *v23;
  char *v24;
  char *v25;
  __int128 buf;
  void (*v27)(uint64_t, const char *, uint64_t, uint64_t, uint64_t);
  void *v28;
  uint64_t *v29;
  double v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
    v3 = qword_1EE16D920;
    if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_FAULT, "Unrecognized notification", (uint8_t *)&buf, 2u);
    }
    v4 = 0.0;
    if (sub_18F1FCA08(115, 0))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1EE16D918 != -1)
        dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual CFTimeInterval CLInertialOdometryNotifier::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v5);
      if (v5 != (char *)&buf)
        free(v5);
    }
  }
  else
  {
    v4 = 0.0;
    if (sub_18F4CE9F4((uint64_t)(a1 + 4)))
    {
      if (qword_1EE16D918 != -1)
        dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
      v8 = qword_1EE16D920;
      if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(double *)a3;
        LODWORD(buf) = 134349056;
        *(double *)((char *)&buf + 4) = v9;
        _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEFAULT, "Minimum inertial odometry update interval changed to %{public}f", (uint8_t *)&buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1EE16D918 != -1)
          dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
        v23 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "virtual CFTimeInterval CLInertialOdometryNotifier::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v23);
        if (v23 != (char *)&buf)
          free(v23);
      }
      v10 = rint(*(double *)a3 * 1000000.0);
      if (*(double *)a3 < 0.0)
        v11 = 0;
      else
        v11 = (uint64_t)v10;
      sub_18F203AF8(a1[5], v11);
      v12 = *(double *)a3;
      v13 = a1[11];
      *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
      *((_QWORD *)&buf + 1) = 3221225472;
      v27 = sub_18F44F6BC;
      v28 = &unk_1E2958238;
      v29 = a1;
      v30 = v12;
      dispatch_async(v13, &buf);
      v14 = *(double *)a3;
      v15 = a1[9];
      sub_18F1F77DC();
      if (v14 <= 0.0)
      {
        *(_QWORD *)(v15 + 8) = 0;
        if (*(_QWORD *)(v15 + 16))
        {
          if (qword_1EE16D918 != -1)
            dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
          v19 = qword_1EE16D920;
          if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_INFO))
          {
            LOWORD(buf) = 0;
            _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_INFO, "Unregistering for geomagnetic model updates", (uint8_t *)&buf, 2u);
          }
          if (sub_18F1FCA08(115, 2))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_1EE16D918 != -1)
              dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
            v25 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CLInertialOdometryNotifier::GeomagneticModelClient::unregisterForGeomagneticModelNotification()", "CoreLocation: %s\n", v25);
            if (v25 != (char *)&buf)
              free(v25);
          }
          objc_msgSend_unregister_forNotification_(*(void **)(*(_QWORD *)(v15 + 16) + 16), v20, *(_QWORD *)(*(_QWORD *)(v15 + 16) + 8), 0, v21);
        }
      }
      else
      {
        if (!*(_QWORD *)(v15 + 16))
        {
          sub_18F1DF558((uint64_t)sub_18F44E27C, v15, *(void **)v15, &buf);
          v16 = *(_QWORD *)(v15 + 16);
          *(_QWORD *)(v15 + 16) = buf;
          if (v16)
            (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
        }
        if (qword_1EE16D918 != -1)
          dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
        v17 = qword_1EE16D920;
        if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_INFO))
        {
          LOWORD(buf) = 0;
          _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_INFO, "Registering for geomagnetic model updates", (uint8_t *)&buf, 2u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_1EE16D918 != -1)
            dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
          v24 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLInertialOdometryNotifier::GeomagneticModelClient::registerForGeomagneticModelNotification()", "CoreLocation: %s\n", v24);
          if (v24 != (char *)&buf)
            free(v24);
        }
        objc_msgSend_register_forNotification_registrationInfo_(*(void **)(*(_QWORD *)(v15 + 16) + 16), v18, *(_QWORD *)(*(_QWORD *)(v15 + 16) + 8), 0, 0);
      }
      return *(double *)a3;
    }
  }
  return v4;
}

void sub_18F44F104(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  char *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D918 != -1)
    dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
  v3 = qword_1EE16D920;
  if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_DWORD *)(a2 + 1);
    *(_DWORD *)buf = 67240192;
    v7 = v4;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "pong,%{public}u", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLInertialOdometryNotifier::visitPong(const CMInertialOdometryReport::Pong *)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
}

uint64_t sub_18F44F2B8(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  float v22;
  uint64_t v24;
  char *v25;
  _BYTE buf[32];
  _BYTE v27[40];
  _BYTE v28[32];
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D918 != -1)
    dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
  v4 = qword_1EE16D920;
  if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_DEBUG))
  {
    v5 = *(_QWORD *)(a2 + 1);
    v6 = *(_QWORD *)(a1 + 56);
    v7 = mach_absolute_time();
    v8 = sub_18F1FD20C(v7);
    v9 = *(float *)(a2 + 9);
    v10 = *(float *)(a2 + 13);
    v11 = *(float *)(a2 + 17);
    v12 = *(float *)(a2 + 21);
    v13 = *(float *)(a2 + 25);
    v14 = *(float *)(a2 + 29);
    v15 = *(_QWORD *)(a2 + 33);
    v16 = *(_QWORD *)(a2 + 41);
    v17 = *(_QWORD *)(a2 + 49);
    v18 = *(_QWORD *)(a2 + 57);
    v19 = *(_QWORD *)(a2 + 65);
    v20 = *(_QWORD *)(a2 + 73);
    v21 = *(unsigned __int8 *)(a2 + 101);
    *(_DWORD *)buf = 134352896;
    *(_QWORD *)&buf[4] = v5;
    *(_WORD *)&buf[12] = 2050;
    *(_QWORD *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2050;
    *(double *)&buf[24] = v8;
    *(_WORD *)v27 = 2050;
    *(double *)&v27[2] = v9;
    *(_WORD *)&v27[10] = 2050;
    *(double *)&v27[12] = v10;
    *(_WORD *)&v27[20] = 2050;
    *(double *)&v27[22] = v11;
    *(_WORD *)&v27[30] = 2050;
    *(double *)&v27[32] = v12;
    *(_WORD *)v28 = 2050;
    *(double *)&v28[2] = v13;
    *(_WORD *)&v28[10] = 2050;
    *(double *)&v28[12] = v14;
    *(_WORD *)&v28[20] = 2050;
    *(_QWORD *)&v28[22] = v15;
    *(_WORD *)&v28[30] = 2050;
    v29 = v16;
    v30 = 2050;
    v31 = v17;
    v32 = 2050;
    v33 = v18;
    v34 = 2050;
    v35 = v19;
    v36 = 2050;
    v37 = v20;
    v38 = 1026;
    v39 = v21;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEBUG, "Report,aopTimestamp,%{public}llu,reportTimestamp,%{public}f,machTimeNow,%{public}f,posX,%{public}f,posY,%{public}f,posZ,%{public}f,dvCumsumX,%{public}f,dvCumsumY,%{public}f,dvCumsumZ,%{public}f,tsPosRollover,%{public}llu,tsVelRollover,%{public}llu,tsDeltaPosXUnavailable,%{public}llu,tsDeltaPosYUnavailable,%{public}llu,tsDeltaPosZUnavailable,%{public}llu,tsDMReinit,%{public}llu,displacingState,%{public}u", buf, 0x9Eu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E2954A48);
    v24 = mach_absolute_time();
    sub_18F1FD20C(v24);
    v25 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLInertialOdometryNotifier::visitInertialOdometry(const CMInertialOdometryReport::InertialOdometry *)", "CoreLocation: %s\n", v25);
    if (v25 != buf)
      free(v25);
  }
  *(_QWORD *)buf = *(_QWORD *)(a1 + 56);
  *(_QWORD *)&buf[8] = *(_QWORD *)(a2 + 1);
  *(_OWORD *)&buf[16] = *(_OWORD *)(a2 + 9);
  *(_QWORD *)v27 = *(_QWORD *)(a2 + 25);
  *(_OWORD *)&v27[8] = *(_OWORD *)(a2 + 33);
  *(_OWORD *)&v27[24] = *(_OWORD *)(a2 + 49);
  *(_OWORD *)v28 = *(_OWORD *)(a2 + 65);
  *(_OWORD *)&v28[16] = *(_OWORD *)(a2 + 81);
  v22 = *(float *)(a2 + 97) - *(double *)(*(_QWORD *)(a1 + 72) + 8);
  *(float *)&v29 = v22;
  BYTE4(v29) = *(_BYTE *)(a2 + 101);
  return sub_18F1FD2C8(a1, 0, (uint64_t)buf, 112);
}

uint64_t sub_18F44F6B4(uint64_t a1, uint64_t a2)
{
  return sub_18F44F2B8(a1 - 32, a2);
}

void sub_18F44F6BC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  _QWORD v26[2];
  _QWORD v27[3];

  v27[2] = *MEMORY[0x1E0C80C00];
  v26[0] = CFSTR("CMInertialOdometryUpdateInterval");
  v27[0] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], a2, a3, a4, a5, *(double *)(a1 + 40));
  v26[1] = CFSTR("CMPedestrianFenceClientIdentifier");
  v9 = (void *)objc_msgSend_processInfo(MEMORY[0x1E0CB3898], v5, v6, v7, v8);
  v27[1] = objc_msgSend_processName(v9, v10, v11, v12, v13);
  v25 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v14, (uint64_t)v27, (uint64_t)v26, 2);
  sub_18F44F8D8("PedestrianFence/kCLConnectionMessageInertialOdometry", &v25, &v23);
  v22 = v24;
  if (v24)
  {
    p_shared_owners = (unint64_t *)&v24->__shared_owners_;
    do
      v16 = __ldxr(p_shared_owners);
    while (__stxr(v16 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v22)
  {
    v17 = (unint64_t *)&v22->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  v19 = v24;
  if (v24)
  {
    v20 = (unint64_t *)&v24->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_18F44F82C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

os_log_t sub_18F44F850()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "InertialOdometry");
  qword_1EE16D920 = (uint64_t)result;
  return result;
}

uint64_t *sub_18F44F87C(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    *(_QWORD *)(v2 + 16) = 0;
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    JUMPOUT(0x194001438);
  }
  return result;
}

_QWORD *sub_18F44F8D8@<X0>(char *a1@<X1>, _QWORD *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x70uLL);
  result = sub_18F44F938(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_18F44F924(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F44F938(_QWORD *a1, char *__s, _QWORD *a3)
{
  char v5;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_1E2952688;
  sub_18F44F998((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_18F44F984(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_18F44F998(int a1, uint64_t a2, char *__s, _QWORD *a4)
{
  void *__p[2];
  char v7;

  sub_18F270374(__p, __s);
  MEMORY[0x19400103C](a2, __p, *a4);
  if (v7 < 0)
    operator delete(__p[0]);
}

void sub_18F44F9EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_18F44FA08()
{
  uint64_t v0;
  uint64_t result;

  v0 = operator new();
  result = sub_18F1E61EC(v0, (uint64_t)"CMCallHandednessService", 1);
  *(_QWORD *)v0 = &off_1E294B078;
  *(_QWORD *)(v0 + 32) = 0;
  *(_QWORD *)(v0 + 40) = 0;
  *(_BYTE *)(v0 + 48) = 0;
  qword_1EE16E8B0 = v0;
  return result;
}

void sub_18F44FA6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10F1C4036CF7AFFLL);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F44FA90(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E294B078;
  sub_18F44FB14((uint64_t)a1, 0, 0);
  v2 = a1[4];
  a1[4] = 0;
  if (v2)
    MEMORY[0x194001438](v2, 0x1000C401249A764);
  return sub_18F3DB8A0(a1);
}

void sub_18F44FAF0(_QWORD *a1)
{
  sub_18F44FA90(a1);
  JUMPOUT(0x194001438);
}

void sub_18F44FB14(uint64_t a1, int a2, uint64_t a3)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  _QWORD *v14;
  uint64_t v15;
  NSObject *v16;
  char *v17;
  NSObject *v18;
  NSObject *v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 buf;
  uint64_t *(*v24)(uint64_t);
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a2)
    return;
  if (qword_1EE16D3E8 != -1)
    dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
  v5 = qword_1EE16D3D8;
  if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = a3;
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEBUG, "CMCallHandednessService Spectators, %zd", (uint8_t *)&buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
    v20 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CMCallHandednessService::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v20);
    if (v20 != (char *)&buf)
      free(v20);
  }
  if (a3 == 1)
  {
    if (sub_18F1DFF7C())
    {
      *(_BYTE *)(a1 + 48) = 0;
      v11 = operator new();
      *(_WORD *)v11 = 1;
      *(_BYTE *)(v11 + 8) = 3;
      *(_QWORD *)(v11 + 16) = 0;
      *(_QWORD *)(v11 + 64) = 0xF00000000;
      *(_DWORD *)(v11 + 24) = 0;
      *(_OWORD *)(v11 + 28) = xmmword_18F508D60;
      *(int64x2_t *)(v11 + 48) = vdupq_n_s64(2uLL);
      v12 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)(a1 + 32) = v11;
      if (v12)
        MEMORY[0x194001438](v12, 0x1000C401249A764);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
      v13 = qword_1EE16D3D8;
      if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 134217984;
        *(_QWORD *)((char *)&buf + 4) = 0x4059000009600004;
        _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEBUG, "Starting CallHandedness detection with accelFrequency %.1f", (uint8_t *)&buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1EE16D3E8 != -1)
          dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
        v21 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMCallHandednessService::startDetection()", "CoreLocation: %s\n", v21);
        if (v21 != (char *)&buf)
          free(v21);
      }
      if (!*(_QWORD *)(a1 + 40))
      {
        v14 = (_QWORD *)operator new();
        *v14 = off_1E294C238;
        *v14 = &off_1E294C3C0;
        v14[1] = 0;
        v14[2] = sub_18F450474;
        v14[3] = a1;
        *(_QWORD *)(a1 + 40) = v14;
        v15 = sub_18F1DFF7C();
        sub_18F1F4F0C(v15, 0, *(_QWORD *)(a1 + 40), 0.00999999978);
      }
    }
    else
    {
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
      v18 = qword_1EE16D3D8;
      if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_DEFAULT, "#Warning No accelerometer; not starting CMCallHandedness detection!",
          (uint8_t *)&buf,
          2u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1EE16D3E8 != -1)
          dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
        v22 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMCallHandednessService::startDetection()", "CoreLocation: %s\n", v22);
        if (v22 != (char *)&buf)
          free(v22);
      }
    }
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
    v19 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = 1;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_DEBUG, "CMCallHandednessService started, %zd", (uint8_t *)&buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1EE16D3E8 == -1)
      {
LABEL_50:
        v17 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "virtual void CMCallHandednessService::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v17);
LABEL_51:
        if (v17 != (char *)&buf)
          free(v17);
        return;
      }
LABEL_65:
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
      goto LABEL_50;
    }
  }
  else if (a3)
  {
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
    v16 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_ERROR, "CMCallHandednessService expects only 1 client", (uint8_t *)&buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
      v17 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual void CMCallHandednessService::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v17);
      goto LABEL_51;
    }
  }
  else
  {
    if (*(_QWORD *)(a1 + 40))
    {
      v6 = sub_18F1DFF7C();
      v7 = *(_QWORD *)(a1 + 40);
      v8 = sub_18F204AE4();
      *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
      *((_QWORD *)&buf + 1) = 3221225472;
      v24 = sub_18F1F5EE0;
      v25 = &unk_1E2956E98;
      v28 = 0;
      v26 = v6;
      v27 = v7;
      sub_18F1F5E28(v8, (uint64_t)&buf);
      v9 = *(_QWORD *)(a1 + 40);
      if (v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
      *(_QWORD *)(a1 + 40) = 0;
    }
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
    v10 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = 0;
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEBUG, "CMCallHandednessService stopped, %zd", (uint8_t *)&buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1EE16D3E8 == -1)
        goto LABEL_50;
      goto LABEL_65;
    }
  }
}

void sub_18F450448(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_18F450474(float32x2_t *a1, uint64_t a2)
{
  __int32 v4;
  double v5;
  uint64_t result;
  BOOL v7;
  unsigned __int8 v8;
  NSObject *v9;
  char *v10;
  float32x2_t v11;
  __int32 v12;
  uint8_t buf[8];
  float32x2_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = a1[2].i32[0];
  v5 = *(double *)a1;
  v11 = a1[1];
  v12 = v4;
  result = sub_18F480398(*(float32x2_t **)(a2 + 32), &v11, v5);
  if ((_DWORD)result)
    v7 = (_DWORD)result == *(unsigned __int8 *)(a2 + 48);
  else
    v7 = 1;
  if (!v7)
  {
    v8 = result;
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
    v9 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEBUG, "Sending CMCallHandedness notification.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954668);
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CMCallHandednessService::onAccelerometerData(const CLAccelerometer::Sample *, void *)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
    *(_QWORD *)buf = v8;
    v14 = *a1;
    result = sub_18F1E5A28(a2, 0, (uint64_t)buf, 16);
    *(_BYTE *)(a2 + 48) = v8;
  }
  return result;
}

os_log_t sub_18F450668()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Gesture");
  qword_1EE16D3D8 = (uint64_t)result;
  return result;
}

CLLocationInternalClient_CoreMotion *sub_18F450694()
{
  CLLocationInternalClient_CoreMotion *result;

  result = objc_alloc_init(CLLocationInternalClient_CoreMotion);
  qword_1ECEDFB68 = (uint64_t)result;
  return result;
}

void sub_18F4506B8()
{
  NSObject *v0;
  char *v1;
  uint8_t buf[1640];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v0 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_ERROR, "#Spi, Interrupted", buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v1 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion connection]_block_invoke", "CoreLocation: %s\n", v1);
    if (v1 != (char *)buf)
      free(v1);
  }
}

uint64_t sub_18F45083C(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v2 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "#Spi, Invalidated", buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion connection]_block_invoke", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
  v3 = *(void **)(a1 + 32);
  objc_sync_enter(v3);

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = 0;
  return objc_sync_exit(v3);
}

void sub_18F4509F4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_18F450A10(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  char *v4;
  uint8_t buf[4];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v3 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    v6 = a2;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_ERROR, "#Spi, Error with proxy, error: %@", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion synchronousRemoteObject]_block_invoke", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
}

void sub_18F450C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F450C90(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F450D50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F450D68(uint64_t result, uint64_t a2, int a3)
{
  if (!a2)
  {
    **(_DWORD **)(result + 40) = a3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F450E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F450E48(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F450EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F450F10(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F450FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F450FCC(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F451114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 80), 8);
  _Unwind_Resume(a1);
}

id sub_18F451138(uint64_t a1, void *a2, void *a3)
{
  id result;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = a2;
  result = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = result;
  return result;
}

void sub_18F4512E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id sub_18F451308(uint64_t a1, void *a2)
{
  id result;

  result = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  return result;
}

void sub_18F4513E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4513FC(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 40) = a3;
    return *(id *)(*(_QWORD *)(result[4] + 8) + 40);
  }
  return result;
}

void sub_18F4514C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4514D8(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 40) = a3;
    return *(id *)(*(_QWORD *)(result[4] + 8) + 40);
  }
  return result;
}

void sub_18F451588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4515A0(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    if (a3)
    {
      *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a3;
      return CFRetain(*(CFTypeRef *)(*(_QWORD *)(result[4] + 8) + 24));
    }
  }
  return result;
}

void sub_18F451668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F451680(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    if (a3)
    {
      *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 40) = a3;
      return *(id *)(*(_QWORD *)(result[4] + 8) + 40);
    }
  }
  return result;
}

void sub_18F451734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F45174C(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    if (a3)
    {
      *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a3;
      return CFRetain(*(CFTypeRef *)(*(_QWORD *)(result[4] + 8) + 24));
    }
  }
  return result;
}

void sub_18F451800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F451818(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    if (a3)
    {
      *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a3;
      return CFRetain(*(CFTypeRef *)(*(_QWORD *)(result[4] + 8) + 24));
    }
  }
  return result;
}

void sub_18F4518CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4518E4(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    if (a3)
    {
      *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a3;
      return CFRetain(*(CFTypeRef *)(*(_QWORD *)(result[4] + 8) + 24));
    }
  }
  return result;
}

void sub_18F451B0C(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v2 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_FAULT, "#Spi, Couldn't set location default!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion setLocationDefaultForKey:value:]_block_invoke", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
}

void sub_18F451D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_18F451D90(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v6;
  id result;
  _DWORD v8[2];
  __int16 v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v6 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEBUG))
  {
    v8[0] = 68289282;
    v8[1] = 0;
    v9 = 2082;
    v10 = "";
    v11 = 2114;
    v12 = a2;
    _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"#Spi, getLocationDefaultForKey, \", \"error\":%{public, location:escape_only}@}", (uint8_t *)v8, 0x1Cu);
  }
  result = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  return result;
}

void sub_18F451FEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F452004(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  id v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;

  if (!a2)
  {
    if (a3)
    {
      v4 = result;
      v5 = objc_alloc(MEMORY[0x1E0C99E80]);
      result = objc_msgSend_initWithName_(v5, v6, a3, v7, v8);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 40) = result;
    }
  }
  return result;
}

void sub_18F45207C(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v2 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_FAULT, "#Spi, setPrivateMode failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion setPrivateMode:]_block_invoke", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
}

void sub_18F452290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4522A8(uint64_t result, uint64_t a2, char a3)
{
  if (!a2)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a3;
  return result;
}

void sub_18F45234C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F452364(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4523D0(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v2 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_FAULT, "#Spi, CLInternalSetLocationServicesEnabled failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion setLocationServicesEnabled:]_block_invoke", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
}

void sub_18F4525EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F452604(uint64_t result, uint64_t a2, int a3)
{
  if (!a2)
  {
    **(_BYTE **)(result + 40) = a3 == 1;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F4526E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4526FC(_QWORD *result, void *a2)
{
  _QWORD *v3;
  NSObject *v4;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = result;
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v4 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "#Spi, CLInternalSetAuthorizationPromptMapDisplayEnabled failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion setAuthorizationPromptMapDisplayEnabled:]_block_invoke", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    result = a2;
    *(_QWORD *)(*(_QWORD *)(v3[4] + 8) + 40) = result;
  }
  return result;
}

void sub_18F452938(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F452950(uint64_t result, uint64_t a2, char a3)
{
  if (!a2)
  {
    **(_BYTE **)(result + 40) = a3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F452AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F452AC0(uint64_t result, void *a2)
{
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  void *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = result;
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v4 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      v10 = 68289282;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2114;
      v15 = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#Spi, CLSetClientTransientAuthorizationInfo failed\", \"error\":%{public, location:escape_only}@}", (uint8_t *)&v10, 0x1Cu);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    }
    v5 = qword_1ECEDEE50;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE50))
    {
      v10 = 68289282;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2114;
      v15 = a2;
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Spi, CLSetClientTransientAuthorizationInfo failed", "{\"msg%{public}.0s\":\"#Spi, CLSetClientTransientAuthorizationInfo failed\", \"error\":%{public, location:escape_only}@}", (uint8_t *)&v10, 0x1Cu);
    }
    result = objc_msgSend_copy(a2, v6, v7, v8, v9);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 40) = result;
  }
  return result;
}

void sub_18F452D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F452D44(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  NSObject *v8;
  NSObject *v9;
  uint64_t result;
  int v11;
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  void *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v8 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      v11 = 68289282;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2114;
      v16 = a2;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#Spi, CLGetClientTransientAuthorizationInfo failed\", \"error\":%{public, location:escape_only}@}", (uint8_t *)&v11, 0x1Cu);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    }
    v9 = qword_1ECEDEE50;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE50))
    {
      v11 = 68289282;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2114;
      v16 = a2;
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Spi, CLGetClientTransientAuthorizationInfo failed", "{\"msg%{public}.0s\":\"#Spi, CLGetClientTransientAuthorizationInfo failed\", \"error\":%{public, location:escape_only}@}", (uint8_t *)&v11, 0x1Cu);
    }
    if (*(_QWORD *)(a1 + 40))
      **(_QWORD **)(a1 + 40) = a2;
  }
  result = objc_msgSend_copy(a3, (const char *)a2, (uint64_t)a3, a4, a5);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  return result;
}

void sub_18F452FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18F452FD8(uint64_t a1, uint64_t a2, double a3)
{
  NSObject *v6;
  NSObject *v7;
  int v8;
  int v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v6 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      v8 = 68289282;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      v12 = 2114;
      v13 = a2;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#Spi, CLInternalChangeClientAuthorizationTime failed\", \"error\":%{public, location:escape_only}@}", (uint8_t *)&v8, 0x1Cu);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    }
    v7 = qword_1ECEDEE50;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE50))
    {
      v8 = 68289282;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      v12 = 2114;
      v13 = a2;
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Spi, CLInternalChangeClientAuthorizationTime failed", "{\"msg%{public}.0s\":\"#Spi, CLInternalChangeClientAuthorizationTime failed\", \"error\":%{public, location:escape_only}@}", (uint8_t *)&v8, 0x1Cu);
    }
    *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
  }
}

void sub_18F453224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F45323C(_QWORD *result, void *a2)
{
  _QWORD *v3;
  NSObject *v4;
  NSObject *v5;
  int v6;
  int v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = result;
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v4 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      v6 = 68289282;
      v7 = 0;
      v8 = 2082;
      v9 = "";
      v10 = 2114;
      v11 = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"#Spi, CLInternalTriggerExpiredAuthorizationPurge failed\", \"error\":%{public, location:escape_only}@}", (uint8_t *)&v6, 0x1Cu);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    }
    v5 = qword_1ECEDEE50;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE50))
    {
      v6 = 68289282;
      v7 = 0;
      v8 = 2082;
      v9 = "";
      v10 = 2114;
      v11 = a2;
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#Spi, CLInternalTriggerExpiredAuthorizationPurge failed", "{\"msg%{public}.0s\":\"#Spi, CLInternalTriggerExpiredAuthorizationPurge failed\", \"error\":%{public, location:escape_only}@}", (uint8_t *)&v6, 0x1Cu);
    }
    result = a2;
    *(_QWORD *)(*(_QWORD *)(v3[4] + 8) + 40) = result;
  }
  return result;
}

void sub_18F453410(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v2 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_FAULT, "#Spi, CLInternalSetGestureServiceEnabled failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion setGestureServiceEnabled:]_block_invoke", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
}

void sub_18F45362C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F453644(uint64_t result, uint64_t a2, char a3)
{
  if (!a2)
  {
    **(_BYTE **)(result + 40) = a3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F453710(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F453728(uint64_t result, uint64_t a2, int a3)
{
  if (!a2)
  {
    **(_DWORD **)(result + 40) = a3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F4537F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F45380C(uint64_t result, uint64_t a2, int a3)
{
  if (!a2)
  {
    **(_DWORD **)(result + 40) = a3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F453AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

_BYTE **sub_18F453AC8(_BYTE **result, void *a2, char a3)
{
  _BYTE **v3;

  v3 = result;
  if (a2)
  {
    result = a2;
    *(_QWORD *)(*((_QWORD *)v3[5] + 1) + 40) = result;
  }
  else
  {
    *result[6] = a3;
    *(_BYTE *)(*((_QWORD *)result[4] + 1) + 24) = 1;
  }
  return result;
}

void sub_18F453D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F453D2C(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F453F40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F453F5C(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  return result;
}

void sub_18F45416C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F454188(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4543A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4543C0(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F45447C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F454494(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    if (a3)
    {
      *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a3;
      return CFRetain(*(CFTypeRef *)(*(_QWORD *)(result[4] + 8) + 24));
    }
  }
  return result;
}

void sub_18F454624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

id sub_18F454654(_QWORD *a1, void *a2, char a3)
{
  id result;

  result = a2;
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 40) = result;
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = a3;
  *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  return result;
}

void sub_18F4547F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id sub_18F454818(uint64_t a1, void *a2)
{
  id result;

  result = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F454994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

id sub_18F4549B8(uint64_t a1, void *a2)
{
  id result;

  result = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F454B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id sub_18F454B44(uint64_t a1, void *a2)
{
  id result;

  result = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F454C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 80), 8);
  _Unwind_Resume(a1);
}

id sub_18F454CC0(uint64_t a1, void *a2)
{
  id result;

  result = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F454DD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F454DF0(uint64_t result, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  if (!a2)
  {
    v5 = result;
    result = objc_msgSend_getBytes_length_(a3, 0, *(_QWORD *)(result + 40), 156, a5);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F454EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 sub_18F454F14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _OWORD *v3;
  __n128 result;
  __int128 v5;

  if (!a2)
  {
    v3 = *(_OWORD **)(a1 + 40);
    result = *(__n128 *)a3;
    v5 = *(_OWORD *)(a3 + 16);
    *v3 = *(_OWORD *)a3;
    v3[1] = v5;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F4552D0(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v2 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "#Spi,RouteHintError,Couldn't set map-matching route hint!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion setMapMatchingRouteHint:count:routingType:stepType:]_block_invoke", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
}

void sub_18F45561C(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v2 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "#Spi,CLTR,TrackRunHintError,Couldn't set track run hint!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion setTrackRunHint:]_block_invoke", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
}

void sub_18F4559BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18F4559D8(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v4;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v4 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEBUG, "#Spi,getAccessoryTypeBitSet,failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CLLocationInternalClient_CoreMotion getAccessoryTypeBitSet]_block_invoke", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    a3 = -1;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
}

void sub_18F455D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18F455DB4(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v4;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v4 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEBUG, "#Spi,getAccessoryPASCDTransmissionState,failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CLLocationInternalClient_CoreMotion getAccessoryPASCDTransmissionState]_block_invoke", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    a3 = 4;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
}

void sub_18F45619C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18F4561C0(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v3;
  char *v4;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint8_t buf[4];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v3 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_ERROR, "#Spi,getOdometryBatchedLocations,returned with error", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      v4 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CLLocationInternalClient_CoreMotion getOdometryBatchedLocations]_block_invoke", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf)
        free(v4);
    }
  }
  else
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v7 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134349056;
      v18 = objc_msgSend_count(a3, v8, v9, v10, v11);
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEBUG, "#Spi,getOdometryBatchedLocations,received data count,%{public}lu", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
      objc_msgSend_count(a3, v12, v13, v14, v15);
      v16 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CLLocationInternalClient_CoreMotion getOdometryBatchedLocations]_block_invoke", "CoreLocation: %s\n", v16);
      if (v16 != (char *)buf)
        free(v16);
    }
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = a3;
  }
}

void sub_18F4566B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4566D4(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F456900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F456918(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4569D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18F4569EC(uint64_t a1, uint64_t a2, char a3)
{
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  int v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v4 = qword_1ECEDEE50;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_FAULT))
    {
      v5 = *(int *)(a1 + 48);
      v8 = 68289282;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      v12 = 2050;
      v13 = v5;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Getting status bar enabled for entity class failed\", \"entityClass\":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld}", (uint8_t *)&v8, 0x1Cu);
      if (qword_1ECEDEE58 != -1)
        dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    }
    v6 = qword_1ECEDEE50;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE50))
    {
      v7 = *(int *)(a1 + 48);
      v8 = 68289282;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      v12 = 2050;
      v13 = v7;
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Getting status bar enabled for entity class failed", "{\"msg%{public}.0s\":\"Getting status bar enabled for entity class failed\", \"entityClass\":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld}", (uint8_t *)&v8, 0x1Cu);
    }
  }
  else
  {
    **(_BYTE **)(a1 + 40) = a3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

void sub_18F456C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F456C3C(uint64_t result, uint64_t a2, int a3)
{
  if (!a2)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a3;
  return result;
}

void sub_18F456D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_18F456D4C(uint64_t a1, const char *a2, void *a3, uint64_t a4, uint64_t a5)
{
  id result;

  if (a2)
    a3 = (void *)objc_msgSend_array(MEMORY[0x1E0C99D20], a2, (uint64_t)a3, a4, a5);
  result = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  return result;
}

void sub_18F456E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F456E44(uint64_t result, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  if (!a2)
  {
    v5 = result;
    result = objc_msgSend_getBytes_length_(a3, 0, *(_QWORD *)(result + 40), 320, a5);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F456F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F456F6C(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F457070(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F457088(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F45712C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F457144(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4571EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F457204(uint64_t result, uint64_t a2, int a3)
{
  if (!a2)
  {
    **(_DWORD **)(result + 40) = a3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_18F4572CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4572E4(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4575F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F457614(uint64_t result, uint64_t a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double *v9;
  double *v10;
  double *v11;

  v9 = *(double **)(result + 48);
  **(double **)(result + 40) = a4;
  *v9 = a5;
  v10 = *(double **)(result + 64);
  **(double **)(result + 56) = a6;
  *v10 = a7;
  v11 = *(double **)(result + 80);
  **(double **)(result + 72) = a8;
  *v11 = a9;
  **(_DWORD **)(result + 88) = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40) = a2;
  return result;
}

uint64_t sub_18F457650(uint64_t result, uint64_t a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double *v9;
  double *v10;
  double *v11;

  v9 = *(double **)(result + 48);
  **(double **)(result + 40) = a4;
  *v9 = a5;
  v10 = *(double **)(result + 64);
  **(double **)(result + 56) = a6;
  *v10 = a7;
  v11 = *(double **)(result + 80);
  **(double **)(result + 72) = a8;
  *v11 = a9;
  **(_DWORD **)(result + 88) = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40) = a2;
  return result;
}

void sub_18F457738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F457750(uint64_t result, uint64_t a2, int a3, int a4)
{
  _DWORD *v4;

  v4 = *(_DWORD **)(result + 48);
  **(_DWORD **)(result + 40) = a3;
  *v4 = a4;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F457800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F457818(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4578D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4578E8(_QWORD *result, void *a2)
{
  _QWORD *v2;

  if (a2)
  {
    v2 = result;
    result = a2;
    *(_QWORD *)(*(_QWORD *)(v2[4] + 8) + 40) = result;
  }
  return result;
}

void sub_18F4579C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4579D8(_QWORD *result, void *a2)
{
  _QWORD *v2;

  if (a2)
  {
    v2 = result;
    result = a2;
    *(_QWORD *)(*(_QWORD *)(v2[4] + 8) + 40) = result;
  }
  return result;
}

void sub_18F457ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F457AD4(_QWORD *result, void *a2, int a3, int a4)
{
  _QWORD *v6;
  _DWORD *v7;
  _DWORD *v8;

  v6 = result;
  if (a2)
  {
    result = a2;
    *(_QWORD *)(*(_QWORD *)(v6[4] + 8) + 40) = result;
  }
  v7 = (_DWORD *)v6[5];
  if (v7)
    *v7 = a3;
  v8 = (_DWORD *)v6[6];
  if (v8)
    *v8 = a4;
  return result;
}

void sub_18F457BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F457BD0(uint64_t result, char a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2;
  return result;
}

void sub_18F457C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_18F457CAC(uint64_t a1, void *a2, void *a3)
{
  id result;

  result = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (a2)
  {
    result = a2;
    **(_QWORD **)(a1 + 40) = result;
  }
  return result;
}

void sub_18F457DA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_18F457DB8(uint64_t a1, void *a2, void *a3)
{
  id result;

  result = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (a2)
  {
    result = a2;
    **(_QWORD **)(a1 + 40) = result;
  }
  return result;
}

void sub_18F457EC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_18F457EE4(uint64_t a1, void *a2)
{
  id result;

  result = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  return result;
}

void sub_18F457FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_18F457FFC(uint64_t a1, void *a2)
{
  id result;

  result = a2;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  return result;
}

void sub_18F458114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F45812C(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4581F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F45820C(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4582C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4582E0(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F458384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F45839C(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (!a2)
  {
    *(_QWORD *)(*(_QWORD *)(result[4] + 8) + 24) = a3;
    return CFRetain(*(CFTypeRef *)(*(_QWORD *)(result[4] + 8) + 24));
  }
  return result;
}

void sub_18F458494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4584AC(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F458558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F458570(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F45862C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F458644(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F458708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F458720(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4587E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4587FC(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F4588C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4588DC(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = a2 == 0;
  return result;
}

void sub_18F458984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F45899C(uint64_t result, uint64_t a2, int a3)
{
  if (!a2)
  {
    **(_DWORD **)(result + 40) = a3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t CLCopyAppsUsingLocation()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyAppsUsingLocation", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyAppsUsingLocation\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_copyAppsUsingLocation(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F458B90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLCopyActiveClientsUsingLocation()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t active;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyActiveClientsUsingLocation", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyActiveClientsUsingLocation\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  active = objc_msgSend_copyActiveClientsUsingLocation(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return active;
}

void sub_18F458CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLCopyInternalState()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyInternalState", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyInternalState\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_copyInternalState(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F458E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void CLSetLocationDefault(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = _os_activity_create(&dword_18F1DC000, "CL: CLSetLocationDefault", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v4, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v5 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289538;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    v20 = 2114;
    v21 = a1;
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLSetLocationDefault\", \"event\":%{public, location:escape_only}s, \"key\":%{public, location:escape_only}@}", buf, 0x26u);
  }
  v10 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v6, v7, v8, v9);
  objc_msgSend_setLocationDefaultForKey_value_(v10, v11, a1, a2, v12);
  os_activity_scope_leave(&v13);
}

void sub_18F458F90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLCopyMicroLocationInternalVersion()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyMicroLocationInternalVersion", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyMicroLocationInternalVersion\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_copyMicroLocationInternalVersion(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F4590DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLCopyZaxisStats()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyZaxisStats", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyZaxisStats\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_copyZaxisStats(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F459228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLCopyTechnologiesInUse()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyTechnologiesInUse", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyTechnologiesInUse\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_copyTechnologiesInUse(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F459374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

id CLCopyGnssBandsInUse()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFArray *v11;
  id v12;
  CFIndex Count;
  CFIndex v14;
  uint64_t v15;
  unint64_t v16;
  const __CFNumber *ValueAtIndex;
  const char *v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  BOOL v22;
  int v23;
  __int128 v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  char *v31;
  int valuePtr;
  os_activity_scope_state_s state;
  int v35;
  int v36;
  uint8_t buf[1632];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyGnssBandsInUse", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v0, &state);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2082;
    *(_QWORD *)&buf[20] = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyGnssBandsInUse\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = (const __CFArray *)objc_msgSend_copyGnssBandsInUse(v6, v7, v8, v9, v10);
  v12 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  if (v11)
  {
    Count = CFArrayGetCount(v11);
    if (Count && (int)Count >= 1)
    {
      v14 = 0;
      v15 = Count;
      v16 = 0x1E0CB3000uLL;
      do
      {
        valuePtr = 0;
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v11, v14);
        CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
        v20 = valuePtr & 0xF00;
        v21 = (v20 - 256) >> 8;
        v22 = v21 > 7;
        v23 = (1 << v21) & 0x8B;
        if (v22 || v23 == 0)
        {
          if ((valuePtr & 0xF00) != 0)
          {
            if (qword_1ECEDEE58 != -1)
              dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
            v30 = qword_1ECEDEE50;
            if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67240192;
              *(_DWORD *)&buf[4] = v20;
              _os_log_impl(&dword_18F1DC000, v30, OS_LOG_TYPE_ERROR, "Invalid bandUse,%{public}d", buf, 8u);
            }
            v16 = 0x1E0CB3000;
            if (sub_18F1FCA08(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE58 != -1)
                dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
              v35 = 67240192;
              v36 = v20;
              v31 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 0, "CFArrayRef CLCopyGnssBandsInUse(void)", "CoreLocation: %s\n", v31);
              if (v31 != (char *)buf)
                free(v31);
            }
          }
          goto LABEL_22;
        }
        memset(buf, 0, 32);
        *(_DWORD *)&buf[24] = valuePtr & 0xF00;
        switch(valuePtr)
        {
          case 4u:
            *(_DWORD *)buf = 4;
            v25 = xmmword_18F508DB0;
            break;
          case 2u:
            *(_DWORD *)buf = 2;
            v25 = xmmword_18F508DA0;
            break;
          case 1u:
            *(_DWORD *)buf = 1;
            v25 = xmmword_18F508DC0;
            break;
          default:
            memset(&buf[8], 0, 20);
            goto LABEL_21;
        }
        *(_OWORD *)&buf[8] = v25;
LABEL_21:
        v26 = objc_msgSend_valueWithBytes_objCType_(*(void **)(v16 + 2840), v18, (uint64_t)buf, (uint64_t)"{CLGnssBandInfo=iddi}", v19);
        objc_msgSend_addObject_(v12, v27, v26, v28, v29);
LABEL_22:
        ++v14;
      }
      while (v15 != v14);
    }
    CFRelease(v11);
  }
  os_activity_scope_leave(&state);
  return v12;
}

void sub_18F459778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t CLGetLocationDefault(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t LocationDefaultForKey;
  os_activity_scope_state_s v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v2 = _os_activity_create(&dword_18F1DC000, "CL: CLGetLocationDefault", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v14.opaque[0] = 0;
  v14.opaque[1] = 0;
  os_activity_scope_enter(v2, &v14);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v3 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289538;
    v16 = 0;
    v17 = 2082;
    v18 = "";
    v19 = 2082;
    v20 = "activity";
    v21 = 2114;
    v22 = a1;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetLocationDefault\", \"event\":%{public, location:escape_only}s, \"key\":%{public, location:escape_only}@}", buf, 0x26u);
  }
  v8 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v4, v5, v6, v7);
  LocationDefaultForKey = objc_msgSend_getLocationDefaultForKey_(v8, v9, a1, v10, v11);
  os_activity_scope_leave(&v14);
  return LocationDefaultForKey;
}

void sub_18F4598F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_18F459908()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyActivityAlarms", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyActivityAlarms\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_copyActivityAlarms(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F459A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLGetPipelinedCache()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t PipelinedCache;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLGetPipelinedCaches", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetPipelinedCaches\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  PipelinedCache = objc_msgSend_getPipelinedCache(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return PipelinedCache;
}

void sub_18F459B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLGetMotionSensorLogs()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t MotionSensorLogs;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLGetMotionSensorLogs", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetMotionSensorLogs\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  MotionSensorLogs = objc_msgSend_getMotionSensorLogs(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return MotionSensorLogs;
}

void sub_18F459CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLGetAccessoryMotionSensorLogs()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AccessoryMotionSensorLogs;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLGetAccessoryMotionSensorLogs", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetAccessoryMotionSensorLogs\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  AccessoryMotionSensorLogs = objc_msgSend_getAccessoryMotionSensorLogs(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return AccessoryMotionSensorLogs;
}

void sub_18F459E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLApplyArchivedAuthorizationDecisions(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  os_activity_scope_state_s v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = _os_activity_create(&dword_18F1DC000, "CL: CLApplyArchivedAuthorizationDecisions", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v14.opaque[0] = 0;
  v14.opaque[1] = 0;
  os_activity_scope_enter(v2, &v14);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v3 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v16 = 0;
    v17 = 2082;
    v18 = "";
    v19 = 2082;
    v20 = "activity";
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLApplyArchivedAuthorizationDecisions\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v8 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v4, v5, v6, v7);
  v12 = objc_msgSend_applyArchivedAuthorizationDecisions_(v8, v9, a1, v10, v11);
  os_activity_scope_leave(&v14);
  return v12;
}

void sub_18F459F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLGetArchivedAuthorizationDecisions(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t ArchivedAuthorizationDecisionsWithError;
  os_activity_scope_state_s v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = _os_activity_create(&dword_18F1DC000, "CL: CLGetArchivedAuthorizationDecisions", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v14.opaque[0] = 0;
  v14.opaque[1] = 0;
  os_activity_scope_enter(v2, &v14);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v3 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v16 = 0;
    v17 = 2082;
    v18 = "";
    v19 = 2082;
    v20 = "activity";
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetArchivedAuthorizationDecisions\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v8 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v4, v5, v6, v7);
  ArchivedAuthorizationDecisionsWithError = objc_msgSend_getArchivedAuthorizationDecisionsWithError_(v8, v9, a1, v10, v11);
  os_activity_scope_leave(&v14);
  return ArchivedAuthorizationDecisionsWithError;
}

void sub_18F45A0CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLStartStopAdvertisingBeacon(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t started;
  os_activity_scope_state_s v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = _os_activity_create(&dword_18F1DC000, "CL: CLStartStopAdvertisingBeacon", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v15.opaque[0] = 0;
  v15.opaque[1] = 0;
  os_activity_scope_enter(v4, &v15);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v5 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289795;
    v17 = 0;
    v18 = 2082;
    v19 = "";
    v20 = 2082;
    v21 = "activity";
    v22 = 2113;
    v23 = a1;
    v24 = 2114;
    v25 = a2;
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLStartStopAdvertisingBeacon\", \"event\":%{public, location:escape_only}s, \"region\":%{private, location:escape_only}@, \"power\":%{public, location:escape_only}@}", buf, 0x30u);
  }
  v10 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v6, v7, v8, v9);
  started = objc_msgSend_startStopAdvertisingBeacon_power_(v10, v11, a1, a2, v12);
  os_activity_scope_leave(&v15);
  return started;
}

void sub_18F45A248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLPingDaemon()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLPingDaemon", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLPingDaemon\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_pingDaemon(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F45A394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void CLPassKitNotifyPayment(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  os_activity_scope_state_s v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v6 = _os_activity_create(&dword_18F1DC000, "CL: CLPassKitNotifyPassUsage", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v14.opaque[0] = 0;
  v14.opaque[1] = 0;
  os_activity_scope_enter(v6, &v14);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v7 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v16 = 0;
    v17 = 2082;
    v18 = "";
    v19 = 2082;
    v20 = "activity";
    _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLPassKitNotifyPassUsage\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v12 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v8, v9, v10, v11);
  objc_msgSend_notifyPassKitPayment_transaction_info_(v12, v13, a1, a2, a3);
  os_activity_scope_leave(&v14);
}

void sub_18F45A4F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void CLWeatherNotifyForecast(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  NSObject *v7;
  NSObject *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  id v20;
  const char *v21;
  uint64_t v22;
  void *v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t i;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t j;
  void *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  double v43;
  double v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  void *v50;
  id obj;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  os_activity_scope_state_s state;
  _BYTE v62[128];
  _BYTE v63[128];
  uint64_t buf;
  __int16 v65;
  const char *v66;
  __int16 v67;
  const char *v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v7 = _os_activity_create(&dword_18F1DC000, "CL: CLWeatherNotifyForecastUsage", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v7, &state);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v8 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    buf = 68289282;
    v65 = 2082;
    v66 = "";
    v67 = 2082;
    v68 = "activity";
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLWeatherNotifyForecastUsage\", \"event\":%{public, location:escape_only}s}", (uint8_t *)&buf, 0x1Cu);
  }
  v9 = (void *)MEMORY[0x1E0C99D20];
  v10 = objc_opt_class();
  v11 = objc_opt_class();
  v12 = objc_opt_class();
  v13 = objc_opt_class();
  v14 = objc_opt_class();
  v15 = objc_opt_class();
  v19 = (void *)objc_msgSend_arrayWithObjects_(v9, v16, v10, v17, v18, v11, v12, v13, v14, v15, 0);
  v20 = objc_alloc(MEMORY[0x1E0C99E08]);
  v23 = (void *)objc_msgSend_initWithDictionary_copyItems_(v20, v21, (uint64_t)a1, 1, v22);
  v50 = a5;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(a1, v24, (uint64_t)&v57, (uint64_t)v63, 16);
  if (v29)
  {
    obj = a1;
    v52 = *(_QWORD *)v58;
    do
    {
      for (i = 0; i != v29; ++i)
      {
        if (*(_QWORD *)v58 != v52)
          objc_enumerationMutation(obj);
        v31 = *(_QWORD *)(*((_QWORD *)&v57 + 1) + 8 * i);
        v53 = 0u;
        v54 = 0u;
        v55 = 0u;
        v56 = 0u;
        v34 = objc_msgSend_countByEnumeratingWithState_objects_count_(v19, v25, (uint64_t)&v53, (uint64_t)v62, 16);
        if (!v34)
          goto LABEL_18;
        v35 = 0;
        v36 = *(_QWORD *)v54;
        do
        {
          for (j = 0; j != v34; ++j)
          {
            if (*(_QWORD *)v54 != v36)
              objc_enumerationMutation(v19);
            objc_msgSend_objectForKeyedSubscript_(v23, v25, v31, v32, v33);
            v35 |= objc_opt_isKindOfClass();
          }
          v34 = objc_msgSend_countByEnumeratingWithState_objects_count_(v19, v25, (uint64_t)&v53, (uint64_t)v62, 16);
        }
        while (v34);
        if ((v35 & 1) == 0)
LABEL_18:
          objc_msgSend_removeObjectForKey_(v23, v25, v31, v32, v33);
      }
      v29 = objc_msgSend_countByEnumeratingWithState_objects_count_(obj, v25, (uint64_t)&v57, (uint64_t)v63, 16);
    }
    while (v29);
  }
  v38 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v25, v26, v27, v28);
  objc_msgSend_coordinate(v50, v39, v40, v41, v42);
  v44 = v43;
  objc_msgSend_coordinate(v50, v45, v46, v47, v48);
  objc_msgSend_notifyWeatherForecast_airQualityConditions_hourlyForecasts_dailyForecasts_latitude_longitude_(v38, v49, (uint64_t)v23, MEMORY[0x1E0C9AA70], MEMORY[0x1E0C9AA60], MEMORY[0x1E0C9AA60], v44);

  os_activity_scope_leave(&state);
}

void sub_18F45A878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t CLGetClientTransientAuthorizationInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t TemporaryAuthorizationStatusForBundleId_orBundlePath_error;
  os_activity_scope_state_s v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v6 = _os_activity_create(&dword_18F1DC000, "CL: CLGetClientTransientAuthorizationInfo", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v16.opaque[0] = 0;
  v16.opaque[1] = 0;
  os_activity_scope_enter(v6, &v16);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v7 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v18 = 0;
    v19 = 2082;
    v20 = "";
    v21 = 2082;
    v22 = "activity";
    _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetClientTransientAuthorizationInfo\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v12 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v8, v9, v10, v11);
  TemporaryAuthorizationStatusForBundleId_orBundlePath_error = objc_msgSend_getTemporaryAuthorizationStatusForBundleId_orBundlePath_error_(v12, v13, a1, a2, a3);
  os_activity_scope_leave(&v16);
  return TemporaryAuthorizationStatusForBundleId_orBundlePath_error;
}

void sub_18F45AA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLSetClientTransientAuthorizationInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  NSObject *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  os_activity_scope_state_s v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v6 = _os_activity_create(&dword_18F1DC000, "CL: CLSetClientTransientAuthorizationInfo", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v16.opaque[0] = 0;
  v16.opaque[1] = 0;
  os_activity_scope_enter(v6, &v16);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v7 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v18 = 0;
    v19 = 2082;
    v20 = "";
    v21 = 2082;
    v22 = "activity";
    _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLSetClientTransientAuthorizationInfo\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v12 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v8, v9, v10, v11);
  v14 = objc_msgSend_setTemporaryAuthorizationStatusForBundleId_orBundlePath_statusData_(v12, v13, a1, a2, a3);
  os_activity_scope_leave(&v16);
  return v14;
}

void sub_18F45AB74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_18F45AB88(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel_setGestureServiceEnabled_, a1, v7, v8);
}

uint64_t sub_18F45ABB4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel_getGestureServiceEnabled_, a1, v7, v8);
}

uint64_t CLInternalPerformMigration()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLInternalPerformMigration", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLInternalPerformMigration\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_performMigration(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F45AD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLGetStatusBarIconState()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t StatusBarIconState;
  NSObject *v12;
  char *v14;
  os_activity_scope_state_s state;
  int v16;
  int v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLGetStatusBarIconState", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v0, &state);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v19 = 0;
    v20 = 2082;
    v21 = "";
    v22 = 2082;
    v23 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetStatusBarIconState\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  StatusBarIconState = objc_msgSend_getStatusBarIconState(v6, v7, v8, v9, v10);
  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v12 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    v19 = StatusBarIconState;
    _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_DEFAULT, "CLStatusBarIconState received an icon stateu of %d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v16 = 67109120;
    v17 = StatusBarIconState;
    v14 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLStatusBarIconState CLGetStatusBarIconState()", "CoreLocation: %s\n", v14);
    if (v14 != (char *)buf)
      free(v14);
  }
  os_activity_scope_leave(&state);
  return StatusBarIconState;
}

void sub_18F45AFB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void CLSetMapMatchingRouteHint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  char *v17;
  os_activity_scope_state_s state;
  int v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint8_t buf[4];
  _BYTE v26[14];
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v8 = _os_activity_create(&dword_18F1DC000, "CL: CLSetMapMatchingRouteHint", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v8, &state);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v9 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)v26 = 0;
    *(_WORD *)&v26[4] = 2082;
    *(_QWORD *)&v26[6] = "";
    v27 = 2082;
    v28 = "activity";
    _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLSetMapMatchingRouteHint\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  }
  v10 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134218496;
    *(_QWORD *)v26 = (int)a4;
    *(_WORD *)&v26[8] = 1024;
    *(_DWORD *)&v26[10] = a1;
    v27 = 1024;
    LODWORD(v28) = a2;
    _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEBUG, "RouteHints,CLSetRouteHintsForMapMatching,received,%lu,routeType,%d,stepType,%d", buf, 0x18u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v19 = 134218496;
    v20 = (int)a4;
    v21 = 1024;
    v22 = a1;
    v23 = 1024;
    v24 = a2;
    v17 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLSetMapMatchingRouteHint(CLClientLocationRouteHintType, CLClientLocationRouteHintType, CLMapsRouteHint *, int)", "CoreLocation: %s\n", v17);
    if (v17 != (char *)buf)
      free(v17);
  }
  v15 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v11, v12, v13, v14);
  objc_msgSend_setMapMatchingRouteHint_count_routingType_stepType_(v15, v16, a3, a4, a1, a2);
  os_activity_scope_leave(&state);
}

void sub_18F45B2A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void CLSetRouteHintsForMapMatching(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  const char *v14;
  char *v15;
  os_activity_scope_state_s state;
  int v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  uint8_t buf[4];
  _BYTE v22[14];
  __int16 v23;
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v6 = _os_activity_create(&dword_18F1DC000, "CL: CLSetRouteHintsForMapMatching", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v6, &state);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v7 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)v22 = 0;
    *(_WORD *)&v22[4] = 2082;
    *(_QWORD *)&v22[6] = "";
    v23 = 2082;
    v24 = "activity";
    _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLSetRouteHintsForMapMatching\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  }
  v8 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)v22 = (int)a3;
    *(_WORD *)&v22[8] = 1024;
    *(_DWORD *)&v22[10] = a1;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEBUG, "RouteHints,CLSetRouteHintsForMapMatching,received,%lu,routeType,%d", buf, 0x12u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v17 = 134218240;
    v18 = (int)a3;
    v19 = 1024;
    v20 = a1;
    v15 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLSetRouteHintsForMapMatching(CLClientLocationRouteHintType, CLMapsRouteHint *, int)", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf)
      free(v15);
  }
  v13 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v9, v10, v11, v12);
  objc_msgSend_setMapMatchingRouteHint_count_routingType_stepType_(v13, v14, a2, a3, a1, a1);
  os_activity_scope_leave(&state);
}

void sub_18F45B584(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void CLSetTrackRunHint(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  int v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  char *v19;
  os_activity_scope_state_s state;
  int v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  uint8_t buf[4];
  _BYTE v28[14];
  __int16 v29;
  const char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v2 = _os_activity_create(&dword_18F1DC000, "CL: CLSetTrackRunHint", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v2, &state);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v3 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)v28 = 0;
    *(_WORD *)&v28[4] = 2082;
    *(_QWORD *)&v28[6] = "";
    v29 = 2082;
    v30 = "activity";
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLSetTrackRunHint\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  }
  v4 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)a1;
    v6 = *(_DWORD *)(a1 + 8);
    v7 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)buf = 134349569;
    *(_QWORD *)v28 = v5;
    *(_WORD *)&v28[8] = 1025;
    *(_DWORD *)&v28[10] = v6;
    v29 = 1025;
    LODWORD(v30) = v7;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEFAULT, "TrackRunHint,CLSetTrackRunHint,received,MCTime,%{public}.1lf,lane,%{private}d,notification,%{private}d", buf, 0x18u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v16 = *(_QWORD *)a1;
    v17 = *(_DWORD *)(a1 + 8);
    v18 = *(_DWORD *)(a1 + 12);
    v21 = 134349569;
    v22 = v16;
    v23 = 1025;
    v24 = v17;
    v25 = 1025;
    v26 = v18;
    v19 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLSetTrackRunHint(CLTrackRunHint *)", "CoreLocation: %s\n", v19);
    if (v19 != (char *)buf)
      free(v19);
  }
  v12 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v8, v9, v10, v11);
  objc_msgSend_setTrackRunHint_(v12, v13, a1, v14, v15);
  os_activity_scope_leave(&state);
}

void sub_18F45B85C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t CLGetAccessoryTypeBitSet()
{
  NSObject *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v11;
  uint8_t buf[1640];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v0 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_DEBUG, "CLGetAccessoryTypeBitSet", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "int32_t CLGetAccessoryTypeBitSet()", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
  }
  v5 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v1, v2, v3, v4);
  return objc_msgSend_getAccessoryTypeBitSet(v5, v6, v7, v8, v9);
}

uint64_t CLGetAccessoryPASCDTransmissionState()
{
  NSObject *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v11;
  uint8_t buf[1640];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v0 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_DEBUG, "CLGetAccessoryPASCDTransmissionState", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLClientPASCDTransmissionState CLGetAccessoryPASCDTransmissionState()", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
  }
  v5 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v1, v2, v3, v4);
  return objc_msgSend_getAccessoryPASCDTransmissionState(v5, v6, v7, v8, v9);
}

uint64_t sub_18F45BB9C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel_getGyroCalibrationDatabaseBiasFit_atTemperature_, a1, v7, v8);
}

uint64_t sub_18F45BBD8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v5, sel_insertGyroCalibrationDatabaseBiasEstimateIfValid_temperature_variance_timestamp_, v6, v7, v8);
}

uint64_t sub_18F45BC54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v5, sel_gyroCalibrationDatabaseWipe, v6, v7, v8);
}

uint64_t sub_18F45BC70(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel_getGyroCalibrationDatabaseNumTemperatures_, a1, v7, v8);
}

uint64_t sub_18F45BC9C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;

  v7 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v7, sel_configure_, a1, a2, v8);
}

uint64_t CLGetOdometryBatchedLocations()
{
  NSObject *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v11;
  uint8_t buf[1640];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v0 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_DEFAULT, "CLGetOdometryBatchedLocations", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE58 != -1)
      dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "NSDictionary *CLGetOdometryBatchedLocations()", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
  }
  v5 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v1, v2, v3, v4);
  return objc_msgSend_getOdometryBatchedLocations(v5, v6, v7, v8, v9);
}

uint64_t CLGetControlPlaneStatusReport(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  const char *v23;
  uint64_t ControlPlaneStatusReportClear_startTime_endTime_latitude_longitude_altitude_accuracy_status;
  os_activity_scope_state_s state;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v16 = _os_activity_create(&dword_18F1DC000, "CL: CLGetControlPlaneStatusReport", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v16, &state);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v17 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289538;
    v28 = 0;
    v29 = 2082;
    v30 = "";
    v31 = 2082;
    v32 = "activity";
    v33 = 1026;
    v34 = a1;
    _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetControlPlaneStatusReport\", \"event\":%{public, location:escape_only}s, \"clear\":%{public}d}", buf, 0x22u);
  }
  v22 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v18, v19, v20, v21);
  ControlPlaneStatusReportClear_startTime_endTime_latitude_longitude_altitude_accuracy_status = objc_msgSend_getControlPlaneStatusReportClear_startTime_endTime_latitude_longitude_altitude_accuracy_status_(v22, v23, a1, a2, a3, a4, a5, a6, a7, a8);
  os_activity_scope_leave(&state);
  return ControlPlaneStatusReportClear_startTime_endTime_latitude_longitude_altitude_accuracy_status;
}

void sub_18F45C004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t CLGetEmergencyLocationSettingsVersionInfo(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t EmergencyLocationSettingsCompatibilityVersion_andContentVersion;
  os_activity_scope_state_s v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = _os_activity_create(&dword_18F1DC000, "CL: CLGetEmergencyLocationSettingsVersion", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v15.opaque[0] = 0;
  v15.opaque[1] = 0;
  os_activity_scope_enter(v4, &v15);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v5 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v17 = 0;
    v18 = 2082;
    v19 = "";
    v20 = 2082;
    v21 = "activity";
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLGetEmergencyLocationSettingsVersion\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v10 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v6, v7, v8, v9);
  EmergencyLocationSettingsCompatibilityVersion_andContentVersion = objc_msgSend_getEmergencyLocationSettingsCompatibilityVersion_andContentVersion_(v10, v11, a1, a2, v12);
  os_activity_scope_leave(&v15);
  return EmergencyLocationSettingsCompatibilityVersion_andContentVersion;
}

void sub_18F45C168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLDeleteCurrentEmergencyLocationAsset()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLDeleteCurrentEmergencyLocationAsset", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLDeleteCurrentEmergencyLocationAsset\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_deleteCurrentEmergencyLocationAsset(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F45C2B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLCopyNearbyAssetSettings()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyNearbyAssetSettings", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyNearbyAssetSettings\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  v11 = objc_msgSend_copyNearbyAssetSettings(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return v11;
}

void sub_18F45C400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLCopyNearbyAssetSettingsOfAccessoryFile(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyNearbyAssetSettingsOfAccessoryFile", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v2, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v3 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyNearbyAssetSettingsOfAccessoryFile\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  if (a1)
  {
    v8 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v4, v5, v6, v7);
    a1 = objc_msgSend_copyNearbyAssetSettingsOfAccessoryFile_(v8, v9, a1, v10, v11);
  }
  os_activity_scope_leave(&v13);
  return a1;
}

void sub_18F45C558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLCopyRoutineAssetSettings(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  os_activity_scope_state_s v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = _os_activity_create(&dword_18F1DC000, "CL: CLCopyRoutineAssetSettings", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v15.opaque[0] = 0;
  v15.opaque[1] = 0;
  os_activity_scope_enter(v4, &v15);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v5 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v17 = 0;
    v18 = 2082;
    v19 = "";
    v20 = 2082;
    v21 = "activity";
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLCopyRoutineAssetSettings\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v10 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v6, v7, v8, v9);
  v13 = objc_msgSend_copyRoutineAssetSettingsWithCompatibilityVersion_contentVersion_(v10, v11, a1, a2, v12);
  os_activity_scope_leave(&v15);
  return v13;
}

void sub_18F45C6BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLShouldDisplayEEDUI()
{
  NSObject *v0;
  NSObject *v1;
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t shouldDisplayEEDUI;
  os_activity_scope_state_s v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_18F1DC000, "CL: CLShouldDisplayEEDUI", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0;
  v13.opaque[1] = 0;
  os_activity_scope_enter(v0, &v13);

  if (qword_1ECEDEE58 != -1)
    dispatch_once(&qword_1ECEDEE58, &unk_1E2958720);
  v1 = qword_1ECEDEE50;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    v15 = 0;
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "activity";
    _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLShouldDisplayEEDUI\", \"event\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  v6 = (void *)objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, v2, v3, v4, v5);
  shouldDisplayEEDUI = objc_msgSend_shouldDisplayEEDUI(v6, v7, v8, v9, v10);
  os_activity_scope_leave(&v13);
  return shouldDisplayEEDUI;
}

void sub_18F45C808(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t CLGetEEDCloakingKey(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel_getEEDCloakingKey_, a1, v7, v8);
}

uint64_t CLGetEEDEmergencyContactNames(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel_getEEDEmergencyContactNames_, a1, v7, v8);
}

uint64_t sub_18F45C874(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend_sharedServiceClient(CLLocationInternalClient_CoreMotion, a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel_gyroCalibrationDatabaseSupportsMiniCalibration_, a1, v7, v8);
}

os_log_t sub_18F45C8A0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Core", "Client");
  qword_1ECEDEE50 = (uint64_t)result;
  return result;
}

uint64_t sub_18F45C8CC(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  float v8;
  unint64_t v9;
  unint64_t v10;
  float v11;
  float v12;
  unint64_t v13;
  float v14;
  unint64_t v15;
  float v16;
  float v17;
  float v18;
  NSObject *v19;
  char *v20;
  uint8_t buf[4];
  unint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  result = sub_18F45D65C(a2);
  if ((_DWORD)result)
  {
    v5 = 3;
    v6 = 2;
    while (1)
    {
      v7 = v6;
      v8 = sub_18F37D890(a2, v6, v6);
      v9 = v5;
      v10 = v5 - 2;
      if (v5 <= 2)
      {
        do
        {
          v11 = *(float *)sub_18F45D6FC(a1 + 12, v7, v9);
          v12 = *(float *)sub_18F45D6FC(a1 + 12, v7, v9);
          v8 = v8 + (float)((float)-(float)(v11 * v12) * *(float *)sub_18F45DA54(a1, v9++));
        }
        while (v9 != 3);
      }
      *(float *)sub_18F45DA54(a1, v7) = v8;
      if (*(float *)sub_18F45DA54(a1, v7) <= 0.0)
        break;
      if (!v7)
        return 1;
      do
      {
        v13 = v10;
        v14 = sub_18F37D890(a2, v10, v7);
        v15 = v5;
        if (v5 <= 2)
        {
          do
          {
            v16 = *(float *)sub_18F45D6FC(a1 + 12, v13, v15);
            v17 = *(float *)sub_18F45D6FC(a1 + 12, v7, v15);
            v14 = v14 + (float)((float)-(float)(v16 * v17) * *(float *)sub_18F45DA54(a1, v15++));
          }
          while (v15 != 3);
        }
        v18 = v14 / *(float *)sub_18F45DA54(a1, v7);
        *(float *)sub_18F45D6FC(a1 + 12, v13, v7) = v18;
        v10 = v13 - 1;
      }
      while (v13);
      v6 = v7 - 1;
      v5 = v7;
    }
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
    v19 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      v22 = v7;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_DEBUG, "D(%zu) <= 0 non-positive definite matrix!", buf, 0xCu);
    }
    result = sub_18F1FCA08(115, 2);
    if ((_DWORD)result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
      v20 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL CMFactoredMatrix<float, 3>::factor(const CMMatrix<T, N, N> &) [T = float, N = 3]", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf)
        free(v20);
      return 0;
    }
  }
  return result;
}

void sub_18F45CBF8(float *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  float v5;
  float v6;
  float v7;
  __float2 v8;
  float v9[3];

  v4 = 0;
  v5 = 0.0;
  do
  {
    v5 = v5 + (float)(a1[v4] * a1[v4]);
    ++v4;
  }
  while (v4 != 3);
  v6 = sqrtf(v5);
  v7 = -v6;
  if (v6 > 0.0)
    v7 = v6;
  if (v7 == 0.0)
  {
    *(_DWORD *)(a2 + 32) = 1065353216;
    *(_OWORD *)a2 = xmmword_18F508DEC;
    *(_OWORD *)(a2 + 16) = unk_18F508DFC;
  }
  else
  {
    v8 = __sincosf_stret(v6);
    v9[0] = 1.0;
    v9[1] = v8.__sinval / v6;
    v9[2] = (float)(1.0 - v8.__cosval) / (float)(v6 * v6);
    sub_18F45DC2C(a1, v9, a2);
  }
}

void sub_18F45CCB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t i;
  float v10;
  float v11;
  float *v12;
  unint64_t j;
  unint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  unint64_t m;
  unint64_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  unint64_t v29;
  float v30;
  float v31;
  float *v32;
  float v33;
  float v34;
  float *v35;
  NSObject *v36;
  char *v37;
  unint64_t k;
  float v39;
  _BYTE v40[36];
  int v41;
  unint64_t v42;
  uint8_t buf[4];
  unint64_t v44;
  float v45[3];
  uint64_t v46;

  v6 = 0;
  v46 = *MEMORY[0x1E0C80C00];
  v7 = a1 + 12;
  do
  {
    v8 = 2;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        v10 = *(float *)sub_18F3558C8(a2, v6, i);
        v11 = *(float *)sub_18F45D6FC(v7, i, v8);
        v12 = (float *)sub_18F3558C8(a2, v6, v8);
        *v12 = *v12 + (float)(v10 * v11);
      }
      *(_DWORD *)sub_18F3558C8((uint64_t)v40, v6, v8--) = 0;
    }
    while (v8);
    *(_DWORD *)sub_18F3558C8((uint64_t)v40, v6, 0) = 0;
    *(_DWORD *)sub_18F3558C8((uint64_t)v40, v6, v6) = 1065353216;
    ++v6;
  }
  while (v6 != 3);
  for (j = 2; ; --j)
  {
    v14 = 0;
    v45[j] = 0.0;
    v15 = 0.0;
    do
    {
      v16 = *(float *)sub_18F3558C8(a2, j, v14);
      v17 = v16 * *(float *)sub_18F3558C8(a2, j, v14);
      v18 = v15 + (float)(v17 * *(float *)sub_18F45DA54(a1, v14));
      v19 = *(float *)sub_18F3558C8((uint64_t)v40, j, v14);
      v20 = v19 * *(float *)sub_18F3558C8((uint64_t)v40, j, v14);
      v15 = v18 + (float)(v20 * sub_18F3551B0(a3, v14));
      v45[j] = v15;
      ++v14;
    }
    while (v14 != 3);
    if (v15 <= 0.0)
      break;
    if (!j)
    {
      for (k = 0; k != 3; ++k)
      {
        v39 = v45[k];
        *(float *)sub_18F45DA54(a1, k) = v39;
      }
      return;
    }
    for (m = 0; m != j; ++m)
    {
      v22 = 0;
      v23 = 0.0;
      do
      {
        v24 = *(float *)sub_18F3558C8(a2, m, v22);
        v25 = v24 * *(float *)sub_18F45DA54(a1, v22);
        v26 = v23 + (float)(v25 * *(float *)sub_18F3558C8(a2, j, v22));
        v27 = *(float *)sub_18F3558C8((uint64_t)v40, m, v22);
        v28 = v27 * sub_18F3551B0(a3, v22);
        v23 = v26 + (float)(v28 * *(float *)sub_18F3558C8((uint64_t)v40, j, v22++));
      }
      while (v22 != 3);
      v29 = 0;
      *(float *)sub_18F45D6FC(v7, m, j) = v23 / v15;
      do
      {
        v30 = *(float *)sub_18F45D6FC(v7, m, j);
        v31 = *(float *)sub_18F3558C8(a2, j, v29);
        v32 = (float *)sub_18F3558C8(a2, m, v29);
        *v32 = *v32 - (float)(v30 * v31);
        v33 = *(float *)sub_18F45D6FC(v7, m, j);
        v34 = *(float *)sub_18F3558C8((uint64_t)v40, j, v29);
        v35 = (float *)sub_18F3558C8((uint64_t)v40, m, v29);
        *v35 = *v35 - (float)(v33 * v34);
        ++v29;
      }
      while (v29 != 3);
    }
  }
  if (qword_1ECEDEE88 != -1)
    dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
  v36 = off_1ECEDEE80;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    v44 = j;
    _os_log_impl(&dword_18F1DC000, v36, OS_LOG_TYPE_DEBUG, "D[%zu] <= 0, matrix ! positive definite", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
    v41 = 134217984;
    v42 = j;
    v37 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMFactoredMatrix<float, 3>::thorntonTemporalUpdate(CMMatrix<T, N, N> &, const CMVector<T, N> &) [T = float, N = 3]", "CoreLocation: %s\n", v37);
    if (v37 != (char *)buf)
      free(v37);
  }
}

void sub_18F45D164(float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  float v11;
  unint64_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  char v18;
  unint64_t v19;
  float v20;
  float v21;
  char v22;
  float v23;
  float *v24;
  unint64_t v25;
  float v26;
  float v27;
  float *v28;
  float v29;
  unint64_t v30;
  float v31;
  float v32;
  float *v33;
  NSObject *v34;
  NSObject *v35;
  char *v36;
  uint64_t v38;
  int v39;
  int v40;
  unint64_t v41;
  uint8_t buf[4];
  unint64_t v43;
  float v44[3];
  float v45[3];
  uint64_t v46;

  v7 = 0;
  v46 = *MEMORY[0x1E0C80C00];
  v38 = 0;
  v39 = 0;
  v8 = (uint64_t)(a1 + 3);
LABEL_2:
  v9 = 0;
  v10 = -1;
  do
  {
    v11 = sub_18F37D890(a2, v7, v9);
    v12 = v10;
    if (v9)
    {
      do
      {
        v13 = sub_18F37D890(a2, v7, v12);
        v11 = v11 + (float)(v13 * *(float *)sub_18F45D6FC(v8, v12--, v9));
      }
      while (v12 != -1);
    }
    v45[v9] = v11;
    v44[v9] = v11 * *(float *)sub_18F45DA54((uint64_t)a1, v9);
    ++v9;
    ++v10;
  }
  while (v9 != 3);
  v14 = sub_18F3551B0(a3, v7);
  v15 = v14 + (float)(v45[0] * v44[0]);
  if (v15 <= 0.0)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
    v35 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      v43 = v7;
      _os_log_impl(&dword_18F1DC000, v35, OS_LOG_TYPE_DEBUG, "%zu: alpha <= 0, matrix ! positive definite", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
      v40 = 134217984;
      v41 = v7;
LABEL_33:
      v36 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "CMVector<T, N> CMFactoredMatrix<float, 3>::biermanObservationalUpdate(const CMMatrix<T, P, N> &, const CMVector<T, P> &, const CMVector<T, P> &) [T = float, N = 3, P = 3UL]", "CoreLocation: %s\n", v36);
      if (v36 != (char *)buf)
        free(v36);
    }
  }
  else
  {
    v16 = 1.0 / v15;
    v17 = sub_18F3551B0(a3, v7);
    v18 = 0;
    *a1 = *a1 * (float)((float)(1.0 / v15) * v17);
    v19 = 1;
    while (1)
    {
      v20 = v45[v19];
      v21 = v15 + (float)(v20 * v44[v19]);
      if (v21 <= 0.0)
        break;
      v22 = v18;
      v23 = -(float)(v20 * v16);
      v16 = 1.0 / v21;
      v24 = (float *)sub_18F45DA54((uint64_t)a1, v19);
      v25 = 0;
      *v24 = (float)(v15 * (float)(1.0 / v21)) * *v24;
      do
      {
        v26 = *(float *)sub_18F45D6FC(v8, v25, v19);
        v27 = v44[v25];
        v28 = (float *)sub_18F45D6FC(v8, v25, v19);
        v29 = v44[v19];
        *v28 = v26 + (float)(v27 * v23);
        v44[v25++] = v27 + (float)(v29 * v26);
      }
      while (v19 != v25);
      v18 = 1;
      v19 = 2;
      v15 = v21;
      if ((v22 & 1) != 0)
      {
        v30 = 0;
        v31 = v16 * sub_18F3551B0(a4, v7);
        do
        {
          v32 = v44[v30];
          v33 = (float *)sub_18F33D3D0((uint64_t)&v38, v30);
          *v33 = *v33 + (float)(v31 * v32);
          ++v30;
        }
        while (v30 != 3);
        if (++v7 != 3)
          goto LABEL_2;
        return;
      }
    }
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
    v34 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      v43 = v7;
      _os_log_impl(&dword_18F1DC000, v34, OS_LOG_TYPE_DEBUG, "%zu: alpha <= 0, matrix ! positive definite", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
      v40 = 134217984;
      v41 = v7;
      goto LABEL_33;
    }
  }
}

uint64_t sub_18F45D618()
{
  return 0;
}

uint64_t sub_18F45D620()
{
  return 0;
}

uint64_t sub_18F45D628()
{
  return 0;
}

uint64_t sub_18F45D630()
{
  return 0;
}

uint64_t sub_18F45D638()
{
  return 0;
}

uint64_t sub_18F45D64C()
{
  return 0;
}

uint64_t sub_18F45D654()
{
  return 0;
}

BOOL sub_18F45D65C(uint64_t a1)
{
  unint64_t v2;
  char v3;
  char v4;
  unint64_t v5;
  float v6;
  float v7;
  BOOL v8;

  v2 = 0;
  v3 = 1;
LABEL_2:
  v4 = v3;
  v5 = v2 + 1;
  while (1)
  {
    v6 = sub_18F37D890(a1, v2, v5);
    v7 = v6 - sub_18F37D890(a1, v5, v2);
    if (v7 <= 0.0)
      v7 = -v7;
    if (v7 > 1.0e-16)
      return v7 <= 1.0e-16;
    v8 = v5 == 2;
    v5 = 2;
    if (v8)
    {
      v3 = 0;
      v2 = 1;
      if ((v4 & 1) != 0)
        goto LABEL_2;
      return v7 <= 1.0e-16;
    }
  }
}

uint64_t sub_18F45D6FC(uint64_t a1, unint64_t a2, unint64_t a3)
{
  NSObject *v7;
  char *v8;
  NSObject *v9;
  char *v10;
  uint8_t buf[4];
  unint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a3 >= 3)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
    v7 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      v12 = a3;
      v13 = 2048;
      v14 = 3;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMFactoredMatrix.h, line 237,invalid col %zu > %zu.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
      v8 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "T &CMFactoredMatrix<float, 3>::UnitaryUpperTriangularMatrix::operator()(size_t, size_t) [T = float, N = 3]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf)
        free(v8);
    }
  }
  if (a3 <= a2)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
    v9 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      v12 = a3;
      v13 = 2048;
      v14 = a2;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_FAULT, "Assertion failed: col > row, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMFactoredMatrix.h, line 238,invalid element %zu <= %zu.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "T &CMFactoredMatrix<float, 3>::UnitaryUpperTriangularMatrix::operator()(size_t, size_t) [T = float, N = 3]", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
  }
  return a1 + 4 * (a2 + (((a3 - 1) * a3) >> 1));
}

uint64_t sub_18F45DA54(uint64_t a1, unint64_t a2)
{
  NSObject *v5;
  char *v6;
  uint8_t buf[4];
  unint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a2 >= 3)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
    v5 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      v8 = a2;
      v9 = 2048;
      v10 = 3;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: row < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMFactoredMatrix.h, line 191,invalid row %zu > %zu.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2953B88);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "T &CMFactoredMatrix<float, 3>::DiagonalMatrix::operator()(size_t) [T = float, N = 3]", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
  return a1 + 4 * a2;
}

float sub_18F45DC2C@<S0>(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  float v5;
  float v6;
  float result;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  unint64_t i;
  unint64_t v17;
  __int128 v18;
  __int128 v19;
  int v20;
  _OWORD v21[2];
  int v22;
  _BYTE v23[36];
  __int128 v24;
  __int128 v25;
  int v26;
  __int128 v27;
  __int128 v28;
  int v29;
  _OWORD v30[2];
  int v31;
  __int128 v32;
  __int128 v33;
  int v34;

  v4 = 0;
  v5 = 0.0;
  do
  {
    v5 = v5 + (float)(a1[v4] * a1[v4]);
    ++v4;
  }
  while (v4 != 3);
  v6 = *a2;
  *(float *)a3 = *a2;
  *(_QWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  *(float *)(a3 + 16) = v6;
  *(_QWORD *)(a3 + 20) = 0;
  *(_DWORD *)(a3 + 28) = 0;
  *(float *)(a3 + 32) = v6;
  result = sqrtf(v5);
  if (result <= 0.0)
    result = -result;
  if (result != 0.0)
  {
    v8 = 0;
    v10 = a1[1];
    v9 = a1[2];
    v11 = *a1;
    v12 = -*a1;
    LODWORD(v32) = 0;
    *((float *)&v32 + 1) = v9;
    *((float *)&v32 + 2) = -v10;
    *((float *)&v32 + 3) = -v9;
    LODWORD(v33) = 0;
    *(_QWORD *)((char *)&v33 + 4) = __PAIR64__(LODWORD(v10), LODWORD(v11));
    *((float *)&v33 + 3) = v12;
    v34 = 0;
    v13 = a2[1];
    v26 = 0;
    v24 = v32;
    v25 = v33;
    do
    {
      *(float *)((char *)&v24 + v8) = v13 * *(float *)((char *)&v24 + v8);
      v8 += 4;
    }
    while (v8 != 36);
    v14 = 0;
    v29 = v26;
    v27 = v24;
    v28 = v25;
    v15 = a2[2];
    v18 = v32;
    v19 = v33;
    v20 = v34;
    do
    {
      *(float *)((char *)&v18 + v14) = v15 * *(float *)((char *)&v18 + v14);
      v14 += 4;
    }
    while (v14 != 36);
    v21[0] = v18;
    v21[1] = v19;
    v22 = v20;
    sub_18F38101C((uint64_t)v21, (uint64_t)&v32, (uint64_t)v23);
    for (i = 0; i != 9; ++i)
      *((float *)&v27 + i) = sub_18F359948((uint64_t)v23, i) + *((float *)&v27 + i);
    v17 = 0;
    v30[0] = v27;
    v30[1] = v28;
    v31 = v29;
    do
    {
      result = sub_18F359948((uint64_t)v30, v17) + *(float *)(a3 + 4 * v17);
      *(float *)(a3 + 4 * v17++) = result;
    }
    while (v17 != 9);
  }
  return result;
}

_QWORD *sub_18F45DDE0(_QWORD *a1)
{
  *a1 = off_1E29496C0;
  sub_18F20CB2C((uint64_t)a1, 0, 0);
  sub_18F2A8438((uint64_t)(a1 + 4));
  return sub_18F3DB8A0(a1);
}

uint64_t sub_18F45DE2C(uint64_t a1)
{
  uint64_t result;
  int IntegerValue;
  BOOL v4;
  unint64_t TimeStamp;
  BOOL v6;

  result = IOHIDEventGetType();
  if ((_DWORD)result == 3)
  {
    IntegerValue = IOHIDEventGetIntegerValue();
    result = IOHIDEventGetIntegerValue();
    if (IntegerValue == 65289 && result == 1)
    {
      v4 = IOHIDEventGetIntegerValue() == 0;
      TimeStamp = IOHIDEventGetTimeStamp();
      sub_18F1FD20C(TimeStamp);
      v6 = v4;
      return sub_18F1FD2C8(a1, 0, (uint64_t)&v6, 1);
    }
  }
  return result;
}

void sub_18F45E858(_QWORD *a1)
{
  sub_18F45DDE0(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F45E880()
{
  if (qword_1ECEDFB78 != -1)
    dispatch_once(&qword_1ECEDFB78, &unk_1E2953BC8);
  return qword_1ECEDFB70;
}

void sub_18F45E8C0()
{
  uint64_t v0;
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  char v5;
  char v6;
  unint64_t *v7;
  unint64_t v8;
  const __CFData *v9;
  CFIndex Length;
  const UInt8 *BytePtr;
  __int128 *v12;
  int v13;
  NSObject *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  NSObject *v38;
  NSObject *v39;
  _QWORD *v40;
  NSObject *v41;
  char *v42;
  NSObject *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  char v48;
  int v49;
  int v50;
  __int16 v51;
  CFIndex v52;
  uint8_t buf[8];
  _QWORD v54[205];

  v54[204] = *MEMORY[0x1E0C80C00];
  v0 = sub_18F204AE4();
  v1 = *(_QWORD *)(v0 + 24);
  v2 = *(std::__shared_weak_count **)(v0 + 32);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  v48 = 0;
  v5 = sub_18F1EE944(v1, "EnableMagnetometerCoexistenceCompensation", (BOOL *)&v48);
  v6 = v5;
  if (!v2)
    goto LABEL_8;
  v7 = (unint64_t *)&v2->__shared_owners_;
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (v8)
  {
LABEL_8:
    if ((v5 & 1) != 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
  std::__shared_weak_count::__release_weak(v2);
  if ((v6 & 1) == 0)
LABEL_9:
    v48 = 1;
LABEL_10:
  sub_18F204AE4();
  if (*(_BYTE *)(qword_1ECEDFE08 + 16))
  {
    v9 = (const __CFData *)sub_18F3C88F8();
  }
  else
  {
    sub_18F35C374("kCLConnectionMessageCompassCalibrationData", buf);
    v16 = (void *)MEMORY[0x1E0C99E60];
    v17 = objc_opt_class();
    v18 = objc_opt_class();
    v19 = objc_opt_class();
    v24 = objc_msgSend_setWithObjects_(v16, v20, v17, v21, v22, v18, v19, 0);
    v46 = *(_QWORD *)buf;
    v47 = (std::__shared_weak_count *)v54[0];
    if (v54[0])
    {
      v26 = (unint64_t *)(v54[0] + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    v31 = (void *)objc_msgSend_sendMessage_withReplyClassesSync_(CMMotionUtils, v23, (uint64_t)&v46, v24, v25);
    v32 = v47;
    if (v47)
    {
      v33 = (unint64_t *)&v47->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    v9 = (const __CFData *)objc_msgSend_objectForKeyedSubscript_(v31, v28, (uint64_t)CFSTR("CMCompassCalibrationData"), v29, v30);
    v35 = (std::__shared_weak_count *)v54[0];
    if (v54[0])
    {
      v36 = (unint64_t *)(v54[0] + 8);
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
  }
  if (!v9)
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
    v38 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v38, OS_LOG_TYPE_DEFAULT, "#Warning CPAS data response was invaild.", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      goto LABEL_51;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 == -1)
      goto LABEL_81;
    goto LABEL_88;
  }
  if (!v48)
    goto LABEL_51;
  Length = CFDataGetLength(v9);
  BytePtr = CFDataGetBytePtr(v9);
  v12 = (__int128 *)BytePtr;
  if (!BytePtr)
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
    v39 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v39, OS_LOG_TYPE_DEFAULT, "#Warning CPAS data is NULL", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      goto LABEL_51;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 == -1)
      goto LABEL_81;
LABEL_88:
    dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
LABEL_81:
    LOWORD(v49) = 0;
    v44 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "static void CLMagnetometerCoexistenceNotifier::create()", "CoreLocation: %s\n", v44);
LABEL_82:
    if (v44 != (char *)buf)
      free(v44);
    goto LABEL_51;
  }
  if (Length >= 2)
  {
    v13 = *BytePtr;
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
    v14 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v13;
      LOWORD(v54[0]) = 2048;
      *(_QWORD *)((char *)v54 + 2) = Length;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_INFO, "cpas version is %u, length is %ld bytes", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
      v49 = 67109376;
      v50 = v13;
      v51 = 2048;
      v52 = Length;
      v45 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLMagnetometerCoexistenceNotifier::create()", "CoreLocation: %s\n", v45);
      if (v45 != (char *)buf)
        free(v45);
    }
    if (v13 == 5 && Length == 76)
    {
      v15 = (_QWORD *)operator new();
      sub_18F467754(v15, v12);
LABEL_70:
      qword_1ECEDFB70 = (uint64_t)v15;
      return;
    }
    if (v13 == 6 && Length == 76)
    {
      v15 = (_QWORD *)operator new();
      sub_18F46A680(v15, v12);
      goto LABEL_70;
    }
    if (v13 == 10 && Length == 76)
    {
      v15 = (_QWORD *)operator new();
      sub_18F46E604(v15, v12);
      goto LABEL_70;
    }
    if (v13 == 11 && Length == 28)
    {
      v15 = (_QWORD *)operator new();
      sub_18F48D818(v15, v12);
      goto LABEL_70;
    }
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
    v43 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v13;
      LOWORD(v54[0]) = 2048;
      *(_QWORD *)((char *)v54 + 2) = Length;
      _os_log_impl(&dword_18F1DC000, v43, OS_LOG_TYPE_INFO, "Warning: cpas data was found but did not match any versions. version (%u) length (%ld)", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
      v49 = 67109376;
      v50 = v13;
      v51 = 2048;
      v52 = Length;
      v44 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLMagnetometerCoexistenceNotifier::create()", "CoreLocation: %s\n", v44);
      goto LABEL_82;
    }
  }
LABEL_51:
  if (!qword_1ECEDFB70)
  {
    v40 = (_QWORD *)operator new();
    sub_18F1E61EC((uint64_t)v40, (uint64_t)"CLMagnetometerCoexistenceNotifier", 2);
    *v40 = &off_1E294B828;
    qword_1ECEDFB70 = (uint64_t)v40;
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
    v41 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v41, OS_LOG_TYPE_INFO, "Magnetometer coexistence compensation is disabled", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E29547C8);
      LOWORD(v49) = 0;
      v42 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLMagnetometerCoexistenceNotifier::create()", "CoreLocation: %s\n", v42);
      if (v42 != (char *)buf)
        free(v42);
    }
  }
}

void sub_18F45F28C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10F1C406E37FBC4);
  _Unwind_Resume(a1);
}

void sub_18F45F3A0(_QWORD *a1)
{
  sub_18F3DB8A0(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F45F3C4(uint64_t a1, float *a2)
{
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;
  float v16;
  float v17;
  unint64_t v19;
  unint64_t v20;
  float v21[3];

  v4 = *(_BYTE *)(a1 + 8);
  if ((v4 & 1) != 0)
  {
    v5 = 0;
    v6 = a1 + 16;
    while (*(float *)(a1 + v5 * 4 + 20) == a2[v5 + 1]
         && *(float *)(a1 + v5 * 4 + 24) == a2[v5 + 2]
         && *(float *)(a1 + v5 * 4 + 28) == a2[v5 + 3]
         && *(float *)(a1 + v5 * 4 + 32) == a2[v5 + 4]
         && *(float *)(a1 + v5 * 4 + 36) == a2[v5 + 5]
         && *(float *)(a1 + v5 * 4 + 40) == a2[v5 + 6])
    {
      v5 += 6;
      if (v5 == 48)
      {
        v7 = 0;
        while (*(float *)(a1 + 212 + v7 * 4) == a2[v7 + 49])
        {
          if (++v7 == 7)
          {
            if (*(float *)(a1 + 240) != a2[56])
              goto LABEL_15;
            v19 = 0;
            do
            {
              v20 = v19;
              if ((float *)v6 != a2)
                break;
              ++v19;
            }
            while (v20 < 0x12);
            if ((v4 & 2) != 0 && v20 <= 0x11)
              goto LABEL_16;
            goto LABEL_17;
          }
        }
        break;
      }
    }
LABEL_15:
    if ((v4 & 2) != 0)
    {
LABEL_16:
      v8 = *(float *)(a1 + 12);
      v9 = sub_18F45F57C(v6, v8).f32[0];
      v11 = v10;
      v13 = v12;
      v14 = sub_18F45F57C((uint64_t)a2, v8).f32[0];
      v15 = *(_QWORD *)a1;
      v21[0] = v14 - v9;
      v21[1] = v16 - v11;
      v21[2] = v17 - v13;
      (*(void (**)(uint64_t, float *))(*(_QWORD *)v15 + 32))(v15, v21);
    }
  }
  else
  {
    (*(void (**)(void))(**(_QWORD **)a1 + 24))();
  }
LABEL_17:
  *(_BYTE *)(a1 + 8) |= 1u;
  memcpy((void *)(a1 + 16), a2, 0x11AuLL);
  return sub_18F45F6D8(a1);
}

float32x2_t sub_18F45F57C(uint64_t a1, float a2)
{
  uint64_t v2;
  float v3;
  float v4;
  float v5;
  uint64_t v6;
  float32x2_t v7;
  float32x2_t v8;
  uint64_t v10;
  float32x2_t v11;
  float32x2_t v12;
  uint64_t v13;

  v2 = 0;
  v3 = *(float *)(a1 + 224);
  while (1)
  {
    v4 = *(float *)(a1 + 196 + 4 * v2);
    if ((float)(v3 + v4) > a2)
      break;
    if (++v2 == 6)
    {
      v4 = *(float *)(a1 + 220);
      break;
    }
  }
  v5 = (float)((float)(a2 - v4) / (float)(v3 + v3)) + 0.5;
  if (v5 <= 0.0)
  {
    v10 = a1 + 24 * v2;
    v11 = *(float32x2_t *)(v10 + 4);
    v12 = *(float32x2_t *)(v10 + 16);
  }
  else
  {
    if (v5 < 1.0)
    {
      v6 = a1 + 24 * v2;
      v7 = (float32x2_t)vdup_n_s32(0x3C8EFA35u);
      v8 = vmul_f32(vadd_f32(vmul_n_f32(*(float32x2_t *)(v6 + 4), a2), *(float32x2_t *)(v6 + 16)), v7);
      return vadd_f32(v8, vmul_n_f32(vsub_f32(vmul_f32(vadd_f32(vmul_n_f32(*(float32x2_t *)(v6 + 28), a2), *(float32x2_t *)(v6 + 40)), v7), v8), v5 * (float)(v5 * (float)((float)(v5 * -2.0) + 3.0))));
    }
    v13 = a1 + 24 * v2;
    v11 = *(float32x2_t *)(v13 + 28);
    v12 = *(float32x2_t *)(v13 + 40);
  }
  return vmul_f32(vadd_f32(vmul_n_f32(v11, a2), v12), (float32x2_t)vdup_n_s32(0x3C8EFA35u));
}

uint64_t sub_18F45F6D8(uint64_t result)
{
  _BYTE *v1;
  float v2;
  unsigned int v3;
  int v4;
  __n128 v5;
  int v6;
  unsigned int v7;
  float v8;
  _BYTE *v9;
  _DWORD v10[3];

  if ((~*(unsigned __int8 *)(result + 8) & 3) == 0)
  {
    v1 = (_BYTE *)result;
    v2 = *(float *)(result + 12);
    v5.n128_u64[0] = (unint64_t)sub_18F45F57C(result + 16, v2);
    v10[0] = v5.n128_u32[0];
    v10[1] = v4;
    v10[2] = v3;
    v5.n128_f32[0] = (float)(v2 + -2.0) * 0.25;
    if (v5.n128_f32[0] >= 0.0)
    {
      v6 = (int)v5.n128_f32[0];
      if ((int)v5.n128_f32[0] < 0x11)
      {
        *(float *)&v7 = (float)v6;
        v8 = v5.n128_f32[0] - (float)v6;
        v9 = &v1[v6];
        LOBYTE(v7) = v9[244];
        LOBYTE(v3) = v9[245];
        v5.n128_f32[0] = (float)v7 + (float)(v8 * (float)((float)v3 - (float)v7));
        goto LABEL_8;
      }
      v5.n128_u8[0] = v1[261];
    }
    else
    {
      v5.n128_u8[0] = v1[244];
    }
    v5.n128_f32[0] = (float)v5.n128_u32[0];
LABEL_8:
    v5.n128_f32[0] = v5.n128_f32[0] * 0.00017453;
    return (*(uint64_t (**)(_QWORD, _DWORD *, BOOL, __n128))(**(_QWORD **)v1 + 16))(*(_QWORD *)v1, v10, v2 < 20.0, v5);
  }
  return result;
}

uint64_t sub_18F45F7B4(uint64_t a1, float a2)
{
  NSObject *v5;
  char *v6;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a2 == 3.4028e38)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953BE8);
    v5 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134217984;
      v8 = 0x47EFFFFFE0000000;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_FAULT, "Assertion failed: temperature != 3.40282347e+38F, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMNonlinearTemperatureFit.cpp, line 77,temperature,%f.", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2953BE8);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CMNonlinearTemperatureFit::feedGyroTemperature(float)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
  *(_BYTE *)(a1 + 8) |= 2u;
  *(float *)(a1 + 12) = a2;
  return sub_18F45F6D8(a1);
}

uint64_t sub_18F45FE08(uint64_t a1, char a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 8) = xmmword_18F508E60;
  *(_QWORD *)(a1 + 24) = 0x7FF8000000000000;
  *(_BYTE *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 40) = 0;
  v3 = (uint64_t *)(a1 + 40);
  sub_18F354BB8(a1 + 48);
  *(_QWORD *)(a1 + 6008) = 0x7FF8000000000000;
  *(_QWORD *)(a1 + 6016) = 0x7FF8000000000000;
  *(_BYTE *)(a1 + 6024) = 0;
  if (*(_BYTE *)(a1 + 32))
  {
    v4 = operator new();
    sub_18F3CC2D8(v4, 1.69);
    sub_18F44CEA0(v3, v4);
    v5 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(v5 + 10912) = sub_18F45FF14;
    *(_QWORD *)(v5 + 10920) = a1;
  }
  *(_QWORD *)(a1 + 5976) = sub_18F45FF3C;
  *(_QWORD *)(a1 + 5984) = a1;
  return a1;
}

void sub_18F45FECC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  MEMORY[0x194001438](v4, 0x10E0C408232E938);
  *(_OWORD *)(v1 + 5976) = 0u;
  sub_18F44CEA0(v2, 0);
  _Unwind_Resume(a1);
}

double sub_18F45FF14(int a1, unint64_t a2, uint64_t a3)
{
  double result;

  if ((a1 - 1) <= 1)
    *(_DWORD *)a3 = a1;
  result = (double)a2 * 0.000001;
  *(double *)(a3 + 8) = result;
  return result;
}

void sub_18F45FF3C(int a1, uint64_t a2, int *a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  uint8_t buf[4];
  double v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)a3 + 32))
    sub_18F3CC810(*((_QWORD *)a3 + 5), a1, a2);
  v6 = *a3;
  if (a1)
  {
    if (v6 == 1)
    {
      *a3 = 3;
      *((double *)a3 + 1) = (double)(unint64_t)a2 * 0.000001;
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
      v7 = qword_1EE16D8E0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134217984;
        v11 = (double)(unint64_t)a2 * 0.000001;
        _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEBUG, "[CMAccessoryActivity] Walking. time %f\n", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D8D8 == -1)
        {
LABEL_20:
          v9 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMAccessoryActivity::stepDetectorCallback(BOOL, uint64_t)", "CoreLocation: %s\n", v9);
          if (v9 != (char *)buf)
            free(v9);
          return;
        }
LABEL_22:
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
        goto LABEL_20;
      }
    }
  }
  else if (v6 == 3)
  {
    *a3 = 1;
    *((double *)a3 + 1) = (double)(unint64_t)a2 * 0.000001;
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
    v8 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      v11 = (double)(unint64_t)a2 * 0.000001;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEBUG, "[CMAccessoryActivity] Not walking. time %f\n", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 == -1)
        goto LABEL_20;
      goto LABEL_22;
    }
  }
}

void sub_18F460240(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  double v15;
  NSObject *v16;
  float32x4_t v17;
  uint64_t v18;
  __int128 v19;
  NSObject *v20;
  char *v21;
  char *v22;
  char *v23;
  float32x2_t v24;
  int v25;
  float v26;
  float v27;
  float v28;
  __int128 v29;
  int32x2_t v30;
  unint64_t v31;
  __int128 v32;
  int v33;
  double v34;
  __int16 v35;
  uint64_t v36;
  uint8_t buf[4];
  double v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 6024))
  {
    v24 = *(float32x2_t *)(a2 + 8);
    v25 = *(_DWORD *)(a2 + 16);
    v6 = sub_18F200A14((float *)(a2 + 32));
    v8 = *(float *)(a2 + 24) + v7;
    v10 = v9 + *(float *)(a2 + 28);
    v26 = *(float *)(a2 + 20) + v6;
    v27 = v8;
    v28 = v10;
    v29 = xmmword_18F508E70;
    v30 = vdup_n_s32(0x3A03126Fu);
    v31 = 0xBF80000000000000;
    v32 = *(_OWORD *)(a2 + 32);
    v11 = sub_18F355EC8(a1 + 48, &v24, *(double *)a2);
    v13 = v12;
    *(double *)(a1 + 6008) = v11;
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
    v14 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218240;
      v38 = v11;
      v39 = 2048;
      v40 = v13;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_DEBUG, "[CMAccessoryActivity] Start impulse start %f, end, %f.\n", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
      v33 = 134218240;
      v34 = v11;
      v35 = 2048;
      v36 = v13;
      v21 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "CMAccessoryStepDetector::Impulse CMAccessoryActivity::feedImuSampleToStep(const AccessoryActivity::ImuData *const)", "CoreLocation: %s\n", v21);
      if (v21 != (char *)buf)
        free(v21);
    }
    v15 = *(double *)(a1 + 6008);
    *(_QWORD *)(a1 + 6008) = 0x7FF8000000000000;
    *(_QWORD *)(a1 + 6016) = 0x7FF8000000000000;
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
    v16 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218240;
      v38 = v15;
      v39 = 2048;
      v40 = v13;
      _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_DEBUG, "[CMAccessoryActivity] End impulse start %f, end, %f.\n", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
      v33 = 134218240;
      v34 = v15;
      v35 = 2048;
      v36 = v13;
      v23 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "CMAccessoryStepDetector::Impulse CMAccessoryActivity::feedImuSampleToStep(const AccessoryActivity::ImuData *const)", "CoreLocation: %s\n", v23);
      if (v23 != (char *)buf)
        free(v23);
    }
    *(double *)(a1 + 16) = v15;
    *(_QWORD *)(a1 + 24) = v13;
    v18 = *(_QWORD *)(a1 + 40);
    if (v18)
      sub_18F3CEAD0(v18, a2, v17);
    v19 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a1;
    *(_OWORD *)(a3 + 16) = v19;
  }
  else
  {
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
    v20 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_DEFAULT, "[CMAccessoryActivity] headsetOrientation is not set. Do nothing.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953C08);
      v24.i16[0] = 0;
      v22 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "AccessoryActivity::ActivityPacket CMAccessoryActivity::feedIMUData(const AccessoryActivity::ImuData *const)", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf)
        free(v22);
    }
    *(_QWORD *)a3 = 0;
    *(_OWORD *)(a3 + 8) = xmmword_18F508E60;
    *(_QWORD *)(a3 + 24) = 0x7FF8000000000000;
  }
}

os_log_t sub_18F460794()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1EE16D8E0 = (uint64_t)result;
  return result;
}

void sub_18F4607C0(_BYTE *a1, uint64_t a2)
{
  NSObject *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  __CFRunLoopTimer *v8;
  CFAbsoluteTime Current;
  NSObject *global_queue;
  const char *v11;
  char *v12;
  _QWORD block[5];
  int v14;
  const char *v15;
  uint8_t buf[4];
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2954AE8);
  v4 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    if (*a1)
      v5 = "open";
    else
      v5 = "closed";
    *(_DWORD *)buf = 136315138;
    v17 = v5;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEBUG, "Cover %s", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2954AE8);
    if (*a1)
      v11 = "open";
    else
      v11 = "closed";
    v14 = 136315138;
    v15 = v11;
    v12 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "static void CLCompass::onCoverState(const BOOL *, void *)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf)
      free(v12);
  }
  if (*a1)
  {
    if (*(_QWORD *)(a2 + 56))
    {
      if (*(_BYTE *)(a2 + 48))
      {
        *(_BYTE *)(a2 + 28) = 0;
        (*(void (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2);
        objc_msgSend_unregister_forNotification_(*(void **)(*(_QWORD *)(a2 + 40) + 16), v6, *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8), 0, v7);
        *(_BYTE *)(a2 + 64) = 1;
        v8 = *(__CFRunLoopTimer **)(a2 + 56);
        Current = CFAbsoluteTimeGetCurrent();
        CFRunLoopTimerSetNextFireDate(v8, Current + 3.0);
      }
    }
    *(CFAbsoluteTime *)(a2 + 72) = CFAbsoluteTimeGetCurrent();
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F46123C;
    block[3] = &unk_1E2955738;
    block[4] = a2;
    dispatch_async(global_queue, block);
  }
}

void sub_18F460A4C(uint64_t a1, const char *a2, __int128 *a3, uint64_t a4, uint64_t a5)
{
  int v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  _QWORD v12[5];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  sub_18F3DE3EC(a1, a2, (uint64_t)a3, a4, a5);
  v8 = *(_DWORD *)a2;
  v9 = a3[1];
  v17 = *a3;
  v18 = v9;
  v10 = a3[3];
  v19 = a3[2];
  v20 = v10;
  if (!v8)
  {
    v11 = sub_18F204AE4();
    v12[1] = 3221225472;
    v13 = v17;
    v14 = v18;
    v15 = v19;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[2] = sub_18F461210;
    v12[3] = &unk_1E2958028;
    v12[4] = a4;
    v16 = v20;
    sub_18F1F5E28(v11, (uint64_t)v12);
  }
}

_QWORD *sub_18F460AF0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t *(*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;

  *(_QWORD *)a1 = &off_1E294BB38;
  v2 = MEMORY[0x1E0C809B0];
  if (*(_QWORD *)(a1 + 88))
  {
    CFRunLoopTimerInvalidate(*(CFRunLoopTimerRef *)(a1 + 56));
    CFRelease(*(CFTypeRef *)(a1 + 56));
    *(_QWORD *)(a1 + 56) = 0;
    if (qword_1EE16E910 != -1)
      dispatch_once(&qword_1EE16E910, &unk_1E2953BA8);
    v3 = qword_1EE16E900;
    v4 = *(_QWORD *)(a1 + 88);
    v5 = sub_18F204AE4();
    v18 = v2;
    v19 = 3221225472;
    v20 = sub_18F1F5EE0;
    v21 = &unk_1E2956E98;
    v24 = 0;
    v22 = v3;
    v23 = v4;
    sub_18F1F5E28(v5, (uint64_t)&v18);
    v6 = *(_QWORD *)(a1 + 88);
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    *(_QWORD *)(a1 + 88) = 0;
  }
  if (*(_QWORD *)(a1 + 96))
  {
    v7 = sub_18F3918E4();
    v8 = *(_QWORD *)(a1 + 96);
    v9 = sub_18F204AE4();
    v18 = v2;
    v19 = 3221225472;
    v20 = sub_18F1F5EE0;
    v21 = &unk_1E2956E98;
    v24 = 0;
    v22 = v7;
    v23 = v8;
    sub_18F1F5E28(v9, (uint64_t)&v18);
    v10 = *(_QWORD *)(a1 + 96);
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    *(_QWORD *)(a1 + 96) = 0;
  }
  if (*(_QWORD *)(a1 + 112))
  {
    v11 = sub_18F3DD3D0();
    v12 = *(_QWORD *)(a1 + 112);
    v13 = sub_18F204AE4();
    v18 = v2;
    v19 = 3221225472;
    v20 = sub_18F1F5EE0;
    v21 = &unk_1E2956E98;
    v24 = 4;
    v22 = v11;
    v23 = v12;
    sub_18F1F5E28(v13, (uint64_t)&v18);
    v14 = *(_QWORD *)(a1 + 112);
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v15 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 120) = 0;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  v16 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v16)
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
  return sub_18F3DB8A0((_QWORD *)a1);
}

void sub_18F460CC0(uint64_t a1)
{
  sub_18F460AF0(a1);
  JUMPOUT(0x194001438);
}

double sub_18F460CE4(uint64_t a1, int a2, double *a3)
{
  double result;
  double v5;
  CFRunLoopTimerRef v6;
  const char *v7;
  uint64_t v8;
  NSObject *v9;
  char *v10;
  CFRunLoopTimerContext context;
  uint8_t buf[1640];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = 0.0;
  if (!a2)
  {
    v5 = *a3;
    if (*a3 <= 0.0)
    {
      *(_BYTE *)(a1 + 28) = 0;
      (*(void (**)(uint64_t, double))(*(_QWORD *)a1 + 56))(a1, v5);
      objc_msgSend_unregister_forNotification_(*(void **)(*(_QWORD *)(a1 + 40) + 16), v7, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), 0, v8);
      *(_BYTE *)(a1 + 48) = 0;
    }
    else
    {
      if (qword_1EE16E910 != -1)
        dispatch_once(&qword_1EE16E910, &unk_1E2953BA8);
      if (!*(_QWORD *)(a1 + 88))
      {
        context.version = 0;
        context.info = (void *)a1;
        memset(&context.retain, 0, 24);
        v6 = CFRunLoopTimerCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1.79769313e308, 1.79769313e308, 0, 0, (CFRunLoopTimerCallBack)sub_18F460FA8, &context);
        *(_QWORD *)(a1 + 56) = v6;
        if (v6)
        {
          sub_18F204AE4();
          CFRunLoopAddTimer(*(CFRunLoopRef *)qword_1ECEDFE08, *(CFRunLoopTimerRef *)(a1 + 56), (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
        }
        else
        {
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2954AE8);
          v9 = qword_1EE16D690;
          if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_FAULT, "Could not create timer", buf, 2u);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EE16D698 != -1)
              dispatch_once(&qword_1EE16D698, &unk_1E2954AE8);
            v10 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "virtual CFTimeInterval CLCompass::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v10);
            if (v10 != (char *)buf)
              free(v10);
          }
        }
        if (qword_1EE16E910 != -1)
          dispatch_once(&qword_1EE16E910, &unk_1E2953BA8);
        *(double *)(a1 + 72) = (*(double (**)(uint64_t))(*(_QWORD *)qword_1EE16E900 + 56))(qword_1EE16E900);
      }
      *(_BYTE *)(a1 + 48) = 1;
      if (!*(_BYTE *)(a1 + 64))
        sub_18F460FD8(a1);
    }
    return *(double *)(a1 + 32);
  }
  return result;
}

uint64_t sub_18F460FA8(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_BYTE *)(a2 + 48))
    result = sub_18F460FD8(a2);
  *(_BYTE *)(a2 + 64) = 0;
  return result;
}

uint64_t sub_18F460FD8(uint64_t a1)
{
  _BOOL8 v2;
  NSObject *v3;
  int v4;
  const char *v5;
  char *v7;
  uint8_t buf[4];
  _BOOL4 v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 83))
    v2 = *(_BYTE *)(a1 + 84) != 0;
  else
    v2 = *(double *)(a1 + 72) > 0.0 && CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 72) < 432000.0;
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2954AE8);
  v3 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
  {
    v4 = *(unsigned __int8 *)(a1 + 83);
    *(_DWORD *)buf = 67109376;
    v9 = v2;
    v10 = 1024;
    v11 = v4;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEBUG, "Cover attached,%d,forced,%d", buf, 0xEu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2954AE8);
    v7 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLCompass::startCompass()", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf)
      free(v7);
  }
  objc_msgSend_register_forNotification_registrationInfo_(*(void **)(*(_QWORD *)(a1 + 40) + 16), v5, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), 0, 0);
  return (*(uint64_t (**)(uint64_t, _BOOL8))(*(_QWORD *)a1 + 48))(a1, v2);
}

uint64_t sub_18F461210(uint64_t a1)
{
  _BYTE *v2;

  v2 = *(_BYTE **)(a1 + 32);
  if (*(double *)(a1 + 96) > 0.0)
    v2[28] = 1;
  return (*(uint64_t (**)(_BYTE *, uint64_t))(*(_QWORD *)v2 + 72))(v2, a1 + 40);
}

uint64_t sub_18F46123C(uint64_t a1)
{
  if (qword_1EE16E910 != -1)
    dispatch_once(&qword_1EE16E910, &unk_1E2953BA8);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)qword_1EE16E900 + 48))(qword_1EE16E900, *(_QWORD *)(a1 + 32) + 72);
}

uint64_t sub_18F461874(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t started;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  void *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  double v47;
  double v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  double v57;
  double v58;
  void *v59;

  if (objc_msgSend_walking(*(void **)(a1 + 32), a2, a3, a4, a5))
  {
    v10 = *(void **)(a1 + 40);
    v11 = (void *)objc_msgSend_endDate(*(void **)(a1 + 32), v6, v7, v8, v9);
    started = objc_msgSend_startDate(*(void **)(a1 + 32), v12, v13, v14, v15);
    objc_msgSend_timeIntervalSinceDate_(v11, v17, started, v18, v19);
    v21 = v20;
    objc_msgSend_trueWalkInBout(v10, v22, v23, v24, v25);
    return objc_msgSend_setTrueWalkInBout_(v10, v27, v28, v29, v30, v21 + v26);
  }
  else
  {
    v32 = objc_msgSend_running(*(void **)(a1 + 32), v6, v7, v8, v9);
    v37 = *(void **)(a1 + 40);
    if (v32)
    {
      v38 = (void *)objc_msgSend_endDate(*(void **)(a1 + 32), v33, v34, v35, v36);
      v43 = objc_msgSend_startDate(*(void **)(a1 + 32), v39, v40, v41, v42);
      objc_msgSend_timeIntervalSinceDate_(v38, v44, v43, v45, v46);
      v48 = v47;
      objc_msgSend_trueRunInBout(v37, v49, v50, v51, v52);
      v58 = v48 + v57;
      v59 = v37;
    }
    else
    {
      objc_msgSend_setTrueWalkInBout_(*(void **)(a1 + 40), v33, v34, v35, v36, 0.0);
      v59 = *(void **)(a1 + 40);
      v58 = 0.0;
    }
    return objc_msgSend_setTrueRunInBout_(v59, v53, v54, v55, v56, v58);
  }
}

uint64_t sub_18F461950(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *Object;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  const char *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  double v33;
  double v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  double v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  double v45;
  double v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  double v51;
  double v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  double v61;
  _DWORD *v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;

  Object = (void *)objc_msgSend_lastObject(*(void **)(a1 + 32), a2, a3, a4, a5);
  result = objc_msgSend_isSameStateAs_(Object, v7, *(_QWORD *)(a1 + 40), v8, v9);
  if ((_DWORD)result)
  {
    result = objc_msgSend_isTimeFromActivity_toActivity_withinLimitForAttribute_(CMMotionActivityFiltering, v11, (uint64_t)Object, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
    if ((_DWORD)result)
    {
      v16 = (void *)objc_msgSend_endDate(*(void **)(a1 + 40), v12, v13, v14, v15);
      objc_msgSend_timeIntervalSinceReferenceDate(v16, v17, v18, v19, v20);
      objc_msgSend_setEndTime_(Object, v21, v22, v23, v24);
      (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
      if ((objc_msgSend_walking(*(void **)(a1 + 40), v25, v26, v27, v28) & 1) == 0
        && !objc_msgSend_running(*(void **)(a1 + 40), v29, v30, v31, v32))
      {
        return 1;
      }
      objc_msgSend_trueRunInBout(*(void **)(a1 + 48), v29, v30, v31, v32);
      v34 = v33;
      objc_msgSend_trueWalkInBout(*(void **)(a1 + 48), v35, v36, v37, v38);
      v40 = v39;
      objc_msgSend_trueRunInBout(*(void **)(a1 + 48), v41, v42, v43, v44);
      v46 = v34 / (v40 + v45);
      objc_msgSend_trueWalkInBout(*(void **)(a1 + 48), v47, v48, v49, v50);
      v52 = v51;
      objc_msgSend_trueRunInBout(*(void **)(a1 + 48), v53, v54, v55, v56);
      if (v46 <= dbl_18F508EA0[v52 + v61 >= 3600.0])
      {
        v62 = (_DWORD *)objc_msgSend_motionActivity(Object, v57, v58, v59, v60);
        if (v46 >= 0.1)
        {
          *v62 = 8;
          v66 = 1;
          goto LABEL_11;
        }
        v66 = 0;
        v67 = 4;
      }
      else
      {
        v62 = (_DWORD *)objc_msgSend_motionActivity(Object, v57, v58, v59, v60);
        v66 = 0;
        v67 = 8;
      }
      *v62 = v67;
LABEL_11:
      objc_msgSend_setIsRunWalk_(Object, v63, v66, v64, v65);
      return 1;
    }
  }
  return result;
}

uint64_t sub_18F461AB4()
{
  _QWORD *v0;
  uint64_t result;

  v0 = (_QWORD *)operator new();
  result = sub_18F1E61EC((uint64_t)v0, (uint64_t)"CLProximityNotifier", 1);
  *v0 = &off_1E294AB18;
  v0[4] = 0;
  v0[5] = 0;
  qword_1EE16E918 = (uint64_t)v0;
  return result;
}

void sub_18F461B14(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10F1C40BE01E9BALL);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F461B38(_QWORD *a1)
{
  *a1 = &off_1E294AB18;
  sub_18F461BA4((uint64_t)a1, 0, 0);
  sub_18F2A8438((uint64_t)(a1 + 4));
  return sub_18F3DB8A0(a1);
}

void sub_18F461B80(_QWORD *a1)
{
  sub_18F461B38(a1);
  JUMPOUT(0x194001438);
}

void sub_18F461BA4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t *v8;
  uint64_t (*v9)(uint64_t);
  uint64_t v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  char v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;

  if (!a2)
  {
    v18 = v3;
    v19 = v4;
    v8 = (uint64_t *)(a1 + 32);
    v7 = *(_QWORD *)(a1 + 32);
    if (v7)
    {
      if (a3)
      {
LABEL_4:
        v9 = sub_18F461C80;
        v10 = a1;
LABEL_12:
        sub_18F203148(v7, (uint64_t)v9, v10);
        return;
      }
    }
    else
    {
      v11 = (_QWORD *)sub_18F1E0F30();
      v15 = 0x80000FF00;
      v16 = 0;
      sub_18F1E9BC8(v11, (uint64_t)&v15, (uint64_t *)&v17);
      sub_18F346DC8((uint64_t)v8, &v17);
      v12 = (std::__shared_weak_count *)*((_QWORD *)&v17 + 1);
      if (*((_QWORD *)&v17 + 1))
      {
        v13 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      sub_18F4D49D8((_DWORD *)*v8, 14);
      v7 = *v8;
      if (a3)
        goto LABEL_4;
    }
    v9 = 0;
    v10 = 0;
    goto LABEL_12;
  }
}

uint64_t sub_18F461C80(uint64_t a1)
{
  uint64_t result;
  int IntegerValue;
  unint64_t TimeStamp;
  double v5;
  int v6;

  result = IOHIDEventGetType();
  if ((_DWORD)result == 14)
  {
    IntegerValue = IOHIDEventGetIntegerValue();
    TimeStamp = IOHIDEventGetTimeStamp();
    v5 = sub_18F1FD20C(TimeStamp);
    v6 = IntegerValue;
    return sub_18F1FD2C8(a1, 0, (uint64_t)&v5, 16);
  }
  return result;
}

void sub_18F461DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v15, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F461EE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18F461F00(uint64_t a1, CLConnectionMessage **a2)
{
  void *Dictionary;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  char *v20;
  uint8_t buf[4];
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (*a2)
  {
    Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
    if (objc_msgSend_objectForKeyedSubscript_(Dictionary, v3, (uint64_t)CFSTR("CMErrorMessage"), v4, v5))
    {
      v9 = (void *)objc_msgSend_objectForKeyedSubscript_(Dictionary, v6, (uint64_t)CFSTR("CMErrorMessage"), v7, v8);
      v10 = (void *)MEMORY[0x1E0CB35C8];
      v15 = objc_msgSend_integerValue(v9, v11, v12, v13, v14);
      v17 = objc_msgSend_errorWithDomain_code_userInfo_(v10, v16, (uint64_t)CFSTR("CMErrorDomain"), v15, 0);
      if (qword_1EE16D8E8 != -1)
        dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
      v18 = qword_1EE16D8F0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D8F0, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v22 = v17;
        _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_ERROR, "Failed with error %{public}@", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D8E8 == -1)
        {
LABEL_17:
          v20 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "-[CMContextConfigurationManager connect]_block_invoke", "CoreLocation: %s\n", v20);
          if (v20 != (char *)buf)
            free(v20);
          return;
        }
LABEL_19:
        dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
        goto LABEL_17;
      }
    }
  }
  else
  {
    if (qword_1EE16D8E8 != -1)
      dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
    v19 = qword_1EE16D8F0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8F0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_ERROR, "Failed with unknown internal error.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8E8 == -1)
        goto LABEL_17;
      goto LABEL_19;
    }
  }
}

void sub_18F4621DC(uint64_t a1)
{
  id Weak;
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t ExecutablePathFromPid;
  void *v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  pid_t v21;
  __int16 v22;
  id v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  Weak = objc_loadWeak((id *)(a1 + 32));
  v2 = getpid();
  ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2, v4, v5);
  if (ExecutablePathFromPid)
  {
    v7 = (void *)ExecutablePathFromPid;
    if (qword_1EE16D8E8 != -1)
      dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
    v8 = qword_1EE16D8F0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8F0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446722;
      v19 = objc_msgSend_UTF8String(v7, v9, v10, v11, v12);
      v20 = 1026;
      v21 = getpid();
      v22 = 2050;
      v23 = Weak;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "Client connection interrupt, %{public}s, %{public}d, %{public}p", buf, 0x1Cu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8E8 != -1)
        dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
      objc_msgSend_UTF8String(v7, v13, v14, v15, v16);
      getpid();
      v17 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMContextConfigurationManager connect]_block_invoke", "CoreLocation: %s\n", v17);
      if (v17 != (char *)buf)
        free(v17);
    }
  }
}

void sub_18F462784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4627A8(uint64_t a1, CLConnectionMessage **a2)
{
  void *Dictionary;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  NSObject *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  char *v38;
  char *v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint8_t buf[4];
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (*a2 && (Dictionary = (void *)CLConnectionMessage::getDictionary(*a2)) != 0)
  {
    v7 = Dictionary;
    v8 = objc_msgSend_objectForKeyedSubscript_(Dictionary, v4, (uint64_t)CFSTR("CMErrorMessage"), v5, v6);
    if (v8)
    {
      v12 = (void *)v8;
      if (qword_1EE16D8E8 != -1)
        dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
      v13 = qword_1EE16D8F0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D8F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v51 = (uint64_t)v12;
        _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEFAULT, "Error in writeContextConfiguration: %@", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D8E8 != -1)
          dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
        v39 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "-[CMContextConfigurationManager writeContextConfiguration:withHandler:]_block_invoke", "CoreLocation: %s\n", v39);
        if (v39 != (char *)buf)
          free(v39);
      }
      v18 = (void *)MEMORY[0x1E0CB35C8];
      v19 = (int)objc_msgSend_intValue(v12, v14, v15, v16, v17);
      v21 = objc_msgSend_errorWithDomain_code_userInfo_(v18, v20, (uint64_t)CFSTR("CMErrorDomain"), v19, 0);
      return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), v21);
    }
    if (!objc_msgSend_objectForKeyedSubscript_(v7, v9, (uint64_t)CFSTR("CMReturnCode"), v10, v11))
    {
      if (qword_1EE16D8E8 != -1)
        dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
      v27 = qword_1EE16D8F0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D8F0, OS_LOG_TYPE_DEFAULT))
      {
        v32 = (void *)objc_msgSend_description(v7, v28, v29, v30, v31);
        *(_DWORD *)buf = 136446210;
        v51 = objc_msgSend_UTF8String(v32, v33, v34, v35, v36);
        _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_DEFAULT, "Unable to parse message (%{public}s) for query response", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D8E8 != -1)
          dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
        v44 = (void *)objc_msgSend_description(v7, v40, v41, v42, v43);
        objc_msgSend_UTF8String(v44, v45, v46, v47, v48);
        v49 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "-[CMContextConfigurationManager writeContextConfiguration:withHandler:]_block_invoke", "CoreLocation: %s\n", v49);
        if (v49 != (char *)buf)
          free(v49);
      }
      v21 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], v37, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
      return (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), v21);
    }
    return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), 0);
  }
  else
  {
    if (qword_1EE16D8E8 != -1)
      dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
    v23 = qword_1EE16D8F0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8F0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_ERROR, "Unable to parse response.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8E8 != -1)
        dispatch_once(&qword_1EE16D8E8, &unk_1E2954EA8);
      v38 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMContextConfigurationManager writeContextConfiguration:withHandler:]_block_invoke", "CoreLocation: %s\n", v38);
      if (v38 != (char *)buf)
        free(v38);
    }
    v25 = *(_QWORD *)(a1 + 32);
    v26 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], v24, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
    return (*(uint64_t (**)(uint64_t, uint64_t))(v25 + 16))(v25, v26);
  }
}

os_log_t sub_18F462CF4()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "ContextConfiguration");
  qword_1EE16D8F0 = (uint64_t)result;
  return result;
}

void sub_18F463338(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  char *v9;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v2 + 16058))
    {
      sub_18F3F6D04(v2);
      if ((*(_DWORD *)(a1 + 112) | 2) == 3)
      {
        v3 = *(_DWORD **)(a1 + 32);
        if (v3)
        {
          v3[552] = 0;
          v3[682] = 0;
          v3[812] = 0;
          v3[942] = 0;
          v3[1502] = 0;
          v3[1632] = 0;
          v3[1762] = 0;
          v3[1458] = 0;
          v3[1892] = 0;
        }
        else
        {
          v4 = *(char **)(a1 + 40);
          if (v4)
            sub_18F355E70(v4);
        }
        v5 = *(_QWORD *)(a1 + 96);
        if (v5 && *(_DWORD *)(a1 + 108) != 4)
          sub_18F4E7CF0(v5, 4, (uint64_t)buf);
        *(_BYTE *)(a1 + 72) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_BYTE *)(a1 + 48) = 0;
      }
      *(_DWORD *)(a1 + 112) = 0;
      *(_BYTE *)(a1 + 88) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 108) - 1;
        if (v7 > 5)
          v8 = "kUnknown";
        else
          v8 = off_1E29587C8[v7];
        *(_DWORD *)buf = 136315138;
        v11 = v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking re-enabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::enable(const T *) [T = CMHeadTrackingController::EUserInteractedWithDevice]", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf)
          free(v9);
      }
    }
  }
}

void sub_18F4635CC(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  char *v9;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v2 + 16058))
    {
      sub_18F3F6D04(v2);
      if ((*(_DWORD *)(a1 + 112) | 2) == 3)
      {
        v3 = *(_DWORD **)(a1 + 32);
        if (v3)
        {
          v3[552] = 0;
          v3[682] = 0;
          v3[812] = 0;
          v3[942] = 0;
          v3[1502] = 0;
          v3[1632] = 0;
          v3[1762] = 0;
          v3[1458] = 0;
          v3[1892] = 0;
        }
        else
        {
          v4 = *(char **)(a1 + 40);
          if (v4)
            sub_18F355E70(v4);
        }
        v5 = *(_QWORD *)(a1 + 96);
        if (v5 && *(_DWORD *)(a1 + 108) != 4)
          sub_18F4E7CF0(v5, 4, (uint64_t)buf);
        *(_BYTE *)(a1 + 72) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_BYTE *)(a1 + 48) = 0;
      }
      *(_DWORD *)(a1 + 112) = 0;
      *(_BYTE *)(a1 + 88) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 108) - 1;
        if (v7 > 5)
          v8 = "kUnknown";
        else
          v8 = off_1E29587C8[v7];
        *(_DWORD *)buf = 136315138;
        v11 = v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking re-enabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::enable(const T *) [T = CMHeadTrackingController::ESrcMoved]", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf)
          free(v9);
      }
    }
  }
}

void sub_18F463860(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  char *v9;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v2 + 16058))
    {
      sub_18F3F6D04(v2);
      if ((*(_DWORD *)(a1 + 112) | 2) == 3)
      {
        v3 = *(_DWORD **)(a1 + 32);
        if (v3)
        {
          v3[552] = 0;
          v3[682] = 0;
          v3[812] = 0;
          v3[942] = 0;
          v3[1502] = 0;
          v3[1632] = 0;
          v3[1762] = 0;
          v3[1458] = 0;
          v3[1892] = 0;
        }
        else
        {
          v4 = *(char **)(a1 + 40);
          if (v4)
            sub_18F355E70(v4);
        }
        v5 = *(_QWORD *)(a1 + 96);
        if (v5 && *(_DWORD *)(a1 + 108) != 4)
          sub_18F4E7CF0(v5, 4, (uint64_t)buf);
        *(_BYTE *)(a1 + 72) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_BYTE *)(a1 + 48) = 0;
      }
      *(_DWORD *)(a1 + 112) = 0;
      *(_BYTE *)(a1 + 88) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 108) - 1;
        if (v7 > 5)
          v8 = "kUnknown";
        else
          v8 = off_1E29587C8[v7];
        *(_DWORD *)buf = 136315138;
        v11 = v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking re-enabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::enable(const T *) [T = CMHeadTrackingController::EAuxHasBeenStatic]", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf)
          free(v9);
      }
    }
  }
}

void sub_18F463AF4(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  char *v9;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v2 + 16058))
    {
      sub_18F3F6D04(v2);
      if ((*(_DWORD *)(a1 + 112) | 2) == 3)
      {
        v3 = *(_DWORD **)(a1 + 32);
        if (v3)
        {
          v3[552] = 0;
          v3[682] = 0;
          v3[812] = 0;
          v3[942] = 0;
          v3[1502] = 0;
          v3[1632] = 0;
          v3[1762] = 0;
          v3[1458] = 0;
          v3[1892] = 0;
        }
        else
        {
          v4 = *(char **)(a1 + 40);
          if (v4)
            sub_18F355E70(v4);
        }
        v5 = *(_QWORD *)(a1 + 96);
        if (v5 && *(_DWORD *)(a1 + 108) != 4)
          sub_18F4E7CF0(v5, 4, (uint64_t)buf);
        *(_BYTE *)(a1 + 72) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_BYTE *)(a1 + 48) = 0;
      }
      *(_DWORD *)(a1 + 112) = 0;
      *(_BYTE *)(a1 + 88) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 108) - 1;
        if (v7 > 5)
          v8 = "kUnknown";
        else
          v8 = off_1E29587C8[v7];
        *(_DWORD *)buf = 136315138;
        v11 = v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking re-enabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::enable(const T *) [T = CMHeadTrackingController::EStandToSit]", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf)
          free(v9);
      }
    }
  }
}

void sub_18F463D88(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  char *v9;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v2 + 16058))
    {
      sub_18F3F6D04(v2);
      if ((*(_DWORD *)(a1 + 112) | 2) == 3)
      {
        v3 = *(_DWORD **)(a1 + 32);
        if (v3)
        {
          v3[552] = 0;
          v3[682] = 0;
          v3[812] = 0;
          v3[942] = 0;
          v3[1502] = 0;
          v3[1632] = 0;
          v3[1762] = 0;
          v3[1458] = 0;
          v3[1892] = 0;
        }
        else
        {
          v4 = *(char **)(a1 + 40);
          if (v4)
            sub_18F355E70(v4);
        }
        v5 = *(_QWORD *)(a1 + 96);
        if (v5 && *(_DWORD *)(a1 + 108) != 4)
          sub_18F4E7CF0(v5, 4, (uint64_t)buf);
        *(_BYTE *)(a1 + 72) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_BYTE *)(a1 + 48) = 0;
      }
      *(_DWORD *)(a1 + 112) = 0;
      *(_BYTE *)(a1 + 88) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 108) - 1;
        if (v7 > 5)
          v8 = "kUnknown";
        else
          v8 = off_1E29587C8[v7];
        *(_DWORD *)buf = 136315138;
        v11 = v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking re-enabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::enable(const T *) [T = CMHeadTrackingController::EJBLBackBelowLimit]", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf)
          free(v9);
      }
    }
  }
}

void sub_18F46401C(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  char *v9;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v2 + 16058))
    {
      sub_18F3F6D04(v2);
      if ((*(_DWORD *)(a1 + 112) | 2) == 3)
      {
        v3 = *(_DWORD **)(a1 + 32);
        if (v3)
        {
          v3[552] = 0;
          v3[682] = 0;
          v3[812] = 0;
          v3[942] = 0;
          v3[1502] = 0;
          v3[1632] = 0;
          v3[1762] = 0;
          v3[1458] = 0;
          v3[1892] = 0;
        }
        else
        {
          v4 = *(char **)(a1 + 40);
          if (v4)
            sub_18F355E70(v4);
        }
        v5 = *(_QWORD *)(a1 + 96);
        if (v5 && *(_DWORD *)(a1 + 108) != 4)
          sub_18F4E7CF0(v5, 4, (uint64_t)buf);
        *(_BYTE *)(a1 + 72) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_BYTE *)(a1 + 48) = 0;
      }
      *(_DWORD *)(a1 + 112) = 0;
      *(_BYTE *)(a1 + 88) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 108) - 1;
        if (v7 > 5)
          v8 = "kUnknown";
        else
          v8 = off_1E29587C8[v7];
        *(_DWORD *)buf = 136315138;
        v11 = v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking re-enabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::enable(const T *) [T = CMHeadTrackingController::EDetectedFace]", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf)
          free(v9);
      }
    }
  }
}

double sub_18F4642B0(uint64_t a1, _QWORD *a2, double result)
{
  uint64_t v4;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  NSObject *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  char *v14;
  char *v15;
  uint8_t buf[4];
  double v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v4 = *(_QWORD *)(a1 + 24);
    if (!*(_BYTE *)(v4 + 16058) && (!*(_BYTE *)(a1 + 89) || (*(_DWORD *)(a1 + 112) | 2) != 3))
    {
      sub_18F3F6B60(v4);
      *(_DWORD *)(a1 + 108) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 112) - 1;
        if (v7 > 3)
          v8 = "kUnknown";
        else
          v8 = off_1E29587F8[v7];
        *(_DWORD *)buf = 136315138;
        v17 = *(double *)&v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking disabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v14 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::disable(const T *) [T = CMHeadTrackingController::EWalking]", "CoreLocation: %s\n", v14);
        if (v14 != (char *)buf)
          free(v14);
      }
      if (*(_QWORD *)(a1 + 56) && *(_DWORD *)(a1 + 112) == 3)
      {
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = qword_1EE16D820;
        if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
        {
          v10 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
          *(_DWORD *)buf = 134217984;
          v17 = v10;
          _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEBUG, "[CMHeadTrackingController] Time between stand and disable: %f seconds", buf, 0xCu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D818 != -1)
            dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
          v15 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::disable(const T *) [T = CMHeadTrackingController::EWalking]", "CoreLocation: %s\n", v15);
          if (v15 != (char *)buf)
            free(v15);
        }
        v11 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        v13 = *(double *)(a1 + 264);
        v12 = *(double *)(a1 + 272);
        if (v12 <= v11)
          v12 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        if (v13 >= v11)
          v13 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        *(double *)(a1 + 264) = v13;
        *(double *)(a1 + 272) = v12;
        result = v11 + *(double *)(a1 + 280);
        *(double *)(a1 + 280) = result;
        ++*(_DWORD *)(a1 + 288);
      }
    }
  }
  return result;
}

double sub_18F4646BC(uint64_t a1, _QWORD *a2, double result)
{
  uint64_t v4;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  NSObject *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  char *v14;
  char *v15;
  uint8_t buf[4];
  double v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v4 = *(_QWORD *)(a1 + 24);
    if (!*(_BYTE *)(v4 + 16058) && (!*(_BYTE *)(a1 + 89) || (*(_DWORD *)(a1 + 112) | 2) != 3))
    {
      sub_18F3F6B60(v4);
      *(_DWORD *)(a1 + 108) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 112) - 1;
        if (v7 > 3)
          v8 = "kUnknown";
        else
          v8 = off_1E29587F8[v7];
        *(_DWORD *)buf = 136315138;
        v17 = *(double *)&v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking disabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v14 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::disable(const T *) [T = CMHeadTrackingController::EJBLExceededLimit]", "CoreLocation: %s\n", v14);
        if (v14 != (char *)buf)
          free(v14);
      }
      if (*(_QWORD *)(a1 + 56) && *(_DWORD *)(a1 + 112) == 3)
      {
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = qword_1EE16D820;
        if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
        {
          v10 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
          *(_DWORD *)buf = 134217984;
          v17 = v10;
          _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEBUG, "[CMHeadTrackingController] Time between stand and disable: %f seconds", buf, 0xCu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D818 != -1)
            dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
          v15 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::disable(const T *) [T = CMHeadTrackingController::EJBLExceededLimit]", "CoreLocation: %s\n", v15);
          if (v15 != (char *)buf)
            free(v15);
        }
        v11 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        v13 = *(double *)(a1 + 264);
        v12 = *(double *)(a1 + 272);
        if (v12 <= v11)
          v12 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        if (v13 >= v11)
          v13 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        *(double *)(a1 + 264) = v13;
        *(double *)(a1 + 272) = v12;
        result = v11 + *(double *)(a1 + 280);
        *(double *)(a1 + 280) = result;
        ++*(_DWORD *)(a1 + 288);
      }
    }
  }
  return result;
}

double sub_18F464AC8(uint64_t a1, _QWORD *a2, double result)
{
  uint64_t v4;
  NSObject *v6;
  unsigned int v7;
  const char *v8;
  NSObject *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  char *v14;
  char *v15;
  uint8_t buf[4];
  double v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 104))
  {
    v4 = *(_QWORD *)(a1 + 24);
    if (!*(_BYTE *)(v4 + 16058) && (!*(_BYTE *)(a1 + 89) || (*(_DWORD *)(a1 + 112) | 2) != 3))
    {
      sub_18F3F6B60(v4);
      *(_DWORD *)(a1 + 108) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v6 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 112) - 1;
        if (v7 > 3)
          v8 = "kUnknown";
        else
          v8 = off_1E29587F8[v7];
        *(_DWORD *)buf = 136315138;
        v17 = *(double *)&v8;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] FSM state: tracking disabled from route %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v14 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::disable(const T *) [T = CMHeadTrackingController::EInVehicle]", "CoreLocation: %s\n", v14);
        if (v14 != (char *)buf)
          free(v14);
      }
      if (*(_QWORD *)(a1 + 56) && *(_DWORD *)(a1 + 112) == 3)
      {
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v9 = qword_1EE16D820;
        if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
        {
          v10 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
          *(_DWORD *)buf = 134217984;
          v17 = v10;
          _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEBUG, "[CMHeadTrackingController] Time between stand and disable: %f seconds", buf, 0xCu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D818 != -1)
            dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
          v15 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::disable(const T *) [T = CMHeadTrackingController::EInVehicle]", "CoreLocation: %s\n", v15);
          if (v15 != (char *)buf)
            free(v15);
        }
        v11 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        v13 = *(double *)(a1 + 264);
        v12 = *(double *)(a1 + 272);
        if (v12 <= v11)
          v12 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        if (v13 >= v11)
          v13 = (double)(unint64_t)(*a2 - *(_QWORD *)(a1 + 56)) * 0.000001;
        *(double *)(a1 + 264) = v13;
        *(double *)(a1 + 272) = v12;
        result = v11 + *(double *)(a1 + 280);
        *(double *)(a1 + 280) = result;
        ++*(_DWORD *)(a1 + 288);
      }
    }
  }
  return result;
}

uint64_t sub_18F464ED4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(_QWORD *)result = &unk_1E29454B8;
  *(_QWORD *)(result + 8) = 9;
  *(_WORD *)(result + 16) = 512;
  *(_QWORD *)(result + 24) = a2;
  *(_QWORD *)(result + 32) = a3;
  *(_QWORD *)(result + 40) = a4;
  *(_BYTE *)(result + 48) = 0;
  *(_QWORD *)(result + 80) = 0;
  *(_WORD *)(result + 88) = 0;
  *(_QWORD *)(result + 56) = 0;
  *(_QWORD *)(result + 64) = 0;
  *(_WORD *)(result + 72) = 0;
  *(_BYTE *)(result + 90) = 1;
  *(_QWORD *)(result + 96) = a5;
  *(_BYTE *)(result + 104) = a6;
  *(_DWORD *)(result + 108) = 0;
  *(_DWORD *)(result + 112) = 0;
  *(_QWORD *)(result + 120) = 0;
  *(_QWORD *)(result + 128) = 0;
  *(_OWORD *)(result + 136) = xmmword_18F504010;
  *(_QWORD *)(result + 152) = 0;
  *(_DWORD *)(result + 160) = 0;
  *(_OWORD *)(result + 168) = xmmword_18F504010;
  *(_QWORD *)(result + 184) = 0;
  *(_DWORD *)(result + 192) = 0;
  *(_OWORD *)(result + 200) = xmmword_18F504010;
  *(_QWORD *)(result + 216) = 0;
  *(_DWORD *)(result + 224) = 0;
  *(_OWORD *)(result + 232) = xmmword_18F504010;
  *(_QWORD *)(result + 248) = 0;
  *(_DWORD *)(result + 256) = 0;
  *(_QWORD *)(result + 264) = 0x7FEFFFFFFFFFFFFFLL;
  *(_OWORD *)(result + 272) = xmmword_18F508EE0;
  *(_DWORD *)(result + 288) = 0;
  *(_QWORD *)(result + 296) = 0x7FEFFFFFFFFFFFFFLL;
  *(_OWORD *)(result + 304) = xmmword_18F508EE0;
  *(_DWORD *)(result + 320) = 0;
  *(_QWORD *)(result + 328) = 0x7FEFFFFFFFFFFFFFLL;
  *(_OWORD *)(result + 336) = xmmword_18F508EE0;
  *(_DWORD *)(result + 352) = 0;
  *(_QWORD *)(result + 360) = 0x7FF8000000000000;
  *(_QWORD *)(result + 368) = 0x404E000000000000;
  *(_OWORD *)(result + 376) = xmmword_18F508EF0;
  if (a5)
  {
    if (a6)
    {
      *(_QWORD *)(a5 + 10912) = sub_18F464FC0;
      *(_QWORD *)(a5 + 10920) = result;
    }
  }
  return result;
}

void sub_18F464FC0(int a1, unint64_t a2, uint64_t a3)
{
  NSObject *v5;
  double v6;
  double v7;
  double v8;
  double v9;
  _DWORD *v10;
  uint64_t v11;
  _DWORD *v12;
  NSObject *v13;
  NSObject *v14;
  double v15;
  double v16;
  double v17;
  double v18;
  unint64_t v19;
  unint64_t v20;
  NSObject *v21;
  char *v22;
  char *v23;
  char *v24;
  _BYTE buf[12];
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a1 == 2)
  {
    v11 = *(_QWORD *)(a3 + 24);
    if (*(_BYTE *)(v11 + 16058))
    {
      if (*(_DWORD *)(a3 + 112) != 2 || *(_BYTE *)(a3 + 88))
      {
        *(_DWORD *)(a3 + 108) = 4;
        *(_QWORD *)(a3 + 64) = a2;
        *(_QWORD *)buf = a2;
        sub_18F4E7CF0(a3, 7, (uint64_t)buf);
      }
LABEL_24:
      ++*(_DWORD *)(a3 + 128);
      *(_QWORD *)(a3 + 120) = a2;
      if (!*(_QWORD *)(a3 + 56))
        return;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v14 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
      {
        v15 = (double)(a2 - *(_QWORD *)(a3 + 56)) * 0.000001;
        *(_DWORD *)buf = 134217984;
        *(double *)&buf[4] = v15;
        _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_DEBUG, "[CMHeadTrackingController] Time between standing and sitting: %f seconds", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v23 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::sitStandDetectorCallback(TransitionState, uint64_t)", "CoreLocation: %s\n", v23);
        if (v23 != buf)
          free(v23);
      }
      v16 = (double)(a2 - *(_QWORD *)(a3 + 56)) * 0.000001;
      v18 = *(double *)(a3 + 200);
      v17 = *(double *)(a3 + 208);
      if (v17 <= v16)
        v17 = (double)(a2 - *(_QWORD *)(a3 + 56)) * 0.000001;
      if (v18 >= v16)
        v18 = (double)(a2 - *(_QWORD *)(a3 + 56)) * 0.000001;
      *(double *)(a3 + 200) = v18;
      *(double *)(a3 + 208) = v17;
      *(double *)(a3 + 216) = v16 + *(double *)(a3 + 216);
      v10 = (_DWORD *)(a3 + 224);
      goto LABEL_35;
    }
    if (*(_BYTE *)(a3 + 73))
    {
      sub_18F3F631C(v11, 1);
      v12 = *(_DWORD **)(a3 + 32);
      v12[552] = 0;
      v12[682] = 0;
      v12[812] = 0;
      v12[942] = 0;
      v12[1502] = 0;
      v12[1632] = 0;
      v12[1762] = 0;
      v12[1458] = 0;
      v12[1892] = 0;
      *(_BYTE *)(a3 + 73) = 0;
      *(_QWORD *)(a3 + 64) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v13 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Reset tracker on Stand->Sit when already enabled", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 2))
        goto LABEL_24;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
        goto LABEL_56;
    }
    else
    {
      v19 = *(_QWORD *)(a3 + 56);
      if (!v19)
        goto LABEL_24;
      v20 = a2 - v19;
      if (a2 <= v19 || v20 > 0x3D08FF)
        goto LABEL_24;
      *(_QWORD *)(a3 + 80) = a2;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v21 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134349312;
        *(double *)&buf[4] = (float)((float)v20 * 0.000001);
        v26 = 2050;
        v27 = 0x4010000000000000;
        _os_log_impl(&dword_18F1DC000, v21, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Back to back sit-stand transitions. dt, %{public}.3f, windowSize, %{public}.3f", buf, 0x16u);
      }
      if (!sub_18F1FCA08(115, 2))
        goto LABEL_24;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
        goto LABEL_56;
    }
    dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
LABEL_56:
    v24 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::sitStandDetectorCallback(TransitionState, uint64_t)", "CoreLocation: %s\n", v24);
    if (v24 != buf)
      free(v24);
    goto LABEL_24;
  }
  if (a1 == 1)
  {
    *(_BYTE *)(a3 + 73) = 0;
    *(_QWORD *)(a3 + 56) = a2;
    *(_QWORD *)(a3 + 64) = 0;
    sub_18F3FFAB0(*(_QWORD *)(a3 + 24), a2);
    ++*(_DWORD *)(a3 + 132);
    if (*(_QWORD *)(a3 + 120))
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v5 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
      {
        v6 = (double)(a2 - *(_QWORD *)(a3 + 120)) * 0.000001;
        *(_DWORD *)buf = 134217984;
        *(double *)&buf[4] = v6;
        _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEBUG, "[CMHeadTrackingController] Time between sitting and standing: %f seconds", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v22 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::sitStandDetectorCallback(TransitionState, uint64_t)", "CoreLocation: %s\n", v22);
        if (v22 != buf)
          free(v22);
      }
      v7 = (double)(a2 - *(_QWORD *)(a3 + 120)) * 0.000001;
      v9 = *(double *)(a3 + 232);
      v8 = *(double *)(a3 + 240);
      if (v8 <= v7)
        v8 = (double)(a2 - *(_QWORD *)(a3 + 120)) * 0.000001;
      if (v9 >= v7)
        v9 = (double)(a2 - *(_QWORD *)(a3 + 120)) * 0.000001;
      *(double *)(a3 + 232) = v9;
      *(double *)(a3 + 240) = v8;
      *(double *)(a3 + 248) = v7 + *(double *)(a3 + 248);
      v10 = (_DWORD *)(a3 + 256);
LABEL_35:
      ++*v10;
    }
  }
}

void sub_18F465704(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 112) != 2 || *(_BYTE *)(a1 + 88))
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v4 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "[CMHeadTrackingController] Received user interacted with device event. timestampUs, %llu", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedUserInteractedWithDeviceEvent(uint64_t)", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    *(_DWORD *)(a1 + 108) = 1;
    *(_QWORD *)buf = a2;
    sub_18F4E7CF0(a1, 2, (uint64_t)buf);
  }
}

void sub_18F4658E0(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 112) != 2 || *(_BYTE *)(a1 + 88))
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v4 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "[CMHeadTrackingController] Received srcMoved event. timestampUs, %llu", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedSrcMovedEvent(uint64_t)", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    *(_DWORD *)(a1 + 108) = 2;
    *(_QWORD *)buf = a2;
    sub_18F4E7CF0(a1, 3, (uint64_t)buf);
  }
}

void sub_18F465AC4(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 112) != 2 || *(_BYTE *)(a1 + 88))
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v4 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "[CMHeadTrackingController] Received auxHasBeenStatic event. timestampUs, %llu", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedAuxHasBeenStaticEvent(uint64_t)", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    *(_DWORD *)(a1 + 108) = 3;
    *(_QWORD *)buf = a2;
    sub_18F4E7CF0(a1, 4, (uint64_t)buf);
  }
}

void sub_18F465CA0(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 112) != 2 || *(_BYTE *)(a1 + 88))
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v4 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "[CMHeadTrackingController] Received DetectedFace event. timestampUs, %llu", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedDetectedFaceEvent(uint64_t)", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    *(_DWORD *)(a1 + 108) = 6;
    *(_QWORD *)buf = a2;
    sub_18F4E7CF0(a1, 10, (uint64_t)buf);
  }
}

void sub_18F465E7C(uint64_t a1, int a2, unint64_t a3)
{
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  _BOOL4 v8;
  char *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  double v17;
  int v18;
  NSObject *v19;
  char *v20;
  uint8_t buf[8];
  __int16 v22;
  _BOOL4 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (!*(_BYTE *)(*(_QWORD *)(a1 + 24) + 16058))
    {
      *(_DWORD *)(a1 + 112) = 2;
      *(_QWORD *)buf = a3;
      sub_18F4E7CF0(a1, 5, (uint64_t)buf);
      v10 = (double)a3;
      v11 = *(double *)(a1 + 360);
      if (v11 <= (double)a3)
      {
        if (v10 - v11 > 18000.0)
        {
          *(double *)(a1 + 360) = v10;
          v11 = (double)a3;
        }
        v12 = *(double *)(a1 + 368);
        v13 = v11 + v12;
        if (v13 >= v10)
        {
          v18 = *(_DWORD *)(a1 + 376) + 1;
        }
        else
        {
          v14 = *(_DWORD *)(a1 + 376);
          v15 = *(_DWORD *)(a1 + 384);
          v16 = *(_DWORD *)(a1 + 388);
          do
          {
            v17 = v13;
            if (v14 < v15)
              v15 = v14;
            if (v14 > v16)
              v16 = v14;
            v13 = v12 + v13;
            v14 = 0;
          }
          while (v13 < v10);
          *(_DWORD *)(a1 + 384) = v15;
          *(_DWORD *)(a1 + 388) = v16;
          v18 = 1;
          *(double *)(a1 + 360) = v17;
        }
        *(_DWORD *)(a1 + 376) = v18;
        ++*(_DWORD *)(a1 + 380);
      }
      goto LABEL_51;
    }
    if (*(_BYTE *)(a1 + 88))
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v5 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] JBL back over limit while waiting to re-enable.", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 2))
        goto LABEL_51;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
      {
LABEL_46:
        v20 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedBTJitterBufferLatencyEvent(BOOL, uint64_t)", "CoreLocation: %s\n", v20);
        if (v20 != (char *)buf)
          free(v20);
LABEL_51:
        *(_BYTE *)(a1 + 88) = 0;
        return;
      }
    }
    else
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v19 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] JBL back over limit received while already not tracking.", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 2))
        goto LABEL_51;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
        goto LABEL_46;
    }
    dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    goto LABEL_46;
  }
  if (*(_BYTE *)(*(_QWORD *)(a1 + 24) + 16058) && *(_DWORD *)(a1 + 112) == 2)
  {
    if (!*(_BYTE *)(a1 + 90))
    {
      *(_DWORD *)(a1 + 108) = 5;
      *(_QWORD *)buf = a3;
      sub_18F4E7CF0(a1, 9, (uint64_t)buf);
      return;
    }
    *(_BYTE *)(a1 + 88) = 1;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v6 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] JBL went under limit, transition to waiting to re-enable.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
      {
LABEL_27:
        v9 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedBTJitterBufferLatencyEvent(BOOL, uint64_t)", "CoreLocation: %s\n", v9);
        if (v9 != (char *)buf)
          free(v9);
        return;
      }
LABEL_53:
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      goto LABEL_27;
    }
  }
  else
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v7 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
    {
      v8 = *(_BYTE *)(*(_QWORD *)(a1 + 24) + 16058) == 0;
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = 0;
      v22 = 1024;
      v23 = v8;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_INFO, "[CMHeadTrackingController] Received JBL event but taking no action. exceededThreshold,%d isTrackingEnabled,%d", buf, 0xEu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
        goto LABEL_27;
      goto LABEL_53;
    }
  }
}

void sub_18F466468(uint64_t a1, int *a2)
{
  int v3;
  char v4;
  BOOL v5;
  char v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  char *v10;
  char *v11;
  uint8_t buf[1640];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!a2[2])
    return;
  v3 = *a2;
  v4 = 1;
  if (*a2 > 51)
  {
    if (v3 != 52 && v3 != 56)
LABEL_8:
      v4 = 0;
  }
  else
  {
    if (!v3)
    {
      v7 = qword_1EE16D818;
      goto LABEL_20;
    }
    if (v3 != 5)
      goto LABEL_8;
  }
  v5 = (v3 & 0xFFFFFFFE) == 10;
  v6 = v4 ^ 1;
  v7 = qword_1EE16D818;
  if (v5)
    v6 = 0;
  if ((v6 & 1) == 0 && a2[1] > 0)
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v8 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Received high / medium confidence in-vehicle event", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v11 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedVehicleState(const CLMotionActivity &)", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf)
        free(v11);
    }
    *(_DWORD *)(a1 + 112) = 4;
    *(_QWORD *)buf = 0;
    sub_18F4E7CF0(a1, 8, (uint64_t)buf);
    return;
  }
LABEL_20:
  if (v7 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
  v9 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Received not in-vehicle event", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v10 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedVehicleState(const CLMotionActivity &)", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf)
      free(v10);
  }
}

void sub_18F4667A8(uint64_t a1, int a2, int a3, int a4, unint64_t a5)
{
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  NSObject *v13;
  double v14;
  NSObject *v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  float v21;
  float v22;
  float v23;
  NSObject *v25;
  int v26;
  float v27;
  float v28;
  NSObject *v29;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  NSObject *v34;
  double v35;
  double v36;
  double v37;
  double v38;
  NSObject *v39;
  double v40;
  double v41;
  double v42;
  double v43;
  unint64_t v44;
  unint64_t v45;
  NSObject *v46;
  NSObject *v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  _BYTE buf[22];
  __int16 v56;
  const char *v57;
  __int16 v58;
  double v59;
  __int16 v60;
  double v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    if ((a2 & 1) != 0)
    {
      v10 = *(_QWORD *)(a1 + 80);
      if (v10)
        v11 = v10 + 3000000 > a5;
      else
        v11 = 0;
      if (v11)
      {
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v15 = qword_1EE16D820;
        if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
        {
          v16 = (float)((float)(a5 - *(_QWORD *)(a1 + 80)) * 0.000001);
          *(_DWORD *)buf = 134349056;
          *(double *)&buf[4] = v16;
          _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Discount walk detection after a back to back SS transition. dt, %{public}.3f", buf, 0xCu);
        }
        if (!sub_18F1FCA08(115, 2))
          goto LABEL_24;
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 == -1)
          goto LABEL_113;
        goto LABEL_134;
      }
      v12 = *(_QWORD *)(a1 + 56);
      if (v12 && v12 + 3000000 > a5)
      {
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v13 = qword_1EE16D820;
        if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
        {
          v14 = (float)((float)(a5 - *(_QWORD *)(a1 + 56)) * 0.000001);
          *(_DWORD *)buf = 134349056;
          *(double *)&buf[4] = v14;
          _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Discount walk detection right after sit->stand transition. dt, %{public}.3f", buf, 0xCu);
        }
        if (!sub_18F1FCA08(115, 2))
          goto LABEL_24;
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 == -1)
          goto LABEL_113;
LABEL_134:
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
LABEL_113:
        v49 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::walkingDetectorCallback(BOOL, BOOL, BOOL, uint64_t)", "CoreLocation: %s\n", v49);
        if (v49 != buf)
          free(v49);
        goto LABEL_24;
      }
    }
    ++*(_BYTE *)(a1 + 72);
LABEL_24:
    sub_18F3FF904(*(_QWORD *)(a1 + 24), a5);
    goto LABEL_25;
  }
  if (*(_BYTE *)(a1 + 72))
    --*(_BYTE *)(a1 + 72);
LABEL_25:
  v17 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(v17 + 4) == 1)
    *(_BYTE *)(v17 + 37448) = a4;
  if (a2 && !*(_BYTE *)(a1 + 73) && *(_QWORD *)(a1 + 64))
  {
    v18 = *(_QWORD *)(a1 + 96);
    if ((a4 & 1) == 0 && !*(_BYTE *)(v18 + 10816))
      goto LABEL_55;
    sub_18F4E7CF0(v18, 4, (uint64_t)buf);
    *(_BYTE *)(a1 + 73) = 1;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v19 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Likely false re-enable via Stand->Sit detected. Reset SS FSM.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v53 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::walkingDetectorCallback(BOOL, BOOL, BOOL, uint64_t)", "CoreLocation: %s\n", v53);
      if (v53 != buf)
        free(v53);
    }
  }
  if (a4)
  {
    v20 = *(_QWORD *)(a1 + 24);
    if (!*(_BYTE *)(v20 + 16058))
    {
      if (!a3)
        goto LABEL_48;
      v21 = sub_18F48E94C(v20 + 5216, a5);
      v22 = sub_18F48EF5C(*(_QWORD *)(a1 + 24) + 5216, a5);
      v23 = 3.0;
      if (!*(_QWORD *)(a1 + 40))
        v23 = 5.0;
      if (v21 > v23 && v22 < v23)
      {
LABEL_48:
        if (a2 && *(unsigned __int8 *)(a1 + 72) <= 1u)
        {
          v44 = *(_QWORD *)(a1 + 56);
          if (!v44)
            goto LABEL_55;
          v45 = a5 - v44;
          if (a5 <= v44)
            goto LABEL_55;
          if (qword_1EE16D818 != -1)
            dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
          v46 = qword_1EE16D820;
          if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134217984;
            *(double *)&buf[4] = (float)((float)v45 * 0.000001);
            _os_log_impl(&dword_18F1DC000, v46, OS_LOG_TYPE_DEBUG, "[CMHeadTrackingController] Sit->Stand %.2f seconds before walking detection", buf, 0xCu);
          }
          if (sub_18F1FCA08(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EE16D818 != -1)
              dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
            v54 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::updateDistractedViewingState(BOOL, BOOL, uint64_t)", "CoreLocation: %s\n", v54);
            if (v54 != buf)
              free(v54);
          }
          if (v45 - 9000000 < 0xFFFFFFFFFF953041)
            goto LABEL_55;
          *(_DWORD *)(a1 + 112) = 3;
          *(_QWORD *)(a1 + 64) = 0;
          if (qword_1EE16D818 != -1)
            dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
          v47 = qword_1EE16D820;
          if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = a5;
            _os_log_impl(&dword_18F1DC000, v47, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Distracted viewing from sit->stand + walking event. timestampUs, %llu", buf, 0xCu);
          }
          if (!sub_18F1FCA08(115, 2))
          {
LABEL_54:
            *(_QWORD *)buf = a5;
            sub_18F4E7CF0(a1, 1, (uint64_t)buf);
            goto LABEL_55;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D818 == -1)
          {
LABEL_124:
            v52 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::feedDistractedViewingEvent(TrackingDisableRoute, uint64_t)", "CoreLocation: %s\n", v52);
            if (v52 != buf)
              free(v52);
            goto LABEL_54;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 112) = 1;
          *(_QWORD *)(a1 + 64) = 0;
          if (qword_1EE16D818 != -1)
            dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
          v25 = qword_1EE16D820;
          if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
          {
            v26 = *(unsigned __int8 *)(a1 + 72);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)&buf[4] = v26;
            *(_WORD *)&buf[8] = 2048;
            *(_QWORD *)&buf[10] = a5;
            _os_log_impl(&dword_18F1DC000, v25, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Distracted viewing from walking event. numWalking, %d, timestampUs, %llu", buf, 0x12u);
          }
          if (!sub_18F1FCA08(115, 2))
            goto LABEL_54;
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D818 == -1)
            goto LABEL_124;
        }
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        goto LABEL_124;
      }
    }
  }
LABEL_55:
  if (*(unsigned __int8 *)(a1 + 48) != a4)
  {
    v27 = sub_18F48E94C(*(_QWORD *)(a1 + 24) + 5216, a5);
    v28 = sub_18F48EF5C(*(_QWORD *)(a1 + 24) + 5216, a5);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
    v29 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
    {
      v30 = "WalkDetector";
      v31 = *(unsigned __int8 *)(a1 + 48);
      if (!*(_QWORD *)(a1 + 32))
        v30 = "StepDetector";
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v30;
      v32 = "No Walking";
      *(_WORD *)&buf[12] = 2082;
      if (v31)
        v33 = "Walking";
      else
        v33 = "No Walking";
      *(_QWORD *)&buf[14] = v33;
      if (a4)
        v32 = "Walking";
      v56 = 2082;
      v57 = v32;
      v58 = 2050;
      v59 = v27;
      v60 = 2050;
      v61 = v28;
      _os_log_impl(&dword_18F1DC000, v29, OS_LOG_TYPE_DEFAULT, "[CMHeadTrackingController] Via %s: Walk Detection changed : From %{public}s -> %{public}s, srcStaticFor, %{public}.2f secs, timeSinceLastSrcFrozen, %{public}.2f secs", buf, 0x34u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v48 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::walkingDetectorCallback(BOOL, BOOL, BOOL, uint64_t)", "CoreLocation: %s\n", v48);
      if (v48 != buf)
        free(v48);
    }
  }
  if (a4 && !*(_BYTE *)(a1 + 48))
  {
    if (*(_QWORD *)(a1 + 120))
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v34 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
      {
        v35 = (double)(a5 - *(_QWORD *)(a1 + 120)) * 0.000001;
        *(_DWORD *)buf = 134217984;
        *(double *)&buf[4] = v35;
        _os_log_impl(&dword_18F1DC000, v34, OS_LOG_TYPE_DEBUG, "[CMHeadTrackingController] Time between sit and walking: %f seconds", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v50 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::walkingDetectorCallback(BOOL, BOOL, BOOL, uint64_t)", "CoreLocation: %s\n", v50);
        if (v50 != buf)
          free(v50);
      }
      v36 = (double)(a5 - *(_QWORD *)(a1 + 120)) * 0.000001;
      v38 = *(double *)(a1 + 168);
      v37 = *(double *)(a1 + 176);
      if (v37 <= v36)
        v37 = (double)(a5 - *(_QWORD *)(a1 + 120)) * 0.000001;
      if (v38 >= v36)
        v38 = (double)(a5 - *(_QWORD *)(a1 + 120)) * 0.000001;
      *(double *)(a1 + 168) = v38;
      *(double *)(a1 + 176) = v37;
      *(double *)(a1 + 184) = v36 + *(double *)(a1 + 184);
      ++*(_DWORD *)(a1 + 192);
    }
    if (*(_QWORD *)(a1 + 56))
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
      v39 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
      {
        v40 = (double)(a5 - *(_QWORD *)(a1 + 56)) * 0.000001;
        *(_DWORD *)buf = 134217984;
        *(double *)&buf[4] = v40;
        _os_log_impl(&dword_18F1DC000, v39, OS_LOG_TYPE_DEBUG, "[CMHeadTrackingController] Time between stand and walking: %f seconds", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953C88);
        v51 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMHeadTrackingController::walkingDetectorCallback(BOOL, BOOL, BOOL, uint64_t)", "CoreLocation: %s\n", v51);
        if (v51 != buf)
          free(v51);
      }
      v41 = (double)(a5 - *(_QWORD *)(a1 + 56)) * 0.000001;
      v43 = *(double *)(a1 + 136);
      v42 = *(double *)(a1 + 144);
      if (v42 <= v41)
        v42 = (double)(a5 - *(_QWORD *)(a1 + 56)) * 0.000001;
      if (v43 >= v41)
        v43 = (double)(a5 - *(_QWORD *)(a1 + 56)) * 0.000001;
      *(double *)(a1 + 136) = v43;
      *(double *)(a1 + 144) = v42;
      *(double *)(a1 + 152) = v41 + *(double *)(a1 + 152);
      ++*(_DWORD *)(a1 + 160);
    }
  }
  *(_BYTE *)(a1 + 48) = a4;
}

os_log_t sub_18F467728()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1EE16D820 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F467754(_QWORD *a1, __int128 *a2)
{
  float32x2_t *v4;

  v4 = (float32x2_t *)sub_18F46C450(a1);
  *v4 = (float32x2_t)&off_1E294B910;
  sub_18F4677A4(v4, a2);
  return a1;
}

void sub_18F467790(_Unwind_Exception *a1)
{
  _DWORD *v1;

  sub_18F46C4C4(v1);
  _Unwind_Resume(a1);
}

void sub_18F4677A4(float32x2_t *a1, __int128 *a2)
{
  __int128 v3;
  NSObject *v4;
  __int16 *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  __int128 v16;
  __int128 v17;
  _OWORD v18[2];
  int v19;
  int v20;
  uint8_t buf[4];
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a2[1];
  v16 = *a2;
  v17 = v3;
  v18[0] = a2[2];
  *(_OWORD *)((char *)v18 + 13) = *(__int128 *)((char *)a2 + 45);
  if (sub_18F46D668())
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
    v4 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "Device still has original rear camera. Using unit-specific calibration info", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
      LOWORD(v19) = 0;
      v12 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV5::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf)
        free(v12);
    }
    v5 = (__int16 *)((char *)&v16 + 7);
LABEL_27:
    sub_18F46D240(a1, v5);
    return;
  }
  v6 = sub_18F46D858();
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
  v7 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    v22 = v6;
    _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_INFO, "Rear camera was replaced. VCM actuator ID is %d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
    v19 = 67109120;
    v20 = v6;
    v13 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV5::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v13);
    if (v13 != (char *)buf)
      free(v13);
  }
  if (v6 == 4)
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
    v9 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "Using generic Alps calibration info", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
      LOWORD(v19) = 0;
      v15 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV5::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v15);
      if (v15 != (char *)buf)
        free(v15);
    }
    v5 = (__int16 *)((char *)v18 + 11);
    goto LABEL_27;
  }
  if (v6 == 3)
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
    v8 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "Using generic Mitsumi calibration info", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
      LOWORD(v19) = 0;
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV5::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
    }
    v5 = (__int16 *)((char *)&v17 + 9);
    goto LABEL_27;
  }
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
  v10 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_INFO, "Unrecongized VCM actuator. Not performing compensation", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953CA8);
    LOWORD(v19) = 0;
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV5::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
  }
}

void sub_18F467E60(_DWORD *a1)
{
  sub_18F46C4C4(a1);
  JUMPOUT(0x194001438);
}

void sub_18F468064(uint64_t a1)
{
  NSObject *v1;
  char *v2;
  _QWORD *v4;
  uint64_t v5;
  NSObject *v6;
  uint8_t buf[1640];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16))
  {
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
    v1 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v1, OS_LOG_TYPE_ERROR, "Pickup detection already started!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
      v2 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMPickupManager startPickupUpdates]_block_invoke", "CoreLocation: %s\n", v2);
LABEL_21:
      if (v2 != (char *)buf)
        free(v2);
    }
  }
  else
  {
    v4 = (_QWORD *)operator new();
    v5 = *(_QWORD *)(a1 + 32);
    *v4 = off_1E294C238;
    *v4 = &off_1E294C430;
    v4[1] = 0;
    v4[2] = sub_18F4683D8;
    v4[3] = v5;
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) = v4;
    if (qword_1EE16E958 != -1)
      dispatch_once(&qword_1EE16E958, &unk_1E29532C8);
    sub_18F1F4F0C(qword_1EE16E950, 0, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16), -1.0);
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
    v6 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "Started pickup detection updates", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
      v2 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMPickupManager startPickupUpdates]_block_invoke", "CoreLocation: %s\n", v2);
      goto LABEL_21;
    }
  }
}

void sub_18F4683AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4683D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a2, sel_onPickupStateUpdated_, a1, a4, a5);
}

void sub_18F46843C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;
  NSObject *v9;
  uint8_t buf[8];
  uint64_t v11;
  uint64_t *(*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16))
  {
    if (qword_1EE16E958 != -1)
      dispatch_once(&qword_1EE16E958, &unk_1E29532C8);
    v2 = qword_1EE16E950;
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
    v4 = sub_18F204AE4();
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    v11 = 3221225472;
    v12 = sub_18F1F5EE0;
    v13 = &unk_1E2956E98;
    v16 = 0;
    v14 = v2;
    v15 = v3;
    sub_18F1F5E28(v4, (uint64_t)buf);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = *(_QWORD *)(v5 + 16);
    if (v6)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      v5 = *(_QWORD *)(a1 + 32);
    }
    *(_QWORD *)(v5 + 16) = 0;
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
    v7 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEFAULT, "Stopped pickup detection updates", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
      v8 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMPickupManager stopPickupUpdates]_block_invoke", "CoreLocation: %s\n");
LABEL_23:
      if (v8 != buf)
        free(v8);
    }
  }
  else
  {
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
    v9 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_ERROR, "Pickup detection service already stopped!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
      v8 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMPickupManager stopPickupUpdates]_block_invoke", "CoreLocation: %s\n");
      goto LABEL_23;
    }
  }
}

uint64_t sub_18F46880C(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  char *v16;
  uint8_t buf[4];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D3E8 != -1)
    dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
  v2 = qword_1EE16D3D8;
  if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 134349056;
    v18 = v3;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "Pickup Detection: %{public}ld", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2953CC8);
    v16 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMPickupManager onPickupStateUpdated:]_block_invoke", "CoreLocation: %s\n", v16);
    if (v16 != (char *)buf)
      free(v16);
  }
  objc_msgSend_delegate(*(void **)(a1 + 32), v4, v5, v6, v7);
  result = objc_opt_respondsToSelector();
  if ((result & 1) != 0)
  {
    v13 = (void *)objc_msgSend_delegate(*(void **)(a1 + 32), v9, v10, v11, v12);
    return objc_msgSend_pickupManager_didUpdateState_(v13, v14, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), v15);
  }
  return result;
}

os_log_t sub_18F468A00()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Gesture");
  qword_1EE16D3D8 = (uint64_t)result;
  return result;
}

void sub_18F468A30(uint64_t a1)
{
  sub_18F1E932C(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F468A54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 16))(a3, *(_QWORD *)(a1 + 24));
}

BOOL sub_18F468A60(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float v3;
  uint64_t v4;
  float v5;
  uint64_t v6;
  float v7;
  BOOL v8;

  v2 = 0;
  v3 = 0.0;
  do
  {
    v3 = v3 + (float)(*(float *)(a1 + v2) * *(float *)(a1 + v2));
    v2 += 4;
  }
  while (v2 != 12);
  v4 = 0;
  v5 = 0.0;
  do
  {
    v5 = v5 + (float)(*(float *)(a2 + v4) * *(float *)(a2 + v4));
    v4 += 4;
  }
  while (v4 != 12);
  v6 = 0;
  if (sqrtf(v3) <= sqrtf(v5))
  {
    v7 = 0.0;
    do
    {
      v7 = v7 + (float)(*(float *)(a2 + v6) * *(float *)(a2 + v6));
      v6 += 4;
    }
    while (v6 != 12);
  }
  else
  {
    v7 = 0.0;
    do
    {
      v7 = v7 + (float)(*(float *)(a1 + v6) * *(float *)(a1 + v6));
      v6 += 4;
    }
    while (v6 != 12);
  }
  if (*(_DWORD *)(a1 + 48))
    v8 = *(_DWORD *)(a2 + 48) == 0;
  else
    v8 = 1;
  return !v8 && sqrtf(v7) <= 0.17453;
}

double sub_18F468B24(uint64_t a1, int a2)
{
  NSObject *v4;
  int v5;
  double result;
  char *v7;
  uint8_t buf[4];
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(unsigned __int8 *)(a1 + 116) != a2)
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v4 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
    {
      v5 = *(unsigned __int8 *)(a1 + 116);
      *(_DWORD *)buf = 67109376;
      v9 = v5;
      v10 = 1024;
      v11 = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "[CMBleedToZero] Changed tracking behavior from %d to %d.", buf, 0xEu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMBleedToZero::setTrackingBehavior(CMRelDM::TrackingBehavior)", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }
    *(_QWORD *)(a1 + 80) = 0;
    result = 0.0;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_DWORD *)a1 = 1084227584;
    *(_BYTE *)(a1 + 132) = 0;
    *(_BYTE *)(a1 + 116) = a2;
  }
  return result;
}

void sub_18F468D18(uint64_t a1@<X0>, float *a2@<X1>, float *a3@<X2>, float *a4@<X3>, float32x4_t *a5@<X8>)
{
  uint64_t v10;
  float v11;
  uint64_t v12;
  float v13;
  uint64_t v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  uint64_t v35;
  float v36;
  BOOL v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float32x4_t v43;
  NSObject *v44;
  uint64_t v45;
  float v46;
  float v47;
  float v48;
  float v49;
  uint64_t v50;
  float v51;
  float32x2_t *v52;
  __int32 v53;
  float32x4_t v54;
  float v55;
  uint64_t v56;
  float v57;
  float v58;
  float v59;
  float v60;
  NSObject *v61;
  float v62;
  float v63;
  float *v64;
  float32x4_t v65;
  float v66;
  float v67;
  uint64_t v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  uint64_t v77;
  float v78;
  uint64_t v79;
  float v80;
  float v81;
  uint64_t v82;
  float v83;
  float v84;
  float v85;
  uint64_t v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  uint64_t v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float32x4_t v102;
  NSObject *v103;
  NSObject *v104;
  float32x4_t *v105;
  float32x4_t *v106;
  float v107[3];
  float v108[4];
  float v109[4];
  float32x4_t v110;
  float32x4_t v111;
  float v112;
  float v113;
  float v114;
  float32x4_t buf[102];
  uint64_t v116;

  v10 = 0;
  v116 = *MEMORY[0x1E0C80C00];
  v11 = 0.0;
  do
  {
    v11 = v11 + (float)(a2[v10] * a2[v10]);
    ++v10;
  }
  while (v10 != 3);
  if (sqrtf(v11) <= 0.000001)
    goto LABEL_27;
  v12 = 0;
  v13 = 0.0;
  do
  {
    v13 = v13 + (float)(a3[v12] * a3[v12]);
    ++v12;
  }
  while (v12 != 3);
  if (sqrtf(v13) <= 0.000001)
  {
LABEL_27:
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v44 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_ERROR))
    {
      buf[0].i16[0] = 0;
      _os_log_impl(&dword_18F1DC000, v44, OS_LOG_TYPE_ERROR, "[CMBleedToZero] unexpected 0 accel magnitude.", (uint8_t *)buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
      v111.i16[0] = 0;
      v106 = (float32x4_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "CMOQuaternion CMBleedToZero::alignAttitudeWithGravity(const CMVector3d &, const CMVector3d &, const CMOQuaternion &) const", "CoreLocation: %s\n", (const char *)v106);
      if (v106 != buf)
        free(v106);
    }
    goto LABEL_32;
  }
  v14 = 0;
  v15 = 0.0;
  do
  {
    v15 = v15 + (float)(a2[v14] * a2[v14]);
    ++v14;
  }
  while (v14 != 3);
  v16 = 0;
  v17 = 0.0;
  do
  {
    v17 = v17 + (float)(a3[v16] * a3[v16]);
    ++v16;
  }
  while (v16 != 3);
  v18 = sqrtf(v15);
  v19 = a2[1] / v18;
  v20 = *a2 / v18;
  v21 = a2[2] / v18;
  v22 = sqrtf(v17);
  v25 = sub_18F3D39F4(a4, *a3 / v22, a3[1] / v22, a3[2] / v22);
  v26 = (float)((float)(v21 * v24) + (float)(v19 * v23)) + (float)(v20 * v25);
  v27 = 1.0;
  if (v26 < 1.0)
  {
    v27 = -1.0;
    if (v26 > -1.0)
      v27 = (float)((float)(v21 * v24) + (float)(v19 * v23)) + (float)(v20 * v25);
  }
  v28 = 0;
  v29 = (float)(v19 * v24) - (float)(v21 * v23);
  v30 = (float)(v21 * v25) - (float)(v20 * v24);
  v31 = (float)(v20 * v23) - (float)(v19 * v25);
  v110.f32[0] = v29;
  v110.f32[1] = v30;
  v110.f32[2] = v31;
  v32 = 0.0;
  do
  {
    v32 = v32 + (float)(v110.f32[v28] * v110.f32[v28]);
    ++v28;
  }
  while (v28 != 3);
  v33 = acosf(v27);
  v34 = sqrtf(v32);
  if (v34 >= 0.000001)
    goto LABEL_26;
  if (v33 < 1.57079633)
  {
LABEL_32:
    v111 = *(float32x4_t *)a4;
    goto LABEL_33;
  }
  v35 = 0;
  if (v21 <= 0.0)
    v36 = -v21;
  else
    v36 = v21;
  v37 = v36 <= 0.9;
  v38 = 0.0;
  v39 = (float)(v21 * 0.0) - v19;
  v40 = v20 + (float)(v21 * -0.0);
  v41 = (float)(v20 * -0.0) + (float)(v19 * 0.0);
  if (!v37)
  {
    v41 = v19 + (float)(v20 * -0.0);
    v40 = (float)(v20 * 0.0) - v21;
    v39 = (float)(v19 * -0.0) + (float)(v21 * 0.0);
  }
  v29 = (float)(v40 * v21) - (float)(v41 * v19);
  v30 = (float)(v41 * v20) - (float)(v39 * v21);
  v31 = (float)(v39 * v19) - (float)(v40 * v20);
  v110.f32[0] = v29;
  v110.f32[1] = v30;
  v110.f32[2] = v31;
  do
  {
    v38 = v38 + (float)(v110.f32[v35] * v110.f32[v35]);
    ++v35;
  }
  while (v35 != 3);
  v34 = sqrtf(v38);
LABEL_26:
  v42 = v33 / v34;
  v112 = v29 * v42;
  v113 = v30 * v42;
  v114 = v31 * v42;
  *(double *)v43.i64 = sub_18F3D3AA8(buf, &v112);
  sub_18F3D3764((uint64_t)buf, a4, &v111, v43);
LABEL_33:
  v45 = 0;
  v46 = 0.0;
  do
  {
    v46 = v46 + (float)(a3[v45] * a3[v45]);
    ++v45;
  }
  while (v45 != 3);
  v47 = sqrtf(v46);
  v48 = *a3 / v47;
  v49 = a3[1] / v47;
  v50 = a1 + 8;
  v51 = a3[2] / v47;
  v52 = (float32x2_t *)sub_18F382974(v50);
  v53 = v52[1].i32[1];
  v54.f32[0] = -v52[1].f32[0];
  *(float32x2_t *)buf[0].f32 = vneg_f32(*v52);
  buf[0].i64[1] = __PAIR64__(v53, v54.u32[0]);
  sub_18F1FFE94(buf, v54);
  sub_18F3D39F4(buf[0].f32, v48, v49, v51);
  v56 = 0;
  v57 = 0.0;
  do
  {
    v57 = v57 + (float)(a2[v56] * a2[v56]);
    ++v56;
  }
  while (v56 != 3);
  if (v55 <= 0.0)
    v55 = -v55;
  if (v55 > 0.9)
    goto LABEL_43;
  v58 = sqrtf(v57);
  v59 = a2[2] / v58;
  v60 = -v59;
  if (v59 > 0.0)
    v60 = a2[2] / v58;
  if (v60 > 0.9)
  {
LABEL_43:
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v61 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
    {
      buf[0].i16[0] = 0;
      _os_log_impl(&dword_18F1DC000, v61, OS_LOG_TYPE_DEBUG, "[CMBleedToZero] Do not BTZ yaw because face or source frame z-axis is aligned with gravity.", (uint8_t *)buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      goto LABEL_48;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v110.i16[0] = 0;
    v105 = (float32x4_t *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CMOQuaternion CMBleedToZero::relAttitudeBTZDefault(const CMVector3d &, const CMVector3d &, const CMOQuaternion &) const", "CoreLocation: %s\n");
LABEL_93:
    if (v105 != buf)
      free(v105);
LABEL_48:
    *a5 = v111;
    return;
  }
  v62 = *a2 / v58;
  v63 = a2[1] / v58;
  v64 = (float *)sub_18F382974(v50);
  sub_18F3D3764((uint64_t)&v111, v64, &v110, v65);
  v66 = 0.0;
  v67 = sub_18F3D39F4(v110.f32, 0.0, 0.0, 1.0);
  v68 = 0;
  v71 = (float)((float)(v59 * v69) + (float)(v70 * v63)) + (float)(v67 * v62);
  v72 = v63 * v71;
  v73 = v59 * v71;
  v74 = v67 - (float)(v62 * v71);
  v75 = v70 - v72;
  v76 = v69 - v73;
  v112 = v74;
  v113 = v75;
  v114 = v69 - v73;
  do
  {
    v66 = v66 + (float)(*(float *)((char *)&v112 + v68) * *(float *)((char *)&v112 + v68));
    v68 += 4;
  }
  while (v68 != 12);
  if (sqrtf(v66) <= 0.000001)
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v103 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_ERROR))
    {
      buf[0].i16[0] = 0;
      _os_log_impl(&dword_18F1DC000, v103, OS_LOG_TYPE_ERROR, "[CMBleedToZero] unexpected 0 accel magnitude on zVecInS_pred_proj.", (uint8_t *)buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_48;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    LOWORD(v109[0]) = 0;
LABEL_85:
    v105 = (float32x4_t *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "CMOQuaternion CMBleedToZero::relAttitudeBTZDefault(const CMVector3d &, const CMVector3d &, const CMOQuaternion &) const", "CoreLocation: %s\n");
    goto LABEL_93;
  }
  v77 = 0;
  v78 = 0.0;
  do
  {
    v78 = v78 + (float)(*(float *)((char *)&v112 + v77) * *(float *)((char *)&v112 + v77));
    v77 += 4;
  }
  while (v77 != 12);
  v79 = 0;
  v80 = sqrtf(v78);
  v81 = v75 / v80;
  buf[0].i64[0] = 0;
  buf[0].i32[2] = 1065353216;
  do
  {
    buf[0].f32[v79] = -buf[0].f32[v79];
    ++v79;
  }
  while (v79 != 3);
  v82 = 0;
  v83 = v74 / v80;
  v84 = 0.0;
  v85 = (float)(v59 + (float)(v63 * 0.0)) + (float)(v62 * 0.0);
  v109[0] = (float)(v62 * v85) + buf[0].f32[0];
  v109[1] = (float)(v63 * v85) + buf[0].f32[1];
  v109[2] = (float)(v59 * v85) + buf[0].f32[2];
  do
  {
    v84 = v84 + (float)(v109[v82] * v109[v82]);
    ++v82;
  }
  while (v82 != 3);
  if (sqrtf(v84) <= 0.000001)
  {
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v104 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_ERROR))
    {
      buf[0].i16[0] = 0;
      _os_log_impl(&dword_18F1DC000, v104, OS_LOG_TYPE_ERROR, "[CMBleedToZero] unexpected 0 accel magnitude on zVecInS_BTZ_proj.", (uint8_t *)buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_48;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    LOWORD(v108[0]) = 0;
    goto LABEL_85;
  }
  v86 = 0;
  v87 = 0.0;
  v88 = v76 / v80;
  do
  {
    v87 = v87 + (float)(v109[v86] * v109[v86]);
    ++v86;
  }
  while (v86 != 3);
  v89 = sqrtf(v87);
  v90 = (float)((float)(v62 * v85) + buf[0].f32[0]) / v89;
  v91 = (float)((float)(v63 * v85) + buf[0].f32[1]) / v89;
  v92 = (float)((float)(v59 * v85) + buf[0].f32[2]) / v89;
  v93 = (float)((float)(v88 * v92) + (float)(v91 * v81)) + (float)(v90 * v83);
  v94 = 1.0;
  if (v93 < 1.0)
  {
    v94 = -1.0;
    if (v93 > -1.0)
      v94 = (float)((float)(v88 * v92) + (float)(v91 * v81)) + (float)(v90 * v83);
  }
  v95 = 0;
  v96 = (float)(v91 * v88) - (float)(v92 * v81);
  v97 = (float)(v92 * v83) - (float)(v90 * v88);
  v98 = (float)(v90 * v81) - (float)(v91 * v83);
  v108[0] = v96;
  v108[1] = v97;
  v108[2] = v98;
  v99 = 0.0;
  do
  {
    v99 = v99 + (float)(v108[v95] * v108[v95]);
    ++v95;
  }
  while (v95 != 3);
  v100 = acosf(v94);
  v101 = sqrtf(v99);
  if (v101 >= 0.000001)
  {
    v62 = v96 / v101;
    v63 = v97 / v101;
    v59 = v98 / v101;
  }
  v107[0] = v100 * v62;
  v107[1] = v100 * v63;
  v107[2] = v100 * v59;
  *(double *)v102.i64 = sub_18F3D3AA8(buf, v107);
  sub_18F3D3764((uint64_t)buf, v111.f32, a5, v102);
}

float sub_18F469764(uint64_t a1, float *a2)
{
  uint64_t v3;
  float *v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float *v13;
  float v14;
  uint64_t v15;
  int v16;
  int v17;
  _DWORD v19[3];

  v3 = a1 + 8;
  v4 = (float *)sub_18F382974(a1 + 8);
  v5 = sub_18F3FF4CC();
  v8 = sub_18F3D39F4(v4, v5, v6, v7);
  v10 = v9;
  v12 = v11;
  v13 = (float *)sub_18F3827D8(v3);
  v14 = sub_18F3D39F4(a2, *v13 + v8, v10 + v13[1], v12 + v13[2]);
  v15 = 0;
  *(float *)v19 = v14;
  v19[1] = v16;
  v19[2] = v17;
  do
  {
    *(float *)&v19[v15] = -*(float *)&v19[v15];
    ++v15;
  }
  while (v15 != 3);
  return *(float *)v19;
}

void sub_18F46981C(uint64_t a1@<X0>, float *a2@<X1>, float *a3@<X2>, float *a4@<X3>, uint64_t a5@<X8>, float32x4_t a6@<Q0>)
{
  float *v11;
  int v12;
  int v13;
  float32x4_t v14;

  v11 = (float *)(a5 + 12);
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a5 + 16) = 0;
  *(_DWORD *)(a5 + 24) = 1065353216;
  sub_18F1FFE94((float32x4_t *)(a5 + 12), a6);
  sub_18F468D18(a1, a2, a3, a4, &v14);
  *(float32x4_t *)(a5 + 12) = v14;
  *(float *)a5 = sub_18F469764(a1, v11);
  *(_DWORD *)(a5 + 4) = v12;
  *(_DWORD *)(a5 + 8) = v13;
}

void sub_18F4698B0(uint64_t a1, float a2, float a3, float a4)
{
  float v8;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  char *v14;
  uint8_t buf[4];
  double v16;
  __int16 v17;
  double v18;
  __int16 v19;
  double v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (*(float *)a1 >= 20.0 || *(double *)(a1 + 56) <= 2.5)
    return;
  if (a3 >= a4)
    v8 = a4;
  else
    v8 = a3;
  if (a2 < 20.0 && v8 > a2)
  {
    *(_DWORD *)a1 = 1101004800;
    *(_BYTE *)(a1 + 40) = 1;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v12 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_QWORD *)(a1 + 56);
      *(_DWORD *)buf = 134218752;
      v16 = a2;
      v17 = 2048;
      v18 = a4;
      v19 = 2048;
      v20 = a3;
      v21 = 2048;
      v22 = v13;
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_DEFAULT, "[CMBleedToZero] Set extendedBTZ. TimeSinceAnchor %.2f, timeSinceLastUncorrelatedSrcMotion, %.2f, TimeSinceLastWalkingOrSitToStand, %.2f, quiescenceDuration, %.2f", buf, 0x2Au);
    }
    if (!sub_18F1FCA08(115, 2))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 == -1)
    {
LABEL_25:
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMBleedToZero::updateExtendedBTZFromAnchor(const float, const float, const float)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
      return;
    }
LABEL_27:
    dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    goto LABEL_25;
  }
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
  v10 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
  {
    v11 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)buf = 134218752;
    v16 = a2;
    v17 = 2048;
    v18 = a4;
    v19 = 2048;
    v20 = a3;
    v21 = 2048;
    v22 = v11;
    _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEBUG, "[CMBleedToZero] No extendedBTZ. TimeSinceAnchor %.2f, timeSinceLastUncorrelatedSrcMotion, %.2f, TimeSinceLastWalkingOrSitToStand, %.2f, quiescenceDuration, %.2f", buf, 0x2Au);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 == -1)
      goto LABEL_25;
    goto LABEL_27;
  }
}

double sub_18F469C70(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, int a5, int a6, uint64_t a7, double a8)
{
  double v15;
  double v16;
  char v17;
  double v18;
  double v19;
  double v20;
  double *v21;
  double v22;
  float64x2_t v23;
  double v24;
  int v25;
  double v26;
  double *v27;
  NSObject *v28;
  double v29;
  float v30;
  int v31;
  char v32;
  NSObject *v33;
  double result;
  int v35;
  BOOL v36;
  float v37;
  NSObject *v38;
  double v39;
  uint64_t v40;
  float32x4_t v41;
  double v42;
  double *v43;
  NSObject *v44;
  int v45;
  int v46;
  unsigned int v47;
  int v48;
  NSObject *v49;
  double v50;
  uint64_t v51;
  char *v52;
  double v53;
  char *v54;
  char *v55;
  char *v56;
  unint64_t v58;
  int v59;
  _BYTE v60[12];
  __int16 v61;
  uint64_t v62;
  _BYTE buf[12];
  double v64[202];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (sub_18F468A60(a2, a3))
  {
    *(float64x2_t *)(a1 + 48) = vaddq_f64(*(float64x2_t *)(a1 + 48), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a8, 0));
    *(double *)(a1 + 80) = *(double *)(a1 + 80) + a8;
    v15 = *(double *)(a1 + 64);
    if (v15 >= a8)
      *(double *)(a1 + 64) = v15 - a8;
    v16 = *(double *)(a1 + 72);
    if (v16 >= a8)
    {
      v17 = 0;
      v18 = v16 - a8;
LABEL_15:
      *(double *)(a1 + 72) = v18;
      goto LABEL_16;
    }
    goto LABEL_10;
  }
  if (a5)
  {
    v19 = *(double *)(a1 + 64);
    *(double *)(a1 + 56) = *(double *)(a1 + 56) + a8;
    *(double *)(a1 + 80) = *(double *)(a1 + 80) + a8;
    if (v19 >= a8)
      *(double *)(a1 + 64) = v19 - a8;
    v20 = *(double *)(a1 + 72);
    if (v20 >= a8)
    {
      v17 = 0;
      v18 = v20 - a8;
      goto LABEL_15;
    }
LABEL_10:
    v17 = 0;
LABEL_16:
    LOBYTE(v25) = 1;
    goto LABEL_42;
  }
  v21 = (double *)(a1 + 48);
  v22 = *(double *)(a1 + 48);
  v23 = vaddq_f64(*(float64x2_t *)(a1 + 64), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a8, 0));
  *(float64x2_t *)(a1 + 64) = v23;
  if (v22 >= a8)
  {
    *v21 = v22 - a8;
  }
  else
  {
    v24 = *(double *)(a1 + 56);
    if (v24 >= a8)
    {
      *(double *)(a1 + 56) = v24 - a8;
    }
    else
    {
      *v21 = 0.0;
      *(_QWORD *)(a1 + 56) = 0;
      v23.f64[0] = 0.0;
      *(_QWORD *)(a1 + 64) = 0;
    }
  }
  v26 = *(double *)(a1 + 80);
  if (v26 >= a8)
    *(double *)(a1 + 80) = v26 - a8;
  v27 = (double *)(a1 + 72);
  if (v23.f64[0] > 0.200000003)
  {
    *v21 = 0.0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    if (*(float *)a1 == 20.0)
    {
      *(_DWORD *)a1 = *(_DWORD *)(a1 + 4);
      *(_BYTE *)(a1 + 40) = 0;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
      v28 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
      {
        v29 = *(float *)a1;
        *(_DWORD *)buf = 134217984;
        *(double *)&buf[4] = v29;
        _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_DEFAULT, "[CMBleedToZero] Reset BTZ horizon from extendedBTZ to %.2f", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
        v53 = *(float *)a1;
        *(_DWORD *)v60 = 134217984;
        *(double *)&v60[4] = v53;
        v54 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMBleedToZero::updateMutualQuiescence(const CMRelDM::IMUData &, const CMRelDM::IMUData &, BOOL, double, const uint64_t)", "CoreLocation: %s\n", v54);
        if (v54 != buf)
          free(v54);
      }
    }
  }
  if (*v27 <= 0.800000012)
    goto LABEL_38;
  *(_QWORD *)(a1 + 120) = a7;
  v30 = *(double *)(a1 + 80);
  *(float *)(a1 + 128) = v30;
  *v27 = 0.0;
  *(_QWORD *)(a1 + 80) = 0;
  v31 = *(_DWORD *)(a2 + 48);
  v25 = *(_DWORD *)(a3 + 48);
  if (!(v31 | v25))
  {
    LOBYTE(v25) = 0;
    v32 = 3;
LABEL_40:
    *(_BYTE *)(a1 + 132) = v32;
    goto LABEL_41;
  }
  if (!v31)
  {
    LOBYTE(v25) = 0;
    v32 = 2;
    goto LABEL_40;
  }
  if (v25)
  {
    *(_BYTE *)(a1 + 132) = 0;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v33 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a7;
      _os_log_impl(&dword_18F1DC000, v33, OS_LOG_TYPE_DEBUG, "[CMBleedToZero] Unexpected behavior: Cam controller disturbance threshold reached, but both srcIMU.qMode != kNotStatic and auxIMU.qMode != kNotStatic, timestamp: %llu", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
      *(_DWORD *)v60 = 134217984;
      *(_QWORD *)&v60[4] = a7;
      v56 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMBleedToZero::updateMutualQuiescence(const CMRelDM::IMUData &, const CMRelDM::IMUData &, BOOL, double, const uint64_t)", "CoreLocation: %s\n", v56);
      if (v56 != buf)
        free(v56);
    }
LABEL_38:
    LOBYTE(v25) = 0;
LABEL_41:
    v17 = 1;
    goto LABEL_42;
  }
  v17 = 1;
  *(_BYTE *)(a1 + 132) = 1;
LABEL_42:
  *(_BYTE *)(a1 + 41) = v25;
  *(_BYTE *)(a1 + 43) = sub_18F468A60(a2, a3);
  if ((v17 & 1) != 0)
  {
    v35 = 0;
  }
  else
  {
    if (*(_BYTE *)(a1 + 40))
    {
      result = *(double *)(a1 + 56);
      v36 = result < *(float *)a1;
    }
    else
    {
      v37 = *(float *)a1;
      if (*(_BYTE *)(a1 + 116))
      {
        result = fmaxf(v37, 1.0);
        v36 = *(double *)(a1 + 56) < result;
      }
      else
      {
        if (*(double *)(a1 + 48) >= fmaxf(v37, 5.0))
        {
          v35 = 1;
          *(_BYTE *)(a1 + 42) = 1;
          goto LABEL_54;
        }
        result = fmaxf(v37 + v37, 5.0);
        v36 = *(double *)(a1 + 56) < result;
      }
    }
    v35 = !v36;
  }
  *(_BYTE *)(a1 + 42) = v35 | a6;
  if ((v35 | a6) != 1)
    return result;
LABEL_54:
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
  v38 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
  {
    v39 = *(float *)a1;
    v40 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)buf = 134218240;
    *(double *)&buf[4] = v39;
    LOWORD(v64[0]) = 2048;
    *(_QWORD *)((char *)v64 + 2) = v40;
    _os_log_impl(&dword_18F1DC000, v38, OS_LOG_TYPE_DEBUG, "[CMBleedToZero] horizon, %.3f, quiesenceLoose, %.3f", buf, 0x16u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
    v50 = *(float *)a1;
    v51 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)v60 = 134218240;
    *(double *)&v60[4] = v50;
    v61 = 2048;
    v62 = v51;
    v52 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMBleedToZero::feedInputs(const CMRelDM::IMUData &, const CMRelDM::IMUData &, const CMOQuaternion &, const BOOL, const BOOL, const double, const uint64_t)", "CoreLocation: %s\n", v52);
    if (v52 != buf)
      free(v52);
  }
  v42 = a8;
  if (v35)
  {
    if (*(_BYTE *)(a1 + 43))
    {
      *(_QWORD *)v60 = *(_QWORD *)(a2 + 12);
      *(_DWORD *)&v60[8] = *(_DWORD *)(a2 + 20);
      v58 = *(_QWORD *)(a3 + 12);
      v59 = *(_DWORD *)(a3 + 20);
      v43 = (double *)(a1 + 48);
      if (*(double *)(a1 + 48) < a8)
      {
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
        v44 = qword_1EE16D820;
        if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v44, OS_LOG_TYPE_ERROR, "[CMBleedToZero] unexpected quiescentDurationStrict < dt.", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 0))
          goto LABEL_76;
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 == -1)
        {
LABEL_91:
          v55 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "void CMBleedToZero::feedInputs(const CMRelDM::IMUData &, const CMRelDM::IMUData &, const CMOQuaternion &, const BOOL, const BOOL, const double, const uint64_t)", "CoreLocation: %s\n", v55);
          if (v55 != buf)
            free(v55);
LABEL_76:
          v42 = a8;
          goto LABEL_77;
        }
LABEL_97:
        dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
        goto LABEL_91;
      }
    }
    else
    {
      *(_QWORD *)v60 = *(_QWORD *)(a2 + 24);
      *(_DWORD *)&v60[8] = *(_DWORD *)(a2 + 32);
      v58 = *(_QWORD *)(a3 + 24);
      v59 = *(_DWORD *)(a3 + 32);
      v43 = (double *)(a1 + 56);
      if (*(double *)(a1 + 56) < a8)
      {
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953CE8);
        v49 = qword_1EE16D820;
        if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v49, OS_LOG_TYPE_ERROR, "[CMBleedToZero] unexpected quiescentDurationLoose < dt.", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 0))
          goto LABEL_76;
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 == -1)
          goto LABEL_91;
        goto LABEL_97;
      }
    }
LABEL_77:
    *(double *)v41.i64 = *v43 - v42;
    *v43 = *(double *)v41.i64;
    goto LABEL_78;
  }
  *(_DWORD *)v60 = sub_18F200A14((float *)(a2 + 56));
  *(_DWORD *)&v60[4] = v45;
  *(_DWORD *)&v60[8] = v46;
  v41.f32[0] = sub_18F200A14((float *)(a3 + 56));
  v58 = __PAIR64__(v47, v41.u32[0]);
  v59 = v48;
LABEL_78:
  sub_18F46981C(a1, (float *)v60, (float *)&v58, a4, (uint64_t)buf, v41);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)buf;
  *(_DWORD *)(a1 + 96) = *(_DWORD *)&buf[8];
  result = v64[0];
  *(_OWORD *)(a1 + 100) = *(_OWORD *)v64;
  return result;
}

os_log_t sub_18F46A654()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1EE16D820 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F46A680(_QWORD *a1, __int128 *a2)
{
  float32x2_t *v4;

  v4 = (float32x2_t *)sub_18F46C450(a1);
  *v4 = (float32x2_t)&off_1E294B968;
  sub_18F46A6D0(v4, a2);
  return a1;
}

void sub_18F46A6BC(_Unwind_Exception *a1)
{
  _DWORD *v1;

  sub_18F46C4C4(v1);
  _Unwind_Resume(a1);
}

void sub_18F46A6D0(float32x2_t *a1, __int128 *a2)
{
  __int128 v3;
  __int128 v4;
  NSObject *v5;
  __int16 *v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint8_t buf[4];
  int v18;
  __int128 v19;
  __int128 v20;
  _OWORD v21[2];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a2[1];
  v19 = *a2;
  v20 = v3;
  v4 = a2[3];
  v21[0] = a2[2];
  v21[1] = v4;
  if (sub_18F46D668())
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
    v5 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "Device still has original rear camera. Using unit-specific calibration info", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
      v13 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV6::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v13);
      if (v13 != (char *)buf)
        free(v13);
    }
    v6 = (__int16 *)((unint64_t)&v19 | 0xA);
LABEL_27:
    sub_18F46D240(a1, v6);
    return;
  }
  v7 = sub_18F46D858();
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
  v8 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    v18 = v7;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "Rear camera was replaced. VCM actuator ID is %d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
    v14 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV6::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v14);
    if (v14 != (char *)buf)
      free(v14);
  }
  if (v7 == 4)
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
    v10 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_INFO, "Using generic Alps calibration info", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
      v16 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV6::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v16);
      if (v16 != (char *)buf)
        free(v16);
    }
    v6 = (__int16 *)v21 + 7;
    goto LABEL_27;
  }
  if (v7 == 3)
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
    v9 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "Using generic Mitsumi calibration info", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
      v15 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV6::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v15);
      if (v15 != (char *)buf)
        free(v15);
    }
    v6 = (__int16 *)&v20 + 6;
    goto LABEL_27;
  }
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
  v11 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_INFO, "Unrecongized VCM actuator. Not performing compensation", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D08);
    v12 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV6::initializeCalibrationParamaters(const UInt8 *, int)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf)
      free(v12);
  }
}

void sub_18F46AD88(_DWORD *a1)
{
  sub_18F46C4C4(a1);
  JUMPOUT(0x194001438);
}

__CFString *sub_18F46B3E4(unsigned int a1)
{
  if (a1 > 0xD)
    return 0;
  else
    return off_1E2958838[a1];
}

double sub_18F46B404()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  sub_18F1E61EC(v0, (uint64_t)"CLAccessoryAccelerometer", 2);
  *(_WORD *)(v0 + 28) = 256;
  *(_BYTE *)(v0 + 30) = 0;
  *(_QWORD *)(v0 + 40) = 0;
  *(_QWORD *)(v0 + 48) = 0;
  *(_QWORD *)(v0 + 32) = 0;
  *(_QWORD *)(v0 + 56) = 0x7300000020;
  result = 0.0;
  *(_OWORD *)(v0 + 64) = 0u;
  *(_OWORD *)(v0 + 80) = 0u;
  *(_QWORD *)v0 = &off_1E294B0B8;
  qword_1EE16E9D0 = v0;
  return result;
}

void sub_18F46B488(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10F1C40E59F67ADLL);
  _Unwind_Resume(a1);
}

void sub_18F46B4B0(_QWORD *a1)
{
  sub_18F4A2ABC(a1);
  JUMPOUT(0x194001438);
}

double sub_18F46B4D4(uint64_t a1, int a2, double *a3)
{
  NSObject *v4;
  double v5;
  char *v6;
  NSObject *v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  char *v14;
  uint8_t buf[4];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
    v4 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v16) = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "[AccessoryAccelerometer] Unrecognized update interval notification %{public}d", buf, 8u);
    }
    v5 = 0.0;
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryAccelerometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
  else
  {
    sub_18F4A461C(a1);
    if (*a3 > 0.0)
    {
      (*(void (**)(double))(**(_QWORD **)(a1 + 32) + 16))(*a3);
      (*(void (**)(void))(**(_QWORD **)(a1 + 32) + 16))();
      *(_BYTE *)(a1 + 30) = 0;
    }
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
    v9 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_INFO))
    {
      v10 = *(_QWORD *)a3;
      *(_DWORD *)buf = 134349056;
      v16 = v10;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "[AccessoryAccelerometer] Setting update interval to %{public}f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryAccelerometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
    }
    v11 = rint(*a3 * 1000000.0);
    if (*a3 < 0.0)
      v12 = 0;
    else
      v12 = (uint64_t)v11;
    sub_18F203AF8(*(_QWORD *)(a1 + 32), v12);
    return *a3;
  }
  return v5;
}

double sub_18F46B89C(uint64_t a1, int a2, double *a3)
{
  NSObject *v4;
  double v5;
  char *v6;
  NSObject *v9;
  double v10;
  char *v12;
  uint8_t buf[4];
  double v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
    v4 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v14) = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "[AccessoryAccelerometer] Unrecognized batch interval notification %{public}d", buf, 8u);
    }
    v5 = 0.0;
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryAccelerometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
  else
  {
    sub_18F4A461C(a1);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
    v9 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_INFO))
    {
      v10 = *a3;
      *(_DWORD *)buf = 134349056;
      v14 = v10;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "[AccessoryAccelerometer] Setting batch interval to %{public}f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
      v12 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryAccelerometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf)
        free(v12);
    }
    sub_18F203A68(*(_QWORD *)(a1 + 32), *a3);
    return *a3;
  }
  return v5;
}

void sub_18F46BBC4(uint64_t a1)
{
  NSObject *v2;
  char *v3;
  double v4;
  float v5;
  double v6;
  float v7;
  double v8;
  float v9;
  unint64_t TimeStamp;
  double v11;
  unsigned __int16 IntegerValue;
  uint64_t v13;
  NSObject *v14;
  __IOHIDServiceClient *v15;
  uint64_t v16;
  char *v17;
  NSObject *v18;
  double v19;
  double v20;
  NSObject *v21;
  char *v22;
  char *v23;
  _BYTE *v24;
  _BYTE *v25;
  char *v26;
  double v27;
  float v28;
  float v29;
  float v30;
  uint64_t v31;
  unsigned __int16 v32;
  int v33;
  int v34;
  __int16 v35;
  _BYTE *v36;
  __int16 v37;
  _BYTE *v38;
  _OWORD v39[3];
  uint8_t buf[4];
  int isa;
  __int16 v42;
  double v43;
  __int16 v44;
  double v45;
  __int16 v46;
  double v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  double v51;
  NSObject v52;
  _BYTE v53[10];
  __int16 v54;
  double v55;
  __int16 v56;
  _BYTE v57[10];
  uint64_t v58;
  __int16 v59;
  _BYTE v60[22];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  _BYTE v64[29];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (IOHIDEventGetType() == 13)
  {
    if (IOHIDEventGetIntegerValue() == 1)
    {
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
      v2 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "[AccessoryAccelerometer] Received shake data, discarding.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
        LOWORD(v52.isa) = 0;
        v3 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "virtual void CLAccessoryAccelerometer::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v3);
        if (v3 != (char *)buf)
          free(v3);
      }
    }
    else
    {
      IOHIDEventGetFloatValue();
      v5 = v4;
      v28 = v5;
      IOHIDEventGetFloatValue();
      v7 = v6;
      v29 = v7;
      IOHIDEventGetFloatValue();
      v9 = v8;
      v30 = v9;
      TimeStamp = IOHIDEventGetTimeStamp();
      v11 = sub_18F1FD20C(TimeStamp);
      v27 = v11;
      IntegerValue = IOHIDEventGetIntegerValue();
      v32 = IntegerValue;
      v13 = sub_18F4E3A64();
      v31 = v13;
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
      v14 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67241472;
        isa = IntegerValue;
        v42 = 2050;
        v43 = v5;
        v44 = 2050;
        v45 = v7;
        v46 = 2050;
        v47 = v9;
        v48 = 2050;
        v49 = v13;
        v50 = 2050;
        v51 = v11;
        _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_DEBUG, "[AccessoryAccelerometer] seq,%{public}d,x,%{public}20.20f,y,%{public}20.20f,z,%{public}20.20f,sensorTime,%{public}llu,timestamp,%{public}20.20f", buf, 0x3Au);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
        LODWORD(v52.isa) = 67241472;
        HIDWORD(v52.isa) = IntegerValue;
        *(_WORD *)v53 = 2050;
        *(double *)&v53[2] = v5;
        v54 = 2050;
        v55 = v7;
        v56 = 2050;
        *(double *)v57 = v9;
        *(_WORD *)&v57[8] = 2050;
        v58 = v13;
        v59 = 2050;
        *(double *)v60 = v11;
        v22 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "virtual void CLAccessoryAccelerometer::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v22);
        if (v22 != (char *)buf)
          free(v22);
      }
      sub_18F1FD2C8(a1, 0, (uint64_t)&v27, 40);
      if (!*(_BYTE *)(a1 + 30))
      {
        *(_BYTE *)(a1 + 30) = 1;
        LODWORD(v52.isa) = 0;
        sub_18F270374(v53, "N/A");
        sub_18F270374(&v57[2], "N/A");
        memset(v64, 0, sizeof(v64));
        v63 = 0u;
        v62 = 0u;
        v61 = 0u;
        *(_OWORD *)&v60[6] = 0u;
        if (sub_18F4A4B24((const char *)a1, &v52))
        {
          memset(v39, 0, 44);
          v15 = (__IOHIDServiceClient *)sub_18F1FBD7C(*(_QWORD *)(a1 + 32));
          if (sub_18F4E4C90(v39, v15, CFSTR("ARSC"), 0x2CuLL))
          {
            v16 = 0;
            v17 = &v60[10];
            do
            {
              snprintf(v17, 0x2CuLL, "%02x", *((unsigned __int8 *)v39 + v16++));
              v17 += 2;
            }
            while (v16 != 44);
          }
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
          v18 = qword_1ECEDEE30;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
          {
            if (v57[1] >= 0)
              v19 = COERCE_DOUBLE(v53);
            else
              v19 = *(double *)v53;
            if (v60[5] >= 0)
              v20 = COERCE_DOUBLE(&v57[2]);
            else
              v20 = *(double *)&v57[2];
            *(_DWORD *)buf = 67240707;
            isa = (int)v52.isa;
            v42 = 2081;
            v43 = v19;
            v44 = 2081;
            v45 = v20;
            _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_DEBUG, "[AccessoryAccelerometer] config,side,%{public}d,configuration,%{private}s,serialNumber,%{private}s", buf, 0x1Cu);
          }
          if (sub_18F1FCA08(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
            if (v57[1] >= 0)
              v24 = v53;
            else
              v24 = *(_BYTE **)v53;
            if (v60[5] >= 0)
              v25 = &v57[2];
            else
              v25 = *(_BYTE **)&v57[2];
            v33 = 67240707;
            v34 = (int)v52.isa;
            v35 = 2081;
            v36 = v24;
            v37 = 2081;
            v38 = v25;
            v26 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CLAccessoryAccelerometer::onAccelerometerData(const Sample &)", "CoreLocation: %s\n", v26);
            if (v26 != (char *)buf)
              free(v26);
          }
          sub_18F1FD2C8(a1, 1, (uint64_t)&v52, 152);
        }
        else
        {
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
          v21 = qword_1ECEDEE30;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v21, OS_LOG_TYPE_FAULT, "[AccessoryAccelerometer] Service not found!", buf, 2u);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2954B08);
            LOWORD(v39[0]) = 0;
            v23 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLAccessoryAccelerometer::onAccelerometerData(const Sample &)", "CoreLocation: %s\n", v23);
            if (v23 != (char *)buf)
              free(v23);
          }
        }
        if ((v60[5] & 0x80000000) != 0)
          operator delete(*(void **)&v57[2]);
        if ((v57[1] & 0x80000000) != 0)
          operator delete(*(void **)v53);
      }
    }
  }
}

void sub_18F46C3E4(_Unwind_Exception *a1)
{
  sub_18F3CB298((uint64_t)&STACK[0x6F0]);
  _Unwind_Resume(a1);
}

os_log_t sub_18F46C424()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1ECEDEE30 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F46C450(_QWORD *a1)
{
  uint64_t v2;

  v2 = sub_18F1E61EC((uint64_t)a1, (uint64_t)"CLMagnetometerCoexistenceNotifier", 2);
  *(_QWORD *)v2 = &off_1E294BA70;
  *(_QWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 40) = 0;
  *(_QWORD *)(v2 + 44) = -1;
  *(_DWORD *)(v2 + 52) = -1;
  *(_BYTE *)(v2 + 56) = 0;
  *(_QWORD *)(v2 + 60) = -1;
  a1[12] = 0;
  a1[13] = 0;
  a1[11] = 0;
  bzero((void *)(v2 + 72), 0x10uLL);
  return a1;
}

_QWORD *sub_18F46C4C4(_DWORD *a1)
{
  *(_QWORD *)a1 = &off_1E294BA70;
  sub_18F46C504(a1);
  bzero(a1 + 18, 0x10uLL);
  return sub_18F3DB8A0(a1);
}

uint64_t sub_18F46C504(_DWORD *a1)
{
  __CFNotificationCenter *DarwinNotifyCenter;
  int v3;
  int v4;
  uint64_t result;

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveEveryObserver(DarwinNotifyCenter, a1);
  v3 = a1[11];
  if (v3 != -1)
  {
    notify_cancel(v3);
    a1[11] = -1;
  }
  v4 = a1[13];
  if (v4 != -1)
  {
    notify_cancel(v4);
    a1[13] = -1;
  }
  result = a1[15];
  if ((_DWORD)result != -1)
  {
    result = notify_cancel(result);
    a1[15] = -1;
  }
  return result;
}

void sub_18F46C578(_DWORD *a1)
{
  sub_18F46C4C4(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F46C59C(uint64_t result, unsigned int a2, uint64_t a3)
{
  int *v3;
  NSObject *v4;
  __CFNotificationCenter *DarwinNotifyCenter;
  NSObject *v6;
  __CFNotificationCenter *v7;
  NSObject *v8;
  __CFNotificationCenter *v9;
  char *v10;
  char *v11;
  char *v12;
  uint8_t buf[4];
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2 <= 1)
  {
    v3 = (int *)result;
    *(_QWORD *)(result + 72 + 8 * a2) = a3;
    if (*(_QWORD *)(result + 72) || *(_QWORD *)(result + 80))
    {
      if ((*(_DWORD *)(result + 44) & 0x80000000) != 0)
      {
        if (notify_register_check("com.apple.isp.focusing", (int *)(result + 44)))
        {
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
          v4 = qword_1EE16D690;
          if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            v14 = "com.apple.isp.focusing";
            _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "Could not register for notification %s", buf, 0xCu);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EE16D698 != -1)
              dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
            v10 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()", "CoreLocation: %s\n", v10);
            if (v10 != (char *)buf)
              free(v10);
          }
        }
        DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
        CFNotificationCenterAddObserver(DarwinNotifyCenter, v3, (CFNotificationCallback)sub_18F46DA48, CFSTR("com.apple.isp.focusing"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      }
      if (v3[13] < 0)
      {
        if (notify_register_check("com.apple.isp.backcamerapower", v3 + 13))
        {
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
          v6 = qword_1EE16D690;
          if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            v14 = "com.apple.isp.backcamerapower";
            _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "Could not register for notification %s", buf, 0xCu);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EE16D698 != -1)
              dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
            v11 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()", "CoreLocation: %s\n", v11);
            if (v11 != (char *)buf)
              free(v11);
          }
        }
        v7 = CFNotificationCenterGetDarwinNotifyCenter();
        CFNotificationCenterAddObserver(v7, v3, (CFNotificationCallback)sub_18F46DA48, CFSTR("com.apple.isp.backcamerapower"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      }
      if (v3[15] < 0)
      {
        if (notify_register_check("com.apple.isp.backcamerasensorconfig", v3 + 15))
        {
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
          v8 = qword_1EE16D690;
          if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315138;
            v14 = "com.apple.isp.backcamerasensorconfig";
            _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "Could not register for notification %s", buf, 0xCu);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EE16D698 != -1)
              dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
            v12 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::registerForNotificationsIfNecessary()", "CoreLocation: %s\n", v12);
            if (v12 != (char *)buf)
              free(v12);
          }
        }
        v9 = CFNotificationCenterGetDarwinNotifyCenter();
        CFNotificationCenterAddObserver(v9, v3, (CFNotificationCallback)sub_18F46DA48, CFSTR("com.apple.isp.backcamerasensorconfig"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      }
      sub_18F46CB38((uint64_t)v3);
      sub_18F46CE74((uint64_t)v3);
      return sub_18F46D1A8(v3);
    }
    else
    {
      return sub_18F46C504((_DWORD *)result);
    }
  }
  return result;
}

void sub_18F46CB38(uint64_t a1)
{
  NSObject *v2;
  char *v3;
  NSObject *v4;
  int v5;
  int v6;
  char *v7;
  uint64_t state64;
  int v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  state64 = 0;
  if (notify_get_state(*(_DWORD *)(a1 + 52), &state64))
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v2 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v12 = "com.apple.isp.backcamerapower";
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
      v9 = 136315138;
      v10 = "com.apple.isp.backcamerapower";
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraState()", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 56) = state64 != 0;
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v4 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      v5 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)buf = 67109120;
      LODWORD(v12) = v5;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "camera state = %d", buf, 8u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
      v6 = *(unsigned __int8 *)(a1 + 56);
      v9 = 67109120;
      LODWORD(v10) = v6;
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraState()", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  }
}

void sub_18F46CE74(uint64_t a1)
{
  NSObject *v2;
  uint8_t *v3;
  int v4;
  NSObject *v5;
  int v6;
  int v7;
  BOOL v8;
  uint64_t state64;
  int v10;
  const char *v11;
  uint8_t buf[4];
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  state64 = 0;
  if (notify_get_state(*(_DWORD *)(a1 + 44), &state64))
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v2 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v13 = "com.apple.isp.focusing";
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
      v10 = 136315138;
      v11 = "com.apple.isp.focusing";
      v3 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateFocusPosition()", "CoreLocation: %s\n");
LABEL_19:
      if (v3 != buf)
        free(v3);
    }
  }
  else
  {
    v4 = state64;
    *(_DWORD *)(a1 + 48) = state64;
    v8 = v4 == 0xFFFF;
    sub_18F1E5A28(a1, 1, (uint64_t)&v8, 1);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v5 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      v6 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)buf = 67109120;
      LODWORD(v13) = v6;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "focus position = %d", buf, 8u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
      v7 = *(_DWORD *)(a1 + 48);
      v10 = 67109120;
      LODWORD(v11) = v7;
      v3 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateFocusPosition()", "CoreLocation: %s\n");
      goto LABEL_19;
    }
  }
}

uint64_t sub_18F46D1A8(_BYTE *a1)
{
  int v2;

  v2 = *((_DWORD *)a1 + 12);
  if (v2 != 0xFFFF)
  {
    if (a1[56])
    {
      *((float32x2_t *)a1 + 4) = vmla_n_f32(*(float32x2_t *)(a1 + 100), *(float32x2_t *)(a1 + 88), (float)v2);
      *((float *)a1 + 10) = *((float *)a1 + 27) + (float)(*((float *)a1 + 24) * (float)v2);
    }
    else
    {
      bzero(a1 + 32, 0xCuLL);
    }
  }
  (*(void (**)(_BYTE *))(*(_QWORD *)a1 + 64))(a1);
  return sub_18F1E5A28((uint64_t)a1, 0, (uint64_t)(a1 + 32), 12);
}

void sub_18F46D240(float32x2_t *a1, __int16 *a2)
{
  NSObject *v4;
  double v5;
  double v6;
  double v7;
  NSObject *v8;
  double v9;
  double v10;
  double v11;
  char *v12;
  char *v13;
  uint8_t buf[4];
  double v15;
  __int16 v16;
  double v17;
  __int16 v18;
  double v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  a1[11].f32[0] = (float)*a2 * 0.01;
  a1[11].f32[1] = (float)a2[1] * 0.01;
  a1[12].f32[0] = (float)a2[2] * 0.01;
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
  v4 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    v5 = a1[11].f32[0];
    v6 = a1[11].f32[1];
    v7 = a1[12].f32[0];
    *(_DWORD *)buf = 134218496;
    v15 = v5;
    v16 = 2048;
    v17 = v6;
    v18 = 2048;
    v19 = v7;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "VCM Delta.x,%f,VCM Delta.y,%f,VCM Delta.z,%f", buf, 0x20u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v12 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::setCoexistenceInfo(const CameraCoexistenceInfo &)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf)
      free(v12);
  }
  a1[11] = vdiv_f32(a1[11], (float32x2_t)vdup_n_s32(0x437F0000u));
  a1[12].f32[0] = a1[12].f32[0] / 255.0;
  a1[12].f32[1] = (float)a2[3] * 0.01;
  a1[13].f32[0] = (float)a2[4] * 0.01;
  a1[13].f32[1] = (float)a2[5] * 0.01;
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
  v8 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    v9 = a1[12].f32[1];
    v10 = a1[13].f32[0];
    v11 = a1[13].f32[1];
    *(_DWORD *)buf = 134218496;
    v15 = v9;
    v16 = 2048;
    v17 = v10;
    v18 = 2048;
    v19 = v11;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "Rear camera offset.x,%f,Rear camera offset.y,%f,Rear camera offset.z,%f", buf, 0x20u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v13 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::setCoexistenceInfo(const CameraCoexistenceInfo &)", "CoreLocation: %s\n", v13);
    if (v13 != (char *)buf)
      free(v13);
  }
}

BOOL sub_18F46D668()
{
  uint64_t v0;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  _QWORD *v29;
  std::__shared_weak_count *v30;
  _QWORD *v31;
  std::__shared_weak_count *v32;
  void *__p[2];
  char v34;

  sub_18F204AE4();
  if (*(_BYTE *)(qword_1ECEDFE08 + 16))
    return sub_18F3C7A24();
  v2 = (std::__shared_weak_count *)operator new(0x70uLL);
  v2->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  v2->__shared_weak_owners_ = 0;
  v2->__vftable = (std::__shared_weak_count_vtbl *)&off_1E2952688;
  sub_18F270374(__p, "kCLConnectionMessageDeviceHasOriginalCamera");
  MEMORY[0x194001030](&v2[1], __p);
  if (v34 < 0)
    operator delete(__p[0]);
  v31 = &v2[1].__vftable;
  v32 = v2;
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v11 = objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  v29 = &v2[1].__vftable;
  v30 = v2;
  do
    v13 = __ldxr(p_shared_owners);
  while (__stxr(v13 + 1, p_shared_owners));
  v17 = (void *)objc_msgSend_sendMessage_withReplyClassesSync_(CMMotionUtils, v10, (uint64_t)&v29, v11, v12);
  v18 = v30;
  if (v30)
  {
    v19 = (unint64_t *)&v30->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  v21 = (void *)objc_msgSend_objectForKeyedSubscript_(v17, v14, (uint64_t)CFSTR("CMDeviceHasOriginalBackCamera"), v15, v16);
  v0 = objc_msgSend_BOOLValue(v21, v22, v23, v24, v25);
  v26 = v32;
  if (v32)
  {
    v27 = (unint64_t *)&v32->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  return v0;
}

void sub_18F46D804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_18F2A8438((uint64_t)&a12);
  sub_18F2A8438((uint64_t)&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_18F46D858()
{
  const char *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  _QWORD *v28;
  std::__shared_weak_count *v29;
  _QWORD *v30;
  std::__shared_weak_count *v31;
  void *__p[2];
  char v33;

  sub_18F204AE4();
  if (*(_BYTE *)(qword_1ECEDFE08 + 16))
  {
    v4 = (void *)sub_18F3C8554();
  }
  else
  {
    v6 = (std::__shared_weak_count *)operator new(0x70uLL);
    v6->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    v6->__shared_weak_owners_ = 0;
    v6->__vftable = (std::__shared_weak_count_vtbl *)&off_1E2952688;
    sub_18F270374(__p, "kCLConnectionMessageCameraVcmActuatorId");
    MEMORY[0x194001030](&v6[1], __p);
    if (v33 < 0)
      operator delete(__p[0]);
    v30 = &v6[1].__vftable;
    v31 = v6;
    v8 = (void *)MEMORY[0x1E0C99E60];
    v9 = objc_opt_class();
    v10 = objc_opt_class();
    v15 = objc_msgSend_setWithObjects_(v8, v11, v9, v12, v13, v10, 0);
    v28 = &v6[1].__vftable;
    v29 = v6;
    do
      v17 = __ldxr(p_shared_owners);
    while (__stxr(v17 + 1, p_shared_owners));
    v21 = (void *)objc_msgSend_sendMessage_withReplyClassesSync_(CMMotionUtils, v14, (uint64_t)&v28, v15, v16);
    v22 = v29;
    if (v29)
    {
      v23 = (unint64_t *)&v29->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v4 = (void *)objc_msgSend_objectForKeyedSubscript_(v21, v18, (uint64_t)CFSTR("CMCameraVcmActuatorId"), v19, v20);
    v25 = v31;
    if (v31)
    {
      v26 = (unint64_t *)&v31->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }
  return objc_msgSend_intValue(v4, v0, v1, v2, v3);
}

void sub_18F46D9F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_18F2A8438((uint64_t)&a14);
  _Unwind_Resume(a1);
}

void sub_18F46DA48(int a1, uint64_t a2, CFStringRef theString1)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD v7[5];
  _QWORD v8[5];
  _QWORD v9[5];

  if (CFStringCompare(theString1, CFSTR("com.apple.isp.focusing"), 0))
  {
    if (CFStringCompare(theString1, CFSTR("com.apple.isp.backcamerapower"), 0))
    {
      if (CFStringCompare(theString1, CFSTR("com.apple.isp.backcamerasensorconfig"), 0))
        return;
      v5 = sub_18F204AE4();
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = sub_18F46DEAC;
      v7[3] = &unk_1E2955738;
      v7[4] = a2;
      v6 = v7;
    }
    else
    {
      v5 = sub_18F204AE4();
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = sub_18F46DD0C;
      v8[3] = &unk_1E2955738;
      v8[4] = a2;
      v6 = v8;
    }
  }
  else
  {
    v5 = sub_18F204AE4();
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = sub_18F46DB6C;
    v9[3] = &unk_1E2955738;
    v9[4] = a2;
    v6 = v9;
  }
  sub_18F1F5E28(v5, (uint64_t)v6);
}

uint64_t sub_18F46DB6C(uint64_t a1)
{
  _BYTE *v1;
  NSObject *v2;
  char *v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = *(_BYTE **)(a1 + 32);
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
  v2 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Received focusing notification", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::onFocusingNotification()", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
  sub_18F46CE74((uint64_t)v1);
  return sub_18F46D1A8(v1);
}

uint64_t sub_18F46DD0C(uint64_t a1)
{
  _BYTE *v1;
  NSObject *v2;
  char *v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = *(_BYTE **)(a1 + 32);
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
  v2 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Received camera state notification", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraStateNotification()", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
  sub_18F46CB38((uint64_t)v1);
  return sub_18F46D1A8(v1);
}

uint64_t sub_18F46DEAC(uint64_t a1)
{
  int *v1;
  NSObject *v2;
  NSObject *v3;
  char *v4;
  NSObject *v5;
  int v6;
  char *v8;
  int v9;
  char *v10;
  uint64_t state64;
  int v12;
  const char *v13;
  uint8_t buf[4];
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v1 = *(int **)(a1 + 32);
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
  v2 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Received camera mode notification", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    LOWORD(v12) = 0;
    v8 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::onCameraModeNotification()", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf)
      free(v8);
  }
  state64 = 0;
  if (notify_get_state(v1[15], &state64))
  {
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v3 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315138;
      v15 = "com.apple.isp.backcamerasensorconfig";
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_FAULT, "Could not get state for %s", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
      v12 = 136315138;
      v13 = "com.apple.isp.backcamerasensorconfig";
      v4 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraMode()", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf)
        free(v4);
    }
  }
  else
  {
    v1[16] = state64;
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
    v5 = qword_1EE16D690;
    if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
    {
      v6 = v1[16];
      *(_DWORD *)buf = 67109120;
      LODWORD(v15) = v6;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "camera mode = %d", buf, 8u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D698 != -1)
        dispatch_once(&qword_1EE16D698, &unk_1E2953D48);
      v9 = v1[16];
      v12 = 67109120;
      LODWORD(v13) = v9;
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasCamera::updateCameraMode()", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
    (*(void (**)(int *))(*(_QWORD *)v1 + 56))(v1);
  }
  return sub_18F46D1A8(v1);
}

float sub_18F46E308(int a1)
{
  float result;
  NSObject *v3;
  int v4;
  char *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a1 > 2104)
  {
    if (a1 > 12149)
    {
      switch(a1)
      {
        case 17150:
          return 5.97;
        case 15110:
          return 6.95;
        case 12150:
          return 9.33;
      }
    }
    else
    {
      switch(a1)
      {
        case 2105:
          return 3.71;
        case 2150:
          return 4.6;
        case 3015:
          return 5.87;
      }
    }
  }
  else if (a1 > 2023)
  {
    switch(a1)
    {
      case 2024:
        return 5.13;
      case 2071:
        return 5.91;
      case 2101:
        return 6.07;
    }
  }
  else
  {
    switch(a1)
    {
      case 2010:
        return 6.35;
      case 2020:
        return 7.55;
      case 2022:
        return 5.38;
    }
  }
  if (qword_1EE16D6A0 != -1)
    dispatch_once(&qword_1EE16D6A0, &unk_1E2953D68);
  v3 = qword_1EE16D6A8;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    v7 = a1;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_FAULT, "Unexpected activity type passed to lookup model, %d", buf, 8u);
  }
  v4 = sub_18F1FCA08(115, 0);
  result = 4.4021;
  if (v4)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6A0 != -1)
      dispatch_once(&qword_1EE16D6A0, &unk_1E2953D68);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "float CLCalorieUtils::lookupMetsForActivity(const CLMotionActivity::Type)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
    return 4.4021;
  }
  return result;
}

os_log_t sub_18F46E5D8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1EE16D6A8 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F46E604(_QWORD *a1, _OWORD *a2)
{
  _QWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v4 = sub_18F46C450(a1);
  *v4 = &off_1E294B9C0;
  *((_OWORD *)v4 + 7) = *a2;
  v5 = a2[1];
  v6 = a2[2];
  v7 = a2[3];
  *(_OWORD *)((char *)v4 + 170) = *(_OWORD *)((char *)a2 + 58);
  *((_OWORD *)v4 + 9) = v6;
  *((_OWORD *)v4 + 10) = v7;
  *((_OWORD *)v4 + 8) = v5;
  sub_18F46E69C((float32x2_t *)v4);
  return a1;
}

void sub_18F46E65C(_Unwind_Exception *a1)
{
  _DWORD *v1;

  sub_18F46C4C4(v1);
  _Unwind_Resume(a1);
}

void sub_18F46E674(_DWORD *a1)
{
  sub_18F46C4C4(a1);
  JUMPOUT(0x194001438);
}

void sub_18F46E69C(float32x2_t *a1)
{
  __int32 v2;
  char *v3;
  char *v4;
  NSObject *v5;
  __int32 v6;
  __int32 v7;
  char *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  __int32 v24;
  uint8_t buf[4];
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  __int32 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  bzero(&v9, 0x12uLL);
  v2 = a1[8].i32[0];
  v3 = (char *)&a1[21] + 6;
  if (v2 != 2)
    v3 = (char *)&a1[14] + 2;
  if (v2 == 1)
    v4 = (char *)&a1[17] + 2;
  else
    v4 = v3;
  v9 = *(_QWORD *)v4;
  v10 = *((_DWORD *)v4 + 2);
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953D88);
  v5 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    v6 = a1[8].i32[0];
    *(_DWORD *)buf = 67110656;
    v26 = (__int16)v9;
    v27 = 1024;
    v28 = SWORD1(v9);
    v29 = 1024;
    v30 = SWORD2(v9);
    v31 = 1024;
    v32 = SHIWORD(v9);
    v33 = 1024;
    v34 = (__int16)v10;
    v35 = 1024;
    v36 = SHIWORD(v10);
    v37 = 1024;
    v38 = v6;
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d", buf, 0x2Cu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953D88);
    v7 = a1[8].i32[0];
    v11 = 67110656;
    v12 = (__int16)v9;
    v13 = 1024;
    v14 = SWORD1(v9);
    v15 = 1024;
    v16 = SWORD2(v9);
    v17 = 1024;
    v18 = SHIWORD(v9);
    v19 = 1024;
    v20 = (__int16)v10;
    v21 = 1024;
    v22 = SHIWORD(v10);
    v23 = 1024;
    v24 = v7;
    v8 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV10::chooseOffsetData()", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf)
      free(v8);
  }
  sub_18F46D240(a1, (__int16 *)&v9);
}

uint64_t sub_18F46ED40(uint64_t a1)
{
  NSObject *v2;
  const void *v3;

  dispatch_release(*(dispatch_object_t *)(a1 + 8));
  v2 = *(NSObject **)(a1 + 16);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 24);
  if (v3)
    _Block_release(v3);
  sub_18F331ACC((uint64_t *)a1, 0);
  return a1;
}

void sub_18F46ED90(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  NSObject *v4;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(const void **)(v2 + 24);
  if (v3)
    _Block_release(v3);
  *(_QWORD *)(v2 + 24) = _Block_copy(*(const void **)(a1 + 40));
  v4 = *(NSObject **)(v2 + 16);
  if (v4)
    dispatch_release(v4);
  *(_QWORD *)(v2 + 16) = *(_QWORD *)(a1 + 32);
  dispatch_retain(*(dispatch_object_t *)(a1 + 32));
}

os_log_t sub_18F46EDE0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Pressure");
  qword_1EE16D6C0 = (uint64_t)result;
  return result;
}

uint64_t sub_18F46EE0C(float *a1, float a2)
{
  uint64_t result;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t (***v7)();
  char v8;
  uint64_t (**v9)();
  char v10;
  uint64_t buf;
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v9 = &off_1E2952A18;
  v10 = 0;
  v7 = &v9;
  v8 = 0;
  sub_18F45F3C4((uint64_t)&v7, a1);
  result = sub_18F45F7B4((uint64_t)&v7, a2);
  if (!v10)
  {
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
    v4 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
    {
      buf = 68289539;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "receiver.fGotFit";
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
    }
    v5 = qword_1ECEDEE60;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE60))
    {
      buf = 68289539;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "receiver.fGotFit";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
    }
    v6 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_INFO))
    {
      buf = 68289539;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "receiver.fGotFit";
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x26u);
    }
    abort_report_np();
    __break(1u);
  }
  return result;
}

float sub_18F46F0D0(uint64_t a1, float *a2, unint64_t a3)
{
  float v3;
  float *v4;
  float v5;
  float v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  unint64_t v10;
  float *v11;
  unint64_t v12;
  float *v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float *v18;
  float *v19;
  float v20;
  float v22;
  float v23;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  const char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v3 = (float)((float)a3 * 4.0) + 2.0;
  if ((float *)a1 == a2)
    goto LABEL_23;
  v4 = (float *)(a1 + 24);
  while (v4 != a2)
  {
    v5 = *v4;
    v6 = *(v4 - 6);
    v4 += 6;
    if (v5 < v6)
    {
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
      v7 = qword_1ECEDEE60;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 68289539;
        v25 = 0;
        v26 = 2082;
        v27 = "";
        v28 = 2082;
        v29 = "assert";
        v30 = 2081;
        v31 = "std::is_sorted(samples.begin(), samples.end())";
        _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        if (qword_1ECEDEE68 != -1)
          dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
      }
      v8 = qword_1ECEDEE60;
      if (os_signpost_enabled((os_log_t)qword_1ECEDEE60))
      {
        *(_DWORD *)buf = 68289539;
        v25 = 0;
        v26 = 2082;
        v27 = "";
        v28 = 2082;
        v29 = "assert";
        v30 = 2081;
        v31 = "std::is_sorted(samples.begin(), samples.end())";
        _os_signpost_emit_with_name_impl(&dword_18F1DC000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        if (qword_1ECEDEE68 != -1)
          dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
      }
      v9 = qword_1ECEDEE60;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 68289539;
        v25 = 0;
        v26 = 2082;
        v27 = "";
        v28 = 2082;
        v29 = "assert";
        v30 = 2081;
        v31 = "std::is_sorted(samples.begin(), samples.end())";
        _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      }
      a1 = abort_report_np();
      break;
    }
  }
  v10 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)a2 - a1) >> 3);
  v11 = (float *)a1;
  do
  {
    v12 = v10 >> 1;
    v13 = &v11[6 * (v10 >> 1)];
    v15 = *v13;
    v14 = v13 + 6;
    v10 += ~(v10 >> 1);
    if (v15 < v3)
      v11 = v14;
    else
      v10 = v12;
  }
  while (v10);
  if (v11 == (float *)a1)
  {
LABEL_23:
    v16 = INFINITY;
    v11 = (float *)a1;
  }
  else
  {
    v16 = vabds_f32(*(v11 - 6), v3);
  }
  if (v11 == a2)
    v17 = INFINITY;
  else
    v17 = vabds_f32(*v11, v3);
  v18 = v11;
  do
  {
    if (v11 == (float *)a1 && v18 == a2)
    {
      v20 = 72.0;
LABEL_43:
      v22 = -30.0;
      v23 = 3.0;
      return fminf(v22 + (float)(v20 * v23), 255.0);
    }
    if (v16 >= v17)
    {
      if (v18 + 6 == a2)
      {
        v17 = INFINITY;
        v19 = v18;
        v18 = a2;
      }
      else
      {
        v17 = vabds_f32(v18[6], v3);
        v19 = v18;
        v18 += 6;
      }
    }
    else
    {
      v19 = v11 - 6;
      if (v11 - 6 == (float *)a1)
      {
        v16 = INFINITY;
        v19 = (float *)a1;
        v11 = (float *)a1;
      }
      else
      {
        v16 = vabds_f32(*(v11 - 12), v3);
        v11 -= 6;
      }
    }
  }
  while ((char *)v18 - (char *)v11 < 72);
  v20 = 72.0;
  if (v19 == a2 || !v19)
    goto LABEL_43;
  v20 = vabds_f32(*v19, v3);
  if (v20 < 10.0)
    return roundf((float)(v20 * 0.3) + 7.0);
  if (v20 >= 20.0)
    goto LABEL_43;
  v22 = -10.0;
  v23 = 2.0;
  return fminf(v22 + (float)(v20 * v23), 255.0);
}

void sub_18F46F4F8(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  float *v6;
  unint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  unint64_t v15;
  uint64_t i;
  float v17;
  float v18;
  uint64_t j;
  char v20;
  int v21;
  int32x2_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  uint64_t v26;
  float v27;
  float *v28;
  float *v29;
  unint64_t v30;
  unint64_t v31;
  float *v32;
  float *v33;
  float v34;
  unint64_t v35;
  float *v36;
  unint64_t v37;
  float *v38;
  float *v39;
  float v40;
  uint64_t v41;
  uint64_t k;
  uint64_t m;
  unint64_t v44;
  _BYTE *v45;
  float32x2_t v46;
  float32x2_t v47;
  float *v48;
  float v49;
  unint64_t v50;
  float *v51;
  unint64_t v52;
  float *v53;
  float *v54;
  float v55;
  float v56;
  unint64_t v57;
  float *v58;
  unint64_t v59;
  float *v60;
  float *v61;
  float v62;
  float *v63;
  unint64_t v64;
  float v65;
  uint64_t v66;
  float32x2_t v67;
  float v68;
  float v69;
  float v70;
  uint64_t v71;
  float v72;
  float v73;
  float v74;
  float v75;
  uint64_t v76;
  float v77;
  float32x2_t v78;
  float v79;
  float32x2_t v80;
  float32x2_t v81;
  float v82;
  uint64_t v83;
  float v84;
  float v85;
  float32x2_t v86;
  float32x2_t v87;
  uint64_t v88;
  float v89;
  float32x2_t v90;
  unint64_t v91;
  _BYTE *v92;
  float v93;
  unint64_t n;
  float v95;
  _BYTE *v96;
  NSObject *v97;
  NSObject *v98;
  NSObject *v99;
  int v100;
  _BYTE buf[28];
  __int16 v102;
  const char *v103;
  uint64_t v104;

  v104 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a3 + 266) = 0u;
  *(_OWORD *)(a3 + 241) = 0u;
  *(_OWORD *)(a3 + 225) = 0u;
  *(_OWORD *)(a3 + 209) = 0u;
  *(_OWORD *)(a3 + 193) = 0u;
  *(_OWORD *)(a3 + 177) = 0u;
  *(_OWORD *)(a3 + 161) = 0u;
  *(_OWORD *)(a3 + 145) = 0u;
  *(_OWORD *)(a3 + 129) = 0u;
  *(_OWORD *)(a3 + 113) = 0u;
  *(_OWORD *)(a3 + 97) = 0u;
  *(_OWORD *)(a3 + 81) = 0u;
  *(_OWORD *)(a3 + 65) = 0u;
  *(_OWORD *)(a3 + 49) = 0u;
  *(_OWORD *)(a3 + 33) = 0u;
  *(_OWORD *)(a3 + 17) = 0u;
  *(_OWORD *)(a3 + 1) = 0u;
  *(_OWORD *)(a3 + 257) = 0u;
  *(_BYTE *)a3 = 22;
  v6 = *(float **)a1;
  v7 = *(_QWORD *)(a1 + 8);
  if (v6 == (float *)v7)
  {
    *(_QWORD *)(a3 + 228) = -1;
    *(_QWORD *)(a3 + 246) = -1;
    *(_QWORD *)(a3 + 264) = -1;
    return;
  }
  sub_18F470128((uint64_t)v6, v7, 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (_QWORD)v6) >> 3)), 1);
  v8 = **(float **)a1;
  v9 = *(float *)(*(_QWORD *)(a1 + 8) - 24);
  v10 = v9 - v8;
  v100 = a2;
  if ((float)(v9 - v8) < 6.6667)
  {
    *(_DWORD *)(a3 + 224) = 1084227584;
    v11 = 2.5;
    v12 = 1.0;
    v13 = 10.0;
LABEL_11:
    v18 = (float)((float)(v8 + v9) + (float)(v12 * -10.0)) * 0.5;
    *(float *)(a3 + 196) = v18;
    v15 = 1;
    goto LABEL_12;
  }
  v14 = 3.4028e38;
  v15 = 1;
  for (i = 2; i != 7; ++i)
  {
    v17 = fabsf((float)(v10 / (float)(i - 1)) + -10.0);
    if (v17 < v14)
    {
      v14 = v17;
      v15 = i;
    }
  }
  v13 = v10 / (float)(v15 - 1);
  v12 = v13 / 10.0;
  *(float *)(a3 + 224) = (float)(v13 / 10.0) * 5.0;
  if (v15 >= 7)
  {
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
    v97 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = "assert";
      v102 = 2081;
      v103 = "subfitCount <= Fit::kFitSegments - 2";
      _os_log_impl(&dword_18F1DC000, v97, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
    }
    v98 = qword_1ECEDEE60;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE60))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = "assert";
      v102 = 2081;
      v103 = "subfitCount <= Fit::kFitSegments - 2";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v98, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E29549C8);
    }
    v99 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = "assert";
      v102 = 2081;
      v103 = "subfitCount <= Fit::kFitSegments - 2";
      _os_log_impl(&dword_18F1DC000, v99, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  v11 = (float)(v12 * 0.5) * 5.0;
  if (v15 == 1)
    goto LABEL_11;
  v18 = v8 + (float)((float)(v12 * 0.5) * -10.0);
  *(float *)(a3 + 196) = v18;
  if (!v15)
  {
    v21 = 1;
    v20 = 1;
    goto LABEL_16;
  }
LABEL_12:
  for (j = 0; j != v15; ++j)
  {
    v18 = v13 + v18;
    *(float *)(a3 + 200 + 4 * j) = v18;
  }
  if (v15 > 5)
  {
LABEL_17:
    v23 = 0;
    v24 = a3 + 28;
    do
    {
      v25 = *(float *)(a3 + 196 + 4 * v23) - v11;
      v26 = v23 + 1;
      v27 = v11 + *(float *)(a3 + 196 + 4 * (v23 + 1));
      v29 = *(float **)a1;
      v28 = *(float **)(a1 + 8);
      if (v28 == *(float **)a1)
      {
        v36 = *(float **)(a1 + 8);
      }
      else
      {
        v30 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v28 - *(_QWORD *)a1) >> 3);
        do
        {
          v31 = v30 >> 1;
          v32 = &v29[6 * (v30 >> 1)];
          v34 = *v32;
          v33 = v32 + 6;
          v30 += ~(v30 >> 1);
          if (v34 < v25)
            v29 = v33;
          else
            v30 = v31;
        }
        while (v30);
        if (v28 == v29)
        {
          v36 = *(float **)(a1 + 8);
        }
        else
        {
          v35 = 0xAAAAAAAAAAAAAAABLL * (((char *)v28 - (char *)v29) >> 3);
          v36 = v29;
          do
          {
            v37 = v35 >> 1;
            v38 = &v36[6 * (v35 >> 1)];
            v40 = *v38;
            v39 = v38 + 6;
            v35 += ~(v35 >> 1);
            if (v40 > v27)
              v35 = v37;
            else
              v36 = v39;
          }
          while (v35);
        }
        v28 = v29;
      }
      sub_18F48F978(v28, v36, 0, 0, (float *)buf);
      v41 = a3 + 24 * v26;
      *(_OWORD *)(v41 + 4) = *(_OWORD *)buf;
      *(_QWORD *)(v41 + 20) = *(_QWORD *)&buf[16];
      if (!v23)
      {
        for (k = 0; k != 12; k += 4)
          *(float *)(a3 + k + 16) = *(float *)(a3 + k + 40) + (float)(v25 * *(float *)(a3 + k + 28));
      }
      if (v15 - 1 == v23)
      {
        for (m = 0; m != 12; m += 4)
          *(float *)(a3 + 24 * v15 + 40 + m) = *(float *)(v24 + m + 12) + (float)(v27 * *(float *)(v24 + m));
      }
      v24 += 24;
      ++v23;
    }
    while (v26 != v15);
    goto LABEL_41;
  }
  v20 = 0;
  v21 = v15 + 1;
LABEL_16:
  memset_pattern16((void *)(a3 + (4 * v21 + 196)), &unk_18F509120, 4 * (6 - v21) + 4);
  if ((v20 & 1) == 0)
    goto LABEL_17;
LABEL_41:
  if (v100)
  {
    v44 = 0;
    v45 = (_BYTE *)(a3 + 228);
    v46 = (float32x2_t)vdup_n_s32(0x3C8EFA35u);
    v47 = (float32x2_t)vdup_n_s32(0x42652EE1u);
    while (1)
    {
      v48 = *(float **)(a1 + 8);
      if (v48 == *(float **)a1)
        break;
      v49 = (float)((float)(int)v44 * 4.0) + 2.0;
      v50 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v48 - *(_QWORD *)a1) >> 3);
      v51 = *(float **)a1;
      do
      {
        v52 = v50 >> 1;
        v53 = &v51[6 * (v50 >> 1)];
        v55 = *v53;
        v54 = v53 + 6;
        v50 += ~(v50 >> 1);
        if (v55 < (float)(v49 + -2.0))
          v51 = v54;
        else
          v50 = v52;
      }
      while (v50);
      if (v48 == v51)
      {
        v63 = v51;
        v51 = *(float **)(a1 + 8);
        goto LABEL_58;
      }
      v56 = v49 + 2.0;
      v57 = 0xAAAAAAAAAAAAAAABLL * (((char *)v48 - (char *)v51) >> 3);
      v58 = v51;
      do
      {
        v59 = v57 >> 1;
        v60 = &v58[6 * (v57 >> 1)];
        v62 = *v60;
        v61 = v60 + 6;
        v57 += ~(v57 >> 1);
        if (v62 > v56)
          v57 = v59;
        else
          v58 = v61;
      }
      while (v57);
      v63 = v51;
LABEL_59:
      v64 = 0xAAAAAAAAAAAAAAABLL * (((char *)v58 - (char *)v63) >> 3);
      if (v64 > 4)
      {
        v67 = 0;
        *(_QWORD *)buf = 0;
        *(_DWORD *)&buf[8] = 0;
        if (v51 == v58)
        {
          v70 = 0.0;
LABEL_76:
          v91 = 0;
          *(float *)v22.i32 = (float)v64;
          *(float32x2_t *)buf = vdiv_f32(v67, (float32x2_t)vdup_lane_s32(v22, 0));
          *(float *)&buf[8] = v70 / (float)v64;
          v92 = v45;
          do
          {
            v93 = sqrtf(*(float *)sub_18F33D3D0((uint64_t)buf, v91)) * 100.0;
            if (v93 < 1.0)
              v93 = 1.0;
            *v92 = (int)v93;
            v92 += 18;
            ++v91;
          }
          while (v91 != 3);
          goto LABEL_80;
        }
        v69 = *(float *)(a3 + 220);
        v68 = *(float *)(a3 + 224);
        v70 = 0.0;
        while (2)
        {
          v71 = 0;
          v72 = *v51;
          while (1)
          {
            v73 = *(float *)(a3 + 196 + 4 * v71);
            if ((float)(v68 + v73) > v72)
              break;
            if (++v71 == 6)
            {
              v73 = v69;
              break;
            }
          }
          v74 = (float)((float)(v72 - v73) / (float)(v68 + v68)) + 0.5;
          if (v74 <= 0.0)
          {
            v83 = a3 + 24 * v71;
            v84 = *(float *)(v83 + 24);
            v85 = v72 * *(float *)(v83 + 12);
            v86 = *(float32x2_t *)(v83 + 4);
            v87 = *(float32x2_t *)(v83 + 16);
          }
          else
          {
            if (v74 < 1.0)
            {
              v75 = v74 * (float)(v74 * (float)((float)(v74 * -2.0) + 3.0));
              v76 = a3 + 24 * v71;
              v77 = (float)((float)(v72 * *(float *)(v76 + 12)) + *(float *)(v76 + 24)) * 0.017453;
              v78 = vmul_n_f32(*(float32x2_t *)(v76 + 28), v72);
              v79 = (float)((float)((float)(v72 * *(float *)(v76 + 36)) + *(float *)(v76 + 48)) * 0.017453) - v77;
              v80 = vmul_f32(vadd_f32(vmul_n_f32(*(float32x2_t *)(v76 + 4), v72), *(float32x2_t *)(v76 + 16)), v46);
              v81 = vadd_f32(v80, vmul_n_f32(vsub_f32(vmul_f32(vadd_f32(v78, *(float32x2_t *)(v76 + 40)), v46), v80), v75));
              v82 = v77 + (float)(v75 * v79);
              goto LABEL_73;
            }
            v88 = a3 + 24 * v71;
            v84 = *(float *)(v88 + 48);
            v85 = v72 * *(float *)(v88 + 36);
            v86 = *(float32x2_t *)(v88 + 28);
            v87 = *(float32x2_t *)(v88 + 40);
          }
          v81 = vmul_f32(vadd_f32(vmul_n_f32(v86, v72), v87), v46);
          v82 = (float)(v85 + v84) * 0.017453;
LABEL_73:
          v89 = (float)(v82 * 57.296) - v51[3];
          v90 = vsub_f32(vmul_f32(v81, v47), *(float32x2_t *)(v51 + 1));
          v67 = vmla_f32(v67, v90, v90);
          *(float32x2_t *)buf = v67;
          v70 = v70 + (float)(v89 * v89);
          *(float *)&buf[8] = v70;
          v51 += 6;
          if (v51 == v58)
            goto LABEL_76;
          continue;
        }
      }
      v65 = sub_18F46F0D0(*(_QWORD *)a1, v48, v44);
      v66 = a3 + v44;
      *(_BYTE *)(v66 + 264) = (int)v65;
      *(_BYTE *)(v66 + 246) = (int)v65;
      *(_BYTE *)(a3 + 228 + v44) = (int)v65;
LABEL_80:
      ++v44;
      ++v45;
      if (v44 == 18)
        return;
    }
    v51 = *(float **)a1;
    v63 = *(float **)(a1 + 8);
LABEL_58:
    v58 = *(float **)(a1 + 8);
    goto LABEL_59;
  }
  for (n = 0; n != 18; ++n)
  {
    v95 = sub_18F46F0D0(*(_QWORD *)a1, *(float **)(a1 + 8), n);
    v96 = (_BYTE *)(a3 + n);
    v96[264] = (int)v95;
    v96[246] = (int)v95;
    v96[228] = (int)v95;
  }
}

void sub_18F46FE1C(uint64_t a1, uint64_t *a2, int a3, double a4)
{
  uint64_t v7;
  uint64_t i;
  float *v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v17;
  float v18;
  float *v19;
  float *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  float *v26;
  int v27;
  float *v28;
  uint64_t v29;
  _BYTE *v30;
  unsigned int v31;
  float v32;
  int v33;
  float v34;
  BOOL v35;
  float v36;
  float *__p;
  float *v39;
  char *v40;

  v7 = 0;
  __p = 0;
  v40 = 0;
  do
  {
    for (i = 0; i != 18; ++i)
    {
      v9 = __p;
      v39 = __p;
      v10 = *a2;
      v11 = a2[1];
      v12 = 7.0;
      if (*a2 != v11)
      {
        v13 = (float)((float)(int)i * 4.0) + 2.0;
        v14 = v13 + -2.0;
        v15 = v13 + 2.0;
        do
        {
          if (v14 <= *(float *)v10 && *(float *)v10 < v15)
          {
            v17 = a4 - *(double *)(v10 + 16);
            v18 = fabsf(v17);
            if (v9 >= (float *)v40)
            {
              v20 = __p;
              v21 = v9 - __p;
              v22 = v21 + 1;
              if ((unint64_t)(v21 + 1) >> 62)
                sub_18F26F8C0();
              v23 = v40 - (char *)__p;
              if ((v40 - (char *)__p) >> 1 > v22)
                v22 = v23 >> 1;
              if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL)
                v24 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v24 = v22;
              if (v24)
              {
                v25 = (char *)sub_18F26FB8C((uint64_t)&v40, v24);
                v20 = __p;
                v9 = v39;
              }
              else
              {
                v25 = 0;
              }
              v26 = (float *)&v25[4 * v21];
              *v26 = v18;
              v19 = v26 + 1;
              while (v9 != v20)
              {
                v27 = *((_DWORD *)v9-- - 1);
                *((_DWORD *)v26-- - 1) = v27;
              }
              __p = v26;
              v40 = &v25[4 * v24];
              if (v20)
                operator delete(v20);
            }
            else
            {
              *v9 = v18;
              v19 = v9 + 1;
            }
            v39 = v19;
            v9 = v19;
          }
          v10 += 24;
        }
        while (v10 != v11);
        if (v9 != __p)
        {
          if ((unint64_t)((char *)v9 - (char *)__p) > 0xB)
          {
            v28 = __p + 2;
            if (__p + 2 != v9)
              sub_18F3D33A8((uint64_t)__p, __p + 2, v9);
          }
          else
          {
            v28 = v9 - 1;
          }
          v12 = *v28 / 86400.0;
        }
      }
      v29 = a1 + 18 * v7 + i;
      v31 = *(unsigned __int8 *)(v29 + 228);
      v30 = (_BYTE *)(v29 + 228);
      v32 = (float)v31 * 0.01;
      if (a3)
      {
        if (v12 > 2.0 && v32 < 0.1)
          v32 = 0.1;
      }
      else
      {
        v33 = (int)v12;
        if ((int)v12 >= 6)
          v33 = 6;
        v32 = v32 + flt_18F509080[v33 & ~(v33 >> 31)];
      }
      v34 = v32 * 100.0;
      v35 = v32 <= 2.5;
      v36 = 250.0;
      if (v35)
        v36 = v34;
      *v30 = (int)v36;
    }
    ++v7;
  }
  while (v7 != 3);
  if (__p)
    operator delete(__p);
}

void sub_18F4700C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F4700E8()
{
  JUMPOUT(0x194001438);
}

float sub_18F4700FC(uint64_t a1, uint64_t a2)
{
  float result;

  *(_DWORD *)(a1 + 8) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 4);
  result = *(float *)(a2 + 8);
  *(float *)(a1 + 16) = result;
  *(_BYTE *)(a1 + 20) = 1;
  return result;
}

void sub_18F470128(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  __int128 *v14;
  __int128 *v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  float v19;
  unint64_t v20;
  unint64_t v21;
  float v22;
  float v23;
  unint64_t v24;
  __int128 v25;
  float v26;
  float v27;
  __int128 v28;
  BOOL v29;
  float v30;
  unint64_t v31;
  unint64_t v32;
  float v33;
  __int128 v34;
  float v35;
  float v36;
  __int128 v37;
  unint64_t v38;
  float v39;
  __int128 v40;
  unint64_t v41;
  BOOL v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  float v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  float v57;
  unint64_t v58;
  __int128 v59;
  uint64_t v60;
  uint64_t v61;
  int64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int64_t v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  float v73;
  unint64_t v74;
  __int128 v75;
  uint64_t v77;
  float v78;
  unint64_t v79;
  float v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  int v84;
  int v85;
  int v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  uint64_t v101;
  int v102;

__int128 *sub_18F4709B0(__int128 *result, __int128 *a2, __int128 *a3)
{
  float v3;
  float v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *(float *)a2;
  v4 = *(float *)a3;
  if (*(float *)a2 >= *(float *)result)
  {
    if (v4 < v3)
    {
      v8 = *((_QWORD *)a2 + 2);
      v9 = *a2;
      v10 = *((_QWORD *)a3 + 2);
      *a2 = *a3;
      *((_QWORD *)a2 + 2) = v10;
      *a3 = v9;
      *((_QWORD *)a3 + 2) = v8;
      if (*(float *)a2 < *(float *)result)
      {
        v11 = *((_QWORD *)result + 2);
        v12 = *result;
        v13 = *((_QWORD *)a2 + 2);
        *result = *a2;
        *((_QWORD *)result + 2) = v13;
        *a2 = v12;
        *((_QWORD *)a2 + 2) = v11;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v14 = *((_QWORD *)result + 2);
      v15 = *result;
      v16 = *((_QWORD *)a2 + 2);
      *result = *a2;
      *((_QWORD *)result + 2) = v16;
      *a2 = v15;
      *((_QWORD *)a2 + 2) = v14;
      if (*(float *)a3 >= *(float *)a2)
        return result;
      v5 = *((_QWORD *)a2 + 2);
      v6 = *a2;
      v17 = *((_QWORD *)a3 + 2);
      *a2 = *a3;
      *((_QWORD *)a2 + 2) = v17;
    }
    else
    {
      v5 = *((_QWORD *)result + 2);
      v6 = *result;
      v7 = *((_QWORD *)a3 + 2);
      *result = *a3;
      *((_QWORD *)result + 2) = v7;
    }
    *a3 = v6;
    *((_QWORD *)a3 + 2) = v5;
  }
  return result;
}

BOOL sub_18F470AA0(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  int v19;

  v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = (__int128 *)(a2 - 24);
      if (*(float *)(a2 - 24) < *(float *)a1)
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = *(_OWORD *)a1;
        v9 = *(_QWORD *)(a2 - 8);
        *(_OWORD *)a1 = *v6;
        *(_QWORD *)(a1 + 16) = v9;
        *v6 = v8;
        *(_QWORD *)(a2 - 8) = v7;
      }
      return result;
    case 3uLL:
      sub_18F4709B0((__int128 *)a1, (__int128 *)(a1 + 24), (__int128 *)(a2 - 24));
      return 1;
    case 4uLL:
      sub_18F470C84(a1, a1 + 24, a1 + 48, a2 - 24);
      return 1;
    case 5uLL:
      sub_18F470D50((__n128 *)a1, (__n128 *)(a1 + 24), (__n128 *)(a1 + 48), (__n128 *)(a1 + 72), (__n128 *)(a2 - 24));
      return 1;
    default:
      v10 = (float *)(a1 + 48);
      sub_18F4709B0((__int128 *)a1, (__int128 *)(a1 + 24), (__int128 *)(a1 + 48));
      v11 = a1 + 72;
      if (a1 + 72 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    v14 = *(float *)v11;
    if (*(float *)v11 < *v10)
    {
      v18 = *(_OWORD *)(v11 + 4);
      v19 = *(_DWORD *)(v11 + 20);
      v15 = v12;
      while (1)
      {
        v16 = a1 + v15;
        *(_OWORD *)(v16 + 72) = *(_OWORD *)(a1 + v15 + 48);
        *(_QWORD *)(v16 + 88) = *(_QWORD *)(a1 + v15 + 64);
        if (v15 == -48)
          break;
        v15 -= 24;
        if (v14 >= *(float *)(v16 + 24))
        {
          v17 = a1 + v15 + 72;
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(float *)v17 = v14;
      *(_OWORD *)(v17 + 4) = v18;
      *(_DWORD *)(v17 + 20) = v19;
      if (++v13 == 8)
        return v11 + 24 == a2;
    }
    v10 = (float *)v11;
    v12 += 24;
    v11 += 24;
    if (v11 == a2)
      return 1;
  }
}

__n128 sub_18F470C84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  sub_18F4709B0((__int128 *)a1, (__int128 *)a2, (__int128 *)a3);
  result.n128_u32[0] = *(_DWORD *)a4;
  if (*(float *)a4 < *(float *)a3)
  {
    v9 = *(_QWORD *)(a3 + 16);
    result = *(__n128 *)a3;
    v10 = *(_QWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_QWORD *)(a3 + 16) = v10;
    *(__n128 *)a4 = result;
    *(_QWORD *)(a4 + 16) = v9;
    result.n128_u32[0] = *(_DWORD *)a3;
    if (*(float *)a3 < *(float *)a2)
    {
      v11 = *(_QWORD *)(a2 + 16);
      result = *(__n128 *)a2;
      v12 = *(_QWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_QWORD *)(a2 + 16) = v12;
      *(__n128 *)a3 = result;
      *(_QWORD *)(a3 + 16) = v11;
      result.n128_u32[0] = *(_DWORD *)a2;
      if (*(float *)a2 < *(float *)a1)
      {
        v13 = *(_QWORD *)(a1 + 16);
        result = *(__n128 *)a1;
        v14 = *(_QWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = v14;
        *(__n128 *)a2 = result;
        *(_QWORD *)(a2 + 16) = v13;
      }
    }
  }
  return result;
}

__n128 sub_18F470D50(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;

  result = sub_18F470C84((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4);
  result.n128_u32[0] = a5->n128_u32[0];
  if (a5->n128_f32[0] < a4->n128_f32[0])
  {
    v11 = a4[1].n128_u64[0];
    result = *a4;
    v12 = a5[1].n128_u64[0];
    *a4 = *a5;
    a4[1].n128_u64[0] = v12;
    *a5 = result;
    a5[1].n128_u64[0] = v11;
    result.n128_u32[0] = a4->n128_u32[0];
    if (a4->n128_f32[0] < a3->n128_f32[0])
    {
      v13 = a3[1].n128_u64[0];
      result = *a3;
      v14 = a4[1].n128_u64[0];
      *a3 = *a4;
      a3[1].n128_u64[0] = v14;
      *a4 = result;
      a4[1].n128_u64[0] = v13;
      result.n128_u32[0] = a3->n128_u32[0];
      if (a3->n128_f32[0] < a2->n128_f32[0])
      {
        v15 = a2[1].n128_u64[0];
        result = *a2;
        v16 = a3[1].n128_u64[0];
        *a2 = *a3;
        a2[1].n128_u64[0] = v16;
        *a3 = result;
        a3[1].n128_u64[0] = v15;
        result.n128_u32[0] = a2->n128_u32[0];
        if (a2->n128_f32[0] < a1->n128_f32[0])
        {
          v17 = a1[1].n128_u64[0];
          result = *a1;
          v18 = a2[1].n128_u64[0];
          *a1 = *a2;
          a1[1].n128_u64[0] = v18;
          *a2 = result;
          a2[1].n128_u64[0] = v17;
        }
      }
    }
  }
  return result;
}

uint64_t sub_18F4710C8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_onDeviceOrientation_(a2, (const char *)a2, a1, a4, a5);
}

void sub_18F471408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F471420(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_initPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = result;
  return result;
}

void sub_18F4714D4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD v4[5];

  v3 = sub_18F204AE4();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = sub_18F473518;
  v4[3] = &unk_1E2955938;
  v4[4] = a2;
  sub_18F1F6514(v3, (uint64_t)v4);
}

void sub_18F4715E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F471600(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), sel_deallocPrivate, a3, a4, a5);
}

void sub_18F4719C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_18F471A44(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v26;
  uint8_t buf[8];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v6 = (void *)objc_msgSend_userInfo(*(void **)(a1 + 32), a2, a3, a4, a5);
  v10 = (void *)objc_msgSend_objectForKey_(v6, v7, (uint64_t)CFSTR("CMSetDeviceOrientationTypeKey"), v8, v9);
  v15 = objc_msgSend_intValue(v10, v11, v12, v13, v14);
  if (v15 >= 7)
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2953DC8);
    v16 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&buf[4] = v15;
      _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_FAULT, "The orientation %{public}d is not in bounds", buf, 8u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2953DC8);
      v26 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMDeviceOrientationManager onNotification:]_block_invoke", "CoreLocation: %s\n", v26);
      if (v26 != (char *)buf)
        free(v26);
    }
  }
  v28 = 0;
  *(_QWORD *)buf = CFAbsoluteTimeGetCurrent();
  LODWORD(v28) = v15;
  v20 = (void *)objc_msgSend_objectForKey_(v6, v17, (uint64_t)CFSTR("CMPersistOrientationCallbackModeKey"), v18, v19);
  if (!v20 || objc_msgSend_BOOLValue(v20, v21, v22, v23, v24))
    objc_msgSend_setDeviceOrientationCallbackModePrivate_(*(void **)(a1 + 40), v21, v15, v23, v24);
  return objc_msgSend_onDeviceOrientation_(*(void **)(a1 + 40), v21, (uint64_t)buf, v23, v24);
}

uint64_t sub_18F471EE8(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a1[4], sel_startDeviceOrientationUpdatesPrivateToQueue_withHandler_, a1[5], a1[6], a5);
}

uint64_t sub_18F472108(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_stopDeviceOrientationUpdatesPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
}

void sub_18F47229C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

id sub_18F4722E0(uint64_t a1)
{
  id result;
  const char *v3;
  uint64_t v4;
  uint64_t v5;

  result = objc_loadWeak((id *)(a1 + 40));
  if (result)
    return (id)objc_msgSend_onDeviceOrientation_(result, v3, *(_QWORD *)(a1 + 32) + 64, v4, v5);
  return result;
}

void sub_18F4724FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_18F472AE8(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

void sub_18F4733A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18F4733D4(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 48))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = *(_QWORD *)(v1 + 40);
    v2 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    if (v2)
      dispatch_retain(v2);
  }
}

os_log_t sub_18F4734EC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Orientation");
  off_1ECEDEE20 = result;
  return result;
}

uint64_t sub_18F473518(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_onMotionPreferencesUpdated(*(void **)(a1 + 32), a2, a3, a4, a5);
}

_QWORD *sub_18F473520(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E2949AD8;
  v2 = a1[10];
  a1[10] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  return sub_18F3DB8A0(a1);
}

void sub_18F473564(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E2949AD8;
  v2 = a1[10];
  a1[10] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  sub_18F3DB8A0(a1);
  JUMPOUT(0x194001438);
}

BOOL sub_18F4735BC(uint64_t a1, int *a2)
{
  _BOOL8 result;
  int v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;

  result = 0;
  v4 = *a2;
  if (*a2 > 18)
  {
    if (v4 <= 66)
    {
      if (v4 == 19)
      {
        v5 = *(_QWORD *)(a1 + 32);
        if (!v5)
          return 0;
      }
      else
      {
        if (v4 != 34)
          return result;
        v5 = *(_QWORD *)(a1 + 48);
        if (!v5)
          return 0;
      }
LABEL_30:
      v7 = *(_QWORD *)(v5 + 56) == 0;
      return !v7;
    }
    if (v4 == 67)
    {
LABEL_19:
      v5 = *(_QWORD *)(a1 + 64);
      if (!v5)
        return 0;
      goto LABEL_30;
    }
    if (v4 != 143)
      return result;
LABEL_16:
    v6 = *(_QWORD *)(a1 + 72);
    if (!v6 || !*(_QWORD *)(v6 + 56))
      return 0;
    v7 = *(_BYTE *)(a1 + 28) == 0;
    return !v7;
  }
  if (v4 <= 6)
  {
    if (v4 == 2)
    {
      if ((sub_18F1F7BFC() & 0x80) != 0)
      {
        v5 = *(_QWORD *)(a1 + 56);
        if (!v5)
          return 0;
      }
      else
      {
        v5 = *(_QWORD *)(a1 + 40);
        if (!v5)
          return 0;
      }
      goto LABEL_30;
    }
    if (v4 != 3)
      return result;
    goto LABEL_19;
  }
  if (v4 == 7)
  {
    v8 = *(_QWORD *)(a1 + 72);
    if (v8 && *(_QWORD *)(v8 + 56))
      return *(_BYTE *)(a1 + 28) == 0;
    return 0;
  }
  if (v4 == 15)
    goto LABEL_16;
  return result;
}

void sub_18F4736FC(_QWORD *a1, int a2, uint64_t a3, int *a4, float32x2_t *a5, float32x4_t a6)
{
  double v9;
  NSObject *v12;
  char *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  float32x2_t v20;
  float32x4_t v21[3];
  int v22;
  __int128 v23;
  uint64_t v24;
  int v25;
  char v26;
  uint64_t v27;
  int v28;
  int v29;
  uint8_t buf[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  int v37;
  uint64_t v38;

  v9 = *(double *)a6.i64;
  v38 = *MEMORY[0x1E0C80C00];
  v21[0] = 0uLL;
  v20 = (float32x2_t)0xBFF0000000000000;
  sub_18F1FFE94(v21, a6);
  v22 = 0;
  memset(&v21[1], 0, 32);
  v23 = xmmword_18F506750;
  v24 = 0x1FF00000000;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  if (a2 <= 18)
  {
    switch(a2)
    {
      case 0:
        if (qword_1ECEDEE78 != -1)
          dispatch_once(&qword_1ECEDEE78, &unk_1E2954EC8);
        v12 = off_1ECEDEE70;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&buf[4] = 0;
          _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_FAULT, "Device motion mode (%{public}d) not supported, unable to get predicted device motion", buf, 8u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE78 != -1)
            dispatch_once(&qword_1ECEDEE78, &unk_1E2954EC8);
          v28 = 67240192;
          v29 = 0;
          v13 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "void CLDeviceMotion::getPredictedSample(const CLMotionTypeDeviceMotionMode, const CFTimeInterval, CLDeviceMotion::Sample &, CMError &, CFTimeInterval &)", "CoreLocation: %s\n", v13);
          if (v13 != (char *)buf)
            free(v13);
        }
        goto LABEL_25;
      case 1:
      case 4:
      case 5:
      case 6:
        goto LABEL_25;
      case 2:
        if ((sub_18F1F7BFC() & 0x80) != 0)
        {
          v14 = a1[7];
          if (v14)
            goto LABEL_24;
        }
        else
        {
          v14 = a1[5];
          if (v14)
            goto LABEL_24;
        }
        break;
      case 3:
        goto LABEL_20;
      case 7:
        goto LABEL_23;
      default:
        if (a2 == 15)
          goto LABEL_23;
        goto LABEL_25;
    }
    goto LABEL_25;
  }
  if (a2 <= 66)
  {
    if (a2 == 19)
    {
      v14 = a1[4];
      if (!v14)
        goto LABEL_25;
    }
    else
    {
      if (a2 != 34)
        goto LABEL_25;
      v14 = a1[6];
      if (!v14)
        goto LABEL_25;
    }
LABEL_24:
    (*(void (**)(uint64_t, float32x2_t *))(*(_QWORD *)v14 + 32))(v14, &v20);
    *a5 = v20;
    sub_18F426F6C((uint64_t)&v20, a4, v9);
    goto LABEL_25;
  }
  if (a2 == 67)
  {
LABEL_20:
    v14 = a1[8];
    if (!v14)
      goto LABEL_25;
    goto LABEL_24;
  }
  if (a2 != 143)
    goto LABEL_25;
LABEL_23:
  v14 = a1[9];
  if (v14)
    goto LABEL_24;
LABEL_25:
  sub_18F2008FC((uint64_t)buf, &v20);
  v15 = v35;
  v16 = v36;
  v17 = v33;
  *(_OWORD *)(a3 + 64) = v34;
  *(_OWORD *)(a3 + 80) = v15;
  *(_OWORD *)(a3 + 96) = v16;
  v18 = v31;
  v19 = v32;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_OWORD *)(a3 + 16) = v18;
  *(_DWORD *)(a3 + 112) = v37;
  *(_OWORD *)(a3 + 32) = v19;
  *(_OWORD *)(a3 + 48) = v17;
}

void sub_18F473A38(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint8_t buf[4];
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!*a2)
  {
    *(_QWORD *)(a4 + 96) = *(_QWORD *)(a3 + 40);
    *(_QWORD *)(a4 + 88) = *(_QWORD *)(a3 + 56);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2954EC8);
    v5 = off_1ECEDEE70;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_INFO))
    {
      v7 = *(_QWORD *)(a4 + 88);
      v6 = *(_QWORD *)(a4 + 96);
      *(_DWORD *)buf = 134218240;
      v10 = v6;
      v11 = 2048;
      v12 = v7;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "Received geomagnetic model, declination,%f,timestamp,%f", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE78 != -1)
        dispatch_once(&qword_1ECEDEE78, &unk_1E2954EC8);
      v8 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLDeviceMotion::onGeomagneticModelNotification(int, const CLGeomagneticModelProvider_Type::Notification &, const CLGeomagneticModelProvider_Type::NotificationData &, void *)", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf)
        free(v8);
    }
  }
}

uint64_t sub_18F473C18(uint64_t a1)
{
  uint64_t v2;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  uint8_t buf[4];
  int v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = sub_18F1EE054(a1, 0);
  *(_WORD *)(v2 + 200) = 263;
  *(_BYTE *)(v2 + 202) = 0;
  *(_QWORD *)(v2 + 208) = 0;
  *(_QWORD *)(v2 + 216) = 0;
  *(_QWORD *)v2 = &off_1E294B3C8;
  if ((sub_18F1F7BFC() & 0x80) == 0)
  {
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2954EC8);
    v4 = off_1ECEDEE70;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v8 = 0;
      v9 = 2082;
      v10 = "";
      v11 = 2082;
      v12 = "assert";
      v13 = 2081;
      v14 = "CLPlatformInfo::motionCaps().deviceMotion3Service";
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Device motion service 3 is not supported on this platform!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE78 != -1)
        dispatch_once(&qword_1ECEDEE78, &unk_1E2954EC8);
    }
    v5 = off_1ECEDEE70;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE70))
    {
      *(_DWORD *)buf = 68289539;
      v8 = 0;
      v9 = 2082;
      v10 = "";
      v11 = 2082;
      v12 = "assert";
      v13 = 2081;
      v14 = "CLPlatformInfo::motionCaps().deviceMotion3Service";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Device motion service 3 is not supported on this platform!", "{\"msg%{public}.0s\":\"Device motion service 3 is not supported on this platform!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE78 != -1)
        dispatch_once(&qword_1ECEDEE78, &unk_1E2954EC8);
    }
    v6 = off_1ECEDEE70;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v8 = 0;
      v9 = 2082;
      v10 = "";
      v11 = 2082;
      v12 = "assert";
      v13 = 2081;
      v14 = "CLPlatformInfo::motionCaps().deviceMotion3Service";
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Device motion service 3 is not supported on this platform!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
    __break(1u);
  }
  return a1;
}

void sub_18F473ED0(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_18F3C67EC(v1);
  _Unwind_Resume(a1);
}

void sub_18F473EEC(_QWORD *a1)
{
  sub_18F3C67EC(a1);
  JUMPOUT(0x194001438);
}

void sub_18F473F14(_QWORD *a1)
{
  sub_18F3C67EC(a1);
  JUMPOUT(0x194001438);
}

void sub_18F473F3C(_QWORD *a1)
{
  sub_18F3C67EC(a1);
  JUMPOUT(0x194001438);
}

uint64_t *sub_18F473F60(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  FILE *v6;
  size_t v7;

  v2 = *a1;
  v3 = *a1 + 40;
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
  v6 = *(FILE **)(v2 + 2208);
  if (v6)
  {
    v7 = *(int *)(v2 + 2200);
    if ((_DWORD)v7)
      fwrite((const void *)(v2 + 152), 1uLL, v7, v6);
    *(_DWORD *)(v2 + 2200) = 0;
    sub_18F474904(v2, v4, v7, (uint64_t)v6, v5);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  return a1;
}

void sub_18F473FF0(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_18F346934((uint64_t)va);
  sub_18F213574(a1);
}

uint64_t sub_18F47400C()
{
  if (qword_1ECEDFBB8 != -1)
    dispatch_once(&qword_1ECEDFBB8, &unk_1E2953E08);
  return qword_1ECEDFBA0;
}

void sub_18F47404C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  void **v7;
  BOOL v8;
  BOOL v9;
  unint64_t *v10;
  unint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  int v16;
  const std::string::value_type *v17;
  std::string::size_type v18;
  std::string *v19;
  std::string::size_type v20;
  char v21;
  void **v22;
  NSObject *v23;
  void *v24;
  const char *v25;
  uid_t v26;
  gid_t v27;
  NSObject *v28;
  NSObject *global_queue;
  NSObject *v30;
  unsigned __int8 v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  _BYTE v36[15];
  stat buf[11];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D3E0 != -1)
    dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
  v0 = qword_1EE16D3D0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D3D0, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf[0].st_dev) = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_DEBUG, "creating the BinaryLog instance", (uint8_t *)buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D3E0 != -1)
      dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
    v32 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "static void CLBinaryLog::create()", "CoreLocation: %s\n", v32);
    if (v32 != (char *)buf)
      free(v32);
  }
  v1 = operator new();
  sub_18F1E5748((char *)v1);
  *(_QWORD *)v1 = &off_1E2949690;
  *(_DWORD *)(v1 + 2200) = 0;
  *(_BYTE *)(v1 + 2232) = 0;
  *(_OWORD *)(v1 + 2208) = 0u;
  MEMORY[0x1940012AC](v1 + 104, ".bin");
  v2 = sub_18F204AE4();
  v3 = *(_QWORD *)(v2 + 24);
  v4 = *(std::__shared_weak_count **)(v2 + 32);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = (void **)(v1 + 56);
  v8 = sub_18F36A044(v3, "BinaryLogDirectory", v1 + 56);
  v9 = v8;
  if (!v4)
    goto LABEL_13;
  v10 = (unint64_t *)&v4->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    if (v9)
      goto LABEL_19;
  }
  else
  {
LABEL_13:
    if (v8)
      goto LABEL_19;
  }
  if (qword_1EE16D3E0 != -1)
    dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
  v12 = qword_1EE16D3D0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D3D0, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf[0].st_dev) = 0;
    _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_ERROR, "kCLBinaryLogDirectory not set!", (uint8_t *)buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D3E0 != -1)
      dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
    v35 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "CLBinaryLog::CLBinaryLog()", "CoreLocation: %s\n", v35);
    if (v35 != (char *)buf)
      free(v35);
  }
LABEL_19:
  if (*(char *)(v1 + 79) < 0)
  {
    v13 = *(_QWORD *)(v1 + 64);
    if (!v13)
      goto LABEL_29;
  }
  else
  {
    v13 = *(unsigned __int8 *)(v1 + 79);
    if (!*(_BYTE *)(v1 + 79))
      goto LABEL_29;
  }
  v14 = v13 - 1;
  v15 = (_BYTE *)(v1 + 56);
  if ((*(_BYTE *)(v1 + 79) & 0x80) != 0)
    v15 = *v7;
  if (v15[v14] != 47)
  {
    sub_18F2AA110((const void **)(v1 + 56), 47, (uint64_t)buf);
    if (*(char *)(v1 + 79) < 0)
      operator delete(*v7);
    *(_OWORD *)v7 = *(_OWORD *)&buf[0].st_dev;
    *(_QWORD *)(v1 + 72) = *(_QWORD *)&buf[0].st_uid;
  }
LABEL_29:
  MEMORY[0x1940012AC](v1 + 80, "CoreMotionSensors");
  sub_18F3753CC((const void **)(v1 + 56), (const void **)(v1 + 80), (uint64_t)buf);
  v16 = *(char *)(v1 + 127);
  if (v16 >= 0)
    v17 = (const std::string::value_type *)(v1 + 104);
  else
    v17 = *(const std::string::value_type **)(v1 + 104);
  if (v16 >= 0)
    v18 = *(unsigned __int8 *)(v1 + 127);
  else
    v18 = *(_QWORD *)(v1 + 112);
  v19 = std::string::append((std::string *)buf, v17, v18);
  v20 = v19->__r_.__value_.__r.__words[0];
  *(_QWORD *)v36 = v19->__r_.__value_.__l.__size_;
  *(_QWORD *)&v36[7] = *(std::string::size_type *)((char *)&v19->__r_.__value_.__r.__words[1] + 7);
  v21 = HIBYTE(v19->__r_.__value_.__r.__words[2]);
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  v22 = (void **)(v1 + 128);
  if (*(char *)(v1 + 151) < 0)
    operator delete(*v22);
  *(_QWORD *)(v1 + 128) = v20;
  *(_QWORD *)(v1 + 136) = *(_QWORD *)v36;
  *(_QWORD *)(v1 + 143) = *(_QWORD *)&v36[7];
  *(_BYTE *)(v1 + 151) = v21;
  if (SHIBYTE(buf[0].st_gid) < 0)
    operator delete(*(void **)&buf[0].st_dev);
  if (qword_1EE16D3E0 != -1)
    dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
  v23 = qword_1EE16D3D0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D3D0, OS_LOG_TYPE_DEFAULT))
  {
    v24 = (void *)(v1 + 128);
    if (*(char *)(v1 + 151) < 0)
      v24 = *v22;
    buf[0].st_dev = 136446210;
    *(_QWORD *)&buf[0].st_mode = v24;
    _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_DEFAULT, "#Notice Logging binary sensor data to %{public}s", (uint8_t *)buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D3E0 != -1)
      dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
    v33 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLBinaryLog::CLBinaryLog()", "CoreLocation: %s\n", v33);
    if (v33 != (char *)buf)
      free(v33);
  }
  v25 = (const char *)(v1 + 56);
  if (*(char *)(v1 + 79) < 0)
    v25 = (const char *)*v7;
  if (stat(v25, buf))
  {
    if (*(char *)(v1 + 79) < 0)
      v7 = (void **)*v7;
    v26 = getuid();
    v27 = getgid();
    sub_18F3605AC(v7, v26, v27);
  }
  v28 = dispatch_queue_create("com.apple.locationd.binlog.compression", 0);
  *(_QWORD *)(v1 + 2224) = v28;
  global_queue = dispatch_get_global_queue(-32768, 0);
  dispatch_set_target_queue(v28, global_queue);
  qword_1ECEDFBA0 = v1;
  if (qword_1EE16D3E0 != -1)
    dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
  v30 = qword_1EE16D3D0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D3D0, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf[0].st_dev) = 0;
    _os_log_impl(&dword_18F1DC000, v30, OS_LOG_TYPE_DEBUG, "creating fInstance = new CLBinaryLog()", (uint8_t *)buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D3E0 != -1)
      dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
    v34 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "static void CLBinaryLog::create()", "CoreLocation: %s\n", v34);
    if (v34 != (char *)buf)
      free(v34);
  }
  v31 = atomic_load((unsigned __int8 *)&qword_1ECEDFBB0);
  if ((v31 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1ECEDFBB0))
    {
      qword_1ECEDFBA8 = qword_1ECEDFBA0;
      __cxa_atexit((void (*)(void *))sub_18F473F60, &qword_1ECEDFBA8, &dword_18F1DC000);
      __cxa_guard_release(&qword_1ECEDFBB0);
    }
  }
}

void sub_18F474834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  _QWORD *v18;

  sub_18F494CAC(v18);
  MEMORY[0x194001438](v18, 0x10B3C40F30FBFA2);
  _Unwind_Resume(a1);
}

void sub_18F4748E0(_QWORD *a1)
{
  sub_18F494CAC(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F474904(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _opaque_pthread_t *v6;
  uint64_t result;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  uint8_t buf[4];
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  objc_msgSend_assertInside(*(void **)(*(_QWORD *)(a1 + 48) + 64), a2, a3, a4, a5);
  v6 = *(_opaque_pthread_t **)(*(_QWORD *)(a1 + 48) + 80);
  if (v6 != pthread_self())
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E29451A8);
    v8 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2082;
      v16 = "assert";
      v17 = 2081;
      v18 = "(fMutex).__assertOwned()";
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E29451A8);
    }
    v9 = off_1ECEDEE80;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE80))
    {
      *(_DWORD *)buf = 68289539;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2082;
      v16 = "assert";
      v17 = 2081;
      v18 = "(fMutex).__assertOwned()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CSI assertion failed", "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E29451A8);
    }
    v10 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2082;
      v16 = "assert";
      v17 = 2081;
      v18 = "(fMutex).__assertOwned()";
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  result = fclose(*(FILE **)(a1 + 2208));
  *(_QWORD *)(a1 + 2208) = 0;
  return result;
}

uint64_t sub_18F474B8C(uint64_t a1)
{
  uint64_t v2;
  FILE **v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  int *v11;
  char *v12;
  uint64_t v13;
  uint64_t v15;
  size_t v16;
  __int128 *v17;
  const void *v18;
  size_t size;
  void **v20;
  std::string *v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  stat *v28;
  __int128 *v29;
  stat *v30;
  uid_t v31;
  gid_t v32;
  std::error_code *v33;
  const std::__fs::filesystem::path **v34;
  const std::__fs::filesystem::path *v35;
  const std::__fs::filesystem::path *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  NSObject *v42;
  const std::__fs::filesystem::path *v43;
  int v44;
  std::string::size_type v45;
  int *v46;
  std::string *v47;
  dev_t v48;
  int v49;
  NSObject *v50;
  int v52;
  int *v53;
  char *v54;
  char *v55;
  int v56;
  std::string::size_type v57;
  int *v58;
  std::string *v59;
  int v60;
  char *v61;
  _QWORD block[5];
  std::string v63;
  __int128 v64;
  uint64_t v65;
  __int128 __p;
  uint64_t v67;
  int v68;
  void *v69[2];
  uint64_t v70;
  std::string v71;
  __int128 v72;
  uint64_t v73;
  uint64_t v74;
  __int16 v75;
  int v76;
  _BYTE v77[18];
  __int16 v78;
  int v79;
  stat buf[11];
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v3 = (FILE **)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 40);
  v74 = a1 + 40;
  (*(void (**)(uint64_t))(v2 + 16))(a1 + 40);
  v75 = 256;
  v4 = MEMORY[0x194001948](v3[271]);
  if (ferror(v3[271]))
  {
    if (qword_1EE16D3E0 != -1)
      dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
    v9 = qword_1EE16D3D0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D0, OS_LOG_TYPE_FAULT))
    {
      v10 = *__error();
      v11 = __error();
      v12 = strerror(*v11);
      buf[0].st_dev = 67240450;
      *(_DWORD *)&buf[0].st_mode = v10;
      LOWORD(buf[0].st_ino) = 2082;
      *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 2) = (__darwin_ino64_t)v12;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_FAULT, "Failed to determine if log rotation is needed. errno, %{public}d, %{public}s", (uint8_t *)buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E0 != -1)
        dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
      v52 = *__error();
      v53 = __error();
      v54 = strerror(*v53);
      v76 = 67240450;
      *(_DWORD *)v77 = v52;
      *(_WORD *)&v77[4] = 2082;
      *(_QWORD *)&v77[6] = v54;
      v55 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLBinaryLog::rotateIfNeeded(const double &)", "CoreLocation: %s\n", v55);
      if (v55 != (char *)buf)
        free(v55);
    }
    clearerr(*(FILE **)(a1 + 2208));
  }
  else
  {
    v13 = *(unsigned int *)(a1 + 12);
    if ((int)v13 >= 1 && v4 > v13)
    {
      v15 = sub_18F495604(a1, v5, v6, v7, v8);
      if (*(char *)(a1 + 79) >= 0)
        v16 = *(unsigned __int8 *)(a1 + 79);
      else
        v16 = *(_QWORD *)(a1 + 64);
      v17 = &v72;
      sub_18F2B6B4C((uint64_t)&v72, v16 + 4);
      if (v73 < 0)
        v17 = (__int128 *)v72;
      if (v16)
      {
        if (*(char *)(a1 + 79) >= 0)
          v18 = (const void *)(a1 + 56);
        else
          v18 = *(const void **)(a1 + 56);
        memmove(v17, v18, v16);
      }
      strcpy((char *)v17 + v16, "logs");
      sub_18F4951D4((const void **)&v72, a1 + 80, a1 + 104, v15, &v71);
      if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v71.__r_.__value_.__r.__words[2]);
      else
        size = v71.__r_.__value_.__l.__size_;
      v20 = v69;
      sub_18F2B6B4C((uint64_t)v69, size + 4);
      if (v70 < 0)
        v20 = (void **)v69[0];
      if (size)
      {
        if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v21 = &v71;
        else
          v21 = (std::string *)v71.__r_.__value_.__r.__words[0];
        memmove(v20, v21, size);
      }
      strcpy((char *)v20 + size, ".bz2");
      if (v73 >= 0)
        v22 = (const char *)&v72;
      else
        v22 = (const char *)v72;
      if (stat(v22, buf))
      {
        if (v73 >= 0)
          v27 = HIBYTE(v73);
        else
          v27 = *((_QWORD *)&v72 + 1);
        v28 = buf;
        sub_18F2B6B4C((uint64_t)buf, v27 + 1);
        if ((buf[0].st_gid & 0x80000000) != 0)
          v28 = *(stat **)&buf[0].st_dev;
        if (v27)
        {
          if (v73 >= 0)
            v29 = &v72;
          else
            v29 = (__int128 *)v72;
          memmove(v28, v29, v27);
        }
        *(_WORD *)((char *)&v28->st_dev + v27) = 47;
        if ((buf[0].st_gid & 0x80000000) == 0)
          v30 = buf;
        else
          v30 = *(stat **)&buf[0].st_dev;
        v31 = getuid();
        v32 = getgid();
        sub_18F3605AC(v30, v31, v32);
        if (SHIBYTE(buf[0].st_gid) < 0)
          operator delete(*(void **)&buf[0].st_dev);
      }
      sub_18F474904(a1, v23, v24, v25, v26);
      v34 = (const std::__fs::filesystem::path **)(a1 + 128);
      v35 = (const std::__fs::filesystem::path *)(a1 + 128);
      if (*(char *)(a1 + 151) < 0)
        v35 = *v34;
      if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v36 = (const std::__fs::filesystem::path *)&v71;
      else
        v36 = (const std::__fs::filesystem::path *)v71.__r_.__value_.__r.__words[0];
      rename(v35, v36, v33);
      if (v41)
      {
        if (qword_1EE16D3E0 != -1)
          dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
        v42 = qword_1EE16D3D0;
        if (os_log_type_enabled((os_log_t)qword_1EE16D3D0, OS_LOG_TYPE_DEFAULT))
        {
          v43 = (const std::__fs::filesystem::path *)(a1 + 128);
          if (*(char *)(a1 + 151) < 0)
            v43 = *v34;
          v44 = SHIBYTE(v71.__r_.__value_.__r.__words[2]);
          v45 = v71.__r_.__value_.__r.__words[0];
          v46 = __error();
          v47 = &v71;
          v48 = *v46;
          if (v44 < 0)
            v47 = (std::string *)v45;
          buf[0].st_dev = 136315650;
          *(_QWORD *)&buf[0].st_mode = v43;
          WORD2(buf[0].st_ino) = 2080;
          *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = (__darwin_ino64_t)v47;
          HIWORD(buf[0].st_gid) = 1024;
          buf[0].st_rdev = v48;
          _os_log_impl(&dword_18F1DC000, v42, OS_LOG_TYPE_DEFAULT, "#Warning Failed to move aside log file %s to %s (%d)", (uint8_t *)buf, 0x1Cu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D3E0 != -1)
            dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
          if (*(char *)(a1 + 151) < 0)
            v34 = (const std::__fs::filesystem::path **)*v34;
          v56 = SHIBYTE(v71.__r_.__value_.__r.__words[2]);
          v57 = v71.__r_.__value_.__r.__words[0];
          v58 = __error();
          v59 = &v71;
          v60 = *v58;
          if (v56 < 0)
            v59 = (std::string *)v57;
          v76 = 136315650;
          *(_QWORD *)v77 = v34;
          *(_WORD *)&v77[8] = 2080;
          *(_QWORD *)&v77[10] = v59;
          v78 = 1024;
          v79 = v60;
          v61 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLBinaryLog::rotateIfNeeded(const double &)", "CoreLocation: %s\n", v61);
          if (v61 != (char *)buf)
            free(v61);
        }
      }
      sub_18F4753D4((char *)a1, v37, v38, v39, v40);
      *(_QWORD *)(a1 + 2216) = 0;
      v49 = *(_DWORD *)(a1 + 16);
      v50 = *(NSObject **)(a1 + 2224);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3321888768;
      block[2] = sub_18F47580C;
      block[3] = &unk_1E2952AB0;
      block[4] = a1;
      v68 = v49;
      if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0)
        sub_18F26F9A4(&v63, v71.__r_.__value_.__l.__data_, v71.__r_.__value_.__l.__size_);
      else
        v63 = v71;
      if (SHIBYTE(v70) < 0)
      {
        sub_18F26F9A4(&v64, v69[0], (unint64_t)v69[1]);
      }
      else
      {
        v64 = *(_OWORD *)v69;
        v65 = v70;
      }
      if (SHIBYTE(v73) < 0)
      {
        sub_18F26F9A4(&__p, (void *)v72, *((unint64_t *)&v72 + 1));
      }
      else
      {
        __p = v72;
        v67 = v73;
      }
      dispatch_async(v50, block);
      if (SHIBYTE(v67) < 0)
        operator delete((void *)__p);
      if (SHIBYTE(v65) < 0)
        operator delete((void *)v64);
      if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v63.__r_.__value_.__l.__data_);
      if (SHIBYTE(v70) < 0)
        operator delete(v69[0]);
      if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v71.__r_.__value_.__l.__data_);
      if (SHIBYTE(v73) < 0)
        operator delete((void *)v72);
    }
  }
  return ((uint64_t (*)(FILE **))(*v3)->_bf._base)(v3);
}

void sub_18F4752FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a38 < 0)
    operator delete(__p);
  if (a44 < 0)
    operator delete(a39);
  if (a50 < 0)
    operator delete(a45);
  sub_18F346934((uint64_t)&a51);
  _Unwind_Resume(a1);
}

void sub_18F4753C4(void *a1, int a2)
{
  if (a2)
    sub_18F213574(a1);
  JUMPOUT(0x18F4753BCLL);
}

void sub_18F4753D4(char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void **p_vtable;
  char *v6;
  _opaque_pthread_t *v7;
  const char **v8;
  const char *v9;
  FILE *v10;
  NSObject *v11;
  void *v12;
  NSObject *v13;
  NSObject *v14;
  char *v15;
  uint8_t buf[4];
  _BYTE v17[14];
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v6 = a1;
  v22 = *MEMORY[0x1E0C80C00];
  objc_msgSend_assertInside(*(void **)(*((_QWORD *)a1 + 6) + 64), a2, a3, a4, a5);
  v7 = *(_opaque_pthread_t **)(*((_QWORD *)v6 + 6) + 80);
  if (v7 != pthread_self())
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E29451A8);
    v8 = (const char **)CMVO2MaxRetrocomputeState;
    v13 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v17 = 0;
      *(_WORD *)&v17[4] = 2082;
      *(_QWORD *)&v17[6] = "";
      v18 = 2082;
      v19 = "assert";
      v20 = 2081;
      v21 = "(fMutex).__assertOwned()";
      _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E29451A8);
    }
    v14 = off_1ECEDEE80;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE80))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v17 = 0;
      *(_WORD *)&v17[4] = 2082;
      *(_QWORD *)&v17[6] = "";
      v18 = 2082;
      v19 = "assert";
      v20 = 2081;
      v21 = "(fMutex).__assertOwned()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CSI assertion failed", "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E29451A8);
    }
    v6 = (char *)off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v17 = 0;
      *(_WORD *)&v17[4] = 2082;
      *(_QWORD *)&v17[6] = "";
      v18 = 2082;
      v19 = "assert";
      v20 = 2081;
      v21 = "(fMutex).__assertOwned()";
      _os_log_impl(&dword_18F1DC000, (os_log_t)v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CSI assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
    goto LABEL_23;
  }
  v8 = (const char **)(v6 + 128);
  v9 = v6 + 128;
  if (v6[151] < 0)
    v9 = *v8;
  v10 = fopen(v9, "ab");
  *((_QWORD *)v6 + 276) = v10;
  if (!v10)
  {
    p_vtable = &OBJC_METACLASS___CMCardioFitnessSummary.vtable;
    if (qword_1EE16D3E0 == -1)
    {
LABEL_6:
      v11 = qword_1EE16D3D0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D3D0, OS_LOG_TYPE_DEFAULT))
      {
        v12 = v8;
        if (v6[151] < 0)
          v12 = (void *)*v8;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v17 = v12;
        _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_DEFAULT, "#Warning Unable to open %s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (p_vtable[124] != (void *)-1)
          dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
        v15 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLBinaryLog::open()", "CoreLocation: %s\n", v15);
        if (v15 != (char *)buf)
          free(v15);
      }
      return;
    }
LABEL_23:
    dispatch_once(&qword_1EE16D3E0, &unk_1E2954D68);
    goto LABEL_6;
  }
}

void sub_18F47580C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  const char *v7;
  const char *v8;
  const char *v9;
  int v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, std::string::value_type *);
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  void *__p[2];
  uint64_t v19;
  int v20;
  _QWORD v21[3];
  int v22;

  v6 = *(_QWORD *)(a1 + 32);
  if (!*(_DWORD *)(a1 + 112))
    goto LABEL_7;
  v7 = (const char *)(a1 + 40);
  if (*(char *)(a1 + 63) < 0)
    v7 = *(const char **)v7;
  v8 = (const char *)(a1 + 64);
  if (*(char *)(a1 + 87) < 0)
    v8 = *(const char **)v8;
  if (sub_18F360D08(v7, v8, a3, a4, a5))
  {
LABEL_7:
    v9 = (const char *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0)
      v9 = *(const char **)v9;
    unlink(v9);
  }
  v10 = *(_DWORD *)(a1 + 112);
  if (v10 >= 1)
  {
    v21[0] = 0;
    v21[1] = v21;
    v21[2] = 0x2020000000;
    v22 = 0;
    if (*(char *)(a1 + 111) < 0)
    {
      v12 = MEMORY[0x1E0C809B0];
      v13 = 3321888768;
      v14 = sub_18F4759A0;
      v15 = &unk_1E2952B88;
      v17 = v6;
      v11 = *(void **)(a1 + 88);
      sub_18F26F9A4(__p, v11, *(_QWORD *)(a1 + 96));
      v10 = *(_DWORD *)(a1 + 112);
    }
    else
    {
      v11 = (void *)(a1 + 88);
      v12 = MEMORY[0x1E0C809B0];
      v13 = 3321888768;
      v14 = sub_18F4759A0;
      v15 = &unk_1E2952B88;
      v17 = v6;
      *(_OWORD *)__p = *(_OWORD *)(a1 + 88);
      v19 = *(_QWORD *)(a1 + 104);
    }
    v16 = v21;
    v20 = v10;
    sub_18F404218((uint64_t)v11, (uint64_t)&v12);
    if (SHIBYTE(v19) < 0)
      operator delete(__p[0]);
    _Block_object_dispose(v21, 8);
  }
}

void sub_18F475970(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  _Block_object_dispose((const void *)(v20 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4759A0(uint64_t a1, std::string::value_type *a2)
{
  uint64_t v4;
  size_t v5;
  std::string *v6;
  const void *v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  int v11;
  std::string *v12;
  const char *v13;
  void *__p[2];
  char v16;
  std::string v17;
  std::string v18;
  void *v19[2];
  char v20;
  std::string __dst;
  std::string v22;
  std::string v23;
  __int128 v24;
  int64_t v25;

  v4 = *(_QWORD *)(a1 + 40);
  if (*(char *)(a1 + 71) >= 0)
    v5 = *(unsigned __int8 *)(a1 + 71);
  else
    v5 = *(_QWORD *)(a1 + 56);
  v6 = &v23;
  sub_18F2B6B4C((uint64_t)&v23, v5 + 1);
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v6 = (std::string *)v23.__r_.__value_.__r.__words[0];
  if (v5)
  {
    if (*(char *)(a1 + 71) >= 0)
      v7 = (const void *)(a1 + 48);
    else
      v7 = *(const void **)(a1 + 48);
    memmove(v6, v7, v5);
  }
  *(_WORD *)((char *)&v6->__r_.__value_.__l.__data_ + v5) = 47;
  v8 = std::string::append(&v23, a2);
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v25 = v8->__r_.__value_.__r.__words[2];
  v24 = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  sub_18F270374(&v23, a2);
  if (*(char *)(v4 + 103) < 0)
    sub_18F26F9A4(&__dst, *(void **)(v4 + 80), *(_QWORD *)(v4 + 88));
  else
    __dst = *(std::string *)(v4 + 80);
  v10 = std::string::append(&__dst, "_");
  v22 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (sub_18F495610(v4, &v23.__r_.__value_.__l.__data_, (char *)&v22))
  {
    sub_18F270374(v19, a2);
    if (*(char *)(v4 + 127) < 0)
      sub_18F26F9A4(&v17, *(void **)(v4 + 104), *(_QWORD *)(v4 + 112));
    else
      v17 = *(std::string *)(v4 + 104);
    v12 = std::string::append(&v17, ".bz2");
    v18 = *v12;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    if ((sub_18F4956E4(v4, v19, (char *)&v18) & 1) != 0)
    {
      v11 = 1;
    }
    else
    {
      sub_18F270374(__p, a2);
      v11 = sub_18F4956E4(v4, __p, (char *)(v4 + 104));
      if (v16 < 0)
        operator delete(__p[0]);
    }
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v18.__r_.__value_.__l.__data_);
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v17.__r_.__value_.__l.__data_);
    if (v20 < 0)
      operator delete(v19[0]);
  }
  else
  {
    v11 = 0;
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v23.__r_.__value_.__l.__data_);
    if (!v11)
      goto LABEL_45;
  }
  else if (!v11)
  {
    goto LABEL_45;
  }
  if (++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) > *(_DWORD *)(a1 + 72))
  {
    v13 = v25 >= 0 ? (const char *)&v24 : (const char *)v24;
    if (unlink(v13))
      syslog(5, "%s,%s,Failed to delete log: %s", "NOTICE", "CLLog", v13);
  }
LABEL_45:
  if (SHIBYTE(v25) < 0)
    operator delete((void *)v24);
  return 1;
}

void sub_18F475C94(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  uint64_t v39;

  if (*(char *)(v39 - 57) < 0)
    operator delete(*(void **)(v39 - 80));
  _Unwind_Resume(exception_object);
}

_QWORD *sub_18F475D58(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  __int128 v3;

  result = (_QWORD *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0)
    return sub_18F26F9A4(result, *(void **)(a2 + 48), *(_QWORD *)(a2 + 56));
  v3 = *(_OWORD *)(a2 + 48);
  result[2] = *(_QWORD *)(a2 + 64);
  *(_OWORD *)result = v3;
  return result;
}

void sub_18F475D88(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
}

uint64_t sub_18F475D9C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v14;
  uint64_t v15;
  __int16 v16;

  v5 = (_BYTE *)(a1 + 40);
  v4 = *(_QWORD *)(a1 + 40);
  v15 = a1 + 40;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 40);
  v16 = 256;
  if (v5[2192])
  {
    if (*(_QWORD *)(a1 + 2208) || (sub_18F4753D4((char *)a1, v6, v7, v8, v9), *(_QWORD *)(a1 + 2208)))
    {
      v14 = 0;
      v10 = *(_DWORD *)(a1 + 2200);
      v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
      v12 = *(_DWORD *)(a1 + 2200);
      if (v11 + v10 >= 2048)
      {
        fwrite((const void *)(a1 + 152), 1uLL, v12, *(FILE **)(a1 + 2208));
        sub_18F474B8C(a1);
        v12 = 0;
        *(_DWORD *)(a1 + 2200) = 0;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, int *))(*(_QWORD *)a2 + 16))(a2, a1 + v12 + 152, 2048, &v14))
      {
        *(_DWORD *)(a1 + 2200) += v14;
      }
    }
  }
  return (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v5 + 24))(v5);
}

void sub_18F475E9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_18F346934((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_18F475EBC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  objc_msgSend_assertInside(*(void **)(*(_QWORD *)(a1 + 48) + 64), a2, a3, a4, a5);
  pthread_self();
  sub_18F1E4DFC(*(_QWORD *)(a1 + 24), "LogFileRotationSizeBinary", (_DWORD *)(a1 + 12));
  return sub_18F1E4DFC(*(_QWORD *)(a1 + 24), "LogFileStorageCountBinary", (_DWORD *)(a1 + 16));
}

uint64_t sub_18F475F14(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  FILE *v11;
  size_t v12;
  const char *v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  std::error_code *v19;
  const std::__fs::filesystem::path *v20;
  stat *v21;
  int v22;
  int st_gid_high;
  stat *v24;
  int *v25;
  stat *v26;
  size_t v27;
  void **v28;
  const void *v29;
  void **v30;
  void **v31;
  _QWORD v33[5];
  void *__p[2];
  uint64_t v35;
  void *v36[2];
  uint64_t v37;
  uint64_t v38;
  __int16 v39;
  stat v40;

  v3 = a1 + 40;
  v2 = *(_QWORD *)(a1 + 40);
  v38 = a1 + 40;
  (*(void (**)(uint64_t))(v2 + 16))(a1 + 40);
  v39 = 256;
  v10 = sub_18F495604(a1, v4, v5, v6, v7);
  v11 = *(FILE **)(a1 + 2208);
  if (v11)
  {
    v12 = *(unsigned int *)(a1 + 2200);
    if ((int)v12 >= 1)
    {
      if (!fwrite((const void *)(a1 + 152), 1uLL, v12, v11))
        syslog(5, "%s,%s,Failed to write CLBinaryLog Buffer to disk\n", "NOTICE", "CLLog");
      *(_DWORD *)(a1 + 2200) = 0;
    }
    sub_18F474904(a1, v8, v12, (uint64_t)v11, v9);
  }
  v13 = (const char *)(a1 + 128);
  v14 = (const char *)(a1 + 128);
  if (*(char *)(a1 + 151) < 0)
    v14 = *(const char **)v13;
  if (!stat(v14, &v40))
  {
    sub_18F495468(a1, a1 + 80, v10, (std::string *)&v40);
    v20 = (const std::__fs::filesystem::path *)(a1 + 128);
    if (*(char *)(a1 + 151) < 0)
      v20 = *(const std::__fs::filesystem::path **)v13;
    if ((v40.st_gid & 0x80000000) == 0)
      v21 = &v40;
    else
      v21 = *(stat **)&v40.st_dev;
    rename(v20, (const std::__fs::filesystem::path *)v21, v19);
    if (v22)
    {
      if (*(char *)(a1 + 151) < 0)
        v13 = *(const char **)v13;
      st_gid_high = SHIBYTE(v40.st_gid);
      v24 = *(stat **)&v40.st_dev;
      v25 = __error();
      v26 = &v40;
      if (st_gid_high < 0)
        v26 = v24;
      syslog(5, "%s,%s,Failed to move file %s to %s (%d)\n", "NOTICE", "CLLog", v13, (const char *)v26, *v25);
    }
    if (SHIBYTE(v40.st_gid) < 0)
      operator delete(*(void **)&v40.st_dev);
  }
  sub_18F4753D4((char *)a1, v15, v16, v17, v18);
  *(_QWORD *)(a1 + 2216) = 0;
  if (*(char *)(a1 + 79) >= 0)
    v27 = *(unsigned __int8 *)(a1 + 79);
  else
    v27 = *(_QWORD *)(a1 + 64);
  v28 = v36;
  sub_18F2B6B4C((uint64_t)v36, v27 + 4);
  if (v37 < 0)
    v28 = (void **)v36[0];
  if (v27)
  {
    if (*(char *)(a1 + 79) >= 0)
      v29 = (const void *)(a1 + 56);
    else
      v29 = *(const void **)(a1 + 56);
    memmove(v28, v29, v27);
  }
  strcpy((char *)v28 + v27, "logs");
  if (v37 >= 0)
    v30 = v36;
  else
    v30 = (void **)v36[0];
  if (!stat((const char *)v30, &v40))
  {
    v33[0] = MEMORY[0x1E0C809B0];
    v33[1] = 3321888768;
    v33[2] = sub_18F47625C;
    v33[3] = &unk_1E2952B18;
    v33[4] = a1;
    if (SHIBYTE(v37) < 0)
    {
      v31 = (void **)v36[0];
      sub_18F26F9A4(__p, v36[0], (unint64_t)v36[1]);
    }
    else
    {
      *(_OWORD *)__p = *(_OWORD *)v36;
      v35 = v37;
      v31 = v36;
    }
    sub_18F404218((uint64_t)v31, (uint64_t)v33);
    if (SHIBYTE(v35) < 0)
      operator delete(__p[0]);
  }
  if (SHIBYTE(v37) < 0)
    operator delete(v36[0]);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
}

void sub_18F4761F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a25 < 0)
    operator delete(__p);
  if (a31 < 0)
    operator delete(a26);
  sub_18F346934((uint64_t)&a32);
  _Unwind_Resume(a1);
}

uint64_t sub_18F47625C(uint64_t a1, std::string::value_type *a2)
{
  uint64_t v4;
  size_t v5;
  std::string *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  std::string *v15;
  __int128 v16;
  std::string *v17;
  std::error_code *v18;
  int v19;
  std::string *v20;
  const std::__fs::filesystem::path *v21;
  const std::__fs::filesystem::path *v22;
  int v23;
  int *v24;
  void *__p[2];
  char v27;
  std::string v28;
  std::string v29;
  void *v30[2];
  char v31;
  std::string __dst;
  std::string v33;
  std::string v34;
  std::string v35;
  __int128 v36;
  int64_t v37;

  v4 = *(_QWORD *)(a1 + 32);
  if (*(char *)(a1 + 63) >= 0)
    v5 = *(unsigned __int8 *)(a1 + 63);
  else
    v5 = *(_QWORD *)(a1 + 48);
  v6 = &v35;
  sub_18F2B6B4C((uint64_t)&v35, v5 + 1);
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v6 = (std::string *)v35.__r_.__value_.__r.__words[0];
  if (v5)
  {
    v9 = *(char **)(a1 + 40);
    v8 = (char *)(a1 + 40);
    v7 = v9;
    if (v8[23] >= 0)
      v10 = v8;
    else
      v10 = v7;
    memmove(v6, v10, v5);
  }
  *(_WORD *)((char *)&v6->__r_.__value_.__l.__data_ + v5) = 47;
  v11 = std::string::append(&v35, a2);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v37 = v11->__r_.__value_.__r.__words[2];
  v36 = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  sub_18F494D6C((uint64_t)&v33);
  v13 = std::string::append(&v33, "/");
  v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v34.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = std::string::append(&v34, a2);
  v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v33.__r_.__value_.__l.__data_);
  sub_18F270374(&v34, a2);
  if (*(char *)(v4 + 103) < 0)
    sub_18F26F9A4(&__dst, *(void **)(v4 + 80), *(_QWORD *)(v4 + 88));
  else
    __dst = *(std::string *)(v4 + 80);
  v17 = std::string::append(&__dst, "_");
  v33 = *v17;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  if (sub_18F495610(v4, &v34.__r_.__value_.__l.__data_, (char *)&v33))
  {
    sub_18F270374(v30, a2);
    if (*(char *)(v4 + 127) < 0)
      sub_18F26F9A4(&v28, *(void **)(v4 + 104), *(_QWORD *)(v4 + 112));
    else
      v28 = *(std::string *)(v4 + 104);
    v20 = std::string::append(&v28, ".bz2");
    v29 = *v20;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    if ((sub_18F4956E4(v4, v30, (char *)&v29) & 1) != 0)
    {
      v19 = 1;
    }
    else
    {
      sub_18F270374(__p, a2);
      v19 = sub_18F4956E4(v4, __p, (char *)(v4 + 104));
      if (v27 < 0)
        operator delete(__p[0]);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v29.__r_.__value_.__l.__data_);
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v28.__r_.__value_.__l.__data_);
    if (v31 < 0)
      operator delete(v30[0]);
  }
  else
  {
    v19 = 0;
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v33.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v34.__r_.__value_.__l.__data_);
    if (!v19)
      goto LABEL_51;
  }
  else if (!v19)
  {
    goto LABEL_51;
  }
  if (v37 >= 0)
    v21 = (const std::__fs::filesystem::path *)&v36;
  else
    v21 = (const std::__fs::filesystem::path *)v36;
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v22 = (const std::__fs::filesystem::path *)&v35;
  else
    v22 = (const std::__fs::filesystem::path *)v35.__r_.__value_.__r.__words[0];
  rename(v21, v22, v18);
  if (v23)
  {
    v24 = __error();
    syslog(5, "%s,%s,Failed to move file %s to %s (%d)\n", "NOTICE", "CLLog", (const char *)v21, (const char *)v22, *v24);
  }
LABEL_51:
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  if (SHIBYTE(v37) < 0)
    operator delete((void *)v36);
  return 1;
}

void sub_18F4765C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  uint64_t v48;

  if (a35 < 0)
    operator delete(__p);
  if (a48 < 0)
    operator delete(a43);
  if (a41 < 0)
    operator delete(a36);
  if (*(char *)(v48 - 121) < 0)
    operator delete(*(void **)(v48 - 144));
  if (*(char *)(v48 - 89) < 0)
    operator delete(*(void **)(v48 - 112));
  if (*(char *)(v48 - 57) < 0)
    operator delete(*(void **)(v48 - 80));
  _Unwind_Resume(exception_object);
}

void sub_18F4766BC()
{
  uint64_t v0;

  if (*(char *)(v0 - 89) < 0)
    JUMPOUT(0x18F4766B0);
  JUMPOUT(0x18F4766B4);
}

os_log_t sub_18F4766D0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Core", "Core");
  qword_1EE16D3D0 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4767FC(uint64_t a1)
{
  kdebug_trace();
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 16))();
}

void sub_18F476984(uint64_t a1)
{
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend__prepareDispatcher(WeakRetained, v1, v2, v3, v4);

}

void sub_18F476ABC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_18F476AE0()
{
  uint64_t v0;
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v0 = sub_18F204AE4();
  v1 = *(_QWORD *)(v0 + 24);
  v2 = *(std::__shared_weak_count **)(v0 + 32);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  sub_18F1EE8D4(v1, "PocketStateMaxMonitorTime", &qword_1EE16E300);
  if (v2)
  {
    v5 = (unint64_t *)&v2->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void sub_18F476B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_18F2A8438((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_18F476B98(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a2, sel_onPocketStateUpdated_, *a1, a4, a5);
}

void sub_18F476E98()
{
  uint64_t v0;
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v0 = sub_18F204AE4();
  v1 = *(_QWORD *)(v0 + 24);
  v2 = *(std::__shared_weak_count **)(v0 + 32);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  sub_18F1EE944(v1, "DisablePocketState", (BOOL *)&byte_1ECEDFBC0);
  if (v2)
  {
    v5 = (unint64_t *)&v2->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void sub_18F476F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_18F2A8438((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_18F477148(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[6];
  int v6;

  if (sub_18F3DECC0())
  {
    v2 = sub_18F3DECC0();
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32);
    v4 = sub_18F204AE4();
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = sub_18F1F5EE0;
    v5[3] = &unk_1E2956E98;
    v6 = 0;
    v5[4] = v2;
    v5[5] = v3;
    sub_18F1F5E28(v4, (uint64_t)v5);
  }
}

uint64_t sub_18F477290(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  void *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v6 = (void *)MEMORY[0x1E0CB3940];
  v7 = (void *)objc_msgSend_processInfo(MEMORY[0x1E0CB3898], a2, a3, a4, a5);
  v12 = objc_msgSend_processName(v7, v8, v9, v10, v11);
  v16 = (void *)objc_msgSend_stringWithFormat_(v6, v13, (uint64_t)CFSTR("com.apple.CoreMotion.CMPocketStateManager.%@.%@"), v14, v15, v12, *(_QWORD *)(a1 + 32));
  if (qword_1EE16D6B8 != -1)
    dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
  v17 = qword_1EE16D6B0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_INFO))
  {
    v22 = objc_msgSend_UTF8String(v16, v18, v19, v20, v21);
    v23 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 136315394;
    v31 = v22;
    v32 = 2048;
    v33 = v23;
    _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_INFO, "ADClient: %s + %llu", buf, 0x16u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6B8 != -1)
      dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
    objc_msgSend_UTF8String(v16, v25, v26, v27, v28);
    v29 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMPocketStateManager addToAggdScalarWithName:andScalar:]_block_invoke", "CoreLocation: %s\n", v29);
    if (v29 != (char *)buf)
      free(v29);
  }
  return ADClientAddValueForScalarKey();
}

void sub_18F477844(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  double v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  CMPocketStateQueueBlockPair *v12;
  const char *v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  dispatch_time_t v20;
  uint64_t v21;
  NSObject *v22;
  double *v23;
  NSObject *v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  double v37;
  uint64_t v38;
  char *v39;
  _QWORD handler[5];
  int v41;
  double v42;
  __int16 v43;
  uint64_t v44;
  uint8_t buf[4];
  double v46;
  __int16 v47;
  uint64_t v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D6B8 != -1)
    dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
  v2 = qword_1EE16D6B0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_INFO))
  {
    v3 = mach_absolute_time();
    v4 = sub_18F1FD20C(v3);
    v5 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)buf = 134218240;
    v46 = v4;
    v47 = 2048;
    v48 = v5;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "%f: query started with timeout %f", buf, 0x16u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6B8 != -1)
      dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
    v31 = mach_absolute_time();
    v32 = sub_18F1FD20C(v31);
    v33 = *(_QWORD *)(a1 + 56);
    v41 = 134218240;
    v42 = v32;
    v43 = 2048;
    v44 = v33;
    v34 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke", "CoreLocation: %s\n", v34);
    if (v34 != (char *)buf)
      free(v34);
  }
  objc_msgSend_addToAggdScalarWithName_andScalar_(*(void **)(a1 + 32), v6, (uint64_t)CFSTR("queryStart"), 1, v7);
  v8 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v8 + 8))
  {
    if (qword_1EE16D6B8 != -1)
      dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
    v9 = qword_1EE16D6B0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "Query aborted", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6B8 != -1)
        dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
      LOWORD(v41) = 0;
      v35 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke", "CoreLocation: %s\n", v35);
      if (v35 != (char *)buf)
        free(v35);
    }
    objc_msgSend_addToAggdScalarWithName_andScalar_(*(void **)(a1 + 32), v10, (uint64_t)CFSTR("queryAbort"), 1, v11);
    dispatch_source_cancel(*(dispatch_source_t *)(*(_QWORD *)(a1 + 32) + 8));
    dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 8));
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = 0;
    v8 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v8 + 16));
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8))
  {
    v12 = [CMPocketStateQueueBlockPair alloc];
    v15 = (void *)objc_msgSend_initWithQueue_andBlock_(v12, v13, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), v14);
    objc_msgSend_addObject_(*(void **)(*(_QWORD *)(a1 + 32) + 48), v16, (uint64_t)v15, v17, v18);

    v19 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 8);
    v20 = dispatch_time(0, (uint64_t)(*(double *)(a1 + 56) * 1000000000.0));
    dispatch_source_set_timer(v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    v21 = *(_QWORD *)(a1 + 32);
    v22 = *(NSObject **)(v21 + 8);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = sub_18F477F64;
    handler[3] = &unk_1E2955938;
    handler[4] = v21;
    dispatch_source_set_event_handler(v22, handler);
    v23 = (double *)(a1 + 64);
    if (*(double *)(a1 + 64) <= *(double *)(*(_QWORD *)(a1 + 32) + 40))
    {
      v27 = sub_18F3DECC0();
    }
    else
    {
      if (qword_1EE16D6B8 != -1)
        dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
      v24 = qword_1EE16D6B0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_FAULT))
      {
        v25 = *(double *)(*(_QWORD *)(a1 + 32) + 40);
        v26 = *(_QWORD *)(a1 + 64);
        *(_DWORD *)buf = 134218240;
        v46 = v25;
        v47 = 2048;
        v48 = v26;
        _os_log_impl(&dword_18F1DC000, v24, OS_LOG_TYPE_FAULT, "Attempted to exceed max monitor time %f, %f", buf, 0x16u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D6B8 != -1)
          dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
        v37 = *(double *)(*(_QWORD *)(a1 + 32) + 40);
        v38 = *(_QWORD *)(a1 + 64);
        v41 = 134218240;
        v42 = v37;
        v43 = 2048;
        v44 = v38;
        v39 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke", "CoreLocation: %s\n", v39);
        if (v39 != (char *)buf)
          free(v39);
      }
      v27 = sub_18F3DECC0();
      v23 = (double *)(*(_QWORD *)(a1 + 32) + 40);
    }
    sub_18F3E04F8(v27, *v23);
    dispatch_resume(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 8));
  }
  else
  {
    if (qword_1EE16D6B8 != -1)
      dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
    v28 = qword_1EE16D6B0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_FAULT, "Query timer failed to initialize", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6B8 != -1)
        dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
      LOWORD(v41) = 0;
      v36 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke", "CoreLocation: %s\n", v36);
      if (v36 != (char *)buf)
        free(v36);
    }
    objc_msgSend_addToAggdScalarWithName_andScalar_(*(void **)(a1 + 32), v29, (uint64_t)CFSTR("queryTimerFail"), 1, v30);
  }
}

void sub_18F477F64(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  double v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  void *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t i;
  NSObject *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  double v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  _BYTE v66[128];
  int v67;
  double v68;
  __int16 v69;
  int v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  uint64_t v74;
  uint8_t buf[4];
  double v76;
  __int16 v77;
  int v78;
  __int16 v79;
  uint64_t v80;
  __int16 v81;
  uint64_t v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D6B8 != -1)
    dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
  v2 = qword_1EE16D6B0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_INFO))
  {
    v3 = mach_absolute_time();
    *(_DWORD *)buf = 134217984;
    v76 = sub_18F1FD20C(v3);
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "QueryTimerFire,%f", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6B8 != -1)
      dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
    v46 = mach_absolute_time();
    v67 = 134217984;
    v68 = sub_18F1FD20C(v46);
    v47 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke", "CoreLocation: %s\n", v47);
    if (v47 != (char *)buf)
      free(v47);
  }
  objc_msgSend_addToAggdScalarWithName_andScalar_(*(void **)(a1 + 32), v4, (uint64_t)CFSTR("queryTimerFire"), 1, v5);
  v6 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 8);
  if (v6)
  {
    dispatch_source_cancel(v6);
    dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 8));
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = 0;
    v10 = objc_msgSend_translateInternalState_(*(void **)(a1 + 32), v7, *(unsigned int *)(*(_QWORD *)(a1 + 32) + 24), v8, v9);
    v14 = (void *)objc_msgSend_externalStateToString_(*(void **)(a1 + 32), v11, v10, v12, v13);
    v15 = *(void **)(a1 + 32);
    v19 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v16, (uint64_t)CFSTR("queryResponse.%@"), v17, v18, v14);
    objc_msgSend_addToAggdScalarWithName_andScalar_(v15, v20, v19, 1, v21);
    if (qword_1EE16D6B8 != -1)
      dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
    v22 = qword_1EE16D6B0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_DEFAULT))
    {
      v23 = mach_absolute_time();
      v24 = sub_18F1FD20C(v23);
      v29 = objc_msgSend_UTF8String(v14, v25, v26, v27, v28);
      v34 = objc_msgSend_count(*(void **)(*(_QWORD *)(a1 + 32) + 48), v30, v31, v32, v33);
      *(_DWORD *)buf = 134218754;
      v76 = v24;
      v77 = 1024;
      v78 = v10;
      v79 = 2080;
      v80 = v29;
      v81 = 2048;
      v82 = v34;
      _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_DEFAULT, "%f: query response external=%u (%s), cbcount=%lu", buf, 0x26u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6B8 != -1)
        dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
      v48 = mach_absolute_time();
      v49 = sub_18F1FD20C(v48);
      v54 = objc_msgSend_UTF8String(v14, v50, v51, v52, v53);
      v59 = objc_msgSend_count(*(void **)(*(_QWORD *)(a1 + 32) + 48), v55, v56, v57, v58);
      v67 = 134218754;
      v68 = v49;
      v69 = 1024;
      v70 = v10;
      v71 = 2080;
      v72 = v54;
      v73 = 2048;
      v74 = v59;
      v60 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke", "CoreLocation: %s\n", v60);
      if (v60 != (char *)buf)
        free(v60);
    }
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v36 = *(void **)(*(_QWORD *)(a1 + 32) + 48);
    v37 = objc_msgSend_countByEnumeratingWithState_objects_count_(v36, v35, (uint64_t)&v62, (uint64_t)v66, 16);
    if (v37)
    {
      v42 = v37;
      v43 = *(_QWORD *)v63;
      do
      {
        for (i = 0; i != v42; ++i)
        {
          if (*(_QWORD *)v63 != v43)
            objc_enumerationMutation(v36);
          objc_msgSend_dispatchWithState_andError_(*(void **)(*((_QWORD *)&v62 + 1) + 8 * i), v38, v10, 0, v41);
        }
        v42 = objc_msgSend_countByEnumeratingWithState_objects_count_(v36, v38, (uint64_t)&v62, (uint64_t)v66, 16);
      }
      while (v42);
    }
    objc_msgSend_removeAllObjects(*(void **)(*(_QWORD *)(a1 + 32) + 48), v38, v39, v40, v41);
  }
  else
  {
    if (qword_1EE16D6B8 != -1)
      dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
    v45 = qword_1EE16D6B0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v45, OS_LOG_TYPE_FAULT, "timer fired even though fQueryTimer is NULL", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6B8 != -1)
        dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
      LOWORD(v67) = 0;
      v61 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMPocketStateManager queryStateOntoQueue:andMonitorFor:withTimeout:andHandler:]_block_invoke", "CoreLocation: %s\n", v61);
      if (v61 != (char *)buf)
        free(v61);
    }
  }
}

void sub_18F4785C0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  NSObject *v20;
  void *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint8_t buf[4];
  unsigned int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v6 = (void *)objc_msgSend_userInfo(*(void **)(a1 + 32), a2, a3, a4, a5);
  v10 = (void *)objc_msgSend_objectForKey_(v6, v7, (uint64_t)CFSTR("CMSetPocketStateTypeKey"), v8, v9);
  v15 = objc_msgSend_intValue(v10, v11, v12, v13, v14);
  v19 = v15;
  if (v15 < 4)
  {
    v21 = *(void **)(a1 + 40);
    v22 = objc_msgSend_translateExternalState_(v21, v16, v15, v17, v18);
    MEMORY[0x1E0DE7D20](v21, sel_onPocketStateUpdated_, v22, v24, v25);
  }
  else
  {
    if (qword_1EE16D6B8 != -1)
      dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
    v20 = qword_1EE16D6B0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6B0, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67109120;
      v27 = v19;
      _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_FAULT, "The pocket state %d is not in bounds", buf, 8u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6B8 != -1)
        dispatch_once(&qword_1EE16D6B8, &unk_1E29589D8);
      v23 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMPocketStateManager onNotification:]_block_invoke", "CoreLocation: %s\n", v23);
      if (v23 != (char *)buf)
        free(v23);
    }
  }
}

uint64_t sub_18F478830(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) = *(_DWORD *)(a1 + 40);
  objc_msgSend_delegate(*(void **)(a1 + 32), a2, a3, a4, a5);
  result = objc_opt_respondsToSelector();
  if ((result & 1) != 0)
  {
    v11 = objc_msgSend_delegate(*(void **)(a1 + 32), v7, v8, v9, v10);
    v12 = *(void **)(a1 + 32);
    v16 = objc_msgSend_translateInternalState_(v12, v13, *(unsigned int *)(a1 + 40), v14, v15);
    return MEMORY[0x1E0DE7D20](v11, sel_pocketStateManager_didUpdateState_, v12, v16, v17);
  }
  return result;
}

os_log_t sub_18F4788E0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Pocket");
  qword_1EE16D6B0 = (uint64_t)result;
  return result;
}

void sub_18F478910(uint64_t a1)
{
  sub_18F1E932C(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F478934(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 16))(a3, *(_QWORD *)(a1 + 24));
}

long double sub_18F478940(double a1, double a2, double a3, double a4)
{
  double v4;
  long double result;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  long double v14;
  long double v15;
  long double v16;
  double v17;
  double v18;
  __double2 v19;
  __double2 v20;
  unsigned int v21;
  double v22;
  double v23;
  __double2 v24;
  double v25;
  double v26;
  double v27;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v38;
  double v39;
  double v40;
  BOOL v41;
  double v42;
  double v43;
  double v44;

  v4 = a3;
  result = 0.0;
  if (a3 > 90.0 || a1 < -90.0 || a1 > 90.0 || a3 < -90.0)
    return result;
  v7 = a4 + 360.0;
  if (a4 >= 0.0)
    v7 = a4;
  v8 = a2 + 360.0;
  if (a2 >= 0.0)
    v8 = a2;
  v9 = v8 - v7;
  if (v9 <= 180.0)
  {
    if (v9 < -180.0)
      v9 = v9 + 360.0;
  }
  else
  {
    v9 = v9 + -360.0;
  }
  if (fabs(a1 + v4) >= 0.0001)
  {
    v42 = a2;
    v43 = a4;
LABEL_18:
    v11 = v9;
    goto LABEL_19;
  }
  v10 = fabs(a1);
  if (v10 < 0.0001 && 180.0 - fabs(v9) < 0.0001)
    return 20037508.3;
  v41 = fabs(v10 + -90.0) < 0.0001;
  if (v41)
    v11 = 0.0;
  else
    v11 = v9;
  v42 = a2;
  v43 = a4;
  if (!v41 && 180.0 - fabs(v9) >= 0.0001)
    goto LABEL_18;
  if (a1 <= v4)
    v4 = v4 + -0.0001;
  else
    a1 = a1 + -0.0001;
LABEL_19:
  v12 = v11 * 0.0174532925;
  v44 = a1;
  v13 = tan(a1 * 0.0174532925);
  v14 = tan(v4 * 0.0174532925);
  v15 = v13 * 0.996647189;
  v16 = v14 * 0.996647189;
  v17 = atan(v15);
  v18 = atan(v16);
  v19 = __sincos_stret(v17);
  v20 = __sincos_stret(v18);
  v21 = 0;
  v22 = v19.__cosval * v20.__cosval;
  v23 = v12;
  while (1)
  {
    v24 = __sincos_stret(v23);
    v25 = sqrt((-(v19.__sinval * v20.__cosval) * v24.__cosval + v19.__cosval * v20.__sinval)* (-(v19.__sinval * v20.__cosval) * v24.__cosval + v19.__cosval * v20.__sinval)+ v20.__cosval * v24.__sinval * (v20.__cosval * v24.__sinval));
    if (v25 < 2.22044605e-15)
      break;
    v26 = v22 * v24.__cosval + v19.__sinval * v20.__sinval;
    v27 = fabs(v26);
    if (fabs(v25) > 1.0 || v27 > 1.0)
      break;
    v29 = atan2(v25, v26);
    v30 = v22 * v24.__sinval / v25;
    if (v30 > 1.0)
      break;
    v31 = 1.0 - v30 * v30;
    if (fabs(v31) >= 2.22044605e-15)
    {
      v33 = v26 - (v19.__sinval + v19.__sinval) * v20.__sinval / v31;
      v32 = v31 * 0.000209550667 * ((v31 * -3.0 + 4.0) * 0.00335281066 + 4.0);
    }
    else
    {
      v32 = 0.0;
      v33 = -1.0;
    }
    v34 = v30 * ((1.0 - v32) * 0.00335281066);
    v35 = v33 * v33 * 2.0 + -1.0;
    v36 = v12 + v34 * (v29 + v25 * v32 * (v33 + v26 * v32 * v35));
    if (vabdd_f64(v36, v23) > 0.000000001)
    {
      v23 = v36;
      if (v21++ < 0x31)
        continue;
    }
    v38 = v31 * 2.72331606e11 / 4.04083e13;
    v39 = v38 * 0.0000610351562 * (v38 * (v38 * (v38 * -175.0 + 320.0) + -768.0) + 4096.0) + 1.0;
    v40 = v38 * 0.0009765625 * (v38 * (v38 * (v38 * -47.0 + 74.0) + -128.0) + 256.0);
    return v39
         * 6356752.31
         * (v29 - v25 * v40 * (v33 + v40 * 0.25 * ((v33 * v33 * 4.0 + -3.0) * (v40 / 6.0 * v33 * 3.0) + v26 * v35)));
  }
  return sub_18F478D84(v44, v42, v4, v43);
}

long double sub_18F478D84(double a1, double a2, double a3, double a4)
{
  double v5;
  double v6;
  double v7;
  double v8;
  long double v9;
  long double v10;
  __double2 v11;
  long double v12;
  long double v13;
  double v14;
  double v15;
  long double v16;

  v5 = 360.0;
  if (a2 < 0.0)
    a2 = a2 + 360.0;
  if (a4 < 0.0)
    a4 = a4 + 360.0;
  v6 = a4 - a2;
  if (v6 <= 180.0)
  {
    if (v6 >= -180.0)
      goto LABEL_9;
  }
  else
  {
    v5 = -360.0;
  }
  v6 = v6 + v5;
LABEL_9:
  v7 = a1 * 0.0174532925;
  v8 = v6 * 0.0174532925;
  v9 = sin((a3 - a1) * 0.0174532925 * 0.5);
  v10 = v9 * v9;
  v11 = __sincos_stret(v7);
  v12 = v11.__cosval * cos(a3 * 0.0174532925);
  v13 = sin(v8 * 0.5);
  v14 = v10 + v12 * (v13 * v13);
  v15 = 1.0 - v14;
  if (v14 < 0.0)
    v14 = 0.0;
  if (v15 < 0.0)
    v15 = 0.0;
  v16 = atan2(sqrt(v14), sqrt(v15));
  return (fabs(v11.__sinval) * -21000.0 + 6378160.0) * (v16 + v16);
}

BOOL sub_18F478EA8(double a1, double a2, double a3, double a4)
{
  double v4;
  unsigned int v5;
  int v6;

  if (a2 < 0.0)
    a2 = a2 + 360.0;
  if (a4 < 0.0)
    a4 = a4 + 360.0;
  v4 = a4 - a2;
  if (v4 <= 180.0)
  {
    if (v4 < -180.0)
      v4 = v4 + 360.0;
  }
  else
  {
    v4 = v4 + -360.0;
  }
  v5 = (int)v4;
  if ((int)v4 < 0)
    v5 = -v5;
  v6 = (int)a3 - (int)a1;
  if (v6 < 0)
    v6 = (int)a1 - (int)a3;
  return v6 > 2 || v5 > 2;
}

BOOL sub_18F478F2C(double *a1, double *a2, double *a3, double *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v10;
  double v21;
  double v22;
  __double2 v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;

  v10 = vabdd_f64(a5, a8);
  if (v10 <= 2.0)
  {
    v21 = a1[3];
    if (v21 == 0.0 || vabdd_f64(a5, v21) > 0.005)
    {
      v22 = (a5 + a8) * 0.5;
      a1[2] = v22 * 0.0174532925;
      a1[3] = v22;
      v23 = __sincos_stret(v22 * 0.0174532925);
      v24 = v23.__sinval * -0.00669437999 * v23.__sinval + 1.0;
      v25 = sqrt(v24);
      *a1 = 6335439.33 / (v24 * v25);
      a1[1] = 6378137.0 / v25;
      a1[4] = v23.__cosval;
    }
    v26 = 360.0;
    v27 = a6 + 360.0;
    if (a6 >= 0.0)
      v27 = a6;
    v28 = a9 + 360.0;
    if (a9 >= 0.0)
      v28 = a9;
    v29 = v28 - v27;
    if (v29 <= 180.0)
    {
      if (v29 >= -180.0)
      {
LABEL_13:
        *a2 = (a8 - a5) * 0.0174532925 * (*a1 + a7);
        *a3 = v29 * 0.0174532925 * ((a1[1] + a7) * a1[4]);
        *a4 = a10 - a7;
        return v10 <= 2.0;
      }
    }
    else
    {
      v26 = -360.0;
    }
    v29 = v29 + v26;
    goto LABEL_13;
  }
  return v10 <= 2.0;
}

long double sub_18F4790C4(double *a1, double a2, double a3, double a4, double a5, double a6)
{
  double v13;
  double v14;
  double v15;

  v14 = 0.0;
  v15 = 0.0;
  if (sub_18F478EA8(a2, a3, a4, a5) || !sub_18F478F2C(a1, &v15, &v14, &v13, a2, a3, a6, a4, a5, a6))
    return sub_18F478940(a2, a3, a4, a5);
  else
    return sqrt(v14 * v14 + v15 * v15);
}

void sub_18F47918C(double *a1, uint64_t a2, uint64_t a3)
{
  double v6;
  double v7;
  double v8;
  double v9;
  NSObject *v10;
  NSObject *v11;
  char *v12;
  double v13;
  double v14;
  double v15;
  double v16;
  uint8_t buf[4];
  unint64_t v18;
  __int16 v19;
  double v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v6 = *(double *)(a2 + 36);
  v7 = *(double *)(a3 + 36);
  if (v6 <= 0.0 || v7 <= 0.0)
  {
    if (v6 <= 0.0)
    {
      v9 = 0.0;
      if (v7 <= 0.0)
        goto LABEL_26;
      v8 = *(double *)(a3 + 28);
    }
    else
    {
      v8 = *(double *)(a2 + 28);
    }
  }
  else
  {
    v8 = (*(double *)(a2 + 28) + *(double *)(a3 + 28)) * 0.5;
  }
  v9 = -450.0;
  if (v8 >= -450.0)
  {
    v9 = 1000000.0;
    if (v8 <= 1000000.0)
    {
      v9 = v8;
      goto LABEL_26;
    }
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953E48);
    v11 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      v18 = 0x412E848000000000;
      v19 = 2048;
      v20 = v8;
      _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_DEFAULT, "#Warning refAlt > %.1lf,refAlt,%.1lf,using the max", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 == -1)
        goto LABEL_23;
      goto LABEL_29;
    }
  }
  else
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953E48);
    v10 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      v18 = 0xC07C200000000000;
      v19 = 2048;
      v20 = v8;
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEFAULT, "#Warning refAlt < %.1lf,refAlt,%.1lf,using the min", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 == -1)
      {
LABEL_23:
        v12 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "double CLDistanceCalc::calculateDistance(const CLDaemonLocation &, const CLDaemonLocation &)", "CoreLocation: %s\n", v12);
        if (v12 != (char *)buf)
          free(v12);
        goto LABEL_26;
      }
LABEL_29:
      dispatch_once(&qword_1ECEDEE88, &unk_1E2953E48);
      goto LABEL_23;
    }
  }
LABEL_26:
  v13 = *(double *)(a2 + 4);
  v14 = *(double *)(a2 + 12);
  v15 = *(double *)(a3 + 4);
  v16 = *(double *)(a3 + 12);
  if (sub_18F478EA8(v13, v14, v15, v16))
    sub_18F478940(v13, v14, v15, v16);
  else
    sub_18F4790C4(a1, v13, v14, v15, v16, v9);
}

uint64_t sub_18F47A70C()
{
  if (qword_1ECEDFBD8 != -1)
    dispatch_once(&qword_1ECEDFBD8, &unk_1E2953E68);
  return qword_1ECEDFBD0;
}

void sub_18F47A74C()
{
  uint64_t v0;
  _BYTE *v1;
  int v2;
  char v3;
  uint64_t v4;
  char v5;
  NSObject *v6;
  int v7;
  __CFNotificationCenter *DarwinNotifyCenter;
  NSObject *v9;
  NSObject *v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  char *v15;
  _DWORD v16[2];
  __int16 v17;
  int v18;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v0 = operator new();
  sub_18F1E61EC(v0, (uint64_t)"CLOrientationNotifier", 2);
  *(_QWORD *)v0 = &off_1E294AD48;
  *(_WORD *)(v0 + 32) = 0;
  *(_BYTE *)(v0 + 34) = 0;
  v1 = (_BYTE *)(v0 + 34);
  *(_QWORD *)(v0 + 40) = 0;
  *(_QWORD *)(v0 + 48) = 0;
  *(_QWORD *)(v0 + 56) = 1092616192;
  *(_QWORD *)(v0 + 64) = 0;
  *(_QWORD *)(v0 + 72) = 0x100000001;
  *(_BYTE *)(v0 + 80) = 0;
  *(_DWORD *)(v0 + 84) = 0;
  *(_OWORD *)(v0 + 88) = xmmword_18F509370;
  *(_QWORD *)(v0 + 104) = &off_1E294A890;
  *(_QWORD *)(v0 + 112) = 0;
  *(_QWORD *)(v0 + 120) = &off_1E294AC98;
  *(_OWORD *)(v0 + 128) = 0u;
  *(_OWORD *)(v0 + 144) = 0u;
  *(_OWORD *)(v0 + 160) = 0u;
  *(_OWORD *)(v0 + 176) = 0u;
  *(_QWORD *)(v0 + 192) = &off_1E294AC98;
  *(_OWORD *)(v0 + 200) = 0u;
  *(_OWORD *)(v0 + 216) = 0u;
  *(_OWORD *)(v0 + 232) = 0u;
  *(_OWORD *)(v0 + 248) = 0u;
  *(_QWORD *)(v0 + 264) = &off_1E294AC98;
  *(_OWORD *)(v0 + 272) = 0u;
  *(_OWORD *)(v0 + 288) = 0u;
  *(_OWORD *)(v0 + 304) = 0u;
  *(_OWORD *)(v0 + 320) = 0u;
  *(int64x2_t *)(v0 + 336) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  *(_DWORD *)(v0 + 368) = 0;
  *(_QWORD *)(v0 + 352) = 0;
  *(_QWORD *)(v0 + 360) = 0;
  *(_OWORD *)(v0 + 376) = 0u;
  *(_OWORD *)(v0 + 392) = 0u;
  *(_WORD *)(v0 + 408) = 0;
  sub_18F1F77DC();
  v2 = sub_18F1E19B0();
  v3 = 3;
  v4 = 0;
  v5 = 1;
  switch(v2)
  {
    case 7:
    case 8:
    case 9:
    case 29:
    case 30:
      goto LABEL_16;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      v3 = 9;
      goto LABEL_15;
    case 22:
    case 24:
    case 55:
    case 56:
    case 58:
    case 59:
    case 69:
    case 70:
    case 72:
    case 73:
    case 78:
    case 79:
    case 80:
    case 138:
    case 139:
    case 140:
    case 141:
    case 143:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
      goto LABEL_17;
    case 31:
    case 32:
      v3 = 10;
      goto LABEL_15;
    case 33:
    case 34:
    case 146:
    case 147:
      v3 = 11;
      goto LABEL_15;
    case 35:
    case 36:
      v3 = 13;
      goto LABEL_16;
    case 44:
    case 45:
      v3 = 4;
      goto LABEL_16;
    case 46:
    case 47:
      v3 = 6;
      goto LABEL_16;
    case 48:
    case 49:
      v3 = 7;
      goto LABEL_16;
    case 62:
    case 63:
    case 161:
      v3 = 14;
      goto LABEL_16;
    case 64:
    case 65:
    case 76:
    case 77:
      v3 = 5;
      goto LABEL_16;
    case 134:
    case 135:
    case 154:
    case 155:
    case 197:
    case 198:
    case 224:
    case 225:
    case 226:
      v3 = 15;
      goto LABEL_16;
    case 136:
    case 137:
    case 156:
    case 157:
    case 199:
    case 200:
    case 227:
    case 228:
      v3 = 16;
      goto LABEL_16;
    case 144:
    case 145:
    case 201:
    case 202:
    case 203:
    case 204:
    case 205:
    case 206:
    case 237:
      v3 = 8;
      goto LABEL_16;
    case 186:
    case 187:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 229:
    case 230:
    case 231:
    case 232:
    case 238:
    case 239:
      v3 = 17;
      goto LABEL_16;
    case 188:
    case 189:
      v3 = 12;
      goto LABEL_15;
    case 240:
    case 241:
      v3 = 17;
LABEL_15:
      v4 = 0x4082C00000000000;
LABEL_16:
      *(_QWORD *)(v0 + 88) = v4;
      v5 = v3;
LABEL_17:
      *(_BYTE *)(v0 + 32) = v5;
      break;
    default:
      break;
  }
  if (qword_1ECEDEE28 != -1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
  v6 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(unsigned __int8 *)(v0 + 32);
    *(_DWORD *)buf = 67240448;
    v20 = v2;
    v21 = 1026;
    v22 = v7;
    _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "hwType,%{public}d,formFactor,%{public}u", buf, 0xEu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v12 = *(unsigned __int8 *)(v0 + 32);
    v16[0] = 67240448;
    v16[1] = v2;
    v17 = 1026;
    v18 = v12;
    v13 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLOrientationNotifier::CLOrientationNotifier()", "CoreLocation: %s\n", v13);
    if (v13 != (char *)buf)
      free(v13);
  }
  if (*(unsigned __int8 *)(v0 + 32) >= 2u)
  {
    sub_18F1EC720((uint64_t)v16, CFSTR("com.apple.springboard"), 1, 0x1E295B508);
    if ((sub_18F1EE944((uint64_t)v16, "SBHasSeenACaseLatchCoverOnce", (BOOL *)(v0 + 34)) & 1) == 0)
    {
      *v1 = 0;
      DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterAddObserver(DarwinNotifyCenter, (const void *)v0, (CFNotificationCallback)sub_18F47B1B8, CFSTR("com.apple.springboard.HasSeenACaseLatchCoverNotification"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v9 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "Registering for SBHasSeenACaseLatchCoverNotification.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v15 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "CLOrientationNotifier::CLOrientationNotifier()", "CoreLocation: %s\n", v15);
        if (v15 != (char *)buf)
          free(v15);
      }
    }
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v10 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
    {
      v11 = *v1;
      *(_DWORD *)buf = 67240192;
      v20 = v11;
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_INFO, "fHasSeenACaseLatchCoverOnce %{public}u", buf, 8u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "CLOrientationNotifier::CLOrientationNotifier()", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
    }
    sub_18F387C84((uint64_t)v16);
  }
  qword_1ECEDFBD0 = v0;
}

void sub_18F47ADA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  _QWORD *v5;
  _QWORD *v6;
  va_list va;

  va_start(va, a5);
  sub_18F387C84((uint64_t)va);
  sub_18F2A8438((uint64_t)(v5 + 44));
  sub_18F1EB0F0(v6);
  sub_18F3DB8A0(v5);
  MEMORY[0x194001438](v5, 0x10F1C4010CC6B30);
  _Unwind_Resume(a1);
}

void sub_18F47B1B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  _QWORD v11[9];

  v10 = sub_18F204AE4();
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = sub_18F47F404;
  v11[3] = &unk_1E2958A38;
  v11[4] = a2;
  v11[5] = a1;
  v11[6] = a3;
  v11[7] = a4;
  v11[8] = a5;
  sub_18F1F5E28(v10, (uint64_t)v11);
}

_QWORD *sub_18F47B240(_QWORD *a1)
{
  *a1 = &off_1E294AD48;
  sub_18F47B284(a1);
  sub_18F2A8438((uint64_t)(a1 + 44));
  sub_18F1EB0F0(a1 + 13);
  return sub_18F3DB8A0(a1);
}

void sub_18F47B284(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  char *v13;
  uint8_t buf[8];
  uint64_t v15;
  uint64_t *(*v16)(uint64_t);
  void *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = (_QWORD *)a1[5];
  if (v2)
  {
    sub_18F1EB0F0(v2 + 90);
    sub_18F1EB0F0(v2 + 61);
    sub_18F1EB0F0(v2 + 32);
    sub_18F1EB0F0(v2 + 3);
    MEMORY[0x194001438](v2, 0x1080C40300B9403);
    a1[5] = 0;
  }
  v3 = MEMORY[0x1E0C809B0];
  if (a1[6])
  {
    v4 = sub_18F1DFF7C();
    v5 = a1[6];
    v6 = sub_18F204AE4();
    *(_QWORD *)buf = v3;
    v15 = 3221225472;
    v16 = sub_18F1F5EE0;
    v17 = &unk_1E2956E98;
    v20 = 0;
    v18 = v4;
    v19 = v5;
    sub_18F1F5E28(v6, (uint64_t)buf);
    v7 = a1[6];
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    a1[6] = 0;
  }
  if (a1[8])
  {
    v8 = sub_18F1EF73C();
    v9 = a1[8];
    v10 = sub_18F204AE4();
    *(_QWORD *)buf = v3;
    v15 = 3221225472;
    v16 = sub_18F1F5EE0;
    v17 = &unk_1E2956E98;
    v20 = 0;
    v18 = v8;
    v19 = v9;
    sub_18F1F5E28(v10, (uint64_t)buf);
    v11 = a1[8];
    if (v11)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    a1[8] = 0;
  }
  if (qword_1ECEDEE28 != -1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
  v12 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_DEFAULT, "Stopping orientation detection.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v13 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::stopDetection()", "CoreLocation: %s\n", v13);
    if (v13 != (char *)buf)
      free(v13);
  }
}

void sub_18F47B520(_QWORD *a1)
{
  sub_18F47B240(a1);
  JUMPOUT(0x194001438);
}

void sub_18F47B544(uint64_t a1, unsigned int a2, uint64_t a3)
{
  NSObject *v3;
  char *v4;
  void **v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  NSObject *v18;
  char *v19;
  NSObject *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  int v25;
  int v26;
  __int128 buf;
  uint64_t *(*v28)(uint64_t);
  void *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a2 >= 3)
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v3 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_FAULT, "Unrecognized notification", (uint8_t *)&buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      LOWORD(v25) = 0;
      v4 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual void CLOrientationNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v4);
      if (v4 != (char *)&buf)
        free(v4);
    }
    return;
  }
  v8 = (void **)(a1 + 352);
  if (!*(_QWORD *)(a1 + 352))
  {
    if (qword_1ECEDFDE8 != -1)
      dispatch_once(&qword_1ECEDFDE8, &unk_1E2953A08);
    v23 = 0x8A00000020;
    v24 = 0;
    sub_18F1E9BC8((_QWORD *)qword_1ECEDFDE0, (uint64_t)&v23, (uint64_t *)&buf);
    sub_18F346DC8((uint64_t)v8, &buf);
    v9 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v10 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    sub_18F1E4538(*v8, &unk_1E298C258);
  }
  if (a3 != 1)
  {
    if (!a3)
    {
      *(_BYTE *)(a1 + 33) = 0;
      if (*(_QWORD *)(a1 + 392))
      {
        v12 = sub_18F3918E4();
        v13 = *(_QWORD *)(a1 + 392);
        v14 = sub_18F204AE4();
        *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
        *((_QWORD *)&buf + 1) = 3221225472;
        v28 = sub_18F1F5EE0;
        v29 = &unk_1E2956E98;
        v32 = 0;
        v30 = v12;
        v31 = v13;
        sub_18F1F5E28(v14, (uint64_t)&buf);
        v15 = *(_QWORD *)(a1 + 392);
        if (v15)
          (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
        *(_QWORD *)(a1 + 392) = 0;
      }
      if ((sub_18F1F7BFC() & 0x40) != 0)
      {
        sub_18F203AF8(*(_QWORD *)(a1 + 352), 0);
        v16 = *(_DWORD *)(a1 + 368) - 1;
        *(_DWORD *)(a1 + 368) = v16;
        if (!v16)
        {
          sub_18F4D4518((uint64_t)*v8, 0, 0);
          if (sub_18F1FBD7C((uint64_t)*v8))
            sub_18F47D300((_QWORD *)a1);
        }
        sub_18F4D3A58((uint64_t)*v8, 0, 0);
        sub_18F4D3788((uint64_t)*v8, 0, 0);
        sub_18F203148((uint64_t)*v8, 0, 0);
      }
      if (*(_QWORD *)(a1 + 48))
        sub_18F47B284((_QWORD *)a1);
    }
    return;
  }
  if ((sub_18F1F7BFC() & 0x40) != 0)
  {
    sub_18F203148(*(_QWORD *)(a1 + 352), (uint64_t)sub_18F47BC78, a1);
    sub_18F4D3788(*(_QWORD *)(a1 + 352), (uint64_t)sub_18F47C008, a1);
    sub_18F4D3A58(*(_QWORD *)(a1 + 352), (uint64_t)nullsub_159, a1);
    v17 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)(a1 + 368) = v17 + 1;
    if (!v17)
    {
      sub_18F4D4518(*(_QWORD *)(a1 + 352), (const char *)sub_18F47D2DC, a1);
      if (sub_18F1FBD7C(*(_QWORD *)(a1 + 352)))
        sub_18F47D300((_QWORD *)a1);
      sub_18F47D53C(a1);
    }
    if (a2 <= 1)
    {
      sub_18F203AF8((uint64_t)*v8, 1);
      goto LABEL_57;
    }
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v18 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      *(_QWORD *)&buf = 0x204020100;
      _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_FAULT, "Unrecognized notification request %{public}u", (uint8_t *)&buf, 8u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_57;
    bzero(&buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v25 = 67240192;
    v26 = 2;
    v19 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "virtual void CLOrientationNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v19);
LABEL_64:
    if (v19 != (char *)&buf)
      free(v19);
    goto LABEL_57;
  }
  if (a2 == 1)
  {
    sub_18F47C034(a1, 1);
    goto LABEL_57;
  }
  if (a2)
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v20 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_FAULT, "Unrecognized notification", (uint8_t *)&buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_57;
    bzero(&buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    LOWORD(v25) = 0;
    v19 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "virtual void CLOrientationNotifier::numberOfSpectatorsChanged(int, size_t)", "CoreLocation: %s\n", v19);
    goto LABEL_64;
  }
  sub_18F47C034(a1, 0);
LABEL_57:
  if (!*(_QWORD *)(a1 + 392))
  {
    v21 = (_QWORD *)operator new();
    *v21 = off_1E294C238;
    *v21 = &off_1E294C858;
    v21[1] = 0;
    v21[2] = sub_18F47CE0C;
    v21[3] = a1;
    *(_QWORD *)(a1 + 392) = v21;
    v22 = sub_18F3918E4();
    sub_18F1F4F0C(v22, 0, *(_QWORD *)(a1 + 392), -1.0);
  }
  *(_BYTE *)(a1 + 33) = 1;
}

void sub_18F47BC4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_18F47BC78(uint64_t a1)
{
  uint64_t IntegerValue;
  NSObject *v3;
  char *v4;
  NSObject *v5;
  unint64_t v6;
  unint64_t TimeStamp;
  double v8;
  uint8_t buf[4];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 48))
    return;
  if (IOHIDEventGetType() != 10)
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v5 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v10) = IOHIDEventGetType();
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "Received wrong event type %{public}u", buf, 8u);
    }
    if (!sub_18F1FCA08(115, 2))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    IOHIDEventGetType();
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::onIohidEvent(void *, void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v4);
    if (v4 == (char *)buf)
      return;
LABEL_23:
    free(v4);
    return;
  }
  IntegerValue = IOHIDEventGetIntegerValue();
  if ((unint64_t)(IntegerValue - 107) > 0xFFFFFFFFFFFFFFF8)
  {
    v6 = sub_18F4E3A64();
    TimeStamp = IOHIDEventGetTimeStamp();
    v8 = sub_18F1FD20C(TimeStamp);
    sub_18F47FE00(a1, v6, (IntegerValue - 100), v8);
    return;
  }
  if (qword_1ECEDEE28 != -1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
  v3 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134349056;
    v10 = IntegerValue;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_ERROR, "Received invalid orientation %{public}ld", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::onIohidEvent(void *, void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      goto LABEL_23;
  }
}

uint64_t sub_18F47C008(NSObject *a1)
{
  sub_18F47E4C0(a1);
  return sub_18F47F5E4((uint64_t)a1, 1);
}

void sub_18F47C034(uint64_t a1, int a2)
{
  _QWORD *v4;
  unsigned int v5;
  int v6;
  NSObject *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  char v23;
  unint64_t *v24;
  unint64_t v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  NSObject *v37;
  int v38;
  uint64_t v39;
  NSObject *v40;
  double v41;
  int v42;
  int v43;
  _QWORD *v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  _BYTE buf[18];
  __int16 v57;
  double v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD **)(a1 + 40);
  if (v4)
  {
    sub_18F1EB0F0(v4 + 90);
    sub_18F1EB0F0(v4 + 61);
    sub_18F1EB0F0(v4 + 32);
    sub_18F1EB0F0(v4 + 3);
    MEMORY[0x194001438](v4, 0x1080C40300B9403);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v5 = *(unsigned __int8 *)(a1 + 32);
  if (v5 < 2)
    v6 = 1;
  else
    v6 = a2;
  if (v6 == 1)
  {
    if (v5 >= 2 && a2 != 0)
    {
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v8 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(unsigned __int8 *)(a1 + 32);
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&buf[4] = v9;
        _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEFAULT, "forceAccelOnly for device %{public}d", buf, 8u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v54 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::startDetection(BOOL)", "CoreLocation: %s\n", v54);
        if (v54 != buf)
          free(v54);
      }
      *(_BYTE *)(a1 + 32) = 0;
    }
    *(_DWORD *)(a1 + 56) = 1092616192;
    *(_DWORD *)(a1 + 76) = 1;
    *(_QWORD *)(a1 + 88) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 56) = 0x41A0000041C80000;
    v10 = sub_18F204AE4();
    v11 = *(_QWORD *)(v10 + 24);
    v12 = *(std::__shared_weak_count **)(v10 + 32);
    *(_QWORD *)buf = v11;
    *(_QWORD *)&buf[8] = v12;
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    sub_18F1EE8D4(v11, "OrientationGyroTimeout", (void *)(a1 + 88));
    if (v12)
    {
      v15 = (unint64_t *)&v12->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    v17 = *(double *)(a1 + 88);
    *(_BYTE *)(a1 + 80) = v17 > 0.0;
    if (v17 > 0.0)
    {
      *(_QWORD *)(a1 + 112) = 8;
      *(_QWORD *)(a1 + 128) = 8;
      sub_18F1E6174((_QWORD *)(a1 + 120));
      *(_QWORD *)(a1 + 200) = 8;
      sub_18F1E6174((_QWORD *)(a1 + 192));
      *(_QWORD *)(a1 + 272) = 8;
      sub_18F1E6174((_QWORD *)(a1 + 264));
      *(_DWORD *)(a1 + 76) = 2;
    }
    v18 = sub_18F204AE4();
    v19 = *(_QWORD *)(v18 + 24);
    v20 = *(std::__shared_weak_count **)(v18 + 32);
    *(_QWORD *)buf = v19;
    *(_QWORD *)&buf[8] = v20;
    if (v20)
    {
      v21 = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
    }
    v23 = sub_18F1EDFCC(v19, "OrientationStableVariance", (float *)(a1 + 84));
    if (v20)
    {
      v24 = (unint64_t *)&v20->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    if ((v23 & 1) == 0)
      *(_DWORD *)(a1 + 84) = 961656599;
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v26 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
    {
      v27 = *(_QWORD *)(a1 + 88);
      v28 = *(unsigned __int8 *)(a1 + 80);
      v29 = *(float *)(a1 + 84);
      *(_DWORD *)buf = 134349568;
      *(_QWORD *)&buf[4] = v27;
      *(_WORD *)&buf[12] = 1026;
      *(_DWORD *)&buf[14] = v28;
      v57 = 2050;
      v58 = v29;
      _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_INFO, "fOrientationGyroTimeout,%{public}f,fEnableGyroTimeout,%{public}d,fMaxAccelerationVarianceForStability,%{public}f", buf, 0x1Cu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v51 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::startDetection(BOOL)", "CoreLocation: %s\n", v51);
      if (v51 != buf)
        free(v51);
    }
  }
  v30 = sub_18F204AE4();
  v31 = *(_QWORD *)(v30 + 24);
  v32 = *(std::__shared_weak_count **)(v30 + 32);
  *(_QWORD *)buf = v31;
  *(_QWORD *)&buf[8] = v32;
  if (v32)
  {
    v33 = (unint64_t *)&v32->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  sub_18F1E4DFC(v31, "OrientationAccelDecimation", (_DWORD *)(a1 + 76));
  if (v32)
  {
    v35 = (unint64_t *)&v32->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a1 + 76);
  if (*(float *)(a1 + 56) <= 0.0)
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v48 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v48, OS_LOG_TYPE_FAULT, "Not starting orientation detection since requested accelerometer frequency < 0", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 == -1)
    {
LABEL_107:
      v55 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::startDetection(BOOL)", "CoreLocation: %s\n", v55);
      if (v55 != buf)
        free(v55);
      return;
    }
LABEL_109:
    dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    goto LABEL_107;
  }
  if (!sub_18F1DFF7C())
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v49 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v49, OS_LOG_TYPE_FAULT, "No accelerometer; not detecting orientation!", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 == -1)
      goto LABEL_107;
    goto LABEL_109;
  }
  if ((v6 & 1) != 0 || sub_18F1EF73C())
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v37 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
    {
      v38 = *(unsigned __int8 *)(a1 + 34);
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&buf[4] = v38;
      _os_log_impl(&dword_18F1DC000, v37, OS_LOG_TYPE_DEFAULT, "fHasSeenACaseLatchCoverOnce, %{public}d", buf, 8u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v52 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::startDetection(BOOL)", "CoreLocation: %s\n", v52);
      if (v52 != buf)
        free(v52);
    }
    v39 = operator new();
    sub_18F4A571C(v39, *(unsigned __int8 *)(a1 + 32), *(_BYTE *)(a1 + 34));
    *(_QWORD *)(a1 + 40) = v39;
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v40 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
    {
      v41 = *(float *)(a1 + 56);
      v42 = *(unsigned __int8 *)(a1 + 32);
      v43 = *(_DWORD *)(a1 + 76);
      *(_DWORD *)buf = 134349568;
      *(double *)&buf[4] = v41;
      *(_WORD *)&buf[12] = 1026;
      *(_DWORD *)&buf[14] = v42;
      v57 = 1026;
      LODWORD(v58) = v43;
      _os_log_impl(&dword_18F1DC000, v40, OS_LOG_TYPE_DEFAULT, "Starting orientation detection with accelFrequency %{public}f, form factor, %{public}d, decimationRate, %{public}d", buf, 0x18u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v53 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::startDetection(BOOL)", "CoreLocation: %s\n", v53);
      if (v53 != buf)
        free(v53);
    }
    if (!*(_QWORD *)(a1 + 48))
    {
      v44 = (_QWORD *)operator new();
      *v44 = off_1E294C238;
      *v44 = &off_1E294C3C0;
      v44[1] = 0;
      v44[2] = sub_18F47EA94;
      v44[3] = a1;
      *(_QWORD *)(a1 + 48) = v44;
      *(_QWORD *)(a1 + 336) = 0xFFEFFFFFFFFFFFFFLL;
      CFAbsoluteTimeGetCurrent();
      kdebug_trace();
      v45 = sub_18F1DFF7C();
      sub_18F1F4F0C(v45, 0, *(_QWORD *)(a1 + 48), 0.00999999978);
    }
    if ((v6 & 1) == 0 && !*(_QWORD *)(a1 + 64))
    {
      v46 = (_QWORD *)operator new();
      *v46 = off_1E294C238;
      *v46 = &off_1E294C820;
      v46[1] = 0;
      v46[2] = sub_18F47F1F0;
      v46[3] = a1;
      *(_QWORD *)(a1 + 64) = v46;
      *(_QWORD *)(a1 + 344) = 0xFFEFFFFFFFFFFFFFLL;
      CFAbsoluteTimeGetCurrent();
      kdebug_trace();
      v47 = sub_18F1EF73C();
      sub_18F1F4F0C(v47, 0, *(_QWORD *)(a1 + 64), (float)(1.0 / *(float *)(a1 + 60)));
    }
    return;
  }
  if (qword_1ECEDEE28 != -1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
  v50 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v50, OS_LOG_TYPE_FAULT, "No gyro; not detecting orientation!", buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 == -1)
      goto LABEL_107;
    goto LABEL_109;
  }
}

void sub_18F47CDA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_18F47CE0C(_BYTE *a1, uint64_t a2)
{
  NSObject *v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  mach_error_t v9;
  mach_error_t v10;
  NSObject *v11;
  char *v12;
  int v13;
  char *v14;
  int v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char v20;
  __int16 v21;
  int v22;
  char *v23;
  __int16 v24;
  mach_error_t v25;
  uint8_t buf[4];
  char *v27;
  __int16 v28;
  mach_error_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE28 != -1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
  v4 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
  {
    v5 = *a1;
    *(_DWORD *)buf = 67240192;
    LODWORD(v27) = v5;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "Received keyboard state %{public}u", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v13 = *a1;
    v22 = 67240192;
    LODWORD(v23) = v13;
    v14 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "static void CLOrientationNotifier::onKeyboardState(const BOOL *, void *)", "CoreLocation: %s\n", v14);
    if (v14 != (char *)buf)
      free(v14);
  }
  v6 = *(_QWORD *)(a2 + 40);
  if (v6)
    *(_BYTE *)(v6 + 1036) = *a1;
  if (*(_QWORD *)(a2 + 384))
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v7 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
    {
      v8 = *a1;
      *(_DWORD *)buf = 67109120;
      LODWORD(v27) = v8;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_INFO, "Sending keyboard state %u to AOP", buf, 8u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v15 = *a1;
      v22 = 67109120;
      LODWORD(v23) = v15;
      v16 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLOrientationNotifier::onKeyboardState(const BOOL *, void *)", "CoreLocation: %s\n", v16);
      if (v16 != (char *)buf)
        free(v16);
    }
    v21 = 5;
    HIBYTE(v21) = *a1;
    v20 = 0;
    v19 = 1;
    v9 = (*(uint64_t (**)(_QWORD, uint64_t, __int16 *, uint64_t, char *, uint64_t *))(**(_QWORD **)(a2 + 384)
                                                                                           + 160))(*(_QWORD *)(a2 + 384), 32, &v21, 2, &v20, &v19);
    if (v9)
    {
      v10 = v9;
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v11 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
      {
        v12 = mach_error_string(v10);
        *(_DWORD *)buf = 136315394;
        v27 = v12;
        v28 = 1026;
        v29 = v10;
        _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_FAULT, "SendCommand() = %s (0x%{public}x)", buf, 0x12u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v17 = mach_error_string(v10);
        v22 = 136315394;
        v23 = v17;
        v24 = 1026;
        v25 = v10;
        v18 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "static void CLOrientationNotifier::onKeyboardState(const BOOL *, void *)", "CoreLocation: %s\n", v18);
        if (v18 != (char *)buf)
          free(v18);
      }
    }
  }
}

void sub_18F47D2DC(NSObject *a1)
{
  sub_18F47D300(a1);
  sub_18F47D53C(a1);
}

void sub_18F47D300(_QWORD *a1)
{
  CFRunLoopRef Current;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  IOCFPlugInInterface ***v6;
  uint64_t v7;
  char *v8;
  _QWORD v9[5];
  __int16 v10;
  uint8_t buf[1640];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current == *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (a1[44])
    {
      v5 = a1[48];
      if (v5)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 72))(v5, 0);
      v6 = (IOCFPlugInInterface ***)(a1 + 47);
      v7 = a1[47];
      if (v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
        IODestroyPlugInInterface(*v6);
      }
      *(_QWORD *)(a1[44] + 8) = 0;
      *v6 = 0;
      a1[48] = 0;
    }
  }
  else
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v3 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_FAULT, "closeHidDriverInterface should be called from motion thread", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v10 = 0;
      v8 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::closeHidDriverInterface()", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf)
        free(v8);
    }
    v4 = sub_18F204AE4();
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = sub_18F47EA8C;
    v9[3] = &unk_1E2955738;
    v9[4] = a1;
    sub_18F1F5E28(v4, (uint64_t)v9);
  }
}

void sub_18F47D53C(NSObject *a1)
{
  CFRunLoopRef Current;
  NSObject *v3;
  uint64_t v4;
  uint64_t isa;
  __IOHIDServiceClient *v6;
  __IOHIDServiceClient *v7;
  const __CFNumber *RegistryID;
  mach_port_t v9;
  const __CFDictionary *v10;
  io_service_t MatchingService;
  io_object_t v12;
  kern_return_t ParentEntry;
  mach_error_t v14;
  NSObject *v15;
  char *v16;
  io_registry_entry_t v17;
  NSObject *v18;
  uint8_t *v19;
  NSObject *v20;
  kern_return_t v21;
  mach_error_t v22;
  NSObject *v23;
  char *v24;
  io_service_t v25;
  const __CFAllocator *v26;
  const __CFUUID *v27;
  const __CFUUID *v28;
  kern_return_t v29;
  mach_error_t v30;
  NSObject *v31;
  char *v32;
  char *v33;
  IOCFPlugInInterface **v34;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  const __CFUUID *v36;
  CFUUIDBytes v37;
  mach_error_t v38;
  mach_error_t v39;
  NSObject *v40;
  char *v41;
  mach_error_t v42;
  mach_error_t v43;
  NSObject *v44;
  char *v45;
  NSObject *v46;
  Class v47;
  Class v48;
  objc_class *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  char *v58;
  Class v59;
  Class v60;
  char *v61;
  io_registry_entry_t v62;
  io_registry_entry_t parent;
  SInt32 theScore;
  objc_class *v65;
  IOCFPlugInInterface **theInterface;
  uint64_t valuePtr;
  _QWORD v68[5];
  int v69;
  _BYTE v70[28];
  __int16 v71;
  IOCFPlugInInterface **v72;
  __int16 v73;
  objc_class *v74;
  uint8_t buf[4];
  _BYTE v76[28];
  __int16 v77;
  IOCFPlugInInterface **v78;
  __int16 v79;
  objc_class *v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v3 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_FAULT, "openHidDriverInterface should be called from motion thread", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      LOWORD(v69) = 0;
      v50 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::openHidDriverInterface()", "CoreLocation: %s\n", v50);
      if (v50 != (char *)buf)
        free(v50);
    }
    v4 = sub_18F204AE4();
    v68[0] = MEMORY[0x1E0C809B0];
    v68[1] = 3221225472;
    v68[2] = sub_18F47E4B8;
    v68[3] = &unk_1E2955738;
    v68[4] = a1;
    sub_18F1F5E28(v4, (uint64_t)v68);
    return;
  }
  isa = (uint64_t)a1[44].isa;
  if (!isa)
    return;
  theInterface = 0;
  valuePtr = 0;
  v65 = 0;
  v6 = (__IOHIDServiceClient *)sub_18F1FBD7C(isa);
  if (v6)
  {
    v7 = v6;
    RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(v6);
    CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
    theScore = 0;
    v9 = *MEMORY[0x1E0CBBAA8];
    v10 = IORegistryEntryIDMatching(valuePtr);
    MatchingService = IOServiceGetMatchingService(v9, v10);
    if (MatchingService)
    {
      v12 = MatchingService;
      v62 = 0;
      parent = 0;
      ParentEntry = IORegistryEntryGetParentEntry(MatchingService, "IOService", &parent);
      if (ParentEntry)
      {
        v14 = ParentEntry;
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v15 = off_1ECEDEE20;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
        {
          v16 = mach_error_string(v14);
          *(_DWORD *)buf = 67240450;
          *(_DWORD *)v76 = v14;
          *(_WORD *)&v76[4] = 2082;
          *(_QWORD *)&v76[6] = v16;
          _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_FAULT, "Unable to get parent of orientation service,retCode,0x%{public}x,retStr,%{public}s", buf, 0x12u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
          v51 = mach_error_string(v14);
          v69 = 67240450;
          *(_DWORD *)v70 = v14;
          *(_WORD *)&v70[4] = 2082;
          *(_QWORD *)&v70[6] = v51;
          v52 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::openHidDriverInterface()", "CoreLocation: %s\n", v52);
          if (v52 != (char *)buf)
            free(v52);
        }
        v17 = v12;
LABEL_45:
        IOObjectRelease(v17);
        return;
      }
      IOObjectRelease(v12);
      v21 = IORegistryEntryGetParentEntry(parent, "IOService", &v62);
      if (v21)
      {
        v22 = v21;
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v23 = off_1ECEDEE20;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
        {
          v24 = mach_error_string(v22);
          *(_DWORD *)buf = 67240450;
          *(_DWORD *)v76 = v22;
          *(_WORD *)&v76[4] = 2082;
          *(_QWORD *)&v76[6] = v24;
          _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_FAULT, "Unable to get grand parent of orientation service,retCode,0x%{public}x,retStr,%{public}s", buf, 0x12u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
          v53 = mach_error_string(v22);
          v69 = 67240450;
          *(_DWORD *)v70 = v22;
          *(_WORD *)&v70[4] = 2082;
          *(_QWORD *)&v70[6] = v53;
          v54 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::openHidDriverInterface()", "CoreLocation: %s\n", v54);
          if (v54 != (char *)buf)
            free(v54);
        }
        v17 = parent;
        goto LABEL_45;
      }
      IOObjectRelease(parent);
      v25 = v62;
      v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE30];
      v27 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 0x7Au, 0xCFu, 0x53u, 0x32u, 0x1Au, 0x35u, 0x48u, 0x93u, 0x87u, 0xCBu, 0xBAu, 0x64u, 0xE1u, 0x88u, 0x7Fu, 0xAEu);
      v28 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
      v29 = IOCreatePlugInInterfaceForService(v25, v27, v28, &theInterface, &theScore);
      if (!v29)
      {
        v34 = theInterface;
        QueryInterface = (*theInterface)->QueryInterface;
        v36 = CFUUIDGetConstantUUIDWithBytes(v26, 1u, 0x64u, 0x69u, 0xD8u, 0x77u, 0x3Bu, 0x46u, 0xACu, 0x90u, 0x9Eu, 0xF9u, 0xCu, 0x4Au, 0x6Eu, 0x75u, 0x77u);
        v37 = CFUUIDGetUUIDBytes(v36);
        v38 = ((uint64_t (*)(IOCFPlugInInterface **, _QWORD, _QWORD, objc_class **))QueryInterface)(v34, *(_QWORD *)&v37.byte0, *(_QWORD *)&v37.byte8, &v65);
        if (v38)
        {
          v39 = v38;
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
          v40 = off_1ECEDEE20;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
          {
            v41 = mach_error_string(v39);
            *(_DWORD *)buf = 67240706;
            *(_DWORD *)v76 = v39;
            *(_WORD *)&v76[4] = 2082;
            *(_QWORD *)&v76[6] = v41;
            *(_WORD *)&v76[14] = 2114;
            *(_QWORD *)&v76[16] = v7;
            _os_log_impl(&dword_18F1DC000, v40, OS_LOG_TYPE_FAULT, "Unable to set up query interface,retCode,0x%{public}x,retStr,%{public}s,service,%{public}@", buf, 0x1Cu);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
            v55 = mach_error_string(v39);
            v69 = 67240706;
            *(_DWORD *)v70 = v39;
            *(_WORD *)&v70[4] = 2082;
            *(_QWORD *)&v70[6] = v55;
            *(_WORD *)&v70[14] = 2114;
            *(_QWORD *)&v70[16] = v7;
            v56 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::openHidDriverInterface()", "CoreLocation: %s\n", v56);
            if (v56 != (char *)buf)
              free(v56);
          }
        }
        else
        {
          v42 = (*(uint64_t (**)(objc_class *, _QWORD))(*(_QWORD *)v65 + 64))(v65, 0);
          if (!v42)
          {
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
            v46 = off_1ECEDEE20;
            if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
            {
              v47 = a1[47].isa;
              v48 = a1[48].isa;
              *(_DWORD *)buf = 134219008;
              *(_QWORD *)v76 = valuePtr;
              *(_WORD *)&v76[8] = 2048;
              *(_QWORD *)&v76[10] = v47;
              *(_WORD *)&v76[18] = 2048;
              *(_QWORD *)&v76[20] = v48;
              v77 = 2048;
              v78 = theInterface;
              v79 = 2048;
              v80 = v65;
              _os_log_impl(&dword_18F1DC000, v46, OS_LOG_TYPE_DEFAULT, "Opened hid driver interface, registryID %llx, {cfPlugInInterface, hidDriverInterface} was then {%p,%p}, is now {%p,%p}", buf, 0x34u);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE28 != -1)
                dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
              v59 = a1[47].isa;
              v60 = a1[48].isa;
              v69 = 134219008;
              *(_QWORD *)v70 = valuePtr;
              *(_WORD *)&v70[8] = 2048;
              *(_QWORD *)&v70[10] = v59;
              *(_WORD *)&v70[18] = 2048;
              *(_QWORD *)&v70[20] = v60;
              v71 = 2048;
              v72 = theInterface;
              v73 = 2048;
              v74 = v65;
              v61 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::openHidDriverInterface()", "CoreLocation: %s\n", v61);
              if (v61 != (char *)buf)
                free(v61);
            }
            *((_QWORD *)a1[44].isa + 1) = valuePtr;
            v49 = v65;
            a1[47].isa = (Class)theInterface;
            a1[48].isa = v49;
            sub_18F47E4C0(a1);
            return;
          }
          v43 = v42;
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
          v44 = off_1ECEDEE20;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
          {
            v45 = mach_error_string(v43);
            *(_DWORD *)buf = 67240706;
            *(_DWORD *)v76 = v43;
            *(_WORD *)&v76[4] = 2082;
            *(_QWORD *)&v76[6] = v45;
            *(_WORD *)&v76[14] = 2114;
            *(_QWORD *)&v76[16] = v7;
            _os_log_impl(&dword_18F1DC000, v44, OS_LOG_TYPE_FAULT, "Unable to open hid device interface,retCode,0x%{public}x,retStr,%{public}s,service,%{public}@", buf, 0x1Cu);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
            v57 = mach_error_string(v43);
            v69 = 67240706;
            *(_DWORD *)v70 = v43;
            *(_WORD *)&v70[4] = 2082;
            *(_QWORD *)&v70[6] = v57;
            *(_WORD *)&v70[14] = 2114;
            *(_QWORD *)&v70[16] = v7;
            v58 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::openHidDriverInterface()", "CoreLocation: %s\n", v58);
            if (v58 != (char *)buf)
              free(v58);
          }
          if (v65)
            (*(void (**)(objc_class *, _QWORD))(*(_QWORD *)v65 + 72))(v65, 0);
        }
        if (theInterface)
        {
          ((void (*)(IOCFPlugInInterface **))(*theInterface)->Release)(theInterface);
          IODestroyPlugInInterface(theInterface);
        }
        return;
      }
      v30 = v29;
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v31 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
      {
        v32 = mach_error_string(v30);
        *(_DWORD *)buf = 67240706;
        *(_DWORD *)v76 = v30;
        *(_WORD *)&v76[4] = 2082;
        *(_QWORD *)&v76[6] = v32;
        *(_WORD *)&v76[14] = 2114;
        *(_QWORD *)&v76[16] = v7;
        _os_log_impl(&dword_18F1DC000, v31, OS_LOG_TYPE_FAULT, "Unable to create plugin interface,retCode,0x%{public}x,retStr,%{public}s,service,%{public}@", buf, 0x1Cu);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v33 = mach_error_string(v30);
        v69 = 67240706;
        *(_DWORD *)v70 = v30;
        *(_WORD *)&v70[4] = 2082;
        *(_QWORD *)&v70[6] = v33;
        *(_WORD *)&v70[14] = 2114;
        *(_QWORD *)&v70[16] = v7;
LABEL_35:
        v19 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::openHidDriverInterface()", "CoreLocation: %s\n");
LABEL_36:
        if (v19 != buf)
          free(v19);
      }
    }
    else
    {
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v20 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_FAULT, "AOP service doesn't exist", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        LOWORD(v69) = 0;
        goto LABEL_35;
      }
    }
  }
  else
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v18 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_INFO, "IoHidDevice is not ready!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      LOWORD(v69) = 0;
      v19 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::openHidDriverInterface()", "CoreLocation: %s\n");
      goto LABEL_36;
    }
  }
}

uint64_t sub_18F47E4B8(uint64_t a1)
{
  return sub_18F47D53C(*(_QWORD *)(a1 + 32));
}

void sub_18F47E4C0(NSObject *a1)
{
  int v1;
  int isa_low;
  CFRunLoopRef Current;
  NSObject *v5;
  mach_error_t v6;
  mach_error_t v7;
  NSObject *v8;
  char *v9;
  NSObject *v10;
  NSObject *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _BYTE v16[3];
  int v17;
  _BYTE v18[10];
  mach_error_t v19;
  uint8_t buf[4];
  _BYTE v21[14];
  __int16 v22;
  const char *v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current == *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    v16[0] = 4;
    isa_low = LOBYTE(a1[4].isa);
    v16[1] = a1[4].isa;
    v1 = BYTE2(a1[4].isa);
    v16[2] = BYTE2(a1[4].isa);
    if (qword_1ECEDEE28 == -1)
      goto LABEL_3;
  }
  else
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v10 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v21 = 0;
      *(_WORD *)&v21[4] = 2082;
      *(_QWORD *)&v21[6] = "";
      v22 = 2082;
      v23 = "assert";
      v24 = 2081;
      v25 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"sendConfiguration should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    }
    v11 = off_1ECEDEE20;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE20))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v21 = 0;
      *(_WORD *)&v21[4] = 2082;
      *(_QWORD *)&v21[6] = "";
      v22 = 2082;
      v23 = "assert";
      v24 = 2081;
      v25 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "sendConfiguration should be running on motion thread", "{\"msg%{public}.0s\":\"sendConfiguration should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    }
    a1 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)v21 = 0;
      *(_WORD *)&v21[4] = 2082;
      *(_QWORD *)&v21[6] = "";
      v22 = 2082;
      v23 = "assert";
      v24 = 2081;
      v25 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, a1, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"sendConfiguration should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
LABEL_3:
  v5 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67240448;
    *(_DWORD *)v21 = isa_low;
    *(_WORD *)&v21[4] = 1026;
    *(_DWORD *)&v21[6] = v1;
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "Sending config,formFactor,%{public}d,handleCover,%{public}d", buf, 0xEu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v17 = 67240448;
    *(_DWORD *)v18 = isa_low;
    *(_WORD *)&v18[4] = 1026;
    *(_DWORD *)&v18[6] = v1;
    v12 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::sendConfiguration()", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf)
      free(v12);
  }
  v15 = 3;
  v6 = (*(uint64_t (**)(Class, uint64_t, _BYTE *, uint64_t, _BYTE *, uint64_t *))(*(_QWORD *)a1[48].isa + 160))(a1[48].isa, 32, v16, 3, v16, &v15);
  if (v6)
  {
    v7 = v6;
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v8 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      v9 = mach_error_string(v7);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)v21 = v9;
      *(_WORD *)&v21[8] = 1026;
      *(_DWORD *)&v21[10] = v7;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "SendCommand(Config) = %{public}s (0x%{public}x)", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v13 = mach_error_string(v7);
      v17 = 136446466;
      *(_QWORD *)v18 = v13;
      *(_WORD *)&v18[8] = 1026;
      v19 = v7;
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLOrientationNotifier::sendConfiguration()", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
    }
  }
}

uint64_t sub_18F47EA8C(uint64_t a1)
{
  return sub_18F47D300(*(_QWORD *)(a1 + 32));
}

void sub_18F47EA94(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  NSObject *v9;
  unint64_t v10;
  float v11;
  float v12;
  float v13;
  unint64_t v14;
  float v15;
  unint64_t v16;
  float v17;
  float v18;
  NSObject *v19;
  _QWORD *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  double v30;
  int v31;
  uint8_t buf[8];
  uint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  double *v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (*(double *)(a2 + 336) == -1.79769313e308)
  {
    CFAbsoluteTimeGetCurrent();
    kdebug_trace();
    *(CFAbsoluteTime *)(a2 + 336) = CFAbsoluteTimeGetCurrent();
    if (*(_QWORD *)(a2 + 48))
    {
      v4 = sub_18F1DFF7C();
      v5 = *(_QWORD *)(a2 + 48);
      v30 = (float)(1.0 / (float)(*(float *)(a2 + 56) * (float)*(int *)(a2 + 76)));
      v6 = sub_18F204AE4();
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v33 = 3221225472;
      v34 = sub_18F20741C;
      v35 = &unk_1E2956EB8;
      v39 = 0;
      v36 = v4;
      v37 = v5;
      v38 = &v30;
      sub_18F1F5E28(v6, (uint64_t)buf);
    }
  }
  v7 = *(_DWORD *)(a2 + 72);
  v8 = __OFSUB__(v7--, 1);
  *(_DWORD *)(a2 + 72) = v7;
  if ((v7 < 0) ^ v8 | (v7 == 0))
  {
    *(_DWORD *)(a2 + 72) = *(_DWORD *)(a2 + 76);
    sub_18F4A5D64(*(_QWORD *)(a2 + 40), (float *)(a1 + 8), (_QWORD *)a1);
    if (sub_18F4A8054(*(unsigned __int8 **)(a2 + 40), &v31, &v30))
    {
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v9 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "Sending orientation changed notification", buf, 2u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v27 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "static void CLOrientationNotifier::onAccelerometerData(const CLAccelerometer::Sample *, void *)", "CoreLocation: %s\n", v27);
        if (v27 != (char *)buf)
          free(v27);
      }
      sub_18F1E5A28(a2, 0, (uint64_t)&v30, 16);
      sub_18F1E5A28(a2, 1, (uint64_t)&v30, 16);
    }
  }
  if (*(_BYTE *)(a2 + 80))
  {
    sub_18F1FD65C(a2 + 120, (float *)(a1 + 8));
    sub_18F1FD65C(a2 + 192, (float *)(a1 + 12));
    sub_18F1FD65C(a2 + 264, (float *)(a1 + 16));
    v10 = *(_QWORD *)(a2 + 184);
    if (v10 < *(_QWORD *)(a2 + 128))
      goto LABEL_29;
    v11 = 0.0;
    v12 = 0.0;
    if (v10 >= 2)
    {
      v13 = (float)((float)v10 * *(float *)(a2 + 140)) - (float)(*(float *)(a2 + 136) * *(float *)(a2 + 136));
      v12 = 0.0;
      if (v13 >= 0.0)
        v12 = v13 / (float)((v10 - 1) * v10);
    }
    v14 = *(_QWORD *)(a2 + 256);
    if (v14 >= 2)
    {
      v15 = (float)((float)v14 * *(float *)(a2 + 212)) - (float)(*(float *)(a2 + 208) * *(float *)(a2 + 208));
      if (v15 >= 0.0)
        v11 = v15 / (float)((v14 - 1) * v14);
    }
    v16 = *(_QWORD *)(a2 + 328);
    v17 = 0.0;
    if (v16 >= 2)
    {
      v18 = (float)((float)v16 * *(float *)(a2 + 284)) - (float)(*(float *)(a2 + 280) * *(float *)(a2 + 280));
      if (v18 >= 0.0)
        v17 = v18 / (float)((v16 - 1) * v16);
    }
    if (v12 >= v11)
      v11 = v12;
    if (v11 < v17)
      v11 = v17;
    if (v11 <= *(float *)(a2 + 84))
    {
      if (*(_QWORD *)(a2 + 64) && *(double *)a1 > *(double *)(a2 + 96) + *(double *)(a2 + 88))
      {
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v22 = off_1ECEDEE20;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_INFO, "Device is stationary and OrientationGyroTimeout exceeded, disabling Gyro.", buf, 2u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
          LOWORD(v30) = 0;
          v29 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "static void CLOrientationNotifier::onAccelerometerData(const CLAccelerometer::Sample *, void *)", "CoreLocation: %s\n", v29);
          if (v29 != (char *)buf)
            free(v29);
        }
        v23 = sub_18F1EF73C();
        v24 = *(_QWORD *)(a2 + 64);
        v25 = sub_18F204AE4();
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        v33 = 3221225472;
        v34 = sub_18F1F5EE0;
        v35 = &unk_1E2956E98;
        LODWORD(v38) = 0;
        v36 = v23;
        v37 = v24;
        sub_18F1F5E28(v25, (uint64_t)buf);
        v26 = *(_QWORD *)(a2 + 64);
        if (v26)
          (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
        *(_QWORD *)(a2 + 64) = 0;
        sub_18F4AA248(*(_QWORD *)(a2 + 40));
      }
    }
    else
    {
LABEL_29:
      *(_QWORD *)(a2 + 96) = *(_QWORD *)a1;
      if (!*(_QWORD *)(a2 + 64))
      {
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v19 = off_1ECEDEE20;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_INFO, "Device is in motion, re-enabling Gyro.", buf, 2u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
          LOWORD(v30) = 0;
          v28 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "static void CLOrientationNotifier::onAccelerometerData(const CLAccelerometer::Sample *, void *)", "CoreLocation: %s\n", v28);
          if (v28 != (char *)buf)
            free(v28);
        }
        v20 = (_QWORD *)operator new();
        *v20 = off_1E294C238;
        *v20 = &off_1E294C820;
        v20[1] = 0;
        v20[2] = sub_18F47F1F0;
        v20[3] = a2;
        *(_QWORD *)(a2 + 64) = v20;
        v21 = sub_18F1EF73C();
        sub_18F1F4F0C(v21, 0, *(_QWORD *)(a2 + 64), (float)(1.0 / *(float *)(a2 + 60)));
        sub_18F4AA420(*(_QWORD *)(a2 + 40));
      }
    }
  }
}

void sub_18F47F1C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_18F47F1F0(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  char *v5;
  uint64_t v6;
  int v7;
  uint8_t buf[1640];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*(double *)(a2 + 344) == -1.79769313e308)
  {
    CFAbsoluteTimeGetCurrent();
    kdebug_trace();
    *(CFAbsoluteTime *)(a2 + 344) = CFAbsoluteTimeGetCurrent();
  }
  sub_18F4A6180(*(_QWORD *)(a2 + 40), (float *)(a1 + 8), (double *)a1);
  if (!*(_QWORD *)(a2 + 48) && sub_18F4A8054(*(unsigned __int8 **)(a2 + 40), &v7, &v6))
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v4 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "GYRO: Sending orientation changed notification", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLOrientationNotifier::onGyroData(const CLGyro::Sample *, void *)", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    sub_18F1E5A28(a2, 0, (uint64_t)&v6, 16);
  }
}

void sub_18F47F404(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  char *v4;
  uint8_t buf[4];
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (CFStringCompare(*(CFStringRef *)(a1 + 48), CFSTR("com.apple.springboard.HasSeenACaseLatchCoverNotification"), 0) == kCFCompareEqualTo)
  {
    *(_BYTE *)(v1 + 34) = 1;
    if (*(_QWORD *)(v1 + 384))
      sub_18F47E4C0(v1);
  }
  if (qword_1ECEDEE28 != -1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
  v2 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(unsigned __int8 *)(v1 + 34);
    *(_DWORD *)buf = 67240192;
    v6 = v3;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "fHasSeenACaseLatchCoverOnce, %{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::onCoverNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
}

uint64_t sub_18F47F5E4(uint64_t a1, int a2)
{
  double v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  char *v9;
  int v10;
  char *v11;
  int v12;
  char *v13;
  uint64_t *v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  unint64_t v18;
  double v19;
  NSObject *v20;
  NSObject *v21;
  char *v22;
  char *v24;
  int v25;
  char *v26;
  char *v27;
  char *v28;
  int v29;
  _QWORD v30[8];
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t (*v42)(uint64_t, uint64_t);
  uint64_t (*v43)();
  void *v44;
  uint64_t v45;
  __int16 v46;
  int v47;
  char *v48;
  __int16 v49;
  int v50;
  uint8_t buf[4];
  char *v52;
  __int16 v53;
  int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if ((sub_18F1F7BFC() & 0x40) != 0)
  {
    v29 = a2;
    v39 = 0;
    v40 = &v39;
    v41 = 0x4012000000;
    v42 = sub_18F206C84;
    v43 = nullsub_5;
    v5 = 3;
    v46 = 0;
    v44 = &unk_18F58364E;
    v45 = 2;
    v35 = 0;
    v36 = &v35;
    v37 = 0x2020000000;
    v38 = 10;
    v6 = MEMORY[0x1E0C809B0];
    while (1)
    {
      v31 = 0;
      v32 = &v31;
      v33 = 0x2020000000;
      v34 = 0;
      v7 = sub_18F204AE4();
      v30[0] = v6;
      v30[1] = 3221225472;
      v30[2] = sub_18F480160;
      v30[3] = &unk_1E2958A60;
      v30[4] = &v31;
      v30[5] = &v39;
      v30[6] = &v35;
      v30[7] = a1;
      sub_18F1F5E28(v7, (uint64_t)v30);
      if (!*((_DWORD *)v32 + 6))
        break;
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v8 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
      {
        v9 = mach_error_string(*((_DWORD *)v32 + 6));
        v10 = *((_DWORD *)v32 + 6);
        *(_DWORD *)buf = 136315394;
        v52 = v9;
        v53 = 1026;
        v54 = v10;
        _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "SendCommand() = %s (0x%{public}x)", buf, 0x12u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v11 = mach_error_string(*((_DWORD *)v32 + 6));
        v12 = *((_DWORD *)v32 + 6);
        v47 = 136315394;
        v48 = v11;
        v49 = 1026;
        v50 = v12;
        v13 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "CLOrientationNotifier::Sample CLOrientationNotifier::orientationBlocking(const BOOL)", "CoreLocation: %s\n", v13);
        if (v13 != (char *)buf)
          free(v13);
      }
      usleep(0x3E8u);
      _Block_object_dispose(&v31, 8);
      if (!--v5)
      {
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v20 = off_1ECEDEE20;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_FAULT, "No reply for LastOrientation", buf, 2u);
        }
        v4 = -1.0;
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
          LOWORD(v31) = 0;
          v24 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "CLOrientationNotifier::Sample CLOrientationNotifier::orientationBlocking(const BOOL)", "CoreLocation: %s\n", v24);
          if (v24 != (char *)buf)
            free(v24);
        }
        goto LABEL_38;
      }
    }
    if (v36[3] == 10)
    {
      v14 = v40;
      if (*(_QWORD *)(a1 + 402) > *(unint64_t *)((char *)v40 + 50))
      {
        v15 = *(_QWORD *)(a1 + 400);
        *((_WORD *)v40 + 28) = *(_WORD *)(a1 + 408);
        v14[6] = v15;
      }
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v16 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
      {
        v17 = *((unsigned __int8 *)v40 + 49);
        *(_DWORD *)buf = 67240192;
        LODWORD(v52) = v17;
        _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_DEFAULT, "Got cached orientation %{public}u", buf, 8u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v25 = *((unsigned __int8 *)v40 + 49);
        v47 = 67240192;
        LODWORD(v48) = v25;
        v26 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "CLOrientationNotifier::Sample CLOrientationNotifier::orientationBlocking(const BOOL)", "CoreLocation: %s\n", v26);
        if (v26 != (char *)buf)
          free(v26);
      }
      _Block_object_dispose(&v31, 8);
      v18 = *(uint64_t *)((char *)v40 + 50);
      v19 = sub_18F1FD20C(v18);
      v4 = v19;
      if (v29)
        sub_18F47FE00(a1, v18, *((unsigned __int8 *)v40 + 49), v19);
    }
    else
    {
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v21 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
      {
        v22 = (char *)v36[3];
        *(_DWORD *)buf = 134349056;
        v52 = v22;
        _os_log_impl(&dword_18F1DC000, v21, OS_LOG_TYPE_FAULT, "SendCommand() got unexpected response size %{public}zd", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
        v27 = (char *)v36[3];
        v47 = 134349056;
        v48 = v27;
        v28 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "CLOrientationNotifier::Sample CLOrientationNotifier::orientationBlocking(const BOOL)", "CoreLocation: %s\n", v28);
        if (v28 != (char *)buf)
          free(v28);
      }
      _Block_object_dispose(&v31, 8);
      v4 = -1.0;
    }
LABEL_38:
    _Block_object_dispose(&v35, 8);
    _Block_object_dispose(&v39, 8);
  }
  else
  {
    v4 = -1.0;
  }
  return *(_QWORD *)&v4;
}

void sub_18F47FDA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_18F47FE00(uint64_t a1, unint64_t a2, unsigned int a3, double a4)
{
  NSObject *v7;
  NSObject *v8;
  char *v9;
  char *v10;
  double v11;
  _QWORD v12[3];
  uint8_t buf[4];
  unsigned int v14;
  __int16 v15;
  unint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 402) >= a2)
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v8 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67240448;
      v14 = a3;
      v15 = 2050;
      v16 = a2;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEFAULT, "Skipping stale orientation (%{public}u @ %{public}llu)", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      LODWORD(v11) = 67240448;
      HIDWORD(v11) = a3;
      LOWORD(v12[0]) = 2050;
      *(_QWORD *)((char *)v12 + 2) = a2;
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::notifyAOO(const uint64_t, const uint8_t, const CLMotionTypeTimestamp)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 401) = a3;
    *(_QWORD *)(a1 + 402) = a2;
    v11 = a4;
    v12[0] = a3;
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v7 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109120;
      v14 = a3;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEBUG, "AOO update: %u", buf, 8u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationNotifier::notifyAOO(const uint64_t, const uint8_t, const CLMotionTypeTimestamp)", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
    sub_18F1E5A28(a1, 0, (uint64_t)&v11, 16);
    sub_18F1E5A28(a1, 1, (uint64_t)&v11, 16);
  }
}

uint64_t sub_18F480160(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  NSObject *v4;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1[7] + 384);
  if (v2)
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2 + 160))(v2, 32, *(_QWORD *)(a1[5] + 8) + 48, 1, *(_QWORD *)(a1[5] + 8) + 48, *(_QWORD *)(a1[6] + 8) + 24);
  }
  else
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
    v4 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "fHidDeviceInterface NULL", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E29551C8);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "CLOrientationNotifier::Sample CLOrientationNotifier::orientationBlocking(const BOOL)_block_invoke", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
    result = 4160749568;
  }
  *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

os_log_t sub_18F48033C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Orientation");
  off_1ECEDEE20 = result;
  return result;
}

uint64_t sub_18F480368(uint64_t a1)
{

  *(_QWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t sub_18F480398(float32x2_t *a1, float32x2_t *a2, double a3)
{
  uint64_t v5;
  __int32 v6;
  float32x2_t v8;
  __int32 v9;

  sub_18F3F8790(a1 + 3, a2);
  v5 = *(_QWORD *)&a1[7] - 1;
  a1[7] = (float32x2_t)v5;
  if (!v5)
  {
    a1[7] = a1[6];
    v6 = a1[5].i32[0];
    v8 = a1[4];
    v9 = v6;
    sub_18F33FACC((unsigned __int16 *)&a1[8], (uint64_t)&v8);
    sub_18F480414((unsigned __int8 *)a1, a3);
  }
  return a1->u8[1];
}

void sub_18F480414(unsigned __int8 *a1, double a2)
{
  unint64_t v2;
  unsigned __int16 *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  NSObject *v21;
  float v22;
  float v23;
  NSObject *v24;
  float v25;
  float v26;
  float v27;
  int v28;
  BOOL v29;
  float v30;
  float v31;
  float v32;
  BOOL v33;
  int v34;
  float v35;
  BOOL v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  NSObject *v54;
  float v55;
  double v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  double v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  char *v91;
  NSObject *v92;
  NSObject *v93;
  int v94;
  int v95;
  double *v96;
  float v97;
  NSObject *v98;
  float v99;
  NSObject *v100;
  float v101;
  double v102;
  float v103;
  float v104;
  float v105;
  double v106;
  float v107;
  float v108;
  char *v109;
  char *v110;
  _DWORD v111[3];
  int v112;
  _BYTE v113[34];
  uint8_t buf[4];
  _BYTE v115[34];
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  v2 = *((unsigned __int16 *)a1 + 33);
  if (*((_DWORD *)a1 + 17) != (_DWORD)v2)
    return;
  v5 = (unsigned __int16 *)(a1 + 64);
  v6 = sub_18F3403AC((unsigned __int16 *)a1 + 32, 0, v2);
  v8 = v7;
  v10 = v9;
  v11 = 0;
  *(float *)v111 = v6;
  *(float *)&v111[1] = v7;
  *(float *)&v111[2] = v9;
  v12 = 0.0;
  do
  {
    v12 = v12 + (float)(*(float *)&v111[v11] * *(float *)&v111[v11]);
    ++v11;
  }
  while (v11 != 3);
  v13 = sqrtf(v12);
  sub_18F38D4E4(v5, 0, *((unsigned __int16 *)a1 + 33));
  v15 = v14;
  v17 = v16;
  v18 = -(float)(v13 + -1.0);
  if ((float)(v13 + -1.0) > 0.0)
    v18 = v13 + -1.0;
  if (v18 > 0.25)
    goto LABEL_14;
  v19 = v14 <= v17 ? v17 : v14;
  if (v19 > 0.25)
    goto LABEL_14;
  v20 = -v6;
  if (v6 > 0.0)
    v20 = v6;
  if (v20 > 1.1)
  {
LABEL_14:
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
    v21 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
    {
      if (v15 <= v17)
        v22 = v17;
      else
        v22 = v15;
      *(_DWORD *)buf = 134218496;
      *(double *)v115 = v13;
      *(_WORD *)&v115[8] = 2048;
      *(double *)&v115[10] = v22;
      *(_WORD *)&v115[18] = 2048;
      *(double *)&v115[20] = v6;
      _os_log_impl(&dword_18F1DC000, v21, OS_LOG_TYPE_DEBUG, "Invalid dynamics, mag, %.2f, xyVarMax, %.2f, xMean, %.2f", buf, 0x20u);
    }
    if (!sub_18F1FCA08(115, 2))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
    if (v15 <= v17)
      v99 = v17;
    else
      v99 = v15;
    v112 = 134218496;
    *(double *)v113 = v13;
    *(_WORD *)&v113[8] = 2048;
    *(double *)&v113[10] = v99;
    *(_WORD *)&v113[18] = 2048;
    *(double *)&v113[20] = v6;
    goto LABEL_142;
  }
  v23 = sqrtf((float)(v8 * v8) + (float)(v6 * v6));
  if (v23 <= 1.1)
  {
    v25 = v19;
    v26 = (float)(atan2f(v23, -v10) * -57.296) + 90.0;
    if (v26 <= 0.0)
      v27 = -v26;
    else
      v27 = v26;
    if (v27 > 55.0 || ((v28 = *a1, v27 > 30.0) ? (v29 = v28 == 0) : (v29 = 1), !v29))
    {
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
      v92 = qword_1EE16D3D8;
      if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134217984;
        *(double *)v115 = v27;
        _os_log_impl(&dword_18F1DC000, v92, OS_LOG_TYPE_DEBUG, "Invalid tilt, %.2f", buf, 0xCu);
      }
      if (!sub_18F1FCA08(115, 2))
        return;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
      v112 = 134217984;
      *(double *)v113 = v27;
      goto LABEL_142;
    }
    if (v8 <= 0.0)
      v30 = -v8;
    else
      v30 = v8;
    v31 = atan2f(v6, v30);
    v32 = v31 * 57.296;
    v33 = (float)(v31 * 57.296) <= 0.0;
    if ((float)(v31 * 57.296) <= 0.0)
      v34 = 1;
    else
      v34 = 2;
    v35 = -(float)(v31 * 57.296);
    if (!v33)
      v35 = v32;
    if (v35 < 25.0 || (v27 > 45.0 ? (v36 = v35 < 37.5) : (v36 = 0), v36))
    {
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
      v93 = qword_1EE16D3D8;
      if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134217984;
        *(double *)v115 = v32;
        _os_log_impl(&dword_18F1DC000, v93, OS_LOG_TYPE_DEBUG, "Invalid swivel, %.2f", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D3E8 != -1)
          dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
        v112 = 134217984;
        *(double *)v113 = v32;
        v110 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMCallHandednessDetector::detect(double)", "CoreLocation: %s\n", v110);
        if (v110 != (char *)buf)
          free(v110);
      }
      if (*a1)
        return;
      v34 = 0;
    }
    else if (v28)
    {
      v37 = sub_18F33DA38(v5);
      if (v37 <= 0.0)
        v37 = -v37;
      if (v25 > 0.075 || v37 > 1.1)
        goto LABEL_70;
      v38 = sub_18F33DA38(v5);
      v39 = v38 - sub_18F4811CC(v5);
      if (v39 <= 0.0)
        v40 = -v39;
      else
        v40 = v39;
      sub_18F33DA38(v5);
      v42 = v41;
      sub_18F4811CC(v5);
      v44 = v42 - v43;
      v45 = -(float)(v42 - v43);
      if (v44 <= 0.0)
        v46 = v45;
      else
        v46 = v44;
      v47 = sub_18F33DA38(v5);
      v49 = v48;
      v50 = sub_18F4811CC(v5);
      v52 = v49 - v51;
      v53 = v47 - v50;
      if (v40 <= v46)
        v53 = v52;
      if (v53 <= 0.0)
        v53 = -v53;
      if (v53 > 0.6)
      {
LABEL_70:
        if (qword_1EE16D3E8 != -1)
          dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
        v54 = qword_1EE16D3D8;
        if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
        {
          v55 = sub_18F33DA38(v5);
          if (v55 <= 0.0)
            v55 = -v55;
          v56 = v55;
          v57 = sub_18F33DA38(v5);
          v58 = v57 - sub_18F4811CC(v5);
          if (v58 <= 0.0)
            v59 = -v58;
          else
            v59 = v58;
          sub_18F33DA38(v5);
          v61 = v60;
          sub_18F4811CC(v5);
          v63 = v61 - v62;
          v64 = -(float)(v61 - v62);
          if (v63 <= 0.0)
            v65 = v64;
          else
            v65 = v63;
          v66 = sub_18F33DA38(v5);
          v68 = v67;
          v69 = sub_18F4811CC(v5);
          v71 = v68 - v70;
          v72 = v66 - v69;
          if (v59 <= v65)
            v72 = v71;
          if (v72 <= 0.0)
            v72 = -v72;
          *(_DWORD *)buf = 134218496;
          *(double *)v115 = v56;
          *(_WORD *)&v115[8] = 2048;
          *(double *)&v115[10] = v25;
          *(_WORD *)&v115[18] = 2048;
          *(double *)&v115[20] = v72;
          _os_log_impl(&dword_18F1DC000, v54, OS_LOG_TYPE_DEBUG, "Swing1. xMag, %.2f, maxXYVar, %.2f, swingX, %.2f", buf, 0x20u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D3E8 != -1)
            dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
          v73 = sub_18F33DA38(v5);
          if (v73 <= 0.0)
            v73 = -v73;
          v74 = v73;
          v75 = sub_18F33DA38(v5);
          v76 = v75 - sub_18F4811CC(v5);
          if (v76 <= 0.0)
            v77 = -v76;
          else
            v77 = v76;
          sub_18F33DA38(v5);
          v79 = v78;
          sub_18F4811CC(v5);
          v81 = v79 - v80;
          v82 = -(float)(v79 - v80);
          if (v81 <= 0.0)
            v83 = v82;
          else
            v83 = v81;
          v84 = sub_18F33DA38(v5);
          v86 = v85;
          v87 = sub_18F4811CC(v5);
          v89 = v86 - v88;
          v90 = v84 - v87;
          if (v77 <= v83)
            v90 = v89;
          if (v90 <= 0.0)
            v90 = -v90;
          v112 = 134218496;
          *(double *)v113 = v74;
          *(_WORD *)&v113[8] = 2048;
          *(double *)&v113[10] = v25;
          *(_WORD *)&v113[18] = 2048;
          *(double *)&v113[20] = v90;
          v91 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMCallHandednessDetector::detect(double)", "CoreLocation: %s\n", v91);
          if (v91 != (char *)buf)
            goto LABEL_143;
        }
        return;
      }
      v97 = sub_18F4811CC(v5);
      if ((float)(v97 * sub_18F33DA38(v5)) < 0.0)
      {
        if (qword_1EE16D3E8 != -1)
          dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
        v98 = qword_1EE16D3D8;
        if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v98, OS_LOG_TYPE_DEBUG, "Swing2. X sign flipping.", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 2))
          return;
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D3E8 != -1)
          dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
        LOWORD(v112) = 0;
LABEL_142:
        v91 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMCallHandednessDetector::detect(double)", "CoreLocation: %s\n", v91);
        if (v91 == (char *)buf)
          return;
LABEL_143:
        free(v91);
        return;
      }
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
      v100 = qword_1EE16D3D8;
      if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
      {
        v101 = sub_18F33DA38(v5);
        if (v101 <= 0.0)
          v101 = -v101;
        v102 = v101;
        v103 = sub_18F33DA38(v5);
        v104 = v103 - sub_18F4811CC(v5);
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)v115 = v34;
        if (v104 <= 0.0)
          v104 = -v104;
        *(_WORD *)&v115[4] = 2048;
        *(double *)&v115[6] = v102;
        *(_WORD *)&v115[14] = 2048;
        *(double *)&v115[16] = v25;
        *(_WORD *)&v115[24] = 2048;
        *(double *)&v115[26] = v104;
        _os_log_impl(&dword_18F1DC000, v100, OS_LOG_TYPE_DEBUG, "Passed swing-detect. hand, %d, xMag, %.2f, maxXYVar, %.3f, swingX, %.3f", buf, 0x26u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D3E8 != -1)
          dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
        v105 = sub_18F33DA38(v5);
        if (v105 <= 0.0)
          v105 = -v105;
        v106 = v105;
        v107 = sub_18F33DA38(v5);
        v108 = v107 - sub_18F4811CC(v5);
        v112 = 67109888;
        *(_DWORD *)v113 = v34;
        if (v108 <= 0.0)
          v108 = -v108;
        *(_WORD *)&v113[4] = 2048;
        *(double *)&v113[6] = v106;
        *(_WORD *)&v113[14] = 2048;
        *(double *)&v113[16] = v25;
        *(_WORD *)&v113[24] = 2048;
        *(double *)&v113[26] = v108;
        v109 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMCallHandednessDetector::detect(double)", "CoreLocation: %s\n", v109);
        if (v109 != (char *)buf)
          free(v109);
      }
    }
    if (a1[1] == v34)
    {
LABEL_119:
      a1[8] = 3;
      *((_QWORD *)a1 + 2) = 0;
      return;
    }
    v94 = *a1;
    v95 = a1[8];
    if (v95 == 3 || (v96 = (double *)(a1 + 16), a2 - *((double *)a1 + 2) > 2.0))
    {
      a1[8] = v34;
      v96 = (double *)(a1 + 16);
    }
    else
    {
      if (v95 == v34)
      {
        a1[1] = v34;
        *a1 = 0;
        goto LABEL_119;
      }
      a1[8] = v34;
    }
    *v96 = a2;
    if (!v94)
      *(_DWORD *)v5 = 0;
    return;
  }
  if (qword_1EE16D3E8 != -1)
    dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
  v24 = qword_1EE16D3D8;
  if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    *(double *)v115 = v23;
    _os_log_impl(&dword_18F1DC000, v24, OS_LOG_TYPE_DEBUG, "Invalid xyNorm, %.2f", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2953E88);
    v112 = 134217984;
    *(double *)v113 = v23;
    goto LABEL_142;
  }
}

float sub_18F4811CC(unsigned __int16 *a1)
{
  NSObject *v3;
  char *v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (!a1[1])
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E29549E8);
    v3 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_FAULT, "Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMVectorBuffer.h, line 139,front() on empty buffer.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E29549E8);
      v4 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "Element CMVectorBufferBase<float, 3>::front() const [T = float, N = 3]", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf)
        free(v4);
    }
  }
  return *(float *)sub_18F33FF64(a1, 0);
}

os_log_t sub_18F481378()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Gesture");
  qword_1EE16D3D8 = (uint64_t)result;
  return result;
}

void sub_18F481724(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_18F2A8438((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_18F481AD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_18F2A8438((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_18F481CAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;

  sub_18F2A8438((uint64_t)&a12);
  sub_18F2A8438(v19 - 48);
  _Unwind_Resume(a1);
}

void sub_18F481F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_18F482180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4821B0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  const char *v22;
  uint64_t v23;

  v7 = objc_msgSend_objectForKeyedSubscript_(a2, (const char *)a2, (uint64_t)CFSTR("CMErrorMessage"), a4, a5);
  v11 = (void *)objc_msgSend_objectForKeyedSubscript_(a2, v8, (uint64_t)CFSTR("CMReturnCode"), v9, v10);
  v16 = objc_msgSend_BOOLValue(v11, v12, v13, v14, v15);
  if (v7 || (v16 & 1) == 0)
  {
    v21 = (void *)objc_msgSend_defaultManager(MEMORY[0x1E0CB3620], v17, v18, v19, v20);
    objc_msgSend_removeItemAtURL_error_(v21, v22, *(_QWORD *)(a1 + 32), 0, v23);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_18F4823F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  sub_18F2A8438((uint64_t)&a11);
  sub_18F2A8438((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_18F4825D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

os_log_t sub_18F482600()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Fall");
  qword_1EE16D830 = (uint64_t)result;
  return result;
}

void sub_18F482734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;

  if (a19 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F482770(uint64_t a1, CLConnectionMessage **a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D908 != -1)
    dispatch_once(&qword_1EE16D908, &unk_1E2958B30);
  v3 = qword_1EE16D910;
  if (os_log_type_enabled((os_log_t)qword_1EE16D910, OS_LOG_TYPE_DEBUG))
  {
    v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0)
      v5 = v4;
    else
      v5 = *(_QWORD *)v4;
    *(_DWORD *)buf = 136446210;
    v8 = v5;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %{public}s", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D908 != -1)
      dispatch_once(&qword_1EE16D908, &unk_1E2958B30);
    CLConnectionMessage::name(*a2);
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMPedestrianFenceManagerInternal init]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf)
      free(v6);
  }
}

void *sub_18F48294C(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t ExecutablePathFromPid;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  pid_t v13;
  uint64_t v14;
  void *result;
  uint64_t (**v16)(id, _QWORD, uint64_t);
  void *v17;
  const char *v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  pid_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  const __CFString *v26;
  int v27;
  uint64_t v28;
  __int16 v29;
  pid_t v30;
  __int16 v31;
  uint64_t v32;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  pid_t v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v2 = getpid();
  ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2, v4, v5);
  if (ExecutablePathFromPid)
  {
    v11 = ExecutablePathFromPid;
    if (qword_1EE16D908 != -1)
      dispatch_once(&qword_1EE16D908, &unk_1E2958B30);
    v12 = qword_1EE16D910;
    if (os_log_type_enabled((os_log_t)qword_1EE16D910, OS_LOG_TYPE_DEFAULT))
    {
      v13 = getpid();
      v14 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138478339;
      v34 = v11;
      v35 = 1025;
      v36 = v13;
      v37 = 2049;
      v38 = v14;
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_DEFAULT, "Client connection interrupt, %{private}@, %{private}d, %{private}p", buf, 0x1Cu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D908 != -1)
        dispatch_once(&qword_1EE16D908, &unk_1E2958B30);
      v22 = getpid();
      v23 = *(_QWORD *)(a1 + 32);
      v27 = 138478339;
      v28 = v11;
      v29 = 1025;
      v30 = v22;
      v31 = 2049;
      v32 = v23;
      v24 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMPedestrianFenceManagerInternal init]_block_invoke", "CoreLocation: %s\n", v24);
      if (v24 != (char *)buf)
        free(v24);
    }
  }
  result = *(void **)(*(_QWORD *)(a1 + 32) + 24);
  if (result)
  {
    v16 = (uint64_t (**)(id, _QWORD, uint64_t))(id)objc_msgSend_copy(result, v7, v8, v9, v10);
    v17 = (void *)MEMORY[0x1E0CB35C8];
    v25 = *MEMORY[0x1E0CB2D50];
    v26 = CFSTR("Session and fences lost due to disconnection");
    v19 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v18, (uint64_t)&v26, (uint64_t)&v25, 1);
    v21 = objc_msgSend_errorWithDomain_code_userInfo_(v17, v20, (uint64_t)CFSTR("CMPedestrianFenceErrorDomain"), 5, v19);
    return (void *)v16[2](v16, 0, v21);
  }
  return result;
}

void sub_18F482CB8(uint64_t a1)
{
  void *v2;
  void *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  _QWORD v29[6];
  void *__p;
  std::__shared_weak_count *v31;
  char v32;
  _QWORD v33[2];
  _QWORD v34[3];

  v34[2] = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 48))
  {

    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = 0;
  }
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    v3 = *(void **)(*(_QWORD *)(a1 + 32) + 24);
    if (v3 != v2)
    {

      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = objc_msgSend_copy(*(void **)(a1 + 40), v4, v5, v6, v7);
    }
  }
  sub_18F270374(&__p, "PedestrianFence/kCLConnectionMessagePedestrianFenceStatus");
  v29[1] = MEMORY[0x1E0C809B0];
  v29[2] = 3221225472;
  v29[3] = sub_18F482F24;
  v29[4] = &unk_1E2955DD8;
  v29[5] = *(_QWORD *)(a1 + 32);
  CLConnectionClient::setHandlerForMessage();
  if (v32 < 0)
    operator delete(__p);
  v33[0] = CFSTR("kCLConnectionMessageSubscribeKey");
  v34[0] = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], v8, *(unsigned __int8 *)(a1 + 48), v9, v10);
  v33[1] = CFSTR("CMPedestrianFenceClientIdentifier");
  v15 = (void *)objc_msgSend_processInfo(MEMORY[0x1E0CB3898], v11, v12, v13, v14);
  v34[1] = objc_msgSend_processName(v15, v16, v17, v18, v19);
  v29[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v20, (uint64_t)v34, (uint64_t)v33, 2);
  sub_18F33AE44("PedestrianFence/kCLConnectionMessagePedestrianFenceSession", v29, &__p);
  v28 = v31;
  if (v31)
  {
    p_shared_owners = (unint64_t *)&v31->__shared_owners_;
    do
      v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v28)
  {
    v23 = (unint64_t *)&v28->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v25 = v31;
  if (v31)
  {
    v26 = (unint64_t *)&v31->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
}

void sub_18F482EE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  sub_18F2A8438((uint64_t)&a10);
  sub_18F2A8438((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void *sub_18F482F24(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *result;
  uint64_t (**v7)(id, uint64_t, _QWORD);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  void *DictionaryOfClasses;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  result = *(void **)(*(_QWORD *)(a1 + 32) + 24);
  if (result)
  {
    v7 = (uint64_t (**)(id, uint64_t, _QWORD))(id)objc_msgSend_copy(result, a2, a3, a4, a5);
    v8 = (void *)MEMORY[0x1E0C99E60];
    v9 = objc_opt_class();
    v10 = objc_opt_class();
    v14 = (NSSet *)objc_msgSend_setWithObjects_(v8, v11, v9, v12, v13, v10, 0);
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v14);
    v19 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v16, (uint64_t)CFSTR("CMPedestrianFenceStatus"), v17, v18);
    return (void *)v7[2](v7, v19, 0);
  }
  return result;
}

void sub_18F483040(uint64_t a1)
{
  void *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  NSObject *v34;
  char *v35;
  void *v36[2];
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *(*v40)(uint64_t, const char *, uint64_t, uint64_t, uint64_t);
  void *v41;
  uint64_t v42;
  void *__p;
  std::__shared_weak_count *v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v2 = *(void **)(*(_QWORD *)(a1 + 32) + 16);
  if (v2 != *(void **)(a1 + 64))
  {

    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) = objc_msgSend_copy(*(void **)(a1 + 64), v3, v4, v5, v6);
  }
  sub_18F270374(&__p, "PedestrianFence/kCLConnectionMessagePedestrianFence");
  v38 = MEMORY[0x1E0C809B0];
  v39 = 3221225472;
  v40 = sub_18F483478;
  v41 = &unk_1E2955DD8;
  v42 = *(_QWORD *)(a1 + 32);
  CLConnectionClient::setHandlerForMessage();
  if (v45 < 0)
    operator delete(__p);
  v36[0] = 0;
  v36[1] = 0;
  v37 = 0;
  v11 = (void *)objc_msgSend_dictionary(MEMORY[0x1E0C99E08], v7, v8, v9, v10);
  objc_msgSend_setObject_forKeyedSubscript_(v11, v12, *(_QWORD *)(a1 + 40), (uint64_t)CFSTR("CMPedestrianFenceIdentifier"), v13);
  v17 = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], v14, *(unsigned __int8 *)(a1 + 72), v15, v16);
  objc_msgSend_setObject_forKeyedSubscript_(v11, v18, v17, (uint64_t)CFSTR("CMPedestrianFenceShouldWake"), v19);
  if (*(_QWORD *)(a1 + 48))
  {
    objc_msgSend_setObject_forKeyedSubscript_(v11, v20, MEMORY[0x1E0C9AAB0], (uint64_t)CFSTR("kCLConnectionMessageSubscribeKey"), v21);
    objc_msgSend_setObject_forKeyedSubscript_(v11, v22, *(_QWORD *)(a1 + 48), (uint64_t)CFSTR("CMPedestrianFenceRadius"), v23);
    v24 = "PedestrianFence/kCLConnectionMessagePedestrianFence";
    goto LABEL_9;
  }
  v25 = *(_QWORD *)(a1 + 56);
  if (v25)
  {
    objc_msgSend_setObject_forKeyedSubscript_(v11, v20, v25, (uint64_t)CFSTR("CMPedestrianFenceDelay"), v21);
    v24 = "PedestrianFence/kCLConnectionMessagePedestrianFenceSimulation";
LABEL_9:
    MEMORY[0x1940012AC](v36, v24);
    v26 = (std::__shared_weak_count *)operator new(0x70uLL);
    v26->__shared_owners_ = 0;
    p_shared_owners = (unint64_t *)&v26->__shared_owners_;
    v26->__shared_weak_owners_ = 0;
    v26->__vftable = (std::__shared_weak_count_vtbl *)&off_1E2952688;
    __p = (void *)MEMORY[0x19400103C](&v26[1], v36, v11);
    v44 = v26;
    do
      v28 = __ldxr(p_shared_owners);
    while (__stxr(v28 + 1, p_shared_owners));
    CLConnectionClient::sendMessage();
    if (v26)
    {
      v29 = (unint64_t *)&v26->__shared_owners_;
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 - 1, v29));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v31 = v44;
    if (v44)
    {
      v32 = (unint64_t *)&v44->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    if (SHIBYTE(v37) < 0)
      operator delete(v36[0]);
    return;
  }
  if (qword_1EE16D908 != -1)
    dispatch_once(&qword_1EE16D908, &unk_1E2958B30);
  v34 = qword_1EE16D910;
  if (os_log_type_enabled((os_log_t)qword_1EE16D910, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_18F1DC000, v34, OS_LOG_TYPE_ERROR, "Bad parameters given ", (uint8_t *)&__p, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_1EE16D908 != -1)
      dispatch_once(&qword_1EE16D908, &unk_1E2958B30);
    v35 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMPedestrianFenceManagerInternal _setFence:withRadius:wake:delay:withCompletion:]_block_invoke", "CoreLocation: %s\n", v35);
    if (v35 != (char *)&__p)
      free(v35);
  }
}

void sub_18F48340C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *sub_18F483478(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *result;
  uint64_t (**v7)(id, _QWORD, uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  void *DictionaryOfClasses;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  const char *v25;
  uint64_t v26;
  const __CFString *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];

  v34[1] = *MEMORY[0x1E0C80C00];
  result = *(void **)(*(_QWORD *)(a1 + 32) + 16);
  if (result)
  {
    v7 = (uint64_t (**)(id, _QWORD, uint64_t))(id)objc_msgSend_copy(result, a2, a3, a4, a5);
    v8 = (void *)MEMORY[0x1E0C99E60];
    v9 = objc_opt_class();
    v10 = objc_opt_class();
    v14 = (NSSet *)objc_msgSend_setWithObjects_(v8, v11, v9, v12, v13, v10, 0);
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v14);
    v19 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v16, (uint64_t)CFSTR("CMErrorMessage"), v17, v18);
    if (v19)
    {
      v24 = objc_msgSend_integerValue(v19, v20, v21, v22, v23);
      if (v24 > 4)
      {
        v27 = CFSTR("Unknown error");
        v26 = 103;
      }
      else
      {
        v26 = qword_18F5093C0[v24];
        v27 = off_1E2958B50[v24];
      }
      v29 = (void *)MEMORY[0x1E0CB35C8];
      v33 = *MEMORY[0x1E0CB2D50];
      v34[0] = v27;
      v30 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v25, (uint64_t)v34, (uint64_t)&v33, 1);
      v32 = objc_msgSend_errorWithDomain_code_userInfo_(v29, v31, (uint64_t)CFSTR("CMErrorDomain"), v26, v30);
      return (void *)v7[2](v7, 0, v32);
    }
    else
    {
      v28 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v20, (uint64_t)CFSTR("CMPedestrianFenceIdentifier"), v22, v23);
      return (void *)v7[2](v7, v28, 0);
    }
  }
  return result;
}

void sub_18F483684(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  const __CFString *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  _QWORD v23[4];
  _QWORD v24[5];

  v24[4] = *MEMORY[0x1E0C80C00];
  v24[0] = MEMORY[0x1E0C9AAA0];
  v23[0] = CFSTR("kCLConnectionMessageSubscribeKey");
  v23[1] = CFSTR("CMPedestrianFenceForceClear");
  v24[1] = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], a2, *(unsigned __int8 *)(a1 + 48), a4, a5);
  v23[2] = CFSTR("CMPedestrianFenceForceClearAll");
  v9 = objc_msgSend_numberWithBool_(MEMORY[0x1E0CB37E8], v6, *(_QWORD *)(a1 + 32) == 0, v7, v8);
  v23[3] = CFSTR("CMPedestrianFenceIdentifier");
  v11 = *(const __CFString **)(a1 + 32);
  if (!v11)
    v11 = &stru_1E295ADC8;
  v24[2] = v9;
  v24[3] = v11;
  v22 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v10, (uint64_t)v24, (uint64_t)v23, 4);
  sub_18F4850E8("PedestrianFence/kCLConnectionMessagePedestrianFence", &v22, &v20);
  v19 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v19)
  {
    v14 = (unint64_t *)&v19->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  v16 = v21;
  if (v21)
  {
    v17 = (unint64_t *)&v21->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void sub_18F483830(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

os_log_t sub_18F4850BC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "PedestrianFence");
  qword_1EE16D910 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F4850E8@<X0>(char *a1@<X1>, _QWORD *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x70uLL);
  result = sub_18F485148(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_18F485134(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F485148(_QWORD *a1, char *__s, _QWORD *a3)
{
  char v5;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_1E2952688;
  sub_18F4851A8((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_18F485194(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_18F4851A8(int a1, uint64_t a2, char *__s, _QWORD *a4)
{
  void *__p[2];
  char v7;

  sub_18F270374(__p, __s);
  MEMORY[0x19400103C](a2, __p, *a4);
  if (v7 < 0)
    operator delete(__p[0]);
}

void sub_18F4851FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_18F485218(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  *a1 = &off_1E2948FE8;
  sub_18F48528C((uint64_t)a1);
  v2 = a1[36];
  a1[36] = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  sub_18F2A8438((uint64_t)(a1 + 21));
  sub_18F2A8438((uint64_t)(a1 + 19));
  v3 = a1[18];
  a1[18] = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  return sub_18F460AF0((uint64_t)a1);
}

void sub_18F48528C(uint64_t a1)
{
  __CFRunLoopTimer *v2;

  v2 = *(__CFRunLoopTimer **)(a1 + 192);
  if (v2)
  {
    CFRunLoopTimerInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 192));
    *(_QWORD *)(a1 + 192) = 0;
  }
}

void sub_18F4852C4(_QWORD *a1)
{
  sub_18F485218(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4852E8(uint64_t result, double *a2)
{
  double v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  v2 = a2[7];
  if (v2 == -1.0)
  {
    v6 = 0;
    v4 = 0u;
    v5 = 0u;
    v3 = 0u;
    v2 = -1.0;
  }
  else
  {
    v3 = *(_OWORD *)a2;
    v4 = *((_OWORD *)a2 + 1);
    v5 = *((_OWORD *)a2 + 2);
    v6 = *((_QWORD *)a2 + 6);
  }
  *(_OWORD *)(result + 200) = v3;
  *(_OWORD *)(result + 216) = v4;
  *(_OWORD *)(result + 232) = v5;
  *(_QWORD *)(result + 248) = v6;
  *(double *)(result + 256) = v2;
  return result;
}

void sub_18F485354(uint64_t a1, int a2)
{
  NSObject *v4;
  char *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
  v4 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    v7 = a2;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEFAULT, "Compass for AOP started. CoverAttached %{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLCompass7::start(BOOL)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
  *(_BYTE *)(a1 + 272) = a2;
}

void sub_18F485504()
{
  NSObject *v0;
  char *v1;
  uint8_t buf[1640];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
  v0 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_DEFAULT, "Compass for AOP stopped.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
    v1 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLCompass7::stop()", "CoreLocation: %s\n", v1);
    if (v1 != (char *)buf)
      free(v1);
  }
}

double sub_18F485688(uint64_t a1, int a2, double *a3)
{
  uint64_t v6;
  double *v7;
  const __CFAllocator *v8;
  CFAbsoluteTime Current;
  CFRunLoopTimerRef v10;
  NSObject *v11;
  NSObject *v12;
  char *v14;
  char *v15;
  CFRunLoopTimerContext context;
  int v17;
  uint64_t v18;
  uint8_t buf[4];
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  sub_18F460CE4(a1, a2, a3);
  if (!a2)
  {
    if (*a3 <= 0.0)
    {
      if (*(_BYTE *)(a1 + 184))
      {
        *(_BYTE *)(a1 + 184) = 0;
        sub_18F48528C(a1);
        context.version = 0;
        context.info = (void *)a1;
        memset(&context.retain, 0, 24);
        v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Current = CFAbsoluteTimeGetCurrent();
        v10 = CFRunLoopTimerCreate(v8, Current + 600.0, 0.0, 0, 0, (CFRunLoopTimerCallBack)sub_18F486AB0, &context);
        *(_QWORD *)(a1 + 192) = v10;
        if (v10)
        {
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
          v11 = qword_1EE16D690;
          if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134349056;
            v20 = 0x4082C00000000000;
            _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_DEBUG, "Keeping compass on for %{public}.0f seconds", buf, 0xCu);
          }
          if (sub_18F1FCA08(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EE16D698 != -1)
              dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
            v17 = 134349056;
            v18 = 0x4082C00000000000;
            v14 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CLCompass7::startTurnOffTimer()", "CoreLocation: %s\n", v14);
            if (v14 != (char *)buf)
              free(v14);
          }
          sub_18F204AE4();
          CFRunLoopAddTimer(*(CFRunLoopRef *)qword_1ECEDFE08, *(CFRunLoopTimerRef *)(a1 + 192), (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
        }
        else
        {
          if (qword_1EE16D698 != -1)
            dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
          v12 = qword_1EE16D690;
          if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_FAULT, "Could not create turn-off timer", buf, 2u);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1EE16D698 != -1)
              dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
            LOWORD(v17) = 0;
            v15 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLCompass7::startTurnOffTimer()", "CoreLocation: %s\n", v15);
            if (v15 != (char *)buf)
              free(v15);
          }
          sub_18F485A4C(a1, (double *)(a1 + 264));
        }
      }
      if (*(_QWORD *)(a1 + 192))
        v7 = (double *)&unk_18F5093F0;
      else
        v7 = a3;
      v6 = a1;
    }
    else
    {
      v6 = a1;
      v7 = a3;
    }
    sub_18F485A4C(v6, v7);
  }
  *(double *)(a1 + 264) = *a3;
  return *a3;
}

uint64_t sub_18F485A4C(uint64_t a1, double *a2)
{
  NSObject *v4;
  double v5;
  char v6;
  uint64_t *v7;
  uint64_t *v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  double v15;
  uint64_t v16;
  double v18;
  char *v19;
  _DWORD v20[2];
  char v21;
  int v22;
  double v23;
  uint8_t buf[1640];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
  v4 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *a2;
    *(_DWORD *)buf = 134349056;
    *(double *)&buf[4] = v5;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEFAULT, "Setting compass update interval to %{public}f", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953EE8);
    v18 = *a2;
    v22 = 134349056;
    v23 = v18;
    v19 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLCompass7::setDeviceMotionServiceUpdateInterval(const CFTimeInterval &)", "CoreLocation: %s\n", v19);
    if (v19 != (char *)buf)
      free(v19);
  }
  if (*(_BYTE *)(a1 + 136))
  {
    v6 = sub_18F1F7BFC();
    v7 = (uint64_t *)(a1 + 168);
    if ((v6 & 0x20) != 0)
      v8 = (uint64_t *)(a1 + 168);
    else
      v8 = (uint64_t *)(a1 + 152);
    if ((v6 & 0x20) != 0)
      v9 = 8;
    else
      v9 = 4;
    if ((v6 & 0x20) != 0)
      v7 = (uint64_t *)(a1 + 152);
  }
  else
  {
    v7 = (uint64_t *)(a1 + 168);
    v8 = (uint64_t *)(a1 + 152);
    v9 = 4;
  }
  if (*v7)
    sub_18F203AF8(*v7, (uint64_t)rint(0.0));
  v10 = *v8;
  if (!*v8)
  {
    v11 = (_QWORD *)sub_18F1E0F30();
    v20[0] = 65292;
    v20[1] = v9;
    v21 = 0;
    sub_18F1E9BC8(v11, (uint64_t)v20, (uint64_t *)buf);
    sub_18F346DC8((uint64_t)v8, (__int128 *)buf);
    v12 = *(std::__shared_weak_count **)&buf[8];
    if (*(_QWORD *)&buf[8])
    {
      v13 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
      do
        v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    sub_18F203148(*v8, (uint64_t)sub_18F485D00, a1);
    v10 = *v8;
  }
  v15 = rint(*a2 * 1000000.0);
  if (*a2 < 0.0)
    v16 = 0;
  else
    v16 = (uint64_t)v15;
  return sub_18F203AF8(v10, v16);
}

void sub_18F485D00()
{
  NSObject *v0;
  char *v1;
  uint8_t buf[8];
  uint64_t v3;
  uint64_t v4;

  MEMORY[0x1E0C80A78]();
  v4 = *MEMORY[0x1E0C80C00];
  IOHIDEventGetVendorDefinedData();
  if (qword_1ECEDEE98 != -1)
    dispatch_once(&qword_1ECEDEE98, &unk_1E29437E0);
  v0 = off_1ECEDEE90;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_DEBUG, "Empty payload, returning", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E29437E0);
    LOWORD(v3) = 0;
    v1 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "static void CLCompass7::onDeviceMotionServiceIohidEvent(void *, void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v1);
    if (v1 != (char *)buf)
      free(v1);
  }
}

void sub_18F486A94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  sub_18F2B9670((PB::Base *)&a51);
  _Unwind_Resume(a1);
}

void sub_18F486AB0(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a2 + 264) <= 0.0)
    sub_18F485A4C(a2, (double *)(a2 + 264));
  sub_18F48528C(a2);
}

void sub_18F486AEC()
{
  JUMPOUT(0x194001438);
}

__n128 sub_18F486B04(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __n128 result;
  __int128 v5;
  __int128 v6;

  v2 = *a2;
  v3 = a2[1];
  *(_OWORD *)(a1 + 40) = a2[2];
  *(_OWORD *)(a1 + 24) = v3;
  *(_OWORD *)(a1 + 8) = v2;
  result = (__n128)a2[3];
  v5 = a2[4];
  v6 = a2[5];
  *(_DWORD *)(a1 + 104) = *((_DWORD *)a2 + 24);
  *(_OWORD *)(a1 + 88) = v6;
  *(_OWORD *)(a1 + 72) = v5;
  *(__n128 *)(a1 + 56) = result;
  return result;
}

void sub_18F486C58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;

  if (a19 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F486C94(uint64_t a1, CLConnectionMessage **a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSSet *v9;
  void *DictionaryOfClasses;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  char *v21;
  uint8_t buf[4];
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = (void *)MEMORY[0x1E0C99E60];
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v9 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v7, v8, v5, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) != 0
    && (v14 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, (uint64_t)CFSTR("CMErrorMessage"), v12, v13)) != 0)
  {
    v19 = objc_msgSend_intValue(v14, v15, v16, v17, v18);
  }
  else
  {
    v19 = 103;
  }
  if (qword_1EE16D458 != -1)
    dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
  v20 = qword_1EE16D450;
  if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67240192;
    v23 = v19;
    _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D458 != -1)
      dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMSkiTrackerInternal init]_block_invoke", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
  }
}

void sub_18F486EA8(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t ExecutablePathFromPid;
  uint64_t v7;
  NSObject *v8;
  pid_t v9;
  uint64_t v10;
  int v11;
  char *v12;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  pid_t v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = getpid();
  ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2, v4, v5);
  if (ExecutablePathFromPid)
  {
    v7 = ExecutablePathFromPid;
    if (qword_1EE16D458 != -1)
      dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
    v8 = qword_1EE16D450;
    if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_INFO))
    {
      v9 = getpid();
      v10 = *(_QWORD *)(a1 + 32);
      v11 = *(unsigned __int8 *)(v10 + 24);
      *(_DWORD *)buf = 138413058;
      v14 = v7;
      v15 = 1024;
      v16 = v9;
      v17 = 1024;
      v18 = v11;
      v19 = 2048;
      v20 = v10;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "CMSkiTracker client connection interrupt, %@, %d, %d, %p", buf, 0x22u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D458 != -1)
        dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
      getpid();
      v12 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSkiTrackerInternal init]_block_invoke", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf)
        free(v12);
    }
  }
}

void sub_18F4871D4(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const char *v4;
  uint64_t v5;
  id v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  CMSkiData *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  const char *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *p_shared_owners;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  unint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  std::__shared_weak_count *v38;
  _QWORD v39[11];
  __int128 v40;
  uint64_t v41;
  const __CFString *v42;
  uint64_t v43;
  __int128 v44;
  __int128 buf;
  char v46;
  const __CFString *v47;
  void *v48;
  const __CFString *v49;
  _QWORD v50[2];

  v50[1] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void **)(v2 + 40);
  if (v3 != *(void **)(a1 + 48) || !*(_BYTE *)(v2 + 24))
  {

    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) = *(id *)(a1 + 48);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) = *(id *)(a1 + 40);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) = 0xBFF0000000000000;
    v41 = 0;
    v5 = *(_QWORD *)(a1 + 40);
    if (v5)
    {
      v49 = CFSTR("CMSkiKeyDataRecord");
      v50[0] = v5;
      v41 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v4, (uint64_t)v50, (uint64_t)&v49, 1);
    }
    else
    {
      v6 = objc_alloc(MEMORY[0x1E0CB3A28]);
      v10 = (void *)objc_msgSend_initWithUUIDString_(v6, v7, (uint64_t)CFSTR("00000000-0000-0000-0000-000000000000"), v8, v9);
      v11 = [CMSkiData alloc];
      v15 = (void *)objc_msgSend_initWithSessionId_(v11, v12, (uint64_t)v10, v13, v14);
      v47 = CFSTR("CMSkiKeyDataRecord");
      v48 = v15;
      v41 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v16, (uint64_t)&v48, (uint64_t)&v47, 1);

    }
    if (qword_1EE16D458 != -1)
      dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
    v17 = qword_1EE16D450;
    if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_DEFAULT))
    {
      v18 = *(_QWORD *)(a1 + 40);
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v18;
      _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_DEFAULT, "Querying data to anchor updates from %@", (uint8_t *)&buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1EE16D458 != -1)
        dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
      v36 = *(_QWORD *)(a1 + 40);
      LODWORD(v44) = 138412290;
      *(_QWORD *)((char *)&v44 + 4) = v36;
      v37 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSkiTrackerInternal _startUpdatesFromRecord:handler:]_block_invoke", "CoreLocation: %s\n", v37);
      if (v37 != (char *)&buf)
        free(v37);
    }
    sub_18F4040E8("kCLConnectionMessageSkiDataQuery", &v41, &v44);
    v19 = *(_QWORD *)(a1 + 32);
    v40 = v44;
    if (*((_QWORD *)&v44 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
      v19 = *(_QWORD *)(a1 + 32);
    }
    v22 = MEMORY[0x1E0C809B0];
    v39[6] = MEMORY[0x1E0C809B0];
    v39[7] = 3221225472;
    v39[8] = sub_18F487730;
    v39[9] = &unk_1E2955DD8;
    v39[10] = v19;
    CLConnectionClient::sendMessage();
    if (*((_QWORD *)&v40 + 1))
    {
      v23 = (unint64_t *)(*((_QWORD *)&v40 + 1) + 8);
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        (*(void (**)(_QWORD))(**((_QWORD **)&v40 + 1) + 16))(*((_QWORD *)&v40 + 1));
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v40 + 1));
      }
    }
    sub_18F270374(&buf, "kCLConnectionMessageSkiDataUpdate");
    v39[1] = v22;
    v39[2] = 3221225472;
    v39[3] = sub_18F487800;
    v39[4] = &unk_1E2955DD8;
    v39[5] = *(_QWORD *)(a1 + 32);
    CLConnectionClient::setHandlerForMessage();
    if (v46 < 0)
      operator delete((void *)buf);
    v42 = CFSTR("kCLConnectionMessageSubscribeKey");
    v43 = MEMORY[0x1E0C9AAB0];
    v39[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v25, (uint64_t)&v43, (uint64_t)&v42, 1);
    sub_18F489C98("kCLConnectionMessageSkiDataUpdate", v39, &buf);
    v38 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v26 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
    }
    CLConnectionClient::sendMessage();
    if (v38)
    {
      p_shared_owners = (unint64_t *)&v38->__shared_owners_;
      do
        v29 = __ldaxr(p_shared_owners);
      while (__stlxr(v29 - 1, p_shared_owners));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 24) = 1;
    v30 = (std::__shared_weak_count *)*((_QWORD *)&buf + 1);
    if (*((_QWORD *)&buf + 1))
    {
      v31 = (unint64_t *)(*((_QWORD *)&buf + 1) + 8);
      do
        v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    v33 = (std::__shared_weak_count *)*((_QWORD *)&v44 + 1);
    if (*((_QWORD *)&v44 + 1))
    {
      v34 = (unint64_t *)(*((_QWORD *)&v44 + 1) + 8);
      do
        v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
    }
  }
}

void sub_18F4876D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  sub_18F2A8438((uint64_t)&a12);
  sub_18F2A8438((uint64_t)&__p);
  sub_18F2A8438((uint64_t)&a31);
  _Unwind_Resume(a1);
}

uint64_t sub_18F487730(uint64_t result, uint64_t *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  NSSet *v12;
  uint64_t v13;
  uint64_t v14;

  if (*(_QWORD *)(*(_QWORD *)(result + 32) + 40))
  {
    v3 = result;
    v4 = (void *)MEMORY[0x1E0C99E60];
    v5 = objc_opt_class();
    v6 = objc_opt_class();
    v7 = objc_opt_class();
    v8 = objc_opt_class();
    v12 = (NSSet *)objc_msgSend_setWithObjects_(v4, v9, v5, v10, v11, v6, v7, v8, 0);
    result = *a2;
    if (*a2)
    {
      result = CLConnectionMessage::getDictionaryOfClasses((CLConnectionMessage *)result, v12);
      if (result)
        return MEMORY[0x1E0DE7D20](*(_QWORD *)(v3 + 32), sel__handleUpdates_, result, v13, v14);
    }
  }
  return result;
}

void sub_18F487800(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  id v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  NSSet *v17;
  uint64_t DictionaryOfClasses;
  uint64_t v19;
  uint64_t v20;
  _QWORD block[5];

  v6 = *(void **)(*(_QWORD *)(a1 + 32) + 40);
  if (v6)
  {
    v8 = (id)objc_msgSend_copy(v6, a2, a3, a4, a5);
    v9 = (void *)MEMORY[0x1E0C99E60];
    v10 = objc_opt_class();
    v11 = objc_opt_class();
    v12 = objc_opt_class();
    v13 = objc_opt_class();
    v17 = (NSSet *)objc_msgSend_setWithObjects_(v9, v14, v10, v15, v16, v11, v12, v13, 0);
    if (*(_QWORD *)a2
      && (DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v17)) != 0)
    {
      MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleUpdates_, DictionaryOfClasses, v19, v20);
    }
    else
    {
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = sub_18F487928;
      block[3] = &unk_1E2955B10;
      block[4] = v8;
      dispatch_async(MEMORY[0x1E0C80D38], block);
    }
  }
}

uint64_t sub_18F487928(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F4879CC(uint64_t a1, const char *a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  NSObject *v10;
  char *v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  const __CFString *v14;
  uint64_t v15;
  uint8_t buf[8];
  std::__shared_weak_count *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 24))
  {
    v14 = CFSTR("kCLConnectionMessageSubscribeKey");
    v15 = MEMORY[0x1E0C9AAA0];
    v13 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)&v15, (uint64_t)&v14, 1);
    sub_18F489C98("kCLConnectionMessageSkiDataUpdate", &v13, buf);
    v12 = v17;
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        v4 = __ldxr(p_shared_owners);
      while (__stxr(v4 + 1, p_shared_owners));
    }
    CLConnectionClient::sendMessage();
    if (v12)
    {
      v5 = (unint64_t *)&v12->__shared_owners_;
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 24) = 0;
    v7 = v17;
    if (v17)
    {
      v8 = (unint64_t *)&v17->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
  else
  {
    if (qword_1EE16D458 != -1)
      dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
    v10 = qword_1EE16D450;
    if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_INFO, "Unable to stop Ski data updates as we are are not receiving updates.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D458 != -1)
        dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
      LOWORD(v13) = 0;
      v11 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSkiTrackerInternal _stopUpdates]_block_invoke", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf)
        free(v11);
    }
  }
}

void sub_18F487C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F487CDC(uint64_t a1, const char *a2)
{
  uint64_t v2;
  id v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  CMSkiData *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  const __CFString *v25;
  void *v26;
  const __CFString *v27;
  _QWORD v28[2];

  v28[1] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v27 = CFSTR("CMSkiKeyDataRecord");
    v28[0] = v2;
    v24 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v28, (uint64_t)&v27, 1);
  }
  else
  {
    v3 = objc_alloc(MEMORY[0x1E0CB3A28]);
    v7 = (void *)objc_msgSend_initWithUUIDString_(v3, v4, (uint64_t)CFSTR("00000000-0000-0000-0000-000000000000"), v5, v6);
    v8 = [CMSkiData alloc];
    v12 = (void *)objc_msgSend_initWithSessionId_(v8, v9, (uint64_t)v7, v10, v11);
    v25 = CFSTR("CMSkiKeyDataRecord");
    v26 = v12;
    v24 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v13, (uint64_t)&v26, (uint64_t)&v25, 1);

  }
  sub_18F4040E8("kCLConnectionMessageSkiDataQuery", &v24, &v22);
  v21 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v21)
  {
    v16 = (unint64_t *)&v21->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v18 = v23;
  if (v23)
  {
    v19 = (unint64_t *)&v23->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void sub_18F487EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7;
  va_list va;
  uint64_t v9;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v7 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F487EE8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  NSSet *v15;
  void *DictionaryOfClasses;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  NSObject *v27;
  char *v28;
  _QWORD v29[5];
  __int16 v30;
  _QWORD v31[6];
  _QWORD v32[6];
  _QWORD block[5];
  uint8_t buf[1640];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v6 = (id)objc_msgSend_copy(*(void **)(a1 + 32), a2, a3, a4, a5);
  v7 = (void *)MEMORY[0x1E0C99E60];
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  v10 = objc_opt_class();
  v11 = objc_opt_class();
  v15 = (NSSet *)objc_msgSend_setWithObjects_(v7, v12, v8, v13, v14, v9, v10, v11, 0);
  if (*(_QWORD *)a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v15)) != 0)
  {
    v20 = DictionaryOfClasses;
    v21 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v17, (uint64_t)CFSTR("CMErrorMessage"), v18, v19);
    v25 = objc_msgSend_objectForKeyedSubscript_(v20, v22, (uint64_t)CFSTR("CMSkiKeyDataArray"), v23, v24);
    if (v21)
    {
      v32[0] = MEMORY[0x1E0C809B0];
      v32[1] = 3221225472;
      v32[2] = sub_18F488264;
      v32[3] = &unk_1E2955B60;
      v32[4] = v21;
      v32[5] = v6;
      v26 = v32;
    }
    else if (v25)
    {
      v31[0] = MEMORY[0x1E0C809B0];
      v31[1] = 3221225472;
      v31[2] = sub_18F4882C4;
      v31[3] = &unk_1E2955B60;
      v31[4] = v25;
      v31[5] = v6;
      v26 = v31;
    }
    else
    {
      if (qword_1EE16D458 != -1)
        dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
      v27 = qword_1EE16D450;
      if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_FAULT, "Unable to parse kCLConnectionMessageSkiDataQuery message.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D458 != -1)
          dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
        v30 = 0;
        v28 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMSkiTrackerInternal _queryUpdatesFromRecord:handler:]_block_invoke", "CoreLocation: %s\n", v28);
        if (v28 != (char *)buf)
          free(v28);
      }
      v29[0] = MEMORY[0x1E0C809B0];
      v29[1] = 3221225472;
      v29[2] = sub_18F4882D8;
      v29[3] = &unk_1E2955B10;
      v29[4] = v6;
      v26 = v29;
    }
  }
  else
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F488218;
    block[3] = &unk_1E2955B10;
    block[4] = v6;
    v26 = block;
  }
  dispatch_async(MEMORY[0x1E0C80D38], v26);
}

uint64_t sub_18F488218(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F488264(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4882C4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_18F4882D8(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F4889C8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F488A28(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_18F488A3C(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F488AE0(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  std::__shared_weak_count *v12;
  _QWORD v13[7];
  const __CFString *v14;
  uint64_t v15;
  uint8_t buf[8];
  std::__shared_weak_count *v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D458 != -1)
    dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
  v2 = qword_1EE16D450;
  if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "[live data] starting updates", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D458 != -1)
      dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
    LOWORD(v13[0]) = 0;
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMSkiTrackerInternal _startLiveUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
  }

  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) = *(id *)(a1 + 40);
  sub_18F270374(buf, "kCLConnectionMessageSkiDataLiveUpdate");
  v13[2] = MEMORY[0x1E0C809B0];
  v13[3] = 3221225472;
  v13[4] = sub_18F488E28;
  v13[5] = &unk_1E2955DD8;
  v13[6] = *(_QWORD *)(a1 + 32);
  CLConnectionClient::setHandlerForMessage();
  if (v18 < 0)
    operator delete(*(void **)buf);
  v14 = CFSTR("kCLConnectionMessageSubscribeKey");
  v15 = MEMORY[0x1E0C9AAB0];
  v13[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v3, (uint64_t)&v15, (uint64_t)&v14, 1);
  sub_18F3ED6C0("kCLConnectionMessageSkiDataLiveUpdate", v13, buf);
  v12 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v12)
  {
    v6 = (unint64_t *)&v12->__shared_owners_;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v8 = v17;
  if (v17)
  {
    v9 = (unint64_t *)&v17->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

void sub_18F488DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_18F2A8438((uint64_t)&a11);
  sub_18F2A8438((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void sub_18F488E28(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  id v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  NSSet *v15;
  void *DictionaryOfClasses;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  void *v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  _QWORD *v45;
  NSObject *v46;
  uint64_t v47;
  NSObject *v48;
  char *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  char *v59;
  _QWORD v60[6];
  _QWORD v61[6];
  _QWORD block[5];
  int v63;
  uint64_t v64;
  uint8_t buf[4];
  uint64_t v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v5 = *(void **)(*(_QWORD *)(a1 + 32) + 48);
  if (v5)
  {
    v7 = (id)objc_msgSend_copy(v5, a2, a3, a4, a5);
    v8 = (void *)MEMORY[0x1E0C99E60];
    v9 = objc_opt_class();
    v10 = objc_opt_class();
    v11 = objc_opt_class();
    v15 = (NSSet *)objc_msgSend_setWithObjects_(v8, v12, v9, v13, v14, v10, v11, 0);
    if (*(_QWORD *)a2
      && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v15),
          *(_QWORD *)a2)
      && (v20 = DictionaryOfClasses) != 0)
    {
      if (objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v17, (uint64_t)CFSTR("CMErrorMessage"), v18, v19))
      {
        if (qword_1EE16D458 != -1)
          dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
        v24 = qword_1EE16D450;
        if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_ERROR))
        {
          v28 = (void *)objc_msgSend_objectForKeyedSubscript_(v20, v25, (uint64_t)CFSTR("CMErrorMessage"), v26, v27);
          *(_DWORD *)buf = 67109120;
          LODWORD(v66) = objc_msgSend_intValue(v28, v29, v30, v31, v32);
          _os_log_impl(&dword_18F1DC000, v24, OS_LOG_TYPE_ERROR, "[live data] encountered error while trying to stream, %d", buf, 8u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D458 != -1)
            dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
          v53 = (void *)objc_msgSend_objectForKeyedSubscript_(v20, v50, (uint64_t)CFSTR("CMErrorMessage"), v51, v52);
          v63 = 67109120;
          LODWORD(v64) = objc_msgSend_intValue(v53, v54, v55, v56, v57);
          v58 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "-[CMSkiTrackerInternal _startLiveUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v58);
          if (v58 != (char *)buf)
            free(v58);
        }
        v36 = (void *)MEMORY[0x1E0CB35C8];
        v37 = (void *)objc_msgSend_objectForKeyedSubscript_(v20, v33, (uint64_t)CFSTR("CMErrorMessage"), v34, v35);
        v42 = objc_msgSend_integerValue(v37, v38, v39, v40, v41);
        v44 = objc_msgSend_errorWithDomain_code_userInfo_(v36, v43, (uint64_t)CFSTR("CMErrorDomain"), v42, 0);
        v61[0] = MEMORY[0x1E0C809B0];
        v61[1] = 3221225472;
        v61[2] = sub_18F489460;
        v61[3] = &unk_1E2955B60;
        v61[4] = v44;
        v61[5] = v7;
        v45 = v61;
      }
      else
      {
        v47 = objc_msgSend_objectForKeyedSubscript_(v20, v21, (uint64_t)CFSTR("CMSkiKeyDataRecord"), v22, v23);
        if (qword_1EE16D458 != -1)
          dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
        v48 = qword_1EE16D450;
        if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 138412290;
          v66 = v47;
          _os_log_impl(&dword_18F1DC000, v48, OS_LOG_TYPE_INFO, "[live data] delivering live update %@", buf, 0xCu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D458 != -1)
            dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
          v63 = 138412290;
          v64 = v47;
          v59 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "-[CMSkiTrackerInternal _startLiveUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v59);
          if (v59 != (char *)buf)
            free(v59);
        }
        v60[0] = MEMORY[0x1E0C809B0];
        v60[1] = 3221225472;
        v60[2] = sub_18F489474;
        v60[3] = &unk_1E2955B60;
        v60[4] = v47;
        v60[5] = v7;
        v45 = v60;
      }
    }
    else
    {
      if (qword_1EE16D458 != -1)
        dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
      v46 = qword_1EE16D450;
      if (os_log_type_enabled((os_log_t)qword_1EE16D450, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v46, OS_LOG_TYPE_ERROR, "[live data] malformed payload while trying to stream", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D458 != -1)
          dispatch_once(&qword_1EE16D458, &unk_1E2958B78);
        LOWORD(v63) = 0;
        v49 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMSkiTrackerInternal _startLiveUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v49);
        if (v49 != (char *)buf)
          free(v49);
      }
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = sub_18F489414;
      block[3] = &unk_1E2955B10;
      block[4] = v7;
      v45 = block;
    }
    dispatch_async(MEMORY[0x1E0C80D38], v45);
  }
}

uint64_t sub_18F489414(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F489460(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), 0, *(_QWORD *)(a1 + 32));
}

uint64_t sub_18F489474(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

void sub_18F489654(uint64_t a1, const char *a2)
{
  unint64_t *p_shared_owners;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  const __CFString *v13;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v13 = CFSTR("kCLConnectionMessageSubscribeKey");
  v14[0] = MEMORY[0x1E0C9AAA0];
  v12 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v14, (uint64_t)&v13, 1);
  sub_18F3ED6C0("kCLConnectionMessageSkiDataLiveUpdate", &v12, &v10);
  v9 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v3 = __ldxr(p_shared_owners);
    while (__stxr(v3 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v9)
  {
    v4 = (unint64_t *)&v9->__shared_owners_;
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v6 = v11;
  if (v11)
  {
    v7 = (unint64_t *)&v11->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_18F489794(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F489894(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_18F489978(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  const char *v7;
  uint64_t v8;

  v6 = (void *)objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return objc_msgSend__startUpdatesFromRecord_handler_(v6, v7, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), v8);
}

uint64_t sub_18F4899FC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v5, sel__stopUpdates, v6, v7, v8);
}

uint64_t sub_18F489AE8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, (uint64_t)CFSTR("com.apple.locationd.activity"), a4, a5);
  qword_1ECEDFBE0 = result;
  return result;
}

uint64_t sub_18F489BC8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel__startLiveUpdatesWithHandler_, *(_QWORD *)(a1 + 40), v7, v8);
}

uint64_t sub_18F489C4C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v5, sel__stopLiveUpdates, v6, v7, v8);
}

os_log_t sub_18F489C6C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Skiing");
  qword_1EE16D450 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F489C98@<X0>(char *a1@<X1>, _QWORD *a2@<X2>, _QWORD *a3@<X8>)
{
  _QWORD *v6;
  _QWORD *result;

  v6 = operator new(0x70uLL);
  result = sub_18F489CF8(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_18F489CE4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F489CF8(_QWORD *a1, char *__s, _QWORD *a3)
{
  char v5;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_1E2952688;
  sub_18F489D58((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_18F489D44(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_18F489D58(int a1, uint64_t a2, char *__s, _QWORD *a4)
{
  void *__p[2];
  char v7;

  sub_18F270374(__p, __s);
  MEMORY[0x19400103C](a2, __p, *a4);
  if (v7 < 0)
    operator delete(__p[0]);
}

void sub_18F489DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F489E7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v15, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F489F70(uint64_t a1, CLConnectionMessage **a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSSet *v9;
  void *DictionaryOfClasses;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  char *v21;
  uint8_t buf[4];
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = (void *)MEMORY[0x1E0C99E60];
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v9 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v7, v8, v5, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9)) != 0
    && (v14 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, (uint64_t)CFSTR("CMErrorMessage"), v12, v13)) != 0)
  {
    v19 = objc_msgSend_intValue(v14, v15, v16, v17, v18);
  }
  else
  {
    v19 = 103;
  }
  if (qword_1ECEDEE88 != -1)
    dispatch_once(&qword_1ECEDEE88, &unk_1E2954F28);
  v20 = off_1ECEDEE80;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67240192;
    v23 = v19;
    _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954F28);
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMCatherineFeederInternal _startDaemonConnection]_block_invoke", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
  }
}

void sub_18F48A2F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F48A3F8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__teardown(*(void **)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5);
}

uint64_t sub_18F48A61C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = objc_msgSend_internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  v6 = mach_absolute_time();
  sub_18F1FD20C(v6);
  return MEMORY[0x1E0DE7D20](v5, sel__feedCatherine_confidence_timestamp_, v7, v8, v9);
}

os_log_t sub_18F48A670()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1EE16D6A8 = (uint64_t)result;
  return result;
}

void sub_18F48AC84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10F3C40E271C694);
  _Unwind_Resume(a1);
}

void sub_18F48B210(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t *sub_18F48B270(uint64_t *result, uint64_t a2)
{
  uint64_t *v2;

  if (a2)
  {
    v2 = result;
    result = *(uint64_t **)(a2 + 160);
    if (result)
      return (uint64_t *)sub_18F365904(result, v2);
  }
  return result;
}

uint64_t *sub_18F48B28C(uint64_t *result, uint64_t a2)
{
  uint64_t *v2;

  if (a2)
  {
    v2 = result;
    result = *(uint64_t **)(a2 + 160);
    if (result)
      return (uint64_t *)sub_18F365A6C(result, v2);
  }
  return result;
}

uint64_t sub_18F48B2A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a2, sel_onAudioAccessoryDeviceMotion_, a1, a4, a5);
}

void sub_18F48B2B4(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  _QWORD *v5;
  int v6;
  _QWORD *v7;
  int v8;
  uint64_t *v9;
  char *v10;
  uint8_t buf[4];
  int v12;
  __int16 v13;
  _QWORD *v14;
  __int16 v15;
  _QWORD *v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2958C20);
  v4 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_INFO))
  {
    v5 = (_QWORD *)(a1 + 8);
    if (*(char *)(a1 + 31) < 0)
      v5 = (_QWORD *)*v5;
    v6 = *(_DWORD *)a1;
    v7 = (_QWORD *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0)
      v7 = (_QWORD *)*v7;
    v8 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)buf = 67240963;
    v12 = v6;
    v13 = 2081;
    v14 = v5;
    v15 = 2081;
    v16 = v7;
    v17 = 1026;
    v18 = v8;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "[CMHeadphoneActivityManager] Config,side,%{public}d,configuration,%{private}s,serialNumber,%{private}s,hardwareModel,%{public}d", buf, 0x22u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2958C20);
    v10 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void onHeadphoneDeviceMotionConfig(const CLAccessoryDeviceMotion::Config *, void *)", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf)
      free(v10);
  }
  if (a2)
  {
    v9 = *(uint64_t **)(a2 + 160);
    if (v9)
      sub_18F364C10(v9, (int *)a1);
  }
}

uint64_t *sub_18F48B504(uint64_t *result, uint64_t a2)
{
  double *v2;

  if (a2)
  {
    v2 = (double *)result;
    result = *(uint64_t **)(a2 + 160);
    if (result)
      return (uint64_t *)sub_18F363720(result, v2);
  }
  return result;
}

void sub_18F48BB8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_18F48BDB4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  objc_msgSend_pauseActivityStreamingPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
  objc_msgSend_pauseStatusStreamingPrivate(*(void **)(a1 + 32), v6, v7, v8, v9);
  return objc_msgSend_stopMslLoggingPrivate(*(void **)(*(_QWORD *)(a1 + 32) + 8), v10, v11, v12, v13);
}

uint64_t sub_18F48BE34()
{
  const char *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  if ((sub_18F20C9AC() & 1) != 0 || (sub_18F1E1B00() & 1) != 0 || (sub_18F1F7758() & 1) != 0)
    result = 1;
  else
    result = objc_msgSend_isMotionActivityEntitled(CMMotionUtils, v0, v1, v2, v3);
  byte_1ECEDFBF0 = result;
  return result;
}

__n128 sub_18F48BEF4(uint64_t a1)
{
  __int128 v1;
  NSObject *v2;
  __n128 result;
  _QWORD block[4];
  __int128 v5;
  uint64_t v6;

  block[0] = MEMORY[0x1E0C809B0];
  v1 = *(_OWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 8);
  block[1] = 3221225472;
  block[2] = sub_18F48BF60;
  block[3] = &unk_1E2955BD8;
  v5 = v1;
  v6 = *(_QWORD *)(a1 + 48);
  dispatch_async(v2, block);
  return result;
}

uint64_t sub_18F48BF60(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a1[4], sel_startActivityUpdatesPrivateToQueue_withHandler_, a1[5], a1[6], a5);
}

void sub_18F48BFCC(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(v1 + 8) + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_18F48C028;
  block[3] = &unk_1E2955938;
  block[4] = v1;
  dispatch_sync(v2, block);
}

uint64_t sub_18F48C028(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_stopActivityUpdatesPrivate, a3, a4, a5);
}

uint64_t sub_18F48C090(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a1[4], sel_startStatusUpdatesPrivateToQueue_withHandler_, a1[5], a1[6], a5);
}

uint64_t sub_18F48C0FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_stopStatusUpdatesPrivate, a3, a4, a5);
}

uint64_t sub_18F48C198(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_mslLoggingEnabledPrivate(*(void **)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t sub_18F48C22C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1[4] + 8), sel_startMslLoggingPrivateWithFilenamePrefix_filePath_, a1[5], a1[6], a5);
}

uint64_t sub_18F48C29C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_stopMslLoggingPrivate(*(void **)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5);
}

void sub_18F48C4F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_18F48C510(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  void *v15;
  id Weak;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  int isEqualToString;
  id v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  id v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;

  if (a2)
  {
    v3 = result;
    v4 = (void *)MEMORY[0x1E0CB3710];
    v5 = (void *)MEMORY[0x1E0C99E60];
    v6 = objc_opt_class();
    v7 = objc_opt_class();
    v8 = objc_opt_class();
    v9 = objc_opt_class();
    v13 = objc_msgSend_setWithObjects_(v5, v10, v6, v11, v12, v7, v8, v9, 0);
    v15 = (void *)objc_msgSend_unarchivedObjectOfClasses_fromData_error_(v4, v14, v13, a2, 0);
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      Weak = objc_loadWeak((id *)(v3 + 32));
      v18 = (uint64_t)v15;
      v19 = 0;
      return MEMORY[0x1E0DE7D20](Weak, sel_onActivityPrivate_error_, v18, v19, v17);
    }
    objc_opt_class();
    result = objc_opt_isKindOfClass();
    if ((result & 1) != 0)
    {
      v23 = (void *)objc_msgSend_objectForKeyedSubscript_(v15, v20, (uint64_t)CFSTR("EventType"), v21, v22);
      isEqualToString = objc_msgSend_isEqualToString_(v23, v24, (uint64_t)CFSTR("Activity"), v25, v26);
      v28 = objc_loadWeak((id *)(v3 + 32));
      v32 = v28;
      if (isEqualToString)
      {
        v33 = objc_msgSend_objectForKeyedSubscript_(v15, v29, (uint64_t)CFSTR("PayloadData"), v30, v31);
        v19 = objc_msgSend_objectForKeyedSubscript_(v15, v34, (uint64_t)CFSTR("PayloadError"), v35, v36);
        Weak = v32;
        v18 = v33;
        return MEMORY[0x1E0DE7D20](Weak, sel_onActivityPrivate_error_, v18, v19, v17);
      }
      return MEMORY[0x1E0DE7D20](v28, sel_onStatusEventPrivate_, v15, v30, v31);
    }
  }
  return result;
}

uint64_t sub_18F48C7D8(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  char *v6;
  uint8_t buf[4];
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE78 != -1)
    dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
  v2 = off_1ECEDEE70;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEBUG))
  {
    v3 = a1[4];
    v4 = a1[5];
    *(_DWORD *)buf = 138543618;
    v8 = v3;
    v9 = 2114;
    v10 = v4;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "[CMHeadphoneActivityManager] motion activity: %{public}@ error: %{public}@", buf, 0x16u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneActivityManager onActivityPrivate:error:]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf)
      free(v6);
  }
  return (*(uint64_t (**)(void))(a1[6] + 16))();
}

void sub_18F48CC1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_18F48CC40(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  id Weak;
  uint64_t v15;
  uint64_t v16;

  if (a2)
  {
    v3 = result;
    v4 = (void *)MEMORY[0x1E0CB3710];
    v5 = (void *)MEMORY[0x1E0C99E60];
    v6 = objc_opt_class();
    v7 = objc_opt_class();
    v11 = objc_msgSend_setWithObjects_(v5, v8, v6, v9, v10, v7, 0);
    v13 = objc_msgSend_unarchivedObjectOfClasses_fromData_error_(v4, v12, v11, a2, 0);
    objc_opt_class();
    result = objc_opt_isKindOfClass();
    if ((result & 1) != 0)
    {
      Weak = objc_loadWeak((id *)(v3 + 32));
      return MEMORY[0x1E0DE7D20](Weak, sel_onStatusEventPrivate_, v13, v15, v16);
    }
  }
  return result;
}

void sub_18F48D050(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  char *v9;
  _QWORD v10[5];
  __int16 v11;
  uint8_t buf[1640];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 74))
  {
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
    v2 = off_1ECEDEE70;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "[CMHeadphoneActivityManager] Device connected", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE78 != -1)
        dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
      v11 = 0;
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneActivityManager notifyDeviceConnectedEventToClientPrivate]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 74) = 1;
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(_QWORD *)(v6 + 64);
    if (v7)
    {
      v8 = *(void **)(v6 + 56);
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 3221225472;
      v10[2] = sub_18F48D24C;
      v10[3] = &unk_1E2955B10;
      v10[4] = v7;
      objc_msgSend_addOperationWithBlock_(v8, v3, (uint64_t)v10, v4, v5);
    }
  }
}

uint64_t sub_18F48D24C(uint64_t a1)
{
  NSObject *v2;
  char *v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE78 != -1)
    dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
  v2 = off_1ECEDEE70;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "[CMHeadphoneActivityManager] notifying client of connection", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneActivityManager notifyDeviceConnectedEventToClientPrivate]_block_invoke", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_18F48D450(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  char *v9;
  _QWORD v10[5];
  __int16 v11;
  uint8_t buf[1640];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 74))
  {
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
    v2 = off_1ECEDEE70;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "[CMHeadphoneActivityManager] Device disconnected", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE78 != -1)
        dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
      v11 = 0;
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneActivityManager notifyDeviceDisconnectedEventToClientPrivate]_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 74) = 0;
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(_QWORD *)(v6 + 64);
    if (v7)
    {
      v8 = *(void **)(v6 + 56);
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 3221225472;
      v10[2] = sub_18F48D648;
      v10[3] = &unk_1E2955B10;
      v10[4] = v7;
      objc_msgSend_addOperationWithBlock_(v8, v3, (uint64_t)v10, v4, v5);
    }
  }
}

uint64_t sub_18F48D648(uint64_t a1)
{
  NSObject *v2;
  char *v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE78 != -1)
    dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
  v2 = off_1ECEDEE70;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "[CMHeadphoneActivityManager] notifying client of disconnection", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2958C40);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneActivityManager notifyDeviceDisconnectedEventToClientPrivate]_block_invoke", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

os_log_t sub_18F48D7EC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1ECEDEE30 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F48D818(_QWORD *a1, __int128 *a2)
{
  _QWORD *v4;
  __int128 v5;

  v4 = sub_18F46C450(a1);
  *v4 = &off_1E294BA18;
  v5 = *a2;
  *(_OWORD *)((char *)v4 + 122) = *(__int128 *)((char *)a2 + 10);
  *((_OWORD *)v4 + 7) = v5;
  sub_18F48D8A0((uint64_t)v4);
  return a1;
}

void sub_18F48D860(_Unwind_Exception *a1)
{
  _DWORD *v1;

  sub_18F46C4C4(v1);
  _Unwind_Resume(a1);
}

void sub_18F48D878(_DWORD *a1)
{
  sub_18F46C4C4(a1);
  JUMPOUT(0x194001438);
}

void sub_18F48D8A0(uint64_t a1)
{
  NSObject *v2;
  int v3;
  int v4;
  char *v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  bzero(&v6, 0x12uLL);
  v6 = *(_QWORD *)(a1 + 126);
  v7 = *(_DWORD *)(a1 + 134);
  if (qword_1EE16D698 != -1)
    dispatch_once(&qword_1EE16D698, &unk_1E2953F68);
  v2 = qword_1EE16D690;
  if (os_log_type_enabled((os_log_t)qword_1EE16D690, OS_LOG_TYPE_INFO))
  {
    v3 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)buf = 67110656;
    v23 = (__int16)v6;
    v24 = 1024;
    v25 = SWORD1(v6);
    v26 = 1024;
    v27 = SWORD2(v6);
    v28 = 1024;
    v29 = SHIWORD(v6);
    v30 = 1024;
    v31 = (__int16)v7;
    v32 = 1024;
    v33 = SHIWORD(v7);
    v34 = 1024;
    v35 = v3;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d", buf, 0x2Cu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D698 != -1)
      dispatch_once(&qword_1EE16D698, &unk_1E2953F68);
    v4 = *(_DWORD *)(a1 + 64);
    v8 = 67110656;
    v9 = (__int16)v6;
    v10 = 1024;
    v11 = SWORD1(v6);
    v12 = 1024;
    v13 = SWORD2(v6);
    v14 = 1024;
    v15 = SHIWORD(v6);
    v16 = 1024;
    v17 = (__int16)v7;
    v18 = 1024;
    v19 = SHIWORD(v7);
    v20 = 1024;
    v21 = v4;
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLMagnetometerCoexistenceNotifierCpasV11::chooseOffsetData()", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
  sub_18F46D240((float32x2_t *)a1, (__int16 *)&v6);
}

float sub_18F48DB10(float *a1)
{
  uint64_t v1;
  float v2;
  float v3;
  float v5;
  float v6;
  float v7;
  unsigned __int8 v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;

  v1 = 0;
  v2 = 0.0;
  do
  {
    v2 = v2 + (float)(a1[v1] * a1[v1]);
    ++v1;
  }
  while (v1 != 3);
  v3 = sqrtf(v2);
  if (v3 < 0.001)
    return 0.0;
  v5 = *a1;
  v6 = a1[1];
  v7 = a1[2];
  v8 = atomic_load((unsigned __int8 *)&qword_1EE16E9F0);
  if ((v8 & 1) == 0 && __cxa_guard_acquire(&qword_1EE16E9F0))
  {
    v12 = sub_18F3FF4CC();
    *(float *)&dword_1EE16E9E0 = v12 + v12;
    *(float *)algn_1EE16E9E4 = v13 + v13;
    *(float *)&dword_1EE16E9E8 = v14 + v14;
    __cxa_guard_release(&qword_1EE16E9F0);
  }
  v9 = (float)(v7 / v3) * *(float *)&dword_1EE16E9E8;
  v10 = (float)(v9 + (float)((float)(v6 / v3) * *(float *)algn_1EE16E9E4))
      + (float)((float)(v5 / v3) * *(float *)&dword_1EE16E9E0);
  v11 = 1.0;
  if (v10 <= 1.0)
  {
    v11 = -1.0;
    if (v10 >= -1.0)
      v11 = (float)(v9 + (float)((float)(v6 / v3) * *(float *)algn_1EE16E9E4))
          + (float)((float)(v5 / v3) * *(float *)&dword_1EE16E9E0);
  }
  return acosf(v11);
}

void sub_18F48DC18(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1EE16E9F0);
  _Unwind_Resume(a1);
}

uint64_t sub_18F48DC30(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;

  v4 = (_OWORD *)(a1 + 24);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 32) = 0x3F80000000000000;
  sub_18F1FFE94((float32x4_t *)(a1 + 24), (float32x4_t)0);
  *(_OWORD *)(a1 + 40) = xmmword_18F505C20;
  sub_18F1FFE94((float32x4_t *)(a1 + 40), (float32x4_t)xmmword_18F505C20);
  if (a2 != a1)
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
    *v4 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  }
  return a1;
}

void sub_18F48DCD8(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  _BOOL4 v8;
  NSObject *v9;
  unint64_t v10;
  NSObject *v11;
  unint64_t v12;
  unsigned int v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  NSObject *v20;
  const char *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  uint8_t buf[4];
  unint64_t v30;
  __int16 v31;
  _BYTE v32[14];
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v4 = (unint64_t)(*(double *)(a2 + 40) * 1000000.0);
  v5 = *(_DWORD *)a2;
  v6 = (*(_DWORD *)a2 < 0xCu) & (6u >> *(_DWORD *)a2);
  v7 = *(_DWORD *)a1;
  v8 = 1;
  if (*(_DWORD *)a1 > 0xBu)
  {
LABEL_4:
    if ((v6 & v8) == 1 && !*(_QWORD *)(a1 + 16))
    {
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = v4;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v11 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
      {
        v12 = *(_QWORD *)(a1 + 16);
        *(_DWORD *)buf = 134349056;
        v30 = v12;
        _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_INFO, "[RelDM] Activity: detected moving to static. staticStartTime, %{public}llu", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 == -1)
          goto LABEL_81;
        goto LABEL_83;
      }
    }
    else if (v7 <= 0xB
           && ((1 << v7) & 0xC06) != 0
           && (v7 & 0xFFFFFFFE) != 10
           && ((*(_DWORD *)a2 > 0xBu) | (0xFF8u >> *(_DWORD *)a2) & 1) != 0)
    {
      *(_QWORD *)(a1 + 8) = v4;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v9 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
      {
        v10 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)buf = 134349056;
        v30 = v10;
        _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "[RelDM] Activity: detected static to moving. movingStartTime, %{public}llu", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 == -1)
        {
LABEL_81:
          v28 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMRelDM::ActivityState::feedActivity(const CLMotionActivity &)", "CoreLocation: %s\n", v28);
          if (v28 != (char *)buf)
            free(v28);
          goto LABEL_25;
        }
LABEL_83:
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
        goto LABEL_81;
      }
    }
LABEL_25:
    v13 = *(_DWORD *)a1;
    if (*(_DWORD *)a2 == 1)
    {
      if (v13 == 1)
        goto LABEL_62;
      *(_QWORD *)(a1 + 32) = -1;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v14 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134349056;
        v30 = v4;
        _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_INFO, "[RelDM] Activity: entered frozen state, %{public}llu", buf, 0xCu);
      }
      if (!sub_18F1FCA08(115, 2))
        goto LABEL_40;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
        goto LABEL_73;
    }
    else
    {
      if (v13 != 1)
      {
LABEL_41:
        if (v13 == 41 || v13 == 4)
        {
          if (*(_DWORD *)a2 != 4 && *(_DWORD *)a2 != 41)
          {
            *(_QWORD *)(a1 + 24) = v4;
            if (qword_1EE16D818 != -1)
              dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
            v16 = qword_1EE16D820;
            if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 134349056;
              v30 = v4;
              _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_INFO, "[RelDM] Activity: walking stopped, %{public}llu", buf, 0xCu);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1EE16D818 != -1)
                dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
LABEL_78:
              v27 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "void CMRelDM::ActivityState::feedActivity(const CLMotionActivity &)", "CoreLocation: %s\n", v27);
              if (v27 != (char *)buf)
                free(v27);
              goto LABEL_62;
            }
          }
        }
        else if (*(_DWORD *)a2 == 41 || *(_DWORD *)a2 == 4)
        {
          *(_QWORD *)(a1 + 24) = -1;
        }
        goto LABEL_62;
      }
      *(_QWORD *)(a1 + 32) = v4;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v15 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134349056;
        v30 = v4;
        _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_INFO, "[RelDM] Activity: exited frozen state, %{public}llu", buf, 0xCu);
      }
      if (!sub_18F1FCA08(115, 2))
      {
LABEL_40:
        v13 = *(_DWORD *)a1;
        goto LABEL_41;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
      {
LABEL_73:
        v26 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMRelDM::ActivityState::feedActivity(const CLMotionActivity &)", "CoreLocation: %s\n", v26);
        if (v26 != (char *)buf)
          free(v26);
        goto LABEL_40;
      }
    }
    dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
    goto LABEL_73;
  }
  if (((1 << v7) & 0xC06) != 0)
  {
    v8 = (v7 & 0xFFFFFFFE) == 10;
    goto LABEL_4;
  }
  if (v7)
    goto LABEL_4;
  if (v6)
  {
    *(_QWORD *)(a1 + 16) = v4;
    if (v5 == 1)
      *(_QWORD *)(a1 + 32) = -1;
  }
  else if ((*(_DWORD *)a2 > 0xBu) | (0xFF8u >> *(_DWORD *)a2) & 1)
  {
    *(_QWORD *)(a1 + 8) = v4;
  }
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
  v17 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
  {
    v18 = CLMotionActivity::activityTypeToString(*(_DWORD *)a2);
    v19 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)buf = 136446466;
    v30 = (unint64_t)v18;
    v31 = 2050;
    *(_QWORD *)v32 = v19;
    _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_DEFAULT, "[RelDM] Activity: initialize srcMotionState. type %{public}s, timestamp, %{public}f", buf, 0x16u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
    CLMotionActivity::activityTypeToString(*(_DWORD *)a2);
    goto LABEL_78;
  }
LABEL_62:
  *(_QWORD *)a1 = *(_QWORD *)a2;
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
  v20 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
  {
    v21 = CLMotionActivity::activityTypeToString(*(_DWORD *)a1);
    v22 = *(_DWORD *)(a1 + 4);
    v24 = *(_QWORD *)(a1 + 8);
    v23 = *(_QWORD *)(a1 + 16);
    *(_DWORD *)buf = 136447234;
    v30 = (unint64_t)v21;
    v31 = 1026;
    *(_DWORD *)v32 = v22;
    *(_WORD *)&v32[4] = 2050;
    *(_QWORD *)&v32[6] = v4;
    v33 = 2050;
    v34 = v23;
    v35 = 2050;
    v36 = v24;
    _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_INFO, "[RelDM] ActivityType, %{public}s, confidence, %{public}d, timestamp, %{public}llu, lastStaticTS, %{public}llu, lastMovingTS, %{public}llu", buf, 0x30u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
    CLMotionActivity::activityTypeToString(*(_DWORD *)a1);
    v25 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMRelDM::ActivityState::feedActivity(const CLMotionActivity &)", "CoreLocation: %s\n", v25);
    if (v25 != (char *)buf)
      free(v25);
  }
}

void sub_18F48E728(int *a1, unint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  NSObject *v8;
  uint64_t v9;
  char *v10;
  uint8_t buf[4];
  unint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (*a1 <= 0xB)
  {
    if (((1 << v4) & 0xC06) != 0)
    {
      if ((v4 & 0xFFFFFFFE) != 0xA)
        return;
    }
    else if (!v4)
    {
      return;
    }
  }
  v5 = *((_QWORD *)a1 + 1);
  v7 = a2 >= v5;
  v6 = a2 - v5;
  v7 = v6 != 0 && v7 && v6 >= 0x30D41;
  if (v7 && *((_QWORD *)a1 + 2))
  {
    *((_QWORD *)a1 + 2) = 0;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
    v8 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
    {
      v9 = *((_QWORD *)a1 + 1);
      *(_DWORD *)buf = 134349312;
      v12 = a2;
      v13 = 2050;
      v14 = v9;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEBUG, "[RelDM] Activity: Reseting static startTime. Curr %{public}llu, lastMoving, %{public}llu", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMRelDM::ActivityState::feedWatchdogTimestamp(uint64_t)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
  }
}

float sub_18F48E94C(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  float v3;
  BOOL v5;
  unint64_t v6;
  NSObject *v8;
  uint64_t v9;
  char *v11;
  uint8_t buf[4];
  unint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 16);
  v3 = 0.0;
  if (v2)
  {
    v5 = a2 >= v2;
    v6 = a2 - v2;
    if (v6 != 0 && v5)
    {
      return (float)v6 * 0.000001;
    }
    else
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v8 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
      {
        v9 = *(_QWORD *)(a1 + 16);
        *(_DWORD *)buf = 134349312;
        v13 = a2;
        v14 = 2050;
        v15 = v9;
        _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "[RelDM] Activity:timestamp error: current %{public}llu, lastStatic, %{public}llu", buf, 0x16u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
        v11 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "float CMRelDM::ActivityState::getStaticDuration(uint64_t) const", "CoreLocation: %s\n", v11);
        if (v11 != (char *)buf)
          free(v11);
      }
    }
  }
  return v3;
}

float sub_18F48EB4C(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  float v3;
  BOOL v5;
  unint64_t v6;
  NSObject *v8;
  uint64_t v9;
  char *v11;
  uint8_t buf[4];
  unint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  v3 = 0.0;
  if (v2)
  {
    v5 = a2 >= v2;
    v6 = a2 - v2;
    if (v6 != 0 && v5)
    {
      return (float)v6 * 0.000001;
    }
    else
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v8 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
      {
        v9 = *(_QWORD *)(a1 + 8);
        *(_DWORD *)buf = 134349312;
        v13 = a2;
        v14 = 2050;
        v15 = v9;
        _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "[RelDM] Activity:timestamp error: current %{public}llu, lastMoving, %{public}llu", buf, 0x16u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
        v11 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "float CMRelDM::ActivityState::getMovingDuration(uint64_t) const", "CoreLocation: %s\n", v11);
        if (v11 != (char *)buf)
          free(v11);
      }
    }
  }
  return v3;
}

float sub_18F48ED4C(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  float result;
  BOOL v5;
  unint64_t v6;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *v11;
  uint8_t buf[4];
  unint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
    return 3.4028e38;
  if (v2 == -1)
    return 0.0;
  v5 = a2 >= v2;
  v6 = a2 - v2;
  if (v6 != 0 && v5)
    return (float)v6 * 0.000001;
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
  v8 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
  {
    v9 = *(_QWORD *)(a1 + 24);
    *(_DWORD *)buf = 134349312;
    v13 = a2;
    v14 = 2050;
    v15 = v9;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "[RelDM] Activity:timestamp error: current %{public}llu, lastWalkStop, %{public}llu", buf, 0x16u);
  }
  v10 = sub_18F1FCA08(115, 2);
  result = 0.0;
  if (v10)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "float CMRelDM::ActivityState::getTimeSinceWalkingStopped(uint64_t) const", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
    return 0.0;
  }
  return result;
}

float sub_18F48EF5C(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  float result;
  BOOL v5;
  unint64_t v6;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *v11;
  uint8_t buf[4];
  unint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    return 3.4028e38;
  if (v2 == -1)
    return 0.0;
  v5 = a2 >= v2;
  v6 = a2 - v2;
  if (v6 != 0 && v5)
    return (float)v6 * 0.000001;
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
  v8 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
  {
    v9 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 134349312;
    v13 = a2;
    v14 = 2050;
    v15 = v9;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "[RelDM] Activity:timestamp error: current %{public}llu, lastFrozenStopTimestamp, %{public}llu", buf, 0x16u);
  }
  v10 = sub_18F1FCA08(115, 2);
  result = 0.0;
  if (v10)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "float CMRelDM::ActivityState::getTimeSinceLastFrozenState(uint64_t) const", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
    return 0.0;
  }
  return result;
}

unint64_t sub_18F48F16C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  double v9;
  NSObject *v10;
  char *v11;
  char *v12;
  char *v13;
  unint64_t v14;
  _QWORD *v15;
  const void *v16;
  unint64_t v17;
  NSObject *v18;
  uint64_t v19;
  unint64_t result;
  unint64_t v21;
  NSObject *v22;
  int v23;
  int v24;
  void *v25;
  char *v26;
  int v27;
  int v28;
  char *v29;
  void *__p[4];
  uint8_t buf[1640];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  ++*(_DWORD *)a1;
  if (*(double *)(a1 + 8) == 0.0)
  {
    v6 = *(unsigned __int16 *)(a1 + 18);
    if (*(_WORD *)(a1 + 18))
    {
      if (v6 > 2)
      {
        memset(__p, 0, 24);
        sub_18F26F880(__p, v6);
        v12 = (char *)__p[1];
        bzero(__p[1], 8 * v6);
        v13 = &v12[8 * v6];
        __p[1] = v13;
        if (*(_WORD *)(a1 + 18))
        {
          v14 = 0;
          do
          {
            v15 = (_QWORD *)sub_18F355C78((unsigned __int16 *)(a1 + 16), v14);
            v16 = __p[0];
            *((_QWORD *)__p[0] + v14++) = *v15;
          }
          while (v14 < *(unsigned __int16 *)(a1 + 18));
          v13 = (char *)__p[1];
        }
        else
        {
          v16 = __p[0];
        }
        memset(buf, 0, 24);
        sub_18F436CA4(buf, v16, (uint64_t)v13, (v13 - (_BYTE *)v16) >> 3);
        std::__sort<std::__less<double,double> &,double *>();
        v17 = (unint64_t)((uint64_t)(*(_QWORD *)&buf[8] - *(_QWORD *)buf) >> 3) >> 1;
        if (((*(_DWORD *)&buf[8] - *(_DWORD *)buf) & 8) != 0)
          v9 = *(double *)(*(_QWORD *)buf + 8 * v17);
        else
          v9 = (*(double *)(*(_QWORD *)buf + 8 * v17 - 8) + *(double *)(*(_QWORD *)buf + 8 * v17)) * 0.5;
        *(_QWORD *)&buf[8] = *(_QWORD *)buf;
        operator delete(*(void **)buf);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
      }
      else
      {
        v7 = v6 + *(unsigned __int16 *)(a1 + 16) - 1;
        v8 = *(unsigned int *)(a1 + 20);
        if (v7 < v8)
          v8 = 0;
        v9 = *(double *)(a1 + 16 + 8 * (v7 - v8) + 8);
      }
    }
    else
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v10 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_ERROR, "[RelDM][UnTimesyncedAuxSampleHelper] Buffer is empty.", buf, 2u);
      }
      v9 = 0.0;
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
        LOWORD(__p[0]) = 0;
        v11 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "double CMRelDM::UnTimesyncedAuxSampleHelper::getMedianOffset() const", "CoreLocation: %s\n", v11);
        if (v11 != (char *)buf)
          free(v11);
      }
    }
    *(double *)(a1 + 8) = v9;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
    v18 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEFAULT))
    {
      v19 = *(_QWORD *)(a1 + 8);
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v19;
      _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_DEFAULT, "[RelDM] Using auxTimeOfArrival. Offset, %f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v25 = *(void **)(a1 + 8);
      LODWORD(__p[0]) = 134217984;
      *(void **)((char *)__p + 4) = v25;
      v26 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "uint64_t CMRelDM::UnTimesyncedAuxSampleHelper::constructAuxTimestampFromUntimesyncedAuxSample(uint64_t, uint64_t)", "CoreLocation: %s\n", v26);
      if (v26 != (char *)buf)
        free(v26);
    }
  }
  result = (uint64_t)(*(double *)(a1 + 8) * 1000000.0) + a2;
  v21 = result - a3;
  if (result > a3)
  {
    ++*(_DWORD *)(a1 + 4);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
    v22 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_ERROR))
    {
      v23 = *(_DWORD *)a1;
      v24 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)buf = 134218496;
      *(double *)&buf[4] = (float)((float)v21 * 0.001);
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v23;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_ERROR, "[RelDM] fake auxTimestamp is ahead of src, diffMS: %f, totalUnsynced: %u, totalOutlier, %u", buf, 0x18u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2953F88);
      v27 = *(_DWORD *)a1;
      v28 = *(_DWORD *)(a1 + 4);
      LODWORD(__p[0]) = 134218496;
      *(double *)((char *)__p + 4) = (float)((float)v21 * 0.001);
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v27;
      WORD1(__p[2]) = 1024;
      HIDWORD(__p[2]) = v28;
      v29 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "uint64_t CMRelDM::UnTimesyncedAuxSampleHelper::constructAuxTimestampFromUntimesyncedAuxSample(uint64_t, uint64_t)", "CoreLocation: %s\n", v29);
      if (v29 != (char *)buf)
        free(v29);
    }
    if (*(_DWORD *)a1 >= 0x15u && (float)((float)*(unsigned int *)a1 * 0.15) < (float)*(unsigned int *)(a1 + 4))
      sub_18F3B1628(a1, 0);
    return a3;
  }
  return result;
}

void sub_18F48F794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p)
    operator delete(__p);
  if (a11)
    operator delete(a11);
  _Unwind_Resume(exception_object);
}

os_log_t sub_18F48F7D8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1EE16D820 = (uint64_t)result;
  return result;
}

void sub_18F48F978(float *a1@<X0>, float *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, float *a5@<X8>)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  float *v10;
  uint64_t v11;
  float *v12;
  float v13;
  float *v14;
  float *v15;
  float *v16;
  float *v17;
  float *v18;
  float v19;
  float v20;
  unint64_t v21;
  float v22;
  float *v23;
  float *v24;
  float *v25;
  float *v26;
  float *v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float *v32;
  float v33;
  float *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  float *v40;
  int v41;
  float *v42;
  float v43;
  float *v44;
  float *v45;
  float *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  float *v52;
  int v53;
  NSObject *v54;
  NSObject *v55;
  NSObject *v56;
  NSObject *v57;
  NSObject *v58;
  NSObject *v59;
  unint64_t v60;
  float *v61;
  float *v62;
  _BOOL4 v63;
  float *__p;
  float *v65;
  float *v66;
  uint64_t v67;
  uint64_t v68;
  uint8_t buf[4];
  int v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  const char *v74;
  __int16 v75;
  const char *v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v67 = a3;
  v68 = a4;
  *((_QWORD *)a5 + 1) = 0;
  *((_QWORD *)a5 + 2) = 0;
  *(_QWORD *)a5 = 0;
  v6 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)a1) >> 3);
  if (v6 >= 0x42)
  {
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2953FA8);
    v54 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v70 = 0;
      v71 = 2082;
      v72 = "";
      v73 = 2082;
      v74 = "assert";
      v75 = 2081;
      v76 = "n <= 65";
      _os_log_impl(&dword_18F1DC000, v54, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2953FA8);
    }
    v55 = qword_1ECEDEE60;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE60))
    {
      *(_DWORD *)buf = 68289539;
      v70 = 0;
      v71 = 2082;
      v72 = "";
      v73 = 2082;
      v74 = "assert";
      v75 = 2081;
      v76 = "n <= 65";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v55, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2953FA8);
    }
    v56 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v70 = 0;
      v71 = 2082;
      v72 = "";
      v73 = 2082;
      v74 = "assert";
      v75 = 2081;
      v76 = "n <= 65";
      _os_log_impl(&dword_18F1DC000, v56, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
LABEL_120:
    __break(1u);
  }
  v66 = 0;
  v7 = (v6 - 1) * v6;
  if (v7 <= 1)
    v8 = 1;
  else
    v8 = v7;
  if (v8 >> 62)
    sub_18F26F8C0();
  v10 = a1;
  __p = (float *)sub_18F26FB8C((uint64_t)&v66, v8);
  v66 = &__p[v11];
  v60 = v8;
  if (a2 == v10)
  {
    v63 = 0;
  }
  else
  {
    v12 = v10 + 6;
    if (v10 + 6 == a2)
    {
      v14 = v10;
      v12 = v10;
    }
    else
    {
      v13 = v10[6];
      if (v13 >= *v10)
        v14 = v10;
      else
        v14 = v10 + 6;
      if (v13 < *v10)
        v12 = v10;
      v15 = v10 + 12;
      if (v10 + 12 != a2)
      {
        if (v13 >= *v10)
          v13 = *v10;
        v16 = v10;
        while (1)
        {
          v17 = v15;
          v18 = v15 + 6;
          if (v18 == a2)
            break;
          v19 = v17[6];
          v20 = *v17;
          if (v19 >= *v17)
          {
            if (v20 < v13)
            {
              v13 = *v17;
              v14 = v17;
            }
            if (v19 >= *v12)
              v12 = v16 + 18;
          }
          else
          {
            v13 = *v14;
            if (v19 < *v14)
            {
              v13 = v17[6];
              v14 = v18;
            }
            if (v20 >= *v12)
              v12 = v17;
          }
          v15 = v17 + 12;
          v16 = v17;
          if (v17 + 12 == a2)
            goto LABEL_32;
        }
        if (*v17 >= *v14)
        {
          if (*v17 >= *v12)
            v12 = v17;
        }
        else
        {
          v14 = v17;
        }
      }
    }
LABEL_32:
    v63 = (float)(*v12 - *v14) >= 3.0;
  }
  v21 = 0;
  v61 = v10;
  v62 = v10 + 6;
  do
  {
    if (BYTE4(v68))
    {
      v22 = *(float *)sub_18F33D3D0((uint64_t)&v67, v21);
      goto LABEL_36;
    }
    v23 = __p;
    if (!v63)
      goto LABEL_65;
    v65 = __p;
    if (v10 == a2)
      goto LABEL_86;
    if (v62 != a2)
    {
      v24 = v62;
      v25 = v10;
      do
      {
        v26 = v25;
        v25 = v24;
        v27 = v24;
        do
        {
          v28 = *v26;
          v29 = *v27;
          if (vabds_f32(*v26, *v27) > 0.25)
          {
            v30 = sub_18F3551B0((uint64_t)(v26 + 1), v21);
            v31 = sub_18F3551B0((uint64_t)(v27 + 1), v21);
            v32 = v65;
            v33 = (float)(v30 - v31) / (float)(v28 - v29);
            if (v65 >= v66)
            {
              v34 = __p;
              v35 = v65 - __p;
              v36 = v35 + 1;
              if ((unint64_t)(v35 + 1) >> 62)
                sub_18F26F8C0();
              v37 = (char *)v66 - (char *)__p;
              if (((char *)v66 - (char *)__p) >> 1 > v36)
                v36 = v37 >> 1;
              if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFFCLL)
                v38 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v38 = v36;
              if (v38)
              {
                v39 = (char *)sub_18F26FB8C((uint64_t)&v66, v38);
                v34 = __p;
                v32 = v65;
              }
              else
              {
                v39 = 0;
              }
              v40 = (float *)&v39[4 * v35];
              *v40 = v33;
              v23 = v40 + 1;
              while (v32 != v34)
              {
                v41 = *((_DWORD *)v32-- - 1);
                *((_DWORD *)v40-- - 1) = v41;
              }
              __p = v40;
              v66 = (float *)&v39[4 * v38];
              if (v34)
                operator delete(v34);
            }
            else
            {
              *v65 = v33;
              v23 = v65 + 1;
            }
            v65 = v23;
          }
          v27 += 6;
        }
        while (v27 != a2);
        v24 = v25 + 6;
      }
      while (v25 + 6 != a2);
      if (v23 == __p)
      {
        v23 = __p;
        v10 = v61;
      }
      else
      {
        v22 = sub_18F3D32B4((uint64_t)__p, v23);
        v10 = v61;
LABEL_36:
        a5[v21] = v22;
        v23 = __p;
      }
LABEL_65:
      v65 = v23;
      if (v10 == a2)
        goto LABEL_86;
    }
    v42 = v10;
    do
    {
      v43 = sub_18F3551B0((uint64_t)(v42 + 1), v21) - (float)(a5[v21] * *v42);
      v44 = v65;
      if (v65 >= v66)
      {
        v46 = __p;
        v47 = v65 - __p;
        v48 = v47 + 1;
        if ((unint64_t)(v47 + 1) >> 62)
          sub_18F26F8C0();
        v49 = (char *)v66 - (char *)__p;
        if (((char *)v66 - (char *)__p) >> 1 > v48)
          v48 = v49 >> 1;
        if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL)
          v50 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v50 = v48;
        if (v50)
        {
          v51 = (char *)sub_18F26FB8C((uint64_t)&v66, v50);
          v46 = __p;
          v44 = v65;
        }
        else
        {
          v51 = 0;
        }
        v52 = (float *)&v51[4 * v47];
        *v52 = v43;
        v45 = v52 + 1;
        while (v44 != v46)
        {
          v53 = *((_DWORD *)v44-- - 1);
          *((_DWORD *)v52-- - 1) = v53;
        }
        __p = v52;
        v66 = (float *)&v51[4 * v50];
        if (v46)
          operator delete(v46);
      }
      else
      {
        *v65 = v43;
        v45 = v65 + 1;
      }
      v65 = v45;
      v42 += 6;
    }
    while (v42 != a2);
    if (v45 != __p)
      a5[v21 + 3] = sub_18F3D32B4((uint64_t)__p, v45);
LABEL_86:
    ++v21;
  }
  while (v21 != 3);
  if (v60 != v66 - __p)
  {
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2953FA8);
    v57 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v70 = 0;
      v71 = 2082;
      v72 = "";
      v73 = 2082;
      v74 = "assert";
      v75 = 2081;
      v76 = "buffer.capacity() == std::max<size_t>(1, n * (n - 1))";
      _os_log_impl(&dword_18F1DC000, v57, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2953FA8);
    }
    v58 = qword_1ECEDEE60;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE60))
    {
      *(_DWORD *)buf = 68289539;
      v70 = 0;
      v71 = 2082;
      v72 = "";
      v73 = 2082;
      v74 = "assert";
      v75 = 2081;
      v76 = "buffer.capacity() == std::max<size_t>(1, n * (n - 1))";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v58, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2953FA8);
    }
    v59 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v70 = 0;
      v71 = 2082;
      v72 = "";
      v73 = 2082;
      v74 = "assert";
      v75 = 2081;
      v76 = "buffer.capacity() == std::max<size_t>(1, n * (n - 1))";
      _os_log_impl(&dword_18F1DC000, v59, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
    goto LABEL_120;
  }
  if (__p)
    operator delete(__p);
}

void sub_18F4902C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F49041C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;

  if (a19 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F490458(uint64_t a1, CLConnectionMessage **a2)
{
  void *Dictionary;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  char *v13;
  uint8_t buf[4];
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*a2
    && (Dictionary = (void *)CLConnectionMessage::getDictionary(*a2)) != 0
    && (v6 = (void *)objc_msgSend_objectForKeyedSubscript_(Dictionary, v3, (uint64_t)CFSTR("CMErrorMessage"), v4, v5)) != 0)
  {
    v11 = objc_msgSend_intValue(v6, v7, v8, v9, v10);
  }
  else
  {
    v11 = 103;
  }
  if (qword_1EE16D6A0 != -1)
    dispatch_once(&qword_1EE16D6A0, &unk_1E2943B90);
  v12 = qword_1EE16D6A8;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67240192;
    v15 = v11;
    _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_FAULT, "CMWorkoutMets, Failed with CMError code %{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6A0 != -1)
      dispatch_once(&qword_1EE16D6A0, &unk_1E2943B90);
    v13 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMWorkoutMetsInternal init]_block_invoke", "CoreLocation: %s\n", v13);
    if (v13 != (char *)buf)
      free(v13);
  }
}

void sub_18F490630(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t ExecutablePathFromPid;
  void *v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  pid_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  pid_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v2 = getpid();
  ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2, v4, v5);
  if (ExecutablePathFromPid)
  {
    v7 = (void *)ExecutablePathFromPid;
    if (qword_1EE16D6A0 != -1)
      dispatch_once(&qword_1EE16D6A0, &unk_1E2943B90);
    v8 = qword_1EE16D6A8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_INFO))
    {
      v13 = objc_msgSend_UTF8String(v7, v9, v10, v11, v12);
      v14 = getpid();
      v15 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 136446722;
      v22 = v13;
      v23 = 1026;
      v24 = v14;
      v25 = 2050;
      v26 = v15;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "CMWorkoutMets, Client connection interrupt, %{public}s, %{public}d, %{public}p", buf, 0x1Cu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6A0 != -1)
        dispatch_once(&qword_1EE16D6A0, &unk_1E2943B90);
      objc_msgSend_UTF8String(v7, v16, v17, v18, v19);
      getpid();
      v20 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMWorkoutMetsInternal init]_block_invoke", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf)
        free(v20);
    }
  }
}

void sub_18F490AF4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  id v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  _QWORD block[5];
  uint64_t v18;
  const __CFString *v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    v19 = CFSTR("CMWorkoutSessionIdKey");
    v20[0] = v5;
    v18 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v20, (uint64_t)&v19, 1);
    sub_18F3ED590("kCLConnectionMessageWorkoutMetsQuery", &v18, &v15);
    v14 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    CLConnectionClient::sendMessage();
    if (v14)
    {
      v8 = (unint64_t *)&v14->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v10 = v16;
    if (v16)
    {
      v11 = (unint64_t *)&v16->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  else
  {
    v13 = (id)objc_msgSend_copy(*(void **)(a1 + 48), a2, a3, a4, a5);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F490CDC;
    block[3] = &unk_1E2955B10;
    block[4] = v13;
    dispatch_async(MEMORY[0x1E0C80D38], block);
  }
}

void sub_18F490CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F490CDC(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 107, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F490D28(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  void *DictionaryOfClasses;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  NSObject *v26;
  char *v27;
  _QWORD v28[5];
  __int16 v29;
  _QWORD v30[6];
  _QWORD v31[6];
  _QWORD block[5];
  uint8_t buf[1640];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v6 = (id)objc_msgSend_copy(*(void **)(a1 + 32), a2, a3, a4, a5);
  v7 = (void *)MEMORY[0x1E0C99E60];
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  v10 = objc_opt_class();
  v14 = (NSSet *)objc_msgSend_setWithObjects_(v7, v11, v8, v12, v13, v9, v10, 0);
  if (*(_QWORD *)a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v14)) != 0)
  {
    v19 = DictionaryOfClasses;
    v20 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v16, (uint64_t)CFSTR("CMErrorMessage"), v17, v18);
    v24 = objc_msgSend_objectForKeyedSubscript_(v19, v21, (uint64_t)CFSTR("CMWorkoutMetsQueryResult"), v22, v23);
    if (v20)
    {
      v31[0] = MEMORY[0x1E0C809B0];
      v31[1] = 3221225472;
      v31[2] = sub_18F49108C;
      v31[3] = &unk_1E2955B60;
      v31[4] = v20;
      v31[5] = v6;
      v25 = v31;
    }
    else if (v24)
    {
      v30[0] = MEMORY[0x1E0C809B0];
      v30[1] = 3221225472;
      v30[2] = sub_18F4910EC;
      v30[3] = &unk_1E2955B60;
      v30[4] = v24;
      v30[5] = v6;
      v25 = v30;
    }
    else
    {
      if (qword_1EE16D6A0 != -1)
        dispatch_once(&qword_1EE16D6A0, &unk_1E2943B90);
      v26 = qword_1EE16D6A8;
      if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_FAULT, "Unable to parse kCLConnectionMessageWorkoutMetsQuery message.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D6A0 != -1)
          dispatch_once(&qword_1EE16D6A0, &unk_1E2943B90);
        v29 = 0;
        v27 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMWorkoutMetsInternal _queryWorkoutMetsWithSessionId:handler:]_block_invoke", "CoreLocation: %s\n", v27);
        if (v27 != (char *)buf)
          free(v27);
      }
      v28[0] = MEMORY[0x1E0C809B0];
      v28[1] = 3221225472;
      v28[2] = sub_18F491100;
      v28[3] = &unk_1E2955B10;
      v28[4] = v6;
      v25 = v28;
    }
  }
  else
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F491040;
    block[3] = &unk_1E2955B10;
    block[4] = v6;
    v25 = block;
  }
  dispatch_async(MEMORY[0x1E0C80D38], v25);
}

uint64_t sub_18F491040(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F49108C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4910EC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_18F491100(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F491248(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__teardown(*(void **)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5);
}

uint64_t sub_18F491374(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, (uint64_t)CFSTR("com.apple.locationd.activity"), a4, a5);
  qword_1ECEDFC00 = result;
  return result;
}

os_log_t sub_18F4913A8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1EE16D6A8 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4913D4(uint64_t a1)
{
  NSObject *v2;
  char *v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)a1 = 1;
  *(_QWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 28) = 0x1900000000;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0x7FF8000000000000;
  *(_BYTE *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 156) = 0x7FC0000000000000;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  if (qword_1EE16D8D8 != -1)
    dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
  v2 = qword_1EE16D8E0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "Constructing CMTNBDoTEstimatorBase.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CMTNBDoTEstimatorBase::CMTNBDoTEstimatorBase()", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
  return a1;
}

void sub_18F4915A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = 0;
  v4 = v1 + 176;
  while (1)
  {
    v5 = *(_QWORD *)(v4 + v3);
    *(_QWORD *)(v4 + v3) = 0;
    if (v5)
      MEMORY[0x194001438](v5, 0x1000C40FF89C88ELL);
    v3 -= 8;
    if (v3 == -16)
      _Unwind_Resume(exception_object);
  }
}

uint64_t sub_18F4915E4(uint64_t a1, uint64_t a2)
{
  float v4;
  float v5;
  unint64_t v6;
  unint64_t v7;
  float v8;
  double v9;
  float v10;
  __float2 v11;
  double v12;
  double v13;
  float v14;
  float v15;
  float v16;
  NSObject *v17;
  double v18;
  double v19;
  float v20;
  float v21;
  double v22;
  NSObject *v23;
  float v24;
  float v25;
  double v27;
  char *v28;
  float v29;
  float v30;
  char *v31;
  float v32;
  int v33;
  double v34;
  __int16 v35;
  double v36;
  __int16 v37;
  double v38;
  __int16 v39;
  double v40;
  __int16 v41;
  double v42;
  uint8_t buf[4];
  double v44;
  __int16 v45;
  double v46;
  __int16 v47;
  double v48;
  __int16 v49;
  double v50;
  __int16 v51;
  double v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a2 + 68))
  {
    v4 = atan2f(*(float *)(a2 + 48), *(float *)(a2 + 44));
    v5 = (float)(v4 + 1.5708) + floor(((float)(v4 + 1.5708) + 3.14159265) / 6.28318531) * -6.28318531;
    v32 = v5;
    if (*(_WORD *)(a1 + 30))
    {
      v6 = *(unsigned __int16 *)(a1 + 30) + (unint64_t)*(unsigned __int16 *)(a1 + 28) - 1;
      v7 = *(unsigned int *)(a1 + 32);
      if (v6 < v7)
        v7 = 0;
      v8 = *(float *)(a1 + 28 + 4 * (v6 - v7) + 8);
      v9 = (float)(v5 - v8);
      if (v9 <= 3.14159265)
      {
        if (v9 < -3.14159265)
          v9 = v9 + 6.28318531;
      }
      else
      {
        v9 = v9 + -6.28318531;
      }
      v10 = v9;
      v32 = v8 + v10;
    }
    sub_18F33D300(a1, &v32);
    v11 = __sincosf_stret(v32);
    *(float *)(a1 + 136) = v11.__cosval;
    *(float *)(a1 + 140) = v11.__sinval;
    v12 = *(double *)(a2 + 72);
    v13 = *(double *)(a1 + 144);
    if (*(_BYTE *)a1)
      sub_18F33FB38(a1);
    v14 = *(float *)(a1 + 8);
    if (v14 < 0.0)
      v14 = 0.0;
    v15 = sqrtf(v14);
    if (v15 <= 2.0944)
      v16 = 1.0;
    else
      v16 = 2.0944 / v15;
    if (v12 - v13 > 1.75)
      v16 = exp((v12 - v13 + -1.75) * -0.5) * v16;
    *(float *)(a1 + 156) = v16;
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
    v17 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
    {
      v18 = *(double *)(a1 + 144);
      *(_DWORD *)buf = 134218240;
      v44 = v12;
      v45 = 2048;
      v46 = v18;
      _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_DEBUG, "[CMTNBDoTEstimatorBase] timestamp, %.4f, timeOfLastStep, %.4f\n", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
      v27 = *(double *)(a1 + 144);
      v33 = 134218240;
      v34 = v12;
      v35 = 2048;
      v36 = v27;
      v28 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "CMTNBDoTEstimatorBase::TNBDoT CMTNBDoTEstimatorBase::directionFromTNB(const CMPdrInputs &)", "CoreLocation: %s\n", v28);
      if (v28 != (char *)buf)
        free(v28);
    }
    v19 = *(double *)(a1 + 144);
    v20 = sub_18F3412D8((unsigned __int16 *)(a1 + 28), (unsigned int (*)(float, float))sub_18F3414E0, 0);
    v21 = sub_18F3412D8((unsigned __int16 *)(a1 + 28), (unsigned int (*)(float, float))sub_18F3414D4, 0);
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
    v22 = v12 - v19;
    v23 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
    {
      if (*(_BYTE *)a1)
        sub_18F33FB38(a1);
      v24 = *(float *)(a1 + 8);
      if (v24 < 0.0)
        v24 = 0.0;
      v25 = *(float *)(a1 + 156);
      *(_DWORD *)buf = 134219008;
      v44 = (float)(sqrtf(v24) * 57.296);
      v45 = 2048;
      v46 = (float)(v20 * 57.296);
      v47 = 2048;
      v48 = (float)(v21 * 57.296);
      v49 = 2048;
      v50 = v22;
      v51 = 2048;
      v52 = v25;
      _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_DEBUG, "[CMTNBDoTEstimatorBase] Sway std %f, min, %f, max, %f, timeSinceStep, %f, quality, %.2f\n", buf, 0x34u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
      if (*(_BYTE *)a1)
        sub_18F33FB38(a1);
      v29 = *(float *)(a1 + 8);
      if (v29 < 0.0)
        v29 = 0.0;
      v33 = 134219008;
      v30 = *(float *)(a1 + 156);
      v34 = (float)(sqrtf(v29) * 57.296);
      v35 = 2048;
      v36 = (float)(v20 * 57.296);
      v37 = 2048;
      v38 = (float)(v21 * 57.296);
      v39 = 2048;
      v40 = v22;
      v41 = 2048;
      v42 = v30;
      v31 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMTNBDoTEstimatorBase::printDebugInfo(double) const", "CoreLocation: %s\n", v31);
      if (v31 != (char *)buf)
        free(v31);
    }
  }
  return *(_QWORD *)(a1 + 136);
}

double sub_18F491BA0(uint64_t a1, double a2)
{
  float v2;
  double result;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = *(float *)(a1 + 160);
  *(_BYTE *)(a1 + 152) = 0;
  result = v2 * 0.5 + a2;
  *(double *)(a1 + 144) = result;
  return result;
}

BOOL sub_18F491D70(uint64_t a1)
{
  uint64_t v2;
  char v3;
  char v4;
  uint64_t v5;
  int *v6;
  uint64_t i;
  int v8;
  uint64_t v9;
  uint64_t v10;
  float **v11;
  uint64_t v12;
  int v13;
  _BOOL8 result;

  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    v5 = operator new();
    *(_OWORD *)v5 = xmmword_18F503FB0;
    v6 = &dword_18F50871C;
    for (i = 52; i != 32; i -= 4)
    {
      v8 = *v6++;
      *(_DWORD *)(v5 + i) = v8;
    }
    *(float *)(v5 + 40) = -*(float *)(v5 + 40);
    *(float *)(v5 + 48) = -*(float *)(v5 + 48);
    *(_OWORD *)(v5 + 56) = *(_OWORD *)(v5 + 36);
    v9 = a1 + 8 * v2;
    v12 = *(_QWORD *)(v9 + 168);
    v11 = (float **)(v9 + 168);
    v10 = v12;
    *v11 = (float *)v5;
    if (v12)
      MEMORY[0x194001438](v10, 0x1000C40FF89C88ELL);
    v13 = 4;
    do
    {
      result = sub_18F33F604(*v11, 0.0);
      --v13;
    }
    while (v13);
    v3 = 0;
    v2 = 1;
  }
  while ((v4 & 1) != 0);
  return result;
}

float sub_18F491E70(uint64_t a1, float *a2)
{
  unint64_t v4;
  float v5;
  float v6;
  char v7;
  char v8;
  char v9;
  float *v10;
  float v11;
  BOOL v12;
  float v13;
  float v14;

  v4 = 0;
  v6 = *a2;
  v5 = a2[1];
  v7 = 1;
  v8 = 1;
  do
  {
    v9 = v7;
    v10 = *(float **)(a1 + 8 * v4 + 168);
    v11 = sub_18F43F0C8((uint64_t)a2, v4);
    v12 = sub_18F33F604(v10, v11);
    v7 = 0;
    v8 &= v12;
    v4 = 1;
  }
  while ((v9 & 1) != 0);
  if ((v8 & 1) != 0)
  {
    v13 = *(float *)(*(_QWORD *)(a1 + 168) + 4 * *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8) + 16);
    v14 = *(float *)(*(_QWORD *)(a1 + 176) + 4 * *(_QWORD *)(*(_QWORD *)(a1 + 176) + 8) + 16);
  }
  else
  {
    v13 = v6;
    v14 = v5;
  }
  return v13 / sqrtf((float)(v14 * v14) + (float)(v13 * v13));
}

unsigned __int16 *sub_18F491F28(unsigned __int16 *result, float a2, float a3, float a4, double a5)
{
  unsigned __int16 *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;

  v8 = result;
  v13 = a2;
  v11 = 0.0;
  v12 = 0.0;
  *((_BYTE *)result + 200) = 0;
  if (a5 - *(double *)result >= 0.5)
  {
    v9 = (float)(a3 - *((float *)result + 48))
       + floor(((float)(a3 - *((float *)result + 48)) + 3.14159265) / 6.28318531) * -6.28318531;
    v10 = (float)(a4 - *((float *)result + 49))
        + floor(((float)(a4 - *((float *)result + 49)) + 3.14159265) / 6.28318531) * -6.28318531;
    v11 = v10;
    v12 = v9;
    *((_BYTE *)result + 200) = 1;
    sub_18F33D300((uint64_t)(result + 36), &v11);
    sub_18F33D300((uint64_t)(v8 + 6), &v12);
    result = sub_18F33D300((uint64_t)(v8 + 66), &v13);
    *((float *)v8 + 48) = a3;
    *((float *)v8 + 49) = a4;
    *(double *)v8 = a5;
  }
  return result;
}

BOOL sub_18F49201C(uint64_t a1)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  NSObject *v10;
  float v11;
  _BOOL8 v12;
  int v13;
  NSObject *v14;
  int v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  BOOL v20;
  int v21;
  NSObject *v22;
  float v24;
  char *v25;
  char *v26;
  char *v27;
  uint8_t buf[4];
  double v29;
  __int16 v30;
  double v31;
  __int16 v32;
  double v33;
  __int16 v34;
  double v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 200)
    || *(_DWORD *)(a1 + 44) != *(unsigned __int16 *)(a1 + 42)
    || sub_18F3412D8((unsigned __int16 *)(a1 + 160), (unsigned int (*)(float, float))sub_18F3414E0, 0) <= 0.0)
  {
    v17 = *(unsigned __int16 *)(a1 + 160) + (unint64_t)*(unsigned __int16 *)(a1 + 162) - 1;
    v18 = *(unsigned int *)(a1 + 164);
    if (v17 < v18)
      v18 = 0;
    if (*(float *)(a1 + 160 + 4 * (v17 - v18) + 8) == 0.0)
    {
      v19 = *(_DWORD *)(a1 + 204);
      v20 = __OFSUB__(v19, 1);
      v21 = v19 - 1;
      if (v21 < 0 == v20)
      {
        v12 = 0;
        *(_DWORD *)(a1 + 204) = v21;
        return v12;
      }
    }
    return 0;
  }
  if (*(_BYTE *)(a1 + 12))
    sub_18F33FB38(a1 + 12);
  v2 = *(float *)(a1 + 20);
  if (v2 < 0.0)
    v2 = 0.0;
  v3 = sqrtf(v2);
  v4 = *(float *)(a1 + 24) + floor((*(float *)(a1 + 24) + 3.14159265) / 6.28318531) * -6.28318531;
  if (v4 <= 0.0)
    v5 = -v4;
  else
    v5 = v4;
  if (v3 <= v5)
    v6 = v5;
  else
    v6 = v3;
  if (v6 >= 0.2618)
    return 0;
  if (*(_BYTE *)(a1 + 72))
    sub_18F33FB38(a1 + 72);
  v7 = *(float *)(a1 + 80);
  if (v7 < 0.0)
    v7 = 0.0;
  v8 = *(float *)(a1 + 84) + floor((*(float *)(a1 + 84) + 3.14159265) / 6.28318531) * -6.28318531;
  if (v8 <= 0.0)
    v9 = -v8;
  else
    v9 = v8;
  if (qword_1EE16D8D8 != -1)
  {
    v24 = v7;
    dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
    v7 = v24;
  }
  v10 = qword_1EE16D8E0;
  v11 = sqrtf(v7);
  if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218240;
    v29 = (float)(v11 * 57.296);
    v30 = 2048;
    v31 = (float)(v9 * 57.296);
    _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEFAULT, "[CMTNBDoTEstimatorBase::AnomalySteppingDetect] dotStd, %.2f, dotDeltaSum, %.2f", buf, 0x16u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
    v25 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL AnomalySteppingDetect::checkForAnomaly()", "CoreLocation: %s\n", v25);
    if (v25 != (char *)buf)
      free(v25);
  }
  v12 = v9 > 1.1345 || v11 > 0.87266;
  v13 = *(_DWORD *)(a1 + 204);
  if (v12)
  {
    *(_DWORD *)(a1 + 204) = v13 + 1;
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
    v14 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
    {
      v15 = *(_DWORD *)(a1 + 204);
      *(_DWORD *)buf = 134219008;
      v29 = (float)(v3 * 57.296);
      v30 = 2048;
      v31 = (float)(v5 * 57.296);
      v32 = 2048;
      v33 = (float)(v11 * 57.296);
      v34 = 2048;
      v35 = (float)(v9 * 57.296);
      v36 = 1024;
      v37 = v15;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_DEBUG, "[CMTNBDoTEstimatorBase::AnomalySteppingDetect] headingStd, %.2f, headingDelta, %.2f, dotStd, %.2f, dotDelta, %.2f, count, %d", buf, 0x30u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
      v26 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL AnomalySteppingDetect::checkForAnomaly()", "CoreLocation: %s\n", v26);
      if (v26 != (char *)buf)
        free(v26);
    }
    v16 = *(_DWORD *)(a1 + 204);
    goto LABEL_44;
  }
  v20 = __OFSUB__(v13, 1);
  v16 = v13 - 1;
  if (v16 < 0 != v20)
    return 0;
  *(_DWORD *)(a1 + 204) = v16;
LABEL_44:
  if (v16 >= 4)
  {
    if (qword_1EE16D8D8 != -1)
      dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
    v22 = qword_1EE16D8E0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_DEFAULT, "[CMTNBDoTEstimatorBase::AnomalySteppingDetect] TNB degenerate scenario detected! Switch to heading.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2953FE8);
      v27 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL AnomalySteppingDetect::checkForAnomaly()", "CoreLocation: %s\n", v27);
      if (v27 != (char *)buf)
        free(v27);
    }
    *(_BYTE *)(a1 + 8) = 1;
  }
  return v12;
}

os_log_t sub_18F4926E8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1EE16D8E0 = (uint64_t)result;
  return result;
}

uint64_t sub_18F493240(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  objc_msgSend_pauseDeviceMotionStreamingPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
  return objc_msgSend_pauseStatusStreamingPrivate(*(void **)(a1 + 32), v6, v7, v8, v9);
}

uint64_t sub_18F4932B4()
{
  const char *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  if ((sub_18F20C9AC() & 1) != 0 || (sub_18F1E1B00() & 1) != 0 || (sub_18F1F7758() & 1) != 0)
    result = 1;
  else
    result = objc_msgSend_isMotionActivityEntitled(CMMotionUtils, v0, v1, v2, v3);
  byte_1ECEDFC10 = result;
  return result;
}

void sub_18F493374(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(v1 + 8) + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_18F4933D0;
  block[3] = &unk_1E2955938;
  block[4] = v1;
  dispatch_async(v2, block);
}

uint64_t sub_18F4933D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_startDeviceMotionUpdatesPrivateToQueue_withHandler_, 0, 0, a5);
}

__n128 sub_18F493440(uint64_t a1)
{
  __int128 v1;
  NSObject *v2;
  __n128 result;
  _QWORD block[4];
  __int128 v5;
  uint64_t v6;

  block[0] = MEMORY[0x1E0C809B0];
  v1 = *(_OWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 8);
  block[1] = 3221225472;
  block[2] = sub_18F4934AC;
  block[3] = &unk_1E2955BD8;
  v5 = v1;
  v6 = *(_QWORD *)(a1 + 48);
  dispatch_async(v2, block);
  return result;
}

uint64_t sub_18F4934AC(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a1[4], sel_startDeviceMotionUpdatesPrivateToQueue_withHandler_, a1[5], a1[6], a5);
}

void sub_18F493518(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(v1 + 8) + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_18F493574;
  block[3] = &unk_1E2955938;
  block[4] = v1;
  dispatch_sync(v2, block);
}

uint64_t sub_18F493574(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_stopDeviceMotionUpdatesPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_18F4935D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_startStatusUpdatesPrivate, a3, a4, a5);
}

uint64_t sub_18F49363C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_stopStatusUpdatesPrivate, a3, a4, a5);
}

void sub_18F4938C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4938E0(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  id Weak;
  id v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (a2)
  {
    v3 = result;
    v4 = (void *)MEMORY[0x1E0CB3710];
    v5 = (void *)MEMORY[0x1E0C99E60];
    v6 = objc_opt_class();
    v7 = objc_opt_class();
    v8 = objc_opt_class();
    v12 = objc_msgSend_setWithObjects_(v5, v9, v6, v10, v11, v7, v8, 0);
    v14 = objc_msgSend_unarchivedObjectOfClasses_fromData_error_(v4, v13, v12, a2, 0);
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      Weak = objc_loadWeak((id *)(v3 + 32));
      return MEMORY[0x1E0DE7D20](Weak, sel_onDeviceMotionPrivate_, v14, v17, v18);
    }
    else
    {
      objc_opt_class();
      result = objc_opt_isKindOfClass();
      if ((result & 1) != 0)
      {
        v16 = objc_loadWeak((id *)(v3 + 32));
        return MEMORY[0x1E0DE7D20](v16, sel_onStatusEventPrivate_, v14, v19, v20);
      }
    }
  }
  return result;
}

uint64_t sub_18F493AE4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  NSObject *v13;
  char *v15;
  uint8_t buf[4];
  uint64_t v17;
  _QWORD v18[2];
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  v18[0] = CFSTR("logTimestamp");
  v6 = objc_msgSend_numberWithUnsignedLongLong_(MEMORY[0x1E0CB37E8], a2, *(_QWORD *)(a1 + 32), a4, a5);
  v18[1] = CFSTR("timeBetweenDeviceConnectAndFirstValidDeviceMotion");
  v19[0] = v6;
  v19[1] = objc_msgSend_numberWithDouble_(MEMORY[0x1E0CB37E8], v7, v8, v9, v10, *(double *)(a1 + 40));
  v12 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v11, (uint64_t)v19, (uint64_t)v18, 2);
  if (qword_1ECEDEE78 != -1)
    dispatch_once(&qword_1ECEDEE78, &unk_1E2945148);
  v13 = off_1ECEDEE70;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138477827;
    v17 = v12;
    _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEBUG, "[CMHeadphoneMotionManager] Sending analytics: \n%{private}@", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2945148);
    v15 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneMotionManager pauseDeviceMotionStreamingPrivate]_block_invoke", "CoreLocation: %s\n", v15);
    if (v15 != (char *)buf)
      free(v15);
  }
  return v12;
}

uint64_t sub_18F493D7C(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  char *v5;
  uint8_t buf[4];
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE78 != -1)
    dispatch_once(&qword_1ECEDEE78, &unk_1E2945148);
  v2 = off_1ECEDEE70;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEBUG))
  {
    v3 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 138477827;
    v7 = v3;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "[CMHeadphoneMotionManager] deviceMotion: %{private}@", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2945148);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneMotionManager onDeviceMotionPrivate:]_block_invoke", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void sub_18F494378(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_18F494394(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  id Weak;
  uint64_t v15;
  uint64_t v16;

  if (a2)
  {
    v3 = result;
    v4 = (void *)MEMORY[0x1E0CB3710];
    v5 = (void *)MEMORY[0x1E0C99E60];
    v6 = objc_opt_class();
    v7 = objc_opt_class();
    v11 = objc_msgSend_setWithObjects_(v5, v8, v6, v9, v10, v7, 0);
    v13 = objc_msgSend_unarchivedObjectOfClasses_fromData_error_(v4, v12, v11, a2, 0);
    objc_opt_class();
    result = objc_opt_isKindOfClass();
    if ((result & 1) != 0)
    {
      Weak = objc_loadWeak((id *)(v3 + 32));
      return MEMORY[0x1E0DE7D20](Weak, sel_onStatusEventPrivate_, v13, v15, v16);
    }
  }
  return result;
}

uint64_t sub_18F4947A4(uint64_t result)
{
  uint64_t v1;
  NSObject *v2;
  id Weak;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint8_t buf[1640];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 42))
  {
    v1 = result;
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2945148);
    v2 = off_1ECEDEE70;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "[CMHeadphoneMotionManager] Device connected", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE78 != -1)
        dispatch_once(&qword_1ECEDEE78, &unk_1E2945148);
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneMotionManager notifyDeviceConnectedEventToClientPrivate]_block_invoke", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 42) = 1;
    objc_loadWeak((id *)(*(_QWORD *)(v1 + 32) + 16));
    result = objc_opt_respondsToSelector();
    if ((result & 1) != 0)
    {
      Weak = objc_loadWeak((id *)(*(_QWORD *)(v1 + 32) + 16));
      return objc_msgSend_headphoneMotionManagerDidConnect_(Weak, v4, *(_QWORD *)(v1 + 32), v5, v6);
    }
  }
  return result;
}

uint64_t sub_18F4949E4(uint64_t result)
{
  uint64_t v1;
  NSObject *v2;
  id Weak;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint8_t buf[1640];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 42))
  {
    v1 = result;
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2945148);
    v2 = off_1ECEDEE70;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "[CMHeadphoneMotionManager] Device disconnected", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE78 != -1)
        dispatch_once(&qword_1ECEDEE78, &unk_1E2945148);
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMHeadphoneMotionManager notifyDeviceDisconnectedEventToClientPrivate]_block_invoke", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 42) = 0;
    objc_loadWeak((id *)(*(_QWORD *)(v1 + 32) + 16));
    result = objc_opt_respondsToSelector();
    if ((result & 1) != 0)
    {
      Weak = objc_loadWeak((id *)(*(_QWORD *)(v1 + 32) + 16));
      return objc_msgSend_headphoneMotionManagerDidDisconnect_(Weak, v4, *(_QWORD *)(v1 + 32), v5, v6);
    }
  }
  return result;
}

uint64_t sub_18F494BDC()
{
  return sub_18F1F77DC();
}

uint64_t sub_18F494C9C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
}

_QWORD *sub_18F494CAC(_QWORD *a1)
{
  __CFNotificationCenter *LocalCenter;

  *a1 = off_1E294BB98;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveEveryObserver(LocalCenter, a1);
  if (*((char *)a1 + 151) < 0)
    operator delete((void *)a1[16]);
  if (*((char *)a1 + 127) < 0)
    operator delete((void *)a1[13]);
  if (*((char *)a1 + 103) < 0)
    operator delete((void *)a1[10]);
  if (*((char *)a1 + 79) < 0)
    operator delete((void *)a1[7]);
  sub_18F37143C((uint64_t)(a1 + 5));
  sub_18F2A8438((uint64_t)(a1 + 3));
  return a1;
}

uint64_t sub_18F494D40()
{
  uint64_t v0;
  uint64_t v1;

  qword_1ECEDFC20 = objc_opt_new();
  return MEMORY[0x1E0DE7D20](qword_1ECEDFC20, sel_setDateFormat_, CFSTR("yyyy-MM-dd_HH-mm-ss"), v0, v1);
}

void sub_18F494D6C(uint64_t a1@<X8>)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)&qword_1ECEDFC30);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1ECEDFC30))
  {
    unk_1ECEDFC70 = 0;
    xmmword_1ECEDFC60 = 0uLL;
    __cxa_atexit(MEMORY[0x1E0DE44D0], &xmmword_1ECEDFC60, &dword_18F1DC000);
    __cxa_guard_release(&qword_1ECEDFC30);
  }
  if (qword_1ECEDFC38 != -1)
    dispatch_once(&qword_1ECEDFC38, &unk_1E2958D18);
  if (byte_1ECEDFC77 < 0)
  {
    sub_18F26F9A4((_BYTE *)a1, (void *)xmmword_1ECEDFC60, *((unint64_t *)&xmmword_1ECEDFC60 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1ECEDFC60;
    *(_QWORD *)(a1 + 16) = unk_1ECEDFC70;
  }
}

void sub_18F494E40()
{
  JUMPOUT(0x1940012ACLL);
}

void sub_18F494E54(uint64_t a1@<X8>)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)&qword_1ECEDFC40);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1ECEDFC40))
  {
    unk_1ECEDFC88 = 0;
    xmmword_1ECEDFC78 = 0uLL;
    __cxa_atexit(MEMORY[0x1E0DE44D0], &xmmword_1ECEDFC78, &dword_18F1DC000);
    __cxa_guard_release(&qword_1ECEDFC40);
  }
  if (qword_1ECEDFC48 != -1)
    dispatch_once(&qword_1ECEDFC48, &unk_1E2945060);
  if (byte_1ECEDFC8F < 0)
  {
    sub_18F26F9A4((_BYTE *)a1, (void *)xmmword_1ECEDFC78, *((unint64_t *)&xmmword_1ECEDFC78 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1ECEDFC78;
    *(_QWORD *)(a1 + 16) = unk_1ECEDFC88;
  }
}

void sub_18F494F28()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19[2];
  char v20;
  void *__p[2];
  char v22;

  v0 = (void *)MEMORY[0x1E0CB3940];
  sub_18F270374(v19, "mobile");
  sub_18F1E9118((uint64_t)v19, __p);
  if (v22 >= 0)
    v4 = objc_msgSend_stringWithUTF8String_(v0, v1, (uint64_t)__p, v2, v3);
  else
    v4 = objc_msgSend_stringWithUTF8String_(v0, v1, (uint64_t)__p[0], v2, v3);
  v8 = (void *)v4;
  v9 = objc_msgSend_componentsJoinedByString_(&unk_1E298C020, v5, (uint64_t)CFSTR("/"), v6, v7);
  v13 = (void *)objc_msgSend_stringByAppendingPathComponent_(v8, v10, v9, v11, v12);
  v18 = objc_msgSend_UTF8String(v13, v14, v15, v16, v17);
  MEMORY[0x1940012AC](&xmmword_1ECEDFC78, v18);
  if (v22 < 0)
    operator delete(__p[0]);
  if (v20 < 0)
    operator delete(v19[0]);
}

void sub_18F494FE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F495014(uint64_t a1@<X8>)
{
  unsigned __int8 v2;

  v2 = atomic_load((unsigned __int8 *)&qword_1ECEDFC50);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1ECEDFC50))
  {
    unk_1ECEDFCA0 = 0;
    xmmword_1ECEDFC90 = 0uLL;
    __cxa_atexit(MEMORY[0x1E0DE44D0], &xmmword_1ECEDFC90, &dword_18F1DC000);
    __cxa_guard_release(&qword_1ECEDFC50);
  }
  if (qword_1ECEDFC58 != -1)
    dispatch_once(&qword_1ECEDFC58, &unk_1E2954A08);
  if (byte_1ECEDFCA7 < 0)
  {
    sub_18F26F9A4((_BYTE *)a1, (void *)xmmword_1ECEDFC90, *((unint64_t *)&xmmword_1ECEDFC90 + 1));
  }
  else
  {
    *(_OWORD *)a1 = xmmword_1ECEDFC90;
    *(_QWORD *)(a1 + 16) = unk_1ECEDFCA0;
  }
}

void sub_18F4950E8()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19[2];
  char v20;
  void *__p[2];
  char v22;

  v0 = (void *)MEMORY[0x1E0CB3940];
  sub_18F270374(v19, "mobile");
  sub_18F1E9118((uint64_t)v19, __p);
  if (v22 >= 0)
    v4 = objc_msgSend_stringWithUTF8String_(v0, v1, (uint64_t)__p, v2, v3);
  else
    v4 = objc_msgSend_stringWithUTF8String_(v0, v1, (uint64_t)__p[0], v2, v3);
  v8 = (void *)v4;
  v9 = objc_msgSend_componentsJoinedByString_(&unk_1E298C038, v5, (uint64_t)CFSTR("/"), v6, v7);
  v13 = (void *)objc_msgSend_stringByAppendingPathComponent_(v8, v10, v9, v11, v12);
  v18 = objc_msgSend_UTF8String(v13, v14, v15, v16, v17);
  MEMORY[0x1940012AC](&xmmword_1ECEDFC90, v18);
  if (v22 < 0)
    operator delete(__p[0]);
  if (v20 < 0)
    operator delete(v19[0]);
}

void sub_18F4951A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F4951D4(const void **a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, std::string *a5@<X8>)
{
  size_t v10;
  std::string *v11;
  const void *v12;
  int v13;
  const std::string::value_type *v14;
  std::string::size_type v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  void **v29;
  std::string::size_type v30;
  std::string *v31;
  __int128 v32;
  int v33;
  const std::string::value_type *v34;
  std::string::size_type v35;
  std::string *v36;
  void *__p[2];
  unsigned __int8 v38;
  std::string v39;
  std::string v40;
  std::string v41;
  std::string v42;

  if (*((char *)a1 + 23) >= 0)
    v10 = *((unsigned __int8 *)a1 + 23);
  else
    v10 = (size_t)a1[1];
  v11 = &v39;
  sub_18F2B6B4C((uint64_t)&v39, v10 + 1);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v11 = (std::string *)v39.__r_.__value_.__r.__words[0];
  if (v10)
  {
    if (*((char *)a1 + 23) >= 0)
      v12 = a1;
    else
      v12 = *a1;
    memmove(v11, v12, v10);
  }
  *(_WORD *)((char *)&v11->__r_.__value_.__l.__data_ + v10) = 47;
  v13 = *(char *)(a2 + 23);
  if (v13 >= 0)
    v14 = (const std::string::value_type *)a2;
  else
    v14 = *(const std::string::value_type **)a2;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = std::string::append(&v39, v14, v15);
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v40.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  v18 = std::string::append(&v40, "_");
  v22 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v22;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (qword_1ECEDFC28 != -1)
    dispatch_once(&qword_1ECEDFC28, &unk_1E2954028);
  v23 = (void *)objc_msgSend_stringFromDate_((void *)qword_1ECEDFC20, v19, a4, v20, v21);
  v28 = (char *)objc_msgSend_UTF8String(v23, v24, v25, v26, v27);
  sub_18F270374(__p, v28);
  if ((v38 & 0x80u) == 0)
    v29 = __p;
  else
    v29 = (void **)__p[0];
  if ((v38 & 0x80u) == 0)
    v30 = v38;
  else
    v30 = (std::string::size_type)__p[1];
  v31 = std::string::append(&v41, (const std::string::value_type *)v29, v30);
  v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  v33 = *(char *)(a3 + 23);
  if (v33 >= 0)
    v34 = (const std::string::value_type *)a3;
  else
    v34 = *(const std::string::value_type **)a3;
  if (v33 >= 0)
    v35 = *(unsigned __int8 *)(a3 + 23);
  else
    v35 = *(_QWORD *)(a3 + 8);
  v36 = std::string::append(&v42, v34, v35);
  *a5 = *v36;
  v36->__r_.__value_.__l.__size_ = 0;
  v36->__r_.__value_.__r.__words[2] = 0;
  v36->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v42.__r_.__value_.__l.__data_);
  if ((char)v38 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v40.__r_.__value_.__l.__data_);
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v39.__r_.__value_.__l.__data_);
}

void sub_18F4953EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (*(char *)(v33 - 73) < 0)
    operator delete(*(void **)(v33 - 96));
  if (a14 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void sub_18F495468(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  char *v8;
  void *v9[2];
  char v10;
  void *__p[2];
  char v12;

  sub_18F494D6C((uint64_t)v9);
  if (v10 >= 0)
    v8 = (char *)v9;
  else
    v8 = (char *)v9[0];
  sub_18F270374(__p, v8);
  sub_18F4951D4((const void **)__p, a2, a1 + 104, a3, a4);
  if (v12 < 0)
    operator delete(__p[0]);
  if (v10 < 0)
    operator delete(v9[0]);
}

void sub_18F495504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  _Unwind_Resume(exception_object);
}

void sub_18F495538(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  char *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10[2];
  char v11;
  void *__p[2];
  char v13;

  sub_18F495014((uint64_t)v10);
  if (v11 >= 0)
    v4 = (char *)v10;
  else
    v4 = (char *)v10[0];
  sub_18F270374(__p, v4);
  v9 = objc_msgSend_date(MEMORY[0x1E0C99D68], v5, v6, v7, v8);
  sub_18F4951D4((const void **)__p, a1 + 80, a1 + 104, v9, a2);
  if (v13 < 0)
    operator delete(__p[0]);
  if (v11 < 0)
    operator delete(v10[0]);
}

void sub_18F4955D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_18F495604(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_date(MEMORY[0x1E0C99D68], a2, a3, a4, a5);
}

uint64_t sub_18F495610(uint64_t a1, char **a2, char *a3)
{
  char *v3;
  char *v4;
  int v5;
  char *v6;
  int64_t v7;
  char *v8;
  char *v9;
  int v12;
  void *v13;
  char *v14;
  char *v15;

  v3 = (char *)*((unsigned __int8 *)a2 + 23);
  if ((char)v3 >= 0)
    v4 = (char *)a2;
  else
    v4 = *a2;
  v5 = a3[23];
  if (v5 >= 0)
    v6 = a3;
  else
    v6 = *(char **)a3;
  if (v5 >= 0)
    v7 = a3[23];
  else
    v7 = *((_QWORD *)a3 + 1);
  if (!v7)
    return 1;
  if ((char)v3 < 0)
    v3 = a2[1];
  v8 = &v3[(_QWORD)v4];
  if ((uint64_t)v3 >= v7)
  {
    v12 = *v6;
    v13 = v4;
    do
    {
      v14 = &v3[-v7];
      if (v14 == (char *)-1)
        break;
      v15 = (char *)memchr(v13, v12, (size_t)(v14 + 1));
      if (!v15)
        break;
      v9 = v15;
      if (!memcmp(v15, v6, v7))
        return v9 != v8 && v9 == v4;
      v13 = v9 + 1;
      v3 = (char *)(v8 - (v9 + 1));
    }
    while ((uint64_t)v3 >= v7);
  }
  v9 = v8;
  return v9 != v8 && v9 == v4;
}

unint64_t sub_18F4956E4(uint64_t a1, void **a2, char *a3)
{
  unint64_t v3;
  char v4;
  int64_t v5;
  char *v6;
  char *v7;
  unint64_t result;
  char *v9;
  char *v10;
  int64_t v11;
  char *v12;
  int v14;
  int64_t v15;
  char *v16;

  v3 = *((unsigned __int8 *)a2 + 23);
  v4 = a3[23];
  if (v4 >= 0)
    v5 = a3[23];
  else
    v5 = *((_QWORD *)a3 + 1);
  if (v4 >= 0)
    v6 = a3;
  else
    v6 = *(char **)a3;
  if ((v3 & 0x80u) == 0)
  {
    v7 = (char *)a2;
  }
  else
  {
    v3 = (unint64_t)a2[1];
    v7 = (char *)*a2;
  }
  result = v3 == v5;
  if (v3 < result)
    return 1;
  if (v5)
  {
    v9 = &v7[result];
    v10 = &v7[v3];
    v11 = &v7[v3] - v9;
    if (v11 >= v5)
    {
      v14 = *v6;
      do
      {
        v15 = v11 - v5;
        if (v15 == -1)
          break;
        v16 = (char *)memchr(v9, v14, v15 + 1);
        if (!v16)
          break;
        v12 = v16;
        if (!memcmp(v16, v6, v5))
          return v12 != v7 || v12 == v10;
        v9 = v12 + 1;
        v11 = v10 - (v12 + 1);
      }
      while (v11 >= v5);
    }
    v12 = v10;
    return v12 != v7 || v12 == v10;
  }
  return result;
}

void sub_18F4957C0(uint64_t a1, uint64_t a2, char a3, unint64_t a4, float a5, float a6)
{
  unint64_t v7;
  double v8;
  double v9;
  NSObject *v10;
  BOOL v11;
  NSObject *v13;
  char *v14;
  float v15;
  double v16;
  NSObject *v20;
  double v21;
  double v22;
  double v23;
  BOOL v24;
  NSObject *v25;
  char *v26;
  uint8_t buf[4];
  _BOOL4 v28;
  __int16 v29;
  double v30;
  __int16 v31;
  _BOOL4 v32;
  __int16 v33;
  double v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  *(_WORD *)(a1 + 12) = 0;
  v7 = *(_QWORD *)(a1 + 24);
  if (a4 >= v7)
    v8 = (double)(a4 - v7) * 0.000001;
  else
    v8 = 0.0;
  if (*(_BYTE *)a1)
  {
    if (*(_BYTE *)(a1 + 1))
      v9 = *(float *)(a1 + 4);
    else
      v9 = 1.5;
    v11 = v9 >= v8 || *(_DWORD *)(a1 + 16) != 1;
LABEL_24:
    *(_BYTE *)a1 = v11;
    return;
  }
  if (*(_DWORD *)(a1 + 16) == 1)
    return;
  if ((a3 & 1) != 0)
  {
    if (*(_BYTE *)(a1 + 1))
    {
      if (v8 <= *(float *)(a1 + 8))
        return;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2954048);
      v10 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEBUG, "[CMRelDMCameraController] Requesting anchor periodically.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E2954048);
        v26 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CMRelDMCameraController::updateCameraRequest(const CMBleedToZero &, BOOL, float, float, uint64_t)", "CoreLocation: %s\n", v26);
        if (v26 != (char *)buf)
          free(v26);
      }
      v11 = 1;
      goto LABEL_24;
    }
    v15 = *(double *)(a2 + 80);
    v16 = a5;
    if (v8 <= v16)
      v16 = v8;
    if (v16 > 12.0 && v15 < 12.0)
    {
      *(_BYTE *)a1 = 1;
      *(_BYTE *)(a1 + 12) = 1;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2954048);
      v20 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_DEBUG, "[CMRelDMCameraController] Request anchor after long moving duration.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 == -1)
          goto LABEL_32;
        goto LABEL_72;
      }
    }
    else
    {
      if (v8 <= 5.0 || *(_BYTE *)(a2 + 41) == 0 || v15 <= 1.0)
      {
        *(_BYTE *)a1 = 0;
        return;
      }
      v21 = v15;
      v22 = a6;
      if (v8 <= a6)
        v23 = v8;
      else
        v23 = a6;
      v24 = v8 > 17.5;
      *(_BYTE *)(a1 + 13) = v8 > 17.5;
      if (v23 > v21)
        v24 = 1;
      *(_BYTE *)a1 = v24;
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2954048);
      v25 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109888;
        v28 = v23 > v21;
        v29 = 2048;
        v30 = v22;
        v31 = 1024;
        v32 = v8 > 17.5;
        v33 = 2048;
        v34 = v21;
        _os_log_impl(&dword_18F1DC000, v25, OS_LOG_TYPE_DEBUG, "[CMRelDMCameraController] hasMovementSinceLastAnchorOrRequest, %d, timeSinceLastConsumedCamAnchor, %.3f, reachedExtendedDutyCycleStatic, %d, staticPoseDurationAfterDisturbance, %.3f", buf, 0x22u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 == -1)
        {
LABEL_32:
          v14 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CMRelDMCameraController::updateCameraRequest(const CMBleedToZero &, BOOL, float, float, uint64_t)", "CoreLocation: %s\n", v14);
          if (v14 != (char *)buf)
            free(v14);
          return;
        }
LABEL_72:
        dispatch_once(&qword_1EE16D818, &unk_1E2954048);
        goto LABEL_32;
      }
    }
  }
  else
  {
    *(_BYTE *)a1 = 1;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2954048);
    v13 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEBUG, "[CMRelDMCameraController] Requesting anchor on initialization.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 == -1)
        goto LABEL_32;
      goto LABEL_72;
    }
  }
}

void sub_18F495DC8(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  unint64_t v5;
  double v6;
  double v7;
  NSObject *v8;
  BOOL v9;
  NSObject *v11;
  char *v12;
  BOOL v13;
  float v14;
  char *v15;
  uint8_t buf[1640];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 24);
  v6 = (double)(a3 - v5) * 0.000001;
  if (a3 < v5)
    v6 = 0.0;
  if (*(_BYTE *)a1)
  {
    if (*(_BYTE *)(a1 + 1))
      v7 = *(float *)(a1 + 4);
    else
      v7 = 1.5;
    v9 = v7 >= v6 || *(_DWORD *)(a1 + 16) != 1;
LABEL_22:
    *(_BYTE *)a1 = v9;
    return;
  }
  if (*(_DWORD *)(a1 + 16) == 1)
    return;
  if (*(_BYTE *)(a1 + 1))
  {
    if (v6 <= *(float *)(a1 + 8))
      return;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2954048);
    v8 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEBUG, "[CMRelDMCameraController] Requesting anchor periodically during DV.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E2954048);
      v15 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMRelDMCameraController::updateCameraRequestDV(uint64_t, uint64_t, BOOL)", "CoreLocation: %s\n", v15);
      if (v15 != (char *)buf)
        free(v15);
    }
    v9 = 1;
    goto LABEL_22;
  }
  if (!a4)
  {
    v13 = a3 <= a2 || a2 == 0;
    v14 = (float)(a3 - a2) * 0.000001;
    if (v13)
      v14 = 0.0;
    v9 = v14 > 1.0;
    if (v6 <= v14)
      v9 = 0;
    goto LABEL_22;
  }
  *(_BYTE *)a1 = 0;
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E2954048);
  v11 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_DEBUG, "[CMRelDMCameraController] Not requesting anchor during DV because of walking detection.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E2954048);
    v12 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMRelDMCameraController::updateCameraRequestDV(uint64_t, uint64_t, BOOL)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf)
      free(v12);
  }
}

os_log_t sub_18F49614C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1EE16D820 = (uint64_t)result;
  return result;
}

double sub_18F496178()
{
  uint64_t v0;
  double *v1;
  double *v2;
  float32x2_t *v3;
  float32x2_t *v4;
  uint64_t v5;
  __int32 v6;
  float32x4_t v7;
  float v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  float *v16;
  float v17;
  float v18;
  float v19;
  _WORD *v20;
  float v21;
  float v22;
  float v23;
  unint64_t v24;
  unint64_t v25;
  float32x2_t *v26;
  unsigned int v27;
  unint64_t v28;
  double v29;
  double v30;
  unint64_t v31;
  float32x2_t v32;
  float v33;
  double v34;
  double v35;
  uint64_t v37;
  float32x2_t *v38;
  unsigned int v39;
  int32x2_t v40;
  unint64_t v41;
  float32x2_t v42;
  float v43;
  float32x2_t *v44;
  float v45;
  unint64_t i;
  int v47;
  int v48;
  int v49;
  double v50;
  float v51;
  NSObject *v52;
  float32x2_t v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  float v57;
  float v58;
  double v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  double v64;
  int8x16_t v65;
  int8x16_t v66;
  unint64_t v67;
  double v68;
  double v69;
  uint64_t v70;
  double v71;
  unint64_t v72;
  uint64_t v73;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  double v79;
  unint64_t v80;
  uint64_t v81;
  double v82;
  double v83;
  unint64_t v84;
  uint64_t v85;
  double v86;
  double v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  float64x2_t v92;
  double v93;
  double v94;
  __double2 v95;
  __double2 v96;
  double v97;
  double v98;
  double sinval;
  double cosval;
  __double2 v101;
  double v102;
  double v103;
  double v104;
  NSObject *v105;
  float32x2_t v106;
  float32x2_t v108;
  char *v109;
  float32x2_t v110;
  char *v111;
  uint64_t v112[2];
  _DWORD v113[3];
  _BYTE v114[12];
  __int16 v115;
  double v116;
  __int16 v117;
  double v118;
  _BYTE v119[10];
  __int16 v120;
  double v121;
  __int16 v122;
  uint64_t v123;
  _OWORD v124[2];
  _BYTE v125[10];
  __int16 v126;
  double v127;
  __int16 v128;
  double v129;
  __int16 v130;
  double v131;
  _BYTE buf[32];
  _BYTE v133[10];
  __int16 v134;
  double v135;
  __int16 v136;
  double v137;
  __int16 v138;
  double v139;
  float32x4_t v140[150];
  uint64_t v141;

  v0 = MEMORY[0x1E0C80A78]();
  v2 = v1;
  v4 = v3;
  v5 = v0;
  v141 = *MEMORY[0x1E0C80C00];
  v6 = v3[5].i32[1];
  v7.f32[0] = -v3[5].f32[0];
  *(float32x2_t *)v140[0].f32 = vneg_f32(v3[4]);
  v140[0].i64[1] = __PAIR64__(v6, v7.u32[0]);
  sub_18F1FFE94(v140, v7);
  v8 = sub_18F3D39F4(v140[0].f32, -v4[2].f32[1], -v4[3].f32[0], -v4[3].f32[1]);
  v11 = *(unsigned __int16 *)(v5 + 42);
  if (*(_WORD *)(v5 + 42))
  {
    v12 = *(unsigned __int16 *)(v5 + 40);
    v13 = v11 + v12 - 1;
    v14 = *(unsigned int *)(v5 + 44);
    if (v13 >= v14)
      v15 = *(unsigned int *)(v5 + 44);
    else
      v15 = 0;
    v16 = (float *)(v5 + 40 + 24 * (v13 - v15));
    v17 = v16[4];
    v18 = v16[5];
    v19 = v16[6];
  }
  else
  {
    v14 = *(unsigned int *)(v5 + 44);
    v12 = *(unsigned __int16 *)(v5 + 40);
    v17 = 0.0;
    v18 = 0.0;
    v19 = 0.0;
  }
  v20 = (_WORD *)(v5 + 40);
  v21 = v8 + v17;
  v22 = v9 + v18;
  v23 = v10 + v19;
  v24 = v12 + v11;
  if (v24 >= v14)
    v25 = v14;
  else
    v25 = 0;
  v26 = (float32x2_t *)(v5 + 24 * (v24 - v25));
  v26[6] = *v4;
  v26[7].f32[0] = v21;
  v26[7].f32[1] = v22;
  v26[8].f32[0] = v23;
  v27 = *(unsigned __int16 *)(v5 + 42);
  if (v14 <= v27)
  {
    v28 = (unsigned __int16)*v20 + 1;
    if (v28 < v14)
      LOWORD(v14) = 0;
    *v20 = v28 - v14;
  }
  else
  {
    LOWORD(v27) = v27 + 1;
    *(_WORD *)(v5 + 42) = v27;
  }
  v29 = v2[1];
  if (v29 > 0.0 && vabdd_f64(v29, *(double *)(v5 + 8)) > 0.0001)
  {
    v30 = *v2;
    if (*v2 < v29)
    {
      *(double *)(v5 + 8) = v29;
      v140[0].i64[0] = 0xC800000000;
      if ((_WORD)v27)
      {
        v31 = 0;
        v32 = 0;
        v33 = 0.0;
        do
        {
          v34 = *(double *)sub_18F496C30((unsigned __int16 *)(v5 + 40), v31);
          v35 = *(double *)sub_18F496C30((unsigned __int16 *)(v5 + 40), v31);
          if (v30 <= v34 && v35 <= v29)
          {
            v37 = sub_18F496C30((unsigned __int16 *)(v5 + 40), v31);
            sub_18F33FACC((unsigned __int16 *)v140, v37 + 8);
            v38 = (float32x2_t *)sub_18F496C30((unsigned __int16 *)(v5 + 40), v31);
            v32 = vadd_f32(v32, v38[1]);
            v33 = v33 + v38[2].f32[0];
          }
          ++v31;
        }
        while (v31 < *(unsigned __int16 *)(v5 + 42));
        v39 = v140[0].u16[1];
      }
      else
      {
        v39 = 0;
        v32 = 0;
        v33 = 0.0;
      }
      *(_DWORD *)v125 = 0;
      v40.i32[1] = 0;
      memset(v124, 0, sizeof(v124));
      if (v39)
      {
        v41 = 0;
        *(float *)v40.i32 = (float)v39;
        v42 = vdiv_f32(v32, (float32x2_t)vdup_lane_s32(v40, 0));
        v43 = v33 / (float)v39;
        do
        {
          v44 = (float32x2_t *)sub_18F33FF64((unsigned __int16 *)v140, v41);
          v45 = v44[1].f32[0] - v43;
          *(float32x2_t *)v114 = vsub_f32(*v44, v42);
          *(float *)&v114[8] = v45;
          sub_18F3598C4((uint64_t)v114, (uint64_t)buf);
          for (i = 0; i != 9; ++i)
            *((float *)v124 + i) = sub_18F359948((uint64_t)buf, i) + *((float *)v124 + i);
          ++v41;
        }
        while (v41 < v140[0].u16[1]);
      }
      *(_OWORD *)buf = v124[0];
      *(_OWORD *)&buf[16] = v124[1];
      *(_DWORD *)v133 = *(_DWORD *)v125;
      sub_18F359B20((uint64_t)buf, (uint64_t)v114);
      v113[0] = v47;
      v113[1] = v48;
      v113[2] = v49;
      v112[0] = (uint64_t)v113;
      v112[1] = (uint64_t)v114;
      sub_18F35A13C(v112, 0, 1uLL);
      sub_18F35A13C(v112, 0, 2uLL);
      sub_18F35A13C(v112, 1uLL, 2uLL);
      v50 = v118;
      v51 = *(float *)v119;
      if (qword_1EE16D8D8 != -1)
        dispatch_once(&qword_1EE16D8D8, &unk_1E2954068);
      v52 = qword_1EE16D8E0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
      {
        v53 = *v4;
        *(_DWORD *)buf = 134219520;
        *(float32x2_t *)&buf[4] = v53;
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = v30;
        *(_WORD *)&buf[22] = 2048;
        *(double *)&buf[24] = v29;
        *(_WORD *)v133 = 2048;
        *(_QWORD *)&v133[2] = v140[0].u16[1];
        v134 = 2048;
        v135 = *(float *)&v50;
        v136 = 2048;
        v137 = *((float *)&v50 + 1);
        v138 = 2048;
        v139 = v51;
        _os_log_impl(&dword_18F1DC000, v52, OS_LOG_TYPE_DEBUG, "[CMPdr] pdrdir,time,%f,startImpulse,%f,endImpulse,%f,velBufferSize,%zu,planeNormal,%f,%f,%f\n", buf, 0x48u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D8D8 != -1)
          dispatch_once(&qword_1EE16D8D8, &unk_1E2954068);
        v108 = *v4;
        LODWORD(v124[0]) = 134219520;
        *(float32x2_t *)((char *)v124 + 4) = v108;
        WORD6(v124[0]) = 2048;
        *(double *)((char *)v124 + 14) = v30;
        WORD3(v124[1]) = 2048;
        *((double *)&v124[1] + 1) = v29;
        *(_WORD *)v125 = 2048;
        *(_QWORD *)&v125[2] = v140[0].u16[1];
        v126 = 2048;
        v127 = *(float *)&v50;
        v128 = 2048;
        v129 = *((float *)&v50 + 1);
        v130 = 2048;
        v131 = v51;
        v109 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "Pdr::PdrOutput CMPdrDirectionality::feedImuData(const AccessoryActivity::ImuData *const, const CMAccessoryStepDetector::Impulse *const)", "CoreLocation: %s\n", v109);
        if (v109 != buf)
          free(v109);
      }
      *(_QWORD *)&v124[0] = 0x3200000000;
      if (v140[0].i16[1])
      {
        v54 = 0;
        v55 = 0;
        v56 = 0;
        do
        {
          v57 = *(float *)sub_18F33FF64((unsigned __int16 *)v140, v56);
          v58 = *(float *)(sub_18F33FF64((unsigned __int16 *)v140, v56) + 4);
          v59 = (float)((float)((float)(*(float *)&v50 * v58) + (float)(v57 * *((float *)&v50 + 1)))
                      + (float)(*(float *)(sub_18F33FF64((unsigned __int16 *)v140, v56) + 8) * 0.0));
          v60 = v55 + (unsigned __int16)v54;
          if (v60 >= 0x32)
            v61 = 0x7FFFFFFFFFFFFFE7;
          else
            v61 = 0;
          *((double *)&v124[v61] + v60 + 1) = v59;
          if (v55 > 0x31)
          {
            if ((unsigned __int16)v54 >= 0x31u)
              v62 = -50;
            else
              v62 = 0;
            v63 = v54 + v62;
            v54 = v63 + 1;
            LOWORD(v124[0]) = v63 + 1;
          }
          else
          {
            WORD1(v124[0]) = ++v55;
          }
          ++v56;
        }
        while (v56 < v140[0].u16[1]);
      }
      v64 = sub_18F496E2C((unsigned __int16 *)v124, (unsigned int (*)(double, double))sub_18F49702C);
      *(double *)v65.i64 = sub_18F496E2C((unsigned __int16 *)v124, (unsigned int (*)(double, double))sub_18F497038);
      if (WORD1(v124[0]))
      {
        v67 = 0;
        v68 = (v64 + *(double *)v65.i64) * 0.5;
        do
        {
          v69 = *(double *)sub_18F355C78((unsigned __int16 *)v124, v67);
          *(double *)sub_18F355C78((unsigned __int16 *)v124, v67++) = v69 - v68;
        }
        while (v67 < WORD1(v124[0]));
        v70 = WORD1(v124[0]) - 1;
      }
      else
      {
        v70 = -1;
      }
      v71 = *((double *)v124 + LOWORD(v124[0]) + 1);
      v72 = v70 + LOWORD(v124[0]);
      v73 = DWORD1(v124[0]);
      if (v72 < DWORD1(v124[0]))
        v73 = 0;
      if (((*((_QWORD *)v124 + v72 - v73 + 1) ^ *((_QWORD *)v124 + LOWORD(v124[0]) + 1)) & 0x8000000000000000) != 0)
      {
        v74 = sub_18F496E2C((unsigned __int16 *)v124, (unsigned int (*)(double, double))sub_18F49702C);
        v75 = *((double *)v124 + LOWORD(v124[0]) + 1);
        v76 = sub_18F496E2C((unsigned __int16 *)v124, (unsigned int (*)(double, double))sub_18F497038);
        v77 = vabdd_f64(v71, v74);
        v78 = vabdd_f64(v75, v76);
        if (v78 >= v77)
          v79 = v77;
        else
          v79 = v78;
        v80 = LOWORD(v124[0]) + (unint64_t)WORD1(v124[0]) - 1;
        v81 = DWORD1(v124[0]);
        if (v80 < DWORD1(v124[0]))
          v81 = 0;
        v82 = *((double *)v124 + v80 - v81 + 1);
        v83 = sub_18F496E2C((unsigned __int16 *)v124, (unsigned int (*)(double, double))sub_18F49702C);
        v84 = LOWORD(v124[0]) + (unint64_t)WORD1(v124[0]) - 1;
        v85 = DWORD1(v124[0]);
        if (v84 < DWORD1(v124[0]))
          v85 = 0;
        v86 = *((double *)v124 + v84 - v85 + 1);
        *(double *)v65.i64 = sub_18F496E2C((unsigned __int16 *)v124, (unsigned int (*)(double, double))sub_18F497038);
        v87 = vabdd_f64(v82, v83);
        *(double *)v65.i64 = vabdd_f64(v86, *(double *)v65.i64);
        if (*(double *)v65.i64 < v87)
          v87 = *(double *)v65.i64;
        if (v79 <= v87)
        {
          v90 = LOWORD(v124[0]) + (unint64_t)WORD1(v124[0]) - 1;
          v91 = DWORD1(v124[0]);
          if (v90 < DWORD1(v124[0]))
            v91 = 0;
          v65.i64[0] = *((_QWORD *)v124 + v90 - v91 + 1);
          if (v79 < v87)
            *(double *)v65.i64 = *(double *)v65.i64 - *((double *)v124 + LOWORD(v124[0]) + 1);
        }
        else
        {
          v88 = LOWORD(v124[0]) + (unint64_t)WORD1(v124[0]) - 1;
          v89 = DWORD1(v124[0]);
          if (v88 < DWORD1(v124[0]))
            v89 = 0;
          *(double *)v65.i64 = *((double *)v124 + LOWORD(v124[0]) + 1) - *((double *)v124 + v88 - v89 + 1);
        }
      }
      else
      {
        *(double *)v65.i64 = -v71;
      }
      v66.i64[0] = 1.0;
      v92.f64[0] = NAN;
      v92.f64[1] = NAN;
      v92.f64[0] = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v92), v66, v65).i64;
      v93 = atan2(v92.f64[0] * *(float *)&v50, v92.f64[0] * *((float *)&v50 + 1));
      v94 = *(double *)(v5 + 16);
      if (v30 - *(double *)v5 <= 1.0)
      {
        v95 = __sincos_stret(v93);
        v96 = __sincos_stret(v94);
        v97 = atan2((v95.__sinval + v96.__sinval) * 0.5, (v95.__cosval + v96.__cosval) * 0.5);
        v98 = *(double *)(v5 + 24);
        v101 = __sincos_stret(v97);
        cosval = v101.__cosval;
        sinval = v101.__sinval;
        v102 = *(double *)(v5 + 32);
        if (qword_1EE16D8D8 != -1)
        {
          dispatch_once(&qword_1EE16D8D8, &unk_1E2954068);
          cosval = v101.__cosval;
          sinval = v101.__sinval;
        }
        v103 = v98 + cosval * 0.73787;
        v104 = v102 + sinval * 0.73787;
        v105 = qword_1EE16D8E0;
        if (os_log_type_enabled((os_log_t)qword_1EE16D8E0, OS_LOG_TYPE_DEBUG))
        {
          v106 = *v4;
          *(_DWORD *)buf = 134219264;
          *(float32x2_t *)&buf[4] = v106;
          *(_WORD *)&buf[12] = 2048;
          *(double *)&buf[14] = v93;
          *(_WORD *)&buf[22] = 2048;
          *(double *)&buf[24] = v97;
          *(_WORD *)v133 = 2048;
          *(double *)&v133[2] = v103;
          v134 = 2048;
          v135 = v104;
          v136 = 2048;
          *(_QWORD *)&v137 = WORD1(v124[0]);
          _os_log_impl(&dword_18F1DC000, v105, OS_LOG_TYPE_DEBUG, "[CMPdr] directionResult,time,%f,directionRadians,%f,avgDirectionRadians,%f,x,%f,y,%f,scoreBufSize,%zu\n", buf, 0x3Eu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D8D8 != -1)
            dispatch_once(&qword_1EE16D8D8, &unk_1E2954068);
          v110 = *v4;
          *(_DWORD *)v114 = 134219264;
          *(float32x2_t *)&v114[4] = v110;
          v115 = 2048;
          v116 = v93;
          v117 = 2048;
          v118 = v97;
          *(_WORD *)v119 = 2048;
          *(double *)&v119[2] = v103;
          v120 = 2048;
          v121 = v104;
          v122 = 2048;
          v123 = WORD1(v124[0]);
          v111 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "Pdr::PdrOutput CMPdrDirectionality::feedImuData(const AccessoryActivity::ImuData *const, const CMAccessoryStepDetector::Impulse *const)", "CoreLocation: %s\n", v111);
          if (v111 != buf)
            free(v111);
        }
        *(double *)(v5 + 24) = v103;
        *(double *)(v5 + 32) = v104;
      }
      *(double *)(v5 + 16) = v93;
      *(double *)v5 = v30;
    }
  }
  return *(double *)(v5 + 16) * 57.2957802;
}

os_log_t sub_18F496C04()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "MotionContext");
  qword_1EE16D8E0 = (uint64_t)result;
  return result;
}

uint64_t sub_18F496C30(unsigned __int16 *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  NSObject *v7;
  int v8;
  char *v9;
  uint8_t buf[4];
  unint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954808);
    v7 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      v11 = a2;
      v12 = 1024;
      v13 = v8;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954808);
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "const T &CMQueue<CMPdrDirectionality::AggAccelSample>::operator[](const size_t) const [T = CMPdrDirectionality::AggAccelSample]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
  }
  v4 = *a1 + a2;
  v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5)
    v5 = 0;
  return (uint64_t)&a1[12 * (v4 - v5) + 4];
}

double sub_18F496E2C(unsigned __int16 *a1, unsigned int (*a2)(double, double))
{
  uint64_t v3;
  unint64_t v5;
  double v6;
  double *v7;
  double v8;
  NSObject *v10;
  char *v11;
  uint8_t buf[1640];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = a1[1];
  if (a1[1])
  {
    v5 = 0;
    v6 = *(double *)sub_18F355C78(a1, 0);
    do
    {
      v7 = (double *)sub_18F355C78(a1, v5);
      v8 = *v7;
      if (a2(*v7, v6))
        v6 = v8;
      ++v5;
    }
    while (v3 != v5);
  }
  else
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954808);
    v10 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_FAULT, "Assertion failed: n > 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 179,.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954808);
      v11 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "T CMQueue<double>::getComparison(int (*)(const T, const T), size_t) const [T = double]", "CoreLocation: %s\n", v11);
      if (v11 != (char *)buf)
        free(v11);
    }
    return *(double *)sub_18F355C78(a1, 0);
  }
  return v6;
}

BOOL sub_18F49702C(double a1, double a2)
{
  return a2 < a1;
}

BOOL sub_18F497038(double a1, double a2)
{
  return a1 < a2;
}

uint64_t sub_18F497108()
{
  id v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t result;

  v0 = objc_alloc(MEMORY[0x1E0D44528]);
  result = objc_msgSend_initWithIdentifier_(v0, v1, (uint64_t)CFSTR("CLGyroCalibrationDatabaseSilo"), v2, v3);
  qword_1ECEDFCB0 = result;
  return result;
}

uint64_t sub_18F497524()
{
  uint64_t result;

  result = sub_18F1EF73C();
  if (result)
    byte_1ECEDFCA8 = 1;
  return result;
}

uint64_t sub_18F497858(uint64_t a1, char *a2, void *a3)
{
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)a1 = off_1E2949068;
  sub_18F270374((_QWORD *)(a1 + 8), a2);
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = objc_msgSend_silo(a3, v5, v6, v7, v8);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 56) = a1 + 64;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_18F4978D4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_18F4978F0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_QWORD *)a1 = off_1E2949068;
  objc_msgSend_invalidate(*(void **)(a1 + 48), a2, a3, a4, a5);

  sub_18F449DA8(a1 + 80, *(_QWORD **)(a1 + 88));
  sub_18F449DF4(a1 + 56, *(_QWORD **)(a1 + 64));
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

_QWORD *sub_18F497960@<X0>(_DWORD *a1@<X1>, _QWORD *a2@<X8>)
{
  char __str[32];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x20uLL, "%d", *a1);
  return sub_18F270374(a2, __str);
}

uint64_t sub_18F4979D8(uint64_t result)
{
  *(_BYTE *)(result + 108) = 1;
  return result;
}

uint64_t sub_18F4979E4(uint64_t result)
{
  *(_BYTE *)(result + 108) = 1;
  return result;
}

uint64_t sub_18F4979F4()
{
  NSObject *v0;
  char *v2;
  uint8_t buf[1640];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE68 != -1)
    dispatch_once(&qword_1ECEDEE68, &unk_1E2954728);
  v0 = qword_1ECEDEE60;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_INFO, "Warning: Not implemented.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954728);
    v2 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual BOOL CLGyroCalibrationDatabase::getGyroStats(CLMotionTypeRotationRate &, CLMotionTypeRotationRate &, CLMotionTypeRotationRate &, BOOL)", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf)
      free(v2);
  }
  return 0;
}

uint64_t sub_18F497B7C()
{
  NSObject *v0;
  char *v2;
  uint8_t buf[1640];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE68 != -1)
    dispatch_once(&qword_1ECEDEE68, &unk_1E2954728);
  v0 = qword_1ECEDEE60;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_INFO, "Warning: Not implemented.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954728);
    v2 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual int CLGyroCalibrationDatabase::getMaxDynamicTemperature()", "CoreLocation: %s\n", v2);
    if (v2 != (char *)buf)
      free(v2);
  }
  return 0x80000000;
}

os_log_t sub_18F497D04()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Core", "Notifier");
  qword_1EE16D440 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F497D38(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[5];

  *a1 = &off_1E294AD88;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  v2 = sub_18F204AE4();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = sub_18F497DDC;
  v4[3] = &unk_1E2955738;
  v4[4] = a1;
  sub_18F1F5E28(v2, (uint64_t)v4);
  return a1;
}

void sub_18F497DBC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  sub_18F3C67B0((_QWORD **)(v2 + 24), 0);
  sub_18F2A8438(v1);
  _Unwind_Resume(a1);
}

void sub_18F497DDC(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  std::__shared_weak_count *v3;
  unint64_t *v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  char v14;
  __int128 v15;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = (_QWORD *)sub_18F1E0F30();
  v13 = 0x140000FF0CLL;
  v14 = 0;
  sub_18F1E9BC8(v2, (uint64_t)&v13, (uint64_t *)&v15);
  sub_18F346DC8(v1 + 8, &v15);
  v3 = (std::__shared_weak_count *)*((_QWORD *)&v15 + 1);
  if (*((_QWORD *)&v15 + 1))
  {
    v4 = (unint64_t *)(*((_QWORD *)&v15 + 1) + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  sub_18F203148(*(_QWORD *)(v1 + 8), (uint64_t)nullsub_172, v1);
  sub_18F4D3D78(*(_QWORD *)(v1 + 8), (uint64_t)sub_18F497F84, v1);
  sub_18F4D3788(*(_QWORD *)(v1 + 8), (uint64_t)sub_18F497F84, v1);
  sub_18F4D4518(*(_QWORD *)(v1 + 8), (const char *)sub_18F497F84, v1);
  v6 = (_QWORD *)operator new();
  v7 = v6;
  v8 = *(std::__shared_weak_count **)(v1 + 16);
  *(_QWORD *)&v15 = *(_QWORD *)(v1 + 8);
  *((_QWORD *)&v15 + 1) = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  sub_18F410E3C(v6, &v15);
  if (v8)
  {
    v11 = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  sub_18F3C67B0((_QWORD **)(v1 + 24), v7);
  sub_18F4114BC(*(uint64_t **)(v1 + 24));
}

void sub_18F497F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  sub_18F2A8438((uint64_t)va);
  MEMORY[0x194001438](v3, 0xA0C40D4F6A234);
  _Unwind_Resume(a1);
}

uint64_t sub_18F497F84(_QWORD *a1)
{
  uint64_t *v2;

  v2 = (uint64_t *)a1[3];
  sub_18F411138(v2);
  sub_18F4114BC(v2);
  return (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
}

uint64_t sub_18F497FC0(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = &off_1E294AD88;
  v2 = a1 + 8;
  sub_18F3C67B0((_QWORD **)(a1 + 24), 0);
  sub_18F2A8438(v2);
  return a1;
}

void sub_18F498004(uint64_t a1)
{
  uint64_t v1;

  *(_QWORD *)a1 = &off_1E294AD88;
  v1 = a1 + 8;
  sub_18F3C67B0((_QWORD **)(a1 + 24), 0);
  sub_18F2A8438(v1);
  JUMPOUT(0x194001438);
}

BOOL sub_18F498058(uint64_t a1, uint64_t a2, char *a3)
{
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  uint8_t buf[8];
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  sub_18F204AE4();
  sub_18F3DE6D4();
  if ((sub_18F1F7BFC() & 0x100) == 0)
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E29540A8);
    v7 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "isAvailable()";
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29540A8);
    }
    v8 = off_1EE16D428;
    if (os_signpost_enabled((os_log_t)off_1EE16D428))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "isAvailable()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLSPUEclipseInterface] Service required", "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E29540A8);
    }
    v9 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "isAvailable()";
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLSPUEclipseInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  v10 = 0;
  *(_QWORD *)buf = 4;
  return sub_18F4120A8(*(_QWORD *)(a1 + 24), a2, a3, (uint64_t)&v10, (uint64_t)buf) == 0;
}

os_log_t sub_18F4982F8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Eclipse");
  off_1EE16D428 = result;
  return result;
}

uint64_t sub_18F498324(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[5];

  *(_QWORD *)a1 = &off_1E294B148;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_BYTE *)(a1 + 40) = 0;
  v2 = sub_18F204AE4();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = sub_18F4983D0;
  v4[3] = &unk_1E2955738;
  v4[4] = a1;
  sub_18F1F5E28(v2, (uint64_t)v4);
  return a1;
}

void sub_18F4983B0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  sub_18F3C67B0((_QWORD **)(v2 + 24), 0);
  sub_18F2A8438(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4983D0(uint64_t a1)
{
  return sub_18F4983D8(*(_QWORD *)(a1 + 32));
}

uint64_t sub_18F4983D8(uint64_t a1)
{
  unint64_t v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  char *v16;
  uint64_t v17;
  char v18;
  __int16 v19;
  uint8_t buf[1640];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  sub_18F204AE4();
  sub_18F3DE6D4();
  v2 = sub_18F1F7BFC();
  if ((v2 & 0x200) != 0)
  {
    if (!*(_QWORD *)(a1 + 8))
    {
      v3 = (_QWORD *)sub_18F1E0F30();
      v17 = 0x150000FF0CLL;
      v18 = 0;
      sub_18F1E9BC8(v3, (uint64_t)&v17, (uint64_t *)buf);
      sub_18F346DC8(a1 + 8, (__int128 *)buf);
      v4 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v5 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v6 = __ldaxr(v5);
        while (__stlxr(v6 - 1, v5));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      sub_18F203148(*(_QWORD *)(a1 + 8), (uint64_t)sub_18F498CF8, a1);
      sub_18F4D3D78(*(_QWORD *)(a1 + 8), (uint64_t)sub_18F4989B8, a1);
      sub_18F4D3788(*(_QWORD *)(a1 + 8), (uint64_t)sub_18F4989B8, a1);
      sub_18F4D4518(*(_QWORD *)(a1 + 8), (const char *)sub_18F4989B8, a1);
      v7 = (_QWORD *)operator new();
      v8 = v7;
      v9 = *(std::__shared_weak_count **)(a1 + 16);
      *(_QWORD *)buf = *(_QWORD *)(a1 + 8);
      *(_QWORD *)&buf[8] = v9;
      if (v9)
      {
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v11 = __ldxr(p_shared_owners);
        while (__stxr(v11 + 1, p_shared_owners));
      }
      sub_18F410E3C(v7, buf);
      if (v9)
      {
        v12 = (unint64_t *)&v9->__shared_owners_;
        do
          v13 = __ldaxr(v12);
        while (__stlxr(v13 - 1, v12));
        if (!v13)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      sub_18F3C67B0((_QWORD **)(a1 + 24), v8);
      sub_18F4114BC(*(uint64_t **)(a1 + 24));
    }
  }
  else
  {
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    v14 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_FAULT, "Service unavailable.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
      v19 = 0;
      v16 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "BOOL CLSPUMagicMountInterface::openHidDevice()", "CoreLocation: %s\n", v16);
      if (v16 != (char *)buf)
        free(v16);
    }
  }
  return (v2 >> 9) & 1;
}

void sub_18F4986DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  sub_18F2A8438((uint64_t)va);
  MEMORY[0x194001438](v7, 0xA0C40D4F6A234);
  _Unwind_Resume(a1);
}

BOOL sub_18F498718(uint64_t a1, uint64_t a2, char *a3)
{
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  uint8_t buf[8];
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  sub_18F204AE4();
  sub_18F3DE6D4();
  if ((sub_18F1F7BFC() & 0x200) == 0)
  {
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    v7 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "isAvailable()";
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLMagicMountInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    }
    v8 = qword_1EE16D810;
    if (os_signpost_enabled((os_log_t)qword_1EE16D810))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "isAvailable()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLMagicMountInterface] Service required", "{\"msg%{public}.0s\":\"[CLMagicMountInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    }
    v9 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "isAvailable()";
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLMagicMountInterface] Service required\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  v10 = 0;
  *(_QWORD *)buf = 4;
  return sub_18F4120A8(*(_QWORD *)(a1 + 24), a2, a3, (uint64_t)&v10, (uint64_t)buf) == 0;
}

BOOL sub_18F4989B8(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 24);
  sub_18F411138(v2);
  sub_18F4114BC(v2);
  return sub_18F4989EC(a1);
}

BOOL sub_18F4989EC(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _BOOL8 v4;
  NSObject *v5;
  char *v7;
  char *v8;
  _BYTE v9[2];
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint8_t buf[4];
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  sub_18F204AE4();
  sub_18F3DE6D4();
  v9[0] = 2;
  v2 = *(unsigned __int8 *)(a1 + 40);
  v9[1] = *(_BYTE *)(a1 + 40);
  v10 = 0;
  v11 = 0;
  if (qword_1EE16D808 != -1)
    dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
  v3 = qword_1EE16D810;
  if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67240192;
    v15 = v2;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_INFO, "[CLMagicMountInterface] Sending config shouldKeepRunning,%{public}u,", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    v12 = 67240192;
    v13 = v2;
    v7 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CLSPUMagicMountInterface::configure()", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf)
      free(v7);
  }
  v4 = sub_18F498718(a1, (uint64_t)v9, (char *)0xE);
  if (!v4)
  {
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    v5 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_ERROR, "[CLMagicMountInterface] Configure failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
      LOWORD(v12) = 0;
      v8 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "BOOL CLSPUMagicMountInterface::configure()", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf)
        free(v8);
    }
  }
  return v4;
}

void sub_18F498CF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v4;
  uint8_t *v5;
  NSObject *v6;
  uint8_t buf[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    IOHIDEventGetVendorDefinedData();
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    v4 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "Empty payload, returning", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
      v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLSPUMagicMountInterface::onIoHidEvent(IOHIDEventRef)", "CoreLocation: %s\n");
LABEL_19:
      if (v5 != buf)
        free(v5);
    }
  }
  else
  {
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    v6 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "Event ref invalid", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
      v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLSPUMagicMountInterface::onIoHidEvent(IOHIDEventRef)", "CoreLocation: %s\n");
      goto LABEL_19;
    }
  }
}

void sub_18F4993E8(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _BYTE v11[2];
  unint64_t v12;
  int v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (sub_18F4983D8(v2))
  {
    v11[0] = 3;
    v11[1] = *(_BYTE *)(a1 + 48);
    v12 = (unint64_t)(*(double *)(a1 + 40) * 1000000.0);
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
    v3 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(unsigned __int8 *)(a1 + 48);
      v5 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 67240448;
      v18 = v4;
      v19 = 2050;
      v20 = v5;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[CLMagicMountInterface] Simulate,mountStatus,%{public}u,%{public}f", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
      v7 = *(unsigned __int8 *)(a1 + 48);
      v8 = *(_QWORD *)(a1 + 40);
      v13 = 67240448;
      v14 = v7;
      v15 = 2050;
      v16 = v8;
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLSPUMagicMountInterface::simulateMagicMountEvent(uint8_t, CFTimeInterval)_block_invoke", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
    if (!sub_18F498718(v2, (uint64_t)v11, (char *)0xA))
    {
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
      v6 = qword_1EE16D810;
      if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_ERROR, "[CLMagicMountInterface] Simulate failed", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D808 != -1)
          dispatch_once(&qword_1EE16D808, &unk_1E29540C8);
        LOWORD(v13) = 0;
        v10 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CLSPUMagicMountInterface::simulateMagicMountEvent(uint8_t, CFTimeInterval)_block_invoke", "CoreLocation: %s\n", v10);
        if (v10 != (char *)buf)
          free(v10);
      }
    }
  }
}

os_log_t sub_18F49972C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "MagicMount");
  qword_1EE16D810 = (uint64_t)result;
  return result;
}

os_log_t sub_18F49B088()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "HealthColdStorage");
  qword_1EE16D940 = (uint64_t)result;
  return result;
}

void sub_18F49B0B4(uint64_t a1, void *a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  char *v14;
  uint8_t buf[4];
  void *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v8 = *(void **)(a1 + 32);
    v9 = objc_msgSend_sr_dictionaryRepresentation(a2, v4, v5, v6, v7);
    objc_msgSend_addObject_(v8, v10, v9, v11, v12);
  }
  else
  {
    if (qword_1EE16D938 != -1)
      dispatch_once(&qword_1EE16D938, &unk_1E29540E8);
    v13 = qword_1EE16D940;
    if (os_log_type_enabled((os_log_t)qword_1EE16D940, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v16 = a2;
      _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_ERROR, " sr_dictionaryRepresentation not available for %{public}@", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D938 != -1)
        dispatch_once(&qword_1EE16D938, &unk_1E29540E8);
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "NSArray *convertedSRDictArrayFromContainer(NSArray *)_block_invoke", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
    }
  }
}

BOOL sub_18F49B4A0(void *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  _BOOL8 result;
  char *v14;
  int v15;
  NSObject *v16;
  char *v17;
  uint8_t buf[1640];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)objc_msgSend_length(a1, a2, a3, a4, a5) > 1)
  {
    v15 = *(unsigned __int16 *)objc_msgSend_bytes(a1, v7, v8, v9, v10);
    if (a2)
    {
      *(_WORD *)a2 = v15;
    }
    else
    {
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
      v16 = qword_1ECEDEE60;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_ERROR, "Invalid version parameter.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE68 != -1)
          dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
        v17 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "BOOL CLGyroCalibrationUtils::isGYTTVersionValid(NSData *, UInt16 *)", "CoreLocation: %s\n", v17);
        if (v17 != (char *)buf)
          free(v17);
      }
    }
    return v15 == 2;
  }
  else
  {
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
    v11 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_FAULT, "GYTT data not long enough to get version properly", buf, 2u);
    }
    v12 = sub_18F1FCA08(115, 0);
    result = 0;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "BOOL CLGyroCalibrationUtils::isGYTTVersionValid(NSData *, UInt16 *)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
      return 0;
    }
  }
  return result;
}

void sub_18F49B79C(float **a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  int v8;
  const char *v9;
  int v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  const __CFDictionary *v15;
  io_service_t MatchingService;
  io_object_t v17;
  CFTypeID v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFString *v37;
  uint64_t v38;
  uint64_t v39;
  float v40;
  uint64_t v41;
  id v42;
  const char *v43;
  uint64_t v44;
  const char *v45;
  NSObject *v46;
  int v47;
  float v48;
  float v49;
  float v50;
  NSObject *v51;
  unint64_t v52;
  float *v53;
  float *v54;
  NSObject *v55;
  char *v56;
  float *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  float *v63;
  float *v64;
  float *v65;
  char *v66;
  char *v67;
  NSObject *v68;
  char *v69;
  NSObject *v70;
  NSObject *v71;
  id v72;
  const char *v73;
  uint64_t v74;
  const char *v75;
  NSObject *v76;
  const char *v77;
  uint64_t v78;
  uint64_t v79;
  NSObject *v80;
  const char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  __CFString *v85;
  const char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  const char *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  const char *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  const char *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  __int16 v109;
  const char *v110;
  const char *v111;
  NSObject *v112;
  const char *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  id v117;
  const char *v118;
  uint64_t v119;
  const char *v120;
  NSObject *v121;
  id v122;
  const char *v123;
  uint64_t v124;
  const char *v125;
  NSObject *v126;
  char *v127;
  uint64_t v128;
  id v129;
  const char *v130;
  uint64_t v131;
  const char *v132;
  NSObject *v133;
  char *v134;
  char *v135;
  char *v136;
  char *v137;
  char *v138;
  char *v139;
  uint64_t v140;
  uint64_t v141;
  __CFString *v142;
  uint64_t v143;
  CFTypeRef cf;
  uint64_t v146;
  uint64_t v147;
  int v148;
  const __CFString *v149;
  __int16 v150;
  double v151;
  __int16 v152;
  double v153;
  __int16 v154;
  double v155;
  __int16 v156;
  double v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  const __CFString *v165;
  _BYTE buf[22];
  __int16 v167;
  double v168;
  __int16 v169;
  double v170;
  __int16 v171;
  double v172;
  const __CFString *v173;
  uint64_t v174;
  const __CFString *v175;
  _QWORD v176[4];

  v176[1] = *MEMORY[0x1E0C80C00];
  cf = 0;
  v3 = sub_18F204AE4();
  v4 = *(_QWORD *)(v3 + 24);
  v5 = *(std::__shared_weak_count **)(v3 + 32);
  *(_QWORD *)buf = v4;
  *(_QWORD *)&buf[8] = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = sub_18F1DEC8C(v4, "GYTTOverride", &cf, 0xFFFFFFFFLL);
  v10 = v8;
  if (!v5)
    goto LABEL_8;
  v11 = (unint64_t *)&v5->__shared_owners_;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(v12 - 1, v11));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    if (v10)
      goto LABEL_9;
  }
  else
  {
LABEL_8:
    if (v8)
    {
LABEL_9:
      CFRetain(cf);
      goto LABEL_13;
    }
  }
  v175 = CFSTR("name");
  v176[0] = CFSTR("gyro");
  v13 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v9, (uint64_t)v176, (uint64_t)&v175, 1);
  v173 = CFSTR("IOPropertyMatch");
  v174 = v13;
  v15 = (const __CFDictionary *)(id)objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v14, (uint64_t)&v174, (uint64_t)&v173, 1);
  MatchingService = IOServiceGetMatchingService(*MEMORY[0x1E0CBBAA8], v15);
  v17 = MatchingService;
  if (!MatchingService)
  {
    if (qword_1EE16D430 != -1)
      dispatch_once(&qword_1EE16D430, &unk_1E29550E8);
    v71 = qword_1EE16D420;
    if (os_log_type_enabled((os_log_t)qword_1EE16D420, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v71, OS_LOG_TYPE_FAULT, "Service doesn't exist", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D430 != -1)
        dispatch_once(&qword_1EE16D430, &unk_1E29550E8);
      LOWORD(v148) = 0;
      v136 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "BOOL CLGyroCalibrationUtils::copyGYTTData(NSData **)", "CoreLocation: %s\n", v136);
      if (v136 != buf)
        free(v136);
    }
    goto LABEL_94;
  }
  cf = IORegistryEntryCreateCFProperty(MatchingService, CFSTR("gyro-temp-table"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  IOObjectRelease(v17);
LABEL_13:
  if (cf)
  {
    v18 = CFGetTypeID(cf);
    if (v18 == CFDataGetTypeID())
    {
      v142 = (__CFString *)cf;
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
      v19 = qword_1ECEDEE60;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v142;
        _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_DEBUG, "GYTT data %@", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE68 != -1)
          dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
        v148 = 138412290;
        v149 = v142;
        LODWORD(v140) = 12;
        v135 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLGyroCalibrationUtils::copyGYTTData(NSData **)", "CoreLocation: %s\n", v135);
        if (v135 != buf)
          free(v135);
      }
      LOWORD(cf) = -1;
      if (sub_18F49B4A0(v142, (char *)&cf, v20, v21, v22))
      {
        v27 = objc_msgSend_bytes(v142, v23, v24, v25, v26);
      }
      else
      {
        sub_18F1F77DC();
        if (sub_18F1E19B0() - 191 >= 2)
        {
          v116 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v77, (uint64_t)CFSTR("GYTT version (%u) does not match expected version (%u)"), v78, v79, (unsigned __int16)cf, 2);
          if (a2)
          {
            v122 = objc_alloc(MEMORY[0x1E0CB35C8]);
            v162 = *MEMORY[0x1E0CB2D50];
            v163 = v116;
            v124 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v123, (uint64_t)&v163, (uint64_t)&v162, 1);
            *a2 = (id)objc_msgSend_initWithDomain_code_userInfo_(v122, v125, (uint64_t)CFSTR("CMErrorDomainFactory"), 5, v124);
          }
          if (qword_1ECEDEE68 != -1)
            dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
          v126 = qword_1ECEDEE60;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v116;
            _os_log_impl(&dword_18F1DC000, v126, OS_LOG_TYPE_FAULT, "%{public}@", buf, 0xCu);
          }
          if (!sub_18F1FCA08(115, 0))
            goto LABEL_149;
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE68 == -1)
            goto LABEL_139;
          goto LABEL_181;
        }
        if (qword_1ECEDEE68 != -1)
          dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
        v80 = qword_1ECEDEE60;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v80, OS_LOG_TYPE_DEFAULT, "Attempting GYTT recovery!", buf, 2u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE68 != -1)
            dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
          LOWORD(v148) = 0;
          LODWORD(v140) = 2;
          v138 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLGyroCalibrationUtils::readFactoryGYTTWithError(std::vector<std::pair<float, CLMotionTypeRotationRate>> &, NSError **)", "CoreLocation: %s\n", v138);
          if (v138 != buf)
            free(v138);
        }
        v85 = (__CFString *)objc_msgSend_mutableCopy(v142, v81, v82, v83, v84);

        v90 = objc_msgSend_bytes(v85, v86, v87, v88, v89);
        v99 = objc_msgSend_length(v85, v91, v92, v93, v94);
        if (v99 >= 4)
        {
          v100 = 0;
          do
          {
            *(_DWORD *)buf = bswap32(*(_DWORD *)(v90 + v100));
            objc_msgSend_replaceBytesInRange_withBytes_length_(v85, v95, v100, 4, (uint64_t)buf, 4);
            v100 += 4;
            v99 -= 4;
          }
          while (v99 > 3);
        }
        if (!sub_18F49B4A0(v85, (char *)&cf, v96, v97, v98))
        {
          v128 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v101, (uint64_t)CFSTR("After recovery, GYTT version (%u) still does not match expected version (%u)"), v102, v103, (unsigned __int16)cf, 2);
          if (a2)
          {
            v129 = objc_alloc(MEMORY[0x1E0CB35C8]);
            v160 = *MEMORY[0x1E0CB2D50];
            v161 = v128;
            v131 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v130, (uint64_t)&v161, (uint64_t)&v160, 1);
            *a2 = (id)objc_msgSend_initWithDomain_code_userInfo_(v129, v132, (uint64_t)CFSTR("CMErrorDomainFactory"), 5, v131);
          }
          if (qword_1ECEDEE68 != -1)
            dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
          v133 = qword_1ECEDEE60;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 138543362;
            *(_QWORD *)&buf[4] = v128;
            _os_log_impl(&dword_18F1DC000, v133, OS_LOG_TYPE_FAULT, "%{public}@", buf, 0xCu);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE68 != -1)
              dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
            v148 = 138543362;
            v149 = (const __CFString *)v128;
            v139 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLGyroCalibrationUtils::readFactoryGYTTWithError(std::vector<std::pair<float, CLMotionTypeRotationRate>> &, NSError **)", "CoreLocation: %s\n", v139);
            if (v139 != buf)
              free(v139);
          }
          v142 = v85;
          goto LABEL_149;
        }
        sub_18F1F77DC();
        if (sub_18F1E19B0() - 191 <= 1)
        {
          v108 = objc_msgSend_bytes(v85, v104, v105, v106, v107);
          v109 = *(_WORD *)(v108 + 4);
          *(_WORD *)buf = -*(_WORD *)(v108 + 6);
          LOWORD(v148) = v109;
          objc_msgSend_replaceBytesInRange_withBytes_length_(v85, v110, 4, 2, (uint64_t)buf, 2);
          objc_msgSend_replaceBytesInRange_withBytes_length_(v85, v111, 6, 2, (uint64_t)&v148, 2);
        }
        v142 = v85;
        v27 = objc_msgSend_bytes(v85, v104, v105, v106, v107);
      }
      v32 = v27;
      v36 = objc_msgSend_length(v142, v28, v29, v30, v31);
      if ((unint64_t)(v36 - 10) > 0xFFFFFFFFFFFFFFF7)
      {
        v37 = 0;
      }
      else
      {
        v37 = 0;
        v38 = 2;
        v141 = *MEMORY[0x1E0CB2D50];
        do
        {
          v39 = *(_QWORD *)(v32 + v38);
          v40 = (float)(__int16)v39 * 0.0039062;
          if (v40 > 100.0)
          {
            v143 = *(_QWORD *)(v32 + v38);
            v41 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v33, (uint64_t)CFSTR("Invalid GYTT temperature %f"), v34, v35, v40, v140);
            if (a2)
            {
              v42 = objc_alloc(MEMORY[0x1E0CB35C8]);
              v158 = v141;
              v159 = v41;
              v44 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v43, (uint64_t)&v159, (uint64_t)&v158, 1);
              *a2 = (id)objc_msgSend_initWithDomain_code_userInfo_(v42, v45, (uint64_t)CFSTR("CMErrorDomainFactory"), 6, v44);
            }
            if (qword_1ECEDEE68 != -1)
              dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
            v46 = qword_1ECEDEE60;
            if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138543362;
              *(_QWORD *)&buf[4] = v41;
              _os_log_impl(&dword_18F1DC000, v46, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
            }
            v47 = sub_18F1FCA08(115, 0);
            v39 = v143;
            if (v47)
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE68 != -1)
                dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
              v148 = 138543362;
              v149 = (const __CFString *)v41;
              LODWORD(v140) = 12;
              v67 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 0, "void CLGyroCalibrationUtils::readFactoryGYTTWithError(std::vector<std::pair<float, CLMotionTypeRotationRate>> &, NSError **)", "CoreLocation: %s\n", v67);
              if (v67 != buf)
                free(v67);
              v39 = v143;
            }
          }
          v48 = (float)SWORD1(v39) * 0.0039062;
          v49 = (float)SWORD2(v39) * 0.0039062;
          v50 = (float)SHIWORD(v39) * 0.0039062;
          if (v39)
          {
            if (qword_1ECEDEE68 != -1)
              dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
            v51 = qword_1ECEDEE60;
            if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 134219008;
              *(_QWORD *)&buf[4] = v37;
              *(_WORD *)&buf[12] = 2048;
              *(double *)&buf[14] = v40;
              v167 = 2048;
              v168 = v48;
              v169 = 2048;
              v170 = v49;
              v171 = 2048;
              v172 = v50;
              _os_log_impl(&dword_18F1DC000, v51, OS_LOG_TYPE_DEBUG, "Reading GYTT point %zu: %f,%f,%f,%f", buf, 0x34u);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE68 != -1)
                dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
              v148 = 134219008;
              v149 = v37;
              v150 = 2048;
              v151 = v40;
              v152 = 2048;
              v153 = v48;
              v154 = 2048;
              v155 = v49;
              v156 = 2048;
              v157 = v50;
              LODWORD(v140) = 52;
              v66 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "void CLGyroCalibrationUtils::readFactoryGYTTWithError(std::vector<std::pair<float, CLMotionTypeRotationRate>> &, NSError **)", "CoreLocation: %s\n", v66);
              if (v66 != buf)
                free(v66);
            }
            v53 = a1[1];
            v52 = (unint64_t)a1[2];
            if ((unint64_t)v53 >= v52)
            {
              v57 = *a1;
              v58 = ((char *)v53 - (char *)*a1) >> 4;
              v59 = v58 + 1;
              if ((unint64_t)(v58 + 1) >> 60)
                sub_18F26F8C0();
              v60 = v52 - (_QWORD)v57;
              if (v60 >> 3 > v59)
                v59 = v60 >> 3;
              if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF0)
                v61 = 0xFFFFFFFFFFFFFFFLL;
              else
                v61 = v59;
              if (v61 >> 60)
                sub_18F26F97C();
              v62 = (char *)operator new(16 * v61);
              v63 = (float *)&v62[16 * v58];
              *v63 = v40;
              v63[1] = v48;
              v63[2] = v49;
              v63[3] = v50;
              v64 = v63;
              if (v53 != v57)
              {
                do
                {
                  *((_OWORD *)v64 - 1) = *((_OWORD *)v53 - 1);
                  v64 -= 4;
                  v53 -= 4;
                }
                while (v53 != v57);
                v53 = v57;
              }
              v65 = (float *)&v62[16 * v61];
              v54 = v63 + 4;
              *a1 = v64;
              a1[1] = v63 + 4;
              a1[2] = v65;
              if (v53)
                operator delete(v53);
            }
            else
            {
              *v53 = v40;
              v53[1] = v48;
              v54 = v53 + 4;
              v53[2] = v49;
              v53[3] = v50;
            }
            a1[1] = v54;
            v37 = (const __CFString *)((char *)v37 + 1);
          }
          else
          {
            if (qword_1ECEDEE68 != -1)
              dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
            v55 = qword_1ECEDEE60;
            if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 134219008;
              *(_QWORD *)&buf[4] = v37;
              *(_WORD *)&buf[12] = 2048;
              *(double *)&buf[14] = v40;
              v167 = 2048;
              v168 = v48;
              v169 = 2048;
              v170 = v49;
              v171 = 2048;
              v172 = v50;
              _os_log_impl(&dword_18F1DC000, v55, OS_LOG_TYPE_DEBUG, "Skipping GYTT point %zu: %f,%f,%f,%f", buf, 0x34u);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE68 != -1)
                dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
              v148 = 134219008;
              v149 = v37;
              v150 = 2048;
              v151 = v40;
              v152 = 2048;
              v153 = v48;
              v154 = 2048;
              v155 = v49;
              v156 = 2048;
              v157 = v50;
              LODWORD(v140) = 52;
              v56 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "void CLGyroCalibrationUtils::readFactoryGYTTWithError(std::vector<std::pair<float, CLMotionTypeRotationRate>> &, NSError **)", "CoreLocation: %s\n", v56);
              if (v56 != buf)
                free(v56);
            }
          }
          v38 += 8;
        }
        while ((unint64_t)(v36 - v38) > 7);
      }
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
      v112 = qword_1ECEDEE60;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v37;
        _os_log_impl(&dword_18F1DC000, v112, OS_LOG_TYPE_DEBUG, "%zu GYTT points found", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE68 != -1)
          dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
        v148 = 134217984;
        v149 = v37;
        v137 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLGyroCalibrationUtils::readFactoryGYTTWithError(std::vector<std::pair<float, CLMotionTypeRotationRate>> &, NSError **)", "CoreLocation: %s\n", v137);
        if (v137 != buf)
          free(v137);
      }
      if (v37)
        goto LABEL_149;
      v116 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v113, (uint64_t)CFSTR("Insufficent GYTT points. Found: %zu"), v114, v115, 0);
      if (a2)
      {
        v117 = objc_alloc(MEMORY[0x1E0CB35C8]);
        v146 = *MEMORY[0x1E0CB2D50];
        v147 = v116;
        v119 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v118, (uint64_t)&v147, (uint64_t)&v146, 1);
        *a2 = (id)objc_msgSend_initWithDomain_code_userInfo_(v117, v120, (uint64_t)CFSTR("CMErrorDomainFactory"), 7, v119);
      }
      if (qword_1ECEDEE68 != -1)
        dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
      v121 = qword_1ECEDEE60;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v116;
        _os_log_impl(&dword_18F1DC000, v121, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
      }
      if (!sub_18F1FCA08(115, 0))
        goto LABEL_149;
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE68 == -1)
      {
LABEL_139:
        v148 = 138543362;
        v149 = (const __CFString *)v116;
        v127 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CLGyroCalibrationUtils::readFactoryGYTTWithError(std::vector<std::pair<float, CLMotionTypeRotationRate>> &, NSError **)", "CoreLocation: %s\n", v127);
        if (v127 != buf)
          free(v127);
LABEL_149:

        return;
      }
LABEL_181:
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
      goto LABEL_139;
    }
  }
  if ((sub_18F1F7BFC() & 0x80000) != 0)
  {
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
    v70 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v70, OS_LOG_TYPE_DEFAULT, "No optional GYTT data found", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      goto LABEL_87;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
    LOWORD(v148) = 0;
    v69 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CLGyroCalibrationUtils::copyGYTTData(NSData **)", "CoreLocation: %s\n", v69);
  }
  else
  {
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
    v68 = qword_1ECEDEE60;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v68, OS_LOG_TYPE_FAULT, "Cannot get GYTT property", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_87;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
    LOWORD(v148) = 0;
    v69 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "BOOL CLGyroCalibrationUtils::copyGYTTData(NSData **)", "CoreLocation: %s\n", v69);
  }
  if (v69 != buf)
    free(v69);
LABEL_87:
  if (cf)
    CFRelease(cf);
LABEL_94:
  if (a2)
  {
    v72 = objc_alloc(MEMORY[0x1E0CB35C8]);
    v164 = *MEMORY[0x1E0CB2D50];
    v165 = CFSTR("Failed to read GYTT key from gyro service");
    v74 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v73, (uint64_t)&v165, (uint64_t)&v164, 1);
    *a2 = (id)objc_msgSend_initWithDomain_code_userInfo_(v72, v75, (uint64_t)CFSTR("CMErrorDomainFactory"), 3, v74);
  }
  if (qword_1ECEDEE68 != -1)
    dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
  v76 = qword_1ECEDEE60;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE60, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)&buf[4] = CFSTR("Failed to read GYTT key from gyro service");
    _os_log_impl(&dword_18F1DC000, v76, OS_LOG_TYPE_ERROR, "%{public}@", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE68 != -1)
      dispatch_once(&qword_1ECEDEE68, &unk_1E2954108);
    v148 = 138543362;
    v149 = CFSTR("Failed to read GYTT key from gyro service");
    v134 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "void CLGyroCalibrationUtils::readFactoryGYTTWithError(std::vector<std::pair<float, CLMotionTypeRotationRate>> &, NSError **)", "CoreLocation: %s\n", v134);
    if (v134 != buf)
      free(v134);
  }
}

void sub_18F49D02C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  sub_18F2A8438((uint64_t)&a41);
  _Unwind_Resume(a1);
}

os_log_t sub_18F49D048()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "AOP");
  qword_1EE16D420 = (uint64_t)result;
  return result;
}

float sub_18F49D434(unsigned __int16 *a1, int a2, int a3, int a4, float *a5, unsigned int a6)
{
  int v7;
  int v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  uint64_t v14;
  float v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  float v21;
  float v22;
  float *v23;
  uint64_t v24;
  float v25;
  float v26;
  char v28;
  int v29;

  if ((a4 + 1) >= 3)
    v7 = 0;
  else
    v7 = a4;
  if (a3 >= 0)
    v8 = a3;
  else
    v8 = a3 + 1;
  v9 = (v8 >> 1);
  v10 = 0.0;
  v11 = 0.0;
  v12 = 0.0;
  if (a3 >= 2)
  {
    v14 = 0;
    v15 = (float)v7;
    v16 = (a3 + 1) >> 1;
    v28 = a3;
    v17 = a3 + a2;
    v29 = a2;
    v18 = a2;
    v19 = a6 - 1;
    v20 = a5 + 1;
    v21 = 0.0;
    do
    {
      v22 = *a5;
      v23 = v20;
      v24 = v19;
      do
      {
        v25 = *v23++;
        v22 = v25 + (float)(v22 * (float)(v15 * (float)(int)(v16 + ~(_DWORD)v14)));
        --v24;
      }
      while (v24);
      v21 = v21 + v22;
      v26 = *(float *)sub_18F3410E0(a1, v14 + v18);
      v10 = v10 + (float)((float)(v26 + *(float *)sub_18F3410E0(a1, v17 + ~(_DWORD)v14)) * v22);
      if (!v14)
        v11 = v22;
      ++v14;
    }
    while (v14 != v9);
    v12 = v21 + v21;
    a2 = v29;
    LOBYTE(a3) = v28;
  }
  if ((a3 & 1) != 0)
    v10 = v10 + (float)(*(float *)sub_18F3410E0(a1, (int)v9 + a2) * v11);
  return v10 / v12;
}

void sub_18F49DE00(uint64_t a1)
{
  sub_18F49DE38(a1);
  sub_18F203AF8(*(_QWORD *)(a1 + 56), 1);
  *(_BYTE *)(a1 + 80) = 1;
  sub_18F49DFE8(a1);
}

void sub_18F49DE38(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  char v15;
  __int128 v16;

  v1 = a1 + 56;
  if (!*(_QWORD *)(a1 + 56))
  {
    v3 = (_QWORD *)sub_18F1E0F30();
    v14 = 0x10000FF0CLL;
    v15 = 0;
    sub_18F1E9BC8(v3, (uint64_t)&v14, (uint64_t *)&v16);
    sub_18F346DC8(v1, &v16);
    v4 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
    if (*((_QWORD *)&v16 + 1))
    {
      v5 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
      do
        v6 = __ldaxr(v5);
      while (__stlxr(v6 - 1, v5));
      if (!v6)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    sub_18F203148(*(_QWORD *)(a1 + 56), (uint64_t)sub_18F49E1E4, a1);
    sub_18F4D3D78(*(_QWORD *)(a1 + 56), (uint64_t)sub_18F49E7BC, a1);
    sub_18F4D3788(*(_QWORD *)(a1 + 56), (uint64_t)sub_18F49E7BC, a1);
    sub_18F4D4518(*(_QWORD *)(a1 + 56), (const char *)sub_18F49E7BC, a1);
    v7 = (_QWORD *)operator new();
    v8 = v7;
    v9 = *(std::__shared_weak_count **)(a1 + 64);
    *(_QWORD *)&v16 = *(_QWORD *)(a1 + 56);
    *((_QWORD *)&v16 + 1) = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    sub_18F410E3C(v7, &v16);
    if (v9)
    {
      v12 = (unint64_t *)&v9->__shared_owners_;
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    sub_18F3C67B0((_QWORD **)(a1 + 72), v8);
    sub_18F4114BC(*(uint64_t **)(a1 + 72));
  }
}

void sub_18F49DFB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  sub_18F2A8438((uint64_t)va);
  MEMORY[0x194001438](v3, 0xA0C40D4F6A234);
  _Unwind_Resume(a1);
}

void sub_18F49DFE8(uint64_t a1)
{
  NSObject *v2;
  char *v3;
  __int16 v4;
  _DWORD v5[4];
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v4 = 1;
  HIBYTE(v4) = *(_BYTE *)(a1 + 80);
  sub_18F204AE4();
  sub_18F3DE6D4();
  v5[0] = 0;
  *(_QWORD *)buf = 4;
  if (sub_18F4120A8(*(_QWORD *)(a1 + 72), (uint64_t)&v4, (char *)2, (uint64_t)v5, (uint64_t)buf))
  {
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954128);
    v2 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "[PickupDetection] Configure failed", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954128);
      LOWORD(v5[0]) = 0;
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CMPickupServiceMotionCoprocessor::configure()", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
}

void sub_18F49E1B0(uint64_t a1)
{
  sub_18F49DE38(a1);
  sub_18F203AF8(*(_QWORD *)(a1 + 56), 0);
  *(_BYTE *)(a1 + 80) = 0;
  sub_18F49DFE8(a1);
}

void sub_18F49E1E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v4;
  uint8_t *v5;
  NSObject *v6;
  uint8_t buf[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    IOHIDEventGetVendorDefinedData();
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954128);
    v4 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "Empty payload, returning", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954128);
      v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMPickupServiceMotionCoprocessor::onIoHidEvent(IOHIDEventRef)", "CoreLocation: %s\n");
LABEL_18:
      if (v5 != buf)
        free(v5);
    }
  }
  else
  {
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954128);
    v6 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "Event ref invalid", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954128);
      v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CMPickupServiceMotionCoprocessor::onIoHidEvent(IOHIDEventRef)", "CoreLocation: %s\n");
      goto LABEL_18;
    }
  }
}

void sub_18F49E7BC(uint64_t a1)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(a1 + 72);
  sub_18F411138(v2);
  sub_18F4114BC(v2);
  sub_18F49DFE8(a1);
}

uint64_t sub_18F49E7F0(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  char *v10;
  uint8_t buf[8];
  _BYTE v12[10];
  __int16 v13;
  double v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D3E8 != -1)
    dispatch_once(&qword_1EE16D3E8, &unk_1E2954128);
  v4 = qword_1EE16D3D8;
  if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
  {
    v5 = *(unsigned __int8 *)(a2 + 1);
    v6 = *(_QWORD *)(a1 + 48);
    v7 = mach_absolute_time();
    *(_DWORD *)buf = 67240704;
    *(_DWORD *)&buf[4] = v5;
    *(_WORD *)v12 = 2050;
    *(_QWORD *)&v12[2] = v6;
    v13 = 2050;
    v14 = sub_18F1FD20C(v7);
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEBUG, "Report,pickupState,%{public}u,timestamp,%{public}lf,now,%{public}lf", buf, 0x1Cu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954128);
    v9 = mach_absolute_time();
    sub_18F1FD20C(v9);
    v10 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CMPickupServiceMotionCoprocessor::visitPickupState(const CMAudioAccessoryReport::PickupState *)", "CoreLocation: %s\n", v10);
    if (v10 != (char *)buf)
      free(v10);
  }
  *(_QWORD *)buf = 0;
  buf[0] = *(_BYTE *)(a2 + 1);
  *(_QWORD *)v12 = *(_QWORD *)(a1 + 48);
  result = sub_18F1FD2C8(a1, 0, (uint64_t)buf, 16);
  *(_BYTE *)(a1 + 32) = buf[0];
  return result;
}

uint64_t sub_18F49EA24(uint64_t a1, uint64_t a2)
{
  return sub_18F49E7F0(a1 - 40, a2);
}

_QWORD *sub_18F49EA2C(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E294B7A8;
  *(_QWORD *)(a1 + 40) = &unk_1E294B800;
  sub_18F3C67B0((_QWORD **)(a1 + 72), 0);
  sub_18F2A8438(a1 + 56);
  return sub_18F3CA15C((_QWORD *)a1);
}

void sub_18F49EA74(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E294B7A8;
  *(_QWORD *)(a1 + 40) = &unk_1E294B800;
  sub_18F3C67B0((_QWORD **)(a1 + 72), 0);
  sub_18F2A8438(a1 + 56);
  sub_18F3CA15C((_QWORD *)a1);
  JUMPOUT(0x194001438);
}

_QWORD *sub_18F49EAD0(uint64_t a1)
{
  _QWORD *v2;

  *(_QWORD *)(a1 - 40) = &off_1E294B7A8;
  v2 = (_QWORD *)(a1 - 40);
  *(_QWORD *)a1 = &unk_1E294B800;
  sub_18F3C67B0((_QWORD **)(a1 + 32), 0);
  sub_18F2A8438(a1 + 16);
  return sub_18F3CA15C(v2);
}

void sub_18F49EB1C(uint64_t a1)
{
  _QWORD *v2;

  *(_QWORD *)(a1 - 40) = &off_1E294B7A8;
  v2 = (_QWORD *)(a1 - 40);
  *(_QWORD *)a1 = &unk_1E294B800;
  sub_18F3C67B0((_QWORD **)(a1 + 32), 0);
  sub_18F2A8438(a1 + 16);
  sub_18F3CA15C(v2);
  JUMPOUT(0x194001438);
}

os_log_t sub_18F49EB7C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Gesture");
  qword_1EE16D3D8 = (uint64_t)result;
  return result;
}

void sub_18F4A16D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4A16EC()
{
  NSObject *v0;
  uint64_t v1;
  void *__p[2];
  char v4;

  v0 = dispatch_queue_create("com.apple.CoreMotion.CMMotionUtils.AsyncMessageQueue", 0);
  v1 = operator new();
  sub_18F270374(__p, "com.apple.locationd.registration");
  MEMORY[0x19400100C](v1, __p, v0);
  qword_1ECEDFCD8 = v1;
  if (v4 < 0)
    operator delete(__p[0]);
  dispatch_release(v0);
  return CLConnectionClient::start((CLConnectionClient *)qword_1ECEDFCD8);
}

void sub_18F4A178C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v15, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4A17C8(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v2;
  uint64_t DictionaryOfClasses;

  v2 = *(_QWORD *)(a1 + 40);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, *(NSSet **)(a1 + 32));
  else
    DictionaryOfClasses = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 16))(v2, DictionaryOfClasses);
}

void sub_18F4A1918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_18F2A8438((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_18F4A1B88(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_18F2A8438(v1);
  _Unwind_Resume(a1);
}

void sub_18F4A1BAC()
{
  NSObject *v0;
  CLConnectionClient *v1;
  void *__p[2];
  char v3;

  v0 = dispatch_queue_create("com.apple.CoreMotion.CMMotionUtils.SyncMessageQueue", 0);
  v1 = (CLConnectionClient *)operator new();
  sub_18F270374(__p, "com.apple.locationd.registration");
  MEMORY[0x19400100C](v1, __p, v0);
  qword_1ECEDFCE8 = (uint64_t)v1;
  if (v3 < 0)
  {
    operator delete(__p[0]);
    v1 = (CLConnectionClient *)qword_1ECEDFCE8;
  }
  CLConnectionClient::start(v1);
  dispatch_sync(v0, &unk_1E2945080);
  dispatch_release(v0);
}

void sub_18F4A1C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v15, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4A1FB8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  unsigned __int8 v6;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  result = objc_msgSend_isMotionActivityEntitled(CMMotionUtils, a2, a3, a4, a5);
  if ((result & 1) == 0)
  {
    values = (void *)*MEMORY[0x1E0C9AE50];
    keys[0] = CFSTR("_kTCCAccessRequestOptionSyncCallback");
    v6 = atomic_load((unsigned __int8 *)&qword_1ECEDFCF8);
    if ((v6 & 1) == 0)
    {
      if (__cxa_guard_acquire(&qword_1ECEDFCF8))
      {
        qword_1ECEDFCF0 = (uint64_t)CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        __cxa_guard_release(&qword_1ECEDFCF8);
      }
    }
    return TCCAccessRequest();
  }
  return result;
}

void sub_18F4A20B0(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ECEDFCF8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4A20E8(uint64_t a1)
{
  unsigned __int8 v2;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  values = (void *)*MEMORY[0x1E0C9AE50];
  keys[0] = CFSTR("_kTCCAccessRequestOptionSyncCallback");
  v2 = atomic_load((unsigned __int8 *)&qword_1ECEDFD18);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1ECEDFD18))
  {
    qword_1ECEDFD10 = (uint64_t)CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    __cxa_guard_release(&qword_1ECEDFD18);
  }
  if ((byte_1ECEDFCC8 & 1) == 0)
  {
    TCCAccessRequest();
    byte_1ECEDFCC8 = 1;
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_18F4A21F4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&qword_1ECEDFD18);
  _Unwind_Resume(a1);
}

void sub_18F4A23A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_18F2A8438((uint64_t)&a12);
  sub_18F2A8438((uint64_t)&a14);
  _Unwind_Resume(a1);
}

os_log_t sub_18F4A2A90()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Fall");
  qword_1EE16D830 = (uint64_t)result;
  return result;
}

_QWORD *sub_18F4A2ABC(_QWORD *a1)
{
  uint64_t v2;

  *a1 = off_1E294AA88;
  v2 = (uint64_t)(a1 + 4);
  sub_18F2A8438((uint64_t)(a1 + 8));
  sub_18F2A8438(v2);
  return sub_18F3DB8A0(a1);
}

const __CFString *sub_18F4A2B04(int a1)
{
  if ((a1 - 1) > 7)
    return CFSTR("unknown");
  else
    return (const __CFString *)*((_QWORD *)&off_1E2958E58 + a1 - 1);
}

const __CFString *sub_18F4A2B2C(unsigned int a1)
{
  if (a1 > 4)
    return CFSTR("?");
  else
    return (const __CFString *)*((_QWORD *)&off_1E2958E98 + (int)a1);
}

const __CFString *sub_18F4A2B50(int a1)
{
  const __CFString *v1;

  v1 = CFSTR("?");
  if (a1 == 1)
    v1 = CFSTR("Disconnected");
  if (a1)
    return v1;
  else
    return CFSTR("Connected");
}

const __CFString *sub_18F4A2B7C(unsigned int a1)
{
  if (a1 > 2)
    return CFSTR("?");
  else
    return (const __CFString *)*((_QWORD *)&off_1E2958EC0 + (int)a1);
}

BOOL sub_18F4A2BA0(uint64_t a1)
{
  if (!*(_QWORD *)(a1 + 80))
    return 1;
  sub_18F4D6638();
  return !sub_18F4D94F4();
}

uint64_t sub_18F4A2BCC()
{
  uint64_t v0;
  unsigned int v1;
  _BOOL4 v3;
  unsigned int v4;
  uint64_t v6;

  v6 = 0;
  v0 = sub_18F4D6638();
  sub_18F4D8C40(v0, (int *)&v6 + 1, (int *)&v6);
  if (v6)
    v1 = 2;
  else
    v1 = 4;
  v3 = HIDWORD(v6) != 3 || (_DWORD)v6 != 3;
  if ((_DWORD)v6)
    v4 = v3;
  else
    v4 = 3;
  if (HIDWORD(v6))
    return v4;
  else
    return v1;
}

uint64_t sub_18F4A2C38(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;
  char *v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 80))
  {
    v1 = sub_18F4D6638();
    return sub_18F4D955C(v1);
  }
  else
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v3 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] JBL is unavailable because BT accessory is not connected", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      v4 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "uint16_t CLAccessoryNotifier::getAdaptiveLatencyJitterBufferLevel() const", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf)
        free(v4);
    }
    return 0xFFFFLL;
  }
}

uint64_t sub_18F4A2DF8(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  const char *v8;
  NSObject *v9;
  char *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v16;
  _QWORD *v17;
  const char *v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  char *v30;
  NSObject *v31;
  char *v32;
  const char *v33;
  NSObject *v34;
  int v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  uint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  _QWORD v56[5];
  __int16 v57;
  int v58;
  _QWORD v59[7];
  uint64_t v60;
  _QWORD v61[5];
  int v62;
  int v63;
  _BYTE v64[24];
  uint64_t v65;
  uint8_t buf[4];
  void *v67;
  __int16 v68;
  void *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a2 || !a3)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v11 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] Resetting active audio route", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      *(_WORD *)v64 = 0;
      v45 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v45);
      if (v45 != (char *)buf)
        free(v45);
    }
    v12 = sub_18F204AE4();
    v61[0] = MEMORY[0x1E0C809B0];
    v61[1] = 3221225472;
    v61[2] = sub_18F4A4490;
    v61[3] = &unk_1E2955738;
    v61[4] = a1;
    sub_18F1F5E28(v12, (uint64_t)v61);
    return 1;
  }
  v60 = 0;
  v8 = (const char *)objc_msgSend_UTF8String(a2, (const char *)a2, (uint64_t)a3, a4, a5);
  if (sscanf(v8, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &v60, (char *)&v60 + 1, (char *)&v60 + 2, (char *)&v60 + 3, (char *)&v60 + 4, (char *)&v60 + 5) != 6)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v14 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138477827;
      v67 = a2;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_ERROR, "[AccessoryNotifier] Warning! Invalid input BT address %{private}@", buf, 0xCu);
    }
    if (!sub_18F1FCA08(115, 0))
      return 0;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    *(_DWORD *)v64 = 138477827;
    *(_QWORD *)&v64[4] = a2;
    v32 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v32);
    goto LABEL_127;
  }
  if (v60 == *(_QWORD *)(a1 + 88))
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v9 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138477827;
      v67 = a2;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The current active route is identical to the requsting device %{private}@", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      *(_DWORD *)v64 = 138477827;
      *(_QWORD *)&v64[4] = a2;
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
    return 1;
  }
  *(_QWORD *)(a1 + 88) = v60;
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
  v16 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138477827;
    v67 = a2;
    _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] Selecting active audio route for BT Address %{private}@", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    *(_DWORD *)v64 = 138477827;
    *(_QWORD *)&v64[4] = a2;
    v46 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v46);
    if (v46 != (char *)buf)
      free(v46);
  }
  v17 = (_QWORD *)sub_18F4D6638();
  if ((sub_18F4D7BF0(v17, v60) & 1) == 0)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v31 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138478083;
      v67 = a2;
      v68 = 2113;
      v69 = a3;
      _os_log_impl(&dword_18F1DC000, v31, OS_LOG_TYPE_ERROR, "[AccessoryNotifier] Warning! Spatial Audio is not supported for BT address %{private}@ with modelID %{private}@", buf, 0x16u);
    }
    if (!sub_18F1FCA08(115, 0))
      return 0;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    *(_DWORD *)v64 = 138478083;
    *(_QWORD *)&v64[4] = a2;
    *(_WORD *)&v64[12] = 2113;
    *(_QWORD *)&v64[14] = a3;
    v32 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v32);
LABEL_127:
    if (v32 != (char *)buf)
      free(v32);
    return 0;
  }
  v24 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E0C99D50], v18, (uint64_t)&v60, 6, v19);
  v25 = 0;
  v26 = MEMORY[0x1E0C809B0];
  *(_QWORD *)v64 = 0;
  *(_QWORD *)&v64[8] = v64;
  *(_QWORD *)&v64[16] = 0x2020000000;
  v65 = 0;
  do
  {
    if (v25)
    {
      if (v25 == 10)
        break;
      usleep(0x7A120u);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      v27 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67240192;
        LODWORD(v67) = v25 + 1;
        _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] selectActiveAudioRoute retry #%{public}d", buf, 8u);
      }
      v28 = sub_18F1FCA08(115, 2);
      v26 = MEMORY[0x1E0C809B0];
      if (v28)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v62 = 67240192;
        v63 = v25 + 1;
        v30 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v30);
        if (v30 != (char *)buf)
          free(v30);
      }
    }
    v29 = sub_18F204AE4();
    v59[0] = v26;
    v59[1] = 3221225472;
    v59[2] = sub_18F4A454C;
    v59[3] = &unk_1E2958E38;
    v59[5] = v64;
    v59[6] = a1;
    v59[4] = v24;
    sub_18F1F5E28(v29, (uint64_t)v59);
    ++v25;
  }
  while (!*(_QWORD *)(*(_QWORD *)&v64[8] + 24));
  v62 = 0;
  v58 = 0;
  v33 = (const char *)objc_msgSend_UTF8String(a3, v20, v21, v22, v23);
  if (sscanf(v33, "BTHeadphones%d,%d", &v62, &v58) == 2 && v62 == 76)
  {
    switch(v58)
    {
      case 8202:
      case 8223:
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v34 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v34, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is AirPods Max", buf, 2u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
          v57 = 0;
          v47 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v47);
          if (v47 != (char *)buf)
            free(v47);
          v35 = 2;
          goto LABEL_178;
        }
        v35 = 2;
        goto LABEL_115;
      case 8203:
      case 8204:
      case 8205:
      case 8207:
      case 8208:
      case 8209:
      case 8213:
      case 8214:
      case 8216:
      case 8218:
      case 8220:
      case 8221:
      case 8222:
        goto LABEL_73;
      case 8206:
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v40 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v40, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is AirPods Pro", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 2))
        {
          v35 = 1;
          goto LABEL_115;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v57 = 0;
        v52 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v52);
        if (v52 != (char *)buf)
          free(v52);
        v35 = 1;
        goto LABEL_178;
      case 8210:
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v42 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v42, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is Beats Fit Pro", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 2))
        {
          v35 = 4;
          goto LABEL_115;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v57 = 0;
        v54 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v54);
        if (v54 != (char *)buf)
          free(v54);
        v35 = 4;
        goto LABEL_178;
      case 8211:
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v38 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v38, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is AirPods (3rd generation)", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 2))
        {
          v35 = 3;
          goto LABEL_115;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v57 = 0;
        v50 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v50);
        if (v50 != (char *)buf)
          free(v50);
        v35 = 3;
        goto LABEL_178;
      case 8212:
        goto LABEL_67;
      case 8215:
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v41 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v41, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is B453", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 2))
        {
          v35 = 6;
          goto LABEL_115;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v57 = 0;
        v53 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v53);
        if (v53 != (char *)buf)
          free(v53);
        v35 = 6;
        goto LABEL_178;
      case 8217:
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v43 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v43, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is B768E", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 2))
        {
          v35 = 7;
          goto LABEL_115;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v57 = 0;
        v55 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v55);
        if (v55 != (char *)buf)
          free(v55);
        v35 = 7;
        goto LABEL_178;
      case 8219:
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v39 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v39, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is B768M", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 2))
        {
          v35 = 8;
          goto LABEL_115;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v57 = 0;
        v51 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v51);
        if (v51 != (char *)buf)
          free(v51);
        v35 = 8;
        goto LABEL_178;
      default:
        if (v58 == 8228)
        {
LABEL_67:
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
          v36 = qword_1ECEDEE30;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v36, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is AirPods Pro (2nd generation)", buf, 2u);
          }
          if (!sub_18F1FCA08(115, 2))
          {
            v35 = 5;
            goto LABEL_115;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
          v57 = 0;
          v48 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v48);
          if (v48 != (char *)buf)
            free(v48);
          v35 = 5;
        }
        else
        {
LABEL_73:
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
          v37 = qword_1ECEDEE30;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v37, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] The active audio route is unknown", buf, 2u);
          }
          if (!sub_18F1FCA08(115, 2))
          {
            v35 = 0;
            goto LABEL_115;
          }
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
          v57 = 0;
          v49 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)", "CoreLocation: %s\n", v49);
          if (v49 != (char *)buf)
            free(v49);
          v35 = 0;
        }
LABEL_178:
        v26 = MEMORY[0x1E0C809B0];
LABEL_115:
        *(_DWORD *)(a1 + 52) = v35;
        break;
    }
  }
  else
  {
    v35 = 0;
  }
  if (*(_QWORD *)(*(_QWORD *)&v64[8] + 24))
  {
    *(_DWORD *)(a1 + 48) = v35;
    *(_BYTE *)(a1 + 30) = 0;
    v44 = sub_18F204AE4();
    v56[0] = v26;
    v56[1] = 3221225472;
    v56[2] = sub_18F4A47C0;
    v56[3] = &unk_1E2955738;
    v56[4] = a1;
    sub_18F1F5E28(v44, (uint64_t)v56);
    v13 = 1;
  }
  else
  {
    v13 = 0;
  }
  _Block_object_dispose(v64, 8);
  return v13;
}

void sub_18F4A43EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a39, 8);
  _Unwind_Resume(a1);
}

void sub_18F4A4490(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  void *v10;
  const __CFString *v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD **)(a1 + 32);
  v5[11] = 0;
  v6 = v5[4];
  if (v6)
  {
    if (v5[10])
    {
      v7 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E0C99D50], a2, (uint64_t)(v5 + 10), 6, a5);
      v8 = (void *)v5[4];
      v11 = CFSTR("BT_ADDR");
      v12[0] = v7;
      v10 = (void *)objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v9, (uint64_t)v12, (uint64_t)&v11, 1);
      sub_18F1E4538(v8, v10);
    }
    else
    {

      *(_QWORD *)(v6 + 152) = 0;
    }
  }
}

void sub_18F4A454C(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  const char *v5;
  void *v6;
  uint64_t v7;
  const __CFString *v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  v2 = a1[6];
  sub_18F4A461C(v2);
  v3 = *(void **)(v2 + 32);
  v4 = a1[4];
  v8 = CFSTR("BT_ADDR");
  v9[0] = v4;
  v6 = (void *)objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v5, (uint64_t)v9, (uint64_t)&v8, 1);
  sub_18F1E4538(v3, v6);
  *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = sub_18F1FBD7C(*(_QWORD *)(v2 + 32));
  if (!*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24))
  {
    v7 = *(_QWORD *)(v2 + 32);

    *(_QWORD *)(v7 + 152) = 0;
  }
}

void sub_18F4A461C(uint64_t a1)
{
  uint64_t v1;
  int v3;
  int v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *v7;
  unint64_t v8;
  CFRunLoopTimerRef *v9;
  _QWORD *v10;
  unint64_t *v11;
  _DWORD v12[2];
  char v13;
  _DWORD v14[2];
  char v15;
  __int128 v16;

  v1 = a1 + 32;
  if (!*(_QWORD *)(a1 + 32))
  {
    sub_18F4D6638();
    v4 = *(_DWORD *)(a1 + 56);
    v3 = *(_DWORD *)(a1 + 60);
    if (*(_BYTE *)(a1 + 29))
    {
      v5 = (_QWORD *)sub_18F1E0F30();
      v14[0] = v4;
      v14[1] = v3;
      v15 = 1;
      sub_18F1E9BC8(v5, (uint64_t)v14, (uint64_t *)&v16);
      sub_18F346DC8(v1, &v16);
      v6 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
      if (*((_QWORD *)&v16 + 1))
      {
        v7 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
LABEL_10:
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }
    else
    {
      v9 = (CFRunLoopTimerRef *)operator new();
      sub_18F1E1F84(v9, 1, 1);
      *v9 = (CFRunLoopTimerRef)&off_1E294AF78;
      sub_18F3ABC8C((_QWORD *)(a1 + 64), (uint64_t)v9);
      v10 = *(_QWORD **)(a1 + 64);
      v12[0] = v4;
      v12[1] = v3;
      v13 = 1;
      sub_18F1E9BC8(v10, (uint64_t)v12, (uint64_t *)&v16);
      sub_18F346DC8(v1, &v16);
      v6 = (std::__shared_weak_count *)*((_QWORD *)&v16 + 1);
      if (*((_QWORD *)&v16 + 1))
      {
        v11 = (unint64_t *)(*((_QWORD *)&v16 + 1) + 8);
        do
          v8 = __ldaxr(v11);
        while (__stlxr(v8 - 1, v11));
        goto LABEL_10;
      }
    }
    sub_18F4D3788(*(_QWORD *)(a1 + 32), (uint64_t)sub_18F4A5250, a1);
    sub_18F4D3A58(*(_QWORD *)(a1 + 32), (uint64_t)sub_18F4A56A8, a1);
    sub_18F203148(*(_QWORD *)(a1 + 32), (uint64_t)sub_18F4A5244, a1);
  }
}

void sub_18F4A4790(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10A1C40A8081CBALL);
  _Unwind_Resume(a1);
}

void sub_18F4A47C0(uint64_t a1)
{
  uint64_t *v1;
  __IOHIDServiceClient *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint8_t buf[4];
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v1 = *(uint64_t **)(a1 + 32);
  v9 = 0;
  if (sub_18F1FBD7C(v1[4])
    && (v2 = (__IOHIDServiceClient *)sub_18F1FBD7C(v1[4]), sub_18F4E4C90(&v9, v2, CFSTR("BT_ADDR"), 6uLL)))
  {
    v3 = v1[10];
    if (v3 != v9)
    {
      if (v3)
      {
        v1[10] = 0;
        (*(void (**)(uint64_t *))(*v1 + 48))(v1);
      }
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      v4 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134283521;
        v13 = v9;
        _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] BT address of the active audio route : %{private}llx", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
        v10 = 134283521;
        v11 = v9;
        v8 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)_block_invoke", "CoreLocation: %s\n", v8);
        if (v8 != (char *)buf)
          free(v8);
      }
      v1[10] = v9;
      v5 = sub_18F4D6638();
      sub_18F4D69AC(v5, v1[10]);
      (*(void (**)(uint64_t *))(*v1 + 48))(v1);
    }
  }
  else
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v6 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_ERROR, "[AccessoryNotifier] Failed to get an updated BT address", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      LOWORD(v10) = 0;
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "BOOL CLAccessoryNotifier::selectActiveAudioRoute(NSString *, NSString *)_block_invoke", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }
  }
}

BOOL sub_18F4A4B24(const char *a1, NSObject *a2)
{
  CFRunLoopRef Current;
  __IOHIDServiceClient *v5;
  char *v6;
  int v7;
  _QWORD *v8;
  NSObject *v9;
  char *v10;
  NSObject *v12;
  NSObject *v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945228);
    v12 = off_1ECEDEE90;
    v6 = "l22MagneticAccessoryType2E";
    v5 = (__IOHIDServiceClient *)"assert";
    a1 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2082;
      v19 = "assert";
      v20 = 2081;
      v21 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLAccessoryNotifier] getConfig should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945228);
    }
    v13 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      *(_DWORD *)buf = 68289539;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2082;
      v19 = "assert";
      v20 = 2081;
      v21 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLAccessoryNotifier] getConfig should be running on motion thread", "{\"msg%{public}.0s\":\"[CLAccessoryNotifier] getConfig should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945228);
    }
    a2 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2082;
      v19 = "assert";
      v20 = 2081;
      v21 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, a2, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLAccessoryNotifier] getConfig should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
LABEL_40:
    dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    goto LABEL_13;
  }
  v5 = (__IOHIDServiceClient *)sub_18F1FBD7C(*((_QWORD *)a1 + 4));
  if (v5)
  {
    if (!sub_18F4E4568(a2, v5, CFSTR("LocationID")))
      sub_18F4E4568(a2, v5, CFSTR("SIDE"));
    sub_18F4E48BC((uint64_t)&a2[1], v5, CFSTR("CFG#"));
    sub_18F4E48BC((uint64_t)&a2[4], v5, CFSTR("SerialNumber"));
    if (*((_DWORD *)a1 + 12))
      goto LABEL_27;
    LODWORD(v6) = *(_DWORD *)(sub_18F4D6638() + 24);
    switch((int)v6)
    {
      case 8202:
      case 8223:
        v7 = 2;
        goto LABEL_26;
      case 8203:
      case 8204:
      case 8205:
      case 8207:
      case 8208:
      case 8209:
      case 8213:
      case 8214:
      case 8216:
      case 8218:
      case 8220:
      case 8221:
      case 8222:
        goto LABEL_10;
      case 8206:
        v7 = 1;
        goto LABEL_26;
      case 8210:
        v7 = 4;
        goto LABEL_26;
      case 8211:
        v7 = 3;
        goto LABEL_26;
      case 8212:
        goto LABEL_9;
      case 8215:
        v7 = 6;
        goto LABEL_26;
      case 8217:
        v7 = 7;
        goto LABEL_26;
      case 8219:
        v7 = 8;
        goto LABEL_26;
      default:
        if ((_DWORD)v6 == 8228)
        {
LABEL_9:
          v7 = 5;
LABEL_26:
          *((_DWORD *)a1 + 12) = v7;
          goto LABEL_27;
        }
LABEL_10:
        if (*((_QWORD *)a1 + 10))
          goto LABEL_27;
        v8 = (_QWORD *)sub_18F4D6638();
        if ((sub_18F4D7BF0(v8, *((_QWORD *)a1 + 10)) & 1) != 0)
          goto LABEL_27;
        if (qword_1ECEDEE38 != -1)
          goto LABEL_40;
        break;
    }
LABEL_13:
    v9 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67174657;
      v15 = (int)v6;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_ERROR, "[CLAccessoryNotifier] Warning! The connected device %{private}d might not be supported", buf, 8u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLAccessoryNotifier::refreshHardwareModel()", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
LABEL_27:
    LODWORD(a2[7].isa) = *((_DWORD *)a1 + 12);
  }
  return v5 != 0;
}

void sub_18F4A5054(uint64_t a1, int a2, unint64_t a3, unint64_t a4)
{
  NSObject *v8;
  char *v9;
  uint8_t buf[4];
  int v11;
  __int16 v12;
  unint64_t v13;
  __int16 v14;
  unint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
  v8 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67240704;
    v11 = a2;
    v12 = 2050;
    v13 = a3;
    v14 = 2050;
    v15 = a4;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "[AccessoryNotifier] numberOfClientsChanged notification:%{public}d, from:%{public}zu, to:%{public}zu", buf, 0x1Cu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v9 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLAccessoryNotifier::numberOfClientsChanged(int, size_t, size_t)", "CoreLocation: %s\n", v9);
    if (v9 != (char *)buf)
      free(v9);
  }
  if (a3 < a4)
    *(_BYTE *)(a1 + 30) = 0;
}

uint64_t sub_18F4A5244(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

void sub_18F4A5250(uint64_t a1)
{
  __IOHIDServiceClient *v2;
  __IOHIDServiceClient *v3;
  _BYTE *v4;
  NSObject *v5;
  __IOHIDServiceClient *v6;
  int v7;
  int v8;
  __IOHIDServiceClient *v9;
  int v10;
  int v11;
  char *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  const char *v21;
  void *v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  const __CFString *v26;
  uint64_t v27;
  int v28;
  __IOHIDServiceClient *v29;
  __int16 v30;
  _BYTE v31[10];
  uint64_t v32;
  uint8_t buf[4];
  __IOHIDServiceClient *v34;
  __int16 v35;
  _BYTE v36[10];
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  v2 = (__IOHIDServiceClient *)sub_18F1FBD7C(*(_QWORD *)(a1 + 32));
  if (!v2 || (v3 = v2, !sub_18F4E4C90(&v25, v2, CFSTR("BT_ADDR"), 6uLL)))
  {
LABEL_24:
    *(_DWORD *)(a1 + 48) = 0;
    v4 = (_BYTE *)(a1 + 30);
    goto LABEL_25;
  }
  if (v25 != *(_QWORD *)(a1 + 80))
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v13 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_QWORD *)(a1 + 80);
      *(_DWORD *)buf = 134284033;
      v34 = v3;
      v35 = 2049;
      *(_QWORD *)v36 = v14;
      *(_WORD *)&v36[8] = 2049;
      v37 = v25;
      _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEFAULT, "[AccessoryNotifier] onNewHidService for service %{private}p. Updating BT address from %{private}llx to %{private}llx", buf, 0x20u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      v23 = *(_QWORD *)(a1 + 80);
      v28 = 134284033;
      v29 = v3;
      v30 = 2049;
      *(_QWORD *)v31 = v23;
      *(_WORD *)&v31[8] = 2049;
      v32 = v25;
      v24 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLAccessoryNotifier::onNewHidService(void *)", "CoreLocation: %s\n", v24);
      if (v24 != (char *)buf)
        free(v24);
    }
    if (*(_QWORD *)(a1 + 80))
    {
      *(_QWORD *)(a1 + 80) = 0;
      (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    }
    *(_QWORD *)(a1 + 80) = v25;
    v15 = sub_18F4D6638();
    sub_18F4D69AC(v15, *(_QWORD *)(a1 + 80));
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    v18 = *(_QWORD *)(a1 + 88);
    if (!v18 || *(_QWORD *)(a1 + 80) == v18)
    {
      v19 = objc_msgSend_dataWithBytes_length_(MEMORY[0x1E0C99D50], v16, (uint64_t)&v25, 6, v17);
      v20 = *(void **)(a1 + 32);
      v26 = CFSTR("BT_ADDR");
      v27 = v19;
      v22 = (void *)objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v21, (uint64_t)&v27, (uint64_t)&v26, 1);
      sub_18F1E4538(v20, v22);
    }
    goto LABEL_24;
  }
  v4 = (_BYTE *)(a1 + 30);
  if (*(_BYTE *)(a1 + 30))
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
    v5 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      v6 = *(__IOHIDServiceClient **)(a1 + 80);
      v7 = *(_DWORD *)(a1 + 56);
      v8 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)buf = 134284033;
      v34 = v6;
      v35 = 1026;
      *(_DWORD *)v36 = v7;
      *(_WORD *)&v36[4] = 1026;
      *(_DWORD *)&v36[6] = v8;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_ERROR, "[AccessoryNotifier] Duplicate service with the same BT address %{private}llx for usage page %{public}d usage %{public}d", buf, 0x18u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2954168);
      v9 = *(__IOHIDServiceClient **)(a1 + 80);
      v10 = *(_DWORD *)(a1 + 56);
      v11 = *(_DWORD *)(a1 + 60);
      v28 = 134284033;
      v29 = v9;
      v30 = 1026;
      *(_DWORD *)v31 = v10;
      *(_WORD *)&v31[4] = 1026;
      *(_DWORD *)&v31[6] = v11;
      v12 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "static void CLAccessoryNotifier::onNewHidService(void *)", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf)
        free(v12);
    }
  }
LABEL_25:
  *v4 = 0;
}

void sub_18F4A56A8(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1[4];

  *(_QWORD *)(v2 + 152) = 0;
  a1[10] = 0;
  (*(void (**)(_QWORD *))(*a1 + 48))(a1);
  v3 = sub_18F4D6638();
  sub_18F4D69AC(v3, 0);
}

os_log_t sub_18F4A56F0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1ECEDEE30 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4A571C(uint64_t a1, unsigned int a2, char a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  __objc2_class *v12;
  __objc2_class *v13;
  NSObject *v14;
  signed int v15;
  NSObject *cache;
  char *v18;
  char *v19;
  _QWORD *v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 1092616192;
  *(_QWORD *)(a1 + 8) = 0x3FD3333340000000;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 17) = a3;
  *(_QWORD *)(a1 + 24) = &off_1E294A890;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = &off_1E294AC98;
  v4 = (_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 112) = &off_1E294AC98;
  v5 = (_QWORD *)(a1 + 112);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 184) = &off_1E294AC98;
  v6 = (_QWORD *)(a1 + 184);
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_QWORD *)(a1 + 256) = &off_1E294A890;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = &off_1E294AC98;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_QWORD *)(a1 + 344) = &off_1E294AC98;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_QWORD *)(a1 + 416) = &off_1E294AC98;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_QWORD *)(a1 + 488) = &off_1E294A890;
  *(_QWORD *)(a1 + 496) = 0;
  *(_QWORD *)(a1 + 504) = &off_1E294AC98;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_QWORD *)(a1 + 576) = &off_1E294AC98;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_QWORD *)(a1 + 648) = &off_1E294AC98;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_QWORD *)(a1 + 720) = &off_1E294A890;
  *(_QWORD *)(a1 + 728) = 0;
  *(_QWORD *)(a1 + 736) = &off_1E294AC98;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 760) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_QWORD *)(a1 + 808) = &off_1E294AC98;
  *(_OWORD *)(a1 + 848) = 0u;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_QWORD *)(a1 + 880) = &off_1E294AC98;
  *(_OWORD *)(a1 + 949) = 0u;
  *(_OWORD *)(a1 + 936) = 0u;
  *(_OWORD *)(a1 + 920) = 0u;
  *(_OWORD *)(a1 + 904) = 0u;
  *(_OWORD *)(a1 + 888) = 0u;
  *(_BYTE *)(a1 + 965) = 1;
  *(_QWORD *)(a1 + 968) = 0xBFF0000000000000;
  *(_QWORD *)(a1 + 976) = 0x3EE6666600000000;
  *(_DWORD *)(a1 + 984) = 7;
  *(_QWORD *)(a1 + 992) = 0xBFF0000000000000;
  *(_QWORD *)(a1 + 1000) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a1 + 1008) = _Q0;
  *(_QWORD *)(a1 + 1024) = 0x3D23D70A3C23D70ALL;
  *(_DWORD *)(a1 + 1032) = 0;
  *(_BYTE *)(a1 + 1036) = 0;
  v12 = CMVO2MaxRetrocomputeState;
  v13 = CMVO2MaxRetrocomputeState;
  *(_DWORD *)(a1 + 1040) = 0;
  if (a2 >= 2)
  {
    v20 = v4;
    *(_DWORD *)(a1 + 4) = 1103626240;
    *(_QWORD *)(a1 + 8) = 0x3FC99999A0000000;
    *(_BYTE *)(a1 + 16) = 1;
    *(_QWORD *)(a1 + 264) = 5;
    *(_QWORD *)(a1 + 280) = 5;
    sub_18F1E6174((_QWORD *)(a1 + 272));
    *(_QWORD *)(a1 + 352) = 5;
    sub_18F1E6174((_QWORD *)(a1 + 344));
    *(_QWORD *)(a1 + 424) = 5;
    v12 = CMVO2MaxRetrocomputeState;
    sub_18F1E6174((_QWORD *)(a1 + 416));
    *(_QWORD *)(a1 + 496) = 3;
    *(_QWORD *)(a1 + 512) = 3;
    sub_18F1E6174((_QWORD *)(a1 + 504));
    *(_QWORD *)(a1 + 584) = 3;
    sub_18F1E6174((_QWORD *)(a1 + 576));
    *(_QWORD *)(a1 + 656) = 3;
    sub_18F1E6174((_QWORD *)(a1 + 648));
    *(_QWORD *)(a1 + 728) = 5;
    *(_QWORD *)(a1 + 744) = 5;
    sub_18F1E6174((_QWORD *)(a1 + 736));
    *(_QWORD *)(a1 + 816) = 5;
    sub_18F1E6174((_QWORD *)(a1 + 808));
    *(_QWORD *)(a1 + 888) = 5;
    sub_18F1E6174((_QWORD *)(a1 + 880));
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v13 = CMVO2MaxRetrocomputeState;
    v14 = off_1ECEDEE20;
    v6 = (_QWORD *)(a1 + 184);
    v5 = (_QWORD *)(a1 + 112);
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134219008;
      v22 = 0x4034000000000000;
      v23 = 1024;
      v24 = 5;
      v25 = 1024;
      v26 = 3;
      v27 = 1024;
      v28 = 5;
      v29 = 1024;
      v30 = 3;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_DEBUG, "gyroFrequency,%.3f,gyroBufferSize,%d,gyroMeanBufferSize,%d,zRotBufferSize,%d,minRequiredZrots,%d", buf, 0x24u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v19 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "CLOrientationDetector::CLOrientationDetector(FormFactor, BOOL)", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf)
        free(v19);
    }
    *(float *)(a1 + 1024) = *(float *)(a1 + 1024) * 0.8;
    *(_DWORD *)(a1 + 1028) = 1023745720;
    v4 = v20;
  }
  v15 = llround(*(double *)(a1 + 8) * *(float *)(a1 + 4));
  *(_QWORD *)(a1 + 32) = v15;
  *(_QWORD *)(a1 + 48) = v15;
  sub_18F1E6174(v4);
  *(_QWORD *)(a1 + 120) = v15;
  sub_18F1E6174(v5);
  *(_QWORD *)(a1 + 192) = v15;
  sub_18F1E6174(v6);
  if (v12[90].vtable != (void *)-1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
  cache = v13[90].cache;
  if (os_log_type_enabled(cache, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v22) = v15;
    _os_log_impl(&dword_18F1DC000, cache, OS_LOG_TYPE_DEBUG, "accelBufferSize,%d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (v12[90].vtable != (void *)-1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v18 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLOrientationDetector::CLOrientationDetector(FormFactor, BOOL)", "CoreLocation: %s\n", v18);
    if (v18 != (char *)buf)
      free(v18);
  }
  return a1;
}

void sub_18F4A5D2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, _QWORD *a17, _QWORD *a18)
{
  _QWORD *v18;
  _QWORD *v19;

  sub_18F1EB0F0(v19);
  sub_18F1EB0F0(a17);
  sub_18F1EB0F0(v18);
  sub_18F1EB0F0(a18);
  _Unwind_Resume(a1);
}

void sub_18F4A5D64(uint64_t a1, float *a2, _QWORD *a3)
{
  double v6;
  NSObject *v7;
  double v8;
  double v9;
  double v10;
  uint64_t v11;
  NSObject *v12;
  double v13;
  char *v14;
  char *v15;
  uint8_t buf[4];
  double v17;
  __int16 v18;
  double v19;
  __int16 v20;
  double v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = *(double *)(a1 + 1008);
  if (v6 < 0.0 || *(double *)a3 >= v6 && *(double *)a3 - v6 <= 2.0 / *(float *)(a1 + 4))
  {
    sub_18F1FD65C(a1 + 40, a2);
    sub_18F1FD65C(a1 + 112, a2 + 1);
    sub_18F1FD65C(a1 + 184, a2 + 2);
    *(_QWORD *)(a1 + 1008) = *a3;
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v7 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
    {
      v8 = *a2;
      v9 = a2[1];
      v10 = a2[2];
      v11 = *a3;
      *(_DWORD *)buf = 134218752;
      v17 = v8;
      v18 = 2048;
      v19 = v9;
      v20 = 2048;
      v21 = v10;
      v22 = 2048;
      v23 = v11;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEBUG, "accel, %.3f, %.3f, %.3f, timestamp, %.20f", buf, 0x2Au);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::addAccSample(const CLMotionTypeAcceleration &, const CFAbsoluteTime &)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
    }
    if (*(_BYTE *)(a1 + 965))
      *(_QWORD *)(a1 + 968) = *a3;
  }
  else
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v12 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(double *)a3 - *(double *)(a1 + 1008);
      *(_DWORD *)buf = 134349056;
      v17 = v13;
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_DEFAULT, "Accelerometer samples data gap or out of order! deltaInterval=%{public}.4f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v15 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::addAccSample(const CLMotionTypeAcceleration &, const CFAbsoluteTime &)", "CoreLocation: %s\n", v15);
      if (v15 != (char *)buf)
        free(v15);
    }
    sub_18F1E6174((_QWORD *)(a1 + 40));
    sub_18F1E6174((_QWORD *)(a1 + 112));
    sub_18F1E6174((_QWORD *)(a1 + 184));
    *(_QWORD *)(a1 + 1008) = 0xBFF0000000000000;
  }
}

void sub_18F4A6180(uint64_t a1, float *a2, double *a3)
{
  double v6;
  double v7;
  NSObject *v9;
  double v10;
  double v11;
  float *v12;
  unint64_t v13;
  float v14;
  float v15;
  unint64_t v16;
  unint64_t v17;
  float v18;
  int v19;
  float v20;
  float v21;
  float v22;
  NSObject *v23;
  unint64_t v24;
  double v25;
  double v26;
  unint64_t v27;
  unint64_t v28;
  double v29;
  double v30;
  float v31;
  double v32;
  double v33;
  float v34;
  double v35;
  float v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  float v44;
  char *v45;
  NSObject *v46;
  double v47;
  double v48;
  double v49;
  int v50;
  int v51;
  double v52;
  uint64_t v53;
  float v54;
  float v55;
  uint64_t v56;
  uint64_t v57;
  float v58;
  unint64_t v59;
  float v60;
  float v61;
  unint64_t v62;
  unint64_t v63;
  float v64;
  float v65;
  float v66;
  NSObject *v67;
  float v68;
  float v69;
  float v70;
  float v71;
  int v72;
  BOOL v73;
  int v74;
  NSObject *v75;
  char *v76;
  unint64_t v77;
  float v78;
  float v79;
  float v80;
  float v81;
  BOOL v82;
  BOOL v83;
  float v84;
  float v85;
  unint64_t v86;
  float v87;
  NSObject *v88;
  char *v89;
  NSObject *v90;
  float v91;
  float v92;
  int v93;
  NSObject *v95;
  int v96;
  NSObject *v98;
  int v99;
  float v100;
  float v101;
  unint64_t v102;
  unint64_t v103;
  float v104;
  float v105;
  float v106;
  _BOOL4 v107;
  float v108;
  float v109;
  NSObject *v110;
  int v111;
  BOOL v112;
  _BOOL4 v113;
  int v114;
  float v115;
  NSObject *v116;
  float v117;
  float v118;
  float v119;
  NSObject *v121;
  int v122;
  unint64_t v123;
  double v124;
  float v125;
  double v126;
  double v127;
  double v128;
  int v129;
  int v130;
  double v131;
  char *v132;
  char *v133;
  double v134;
  char *v135;
  int v136;
  char *v137;
  int v138;
  char *v139;
  int v140;
  char *v141;
  int v142;
  char *v143;
  float v144;
  float v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  _BYTE v154[16];
  float v155;
  _BYTE v156[12];
  float v157;
  _BYTE v158[8];
  float v159;
  _BYTE v160[16];
  float v161;
  _BYTE v162[12];
  float v163;
  float v164;
  _BYTE v165[8];
  float v166;
  int v167;
  _BYTE v168[30];
  _BYTE v169[10];
  _BYTE v170[10];
  _BYTE v171[10];
  _BYTE v172[10];
  _BYTE v173[10];
  double v174;
  uint8_t buf[4];
  _BYTE v176[30];
  _BYTE v177[10];
  _BYTE v178[10];
  _BYTE v179[10];
  _BYTE v180[10];
  _BYTE v181[10];
  double v182;
  uint64_t v183;

  v183 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 16))
  {
    v6 = *(double *)(a1 + 1016);
    if (v6 < 0.0)
    {
      sub_18F1FD65C(a1 + 272, a2);
      sub_18F1FD65C(a1 + 344, a2 + 1);
      sub_18F1FD65C(a1 + 416, a2 + 2);
LABEL_62:
      *(_WORD *)(a1 + 963) = 0;
      v53 = *(_QWORD *)(a1 + 336);
      v54 = 0.0;
      v55 = 0.0;
      if (v53)
        v55 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 304)
                                   + (((unint64_t)(v53 + *(_QWORD *)(a1 + 328) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                       + 4 * ((v53 + *(_QWORD *)(a1 + 328) - 1) & 0x3FF));
      v56 = *(_QWORD *)(a1 + 408);
      if (v56)
        v54 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 376)
                                   + (((unint64_t)(v56 + *(_QWORD *)(a1 + 400) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                       + 4 * ((v56 + *(_QWORD *)(a1 + 400) - 1) & 0x3FF));
      v57 = *(_QWORD *)(a1 + 480);
      if (v57)
        v58 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 448)
                                   + (((unint64_t)(v57 + *(_QWORD *)(a1 + 472) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                       + 4 * ((v57 + *(_QWORD *)(a1 + 472) - 1) & 0x3FF));
      else
        v58 = 0.0;
      if (!*(_BYTE *)(a1 + 960))
        goto LABEL_84;
      v59 = *(_QWORD *)(a1 + 104);
      v60 = 0.0;
      v61 = 0.0;
      if (v59)
        v61 = *(float *)(a1 + 56) / (float)v59;
      v62 = *(_QWORD *)(a1 + 176);
      if (v62)
        v60 = *(float *)(a1 + 128) / (float)v62;
      v63 = *(_QWORD *)(a1 + 248);
      if (v63)
        v64 = *(float *)(a1 + 200) / (float)v63;
      else
        v64 = 0.0;
      v65 = (float)((float)((float)(v60 * v60) + (float)(v61 * v61)) + (float)(v64 * v64)) + -1.0;
      v66 = fabsf(v65);
      if (v66 < 0.3 && fabsf(v64) > 0.9)
      {
        sub_18F4A7F68(a1, 1);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v67 = off_1ECEDEE20;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v67, OS_LOG_TYPE_DEBUG, "SCREEN FLAT. NOT FILLING UP ZROT BUFFER.", buf, 2u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
          LOWORD(v167) = 0;
          v133 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::checkForRotation()", "CoreLocation: %s\n", v133);
          if (v133 != (char *)buf)
            free(v133);
        }
        goto LABEL_84;
      }
      v77 = *(_QWORD *)(a1 + 800);
      if (v77)
        v78 = *(float *)(a1 + 752) / (float)v77;
      else
        v78 = 0.0;
      v79 = (float)(v58 / 20.0) + *(float *)(a1 + 956);
      *(float *)(a1 + 956) = v79;
      v80 = fabsf(v79);
      v81 = 2.0;
      if (v80 > 75.0)
        v81 = 15.0;
      v82 = v58 >= v81 && v78 < -30.0;
      if (v82 || (v58 <= (float)-v81 ? (v83 = v78 <= 30.0) : (v83 = 1), !v83))
      {
        sub_18F4A7F68(a1, 1);
        *(_BYTE *)(a1 + 964) = 1;
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v90 = off_1ECEDEE20;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v90, OS_LOG_TYPE_DEBUG, "Transient!", buf, 2u);
        }
        if (!sub_18F1FCA08(115, 2))
          goto LABEL_135;
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        LOWORD(v167) = 0;
        v76 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::checkForRotation()", "CoreLocation: %s\n", v76);
        goto LABEL_245;
      }
      v84 = 0.0;
      v85 = 0.0;
      if (v77)
        v85 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 768)
                                   + (((v77 + *(_QWORD *)(a1 + 792) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                       + 4 * ((v77 + *(_QWORD *)(a1 + 792) - 1) & 0x3FF));
      if (v57)
        v84 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 448)
                                   + (((unint64_t)(v57 + *(_QWORD *)(a1 + 472) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                       + 4 * ((v57 + *(_QWORD *)(a1 + 472) - 1) & 0x3FF));
      v148 = v85;
      if ((int)v53 >= 2 && v80 <= 65.0)
      {
        v86 = *(_QWORD *)(a1 + 472) + (v53 - 2);
        v87 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 448) + ((v86 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v86 & 0x3FF));
        if ((float)(v84 * v87) < 0.0)
        {
          sub_18F4A7F68(a1, 1);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
          v88 = off_1ECEDEE20;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v88, OS_LOG_TYPE_DEBUG, "Likely transient.", buf, 2u);
          }
          if (!sub_18F1FCA08(115, 2))
            goto LABEL_198;
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 == -1)
          {
LABEL_128:
            LOWORD(v167) = 0;
            v89 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::updateZRotationStatus(float, float, float)", "CoreLocation: %s\n", v89);
            if (v89 != (char *)buf)
              free(v89);
LABEL_198:
            *(_BYTE *)(a1 + 963) = 0;
LABEL_84:
            v68 = fabsf(v55);
            v69 = fabsf(v54);
            v70 = fabsf(v58);
            if (v68 < v69)
              v68 = v69;
            if (v68 >= v70)
              v71 = v68;
            else
              v71 = v70;
            if (v71 <= 60.0)
              goto LABEL_135;
            *(_BYTE *)(a1 + 964) = 1;
            if (v71 > 195.0)
            {
              v72 = *(_DWORD *)(a1 + 976);
              v73 = __OFSUB__(v72, 1);
              v74 = v72 - 1;
              if (v74 < 0 == v73)
                *(_DWORD *)(a1 + 976) = v74;
            }
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
            v75 = off_1ECEDEE20;
            if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
            {
              *(float *)buf = 3.852e-34;
              *(double *)v176 = v71;
              _os_log_impl(&dword_18F1DC000, v75, OS_LOG_TYPE_DEBUG, "Rotating! Current max gyro rate %.3f", buf, 0xCu);
            }
            if (!sub_18F1FCA08(115, 2))
              goto LABEL_135;
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
            v167 = 134217984;
            *(double *)v168 = v71;
            v76 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::checkForRotation()", "CoreLocation: %s\n", v76);
LABEL_245:
            if (v76 != (char *)buf)
              free(v76);
LABEL_135:
            v11 = *a3;
            goto LABEL_136;
          }
LABEL_263:
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
          goto LABEL_128;
        }
        v91 = fabsf(v87) - fabsf(v84);
        v92 = 0.0;
        if (v79 > 45.0)
          v92 = 1.0;
        v146 = v91 + (float)(v92 * -5.0);
        if (v146 > 15.0)
        {
          ++*(_DWORD *)(a1 + 1032);
          v93 = *(_DWORD *)(a1 + 952);
          if (v93 >= 1)
          {
            *(_DWORD *)(a1 + 952) = v93 - 1;
            if (v146 > 30.0 && v93 != 1)
            {
              *(_DWORD *)(a1 + 952) = v93 - 2;
              *(float *)(a1 + 956) = v79 * 0.8;
            }
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
            v95 = off_1ECEDEE20;
            if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
            {
              v96 = *(_DWORD *)(a1 + 952);
              *(float *)buf = 3.8521e-34;
              *(double *)v176 = v146;
              *(_WORD *)&v176[8] = 1024;
              *(_DWORD *)&v176[10] = v96;
              _os_log_impl(&dword_18F1DC000, v95, OS_LOG_TYPE_DEBUG, "Slowing. decrement numZRot,delta, %.3f, numZRot, %d", buf, 0x12u);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE28 != -1)
                dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
              v140 = *(_DWORD *)(a1 + 952);
              v167 = 134218240;
              *(double *)v168 = v146;
              *(_WORD *)&v168[8] = 1024;
              *(_DWORD *)&v168[10] = v140;
              v141 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::updateZRotationStatus(float, float, float)", "CoreLocation: %s\n", v141);
              if (v141 != (char *)buf)
                free(v141);
            }
          }
          if (v146 > 50.0 || *(_DWORD *)(a1 + 1032) > 3)
          {
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
            v98 = off_1ECEDEE20;
            if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
            {
              v99 = *(_DWORD *)(a1 + 1032);
              *(float *)buf = 3.8521e-34;
              *(double *)v176 = v146;
              *(_WORD *)&v176[8] = 1024;
              *(_DWORD *)&v176[10] = v99;
              _os_log_impl(&dword_18F1DC000, v98, OS_LOG_TYPE_DEBUG, "ZDROP detected. deltaDrop, %.3f, fNumZDrops, %d", buf, 0x12u);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE28 != -1)
                dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
              v142 = *(_DWORD *)(a1 + 1032);
              v167 = 134218240;
              *(double *)v168 = v146;
              *(_WORD *)&v168[8] = 1024;
              *(_DWORD *)&v168[10] = v142;
              v143 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::updateZRotationStatus(float, float, float)", "CoreLocation: %s\n", v143);
              if (v143 != (char *)buf)
                free(v143);
            }
            sub_18F4A7F68(a1, 0);
            goto LABEL_198;
          }
          v77 = *(_QWORD *)(a1 + 800);
        }
      }
      v100 = 0.0;
      v101 = 0.0;
      if (v77)
        v101 = *(float *)(a1 + 752) / (float)v77;
      v102 = *(_QWORD *)(a1 + 872);
      if (v102)
        v100 = *(float *)(a1 + 824) / (float)v102;
      v103 = *(_QWORD *)(a1 + 944);
      v104 = 0.0;
      v105 = 0.0;
      if (v103)
        v105 = *(float *)(a1 + 896) / (float)v103;
      if (v102)
        v104 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 840)
                                    + (((v102 + *(_QWORD *)(a1 + 864) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                        + 4 * ((v102 + *(_QWORD *)(a1 + 864) - 1) & 0x3FF));
      v145 = v84;
      if (v105 >= 90.0)
        goto LABEL_181;
      v106 = (float)(v104 * 0.4) + (float)(v100 * 0.6);
      if ((float)(v106 - v105) > 60.0
        || v102
        && *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 840)
                                + (((v102 + *(_QWORD *)(a1 + 864) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                    + 4 * ((v102 + *(_QWORD *)(a1 + 864) - 1) & 0x3FF)) > 135.0)
      {
        v107 = 1;
        goto LABEL_182;
      }
      if (v103 >= 2
        && (v108 = (float)((float)v103 * *(float *)(a1 + 900)) - (float)(*(float *)(a1 + 896) * *(float *)(a1 + 896)),
            v108 >= 0.0)
        && (float)(v108 / (float)((v103 - 1) * v103)) >= 400.0)
      {
LABEL_181:
        v107 = 0;
      }
      else
      {
        v107 = v106 > (float)(v105 * 1.05);
      }
LABEL_182:
      v109 = (float)(v58 + v148) * 0.5;
      v144 = v105;
      if (qword_1ECEDEE28 != -1)
      {
        v150 = v101;
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v101 = v150;
      }
      v147 = fabsf(v101);
      v149 = fabsf(v109);
      v110 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
      {
        v111 = *(_DWORD *)(a1 + 952);
        *(float *)buf = 1.505e-36;
        *(_DWORD *)v176 = v107;
        *(_WORD *)&v176[4] = 2048;
        *(double *)&v176[6] = v144;
        *(_WORD *)&v176[14] = 2048;
        *(double *)&v176[16] = v147;
        *(_WORD *)&v176[24] = 1024;
        *(_DWORD *)&v176[26] = v111;
        *(_WORD *)v177 = 2048;
        *(double *)&v177[2] = v149;
        *(_WORD *)v178 = 2048;
        *(double *)&v178[2] = v80;
        *(_WORD *)v179 = 2048;
        *(double *)&v179[2] = v65;
        _os_log_impl(&dword_18F1DC000, v110, OS_LOG_TYPE_DEBUG, "mostlyZ, %d, zRotMean.z, %.3f, zRot, %.3f, numZRots, %d, estCurr, %.3f, totalZ, %.2f, mag2MinusGrav, %.2f", buf, 0x40u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v136 = *(_DWORD *)(a1 + 952);
        v167 = 67110656;
        *(_DWORD *)v168 = v107;
        *(_WORD *)&v168[4] = 2048;
        *(double *)&v168[6] = v144;
        *(_WORD *)&v168[14] = 2048;
        *(double *)&v168[16] = v147;
        *(_WORD *)&v168[24] = 1024;
        *(_DWORD *)&v168[26] = v136;
        *(_WORD *)v169 = 2048;
        *(double *)&v169[2] = v149;
        *(_WORD *)v170 = 2048;
        *(double *)&v170[2] = v80;
        *(_WORD *)v171 = 2048;
        *(double *)&v171[2] = v65;
        v137 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::updateZRotationStatus(float, float, float)", "CoreLocation: %s\n", v137);
        if (v137 != (char *)buf)
          free(v137);
      }
      if (v65 >= 0.25 || v65 <= -0.85 || !v107)
        goto LABEL_198;
      v112 = v147 <= 45.0 || (int)v77 <= 1;
      v113 = !v112;
      if (v149 <= 150.0 && !v113)
        goto LABEL_198;
      v114 = *(_DWORD *)(a1 + 952) + 1;
      *(_DWORD *)(a1 + 952) = v114;
      if (v80 <= 65.0)
      {
        v117 = 0.0;
        if (v66 <= 0.3)
          v118 = 0.0;
        else
          v118 = 1.0;
        if (v66 > 0.1)
          v117 = 1.0;
        v119 = (float)((float)(v117 * 5.0) + 35.0) + (float)(v118 * 10.0);
        if (v114 >= (int)v77)
          v114 = v77;
        if (v119 >= v80 || v114 <= 3)
          goto LABEL_198;
      }
      else
      {
        v115 = 255.0;
        if (v80 > 100.0)
          v115 = 225.0;
        if (fabsf(v145) > v115)
        {
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
          v116 = off_1ECEDEE20;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v116, OS_LOG_TYPE_DEBUG, "Going through with 180 turn.", buf, 2u);
          }
          if (!sub_18F1FCA08(115, 2))
            goto LABEL_198;
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 == -1)
            goto LABEL_128;
          goto LABEL_263;
        }
      }
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v121 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
      {
        v122 = *(_DWORD *)(a1 + 952);
        v123 = *(_QWORD *)(a1 + 800);
        v124 = 0.0;
        if (v123 >= 2)
        {
          v125 = (float)((float)v123 * *(float *)(a1 + 756)) - (float)(*(float *)(a1 + 752) * *(float *)(a1 + 752));
          if (v125 >= 0.0)
            v124 = (float)(v125 / (float)((v123 - 1) * v123));
        }
        *(float *)buf = 1.5048e-36;
        *(_DWORD *)v176 = v77;
        *(_WORD *)&v176[4] = 1024;
        *(_DWORD *)&v176[6] = v122;
        *(_WORD *)&v176[10] = 2048;
        *(double *)&v176[12] = v124;
        _os_log_impl(&dword_18F1DC000, v121, OS_LOG_TYPE_DEBUG, "Rotating around Z. numSamples: %d, numAccu, %d, zRotVar, %.3f", buf, 0x18u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v138 = *(_DWORD *)(a1 + 952);
        sub_18F4A7EA4((uint64_t)v165, a1 + 720);
        v167 = 67109632;
        *(_DWORD *)v168 = v77;
        *(_WORD *)&v168[4] = 1024;
        *(_DWORD *)&v168[6] = v138;
        *(_WORD *)&v168[10] = 2048;
        *(double *)&v168[12] = v166;
        v139 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::updateZRotationStatus(float, float, float)", "CoreLocation: %s\n", v139);
        if (v139 != (char *)buf)
          free(v139);
      }
      *(_BYTE *)(a1 + 963) = 1;
      goto LABEL_135;
    }
    v7 = *a3 - v6;
    if (v7 < 0.0 || v7 * 20.0 > 2.5)
    {
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v9 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
      {
        v10 = *a3 - *(double *)(a1 + 1016);
        *(float *)buf = 3.9122e-34;
        *(double *)v176 = v10;
        _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEFAULT, "Gyro samples data gap or out of order! deltaInterval=%{public}.4f", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v134 = *a3 - *(double *)(a1 + 1016);
        v167 = 134349056;
        *(double *)v168 = v134;
        v135 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::addGyroSample(const CLMotionTypeRotationRate &, const CFAbsoluteTime &)", "CoreLocation: %s\n", v135);
        if (v135 != (char *)buf)
          free(v135);
      }
      if (fabs(v7) * 20.0 > 4.0)
      {
        sub_18F1E6174((_QWORD *)(a1 + 272));
        sub_18F1E6174((_QWORD *)(a1 + 344));
        sub_18F1E6174((_QWORD *)(a1 + 416));
        v11 = -1.0;
LABEL_136:
        *(double *)(a1 + 1016) = v11;
        return;
      }
      if (v7 < 0.0)
        return;
    }
    sub_18F1FD65C(a1 + 272, a2);
    sub_18F1FD65C(a1 + 344, a2 + 1);
    v12 = a2 + 2;
    sub_18F1FD65C(a1 + 416, a2 + 2);
    v13 = *(_QWORD *)(a1 + 336);
    v14 = 0.0;
    v15 = 0.0;
    if (v13)
      v15 = *(float *)(a1 + 288) / (float)v13;
    v16 = *(_QWORD *)(a1 + 408);
    if (v16)
      v14 = *(float *)(a1 + 360) / (float)v16;
    v17 = *(_QWORD *)(a1 + 480);
    if (v17)
      v18 = *(float *)(a1 + 432) / (float)v17;
    else
      v18 = 0.0;
    v151 = v15;
    v152 = v14;
    v153 = v18;
    sub_18F1FD65C(a1 + 504, &v151);
    sub_18F1FD65C(a1 + 576, &v152);
    sub_18F1FD65C(a1 + 648, &v153);
    v19 = *(unsigned __int8 *)(a1 + 960);
    if (*(_BYTE *)(a1 + 960) || *(_DWORD *)(a1 + 1004))
    {
      v20 = fabsf(v151);
      v21 = fabsf(v152);
      if (v20 < v21)
        v20 = v21;
      v164 = v20;
      v22 = fabsf(v153);
      if (v19)
      {
        *(float *)buf = v22 - v20;
        sub_18F1FD65C(a1 + 736, &v153);
        sub_18F1FD65C(a1 + 808, (float *)buf);
        sub_18F1FD65C(a1 + 880, &v164);
        if (*(_BYTE *)(a1 + 960))
        {
LABEL_29:
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
          v23 = off_1ECEDEE20;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
          {
            v24 = *(_QWORD *)(a1 + 800);
            v25 = 0.0;
            v26 = 0.0;
            if (v24)
              v26 = (float)(*(float *)(a1 + 752) / (float)v24);
            v27 = *(_QWORD *)(a1 + 872);
            v28 = *(_QWORD *)(a1 + 944);
            if (v27)
              v25 = (float)(*(float *)(a1 + 824) / (float)v27);
            v29 = 0.0;
            v30 = 0.0;
            if (v28)
              v30 = (float)(*(float *)(a1 + 896) / (float)v28);
            if (v24 >= 2)
            {
              v31 = (float)((float)v24 * *(float *)(a1 + 756)) - (float)(*(float *)(a1 + 752) * *(float *)(a1 + 752));
              if (v31 >= 0.0)
                v29 = (float)(v31 / (float)((v24 - 1) * v24));
            }
            v32 = 0.0;
            v33 = 0.0;
            if (v27 >= 2)
            {
              v34 = (float)((float)v27 * *(float *)(a1 + 828)) - (float)(*(float *)(a1 + 824) * *(float *)(a1 + 824));
              v33 = 0.0;
              if (v34 >= 0.0)
                v33 = (float)(v34 / (float)((v27 - 1) * v27));
            }
            v35 = *v12;
            if (v28 >= 2)
            {
              v36 = (float)((float)v28 * *(float *)(a1 + 900)) - (float)(*(float *)(a1 + 896) * *(float *)(a1 + 896));
              if (v36 >= 0.0)
                v32 = (float)(v36 / (float)((v28 - 1) * v28));
            }
            *(float *)buf = 3.8529e-34;
            *(double *)v176 = v35;
            *(_WORD *)&v176[8] = 2048;
            *(double *)&v176[10] = (float)(v22 - v164);
            *(_WORD *)&v176[18] = 2048;
            *(double *)&v176[20] = v164;
            *(_WORD *)&v176[28] = 2048;
            *(double *)v177 = v26;
            *(_WORD *)&v177[8] = 2048;
            *(double *)v178 = v25;
            *(_WORD *)&v178[8] = 2048;
            *(double *)v179 = v30;
            *(_WORD *)&v179[8] = 2048;
            *(double *)v180 = v29;
            *(_WORD *)&v180[8] = 2048;
            *(double *)v181 = v33;
            *(_WORD *)&v181[8] = 2048;
            v182 = v32;
            _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_DEBUG, "zRot (%.3f, %.3f, %.3f), mean(%.3f, %.3f, %.3f), var(%.3f, %.3f, %.3f)", buf, 0x5Cu);
          }
          if (sub_18F1FCA08(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
            v37 = *v12;
            v38 = (float)(v22 - v164);
            v39 = v164;
            sub_18F4A7E40((uint64_t)v165, a1 + 720);
            v40 = v166;
            sub_18F4A7E40((uint64_t)v162, a1 + 720);
            v41 = v163;
            sub_18F4A7E40((uint64_t)v160, a1 + 720);
            v42 = v161;
            sub_18F4A7EA4((uint64_t)v158, a1 + 720);
            v43 = v159;
            sub_18F4A7EA4((uint64_t)v156, a1 + 720);
            v44 = v157;
            sub_18F4A7EA4((uint64_t)v154, a1 + 720);
            v167 = 134220032;
            *(double *)v168 = v37;
            *(_WORD *)&v168[8] = 2048;
            *(double *)&v168[10] = v38;
            *(_WORD *)&v168[18] = 2048;
            *(double *)&v168[20] = v39;
            *(_WORD *)&v168[28] = 2048;
            *(double *)v169 = v40;
            *(_WORD *)&v169[8] = 2048;
            *(double *)v170 = v41;
            *(_WORD *)&v170[8] = 2048;
            *(double *)v171 = v42;
            *(_WORD *)&v171[8] = 2048;
            *(double *)v172 = v43;
            *(_WORD *)&v172[8] = 2048;
            *(double *)v173 = v44;
            *(_WORD *)&v173[8] = 2048;
            v174 = v155;
            v45 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::fillZRotBuffer(const CLMotionTypeRotationRate &, const CLVector3d<float> &)", "CoreLocation: %s\n", v45);
            if (v45 != (char *)buf)
              free(v45);
          }
        }
      }
      else if (v20 < 90.0
             && fabsf((float)(v153 + *v12) * 0.5) > (float)((float)(v20 + 30.0) * 1.25)
             && (v22 > 45.0 || fabsf(*v12) > 75.0))
      {
        *(float *)buf = v22 - v20;
        sub_18F1FD65C(a1 + 736, &v153);
        sub_18F1FD65C(a1 + 808, (float *)buf);
        sub_18F1FD65C(a1 + 880, &v164);
        *(_BYTE *)(a1 + 960) = 1;
        *(_QWORD *)(a1 + 952) = (*(_DWORD *)(a1 + 952) + 1);
        *(_DWORD *)(a1 + 1032) = 0;
        goto LABEL_29;
      }
    }
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v46 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
    {
      v47 = *a2;
      v48 = a2[1];
      v49 = a2[2];
      v50 = *(_DWORD *)(a1 + 1004);
      v51 = *(unsigned __int8 *)(a1 + 960);
      v52 = *a3;
      *(float *)buf = 3.8529e-34;
      *(double *)v176 = v47;
      *(_WORD *)&v176[8] = 2048;
      *(double *)&v176[10] = v48;
      *(_WORD *)&v176[18] = 2048;
      *(double *)&v176[20] = v49;
      *(_WORD *)&v176[28] = 2048;
      *(double *)v177 = v151;
      *(_WORD *)&v177[8] = 2048;
      *(double *)v178 = v152;
      *(_WORD *)&v178[8] = 2048;
      *(double *)v179 = v153;
      *(_WORD *)&v179[8] = 1024;
      *(_DWORD *)v180 = v50;
      *(_WORD *)&v180[4] = 1024;
      *(_DWORD *)&v180[6] = v51;
      *(_WORD *)v181 = 2048;
      *(double *)&v181[2] = v52;
      _os_log_impl(&dword_18F1DC000, v46, OS_LOG_TYPE_DEBUG, "gyro, %.3f, %.3f, %.3f, gyroMean, %.3f, %.3f, %.3f, fLastDetection,%d,fStartZrot,%d, timestamp, %.10f", buf, 0x54u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v126 = *a2;
      v127 = a2[1];
      v128 = a2[2];
      v129 = *(_DWORD *)(a1 + 1004);
      v130 = *(unsigned __int8 *)(a1 + 960);
      v131 = *a3;
      v167 = 134220032;
      *(double *)v168 = v126;
      *(_WORD *)&v168[8] = 2048;
      *(double *)&v168[10] = v127;
      *(_WORD *)&v168[18] = 2048;
      *(double *)&v168[20] = v128;
      *(_WORD *)&v168[28] = 2048;
      *(double *)v169 = v151;
      *(_WORD *)&v169[8] = 2048;
      *(double *)v170 = v152;
      *(_WORD *)&v170[8] = 2048;
      *(double *)v171 = v153;
      *(_WORD *)&v171[8] = 1024;
      *(_DWORD *)v172 = v129;
      *(_WORD *)&v172[4] = 1024;
      *(_DWORD *)&v172[6] = v130;
      *(_WORD *)v173 = 2048;
      *(double *)&v173[2] = v131;
      v132 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::addGyroSample(const CLMotionTypeRotationRate &, const CFAbsoluteTime &)", "CoreLocation: %s\n", v132);
      if (v132 != (char *)buf)
        free(v132);
    }
    goto LABEL_62;
  }
}

uint64_t sub_18F4A7E40(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  float v3;
  float v4;
  unint64_t v5;
  unint64_t v6;
  float v7;

  v2 = *(_QWORD *)(a2 + 80);
  v3 = 0.0;
  v4 = 0.0;
  if (v2)
    v4 = *(float *)(a2 + 32) / (float)v2;
  v5 = *(_QWORD *)(a2 + 152);
  if (v5)
    v3 = *(float *)(a2 + 104) / (float)v5;
  v6 = *(_QWORD *)(a2 + 224);
  if (v6)
    v7 = *(float *)(a2 + 176) / (float)v6;
  else
    v7 = 0.0;
  *(_QWORD *)result = &off_1E2949650;
  *(float *)(result + 8) = v4;
  *(float *)(result + 12) = v3;
  *(float *)(result + 16) = v7;
  return result;
}

uint64_t sub_18F4A7EA4(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  float v3;
  float v4;
  float v5;
  unint64_t v6;
  float v7;
  unint64_t v8;
  float v9;
  float v10;

  v2 = *(_QWORD *)(a2 + 80);
  v3 = 0.0;
  v4 = 0.0;
  if (v2 >= 2)
  {
    v5 = (float)((float)v2 * *(float *)(a2 + 36)) - (float)(*(float *)(a2 + 32) * *(float *)(a2 + 32));
    v4 = 0.0;
    if (v5 >= 0.0)
      v4 = v5 / (float)((v2 - 1) * v2);
  }
  v6 = *(_QWORD *)(a2 + 152);
  if (v6 >= 2)
  {
    v7 = (float)((float)v6 * *(float *)(a2 + 108)) - (float)(*(float *)(a2 + 104) * *(float *)(a2 + 104));
    if (v7 >= 0.0)
      v3 = v7 / (float)((v6 - 1) * v6);
  }
  v8 = *(_QWORD *)(a2 + 224);
  v9 = 0.0;
  if (v8 >= 2)
  {
    v10 = (float)((float)v8 * *(float *)(a2 + 180)) - (float)(*(float *)(a2 + 176) * *(float *)(a2 + 176));
    if (v10 >= 0.0)
      v9 = v10 / (float)((v8 - 1) * v8);
  }
  *(_QWORD *)result = &off_1E2949650;
  *(float *)(result + 8) = v4;
  *(float *)(result + 12) = v3;
  *(float *)(result + 16) = v9;
  return result;
}

void sub_18F4A7F68(uint64_t a1, int a2)
{
  if (a2)
    *(_BYTE *)(a1 + 960) = 0;
  *(_QWORD *)(a1 + 952) = 0;
  *(_DWORD *)(a1 + 1032) = 0;
  sub_18F1E6174((_QWORD *)(a1 + 736));
  sub_18F1E6174((_QWORD *)(a1 + 808));
  sub_18F1E6174((_QWORD *)(a1 + 880));
}

uint64_t sub_18F4A7FA8(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v2 = a2[10];
  v3 = 0;
  v4 = 0;
  if (v2)
    v4 = *(_DWORD *)(*(_QWORD *)(a2[6] + (((unint64_t)(v2 + a2[9] - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                   + 4 * ((v2 + a2[9] - 1) & 0x3FF));
  v5 = a2[19];
  if (v5)
    v3 = *(_DWORD *)(*(_QWORD *)(a2[15] + (((unint64_t)(v5 + a2[18] - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                   + 4 * ((v5 + a2[18] - 1) & 0x3FF));
  v6 = a2[28];
  if (v6)
    v7 = *(_DWORD *)(*(_QWORD *)(a2[24] + (((unint64_t)(v6 + a2[27] - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                   + 4 * ((v6 + a2[27] - 1) & 0x3FF));
  else
    v7 = 0;
  *(_QWORD *)result = &off_1E2949650;
  *(_DWORD *)(result + 8) = v4;
  *(_DWORD *)(result + 12) = v3;
  *(_DWORD *)(result + 16) = v7;
  return result;
}

BOOL sub_18F4A8054(unsigned __int8 *a1, int *a2, _QWORD *a3)
{
  unint64_t v6;
  float v7;
  float v8;
  unint64_t v9;
  unint64_t v10;
  float v11;
  NSObject *v12;
  char *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  NSObject *v22;
  float v23;
  float v24;
  float v25;
  uint64_t v26;
  float v27;
  NSObject *v28;
  uint64_t v29;
  float v30;
  NSObject *v31;
  char *v32;
  uint64_t v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  float v38;
  float v39;
  char v40;
  int v41;
  float v42;
  unint64_t v43;
  unsigned int v44;
  float v45;
  float v46;
  float v47;
  unint64_t v48;
  float v49;
  unint64_t v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  NSObject *v60;
  unsigned int v61;
  float v62;
  float v63;
  float v64;
  float v65;
  int v66;
  float v67;
  int v68;
  float v69;
  float v70;
  int v73;
  uint64_t v74;
  char *v75;
  float v77;
  float v78;
  NSObject *v79;
  int v80;
  double v81;
  NSObject *v82;
  int v83;
  char v84;
  double v85;
  int v86;
  uint64_t v87;
  float v88;
  float v89;
  int v90;
  NSObject *v91;
  float v92;
  int v93;
  NSObject *v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  uint64_t v100;
  int v101;
  int v102;
  NSObject *v103;
  uint64_t v104;
  const char *v105;
  int v106;
  unint64_t v107;
  float v108;
  float v109;
  unint64_t v110;
  unint64_t v111;
  float v112;
  uint64_t v113;
  const char *v114;
  int v115;
  float v117;
  float v118;
  float v119;
  NSObject *v120;
  char *v121;
  NSObject *v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  uint64_t v128;
  char *v129;
  uint64_t v130;
  const char *v131;
  char *v132;
  char *v133;
  uint64_t v134;
  const char *v135;
  char *v136;
  char *v137;
  float v138;
  int v139;
  char *v140;
  int v141;
  double v142;
  char *v143;
  int v144;
  char *v145;
  char *v146;
  double v147;
  float v148;
  float v149;
  int v150;
  _BYTE v151[38];
  __int16 v152;
  double v153;
  __int16 v154;
  double v155;
  __int16 v156;
  double v157;
  __int16 v158;
  _BYTE v159[10];
  __int16 v160;
  int v161;
  __int16 v162;
  int v163;
  __int16 v164;
  int v165;
  __int16 v166;
  uint64_t v167;
  uint8_t buf[4];
  _BYTE v169[38];
  __int16 v170;
  double v171;
  __int16 v172;
  double v173;
  __int16 v174;
  double v175;
  __int16 v176;
  _BYTE v177[10];
  __int16 v178;
  int v179;
  __int16 v180;
  int v181;
  __int16 v182;
  int v183;
  __int16 v184;
  uint64_t v185;
  uint64_t v186;

  v186 = *MEMORY[0x1E0C80C00];
  *((_DWORD *)a1 + 250) = 0;
  v6 = *((_QWORD *)a1 + 13);
  v7 = 0.0;
  v8 = 0.0;
  if (v6)
    v8 = *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 9) + (((v6 + *((_QWORD *)a1 + 12) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                  + 4 * ((v6 + *((_QWORD *)a1 + 12) - 1) & 0x3FF));
  v9 = *((_QWORD *)a1 + 22);
  if (v9)
    v7 = *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 18) + (((v9 + *((_QWORD *)a1 + 21) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                  + 4 * ((v9 + *((_QWORD *)a1 + 21) - 1) & 0x3FF));
  v10 = *((_QWORD *)a1 + 31);
  if (v10)
    v11 = *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 27) + (((v10 + *((_QWORD *)a1 + 30) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                   + 4 * ((v10 + *((_QWORD *)a1 + 30) - 1) & 0x3FF));
  else
    v11 = 0.0;
  if (a1[965] && *((double *)a1 + 126) > 0.0)
  {
    a1[961] = 0;
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v12 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218496;
      *(double *)v169 = v8;
      *(_WORD *)&v169[8] = 2048;
      *(double *)&v169[10] = v7;
      *(_WORD *)&v169[18] = 2048;
      *(double *)&v169[20] = v11;
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_DEBUG, "onStartup, x, %.3f, y, %.3f, z, %.3f", buf, 0x20u);
    }
    v148 = 0.0;
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v150 = 134218496;
      *(double *)v151 = v8;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = v7;
      *(_WORD *)&v151[18] = 2048;
      *(double *)&v151[20] = v11;
      v13 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::calcCurrentOrientation()", "CoreLocation: %s\n", v13);
      if (v13 != (char *)buf)
        free(v13);
    }
    goto LABEL_155;
  }
  v7 = 0.0;
  v8 = 0.0;
  if (v6)
    v8 = *((float *)a1 + 14) / (float)v6;
  if (v9)
    v7 = *((float *)a1 + 32) / (float)v9;
  if (v10)
    v11 = *((float *)a1 + 50) / (float)v10;
  else
    v11 = 0.0;
  v14 = (float)((float)(v7 * v7) + (float)(v8 * v8)) + (float)(v11 * v11);
  if (v6 >= *((_QWORD *)a1 + 6))
  {
    v15 = 0.0;
    v16 = 0.0;
    if (v6 >= 2)
    {
      v17 = (float)((float)v6 * *((float *)a1 + 15)) - (float)(*((float *)a1 + 14) * *((float *)a1 + 14));
      if (v17 >= 0.0)
        v16 = v17 / (float)((v6 - 1) * v6);
    }
    if (v9 >= 2)
    {
      v18 = (float)((float)v9 * *((float *)a1 + 33)) - (float)(*((float *)a1 + 32) * *((float *)a1 + 32));
      if (v18 >= 0.0)
        v15 = v18 / (float)((v9 - 1) * v9);
    }
    v19 = 0.0;
    if (v10 >= 2)
    {
      v20 = (float)((float)v10 * *((float *)a1 + 51)) - (float)(*((float *)a1 + 50) * *((float *)a1 + 50));
      if (v20 >= 0.0)
        v19 = v20 / (float)((v10 - 1) * v10);
    }
    if (v16 >= v15)
      v21 = v16;
    else
      v21 = v15;
    if (v21 < v19)
      v21 = v19;
    v148 = v21;
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v22 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134219776;
      *(double *)v169 = v16;
      *(_WORD *)&v169[8] = 2048;
      *(double *)&v169[10] = v15;
      *(_WORD *)&v169[18] = 2048;
      *(double *)&v169[20] = v19;
      *(_WORD *)&v169[28] = 2048;
      *(double *)&v169[30] = v8;
      v170 = 2048;
      v171 = v7;
      v172 = 2048;
      v173 = v11;
      v174 = 2048;
      v175 = v148;
      v176 = 2048;
      *(double *)v177 = v14;
      _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_DEBUG, "acc variance, %.3f, %.3f, %.3f, acc mean, %.3f, %.3f, %.3f, maxVar, %.3f, mag2,%.3f", buf, 0x52u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v150 = 134219776;
      *(double *)v151 = v16;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = v15;
      *(_WORD *)&v151[18] = 2048;
      *(double *)&v151[20] = v19;
      *(_WORD *)&v151[28] = 2048;
      *(double *)&v151[30] = v8;
      v152 = 2048;
      v153 = v7;
      v154 = 2048;
      v155 = v11;
      v156 = 2048;
      v157 = v148;
      v158 = 2048;
      *(double *)v159 = v14;
      v133 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "float CLOrientationDetector::getAccStats(CLVector3d<float> &, float &)", "CoreLocation: %s\n", v133);
      if (v133 != (char *)buf)
        free(v133);
    }
  }
  else
  {
    v148 = 3.4028e38;
  }
  v23 = fabsf(v14 + -1.0);
  if (a1[16])
  {
    v24 = fabsf(v11);
    if (a1[963])
    {
      if (v24 > 0.925)
        goto LABEL_56;
      if ((float)(*((float *)a1 + 257) * 3.5) < v148)
        goto LABEL_55;
      v25 = 0.0;
      if (fabsf(*((float *)a1 + 239)) > 80.0)
        v25 = 1.0;
      if ((float)((float)(v25 * 0.1) + 0.3) < v23)
      {
LABEL_55:
        v26 = *((_QWORD *)a1 + 109);
        if (!v26
          || *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 105)
                                  + (((unint64_t)(v26 + *((_QWORD *)a1 + 108) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                      + 4 * ((v26 + *((_QWORD *)a1 + 108) - 1) & 0x3FF)) < 90.0)
        {
LABEL_56:
          *(_WORD *)(a1 + 963) = 256;
          v27 = *((float *)a1 + 239) * 0.8;
          *((float *)a1 + 239) = v27;
          --*((_DWORD *)a1 + 238);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
          v28 = off_1ECEDEE20;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_DEBUG, "Nixed rotationAroundZ state.", buf, 2u);
          }
          if (sub_18F1FCA08(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE28 != -1)
              dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
            LOWORD(v150) = 0;
            v137 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::nixRotationAroundZIfNecessary(float, float, float)", "CoreLocation: %s\n", v137);
            if (v137 != (char *)buf)
              free(v137);
          }
        }
      }
      v29 = *((_QWORD *)a1 + 60);
      if (v29)
        v30 = *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 56)
                                   + (((unint64_t)(v29 + *((_QWORD *)a1 + 59) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                       + 4 * ((v29 + *((_QWORD *)a1 + 59) - 1) & 0x3FF));
      else
        v30 = 0.0;
      if (fabsf(v30) <= 30.0)
        goto LABEL_94;
      v33 = *((_QWORD *)a1 + 31);
      v34 = v33
          ? *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 27)
                                 + (((unint64_t)(v33 + *((_QWORD *)a1 + 30) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                     + 4 * ((v33 + *((_QWORD *)a1 + 30) - 1) & 0x3FF))
          : 0.0;
      if (fabsf(v34) >= 0.9)
        goto LABEL_94;
      v35 = *((_QWORD *)a1 + 13);
      v7 = 0.0;
      v8 = 0.0;
      if (v35)
        v8 = *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 9)
                                  + (((unint64_t)(v35 + *((_QWORD *)a1 + 12) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                      + 4 * ((v35 + *((_QWORD *)a1 + 12) - 1) & 0x3FF));
      v36 = *((_QWORD *)a1 + 22);
      if (v36)
        v7 = *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 18)
                                  + (((unint64_t)(v36 + *((_QWORD *)a1 + 21) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                      + 4 * ((v36 + *((_QWORD *)a1 + 21) - 1) & 0x3FF));
      if (v33)
        v11 = *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 27)
                                   + (((unint64_t)(v33 + *((_QWORD *)a1 + 30) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                       + 4 * ((v33 + *((_QWORD *)a1 + 30) - 1) & 0x3FF));
      else
        v11 = 0.0;
      a1[962] = 0;
      *((_DWORD *)a1 + 245) = 1055286886;
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v37 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v37, OS_LOG_TYPE_DEBUG, "Ready for orientation change via rotation", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 2))
        goto LABEL_94;
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      LOWORD(v150) = 0;
      v32 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::setUpForOrienationChangeViaRotation(CLVector3d<float> &)", "CoreLocation: %s\n", v32);
LABEL_390:
      if (v32 != (char *)buf)
        free(v32);
      goto LABEL_94;
    }
    if (*((float *)a1 + 257) <= v148)
      goto LABEL_94;
    if (v24 >= 0.85 || *((_DWORD *)a1 + 251))
    {
      if (v24 > 0.9)
        *((_DWORD *)a1 + 251) = 0;
    }
    else
    {
      *((_DWORD *)a1 + 251) = 1;
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v31 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v31, OS_LOG_TYPE_DEBUG, "Setting lastPrimaryOrientation.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        LOWORD(v150) = 0;
        v32 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::updateLastPrimaryOrientationForZStats(float, float)", "CoreLocation: %s\n", v32);
        goto LABEL_390;
      }
    }
  }
LABEL_94:
  a1[961] = 1;
  v38 = 1.0;
  v39 = 1.5;
  if (*a1)
    v39 = 1.0;
  if (a1[963])
    goto LABEL_101;
  if (!*a1)
    v38 = 2.25;
  if ((float)(v38 * *((float *)a1 + 256)) > v148 && (float)(v39 * 0.15) > v23)
  {
LABEL_101:
    if (!a1[964])
    {
      v41 = 0;
      a1[961] = 0;
      *((_DWORD *)a1 + 244) = 0;
      v40 = 1;
      goto LABEL_109;
    }
    goto LABEL_102;
  }
  if ((float)(v39 * 0.3) <= v23)
  {
    v40 = 0;
    v41 = 1;
    goto LABEL_109;
  }
  v42 = v38 * *((float *)a1 + 257);
  if (v42 > v148)
  {
    v40 = a1[964];
    if (v40)
    {
LABEL_102:
      v40 = 0;
      v41 = 0;
      goto LABEL_109;
    }
LABEL_263:
    v41 = 0;
    ++*((_DWORD *)a1 + 244);
    goto LABEL_109;
  }
  v40 = 0;
  v41 = 1;
  if (*((_QWORD *)a1 + 13) >= *((_QWORD *)a1 + 6) && fabsf(v11) < 0.95)
  {
    if (fabsf(v8) <= 0.45 && fabsf(v7) <= 0.45 || v42 * 4.0 <= v148)
    {
      v40 = 0;
      goto LABEL_109;
    }
    v40 = 0;
    goto LABEL_263;
  }
LABEL_109:
  if (a1[16] && *((_QWORD *)a1 + 42) >= *((_QWORD *)a1 + 35))
  {
    v43 = *((_QWORD *)a1 + 71);
    if (v43 < *((_QWORD *)a1 + 64))
      v40 = 1;
    if ((v40 & 1) == 0)
    {
      v44 = *((_DWORD *)a1 + 244);
      if (v44 < 4 * (int)(float)(*((float *)a1 + 1) / 10.0))
      {
        v45 = 0.0;
        v46 = 0.0;
        if (v43 >= 2)
        {
          v47 = (float)((float)v43 * *((float *)a1 + 131)) - (float)(*((float *)a1 + 130) * *((float *)a1 + 130));
          v46 = 0.0;
          if (v47 >= 0.0)
            v46 = v47 / (float)((v43 - 1) * v43);
        }
        v48 = *((_QWORD *)a1 + 80);
        if (v48 >= 2)
        {
          v49 = (float)((float)v48 * *((float *)a1 + 149)) - (float)(*((float *)a1 + 148) * *((float *)a1 + 148));
          if (v49 >= 0.0)
            v45 = v49 / (float)((v48 - 1) * v48);
        }
        v50 = *((_QWORD *)a1 + 89);
        v51 = 0.0;
        if (v50 >= 2)
        {
          v52 = (float)((float)v50 * *((float *)a1 + 167)) - (float)(*((float *)a1 + 166) * *((float *)a1 + 166));
          if (v52 >= 0.0)
            v51 = v52 / (float)((v50 - 1) * v50);
        }
        if (v46 >= v45)
          v45 = v46;
        if (v45 >= v51)
          v53 = v45;
        else
          v53 = v51;
        if (v23 < 0.45 && (float)(*((float *)a1 + 257) * 4.0) > v148 && v53 < 2000.0)
        {
          sub_18F4A7E40((uint64_t)buf, (uint64_t)(a1 + 488));
          v54 = fabsf(*(float *)&v169[4]);
          v55 = fabsf(*(float *)&v169[8]);
          v56 = fabsf(*(float *)&v169[12]);
          if (v54 < v55)
            v54 = v55;
          if (v54 < v56)
            v54 = v56;
          if (v54 < 30.0 || v53 < 800.0 && v54 < 60.0)
          {
            sub_18F4A7FA8((uint64_t)&v150, (_QWORD *)a1 + 32);
            v57 = fabsf(*(float *)&v151[4]);
            v58 = fabsf(*(float *)&v151[8]);
            v59 = fabsf(*(float *)&v151[12]);
            if (v57 < v58)
              v57 = v58;
            if (v57 < v59)
              v57 = v59;
            if (!a1[964] || v57 < 175.0)
              *((_DWORD *)a1 + 244) = v44 + 2;
            v41 = 0;
          }
        }
      }
    }
  }
  if (v41)
  {
    *((_DWORD *)a1 + 244) = 0;
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v60 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v60, OS_LOG_TYPE_DEBUG, "Resetting stable count", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      LOWORD(v150) = 0;
      v132 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::deviceIsMoving(const CLVector3d<float> &, float, float)", "CoreLocation: %s\n", v132);
      if (v132 != (char *)buf)
        free(v132);
    }
  }
  if (!a1[961] || (a1[962] = 1, *((_DWORD *)a1 + 244) >= (4 * (int)(float)(*((float *)a1 + 1) / 10.0))))
  {
LABEL_155:
    v61 = *a1;
    if (*a1)
    {
      v62 = 0.45;
      if (a1[962])
        v62 = 0.5;
      v63 = *((float *)a1 + 245);
      if (v63 <= v62)
        v64 = v62;
      else
        v64 = (float)(v63 + v62) * 0.5;
      *((float *)a1 + 245) = v64;
      v65 = 0.35;
    }
    else
    {
      v64 = 0.5;
      v65 = 0.4;
    }
    v149 = v65;
    if (v7 < 0.0)
      v66 = 1;
    else
      v66 = 2;
    if (v7 <= 0.0)
      v67 = -v7;
    else
      v67 = v7;
    if (v8 < 0.0)
      v68 = 3;
    else
      v68 = 4;
    if (v8 <= 0.0)
      v69 = -v8;
    else
      v69 = v8;
    if (v67 > v69)
    {
      if (!a1[963] || (v70 = 0.5, v69 >= 0.5) || a1[961] || v11 <= -0.85)
      {
        if (v69 <= 0.15 && v11 >= -0.8)
          v69 = 0.0;
        if (v7 < 0.0 || v61 < 2)
        {
          v70 = v64;
        }
        else
        {
          v149 = v65 + 0.15;
          v70 = v64 + 0.15;
        }
      }
      else
      {
        v69 = 0.0;
        v149 = 0.4;
      }
      if (v67 > v70 && (float)(v67 - v69) > v149)
      {
        *((_DWORD *)a1 + 250) = v66;
        v64 = v70;
        goto LABEL_285;
      }
      v64 = v70;
      goto LABEL_252;
    }
    if (!a1[963] || v67 >= 0.5 || a1[961] || v11 <= -0.85)
    {
      if (v67 <= 0.15 && v11 >= -0.8)
        v67 = 0.0;
    }
    else
    {
      v67 = 0.0;
      v149 = 0.4;
      v64 = 0.5;
    }
    if (v8 >= 0.0 && v61 >= 2 && a1[17])
    {
      v147 = *((double *)a1 + 126) - *((double *)a1 + 121);
      if (v67 >= 0.05)
      {
LABEL_218:
        v73 = 0;
        goto LABEL_219;
      }
      v73 = 0;
      if (v11 < -0.9 && v11 > -1.1)
      {
        v74 = 0;
        while (1)
        {
          if (byte_18F509690[v74] == v61)
          {
            if (a1[1036])
            {
              if (!byte_18F509690[v74 + 13])
                goto LABEL_217;
            }
            else if (byte_18F509690[v74 + 13])
            {
              goto LABEL_217;
            }
            v75 = &byte_18F509690[v74];
            if (v147 < 5.0 || byte_18F509690[v74 + 12] == 0)
            {
              v78 = *((float *)v75 + 1);
              v77 = *((float *)v75 + 2);
              if (vabds_f32(v69, v78) <= v77)
              {
                if (qword_1ECEDEE28 != -1)
                  dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
                v122 = off_1ECEDEE20;
                if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 134218240;
                  *(double *)v169 = v78;
                  *(_WORD *)&v169[8] = 2048;
                  *(double *)&v169[10] = v77;
                  _os_log_impl(&dword_18F1DC000, v122, OS_LOG_TYPE_DEBUG, "Within magic angle limits: Threshold %.4f, Delta %.4f", buf, 0x16u);
                }
                if (sub_18F1FCA08(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1ECEDEE28 != -1)
                    dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
                  v150 = 134218240;
                  *(double *)v151 = v78;
                  *(_WORD *)&v151[8] = 2048;
                  *(double *)&v151[10] = v77;
                  v146 = (char *)_os_log_send_and_compose_impl();
                  sub_18F419700("Generic", 1, 0, 2, "static BOOL CLOrientationDetector::withinMagicAngleLimits(FormFactor, BOOL, float, BOOL)", "CoreLocation: %s\n", v146);
                  if (v146 != (char *)buf)
                    free(v146);
                }
                v73 = 1;
                break;
              }
            }
          }
LABEL_217:
          v74 += 16;
          if (v74 == 320)
            goto LABEL_218;
        }
      }
LABEL_219:
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v79 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
      {
        v80 = *a1;
        v81 = *((double *)a1 + 126) - *((double *)a1 + 121);
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)v169 = v80;
        *(_WORD *)&v169[4] = 1024;
        *(_DWORD *)&v169[6] = v147 < 5.0;
        *(_WORD *)&v169[10] = 2048;
        *(double *)&v169[12] = v81;
        _os_log_impl(&dword_18F1DC000, v79, OS_LOG_TYPE_DEBUG, "Ipad %d: screenJustTurnedOn, %d, deltaTime %.5f", buf, 0x18u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v141 = *a1;
        v142 = *((double *)a1 + 126) - *((double *)a1 + 121);
        v150 = 67109632;
        *(_DWORD *)v151 = v141;
        *(_WORD *)&v151[4] = 1024;
        *(_DWORD *)&v151[6] = v147 < 5.0;
        *(_WORD *)&v151[10] = 2048;
        *(double *)&v151[12] = v142;
        v143 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::atMagicCoverRestingAngle(const float *, float, float, float)", "CoreLocation: %s\n", v143);
        if (v143 != (char *)buf)
          free(v143);
      }
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v82 = off_1ECEDEE20;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
      {
        v83 = a1[962];
        *(_DWORD *)buf = 67110144;
        *(_DWORD *)v169 = v147 < 5.0;
        *(_WORD *)&v169[4] = 1024;
        *(_DWORD *)&v169[6] = 0;
        *(_WORD *)&v169[10] = 1024;
        *(_DWORD *)&v169[12] = v73;
        *(_WORD *)&v169[16] = 1024;
        *(_DWORD *)&v169[18] = v83;
        *(_WORD *)&v169[22] = 2048;
        *(double *)&v169[24] = v148;
        _os_log_impl(&dword_18F1DC000, v82, OS_LOG_TYPE_DEBUG, "allowShallow, %d, magicCaseRest, %d, tiltIn, %d, wasMoving, %d, maxVar, %.5f", buf, 0x24u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v144 = a1[962];
        v150 = 67110144;
        *(_DWORD *)v151 = v147 < 5.0;
        *(_WORD *)&v151[4] = 1024;
        *(_DWORD *)&v151[6] = 0;
        *(_WORD *)&v151[10] = 1024;
        *(_DWORD *)&v151[12] = v73;
        *(_WORD *)&v151[16] = 1024;
        *(_DWORD *)&v151[18] = v144;
        *(_WORD *)&v151[22] = 2048;
        *(double *)&v151[24] = v148;
        v145 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::atMagicCoverRestingAngle(const float *, float, float, float)", "CoreLocation: %s\n", v145);
        if (v145 != (char *)buf)
          free(v145);
      }
      v84 = v73 ^ 1;
      if (a1[962])
        v84 = 1;
      if ((v84 & 1) != 0 || (float)(*((float *)a1 + 256) * 0.025) <= v148)
      {
        if (*((double *)a1 + 124) > 0.0)
          *((_QWORD *)a1 + 124) = 0xBFF0000000000000;
      }
      else
      {
        v85 = *((double *)a1 + 124);
        if (v85 < 0.0)
        {
          v85 = *((double *)a1 + 126);
          *((double *)a1 + 124) = v85;
        }
        if (a1[965] || *((_DWORD *)a1 + 246) == 4 || *((double *)a1 + 126) - v85 > dbl_18F509680[*a1 == 2])
        {
          *((_DWORD *)a1 + 250) = 4;
          *((_QWORD *)a1 + 124) = 0xBFF0000000000000;
          goto LABEL_285;
        }
      }
    }
    if ((float)(v69 - v64) > 0.0 && (float)(v69 - v67) > v149)
    {
      if (*a1 >= 2u
        || (float)(v69 - v64) > 0.15
        && (v86 = *((_DWORD *)a1 + 260) + 1, *((_DWORD *)a1 + 260) = v86, v86 >= (int)(float)(*((float *)a1 + 1) * 0.3)))
      {
        *((_DWORD *)a1 + 250) = v68;
LABEL_285:
        a1[965] = 0;
        if (!a1[961])
        {
          a1[962] = 0;
          if (a1[16])
          {
            if (*a1 >= 2u && *((float *)a1 + 256) > v148)
            {
              v107 = *((_QWORD *)a1 + 71);
              v108 = 0.0;
              v109 = 0.0;
              if (v107)
                v109 = *((float *)a1 + 130) / (float)v107;
              v110 = *((_QWORD *)a1 + 80);
              if (v110)
                v108 = *((float *)a1 + 148) / (float)v110;
              v111 = *((_QWORD *)a1 + 89);
              if (v111)
                v112 = *((float *)a1 + 166) / (float)v111;
              else
                v112 = 0.0;
              v117 = fabsf(v112);
              v118 = fabsf(v109);
              v119 = fabsf(v108);
              if (v118 >= v119)
                v119 = v118;
              if (v117 >= v119)
                v119 = v117;
              if ((*((int *)a1 + 238) < 2 || *((_DWORD *)a1 + 250) == *((_DWORD *)a1 + 246))
                && (fabsf(v11) > 0.85 || v119 < 30.0))
              {
                sub_18F4A7F68((uint64_t)a1, 1);
                if (qword_1ECEDEE28 != -1)
                  dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
                v120 = off_1ECEDEE20;
                if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl(&dword_18F1DC000, v120, OS_LOG_TYPE_DEBUG, "Not filling Zrot buffer.", buf, 2u);
                }
                if (sub_18F1FCA08(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1ECEDEE28 != -1)
                    dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
                  LOWORD(v150) = 0;
                  v121 = (char *)_os_log_send_and_compose_impl();
                  sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::resetZStatsWhenQuiescent(float, float)", "CoreLocation: %s\n", v121);
                  if (v121 != (char *)buf)
                    free(v121);
                }
              }
            }
          }
        }
        if (qword_1ECEDEE28 != -1)
          dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
        v94 = off_1ECEDEE20;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
        {
          v95 = *((_DWORD *)a1 + 250);
          v96 = a1[961];
          v97 = a1[962];
          v98 = *((_DWORD *)a1 + 246);
          v99 = *((_DWORD *)a1 + 244);
          v100 = *((_QWORD *)a1 + 126);
          *(_DWORD *)buf = 134221056;
          *(double *)v169 = v149;
          *(_WORD *)&v169[8] = 2048;
          *(double *)&v169[10] = v64;
          *(_WORD *)&v169[18] = 2048;
          *(double *)&v169[20] = v8;
          *(_WORD *)&v169[28] = 2048;
          *(double *)&v169[30] = v7;
          v170 = 2048;
          v171 = v11;
          v172 = 2048;
          v173 = (float)(v67 - v69);
          v174 = 2048;
          v175 = v67;
          v176 = 1024;
          *(_DWORD *)v177 = v95;
          *(_WORD *)&v177[4] = 1024;
          *(_DWORD *)&v177[6] = v96;
          v178 = 1024;
          v179 = v97;
          v180 = 1024;
          v181 = v98;
          v182 = 1024;
          v183 = v99;
          v184 = 2048;
          v185 = v100;
          _os_log_impl(&dword_18F1DC000, v94, OS_LOG_TYPE_DEBUG, "deltaWeightThreshold, %.3f, tiltWeightTheshold, %.3f, currAcc, %.3f, %.3f, %.3f, deltaWeight, %.3f, tilt, %.3f, fCurrentOrientation, %d, isMoving, %d, wasMoving, %d, fLastClearOrientation, %d, fStableCount, %d, DetectionTime, %f", buf, 0x70u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE28 != -1)
            dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
          v123 = *((_DWORD *)a1 + 250);
          v124 = a1[961];
          v125 = a1[962];
          v126 = *((_DWORD *)a1 + 246);
          v127 = *((_DWORD *)a1 + 244);
          v128 = *((_QWORD *)a1 + 126);
          v150 = 134221056;
          *(double *)v151 = v149;
          *(_WORD *)&v151[8] = 2048;
          *(double *)&v151[10] = v64;
          *(_WORD *)&v151[18] = 2048;
          *(double *)&v151[20] = v8;
          *(_WORD *)&v151[28] = 2048;
          *(double *)&v151[30] = v7;
          v152 = 2048;
          v153 = v11;
          v154 = 2048;
          v155 = (float)(v67 - v69);
          v156 = 2048;
          v157 = v67;
          v158 = 1024;
          *(_DWORD *)v159 = v123;
          *(_WORD *)&v159[4] = 1024;
          *(_DWORD *)&v159[6] = v124;
          v160 = 1024;
          v161 = v125;
          v162 = 1024;
          v163 = v126;
          v164 = 1024;
          v165 = v127;
          v166 = 2048;
          v167 = v128;
          v129 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::calcCurrentOrientation()", "CoreLocation: %s\n", v129);
          if (v129 != (char *)buf)
            free(v129);
        }
        goto LABEL_291;
      }
    }
LABEL_252:
    if (*((_DWORD *)a1 + 250))
      goto LABEL_285;
    if (a1[16] && a1[963])
    {
      v87 = *((_QWORD *)a1 + 60);
      v88 = v87
          ? *(float *)(*(_QWORD *)(*((_QWORD *)a1 + 56)
                                 + (((unint64_t)(v87 + *((_QWORD *)a1 + 59) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                     + 4 * ((v87 + *((_QWORD *)a1 + 59) - 1) & 0x3FF))
          : 0.0;
      if (fabsf(v88) > 60.0)
        goto LABEL_285;
    }
    if (v67 >= v69)
      v89 = v67;
    else
      v89 = v69;
    if (v11 <= 0.0)
    {
      if (v11 >= -0.5 || (float)((float)-v11 - v89) <= 0.4)
        goto LABEL_277;
      v90 = 5;
    }
    else
    {
      if (v11 <= 0.5 || (float)(v11 - v89) <= 0.4)
        goto LABEL_277;
      v90 = 6;
    }
    *((_DWORD *)a1 + 250) = v90;
LABEL_277:
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v91 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEBUG))
    {
      if (v11 <= 0.0)
        v92 = -v11;
      else
        v92 = v11;
      v93 = *((_DWORD *)a1 + 250);
      *(_DWORD *)buf = 134218496;
      *(double *)v169 = v92;
      *(_WORD *)&v169[8] = 2048;
      *(double *)&v169[10] = v89;
      *(_WORD *)&v169[18] = 1024;
      *(_DWORD *)&v169[20] = v93;
      _os_log_impl(&dword_18F1DC000, v91, OS_LOG_TYPE_DEBUG, "FaceUp/Down: maxWeight,%.3f, 2ndWeight,%.3f, orientation,%d", buf, 0x1Cu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      if (v11 <= 0.0)
        v138 = -v11;
      else
        v138 = v11;
      v139 = *((_DWORD *)a1 + 250);
      v150 = 134218496;
      *(double *)v151 = v138;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = v89;
      *(_WORD *)&v151[18] = 1024;
      *(_DWORD *)&v151[20] = v139;
      v140 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::calcCurrentOrientation()", "CoreLocation: %s\n", v140);
      if (v140 != (char *)buf)
        free(v140);
    }
    goto LABEL_285;
  }
LABEL_291:
  v101 = *((_DWORD *)a1 + 250);
  *a2 = v101;
  if (*((_DWORD *)a1 + 250))
  {
    *((_DWORD *)a1 + 260) = 0;
  }
  else
  {
    v106 = *((_DWORD *)a1 + 246);
    if (v106 && v106 != 7)
    {
      *a2 = v106;
      v101 = v106;
    }
  }
  v102 = *((_DWORD *)a1 + 246);
  *a3 = *((_QWORD *)a1 + 126);
  if (v101 != v102)
  {
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v103 = off_1ECEDEE20;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_DEFAULT))
    {
      v104 = *((int *)a1 + 246);
      if (v104 > 6)
        v105 = "Unexpected";
      else
        v105 = off_1E2958ED8[v104];
      v113 = *a2;
      if (v113 > 6)
        v114 = "Unexpected";
      else
        v114 = off_1E2958ED8[v113];
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)v169 = v105;
      *(_WORD *)&v169[8] = 2082;
      *(_QWORD *)&v169[10] = v114;
      _os_log_impl(&dword_18F1DC000, v103, OS_LOG_TYPE_DEFAULT, "Notify from, %{public}s -> %{public}s ", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE28 != -1)
        dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
      v130 = *((int *)a1 + 246);
      if (v130 > 6)
        v131 = "Unexpected";
      else
        v131 = off_1E2958ED8[v130];
      v134 = *a2;
      if (v134 > 6)
        v135 = "Unexpected";
      else
        v135 = off_1E2958ED8[v134];
      v150 = 136446466;
      *(_QWORD *)v151 = v131;
      *(_WORD *)&v151[8] = 2082;
      *(_QWORD *)&v151[10] = v135;
      v136 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL CLOrientationDetector::calcOrientation(CMDeviceOrientationType &, CLMotionTypeTimestamp &)", "CoreLocation: %s\n", v136);
      if (v136 != (char *)buf)
        free(v136);
    }
    *((_DWORD *)a1 + 246) = *((_DWORD *)a1 + 250);
    *((_DWORD *)a1 + 245) = 1055286886;
    a1[962] = 0;
    sub_18F4A7F68((uint64_t)a1, 1);
    v115 = *((_DWORD *)a1 + 250);
    if ((v115 - 5) < 2)
      v115 = 0;
    *((_DWORD *)a1 + 251) = v115;
  }
  return v101 != v102;
}

void sub_18F4AA248(uint64_t a1)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE28 != -1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
  v2 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Disabling gyro.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v3 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::disableGyro()", "CoreLocation: %s\n", v3);
    if (v3 != (char *)buf)
      free(v3);
  }
  if (*(_BYTE *)(a1 + 16))
  {
    *(_BYTE *)(a1 + 16) = 0;
    sub_18F1E6174((_QWORD *)(a1 + 272));
    sub_18F1E6174((_QWORD *)(a1 + 344));
    sub_18F1E6174((_QWORD *)(a1 + 416));
    sub_18F1E6174((_QWORD *)(a1 + 504));
    sub_18F1E6174((_QWORD *)(a1 + 576));
    sub_18F1E6174((_QWORD *)(a1 + 648));
    sub_18F4A7F68(a1, 1);
  }
}

void sub_18F4AA420(uint64_t a1)
{
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE28 != -1)
    dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
  v2 = off_1ECEDEE20;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE20, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Enabling gyro.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE28 != -1)
      dispatch_once(&qword_1ECEDEE28, &unk_1E2954188);
    v3 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLOrientationDetector::enableGyro()", "CoreLocation: %s\n", v3);
    if (v3 != (char *)buf)
      free(v3);
  }
  *(_QWORD *)(a1 + 1016) = 0xBFF0000000000000;
  *(_BYTE *)(a1 + 16) = 1;
}

os_log_t sub_18F4AA5C0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Orientation");
  off_1ECEDEE20 = result;
  return result;
}

uint64_t sub_18F4AAE3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a2, sel_onMagicMountData_, a1, a4, a5);
}

void sub_18F4AB008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  uint64_t v19;

  if (a19 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v19, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F4AB044(uint64_t a1, CLConnectionMessage **a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSSet *v9;
  uint64_t v10;
  uint64_t v11;
  void *DictionaryOfClasses;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  char *v28;
  uint8_t buf[4];
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = (void *)MEMORY[0x1E0C99E60];
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v9 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v7, v8, v5, 0);
  if (*a2)
  {
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9);
    v16 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v13, (uint64_t)CFSTR("CMErrorMessage"), v14, v15);
  }
  else
  {
    DictionaryOfClasses = 0;
    v16 = (void *)objc_msgSend_objectForKeyedSubscript_(0, (const char *)v9, (uint64_t)CFSTR("CMErrorMessage"), v10, v11);
  }
  if (!DictionaryOfClasses || !v16)
  {
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
    v24 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v24, OS_LOG_TYPE_ERROR, "Invalid service response.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 == -1)
        goto LABEL_46;
      goto LABEL_48;
    }
    return;
  }
  v21 = objc_msgSend_integerValue(v16, v17, v18, v19, v20);
  v22 = v21;
  if (v21 > 108)
  {
    if (v21 == 110)
    {
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
      v26 = qword_1EE16D810;
      if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_ERROR, "Not entitled to manage the AOP service.", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 0))
        return;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 != -1)
        goto LABEL_48;
    }
    else
    {
      if (v21 != 109)
      {
LABEL_38:
        if (qword_1EE16D808 != -1)
          dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
        v27 = qword_1EE16D810;
        if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134349056;
          v30 = v22;
          _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_ERROR, "Service request failed! error,%{public}ld", buf, 0xCu);
        }
        if (!sub_18F1FCA08(115, 0))
          return;
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D808 != -1)
          goto LABEL_48;
        goto LABEL_46;
      }
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
      v25 = qword_1EE16D810;
      if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v25, OS_LOG_TYPE_ERROR, "Service is not available!", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 0))
        return;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 != -1)
        goto LABEL_48;
    }
LABEL_46:
    v28 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMMagicMountManagerInternal connect]_block_invoke", "CoreLocation: %s\n", v28);
    if (v28 != (char *)buf)
      free(v28);
    return;
  }
  if (v21 == 100)
    return;
  if (v21 != 108)
    goto LABEL_38;
  if (qword_1EE16D808 != -1)
    dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
  v23 = qword_1EE16D810;
  if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_ERROR, "Unable to communicate with AOP service!", buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D808 == -1)
      goto LABEL_46;
LABEL_48:
    dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
    goto LABEL_46;
  }
}

void sub_18F4AB5D8(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  char *v4;
  _QWORD v5[5];
  __int16 v6;
  uint8_t buf[1640];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 64))
  {
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
    v2 = qword_1EE16D810;
    if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Connection interrupted! Resending service request.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
      v6 = 0;
      v4 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMMagicMountManagerInternal connect]_block_invoke", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf)
        free(v4);
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 64) = 0;
    v3 = sub_18F204AE4();
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = sub_18F4AB7BC;
    v5[3] = &unk_1E2955938;
    v5[4] = *(_QWORD *)(a1 + 32);
    sub_18F1F6514(v3, (uint64_t)v5);
  }
}

uint64_t sub_18F4AB7BC(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  v5 = *(_QWORD *)(result + 32);
  if (!*(_BYTE *)(v5 + 64))
  {
    *(_BYTE *)(v5 + 64) = 1;
    return objc_msgSend_sendServiceRequestPrivate(*(void **)(result + 32), a2, a3, a4, a5);
  }
  return result;
}

void sub_18F4AB938(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4ABC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_18F4ABD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4ABD1C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_initPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = result;
  return result;
}

void sub_18F4ABE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4ABE70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), sel_deallocPrivate, a3, a4, a5);
}

uint64_t sub_18F4AC08C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a1[4], sel_startMagicMountUpdatesPrivateToQueue_withHandler_, a1[5], a1[6], a5);
}

uint64_t sub_18F4AC268(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_stopMagicMountUpdatesPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_18F4AC614(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_setAPWakesAllowedPrivate_(*(void **)(a1 + 32), a2, *(unsigned __int8 *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4AC894(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

void sub_18F4ACCB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 sub_18F4ACCC8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

__n128 sub_18F4ACCD8(uint64_t a1)
{
  __n128 result;

  result = *(__n128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 8);
  *(__n128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48) = result;
  return result;
}

void sub_18F4ACE24(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  double v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (qword_1EE16D808 != -1)
    dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
  v3 = qword_1EE16D810;
  if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)buf = 134349312;
    v19 = v4;
    v20 = 2050;
    v21 = v5;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "Feeding mountStatus=%{public}ld timestamp,%{public}f", buf, 0x16u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D808 != -1)
      dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
    v16 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMMagicMountManager feedMountStatus:apAwake:simulated:timestamp:]_block_invoke", "CoreLocation: %s\n", v16);
    if (v16 != (char *)buf)
      free(v16);
  }
  v10 = *(double *)(v2 + 8);
  v11 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v2 + 16) != v11 || !*(_BYTE *)(a1 + 56) || *(_BYTE *)(a1 + 57) || v10 == 0.0)
  {
    v12 = *(double *)(a1 + 48);
    if (v12 <= v10)
    {
      if (qword_1EE16D808 != -1)
        dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
      v13 = qword_1EE16D810;
      if (os_log_type_enabled((os_log_t)qword_1EE16D810, OS_LOG_TYPE_ERROR))
      {
        v14 = *(_QWORD *)(v2 + 8);
        v15 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 134349312;
        v19 = v14;
        v20 = 2050;
        v21 = v15;
        _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_ERROR, "Invalid magic mount state. Timestamp went backwards! old timestamp,%{public}f, new timestamp %{public}f", buf, 0x16u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D808 != -1)
          dispatch_once(&qword_1EE16D808, &unk_1E2958F38);
        v17 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMMagicMountManager feedMountStatus:apAwake:simulated:timestamp:]_block_invoke", "CoreLocation: %s\n", v17);
        if (v17 != (char *)buf)
          free(v17);
      }
    }
    else
    {
      *(double *)(v2 + 8) = v12;
      *(_QWORD *)(v2 + 16) = v11;
    }
    objc_msgSend_sendMagicMountStateToClientPrivate(*(void **)(a1 + 32), v6, v7, v8, v9);
  }
}

void sub_18F4AD2E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

os_log_t sub_18F4AD618()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "MagicMount");
  qword_1EE16D810 = (uint64_t)result;
  return result;
}

void sub_18F4AD648(uint64_t a1)
{
  sub_18F1E932C(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4AD66C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 16))(a3, *(_QWORD *)(a1 + 24));
}

void sub_18F4AD814(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F4AD868(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  const __CFDictionary *Dictionary;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  void *v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  char *v24;
  NSObject *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  unsigned int v32;
  _QWORD v33[2];
  uint8_t buf[1640];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v4 = *(void **)(a1 + 32);
  objc_sync_enter(v4);
  Dictionary = (const __CFDictionary *)CLConnectionMessage::getDictionary(*a2);
  sub_18F1EDCF0(v33, Dictionary);
  if ((*(int (**)(_QWORD *))(v33[0] + 856))(v33) < 1)
  {
    if (qword_1EE16D468 != -1)
      dispatch_once(&qword_1EE16D468, &unk_1E2954FC8);
    v23 = qword_1EE16D460;
    if (os_log_type_enabled((os_log_t)qword_1EE16D460, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_FAULT, "Could not get dictionary for kCLConnectionMessageActivityAlarm", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_18;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D468 != -1)
      dispatch_once(&qword_1EE16D468, &unk_1E2954FC8);
    LOWORD(v30) = 0;
    v24 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMActivityAlarmProxy init]_block_invoke", "CoreLocation: %s\n", v24);
LABEL_23:
    if (v24 != (char *)buf)
      free(v24);
    goto LABEL_18;
  }
  v31 = 0;
  v32 = -1;
  v30 = 0xBFF0000000000000;
  if (!sub_18F440E28(&v32, &v31, &v30, (uint64_t)v33))
  {
LABEL_18:
    v17 = 0;
    goto LABEL_19;
  }
  v9 = *(void **)(*(_QWORD *)(a1 + 32) + 32);
  v10 = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v6, v32, v7, v8);
  v17 = (id)objc_msgSend_objectForKey_(v9, v11, v10, v12, v13);
  if (!v17)
  {
    if (qword_1EE16D468 != -1)
      dispatch_once(&qword_1EE16D468, &unk_1E2954FC8);
    v25 = qword_1EE16D460;
    if (os_log_type_enabled((os_log_t)qword_1EE16D460, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v25, OS_LOG_TYPE_DEFAULT, "#Warning Did not find the triggered activity alarm in the current set of alarms.", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      goto LABEL_18;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D468 != -1)
      dispatch_once(&qword_1EE16D468, &unk_1E2954FC8);
    v24 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMActivityAlarmProxy init]_block_invoke", "CoreLocation: %s\n", v24);
    goto LABEL_23;
  }
  v18 = *(void **)(*(_QWORD *)(a1 + 32) + 32);
  v19 = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v14, v32, v15, v16);
  objc_msgSend_removeObjectForKey_(v18, v20, v19, v21, v22);
LABEL_19:
  sub_18F1EDCB4(v33);
  objc_sync_exit(v4);
  objc_msgSend_fire(v17, v26, v27, v28, v29);

}

void sub_18F4ADBF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  sub_18F1EDCB4((uint64_t *)va);
  objc_sync_exit(v7);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4ADC28(uint64_t a1)
{
  void *v2;
  const char *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t *p_shared_owners;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  const char *v38;
  uint64_t v40;
  std::__shared_weak_count *v41;
  uint64_t v42;
  uint64_t v43;
  std::__shared_weak_count *v44;
  int v45;
  _QWORD v46[2];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _BYTE v51[128];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v2 = *(void **)(a1 + 32);
  objc_sync_enter(v2);
  v4 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v4 + 48))
  {
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    v5 = *(void **)(v4 + 32);
    v6 = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v3, (uint64_t)&v47, (uint64_t)v51, 16);
    if (v6)
    {
      v7 = *(_QWORD *)v48;
      do
      {
        for (i = 0; i != v6; ++i)
        {
          if (*(_QWORD *)v48 != v7)
            objc_enumerationMutation(v5);
          v9 = *(void **)(*((_QWORD *)&v47 + 1) + 8 * i);
          sub_18F1ECEA0(v46);
          LODWORD(v42) = objc_msgSend_intValue(v9, v10, v11, v12, v13);
          v17 = (void *)objc_msgSend_objectForKeyedSubscript_(*(void **)(*(_QWORD *)(a1 + 32) + 32), v14, (uint64_t)v9, v15, v16);
          v45 = objc_msgSend_trigger(v17, v18, v19, v20, v21);
          v25 = (void *)objc_msgSend_objectForKeyedSubscript_(*(void **)(*(_QWORD *)(a1 + 32) + 32), v22, (uint64_t)v9, v23, v24);
          objc_msgSend_duration(v25, v26, v27, v28, v29);
          v43 = v30;
          sub_18F440DC4(&v42, &v45, &v43, (uint64_t)v46);
          LOBYTE(v43) = 1;
          sub_18F36BB20((uint64_t)v46, "kCLConnectionMessageSubscribeKey", &v43);
          v42 = v46[1];
          sub_18F44DCB8("kCLConnectionMessageActivityAlarmStart", &v42, &v43);
          v40 = v43;
          v41 = v44;
          if (v44)
          {
            p_shared_owners = (unint64_t *)&v44->__shared_owners_;
            do
              v32 = __ldxr(p_shared_owners);
            while (__stxr(v32 + 1, p_shared_owners));
          }
          CLConnectionClient::sendMessage();
          if (v41)
          {
            v33 = (unint64_t *)&v41->__shared_owners_;
            do
              v34 = __ldaxr(v33);
            while (__stlxr(v34 - 1, v33));
            if (!v34)
            {
              ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
              std::__shared_weak_count::__release_weak(v41);
            }
          }
          v35 = v44;
          if (v44)
          {
            v36 = (unint64_t *)&v44->__shared_owners_;
            do
              v37 = __ldaxr(v36);
            while (__stlxr(v37 - 1, v36));
            if (!v37)
            {
              ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
              std::__shared_weak_count::__release_weak(v35);
            }
          }
          sub_18F1EDCB4(v46);
        }
        v6 = objc_msgSend_countByEnumeratingWithState_objects_count_(v5, v38, (uint64_t)&v47, (uint64_t)v51, 16, v40);
      }
      while (v6);
    }
  }
  return objc_sync_exit(v2);
}

void sub_18F4ADE80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15)
{
  void *v15;

  objc_sync_exit(v15);
  _Unwind_Resume(a1);
}

void sub_18F4ADED8(uint64_t a1, CLConnectionMessage **a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D468 != -1)
    dispatch_once(&qword_1EE16D468, &unk_1E2954FC8);
  v3 = qword_1EE16D460;
  if (os_log_type_enabled((os_log_t)qword_1EE16D460, OS_LOG_TYPE_DEBUG))
  {
    v4 = CLConnectionMessage::name(*a2);
    if (*(char *)(v4 + 23) >= 0)
      v5 = v4;
    else
      v5 = *(_QWORD *)v4;
    *(_DWORD *)buf = 136315138;
    v8 = v5;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEBUG, "Default handler received message %s", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D468 != -1)
      dispatch_once(&qword_1EE16D468, &unk_1E2954FC8);
    CLConnectionMessage::name(*a2);
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMActivityAlarmProxy init]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf)
      free(v6);
  }
}

void sub_18F4AE13C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_18F4AE1C4(uint64_t a1)
{
  id result;

  result = objc_alloc_init(*(Class *)(a1 + 32));
  qword_1ECEDFD28 = (uint64_t)result;
  return result;
}

void sub_18F4AE518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  void *v19;

  objc_sync_exit(v19);
  _Unwind_Resume(a1);
}

void sub_18F4AE944(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  void *v27;

  objc_sync_exit(v27);
  _Unwind_Resume(a1);
}

os_log_t sub_18F4AE9B4()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "ActivityAlarm");
  qword_1EE16D460 = (uint64_t)result;
  return result;
}

void sub_18F4AEE34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_18F4AF488(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18F4AF5CC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18F4AF5E8(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  _Block_release(*(const void **)(a1 + 40));
}

void sub_18F4AF61C(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  _Block_release(*(const void **)(a1 + 40));
}

os_log_t sub_18F4AF678()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "ActivityAlarm");
  qword_1EE16D460 = (uint64_t)result;
  return result;
}

void sub_18F4AF6A4()
{
  _QWORD *v0;
  io_connect_t v1;
  NSObject *v2;
  char *v3;
  uint8_t buf[1640];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v0 = (_QWORD *)operator new();
  sub_18F1E61EC((uint64_t)v0, (uint64_t)"CLPowerStateService", 1);
  *v0 = &off_1E294AAD8;
  v0[6] = 0;
  v0[5] = 0;
  v0[4] = dispatch_queue_create("com.apple.CoreMotion.CLPocketStateService", 0);
  v1 = IORegisterForSystemPower(v0, (IONotificationPortRef *)v0 + 6, (IOServiceInterestCallback)sub_18F4AF900, (io_object_t *)v0 + 10);
  *((_DWORD *)v0 + 11) = v1;
  if (v1)
  {
    IONotificationPortSetDispatchQueue((IONotificationPortRef)v0[6], (dispatch_queue_t)v0[4]);
  }
  else
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2958F58);
    v2 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_FAULT, "Could not subscribe to system power notifications", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2958F58);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "CLPowerStateService::CLPowerStateService()", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
  qword_1EE16E8C0 = (uint64_t)v0;
}

void sub_18F4AF8C8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_18F3DB8A0(v1);
  MEMORY[0x194001438](v1, 0x10F1C40233A07BALL);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4AF900(uint64_t a1, uint64_t a2, int a3, intptr_t a4)
{
  uint64_t result;
  int v8;

  v8 = a3;
  result = sub_18F1FD2C8(a1, 0, (uint64_t)&v8, 4);
  if (a3 == -536870272 || a3 == -536870288)
    return IOAllowPowerChange(*(_DWORD *)(a1 + 44), a4);
  return result;
}

_QWORD *sub_18F4AF978(io_object_t *notifier)
{
  io_object_t *v2;
  IONotificationPort *v3;
  io_connect_t v4;

  *(_QWORD *)notifier = &off_1E294AAD8;
  v2 = notifier + 10;
  if (notifier[10])
  {
    IODeregisterForSystemPower(notifier + 10);
    *v2 = 0;
  }
  v3 = (IONotificationPort *)*((_QWORD *)notifier + 6);
  if (v3)
  {
    IONotificationPortDestroy(v3);
    *((_QWORD *)notifier + 6) = 0;
  }
  v4 = notifier[11];
  if (v4)
  {
    IOServiceClose(v4);
    notifier[11] = 0;
  }
  return sub_18F3DB8A0(notifier);
}

void sub_18F4AF9E4(io_object_t *a1)
{
  sub_18F4AF978(a1);
  JUMPOUT(0x194001438);
}

void sub_18F4B0374(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v15, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F4B03B0(uint64_t a1, CLConnectionMessage **a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSSet *v9;
  void *DictionaryOfClasses;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint8_t buf[4];
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = (void *)MEMORY[0x1E0C99E60];
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v9 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v7, v8, v5, 0);
  if (*a2)
  {
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9);
    if (DictionaryOfClasses)
    {
      v14 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, (uint64_t)CFSTR("CMErrorMessage"), v12, v13);
      if (v14)
      {
        v15 = (void *)v14;
        if (qword_1EE16D478 != -1)
          dispatch_once(&qword_1EE16D478, &unk_1E2959018);
        v16 = qword_1EE16D470;
        if (os_log_type_enabled((os_log_t)qword_1EE16D470, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 67240192;
          v27 = objc_msgSend_intValue(v15, v17, v18, v19, v20);
          _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d", buf, 8u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D478 != -1)
            dispatch_once(&qword_1EE16D478, &unk_1E2959018);
          objc_msgSend_intValue(v15, v21, v22, v23, v24);
          v25 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "-[CMStepCounterProxy init]_block_invoke", "CoreLocation: %s\n", v25);
          if (v25 != (char *)buf)
            free(v25);
        }
      }
    }
  }
}

void sub_18F4B0810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4B0834(_QWORD *a1, const char *a2)
{
  void *v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  std::__shared_weak_count *v11;

  v3 = (void *)a1[4];
  v4 = (std::__shared_weak_count *)*((_QWORD *)a2 + 1);
  v10 = *(_QWORD *)a2;
  v11 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  objc_msgSend__handleQueryResponse_onQueue_withHandler_(v3, a2, (uint64_t)&v10, a1[5], a1[6]);
  v7 = v11;
  if (v11)
  {
    v8 = (unint64_t *)&v11->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_18F4B08C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_18F2A8438((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_18F4B0AA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  sub_18F2A8438((uint64_t)&a9);
  sub_18F2A8438((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void sub_18F4B0AE0(_QWORD *a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  NSSet *v11;
  void *DictionaryOfClasses;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  NSObject *v28;
  void *v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  NSObject *v49;
  char *v50;
  _QWORD v51[7];
  int v52;
  _QWORD v53[6];
  int v54;
  void *v55;
  uint8_t buf[4];
  void *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v11 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v9, v10, v6, v7, 0);
  if (*a2 && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v11)) != 0)
  {
    v16 = DictionaryOfClasses;
    v17 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v13, (uint64_t)CFSTR("CMErrorMessage"), v14, v15);
    v21 = (void *)objc_msgSend_objectForKeyedSubscript_(v16, v18, (uint64_t)CFSTR("CMPedometerDataObject"), v19, v20);
    if (v17)
    {
      *(_BYTE *)(a1[4] + 16) = 0;
      v53[0] = MEMORY[0x1E0C809B0];
      v53[1] = 3221225472;
      v53[2] = sub_18F4B0F08;
      v53[3] = &unk_1E2955B60;
      v26 = (void *)a1[5];
      v27 = a1[6];
      v53[4] = v17;
      v53[5] = v27;
      objc_msgSend_addOperationWithBlock_(v26, v22, (uint64_t)v53, v24, v25);
      return;
    }
    v29 = v21;
    if (v21)
    {
      v30 = objc_msgSend_endDate(v21, v22, v23, v24, v25);
      v35 = (void *)objc_msgSend_numberOfSteps(v29, v31, v32, v33, v34);
      v40 = objc_msgSend_intValue(v35, v36, v37, v38, v39);
      v44 = a1[4];
      if (*(_QWORD *)(v44 + 32) == -1)
      {
        *(_QWORD *)(v44 + 32) = v40;
        v44 = a1[4];
      }
      if (!v40)
      {
        *(_QWORD *)(v44 + 32) = 0;
        v44 = a1[4];
      }
      v45 = *(_QWORD *)(v44 + 40);
      v46 = v40;
      if (v45 == -1 || v40 - v45 >= a1[7])
      {
        v51[0] = MEMORY[0x1E0C809B0];
        v51[1] = 3221225472;
        v51[2] = sub_18F4B0F8C;
        v51[3] = &unk_1E2958F80;
        v52 = v40;
        v47 = (void *)a1[5];
        v48 = a1[6];
        v51[5] = v30;
        v51[6] = v48;
        v51[4] = v44;
        objc_msgSend_addOperationWithBlock_(v47, v41, (uint64_t)v51, v42, v43);
        *(_QWORD *)(a1[4] + 40) = v46;
      }
      return;
    }
    if (qword_1EE16D478 != -1)
      dispatch_once(&qword_1EE16D478, &unk_1E2959018);
    v49 = qword_1EE16D470;
    if (os_log_type_enabled((os_log_t)qword_1EE16D470, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 138543362;
      v57 = v16;
      _os_log_impl(&dword_18F1DC000, v49, OS_LOG_TYPE_FAULT, "Unable to parse mesage (%{public}@) when starting updates to queue", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D478 != -1)
        dispatch_once(&qword_1EE16D478, &unk_1E2959018);
      v54 = 138543362;
      v55 = v16;
LABEL_30:
      v50 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMStepCounterProxy _startStepCountingUpdatesToQueue:updateOn:withHandler:]_block_invoke", "CoreLocation: %s\n", v50);
      if (v50 != (char *)buf)
        free(v50);
    }
  }
  else
  {
    if (qword_1EE16D478 != -1)
      dispatch_once(&qword_1EE16D478, &unk_1E2959018);
    v28 = qword_1EE16D470;
    if (os_log_type_enabled((os_log_t)qword_1EE16D470, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_ERROR, "Unable to parse message when starting updates to queue!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D478 != -1)
        dispatch_once(&qword_1EE16D478, &unk_1E2959018);
      LOWORD(v54) = 0;
      goto LABEL_30;
    }
  }
}

uint64_t sub_18F4B0F08(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;

  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_date(MEMORY[0x1E0C99D68], a2, a3, a4, a5);
  v8 = (void *)MEMORY[0x1E0CB35C8];
  v13 = objc_msgSend_integerValue(*(void **)(a1 + 32), v9, v10, v11, v12);
  v15 = objc_msgSend_errorWithDomain_code_userInfo_(v8, v14, (uint64_t)CFSTR("CMErrorDomain"), v13, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(v6 + 16))(v6, 0, v7, v15);
}

uint64_t sub_18F4B0F8C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
}

uint64_t sub_18F4B13E0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4B1440(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 0);
}

uint64_t sub_18F4B1454(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F4B1700()
{
  return TCCAccessRequest();
}

void sub_18F4B1774(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v6;
  __int128 v7;
  _QWORD block[4];
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v6 = *(NSObject **)(objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), a2, a3, a4, a5) + 24);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_18F4B17EC;
  block[3] = &unk_1E2955C48;
  v7 = *(_OWORD *)(a1 + 48);
  v9 = *(_OWORD *)(a1 + 32);
  v10 = v7;
  v11 = *(_QWORD *)(a1 + 64);
  dispatch_async(v6, block);
}

uint64_t sub_18F4B17EC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;

  v6 = objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel__queryStepCountStartingFromInternal_to_toQueue_withHandler_, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
}

void sub_18F4B1924(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v5;
  char *v6;
  uint8_t buf[1640];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), a2, a3, a4, a5) + 16))
  {
    if (qword_1EE16D478 != -1)
      dispatch_once(&qword_1EE16D478, &unk_1E2959018);
    v5 = qword_1EE16D470;
    if (os_log_type_enabled((os_log_t)qword_1EE16D470, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_FAULT, "Unable to start additional step updates while it is already active", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D478 != -1)
        dispatch_once(&qword_1EE16D478, &unk_1E2959018);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMStepCounter startStepCountingUpdatesToQueue:updateOn:withHandler:]_block_invoke", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
  else
  {
    TCCAccessRequest();
  }
}

void sub_18F4B1B10(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v6;
  uint64_t v7;
  _QWORD v8[4];
  __int128 v9;
  uint64_t v10;
  uint64_t v11;

  v6 = *(NSObject **)(objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), a2, a3, a4, a5) + 24);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = sub_18F4B1B84;
  v8[3] = &unk_1E29568A8;
  v9 = *(_OWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 56);
  v10 = *(_QWORD *)(a1 + 48);
  v11 = v7;
  dispatch_async(v6, v8);
}

uint64_t sub_18F4B1B84(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;

  v6 = objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel__startStepCountingUpdatesToQueue_updateOn_withHandler_, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48));
}

void sub_18F4B1C14(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  NSObject *v26;
  char *v27;
  std::__shared_weak_count *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  const __CFString *v31;
  uint64_t v32;
  void *__p[2];
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), a2, a3, a4, a5) + 16))
  {
    v31 = CFSTR("kCLConnectionMessageSubscribeKey");
    v32 = MEMORY[0x1E0C9AAA0];
    __p[0] = (void *)objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v6, (uint64_t)&v32, (uint64_t)&v31, 1);
    sub_18F425E5C("kCLConnectionMessageStepCountUpdate", __p, &v29);
    objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), v7, v8, v9, v10);
    v28 = v30;
    if (v30)
    {
      p_shared_owners = (unint64_t *)&v30->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    CLConnectionClient::sendMessage();
    if (v28)
    {
      v17 = (unint64_t *)&v28->__shared_owners_;
      do
        v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), v13, v14, v15, v16);
    sub_18F270374(__p, "kCLConnectionMessageStepCountUpdate");
    CLConnectionClient::setHandlerForMessage();
    if (v34 < 0)
      operator delete(__p[0]);
    *(_BYTE *)(objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), v19, v20, v21, v22) + 16) = 0;
    v23 = v30;
    if (v30)
    {
      v24 = (unint64_t *)&v30->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
  }
  else
  {
    if (qword_1EE16D478 != -1)
      dispatch_once(&qword_1EE16D478, &unk_1E2959018);
    v26 = qword_1EE16D470;
    if (os_log_type_enabled((os_log_t)qword_1EE16D470, OS_LOG_TYPE_FAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_FAULT, "Unable to stop step updates as we are are not receiving updates", (uint8_t *)__p, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1EE16D478 != -1)
        dispatch_once(&qword_1EE16D478, &unk_1E2959018);
      LOWORD(v29) = 0;
      v27 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMStepCounter stopStepCountingUpdates]_block_invoke", "CoreLocation: %s\n", v27);
      if (v27 != (char *)__p)
        free(v27);
    }
  }
}

void sub_18F4B1EEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0)
    operator delete(__p);
  sub_18F2A8438((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_18F4B1FFC(uint64_t a1)
{
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  sub_18F35C258("kCLConnectionMessageStepCountReset", &v14);
  objc_msgSend_stepcounterProxy(*(void **)(a1 + 32), v2, v3, v4, v5);
  v13 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v13)
  {
    v8 = (unint64_t *)&v13->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  v10 = v15;
  if (v15)
  {
    v11 = (unint64_t *)&v15->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void sub_18F4B20DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

os_log_t sub_18F4B210C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Pedometer");
  qword_1EE16D470 = (uint64_t)result;
  return result;
}

void sub_18F4B2CA4(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  char *v4;
  uint8_t buf[4];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE78 != -1)
    dispatch_once(&qword_1ECEDEE78, &unk_1E2954248);
  v2 = off_1ECEDEE70;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEBUG))
  {
    v3 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    v6 = v3;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "Dumped gyro cal database with id %@", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2954248);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CLSensorFusionService::CLSensorFusionService(int)_block_invoke", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
}

uint64_t sub_18F4B2E54(uint64_t a1)
{
  NSObject *v2;
  int v3;
  char *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = off_1E294ADB0;
  if (qword_1ECEDEE78 != -1)
    dispatch_once(&qword_1ECEDEE78, &unk_1E2954248);
  v2 = off_1ECEDEE70;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEBUG))
  {
    v3 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)buf = 67240192;
    v7 = v3;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEBUG, "Stopping device motion service %{public}#x", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2954248);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual CLSensorFusionService::~CLSensorFusionService()", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
  return a1;
}

void sub_18F4B3014(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  sub_18F213574(a1);
}

void sub_18F4B3028(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  __int128 v5;

  v4 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(_QWORD *)a2 = *(_QWORD *)(a1 + 96);
  if (a1 + 96 != a2)
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 104);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a1 + 140);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a2 + 52) = *(_DWORD *)(a1 + 148);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 152);
  *(_QWORD *)(a2 + 60) = *(_QWORD *)(a1 + 156);
  *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 164);
  *(_DWORD *)(a2 + 72) = *(_DWORD *)(a1 + 168);
  *(_DWORD *)(a2 + 76) = *(_DWORD *)(a1 + 172);
  *(_DWORD *)(a2 + 80) = *(_DWORD *)(a1 + 176);
  v5 = *(_OWORD *)(a1 + 180);
  *(_DWORD *)(a2 + 100) = *(_DWORD *)(a1 + 196);
  *(_OWORD *)(a2 + 84) = v5;
  os_unfair_lock_unlock(v4);
}

void sub_18F4B30FC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD *v5;
  uint64_t v6;
  NSObject *v7;
  char *v8;
  char *v9;
  uint8_t buf[4];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (sub_18F1DFF7C())
  {
    v2 = operator new();
    *(_QWORD *)(v2 + 48) = 0x3E00000000;
    *(_BYTE *)v2 = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_OWORD *)(v2 + 816) = 0u;
    *(_OWORD *)(v2 + 832) = 0u;
    *(_QWORD *)(v2 + 800) = 0;
    *(_DWORD *)(v2 + 808) = 0;
    *(_OWORD *)(v2 + 12) = xmmword_18F5098B0;
    *(int64x2_t *)(v2 + 32) = vdupq_n_s64(1uLL);
    v3 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 40) = v2;
    if (v3)
      MEMORY[0x194001438](v3, 0x1000C40F66057FCLL);
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954268);
    v4 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      v11 = 0x404F3FFFE7190014;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEBUG, "Starting PickupDetector detection with accelFrequency %.1f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954268);
      v8 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual void CMPickupServiceAP::startDetection()", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf)
        free(v8);
    }
    if (!*(_QWORD *)(a1 + 48))
    {
      v5 = (_QWORD *)operator new();
      *v5 = off_1E294C238;
      *v5 = &off_1E294C3C0;
      v5[1] = 0;
      v5[2] = sub_18F4B350C;
      v5[3] = a1;
      *(_QWORD *)(a1 + 48) = v5;
      v6 = sub_18F1DFF7C();
      sub_18F1F4F0C(v6, 0, *(_QWORD *)(a1 + 48), 0.0160000008);
    }
  }
  else
  {
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954268);
    v7 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_DEFAULT, "#Warning No accelerometer; not starting CMPickupDetector detection!",
        buf,
        2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954268);
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual void CMPickupServiceAP::startDetection()", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
  }
}

void sub_18F4B34E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4B350C(uint64_t a1, uint64_t a2)
{
  int v4;
  double v5;
  uint64_t result;
  unsigned __int8 v7;
  NSObject *v8;
  char *v9;
  float32x2_t v10;
  int v11;
  uint8_t buf[8];
  double v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 16);
  v5 = *(double *)a1;
  v10 = *(float32x2_t *)(a1 + 8);
  v11 = v4;
  result = sub_18F4C1700(*(unsigned __int8 **)(a2 + 40), &v10, (unint64_t)(v5 * 1000000.0));
  if ((_DWORD)result != *(unsigned __int8 *)(a2 + 32))
  {
    v7 = result;
    if (qword_1EE16D3E8 != -1)
      dispatch_once(&qword_1EE16D3E8, &unk_1E2954268);
    v8 = qword_1EE16D3D8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D3D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEBUG, "Sending CMPickupDetector notification.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D3E8 != -1)
        dispatch_once(&qword_1EE16D3E8, &unk_1E2954268);
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CMPickupServiceAP::onAccelerometerData(const CLAccelerometer::Sample *, void *)", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
    *(_QWORD *)buf = v7;
    v13 = *(double *)a1;
    result = sub_18F1E5A28(a2, 0, (uint64_t)buf, 16);
    *(_BYTE *)(a2 + 32) = v7;
  }
  return result;
}

_QWORD *sub_18F4B370C(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[6];
  int v6;

  if (result[6])
  {
    v1 = result;
    v2 = sub_18F1DFF7C();
    v3 = v1[6];
    v4 = sub_18F204AE4();
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = sub_18F1F5EE0;
    v5[3] = &unk_1E2956E98;
    v6 = 0;
    v5[4] = v2;
    v5[5] = v3;
    sub_18F1F5E28(v4, (uint64_t)v5);
    result = (_QWORD *)v1[6];
    if (result)
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
    v1[6] = 0;
  }
  return result;
}

_QWORD *sub_18F4B37A4(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E294A8B0;
  v2 = a1[5];
  a1[5] = 0;
  if (v2)
    MEMORY[0x194001438](v2, 0x1000C40F66057FCLL);
  return sub_18F3CA15C(a1);
}

void sub_18F4B37F0(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E294A8B0;
  v2 = a1[5];
  a1[5] = 0;
  if (v2)
    MEMORY[0x194001438](v2, 0x1000C40F66057FCLL);
  sub_18F3CA15C(a1);
  JUMPOUT(0x194001438);
}

os_log_t sub_18F4B3850()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Gesture");
  qword_1EE16D3D8 = (uint64_t)result;
  return result;
}

void sub_18F4B4824(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0xA0C40A8488062);
  _Unwind_Resume(a1);
}

void sub_18F4B54FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4B5550(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
    return MEMORY[0x1E0DE7D20](a2, sel__feedDeviceMotion_, result, a4, a5);
  return result;
}

uint64_t sub_18F4B5564(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
    return MEMORY[0x1E0DE7D20](a2, sel__feedAccel_, result, a4, a5);
  return result;
}

uint64_t sub_18F4B5578(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
    return MEMORY[0x1E0DE7D20](a2, sel__feedGyro_, result, a4, a5);
  return result;
}

uint64_t sub_18F4B558C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
    return MEMORY[0x1E0DE7D20](a2, sel__feedGyroTemperature_, result, a4, a5);
  return result;
}

uint64_t sub_18F4B55A0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
    return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40), sel__feedHeadAccessoryDeviceMotion_, a2, a4, a5);
  return result;
}

uint64_t sub_18F4B55BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), sel_logCounters, a3, a4, a5);
}

void sub_18F4B62D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

os_log_t sub_18F4B69C0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Workout");
  qword_1EE16D880 = (uint64_t)result;
  return result;
}

void sub_18F4B69EC(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  NSObject *v3;
  char *v4;
  uint8_t buf[1640];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954288);
    v2 = qword_1EE16D880;
    if (os_log_type_enabled((os_log_t)qword_1EE16D880, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "[camera] Accessory device motion status : Disconnected", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D878 == -1)
      {
LABEL_16:
        v4 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "_ZL22accessoryStatusHandler_block_invoke", "CoreLocation: %s\n", v4);
        if (v4 != (char *)buf)
          free(v4);
        return;
      }
LABEL_18:
      dispatch_once(&qword_1EE16D878, &unk_1E2954288);
      goto LABEL_16;
    }
  }
  else
  {
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954288);
    v3 = qword_1EE16D880;
    if (os_log_type_enabled((os_log_t)qword_1EE16D880, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[camera] Accessory device motion status : Connected", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D878 == -1)
        goto LABEL_16;
      goto LABEL_18;
    }
  }
}

uint64_t *sub_18F4B6C3C(uint64_t **a1, uint64_t *a2)
{
  uint64_t *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    sub_18F3473DC(result);
    JUMPOUT(0x194001438);
  }
  return result;
}

uint64_t sub_18F4B7900()
{
  uint64_t result;

  result = sub_18F361724(CFSTR("BKDigitizerSignpostsEnabled"), CFSTR("com.apple.backboardd"), (Boolean *)&byte_1ECEDFD30);
  byte_1ECEDFD31 = result;
  return result;
}

uint64_t sub_18F4B793C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a2, sel_onEclipseData_, a1, a4, a5);
}

uint64_t sub_18F4B7948(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a2, sel_onViewObstructedStateData_, a1, a4, a5);
}

uint64_t sub_18F4B7954(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a2, sel_onCameraCapturePoseData_, a1, a4, a5);
}

void sub_18F4B7BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4B7BF8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_initPrivateWithClientType_(*(void **)(a1 + 32), a2, 0, a4, a5);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = result;
  return result;
}

void sub_18F4B7CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4B7CF8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_initPrivateWithClientType_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 48), a4, a5);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = result;
  return result;
}

void sub_18F4B7E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4B7E60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), sel_deallocPrivate, a3, a4, a5);
}

void sub_18F4B7FB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  if (a21 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v21, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F4B7FEC(uint64_t a1, CLConnectionMessage **a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSSet *v9;
  uint64_t v10;
  uint64_t v11;
  void *DictionaryOfClasses;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  char *v28;
  uint8_t buf[4];
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = (void *)MEMORY[0x1E0C99E60];
  v4 = objc_opt_class();
  v5 = objc_opt_class();
  v9 = (NSSet *)objc_msgSend_setWithObjects_(v3, v6, v4, v7, v8, v5, 0);
  if (*a2)
  {
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9);
    v16 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v13, (uint64_t)CFSTR("CMErrorMessage"), v14, v15);
  }
  else
  {
    DictionaryOfClasses = 0;
    v16 = (void *)objc_msgSend_objectForKeyedSubscript_(0, (const char *)v9, (uint64_t)CFSTR("CMErrorMessage"), v10, v11);
  }
  if (!DictionaryOfClasses || !v16)
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v24 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v24, OS_LOG_TYPE_ERROR, "Invalid service response.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 == -1)
        goto LABEL_46;
      goto LABEL_48;
    }
    return;
  }
  v21 = objc_msgSend_integerValue(v16, v17, v18, v19, v20);
  v22 = v21;
  if (v21 > 108)
  {
    if (v21 == 110)
    {
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v26 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_ERROR, "Not entitled to manage the AOP service.", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 0))
        return;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        goto LABEL_48;
    }
    else
    {
      if (v21 != 109)
      {
LABEL_38:
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
        v27 = off_1EE16D428;
        if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134349056;
          v30 = v22;
          _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_ERROR, "Service request failed! error,%{public}ld", buf, 0xCu);
        }
        if (!sub_18F1FCA08(115, 0))
          return;
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D438 != -1)
          goto LABEL_48;
        goto LABEL_46;
      }
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v25 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v25, OS_LOG_TYPE_ERROR, "Service is not available!", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 0))
        return;
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        goto LABEL_48;
    }
LABEL_46:
    v28 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager connect]_block_invoke", "CoreLocation: %s\n", v28);
    if (v28 != (char *)buf)
      free(v28);
    return;
  }
  if (v21 == 100)
    return;
  if (v21 != 108)
    goto LABEL_38;
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
  v23 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_ERROR, "Unable to communicate with AOP service!", buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 == -1)
      goto LABEL_46;
LABEL_48:
    dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    goto LABEL_46;
  }
}

void sub_18F4B8580(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  char *v4;
  _QWORD v5[4];
  __int128 v6;
  __int16 v7;
  uint8_t buf[1640];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 232))
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v2 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Connection interrupted! Resending service request.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v7 = 0;
      v4 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager connect]_block_invoke", "CoreLocation: %s\n", v4);
      if (v4 != (char *)buf)
        free(v4);
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 232) = 0;
    v3 = sub_18F204AE4();
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = sub_18F4B8764;
    v5[3] = &unk_1E29559D0;
    v6 = *(_OWORD *)(a1 + 32);
    sub_18F1F6514(v3, (uint64_t)v5);
  }
}

uint64_t sub_18F4B8764(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;

  v5 = *(_QWORD *)(result + 32);
  if (!*(_BYTE *)(v5 + 232))
  {
    *(_BYTE *)(v5 + 232) = 1;
    return objc_msgSend_sendServiceRequestPrivate(*(void **)(result + 40), a2, a3, a4, a5);
  }
  return result;
}

void sub_18F4B894C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4B8B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4B8B6C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  int v20;
  char *v21;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v7 = (void *)objc_msgSend_objectForKeyedSubscript_(a2, (const char *)a2, (uint64_t)CFSTR("CMErrorMessage"), a4, a5);
  if (!a2 || !v7)
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v16 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_ERROR, "View Obstructed State Invalid service response!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 == -1)
        goto LABEL_34;
      goto LABEL_36;
    }
    return;
  }
  v12 = objc_msgSend_integerValue(v7, v8, v9, v10, v11);
  if (v12 == 100)
    return;
  v13 = v12;
  if (v12 == 108)
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v17 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      v18 = *(unsigned __int8 *)(a1 + 32);
      *(_DWORD *)buf = 67240192;
      v23 = v18;
      _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_ERROR, "View Obstructed State Unable to communicate with AOP service! enable,%{public}d", buf, 8u);
    }
    if (!sub_18F1FCA08(115, 0))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      goto LABEL_36;
LABEL_34:
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager sendViewObstructedRequestPrivate]_block_invoke", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
    return;
  }
  if (v12 != 109)
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v19 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      v20 = *(unsigned __int8 *)(a1 + 32);
      *(_DWORD *)buf = 67240448;
      v23 = v20;
      v24 = 2050;
      v25 = v13;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_ERROR, "View Obstructed State Service request failed! enable,%{public}d, error,%{public}ld", buf, 0x12u);
    }
    if (!sub_18F1FCA08(115, 0))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      goto LABEL_36;
    goto LABEL_34;
  }
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
  v14 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
  {
    v15 = *(unsigned __int8 *)(a1 + 32);
    *(_DWORD *)buf = 67240192;
    v23 = v15;
    _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_ERROR, "View Obstructed State Service is not available! enable,%{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 == -1)
      goto LABEL_34;
LABEL_36:
    dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    goto LABEL_34;
  }
}

void sub_18F4B9090(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  char *v3;
  NSObject *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v1 + 232))
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v2 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "Service already started.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v3 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager startService]_block_invoke", "CoreLocation: %s\n", v3);
      if (v3 != (char *)buf)
        free(v3);
    }
  }
  else
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v5 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
    {
      v10 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v6, v7, v8, v9);
      v11 = *(_QWORD *)(v1 + 344);
      *(_DWORD *)buf = 134349314;
      v18 = v10;
      v19 = 2114;
      v20 = v11;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] Start service called.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v12, v13, v14, v15);
      v16 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager startService]_block_invoke", "CoreLocation: %s\n", v16);
      if (v16 != (char *)buf)
        free(v16);
    }
    *(_BYTE *)(v1 + 232) = 1;
  }
}

void sub_18F4B940C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v1 + 232))
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v3 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
    {
      v8 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v4, v5, v6, v7);
      v9 = *(_QWORD *)(v1 + 344);
      *(_DWORD *)buf = 134349314;
      v22 = v8;
      v23 = 2114;
      v24 = v9;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] Stop service called.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v15, v16, v17, v18);
      v19 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager stopService]_block_invoke", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf)
        free(v19);
    }
    *(_BYTE *)(v1 + 232) = 0;
    objc_msgSend_sendServiceRequestPrivate(*(void **)(a1 + 32), v10, v11, v12, v13);
  }
  else
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v14 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_ERROR, "Service already stopped (or service has not been started yet).", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v20 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager stopService]_block_invoke", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf)
        free(v20);
    }
  }
}

uint64_t sub_18F4B97A4(_QWORD *a1)
{
  return MEMORY[0x1E0DE7D20](a1[4], sel_startSuppressionUpdatesToQueue_withOptions_withHandler_, a1[5], 7, a1[6]);
}

uint64_t sub_18F4B9830(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
  v3 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
  {
    v8 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v4, v5, v6, v7);
    v9 = *(_QWORD *)(v2 + 344);
    v10 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)buf = 134350594;
    v23 = v8;
    v24 = 2114;
    v25 = v9;
    v26 = 1026;
    v27 = v10 & 1;
    v28 = 1026;
    v29 = (v10 >> 1) & 1;
    v30 = 1026;
    v31 = (v10 >> 2) & 1;
    v32 = 1026;
    v33 = (v10 >> 3) & 1;
    v34 = 1026;
    v35 = (v10 >> 4) & 1;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] Starting suppression updates with useViewObstructed,%{public}u,useSmartPowerNap,%{public}u,useWatchPresence,%{public}u,useAlwaysOnViewObstructed,%{public}u,useFacedown,%{public}u", buf, 0x34u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v17, v18, v19, v20);
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager startSuppressionUpdatesToQueue:withOptions:withHandler:]_block_invoke", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
  }
  *(_QWORD *)(v2 + 336) = *(_QWORD *)(a1 + 56);
  objc_msgSend_sendServiceRequestPrivate(*(void **)(a1 + 32), v11, v12, v13, v14);
  return objc_msgSend_startSuppressionUpdatesPrivateToQueue_withOptions_withHandler_(*(void **)(a1 + 32), v15, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48));
}

uint64_t sub_18F4B9B18(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_stopSuppressionUpdatesPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
}

void sub_18F4B9BB4(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (qword_1EE16D438 != -1)
    dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
  v3 = off_1EE16D428;
  if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
  {
    v8 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v4, v5, v6, v7);
    v9 = *(_QWORD *)(v2 + 344);
    *(_DWORD *)buf = 134349314;
    v16 = v8;
    v17 = 2114;
    v18 = v9;
    _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] Significant user interaction detected", buf, 0x16u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v10, v11, v12, v13);
    v14 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager didDetectSignificantUserInteraction]_block_invoke", "CoreLocation: %s\n", v14);
    if (v14 != (char *)buf)
      free(v14);
  }
  if (qword_1EE16E8E0 != -1)
    dispatch_once(&qword_1EE16E8E0, &unk_1E2953948);
  sub_18F439550(qword_1EE16E8E8, 0);
}

uint64_t sub_18F4B9FB0(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a1[4], sel_startCameraCapturePoseUpdatesPrivateToQueue_withHandler_, a1[5], a1[6], a5);
}

uint64_t sub_18F4BA18C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_stopCameraCapturePoseUpdatesPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
}

void sub_18F4BA35C()
{
  if (qword_1EE16E8E0 != -1)
    dispatch_once(&qword_1EE16E8E0, &unk_1E2953948);
  sub_18F439550(qword_1EE16E8E8, 1);
}

void sub_18F4BA5C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Resume(exception_object);
}

void sub_18F4BA5E4(uint64_t a1)
{
  double v2;
  CMSuppressionEvent *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t v9;

  if (qword_1EE16E8E0 != -1)
    dispatch_once(&qword_1EE16E8E0, &unk_1E2953948);
  v7 = 0.0;
  v8 = 0;
  v9 = 0;
  sub_18F4394CC(&v7);
  v2 = v7;
  if (v7 != 0.0)
  {
    v3 = [CMSuppressionEvent alloc];
    if ((_BYTE)v8)
      v6 = objc_msgSend_initWithEventType_reason_timestamp_(v3, v4, 1, 1, v5, v2);
    else
      v6 = objc_msgSend_initWithEventType_reason_timestamp_(v3, v4, 2, 1, v5, v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v6;
  }
}

void sub_18F4BA9C0(uint64_t a1)
{
  uint64_t v1;

  (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
  if (qword_1EE16E8E0 != -1)
    dispatch_once(&qword_1EE16E8E0, &unk_1E2953948);
  v1 = sub_18F204AE4();
  sub_18F1F6514(v1, (uint64_t)&unk_1E2957F80);
}

void sub_18F4BB6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 sub_18F4BB6F4(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

__n128 sub_18F4BB70C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  __n128 result;
  __int128 v4;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  result = *(__n128 *)(v1 + 8);
  v4 = *(_OWORD *)(v1 + 24);
  *(_QWORD *)(v2 + 80) = *(_QWORD *)(v1 + 40);
  *(__n128 *)(v2 + 48) = result;
  *(_OWORD *)(v2 + 64) = v4;
  return result;
}

void sub_18F4BB7C4(uint64_t a1)
{
  double *v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint8_t buf[4];
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v2 = *(double **)(*(_QWORD *)(a1 + 32) + 8);
  if (*((_QWORD *)v2 + 14) || *(_BYTE *)(a1 + 72))
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v3 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
    {
      v8 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v4, v5, v6, v7);
      v9 = *((_QWORD *)v2 + 43);
      v13 = objc_msgSend_stringForEventType_(CMSuppressionEvent, v10, *(_QWORD *)(a1 + 40), v11, v12);
      v14 = *(_QWORD *)(a1 + 48);
      *(_DWORD *)buf = 134349826;
      v58 = v8;
      v59 = 2114;
      v60 = v9;
      v61 = 2114;
      v62 = v13;
      v63 = 2050;
      v64 = v14;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] -> Feeding view obstructed event: %{public}@ @ %{public}f", buf, 0x2Au);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v44, v45, v46, v47);
      objc_msgSend_stringForEventType_(CMSuppressionEvent, v48, *(_QWORD *)(a1 + 40), v49, v50);
      v51 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager feedViewObstructedEvent:facedown:timeSinceLastFacedownStatic:timestamp:force:]_block_invoke", "CoreLocation: %s\n", v51);
      if (v51 != (char *)buf)
        free(v51);
    }
    v19 = *(double *)(a1 + 48);
    if (v19 <= v2[9])
    {
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v23 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
      {
        v28 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v24, v25, v26, v27);
        v29 = *((_QWORD *)v2 + 43);
        v30 = *((_QWORD *)v2 + 9);
        v31 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 134349826;
        v58 = v28;
        v59 = 2114;
        v60 = v29;
        v61 = 2050;
        v62 = v30;
        v63 = 2050;
        v64 = v31;
        _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_ERROR, "[%{public}ld][%{public}@] Invalid view obstructed event. Timestamp went backwards! old timestamp,%{public}f, new timestamp %{public}f", buf, 0x2Au);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
        objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v52, v53, v54, v55);
        v56 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager feedViewObstructedEvent:facedown:timeSinceLastFacedownStatic:timestamp:force:]_block_invoke", "CoreLocation: %s\n", v56);
        if (v56 != (char *)buf)
          free(v56);
      }
    }
    else
    {
      v20 = *(_QWORD *)(a1 + 40);
      v21 = *(_QWORD *)(a1 + 56);
      v22 = *(_QWORD *)(a1 + 64);
      v2[9] = v19;
      *((_QWORD *)v2 + 10) = v20;
      *((_QWORD *)v2 + 11) = 1;
      *((_QWORD *)v2 + 12) = v21;
      *((_QWORD *)v2 + 13) = v22;
    }
    objc_msgSend_updateSuppressionStateAndSendToClient(*(void **)(a1 + 32), v15, v16, v17, v18);
  }
  else
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v32 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      v37 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v33, v34, v35, v36);
      v38 = *((_QWORD *)v2 + 43);
      *(_DWORD *)buf = 134349314;
      v58 = v37;
      v59 = 2114;
      v60 = v38;
      _os_log_impl(&dword_18F1DC000, v32, OS_LOG_TYPE_ERROR, "[%{public}ld][%{public}@] Not feeding view obstructed event! Suppression already stopped.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v39, v40, v41, v42);
      v43 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager feedViewObstructedEvent:facedown:timeSinceLastFacedownStatic:timestamp:force:]_block_invoke", "CoreLocation: %s\n", v43);
      if (v43 != (char *)buf)
        free(v43);
    }
  }
}

void sub_18F4BBE00(uint64_t a1)
{
  double *v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint8_t *v22;
  NSObject *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  uint64_t v40;
  NSObject *v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint8_t buf[4];
  uint64_t v75;
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  uint64_t v79;
  __int16 v80;
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v2 = *(double **)(*(_QWORD *)(a1 + 32) + 8);
  if (*((_QWORD *)v2 + 25) || *(_BYTE *)(a1 + 56))
  {
    if (v2[15] == 0.0 && *(_QWORD *)(a1 + 40) == 2)
    {
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v3 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
      {
        v8 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v4, v5, v6, v7);
        v9 = *((_QWORD *)v2 + 43);
        v13 = objc_msgSend_stringForEventType_(CMSuppressionEvent, v10, *(_QWORD *)(a1 + 40), v11, v12);
        v14 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 134349826;
        v75 = v8;
        v76 = 2114;
        v77 = v9;
        v78 = 2114;
        v79 = v13;
        v80 = 2050;
        v81 = v14;
        _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] -> Not feeding smart power nap event: %{public}@ @ %{public}f", buf, 0x2Au);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
        objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v15, v16, v17, v18);
        objc_msgSend_stringForEventType_(CMSuppressionEvent, v19, *(_QWORD *)(a1 + 40), v20, v21);
        v22 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager feedSmartPowerNapEvent:timestamp:force:]_block_invoke", "CoreLocation: %s\n");
LABEL_35:
        if (v22 != buf)
          free(v22);
      }
    }
    else
    {
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v23 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
      {
        v28 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v24, v25, v26, v27);
        v29 = *((_QWORD *)v2 + 43);
        v33 = objc_msgSend_stringForEventType_(CMSuppressionEvent, v30, *(_QWORD *)(a1 + 40), v31, v32);
        v34 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 134349826;
        v75 = v28;
        v76 = 2114;
        v77 = v29;
        v78 = 2114;
        v79 = v33;
        v80 = 2050;
        v81 = v34;
        _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] -> Feeding smart power nap event: %{public}@ @ %{public}f", buf, 0x2Au);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
        objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v61, v62, v63, v64);
        objc_msgSend_stringForEventType_(CMSuppressionEvent, v65, *(_QWORD *)(a1 + 40), v66, v67);
        v68 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager feedSmartPowerNapEvent:timestamp:force:]_block_invoke", "CoreLocation: %s\n", v68);
        if (v68 != (char *)buf)
          free(v68);
      }
      v39 = *(double *)(a1 + 48);
      if (v39 <= v2[15])
      {
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
        v41 = off_1EE16D428;
        if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
        {
          v46 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v42, v43, v44, v45);
          v47 = *((_QWORD *)v2 + 43);
          v48 = *((_QWORD *)v2 + 15);
          v49 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 134349826;
          v75 = v46;
          v76 = 2114;
          v77 = v47;
          v78 = 2050;
          v79 = v48;
          v80 = 2050;
          v81 = v49;
          _os_log_impl(&dword_18F1DC000, v41, OS_LOG_TYPE_ERROR, "[%{public}ld][%{public}@] Invalid smart power nap event. Timestamp went backwards! old timestamp,%{public}f, new timestamp %{public}f", buf, 0x2Au);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D438 != -1)
            dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
          objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v69, v70, v71, v72);
          v73 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager feedSmartPowerNapEvent:timestamp:force:]_block_invoke", "CoreLocation: %s\n", v73);
          if (v73 != (char *)buf)
            free(v73);
        }
      }
      else
      {
        v40 = *(_QWORD *)(a1 + 40);
        v2[15] = v39;
        *((_QWORD *)v2 + 16) = v40;
        *((_QWORD *)v2 + 17) = 2;
        v2[18] = 0.0;
        v2[19] = 0.0;
      }
      objc_msgSend_updateSuppressionStateAndSendToClient(*(void **)(a1 + 32), v35, v36, v37, v38);
    }
  }
  else
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v50 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      v55 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v51, v52, v53, v54);
      v56 = *((_QWORD *)v2 + 43);
      *(_DWORD *)buf = 134349314;
      v75 = v55;
      v76 = 2114;
      v77 = v56;
      _os_log_impl(&dword_18F1DC000, v50, OS_LOG_TYPE_ERROR, "[%{public}ld][%{public}@] Not feeding smart power nap event! Suppression already stopped.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v57, v58, v59, v60);
      v22 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager feedSmartPowerNapEvent:timestamp:force:]_block_invoke", "CoreLocation: %s\n");
      goto LABEL_35;
    }
  }
}

void sub_18F4BC608(uint64_t a1)
{
  double *v2;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint8_t *v22;
  NSObject *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  uint64_t v40;
  NSObject *v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char *v73;
  uint8_t buf[4];
  uint64_t v75;
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  uint64_t v79;
  __int16 v80;
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v2 = *(double **)(*(_QWORD *)(a1 + 32) + 8);
  if (*((_QWORD *)v2 + 26) || *(_BYTE *)(a1 + 56))
  {
    if (v2[20] == 0.0 && *(_QWORD *)(a1 + 40) == 2)
    {
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v3 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
      {
        v8 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v4, v5, v6, v7);
        v9 = *((_QWORD *)v2 + 43);
        v13 = objc_msgSend_stringForEventType_(CMSuppressionEvent, v10, *(_QWORD *)(a1 + 40), v11, v12);
        v14 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 134349826;
        v75 = v8;
        v76 = 2114;
        v77 = v9;
        v78 = 2114;
        v79 = v13;
        v80 = 2050;
        v81 = v14;
        _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] -> Not feeding device presence event: %{public}@ @ %{public}f", buf, 0x2Au);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
        objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v15, v16, v17, v18);
        objc_msgSend_stringForEventType_(CMSuppressionEvent, v19, *(_QWORD *)(a1 + 40), v20, v21);
        v22 = (uint8_t *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager feedDevicePresenceEvent:timestamp:force:]_block_invoke", "CoreLocation: %s\n");
LABEL_35:
        if (v22 != buf)
          free(v22);
      }
    }
    else
    {
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v23 = off_1EE16D428;
      if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
      {
        v28 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v24, v25, v26, v27);
        v29 = *((_QWORD *)v2 + 43);
        v33 = objc_msgSend_stringForEventType_(CMSuppressionEvent, v30, *(_QWORD *)(a1 + 40), v31, v32);
        v34 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 134349826;
        v75 = v28;
        v76 = 2114;
        v77 = v29;
        v78 = 2114;
        v79 = v33;
        v80 = 2050;
        v81 = v34;
        _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_DEFAULT, "[%{public}ld][%{public}@] -> Feeding device presence event: %{public}@ @ %{public}f", buf, 0x2Au);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
        objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v61, v62, v63, v64);
        objc_msgSend_stringForEventType_(CMSuppressionEvent, v65, *(_QWORD *)(a1 + 40), v66, v67);
        v68 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "-[CMSuppressionManager feedDevicePresenceEvent:timestamp:force:]_block_invoke", "CoreLocation: %s\n", v68);
        if (v68 != (char *)buf)
          free(v68);
      }
      v39 = *(double *)(a1 + 48);
      if (v39 <= v2[20])
      {
        if (qword_1EE16D438 != -1)
          dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
        v41 = off_1EE16D428;
        if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
        {
          v46 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v42, v43, v44, v45);
          v47 = *((_QWORD *)v2 + 43);
          v48 = *((_QWORD *)v2 + 20);
          v49 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 134349826;
          v75 = v46;
          v76 = 2114;
          v77 = v47;
          v78 = 2050;
          v79 = v48;
          v80 = 2050;
          v81 = v49;
          _os_log_impl(&dword_18F1DC000, v41, OS_LOG_TYPE_ERROR, "[%{public}ld][%{public}@] Invalid device presence event. Timestamp went backwards! old timestamp,%{public}f, new timestamp %{public}f", buf, 0x2Au);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1EE16D438 != -1)
            dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
          objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v69, v70, v71, v72);
          v73 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager feedDevicePresenceEvent:timestamp:force:]_block_invoke", "CoreLocation: %s\n", v73);
          if (v73 != (char *)buf)
            free(v73);
        }
      }
      else
      {
        v40 = *(_QWORD *)(a1 + 40);
        v2[20] = v39;
        *((_QWORD *)v2 + 21) = v40;
        *((_QWORD *)v2 + 22) = 4;
        v2[23] = 0.0;
        v2[24] = 0.0;
      }
      objc_msgSend_updateSuppressionStateAndSendToClient(*(void **)(a1 + 32), v35, v36, v37, v38);
    }
  }
  else
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v50 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_ERROR))
    {
      v55 = objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v51, v52, v53, v54);
      v56 = *((_QWORD *)v2 + 43);
      *(_DWORD *)buf = 134349314;
      v75 = v55;
      v76 = 2114;
      v77 = v56;
      _os_log_impl(&dword_18F1DC000, v50, OS_LOG_TYPE_ERROR, "[%{public}ld][%{public}@] Not feeding device presence event! Suppression already stopped.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      objc_msgSend_suppressionClientType(*(void **)(a1 + 32), v57, v58, v59, v60);
      v22 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager feedDevicePresenceEvent:timestamp:force:]_block_invoke", "CoreLocation: %s\n");
      goto LABEL_35;
    }
  }
}

void sub_18F4BD868(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4BD890(uint64_t a1)
{
  double Current;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  char *v20;
  _QWORD v21[5];
  int v22;
  double v23;
  uint8_t buf[4];
  double v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v7 = objc_msgSend_syncState(*(void **)(*(_QWORD *)(a1 + 32) + 200), v3, v4, v5, v6);
  v11 = CFAbsoluteTimeGetCurrent() - Current;
  if (v11 > 10.0)
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v12 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134349056;
      v25 = v11;
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_FAULT, "SmartPowerNap syncState took longer than 10s to return. Waited: %{public}f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      v22 = 134349056;
      v23 = v11;
      v20 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMSuppressionManager startSuppressionUpdatesPrivateToQueue:withOptions:withHandler:]_block_invoke", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf)
        free(v20);
    }
  }
  objc_msgSend_handleSmartPowerNapState_(*(void **)(a1 + 40), v8, v7, v9, v10);
  v13 = *(_QWORD *)(a1 + 32);
  v14 = *(_QWORD *)(a1 + 40);
  v15 = *(void **)(v13 + 200);
  v16 = *(_QWORD *)(v13 + 64);
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = sub_18F4BDABC;
  v21[3] = &unk_1E29591C0;
  v21[4] = v14;
  return objc_msgSend_registerWithCallback_callback_(v15, v17, v16, (uint64_t)v21, v18);
}

uint64_t sub_18F4BDABC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_handleSmartPowerNapState_(*(void **)(a1 + 32), a2, (uint64_t)a2, a4, a5);
}

uint64_t sub_18F4BE1AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_sendViewObstructedStateToClientPrivate_, a3, a4, a5);
}

uint64_t sub_18F4BE394(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[6];
  char v11;

  v5 = *(_QWORD *)(result + 40);
  *(_BYTE *)(*(_QWORD *)(result + 32) + 16) = *(_BYTE *)(result + 48);
  *(_QWORD *)(*(_QWORD *)(result + 32) + 24) = v5;
  v6 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  v7 = *(void **)(v6 + 312);
  if (v7)
  {
    v8 = *(_QWORD *)(v6 + 320);
    if (v8)
    {
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 3221225472;
      v10[2] = sub_18F4BE420;
      v10[3] = &unk_1E29591E8;
      v11 = *(_BYTE *)(result + 48);
      v9 = *(_QWORD *)(result + 40);
      v10[4] = v8;
      v10[5] = v9;
      return objc_msgSend_addOperationWithBlock_(v7, a2, (uint64_t)v10, a4, a5);
    }
  }
  return result;
}

uint64_t sub_18F4BE420(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 48), *(_QWORD *)(a1 + 40), 0);
}

uint64_t sub_18F4BE618(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 233) = 1;
  objc_msgSend_sendViewObstructedRequestPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel_startViewObstructedStateUpdatesPrivateToQueue_withHandler_, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), v6);
}

uint64_t sub_18F4BE820(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 233) = 0;
  objc_msgSend_sendViewObstructedRequestPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
  return objc_msgSend_stopViewObstructedStateUpdatesPrivate(*(void **)(a1 + 32), v6, v7, v8, v9);
}

void sub_18F4BEC50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_18F4BEC74(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

void sub_18F4BEDD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void sub_18F4BF604()
{
  uint64_t v0;
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  int v5;
  int v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  char *v10;
  BOOL v11[16];
  uint8_t buf[8];
  std::__shared_weak_count *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v0 = sub_18F204AE4();
  v1 = *(_QWORD *)(v0 + 24);
  v2 = *(std::__shared_weak_count **)(v0 + 32);
  *(_QWORD *)buf = v1;
  v13 = v2;
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  v11[0] = 0;
  v5 = sub_18F1EE944(v1, "EnableSuppressionManagerOnUnsupportedHardware", v11);
  if (v11[0])
    v6 = v5;
  else
    v6 = 0;
  byte_1EE16E430 = v6;
  if (v2)
  {
    v7 = (unint64_t *)&v2->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    v6 = byte_1EE16E430;
  }
  if (v6)
  {
    if (qword_1EE16D438 != -1)
      dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
    v9 = off_1EE16D428;
    if (os_log_type_enabled((os_log_t)off_1EE16D428, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEFAULT, "Default to enable suppression manager on unsupported hardware is enabled!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D438 != -1)
        dispatch_once(&qword_1EE16D438, &unk_1E2954C28);
      *(_WORD *)v11 = 0;
      v10 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL isSuppressionAvailablePrivate()_block_invoke", "CoreLocation: %s\n", v10);
      if (v10 != (char *)buf)
        free(v10);
    }
  }
}

void sub_18F4BF81C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(exception_object);
}

os_log_t sub_18F4BF838()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Eclipse");
  off_1EE16D428 = result;
  return result;
}

Class sub_18F4BF864()
{
  Class result;

  if (qword_1EE16E448 != -1)
    dispatch_once(&qword_1EE16E448, &unk_1E2954C88);
  result = objc_getClass("_PMSmartPowerNap");
  qword_1EE16E440 = (uint64_t)result;
  off_1ECEDEEA0[0] = sub_18F4BF8C0;
  return result;
}

uint64_t sub_18F4BF8C0()
{
  return qword_1EE16E440;
}

void *sub_18F4BF8CC()
{
  void *result;

  result = dlopen("/System/Library/PrivateFrameworks/LowPowerMode.framework/LowPowerMode", 2);
  qword_1EE16E460 = (uint64_t)result;
  return result;
}

Class sub_18F4BF8F4()
{
  Class result;

  if (qword_1EE16E458 != -1)
    dispatch_once(&qword_1EE16E458, &unk_1E2959208);
  result = objc_getClass("DPCManager");
  qword_1EE16E450 = (uint64_t)result;
  off_1ECEDEEA8[0] = sub_18F4BF950;
  return result;
}

uint64_t sub_18F4BF950()
{
  return qword_1EE16E450;
}

void *sub_18F4BF95C()
{
  void *result;

  result = dlopen("/System/Library/PrivateFrameworks/DevicePresence.framework/DevicePresence", 2);
  qword_1EE16E468 = (uint64_t)result;
  return result;
}

void sub_18F4BF988(uint64_t a1)
{
  sub_18F1E932C(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4BF9AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 16))(a3, *(_QWORD *)(a1 + 24));
}

void sub_18F4BF9BC(uint64_t a1)
{
  sub_18F1E932C(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4BF9E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 16))(a3, *(_QWORD *)(a1 + 24));
}

void sub_18F4BF9F0(uint64_t a1)
{
  sub_18F1E932C(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4BFA14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 16))(a3, *(_QWORD *)(a1 + 24));
}

uint64_t sub_18F4C00BC(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  int v4;
  unsigned int v5;
  unsigned __int8 *v6;

  v2 = 0;
  result = 0;
  v4 = *(_DWORD *)(a1 + 8);
  do
  {
    if (v4)
    {
      --v4;
      v5 = *(unsigned __int8 *)(a1 + 12);
    }
    else
    {
      v6 = (unsigned __int8 *)(*(_QWORD *)a1)++;
      v5 = *v6;
      *(_BYTE *)(a1 + 12) = v5;
      v4 = 7;
    }
    *(_DWORD *)(a1 + 8) = v4;
    result |= (unint64_t)((v5 >> v4) & 1) << v2++;
  }
  while (v2 != 64);
  return result;
}

uint64_t sub_18F4C0118(uint64_t result, int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  unsigned int v5;
  unsigned __int8 *v6;

  if (!a2)
    return 0;
  v2 = result;
  v3 = 0;
  LODWORD(result) = 0;
  v4 = *(_DWORD *)(v2 + 8);
  do
  {
    if (v4)
    {
      --v4;
      v5 = *(unsigned __int8 *)(v2 + 12);
    }
    else
    {
      v6 = (unsigned __int8 *)(*(_QWORD *)v2)++;
      v5 = *v6;
      *(_BYTE *)(v2 + 12) = v5;
      v4 = 7;
    }
    *(_DWORD *)(v2 + 8) = v4;
    result = (((v5 >> v4) & 1) << v3++) | result;
  }
  while (a2 != v3);
  return result;
}

uint64_t sub_18F4C0180(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t result;
  uint64_t v5;

  v2 = sub_18F4C0118(a1, 4);
  v3 = ((v2 << 28 >> 31) & 0xFFFFFFF0) + v2;
  if (v3 == -8)
  {
    result = sub_18F4C00BC(a1);
    v5 = *(_QWORD *)(a1 + 16);
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 16);
    result = v5 + v3 + *(_QWORD *)(a1 + 24);
  }
  *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 24) = result - v5;
  return result;
}

float sub_18F4C01DC@<S0>(int *a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int v6;
  uint64_t v7;
  float result;
  int32x2_t v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v7 = sub_18F4C0180((uint64_t)a1);
  sub_18F4C029C((uint64_t)a1, (uint64_t)&v9, (uint64_t)(a1 + 8));
  *a2 = *a1 - v6;
  *(float32x2_t *)a3 = vmul_f32(vcvt_f32_s32(v9), (float32x2_t)vdup_n_s32(0x39800000u));
  result = (float)v10 * 0.00024414;
  *(float *)(a3 + 8) = result;
  *(_QWORD *)(a3 + 12) = v7;
  return result;
}

uint64_t sub_18F4C029C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t result;
  int v9;
  int v10;

  v6 = 0;
  v7 = byte_18F509A29[(int)sub_18F4C0118(a1, 3)];
  do
  {
    result = sub_18F4C0118(a1, v7);
    if ((result & (1 << (v7 - 1))) != 0)
      v9 = -1 << v7;
    else
      v9 = 0;
    v10 = *(_DWORD *)(a3 + v6) + result + v9;
    *(_DWORD *)(a2 + v6) = v10;
    *(_DWORD *)(a3 + v6) = v10;
    v6 += 4;
  }
  while (v6 != 12);
  return result;
}

float32x4_t sub_18F4C0338@<Q0>(int *a1@<X0>, _DWORD *a2@<X1>, float32x4_t *a3@<X8>)
{
  int v6;
  uint64_t v7;
  float32x4_t result;
  int32x4_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v7 = sub_18F4C0180((uint64_t)a1);
  sub_18F4C03E4((uint64_t)a1, (uint64_t)&v9, (uint64_t)(a1 + 8));
  *a2 = *a1 - v6;
  result = vmulq_f32(vcvtq_f32_s32(v9), (float32x4_t)vdupq_n_s32(0x3D800000u));
  *a3 = result;
  a3[1].i64[0] = v7;
  return result;
}

uint64_t sub_18F4C03E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t result;
  int v9;
  int v10;

  v6 = 0;
  v7 = byte_18F509A31[(int)sub_18F4C0118(a1, 3)];
  do
  {
    result = sub_18F4C0118(a1, v7);
    if ((result & (1 << (v7 - 1))) != 0)
      v9 = -1 << v7;
    else
      v9 = 0;
    v10 = *(_DWORD *)(a3 + v6) + result + v9;
    *(_DWORD *)(a2 + v6) = v10;
    *(_DWORD *)(a3 + v6) = v10;
    v6 += 4;
  }
  while (v6 != 16);
  return result;
}

float32x2_t sub_18F4C0480@<D0>(int *a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int v6;
  uint64_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t result;
  int32x2_t v16[2];

  v16[1] = *(int32x2_t *)MEMORY[0x1E0C80C00];
  v6 = *a1;
  v7 = sub_18F4C0180((uint64_t)a1);
  sub_18F4C0548((uint64_t)a1, (uint64_t)v16, (uint64_t)(a1 + 8));
  *a2 = *a1 - v6;
  v8 = (float32x2_t)vdup_n_s32(0x39800000u);
  v9 = vmul_f32(vcvt_f32_s32(v16[0]), v8);
  v8.i32[0] = 1119092736;
  v8.i32[0] = vadd_f32(v9, v8).u32[0];
  __asm { FMOV            V2.2S, #10.0 }
  result = vmul_f32(v9, _D2);
  v8.i32[1] = result.i32[1];
  *(float32x2_t *)a3 = v8;
  *(_DWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 12) = v7;
  return result;
}

uint64_t sub_18F4C0548(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  char v8;
  char v9;
  uint64_t result;
  int v11;
  int v12;

  v6 = 0;
  v7 = byte_18F509A39[(int)sub_18F4C0118(a1, 3)];
  v8 = 1;
  do
  {
    v9 = v8;
    result = sub_18F4C0118(a1, v7);
    v8 = 0;
    if ((result & (1 << (v7 - 1))) != 0)
      v11 = -1 << v7;
    else
      v11 = 0;
    v12 = *(_DWORD *)(a3 + 4 * v6) + result + v11;
    *(_DWORD *)(a2 + 4 * v6) = v12;
    *(_DWORD *)(a3 + 4 * v6) = v12;
    v6 = 1;
  }
  while ((v9 & 1) != 0);
  return result;
}

Class sub_18F4C06AC()
{
  Class result;

  if (qword_1EE16E870 != -1)
    dispatch_once(&qword_1EE16E870, &unk_1E29542E8);
  result = objc_getClass("NRPairedDeviceRegistry");
  qword_1EE16E868 = (uint64_t)result;
  off_1ECEDEEB0[0] = sub_18F4C0708;
  return result;
}

uint64_t sub_18F4C0708()
{
  return qword_1EE16E868;
}

void *sub_18F4C0714()
{
  void *result;

  result = dlopen("/System/Library/PrivateFrameworks/NanoRegistry.framework/NanoRegistry", 2);
  qword_1EE16E878 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4C073C()
{
  uint64_t *v0;
  uint64_t result;

  if (qword_1EE16E870 != -1)
    dispatch_once(&qword_1EE16E870, &unk_1E29542E8);
  v0 = (uint64_t *)dlsym((void *)qword_1EE16E878, "NRDevicePropertyIsAltAccount");
  if (v0)
  {
    result = *v0;
    qword_1EE16E880 = result;
  }
  else
  {
    result = qword_1EE16E880;
  }
  off_1ECEDEEB8[0] = sub_18F4C07B4;
  return result;
}

uint64_t sub_18F4C07B4()
{
  return qword_1EE16E880;
}

double sub_18F4C07C0(uint64_t a1)
{
  double result;

  *(_QWORD *)a1 = &off_1E294ACB8;
  *(_QWORD *)(a1 + 8) = 0x1000000000;
  *(_QWORD *)(a1 + 228) = 0;
  *(_QWORD *)(a1 + 233) = 0;
  *(_BYTE *)(a1 + 244) = 1;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_QWORD *)(a1 + 272) = 0x2000000000;
  *(_QWORD *)(a1 + 408) = 0;
  *(_WORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 420) = 973279855;
  *(int32x2_t *)(a1 + 424) = vdup_n_s32(0x3A03126Fu);
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_QWORD *)(a1 + 464) = 0;
  *(_QWORD *)(a1 + 472) = 1;
  *(_DWORD *)(a1 + 480) = 32;
  *(_DWORD *)(a1 + 492) = 0;
  *(_QWORD *)(a1 + 484) = 0;
  *(_DWORD *)(a1 + 496) = 1065353216;
  *(_BYTE *)(a1 + 500) = 0;
  *(_QWORD *)(a1 + 504) = 0xA00000000;
  *(_DWORD *)(a1 + 672) = 1065353216;
  *(_QWORD *)(a1 + 680) = 0x500000000;
  *(_QWORD *)(a1 + 728) = 0x500000000;
  *(_DWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 813) = 0;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_QWORD *)&result = 1003306496;
  *(_OWORD *)(a1 + 212) = xmmword_18F509A50;
  return result;
}

int32x2_t sub_18F4C088C(uint64_t a1)
{
  int32x2_t result;

  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_BYTE *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 452) = 0;
  *(_QWORD *)(a1 + 444) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_BYTE *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 800) = 0u;
  *(_DWORD *)(a1 + 816) = 0;
  *(_DWORD *)(a1 + 420) = 973279855;
  result = vdup_n_s32(0x3A03126Fu);
  *(int32x2_t *)(a1 + 424) = result;
  *(_QWORD *)(a1 + 456) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  *(_QWORD *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 440) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 244) = 1;
  *(_QWORD *)(a1 + 484) = 0;
  *(_QWORD *)(a1 + 492) = 0x3F80000000000000;
  *(_DWORD *)(a1 + 504) = 0;
  *(_BYTE *)(a1 + 500) = 0;
  *(_DWORD *)(a1 + 672) = 1065353216;
  *(_DWORD *)(a1 + 680) = 0;
  *(_DWORD *)(a1 + 728) = 0;
  *(_BYTE *)(a1 + 820) = 0;
  return result;
}

float sub_18F4C0928(uint64_t a1, float32x2_t *a2, uint64_t a3)
{
  float result;

  sub_18F33FACC((unsigned __int16 *)(a1 + 8), (uint64_t)a2);
  sub_18F3F8790((float32x2_t *)(a1 + 208), a2);
  *(_QWORD *)(a1 + 228) = *(_QWORD *)(a1 + 808);
  *(_DWORD *)(a1 + 236) = *(_DWORD *)(a1 + 816);
  *(_BYTE *)(a1 + 240) = sub_18F4C09A8(a1, *(_QWORD *)(a1 + 800), a1 + 228);
  *(_QWORD *)(a1 + 800) = a3;
  *(_DWORD *)(a1 + 808) = a2->i32[0];
  *(_DWORD *)(a1 + 812) = a2->i32[1];
  result = a2[1].f32[0];
  *(float *)(a1 + 816) = result;
  return result;
}

uint64_t sub_18F4C09A8(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t result;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  unint64_t v16;
  unint64_t v17;
  float32x2_t *v18;
  float v19;
  int v20;
  int v21;
  unint64_t v22;
  unint64_t *v23;
  float32x2_t *v24;
  uint64_t v25;
  float v26;
  int v27;
  int v28;
  float v29;
  float32x2_t v30;
  float v31;
  float32x2_t v32;
  float v33;

  v3 = *(unsigned __int16 *)(a1 + 682);
  if (*(_DWORD *)(a1 + 684) != (_DWORD)v3)
    return 0;
  v4 = a2;
  v6 = *(unsigned __int16 *)(a1 + 680);
  if (*(_QWORD *)(a1 + 688 + 8 * v6) > a2)
    return 0;
  v7 = v3 + v6 - 1;
  v8 = v7 >= v3 ? *(unsigned __int16 *)(a1 + 682) : 0;
  v9 = *(_QWORD *)(a1 + 688 + 8 * (v7 - v8));
  if (v9 + 10000 < a2)
    return 0;
  v12 = v9 >= a2;
  v13 = v9 - a2;
  if (!v12)
  {
    v14 = 0;
    v15 = (float)v13 * 0.000001;
    v16 = *(unsigned __int16 *)(a1 + 728) + (unint64_t)*(unsigned __int16 *)(a1 + 730) - 1;
    v17 = *(unsigned int *)(a1 + 732);
    if (v16 < v17)
      v17 = 0;
    v18 = (float32x2_t *)(a1 + 728 + 12 * (v16 - v17));
    v19 = v15 * v18[2].f32[0];
    v32 = vmul_n_f32(v18[1], v15);
    v33 = v19;
    do
    {
      v32.f32[v14] = -v32.f32[v14];
      ++v14;
    }
    while (v14 != 3);
    v30 = v32;
    v31 = v33;
    sub_18F45CBF8((float *)&v30, (uint64_t)&v32);
    *(float *)a3 = sub_18F3D3930((uint64_t)&v32, (float *)a3);
    *(_DWORD *)(a3 + 4) = v20;
    *(_DWORD *)(a3 + 8) = v21;
    return 1;
  }
  if ((_DWORD)v3 == 1)
    return 1;
  v22 = 0;
  do
  {
    v23 = (unint64_t *)sub_18F383E04((unsigned __int16 *)(a1 + 680), v22++);
    if (v4 >= *v23 && v4 < *(_QWORD *)sub_18F383E04((unsigned __int16 *)(a1 + 680), v22))
    {
      v29 = (float)(*(_QWORD *)sub_18F383E04((unsigned __int16 *)(a1 + 680), v22) - v4) * 0.000001;
      v24 = (float32x2_t *)sub_18F33FF64((unsigned __int16 *)(a1 + 728), v22);
      v25 = 0;
      v26 = v29 * v24[1].f32[0];
      v32 = vmul_n_f32(*v24, v29);
      v33 = v26;
      do
      {
        v32.f32[v25] = -v32.f32[v25];
        ++v25;
      }
      while (v25 != 3);
      v30 = v32;
      v31 = v33;
      sub_18F45CBF8((float *)&v30, (uint64_t)&v32);
      *(float *)a3 = sub_18F3D3930((uint64_t)&v32, (float *)a3);
      *(_DWORD *)(a3 + 4) = v27;
      *(_DWORD *)(a3 + 8) = v28;
      v4 = *(_QWORD *)sub_18F383E04((unsigned __int16 *)(a1 + 680), v22);
    }
    result = 1;
  }
  while (v22 < (unint64_t)*(unsigned __int16 *)(a1 + 682) - 1);
  return result;
}

void sub_18F4C0C0C(uint64_t a1, float32x2_t *a2, unint64_t a3)
{
  float32x2_t *v6;
  __int32 v7;
  float v8;
  float32x2_t v9;
  float v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  int v16;
  uint64_t v17;
  float v18;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  float v22;
  float32x4_t v23;
  unsigned __int8 v24;
  unint64_t v25;
  float v26;
  uint64_t v27;
  float32x4_t v28;
  unsigned int v29;
  float32x4_t v30;
  float32x2_t v31;
  float v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x2_t v35;
  float v36;

  if (*(_BYTE *)(a1 + 416))
  {
    v6 = (float32x2_t *)(a1 + 444);
    if (*(_BYTE *)(a1 + 820))
    {
      *(_QWORD *)(a1 + 256) = 0;
      *(_QWORD *)(a1 + 264) = 0;
      *(_DWORD *)(a1 + 272) = 0;
      *(_BYTE *)(a1 + 244) = 1;
      v9.i32[0] = a2->i32[0];
      *(_DWORD *)(a1 + 456) = a2->i32[0];
      v7 = a2->i32[1];
      *(_DWORD *)(a1 + 460) = v7;
      v8 = a2[1].f32[0];
      *(float *)(a1 + 464) = v8;
      *(_QWORD *)(a1 + 484) = 0;
      *(_QWORD *)(a1 + 492) = 0x3F80000000000000;
      *(_DWORD *)(a1 + 504) = 0;
      *(_BYTE *)(a1 + 500) = 0;
      *(_DWORD *)(a1 + 672) = 1065353216;
      *(_BYTE *)(a1 + 820) = 0;
      v9.i32[1] = v7;
    }
    else
    {
      v9 = *(float32x2_t *)(a1 + 456);
      v8 = *(float *)(a1 + 464);
    }
    v10 = (float)((float)(v8 + a2[1].f32[0]) * 0.5) - *(float *)(a1 + 452);
    v35 = vsub_f32(vmul_f32(vadd_f32(v9, *a2), (float32x2_t)0x3F0000003F000000), *v6);
    v36 = v10;
    v11 = *(unsigned __int16 *)(a1 + 682);
    v12 = *(unsigned int *)(a1 + 684);
    v13 = *(unsigned __int16 *)(a1 + 680);
    if (v13 + v11 >= v12)
      v14 = *(unsigned int *)(a1 + 684);
    else
      v14 = 0;
    *(_QWORD *)(a1 + 680 + 8 * (v13 + v11 - v14) + 8) = a3;
    if (v12 <= v11)
    {
      if (v13 + 1 < v12)
        LOWORD(v12) = 0;
      *(_WORD *)(a1 + 680) = v13 + 1 - v12;
    }
    else
    {
      *(_WORD *)(a1 + 682) = v11 + 1;
    }
    sub_18F33FACC((unsigned __int16 *)(a1 + 728), (uint64_t)&v35);
    v15 = a2[1].f32[0] - *(float *)(a1 + 452);
    *(float32x2_t *)(a1 + 432) = vsub_f32(*a2, *v6);
    *(float *)(a1 + 440) = v15;
    *(_DWORD *)(a1 + 456) = a2->i32[0];
    *(_DWORD *)(a1 + 460) = a2->i32[1];
    *(_DWORD *)(a1 + 464) = a2[1].i32[0];
    v16 = *(_DWORD *)(a1 + 476) + 1;
    *(_DWORD *)(a1 + 476) = v16;
    if (v16 == *(_DWORD *)(a1 + 472))
    {
      v17 = 0;
      v18 = 0.0;
      do
      {
        v18 = v18 + (float)(*(float *)(a1 + 432 + v17) * *(float *)(a1 + 432 + v17));
        v17 += 4;
      }
      while (v17 != 12);
      v34.i32[0] = sqrtf(v18);
      sub_18F33D300(a1 + 244, v34.f32);
      *(_DWORD *)(a1 + 476) = 0;
    }
    v19 = *(_QWORD *)(a1 + 408);
    if (v19)
    {
      v20 = a3 >= v19;
      v21 = a3 - v19;
      if (v21 != 0 && v20)
      {
        v22 = (float)(*(float *)(a1 + 440) * (float)v21) * 0.000001;
        v31 = vmul_f32(vmul_n_f32(*(float32x2_t *)(a1 + 432), (float)v21), (float32x2_t)vdup_n_s32(0x358637BDu));
        v32 = v22;
        *(double *)v23.i64 = sub_18F3D3AA8(&v33, (float *)&v31);
        sub_18F3D3764((uint64_t)&v33, (float *)(a1 + 484), &v34, v23);
        *(float32x4_t *)(a1 + 484) = v34;
      }
    }
    v24 = *(_BYTE *)(a1 + 500) + 1;
    *(_BYTE *)(a1 + 500) = v24;
    if ((*(_DWORD *)(a1 + 468) * v24) >> 4 >= 0x753)
    {
      sub_18F3F8818((unsigned __int16 *)(a1 + 504), (_OWORD *)(a1 + 484));
      *(_BYTE *)(a1 + 500) = 0;
    }
    if (*(_DWORD *)(a1 + 508) == *(unsigned __int16 *)(a1 + 506))
    {
      v25 = 0;
      v26 = 1.0;
      do
      {
        v27 = sub_18F3FFD58((unsigned __int16 *)(a1 + 504), v25);
        v28.f32[0] = -*(float *)(a1 + 492);
        v29 = *(_DWORD *)(a1 + 496);
        *(float32x2_t *)v33.f32 = vneg_f32(v6[5]);
        v33.i64[1] = __PAIR64__(v29, v28.u32[0]);
        v30 = sub_18F1FFE94(&v33, v28);
        sub_18F3D3764(v27, v33.f32, &v34, v30);
        if (v26 >= v34.f32[3])
          v26 = v34.f32[3];
        ++v25;
      }
      while (v25 != 10);
      *(float *)(a1 + 672) = v26;
    }
    *(_QWORD *)(a1 + 408) = a3;
  }
}

BOOL sub_18F4C0F00(uint64_t a1)
{
  unsigned __int16 *v2;
  float v3;
  uint64_t v4;
  int v5;
  int v6;
  float v7;
  float v8;
  uint64_t v9;
  float v10;
  int v11;
  int v12;
  float v13;
  float v15;
  int v16;
  int v17;

  v2 = (unsigned __int16 *)(a1 + 8);
  v3 = sub_18F3403AC((unsigned __int16 *)(a1 + 8), 0, *(unsigned __int16 *)(a1 + 10));
  v4 = 0;
  v15 = v3;
  v16 = v5;
  v17 = v6;
  v7 = 0.0;
  do
  {
    v7 = v7 + (float)(*(float *)((char *)&v15 + v4) * *(float *)((char *)&v15 + v4));
    v4 += 4;
  }
  while (v4 != 12);
  v8 = sqrtf(v7) + -1.0;
  if (v8 <= 0.0)
    v8 = -v8;
  if (v8 >= 0.05)
    return 0;
  sub_18F38D4E4(v2, 0, *(unsigned __int16 *)(a1 + 10));
  v9 = 0;
  v15 = v10;
  v16 = v11;
  v17 = v12;
  v13 = 0.0;
  do
  {
    v13 = v13 + (float)(*(float *)((char *)&v15 + v9) * *(float *)((char *)&v15 + v9));
    v9 += 4;
  }
  while (v9 != 12);
  return sqrtf(v13) < 0.01;
}

uint64_t sub_18F4C0FE4(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(result + 417) = *(_QWORD *)(a2 + 64) != 0;
  return result;
}

_QWORD *sub_18F4C0FF8(_QWORD *result)
{
  *result = &off_1E294ACB8;
  return result;
}

void sub_18F4C1008(_QWORD *a1)
{
  *a1 = &off_1E294ACB8;
  JUMPOUT(0x194001438);
}

void sub_18F4C1288(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;
  int v18;
  float v19;
  float v20;
  float v21;
  uint64_t i;
  float v23;
  float v24;
  float v25;
  float v26;
  NSObject *v27;
  NSObject *v28;
  char *v29;
  _BYTE v30[4];
  float v31;
  int v32;
  _DWORD v33[3];
  int v34;
  double v35;
  __int16 v36;
  double v37;
  __int16 v38;
  double v39;
  __int16 v40;
  double v41;
  uint8_t buf[4];
  double v43;
  __int16 v44;
  double v45;
  __int16 v46;
  double v47;
  __int16 v48;
  double v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  sub_18F33FACC((unsigned __int16 *)a1, a2);
  if (a5 != 2)
  {
    v9 = *(unsigned __int16 *)(a1 + 2);
    if (v9 >= 0x1F)
    {
      v10 = sub_18F3403AC((unsigned __int16 *)a1, 0, v9);
      v12 = v11;
      v14 = v13;
      *(float *)v33 = v10;
      *(float *)&v33[1] = v11;
      *(float *)&v33[2] = v13;
      sub_18F38D4E4((unsigned __int16 *)a1, 0, *(unsigned __int16 *)(a1 + 2));
      v17 = 0;
      v31 = v16;
      v32 = v18;
      v19 = 0.0;
      do
      {
        v19 = v19 + (float)(*(float *)&v33[v17] * *(float *)&v33[v17]);
        ++v17;
      }
      while (v17 != 3);
      v20 = sqrtf(v19) + -1.0;
      if (v15 <= 0.0)
        v21 = -v15;
      else
        v21 = v15;
      for (i = 4; i != 12; i += 4)
      {
        v23 = *(float *)&v30[i];
        if (v23 <= 0.0)
          v23 = -v23;
        if (v23 > v21)
          v21 = v23;
      }
      v24 = -v20;
      if (v20 > 0.0)
        v24 = v20;
      if (v21 < 0.000002 && v24 < 0.05)
      {
        v25 = -v14;
        if (v14 > 0.0)
          v25 = v14;
        v26 = v25 + -1.0;
        if (v26 <= 0.0)
          v26 = -v26;
        if (v26 <= 0.05)
        {
          if (qword_1ECEDEE88 != -1)
            dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
          v27 = off_1ECEDEE80;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134218752;
            v43 = v10;
            v44 = 2048;
            v45 = v12;
            v46 = 2048;
            v47 = v14;
            v48 = 2048;
            v49 = v21;
            _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_DEBUG, "[Gesture] Grabbing reference pose while static, %.3f, %.3f, %.3f, varInfNorm, %.8f", buf, 0x2Au);
          }
          if (!sub_18F1FCA08(115, 2))
            goto LABEL_45;
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE88 != -1)
            dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
          v34 = 134218752;
          v35 = v10;
          v36 = 2048;
          v37 = v12;
          v38 = 2048;
          v39 = v14;
          v40 = 2048;
          v41 = v21;
          goto LABEL_50;
        }
      }
      if (a5 == 1 && a4 && !*(_QWORD *)(a1 + 752))
      {
        if (v15 <= v16)
        {
          v15 = v16;
          if (v16 < 0.00008)
          {
LABEL_40:
            if (qword_1ECEDEE88 != -1)
              dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
            v28 = off_1ECEDEE80;
            if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_DEBUG, "[Gesture] Getting new reference in StableState when no reference is available yet.", buf, 2u);
            }
            if (!sub_18F1FCA08(115, 2))
              goto LABEL_45;
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE88 != -1)
              dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
            LOWORD(v34) = 0;
LABEL_50:
            v29 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CMPickupDetector::StaticReference::feedBufferAndCalcReference(const CMVector3d &, uint64_t, uint64_t, DetectionState)", "CoreLocation: %s\n", v29);
            if (v29 != (char *)buf)
              free(v29);
LABEL_45:
            *(_QWORD *)(a1 + 752) = a3;
            *(float *)(a1 + 760) = sqrtf((float)(v12 * v12) + (float)(v10 * v10));
            return;
          }
        }
        else if (v15 < 0.00008)
        {
          goto LABEL_40;
        }
        if ((unint64_t)(a3 - a4) >= 0x1E8481 && v15 < 0.0004)
          goto LABEL_40;
      }
    }
  }
}

uint64_t sub_18F4C1700(unsigned __int8 *a1, float32x2_t *a2, unint64_t a3)
{
  uint64_t v5;
  int v6;
  uint64_t v8;
  int v9;

  sub_18F3F8790((float32x2_t *)a1 + 1, a2);
  v5 = *((_QWORD *)a1 + 5) - 1;
  *((_QWORD *)a1 + 5) = v5;
  if (!v5)
  {
    *((_QWORD *)a1 + 5) = *((_QWORD *)a1 + 4);
    v6 = *((_DWORD *)a1 + 6);
    v8 = *((_QWORD *)a1 + 2);
    v9 = v6;
    sub_18F4C1288((uint64_t)(a1 + 48), (uint64_t)&v8, a3, *((_QWORD *)a1 + 105), *a1);
    *((_QWORD *)a1 + 102) = a3;
    sub_18F4C1788((uint64_t)a1, (float *)&v8, a3);
  }
  return *a1;
}

uint64_t sub_18F4C1788(uint64_t a1, float *a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t result;

  v3 = a3;
  if (*(_BYTE *)a1 == 1)
  {
    result = sub_18F4C1D20(a1, a2, a3);
    if (!(_DWORD)result)
      return result;
    v3 = 0;
    *(_BYTE *)a1 = 2;
    *(_QWORD *)(a1 + 800) = 0;
    *(_DWORD *)(a1 + 808) = 0;
    *(_DWORD *)(a1 + 836) = 0;
  }
  else
  {
    result = sub_18F4C17FC(a1, a3);
    if (!(_DWORD)result)
      return result;
    *(_BYTE *)a1 = 1;
    *(_QWORD *)(a1 + 832) = 0;
  }
  *(_QWORD *)(a1 + 840) = v3;
  return result;
}

uint64_t sub_18F4C17FC(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t result;
  uint64_t v6;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  _BOOL4 v15;
  NSObject *v16;
  int v17;
  float v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  BOOL v22;
  int v23;
  char *v24;
  char *v25;
  uint8_t buf[4];
  _BYTE v27[14];
  __int16 v28;
  double v29;
  __int16 v30;
  double v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned __int16 *)(a1 + 50);
  if (v2 < 0x1F)
    return 0;
  v6 = *(_QWORD *)(a1 + 800);
  if (v6 == a2 && v6 - 1 < a2)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
    v21 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v21, OS_LOG_TYPE_DEBUG, "[Gesture] Entered Stable state from being static/frozen", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      return 1;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 == -1)
    {
LABEL_43:
      v25 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL CMPickupDetector::checkForStable(uint64_t)", "CoreLocation: %s\n", v25);
      if (v25 != (char *)buf)
        free(v25);
      return 1;
    }
LABEL_45:
    dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
    goto LABEL_43;
  }
  v8 = sub_18F3403AC((unsigned __int16 *)(a1 + 48), 0, v2);
  v10 = v9;
  sub_18F38D4E4((unsigned __int16 *)(a1 + 48), 0, *(unsigned __int16 *)(a1 + 50));
  v13 = sqrtf((float)(v10 * v10) + (float)(v8 * v8));
  if (v11 <= v12)
    v14 = v12;
  else
    v14 = v11;
  v15 = v13 <= 0.35 && v14 < 0.0004;
  if (qword_1ECEDEE88 != -1)
    dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
  v16 = off_1ECEDEE80;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
  {
    v17 = *(_DWORD *)(a1 + 836);
    v18 = v13 - *(float *)(a1 + 808);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)v27 = v17;
    if (v18 <= 0.0)
      v18 = -v18;
    *(_WORD *)&v27[4] = 2048;
    *(double *)&v27[6] = v14;
    v28 = 2048;
    v29 = v13;
    v30 = 2048;
    v31 = v18;
    _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_DEBUG, "[Gesture] fStableCount, %d, maxXYVar, %.8f, xyMeanNorm, %.3f, deltaTiltMean, %.3f", buf, 0x26u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
    v24 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CMPickupDetector::checkForStable(uint64_t)", "CoreLocation: %s\n", v24);
    if (v24 != (char *)buf)
      free(v24);
  }
  v19 = *(_DWORD *)(a1 + 836);
  if (v15)
  {
    *(_DWORD *)(a1 + 836) = v19 + 1;
    if (v19 >= 62)
    {
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
      v20 = off_1ECEDEE80;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134217984;
        *(double *)v27 = (float)((float)a2 * 0.000001);
        _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_DEBUG, "[Gesture] Entered Stable state. timestamp, %.6f", buf, 0xCu);
      }
      if (!sub_18F1FCA08(115, 2))
        return 1;
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 == -1)
        goto LABEL_43;
      goto LABEL_45;
    }
    return 0;
  }
  v22 = __OFSUB__(v19, 1);
  v23 = v19 - 1;
  if (v23 < 0 != v22)
    return 0;
  result = 0;
  *(_DWORD *)(a1 + 836) = v23;
  return result;
}

uint64_t sub_18F4C1D20(uint64_t a1, float *a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  unint64_t v17;
  NSObject *v18;
  int v19;
  float v20;
  int v21;
  int v22;
  float v23;
  NSObject *v24;
  char *v25;
  char *v26;
  uint8_t buf[4];
  double v28;
  __int16 v29;
  int v30;
  __int16 v31;
  double v32;
  __int16 v33;
  double v34;
  uint64_t v35;

  result = 0;
  v35 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 800);
  if (v5 - 1 >= a3 || ((a3 - v5) & 0x8000000000000000) != 0)
    return result;
  sub_18F38D4E4((unsigned __int16 *)(a1 + 48), 0, *(unsigned __int16 *)(a1 + 50));
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v14 = sqrtf((float)(a2[1] * a2[1]) + (float)(*a2 * *a2)) - *(float *)(a1 + 808);
  if (v14 <= 0.0)
    v15 = -v14;
  else
    v15 = v14;
  v16 = *(_QWORD *)(a1 + 824);
  if (qword_1ECEDEE88 != -1)
    dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
  v17 = a3 - v16;
  v18 = off_1ECEDEE80;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
  {
    v19 = *(_DWORD *)(a1 + 832);
    if (v9 <= v11)
      v20 = v11;
    else
      v20 = v9;
    *(_DWORD *)buf = 134218752;
    v28 = v15;
    v29 = 1024;
    v30 = v19;
    v31 = 2048;
    v32 = (float)(v13 / v20);
    v33 = 2048;
    v34 = (float)((float)v17 * 0.000001);
    _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_DEBUG, "[Gesture] deltaTilt, %.3f, fLiftCount, %d, z2xyRatio, %.3f, dt, %.2f", buf, 0x26u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
    v25 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CMPickupDetector::checkForLift(const CMVector3d &, uint64_t)", "CoreLocation: %s\n", v25);
    if (v25 != (char *)buf)
      free(v25);
  }
  v21 = *(_DWORD *)(a1 + 832);
  if (v15 >= 0.035)
  {
    if (v21 <= 2)
      *(_QWORD *)(a1 + 824) = a3;
    if (v15 < 0.07)
      v22 = 1;
    else
      v22 = 2;
    goto LABEL_23;
  }
  if (v21 >= 1 && v15 <= 0.004)
  {
    v22 = -1;
LABEL_23:
    v21 += v22;
    *(_DWORD *)(a1 + 832) = v21;
  }
  if (v21 < 13)
    return 0;
  if (v17 >> 8 > 0xC34)
  {
    result = 0;
    *(_DWORD *)(a1 + 832) = 0;
    return result;
  }
  v23 = v9 <= v11 ? v11 : v9;
  if (v13 >= (float)(v23 * 16.0))
    return 0;
  if (qword_1ECEDEE88 != -1)
    dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
  v24 = off_1ECEDEE80;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    v28 = (float)((float)a3 * 0.000001);
    _os_log_impl(&dword_18F1DC000, v24, OS_LOG_TYPE_DEBUG, "[Gesture] Entered Lift state. timestamp, %.6f", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954308);
    v26 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CMPickupDetector::checkForLift(const CMVector3d &, uint64_t)", "CoreLocation: %s\n", v26);
    if (v26 != (char *)buf)
      free(v26);
  }
  return 1;
}

uint64_t sub_18F4C21EC(uint64_t a1, char a2, int a3, char a4, char a5)
{
  uint64_t v9;
  char v10;
  uint64_t v11;
  double v13;

  v9 = sub_18F1EE054(a1, a3);
  *(_QWORD *)(v9 + 200) = &unk_1E294B2E0;
  v10 = *(_BYTE *)(v9 + 8);
  *(_QWORD *)(v9 + 208) = 0;
  *(_QWORD *)(v9 + 216) = 0;
  *(_BYTE *)(v9 + 224) = a5;
  *(_BYTE *)(v9 + 225) = 0;
  *(_QWORD *)(v9 + 256) = 0;
  *(_QWORD *)(v9 + 264) = 0;
  *(_BYTE *)(v9 + 272) = 0;
  *(_BYTE *)(v9 + 273) = v10;
  *(_QWORD *)v9 = &off_1E294B278;
  *(_BYTE *)(v9 + 274) = a4;
  *(_BYTE *)(v9 + 275) = 0;
  *(_QWORD *)(v9 + 280) = 0;
  v11 = sub_18F1EF73C();
  v13 = sub_18F1F723C(v11, (double *)(a1 + 24));
  sub_18F1E29C4(a1 + 288, &v13, (double *)(a1 + 16), a2);
  return a1;
}

void sub_18F4C229C(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;

  sub_18F352FB4(v2);
  sub_18F4B2E54(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4C22B8(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E294B278;
  a1[25] = &unk_1E294B2E0;
  v2 = a1 + 25;
  sub_18F209F74((uint64_t)(a1 + 25));
  sub_18F1EAC4C(v2);
  sub_18F209DDC(v2);
  sub_18F3D5D4C(a1 + 36);
  sub_18F352FB4(v2);
  return sub_18F4B2E54((uint64_t)a1);
}

uint64_t sub_18F4C2320(uint64_t a1)
{
  return sub_18F4C22B8((_QWORD *)(a1 - 200));
}

void sub_18F4C2328(_QWORD *a1)
{
  sub_18F4C22B8(a1);
  JUMPOUT(0x194001438);
}

void sub_18F4C234C(uint64_t a1)
{
  sub_18F4C22B8((_QWORD *)(a1 - 200));
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4C2374(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  double v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = a1 + 288;
  sub_18F1E7E0C(a1 + 288);
  if (*(_BYTE *)(a1 + 274))
  {
    sub_18F209FE8(a1 + 200, *(double *)(a1 + 16));
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v6 = 0xBFF0000000000000;
    v3 = mach_absolute_time();
    v5 = sub_18F1FD20C(v3);
    sub_18F20A100(v2, (double *)&v8, (double *)&v7, (double *)&v6, &v5);
  }
  sub_18F209E74(a1 + 200, *(double *)(a1 + 24));
  sub_18F209F30(a1 + 200);
  v8 = 2;
  result = sub_18F1E5858(a1, &v8);
  *(_BYTE *)(a1 + 275) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  return result;
}

_QWORD *sub_18F4C2420(uint64_t a1)
{
  _QWORD *v1;

  v1 = (_QWORD *)(a1 + 200);
  sub_18F209F74(a1 + 200);
  sub_18F1EAC4C(v1);
  return sub_18F209DDC(v1);
}

void sub_18F4C2450(uint64_t a1, int a2)
{
  NSObject *v4;
  char *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE78 != -1)
    dispatch_once(&qword_1ECEDEE78, &unk_1E2954328);
  v4 = off_1ECEDEE70;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    v7 = a2;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "Application state changed, %d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE78 != -1)
      dispatch_once(&qword_1ECEDEE78, &unk_1E2954328);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CLSensorFusionServiceLegacy::applicationStateChanged(BOOL)", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
  *(_BYTE *)(a1 + 275) = a2 ^ 1;
}

void sub_18F4C2604(uint64_t a1, uint64_t a2)
{
  float v4;
  uint64_t v5;
  uint64_t v6;
  float32x4_t v7;
  float v8;
  float v9;
  float v10;
  double v11;
  double v12;
  double v13;
  double v14;
  int v15;
  double v16;
  float64x2_t v17;
  double v18;
  double v19;
  NSObject *v20;
  NSObject *v21;
  char *v22;
  char *v23;
  double v24;
  float32x4_t v25;
  float v26;
  float v27;
  float v28;
  uint64_t v29;
  int v30;
  __int128 v31;
  __int128 v32;
  __int16 v33;
  __int16 v34;
  int v35;
  char v36;
  uint64_t v37;
  double v38[2];
  uint8_t buf[16];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *(float *)(a2 + 12);
  *(double *)buf = *(float *)(a2 + 8);
  v5 = a1 + 304;
  v6 = a1 + 288;
  v24 = v4;
  v38[0] = *(float *)(a2 + 16);
  sub_18F200B54(a1 + 288, (float64x2_t *)buf, (uint64_t)&v24, v38, (_QWORD *)a2);
  v7.i64[0] = *(_QWORD *)(a1 + 464);
  v8 = 0.0;
  v9 = 0.0;
  v10 = 0.0;
  if (*(double *)v7.i64 > 0.0)
  {
    v11 = *(double *)(a1 + 328);
    v12 = *(double *)(a1 + 320) + *(double *)(a1 + 320);
    v13 = *(double *)(a1 + 304);
    v14 = *(double *)(a1 + 312);
    v8 = *(float *)(a1 + 472) - (v11 * (v14 + v14) - v13 * v12);
    v9 = *(float *)(a1 + 476) - (-(v11 * (v13 + v13)) - v14 * v12);
    *(double *)v7.i64 = *(float *)(a1 + 480) - (v13 * (v13 + v13) + -1.0 + v14 * (v14 + v14));
    v10 = *(double *)v7.i64;
  }
  v15 = *(_DWORD *)(a1 + 452);
  v25 = 0uLL;
  v24 = -1.0;
  sub_18F1FFE94(&v25, v7);
  v16 = *(double *)a2;
  v24 = *(double *)a2;
  v17 = *(float64x2_t *)(v5 + 16);
  *(float32x4_t *)buf = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v5), v17);
  sub_18F1FFE94((float32x4_t *)buf, (float32x4_t)v17);
  v25 = *(float32x4_t *)buf;
  v26 = v8;
  v27 = v9;
  v28 = v10;
  v29 = *(_QWORD *)(v5 + 140);
  v30 = v15;
  v33 = 511;
  v31 = xmmword_18F506760;
  v32 = xmmword_18F507C30;
  v34 = (*(unsigned __int8 *)(a1 + 296) << 8) | (16 * *(unsigned __int8 *)(a1 + 252));
  v35 = 3;
  v37 = 0;
  v18 = *(double *)(a1 + 280);
  v36 = *(_BYTE *)(a2 + 22);
  if (v18 != 0.0)
  {
    v19 = v16 - v18;
    if (v16 - v18 > 0.100000001)
    {
      if (qword_1ECEDEE78 != -1)
        dispatch_once(&qword_1ECEDEE78, &unk_1E2954328);
      v20 = off_1ECEDEE70;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        *(double *)&buf[4] = v19;
        _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_INFO, "Large time gap, %lf", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE78 != -1)
          dispatch_once(&qword_1ECEDEE78, &unk_1E2954328);
        LODWORD(v38[0]) = 134217984;
        *(double *)((char *)v38 + 4) = v19;
        v22 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "virtual void CLSensorFusionServiceLegacy::feedGyroData(const CLGyro::Sample *)", "CoreLocation: %s\n", v22);
        if (v22 != (char *)buf)
          free(v22);
      }
      if (*(_BYTE *)(a1 + 275))
      {
        if (qword_1ECEDEE78 != -1)
          dispatch_once(&qword_1ECEDEE78, &unk_1E2954328);
        v21 = off_1ECEDEE70;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE70, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v21, OS_LOG_TYPE_DEFAULT, "Reset while backgrounded", buf, 2u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE78 != -1)
            dispatch_once(&qword_1ECEDEE78, &unk_1E2954328);
          LOWORD(v38[0]) = 0;
          v23 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "virtual void CLSensorFusionServiceLegacy::feedGyroData(const CLGyro::Sample *)", "CoreLocation: %s\n", v23);
          if (v23 != (char *)buf)
            free(v23);
        }
        sub_18F1E7E0C(v6);
      }
    }
  }
  *(double *)(a1 + 280) = v16;
  sub_18F1FFEF8(a1, (uint64_t)&v24);
}

void sub_18F4C2A90(uint64_t a1, uint64_t a2)
{
  sub_18F4C2604(a1 - 200, a2);
}

void sub_18F4C2A98(uint64_t a1, float32x2_t *a2, float *a3)
{
  sub_18F1F57A8(a1 + 288, a2, a3);
}

void sub_18F4C2AA0(uint64_t a1, float32x2_t *a2, float *a3)
{
  sub_18F1F57A8(a1 + 88, a2, a3);
}

void sub_18F4C2AA8(uint64_t a1, uint64_t a2)
{
  float v2;
  double v3;
  double v4;
  double v5;

  v2 = *(float *)(a2 + 12);
  v5 = *(float *)(a2 + 8);
  v3 = *(float *)(a2 + 16);
  v4 = v2;
  sub_18F20A100(a1 + 288, &v5, &v4, &v3, (_QWORD *)a2);
}

void sub_18F4C2AF4(uint64_t a1, uint64_t a2)
{
  sub_18F4C2AA8(a1 - 200, a2);
}

uint64_t sub_18F4C2B14(uint64_t a1)
{
  uint64_t result;
  _OWORD v3[2];
  int v4;

  *(_BYTE *)(a1 + 10) = 0;
  *(_QWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 20) = 0x3F80000000000000;
  v3[0] = xmmword_18F509AD4;
  v3[1] = unk_18F509AE4;
  v4 = 973279855;
  result = sub_18F45C8CC(a1 + 28, (uint64_t)v3);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 1;
  return result;
}

void sub_18F4C2B84(uint64_t a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  unsigned int v4;
  _BOOL4 v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  double v29;
  BOOL v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  uint64_t v37;
  float v38;
  uint64_t v39;
  float v40;
  float v41;
  uint64_t v42;
  float v43;
  float v44;
  float v45;
  NSObject *v46;
  BOOL v47;
  float v48;
  float v49;
  NSObject *v50;
  NSObject *v51;
  NSObject *v52;
  int v53;
  double v54;
  double v55;
  double v56;
  double v57;
  int v58;
  double v59;
  double v60;
  double v61;
  double v62;
  char *v63;
  char *v64;
  char *v65;
  char *v66;
  float32x4_t v67;
  _DWORD v68[3];
  int v69;
  _BYTE v70[14];
  __int16 v71;
  double v72;
  __int16 v73;
  double v74;
  __int16 v75;
  double v76;
  __int16 v77;
  _BOOL4 v78;
  float v79[2];
  _BYTE buf[38];
  __int16 v81;
  double v82;
  __int16 v83;
  _BOOL4 v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v2 = atomic_load((unsigned __int8 *)&qword_1ECEDFD48);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1ECEDFD48))
  {
    dword_1ECEDFD40 = 1060439283;
    __cxa_guard_release(&qword_1ECEDFD48);
  }
  v3 = *(_QWORD *)(a1 + 56);
  v4 = *(unsigned __int16 *)(v3 + 10);
  if (*(_DWORD *)(v3 + 12) == v4)
  {
    if (*(_BYTE *)(v3 + 417))
    {
      v5 = !sub_18F4C0F00(v3);
      v3 = *(_QWORD *)(a1 + 56);
      if (v5)
      {
        v37 = 0;
        v6 = *(float *)(v3 + 216);
        v7 = *(float *)(v3 + 220);
        v8 = *(float *)(v3 + 224);
        *(float *)buf = v6;
        *(float *)&buf[4] = v7;
        *(float *)&buf[8] = v8;
        v38 = 0.0;
        do
        {
          v38 = v38 + (float)(*(float *)&buf[v37] * *(float *)&buf[v37]);
          v37 += 4;
        }
        while (v37 != 12);
        if (sqrtf(v38) > 0.00000011921)
        {
          v39 = 0;
          v40 = 0.0;
          do
          {
            v40 = v40 + (float)(*(float *)&buf[v39] * *(float *)&buf[v39]);
            v39 += 4;
          }
          while (v39 != 12);
          v41 = sqrtf(v40);
          v6 = v6 / v41;
          v7 = v7 / v41;
          v8 = v8 / v41;
        }
LABEL_13:
        v14 = fabsf(v6);
        v15 = (float)(v8 * -0.0) - v7;
        v16 = v6 + (float)(v8 * 0.0);
        v17 = (float)(v7 * -0.0) + (float)(v6 * 0.0);
        if (v14 > *(float *)&dword_1ECEDFD40)
          v18 = v17;
        else
          v18 = 0.0;
        if (v14 > *(float *)&dword_1ECEDFD40)
          v19 = v16;
        else
          v19 = 0.0;
        if (v14 > *(float *)&dword_1ECEDFD40)
          v20 = v15;
        else
          v20 = 1.0;
        v21 = *(_QWORD *)(a1 + 56);
        if (*(_BYTE *)(v21 + 417))
        {
          v22 = sub_18F4C0F00(v21);
          if (!*(_BYTE *)(a1 + 10))
          {
            v30 = v22;
            v21 = *(_QWORD *)(a1 + 56);
            if (!v30)
            {
              v31 = *(float *)(v21 + 216);
              v32 = *(float *)(v21 + 220);
              v33 = *(float *)(v21 + 224);
              *(float *)v68 = v31;
              goto LABEL_36;
            }
            goto LABEL_34;
          }
        }
        else if (!*(_BYTE *)(a1 + 10))
        {
LABEL_34:
          v34 = sub_18F3403AC((unsigned __int16 *)(v21 + 8), 0, *(unsigned __int16 *)(v21 + 10));
          goto LABEL_35;
        }
        v34 = sub_18F200A14((float *)(a1 + 12));
LABEL_35:
        v31 = v34;
        v32 = v35;
        v33 = v36;
        *(float *)v68 = v34;
LABEL_36:
        v42 = 0;
        *(float *)&v68[1] = v32;
        *(float *)&v68[2] = v33;
        v43 = 0.0;
        do
        {
          v43 = v43 + (float)(*(float *)&v68[v42] * *(float *)&v68[v42]);
          ++v42;
        }
        while (v42 != 3);
        v44 = sqrtf(v43);
        v45 = fabsf(v44 + -1.0);
        if (v45 <= 1.0)
        {
          v48 = (float)(v45 / v44) * (float)(v45 / v44);
          v49 = 1.0 / v48;
          v79[0] = 25.0;
          if (v48 < 0.0109)
            v49 = 91.743;
          v79[1] = v49;
          v67.i64[0] = 0;
          v67.i64[1] = 0x3F80000000000000;
          v47 = sub_18F3D3C08(v79, &v67, (uint64_t)&v69, v20, v19, v18, v31, v32, v33, v28, v29, v23, v24, v25, v26, v27, __PAIR64__(LODWORD(v19), LODWORD(v20)), v18);
          if (v47)
          {
            if ((float32x4_t *)(a1 + 12) != &v67)
              *(float32x4_t *)(a1 + 12) = v67;
            if ((sub_18F45C8CC(a1 + 28, (uint64_t)&v69) & 1) == 0)
            {
              if (qword_1ECEDEE88 != -1)
                dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
              v50 = off_1ECEDEE80;
              if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_18F1DC000, v50, OS_LOG_TYPE_DEBUG, "invalid initial covariance !(P > 0), using default", buf, 2u);
              }
              if (sub_18F1FCA08(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1ECEDEE88 != -1)
                  dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
                v66 = (char *)_os_log_send_and_compose_impl();
                sub_18F419700("Generic", 1, 0, 2, "BOOL CMSensorFusionMekfPhone::initializeState(const CMVector3d &, const CMVector3d &, float)", "CoreLocation: %s\n", v66);
                if (v66 != buf)
                  free(v66);
              }
              *(_DWORD *)&buf[32] = 973279855;
              *(_OWORD *)buf = xmmword_18F509AD4;
              *(_OWORD *)&buf[16] = unk_18F509AE4;
              sub_18F45C8CC(a1 + 28, (uint64_t)buf);
            }
          }
          else
          {
            if (qword_1ECEDEE88 != -1)
              dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
            v51 = off_1ECEDEE80;
            if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18F1DC000, v51, OS_LOG_TYPE_DEBUG, "initializeState northAndGravity failed", buf, 2u);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE88 != -1)
                dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
              v65 = (char *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "BOOL CMSensorFusionMekfPhone::initializeState(const CMVector3d &, const CMVector3d &, float)", "CoreLocation: %s\n", v65);
              if (v65 != buf)
                free(v65);
            }
          }
        }
        else
        {
          if (qword_1ECEDEE88 != -1)
            dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
          v46 = off_1ECEDEE80;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 134217984;
            *(double *)&buf[4] = v44;
            _os_log_impl(&dword_18F1DC000, v46, OS_LOG_TYPE_DEBUG, "initializeState MaxInitialDiffUnity failed,magnitude,%f", buf, 0xCu);
          }
          if (sub_18F1FCA08(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE88 != -1)
              dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
            v69 = 134217984;
            *(double *)v70 = v44;
            v64 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "BOOL CMSensorFusionMekfPhone::initializeState(const CMVector3d &, const CMVector3d &, float)", "CoreLocation: %s\n", v64);
            if (v64 != buf)
              free(v64);
          }
          v47 = 0;
        }
        *(_BYTE *)(a1 + 10) = v47;
        if (qword_1ECEDEE88 != -1)
          dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
        v52 = off_1ECEDEE80;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
        {
          v53 = *(unsigned __int8 *)(a1 + 10);
          v54 = *(float *)(a1 + 12);
          v55 = *(float *)(a1 + 16);
          v56 = *(float *)(a1 + 20);
          v57 = *(float *)(a1 + 24);
          *(_DWORD *)buf = 67110400;
          *(_DWORD *)&buf[4] = v53;
          *(_WORD *)&buf[8] = 2048;
          *(double *)&buf[10] = v54;
          *(_WORD *)&buf[18] = 2048;
          *(double *)&buf[20] = v55;
          *(_WORD *)&buf[28] = 2048;
          *(double *)&buf[30] = v56;
          v81 = 2048;
          v82 = v57;
          v83 = 1024;
          v84 = v5;
          _os_log_impl(&dword_18F1DC000, v52, OS_LOG_TYPE_DEBUG, "initialized down,%u,q.x,%f,q.y,%f,q.z,%f,q.w,%f, withAvgGrav, %d", buf, 0x36u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE88 != -1)
            dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
          v58 = *(unsigned __int8 *)(a1 + 10);
          v59 = *(float *)(a1 + 12);
          v60 = *(float *)(a1 + 16);
          v61 = *(float *)(a1 + 20);
          v62 = *(float *)(a1 + 24);
          v69 = 67110400;
          *(_DWORD *)v70 = v58;
          *(_WORD *)&v70[4] = 2048;
          *(double *)&v70[6] = v59;
          v71 = 2048;
          v72 = v60;
          v73 = 2048;
          v74 = v61;
          v75 = 2048;
          v76 = v62;
          v77 = 1024;
          v78 = v5;
          v63 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "virtual void CMSensorFusionMekfPhone::initializeAttitude()", "CoreLocation: %s\n", v63);
          if (v63 != buf)
            free(v63);
        }
        return;
      }
      v4 = *(unsigned __int16 *)(v3 + 10);
    }
    v6 = sub_18F3403AC((unsigned __int16 *)(v3 + 8), 0, v4);
    v9 = 0;
    *(float *)buf = v6;
    *(float *)&buf[4] = v7;
    *(float *)&buf[8] = v8;
    v10 = 0.0;
    do
    {
      v10 = v10 + (float)(*(float *)&buf[v9] * *(float *)&buf[v9]);
      v9 += 4;
    }
    while (v9 != 12);
    if (sqrtf(v10) > 0.00000011921)
    {
      v11 = 0;
      v12 = 0.0;
      do
      {
        v12 = v12 + (float)(*(float *)&buf[v11] * *(float *)&buf[v11]);
        v11 += 4;
      }
      while (v11 != 12);
      v13 = sqrtf(v12);
      v6 = v6 / v13;
      v7 = v7 / v13;
      v8 = v8 / v13;
    }
    v5 = 0;
    goto LABEL_13;
  }
}

void sub_18F4C34A0(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 56);
  if (*(_WORD *)(v1 + 10))
  {
    sub_18F33DA38((unsigned __int16 *)(v1 + 8));
    sub_18F200A14((float *)(a1 + 12));
  }
}

double sub_18F4C3510(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  int v8;
  float32x4_t v9;
  double result;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  __int32 v14;

  v6 = 0;
  v13 = *(_QWORD *)a2;
  v14 = *(_DWORD *)(a2 + 8);
  do
  {
    *(float *)((char *)&v13 + v6) = -*(float *)((char *)&v13 + v6);
    v6 += 4;
  }
  while (v6 != 12);
  v12.i64[0] = v13;
  v12.i32[2] = v14;
  sub_18F45CBF8(v12.f32, (uint64_t)&v13);
  *(float *)(a1 + 64) = sub_18F3D3930((uint64_t)&v13, (float *)(a1 + 64));
  *(_DWORD *)(a1 + 68) = v7;
  *(_DWORD *)(a1 + 72) = v8;
  sub_18F45CCB4(a1 + 28, (uint64_t)&v13, a3);
  *(double *)v9.i64 = sub_18F3D3AA8(&v12, (float *)a2);
  sub_18F3D3764((uint64_t)&v12, (float *)(a1 + 12), &v11, v9);
  result = *(double *)v11.i64;
  *(float32x4_t *)(a1 + 12) = v11;
  return result;
}

double sub_18F4C35D8(_QWORD *a1, int a2, unint64_t a3)
{
  double result;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  int v10;
  NSObject *v11;
  char *v12;
  uint64_t v13;
  int v14;
  uint8_t buf[4];
  int v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!(*(unsigned int (**)(_QWORD *))(*a1 + 64))(a1))
    return result;
  v7 = *(_QWORD *)(a1[7] + 408);
  v8 = a3 >= v7;
  v9 = a3 - v7;
  if (v9 == 0 || !v8)
    return result;
  result = (double)v9 * 0.000001;
  *(float *)&result = result;
  if (*(float *)&result <= 0.0)
    return result;
  if (a2 == 2 || a2 == 1)
  {
    v10 = 833342583;
    goto LABEL_18;
  }
  v10 = 0;
  if (a2)
  {
LABEL_18:
    *(_DWORD *)buf = v10;
    v16 = v10;
    v17 = v10;
    v13 = 0;
    v14 = 0;
    return sub_18F4C3510((uint64_t)a1, (uint64_t)&v13, (uint64_t)buf);
  }
  if (qword_1ECEDEE88 != -1)
    dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
  v11 = off_1ECEDEE80;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_DEBUG, "invalid quiescentState kInMotion, ignoring quiescent", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954348);
    LOWORD(v13) = 0;
    v12 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "virtual void CMSensorFusionMekfPhone::feedQuiescent(CMDeviceMotionInputs::QuiescentState, uint64_t)", "CoreLocation: %s\n", v12);
    if (v12 != (char *)buf)
      free(v12);
  }
  return result;
}

void sub_18F4C37E4(uint64_t a1, float32x2_t *a2, unint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  float v10;
  float32x2_t v11;
  float v12;
  float v13;
  float v14;
  unint64_t v15;
  float *v16;
  float v17;
  unint64_t v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  BOOL v29;
  float v30;
  float v31;
  uint64_t v32;
  float v33;
  uint64_t v34;
  float v35;
  float v36;
  float v37;
  float32x2_t v38;
  float v39;
  uint64_t v40;
  int v41;
  float32x2_t v42;
  float v43;
  float32x2_t v44;
  float v45;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1))
  {
    v6 = *(_QWORD *)(a1 + 56);
    v7 = *(_QWORD *)(v6 + 408);
    v8 = a3 >= v7;
    v9 = a3 - v7;
    if (v9 != 0 && v8)
    {
      v10 = (double)v9 * 0.000001;
      if (v10 > 0.0)
      {
        v11 = vsub_f32(*a2, *(float32x2_t *)(v6 + 444));
        v12 = a2[1].f32[0] - *(float *)(v6 + 452);
        v42 = v11;
        v43 = v12;
        v13 = vaddv_f32(vmul_f32(v11, v11));
        v14 = v12 * v12;
        v40 = 0;
        v41 = 0;
        v37 = (double)v9 * 0.000001;
        if (*(_BYTE *)(a1 + 9))
        {
          v15 = 0;
          v44 = vmul_f32(v11, (float32x2_t)vdup_n_s32(0x3D23D70Au));
          v45 = v12 * 0.04;
          do
          {
            v16 = (float *)sub_18F33D3D0((uint64_t)&v44, v15);
            v17 = fminf(fmaxf(*v16 * *v16, 0.0027416), 9.8696);
            *(float *)sub_18F33D3D0((uint64_t)&v40, v15++) = v17;
          }
          while (v15 != 3);
          *(_BYTE *)(a1 + 9) = 0;
          v10 = v37;
        }
        v18 = 0;
        v19 = v13 + v14;
        v20 = v10 * v10;
        v21 = (float)(v10 * 0.0017) * (float)(v10 * 0.0017);
        v22 = (float)(v10 * 17.453) * (float)(v10 * 17.453);
        do
        {
          v23 = (float)(v20 * sub_18F3551B0(*(_QWORD *)(a1 + 56) + 420, v18)) + (float)(v37 * 0.000000010966);
          v24 = sub_18F3551B0((uint64_t)&v42, v18);
          v25 = v23 + (float)((float)((float)(v24 * 0.00033) * v37) * (float)((float)(v24 * 0.00033) * v37));
          v26 = sub_18F3551B0((uint64_t)&v42, v18);
          v27 = v25 + (float)((float)(v19 - (float)(v26 * v26)) * v21);
          v28 = sub_18F3551B0((uint64_t)&v42, v18);
          if (v28 <= 0.0)
            v28 = -v28;
          v29 = v28 <= 27.925;
          v30 = 0.0;
          if (!v29)
            v30 = v22;
          v31 = *(float *)sub_18F33D3D0((uint64_t)&v40, v18) + (float)(v27 + v30);
          *(float *)sub_18F33D3D0((uint64_t)&v44, v18++) = v31;
        }
        while (v18 != 3);
        v32 = *(_QWORD *)(a1 + 56);
        v33 = (float)((float)((float)(*(float *)(v32 + 464) + a2[1].f32[0]) * 0.5) - *(float *)(v32 + 452)) * v37;
        v38 = vmul_n_f32(vsub_f32(vmul_f32(vadd_f32(*(float32x2_t *)(v32 + 456), *a2), (float32x2_t)0x3F0000003F000000), *(float32x2_t *)(v32 + 444)), v37);
        v39 = v33;
        sub_18F4C3510(a1, (uint64_t)&v38, (uint64_t)&v44);
        v34 = 0;
        v35 = a2->f32[0];
        if (a2->f32[0] <= 0.0)
          v35 = -a2->f32[0];
        do
        {
          v36 = a2->f32[v34 + 1];
          if (v36 <= 0.0)
            v36 = -v36;
          if (v36 > v35)
            v35 = v36;
          ++v34;
        }
        while (v34 != 2);
        if (v35 > 27.925)
          *(_QWORD *)(a1 + 80) = 1;
      }
    }
  }
}

uint64_t sub_18F4C3AD0(float32x2_t *a1)
{
  float32x2_t v2;
  int v3;
  BOOL v4;
  unint64_t v5;
  float v6;
  float32_t v7;
  unint64_t v8;
  float v9;
  __int32 v10;
  float v11;
  float v12;
  uint64_t i;
  float v14;
  float v15;
  uint64_t v16;
  unsigned int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float32x2_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  unsigned int v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  __int32 v38;
  float v39;
  float v40;
  uint64_t v41;
  float v42;
  float v43;
  float *v44;
  float v45;
  uint64_t v46;
  float v47;
  float v48;
  float v49;
  float v50;
  uint64_t v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  uint64_t v57;
  float v58;
  float v59;
  int v60;
  int v61;
  float v63;
  _DWORD v64[3];
  unint64_t v65;
  float v66;

  if (!a1[1].i8[2])
  {
    (*(void (**)(float32x2_t *))(*(_QWORD *)a1 + 160))(a1);
    return 0;
  }
  v2 = a1[7];
  v3 = *(unsigned __int8 *)(*(_QWORD *)&v2 + 820);
  if (a1[1].i8[0])
    v4 = v3 == 0;
  else
    v4 = 0;
  if (v4)
  {
    v5 = 1;
    a1[10] = (float32x2_t)1;
    a1[1].i16[0] = 256;
LABEL_10:
    v6 = 1.0 / (float)v5;
    if (v6 < 0.001)
    {
      v5 = 999;
      a1[10] = (float32x2_t)999;
      v6 = 0.001;
    }
    goto LABEL_12;
  }
  v5 = (unint64_t)a1[10];
  a1[1].i8[0] = v3 != 0;
  if (v5)
    goto LABEL_10;
  v6 = 1.0;
LABEL_12:
  if (*(_BYTE *)(*(_QWORD *)&v2 + 240))
  {
    v7 = (float)((float)(1.0 - v6) * a1[9].f32[0]) + (float)(v6 * *(float *)(*(_QWORD *)&v2 + 236));
    a1[8] = vadd_f32(vmul_n_f32(a1[8], 1.0 - v6), vmul_n_f32(*(float32x2_t *)(*(_QWORD *)&v2 + 228), v6));
    a1[9].f32[0] = v7;
    a1[10] = (float32x2_t)(v5 + 1);
    v3 = *(unsigned __int8 *)(*(_QWORD *)&v2 + 820);
  }
  if (v3 || *(_DWORD *)(*(_QWORD *)&v2 + 276) == *(unsigned __int16 *)(*(_QWORD *)&v2 + 274))
  {
    v8 = *(unsigned __int16 *)(*(_QWORD *)&v2 + 10);
    if (*(_DWORD *)(*(_QWORD *)&v2 + 12) == (_DWORD)v8)
    {
      v63 = v6;
      sub_18F38D4E4((unsigned __int16 *)(*(_QWORD *)&v2 + 8), 0, v8);
      HIDWORD(v65) = v10;
      v66 = v11;
      if (v9 <= 0.0)
        v12 = -v9;
      else
        v12 = v9;
      for (i = 4; i != 12; i += 4)
      {
        v14 = *(float *)((char *)&v65 + i);
        if (v14 <= 0.0)
          v14 = -v14;
        if (v14 > v12)
          v12 = v14;
      }
      v15 = sub_18F3403AC((unsigned __int16 *)(*(_QWORD *)&a1[7] + 8), 0, *(unsigned __int16 *)(*(_QWORD *)&a1[7] + 10));
      v16 = 0;
      v65 = __PAIR64__(v17, LODWORD(v15));
      v66 = v18;
      v19 = 0.0;
      do
      {
        v19 = v19 + (float)(*(float *)((char *)&v65 + v16) * *(float *)((char *)&v65 + v16));
        v16 += 4;
      }
      while (v16 != 12);
      v20 = sqrtf(v12);
      v21 = sqrtf(v19) + -1.0;
      v22 = a1[7];
      v23 = 0.0;
      if (*(_BYTE *)(*(_QWORD *)&v22 + 820))
      {
        v24 = 0.0;
      }
      else
      {
        v24 = sub_18F33F978(*(_QWORD *)&v22 + 244, 32 - *(_DWORD *)(*(_QWORD *)&v22 + 480), *(_DWORD *)(*(_QWORD *)&v22 + 480));
        v22 = a1[7];
      }
      v25 = fabsf(v21);
      v26 = sub_18F4C40CC(flt_18F509AF8, (uint64_t)&unk_18F509B04, 3, v20);
      v27 = sub_18F3403AC((unsigned __int16 *)(*(_QWORD *)&v22 + 8), 0, *(unsigned __int16 *)(*(_QWORD *)&v22 + 10));
      v28 = 0;
      v65 = __PAIR64__(v29, LODWORD(v27));
      v66 = v30;
      do
      {
        v23 = v23 + (float)(*(float *)((char *)&v65 + v28) * *(float *)((char *)&v65 + v28));
        v28 += 4;
      }
      while (v28 != 12);
      v31 = sub_18F4C40CC(flt_18F509B10, (uint64_t)&unk_18F509B2C, 7, sqrtf(v23) + -1.0);
      v2 = a1[7];
      if (v20 < 0.1 && v25 < 0.12 && v24 < 0.05)
      {
        v32 = sub_18F4C40CC(flt_18F509B48, (uint64_t)&unk_18F509B54, 3, v24);
        if (v26 >= v31)
          v33 = v31;
        else
          v33 = v26;
        if (v33 < v32)
          v32 = v33;
        v34 = v32 * v32;
        goto LABEL_44;
      }
      v3 = *(unsigned __int8 *)(*(_QWORD *)&v2 + 820);
      v6 = v63;
    }
    v34 = 0.0;
    if (v3)
    {
LABEL_44:
      v35 = sub_18F340600((unsigned __int16 *)(*(_QWORD *)&v2 + 8), 7uLL);
      v36 = 0;
      v38 = *(_DWORD *)v35;
      v37 = *(float *)(v35 + 4);
      v39 = *(float *)(v35 + 8);
      LODWORD(v65) = *(_DWORD *)v35;
      *((float *)&v65 + 1) = v37;
      v66 = v39;
      v40 = 0.0;
      do
      {
        v40 = v40 + (float)(*(float *)((char *)&v65 + v36) * *(float *)((char *)&v65 + v36));
        v36 += 4;
      }
      while (v36 != 12);
      if (sqrtf(v40) > 0.00000011921)
      {
        v41 = 0;
        v42 = 0.0;
        do
        {
          v42 = v42 + (float)(*(float *)((char *)&v65 + v41) * *(float *)((char *)&v65 + v41));
          v41 += 4;
        }
        while (v41 != 12);
        v43 = sqrtf(v42);
        *(float *)&v38 = *(float *)&v38 / v43;
        v37 = v37 / v43;
        v39 = v39 / v43;
      }
      v65 = __PAIR64__(LODWORD(v37), v38);
      v66 = v39;
      if (*(_BYTE *)(*(_QWORD *)&a1[7] + 820))
        v34 = 0.1;
      v44 = (float *)&a1[1] + 1;
LABEL_71:
      v64[0] = sub_18F200A14(v44);
      v64[1] = v60;
      v64[2] = v61;
      sub_18F4C3FCC((uint64_t)a1, (float32x2_t *)&v65, (uint64_t)v64, v34);
      return 1;
    }
  }
  if (*(_BYTE *)(*(_QWORD *)&v2 + 240))
  {
    v45 = 0.0;
    v46 = 16;
    v47 = v6 / 0.001;
    do
    {
      v45 = v45 + (float)(a1->f32[v46] * a1->f32[v46]);
      ++v46;
    }
    while (v46 != 19);
    v48 = sqrtf(v45);
    v49 = v48 + -1.0;
    if ((float)(v48 + -1.0) <= 0.0)
      v49 = -(float)(v48 + -1.0);
    v50 = acosf(1.0 / (float)(v49 + 1.0));
    if (v48 < 1.0 && v50 <= (float)((float)((float)(1.0 - v48) * 180.0) * 0.017453))
      v50 = (float)((float)(1.0 - v48) * 180.0) * 0.017453;
    v51 = 0;
    v52 = v50 * v50;
    v54 = a1[8].f32[0];
    v53 = a1[8].f32[1];
    v55 = a1[9].f32[0];
    v65 = __PAIR64__(LODWORD(v53), LODWORD(v54));
    v66 = v55;
    v56 = 0.0;
    do
    {
      v56 = v56 + (float)(*(float *)((char *)&v65 + v51) * *(float *)((char *)&v65 + v51));
      v51 += 4;
    }
    while (v51 != 12);
    if ((float)(v47 * 0.00030462) <= v52)
      v34 = v52;
    else
      v34 = v47 * 0.00030462;
    if (sqrtf(v56) > 0.00000011921)
    {
      v57 = 0;
      v58 = 0.0;
      do
      {
        v58 = v58 + (float)(*(float *)((char *)&v65 + v57) * *(float *)((char *)&v65 + v57));
        v57 += 4;
      }
      while (v57 != 12);
      v59 = sqrtf(v58);
      v54 = v54 / v59;
      v53 = v53 / v59;
      v55 = v55 / v59;
    }
    v65 = __PAIR64__(LODWORD(v53), LODWORD(v54));
    v44 = (float *)&a1[1] + 1;
    v66 = v55;
    goto LABEL_71;
  }
  return 0;
}

double sub_18F4C3FCC(uint64_t a1, float32x2_t *a2, uint64_t a3, float a4)
{
  float v5;
  float v6;
  float32x2_t v7;
  float32x2_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float32x4_t v19;
  double result;
  float32x4_t v21;
  float32x4_t v22;
  float v23[3];
  _DWORD v24[3];
  _DWORD v25[2];
  float32x2_t v26;
  int v27;
  float32x2_t v28;
  float v29;
  int v30;
  float32x2_t v31;
  float v32;

  v5 = *(float *)(a3 + 8);
  v6 = a2[1].f32[0] - v5;
  v7 = *(float32x2_t *)a3;
  v31 = vsub_f32(*a2, *(float32x2_t *)a3);
  v32 = v6;
  v8 = *(float32x2_t *)(a3 + 4);
  v25[0] = 0;
  *(float *)&v25[1] = v5;
  v26 = vneg_f32(v8);
  v27 = 0;
  v28 = v7;
  v29 = -v7.f32[0];
  v30 = 0;
  *(float *)v24 = a4;
  *(float *)&v24[1] = a4;
  *(float *)&v24[2] = a4;
  sub_18F45D164((float *)(a1 + 28), (uint64_t)v25, (uint64_t)v24, (uint64_t)&v31);
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v15 = sub_18F200A14((float *)(a1 + 12));
  v18 = (float)((float)(v14 * v16) + (float)(v12 * v17)) + (float)(v10 * v15);
  v23[0] = v10 - (float)(v15 * v18);
  v23[1] = v12 - (float)(v17 * v18);
  v23[2] = v14 - (float)(v16 * v18);
  *(double *)v19.i64 = sub_18F3D3AA8(&v22, v23);
  sub_18F3D3764((uint64_t)&v22, (float *)(a1 + 12), &v21, v19);
  result = *(double *)v21.i64;
  *(float32x4_t *)(a1 + 12) = v21;
  return result;
}

float sub_18F4C40CC(float *a1, uint64_t a2, uint64_t a3, float a4)
{
  uint64_t v4;
  uint64_t v5;
  float v6;
  float v7;
  float v9;
  float *v10;
  float v11;
  float v12;

  if (*a1 >= a4)
    return *(float *)a2;
  v4 = a3 - 1;
  if (a1[a3 - 1] <= a4)
    return *(float *)(a2 + 4 * v4);
  v5 = 0;
  while (1)
  {
    v6 = a1[v5];
    if (v6 <= a4)
    {
      v7 = a1[v5 + 1];
      if (v7 >= a4)
        break;
    }
    if (v4 == ++v5)
      return *(float *)a2;
  }
  v9 = v7 - v6;
  if ((float)(v7 - v6) <= 0.0)
  {
    v11 = *(float *)(a2 + 4 * v5);
    v12 = 0.0;
  }
  else
  {
    v10 = (float *)(a2 + 4 * v5);
    v11 = *v10;
    v12 = (float)(v10[1] - *v10) / v9;
  }
  return v11 + (float)(v12 * (float)(a4 - v6));
}

void sub_18F4C415C()
{
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4C4170(uint64_t a1)
{
  return a1 + 12;
}

uint64_t sub_18F4C4178(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56) + 432;
}

BOOL sub_18F4C4184(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 56);
  return *(_BYTE *)(v1 + 416) && *(_QWORD *)(v1 + 408) && *(_BYTE *)(a1 + 10) != 0;
}

void sub_18F4C43C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F4C441C(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  void *DictionaryOfClasses;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  _QWORD *v31;
  NSObject *v32;
  char *v33;
  void *v34;
  double v35;
  void *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  double v41;
  double v42;
  void *v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  double v48;
  void *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  const char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t started;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  const char *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  const char *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  double v104;
  const char *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  void *v110;
  const char *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  void *v115;
  const char *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  double v120;
  const char *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  const char *v126;
  void *v127;
  uint64_t v128;
  NSObject *v129;
  _QWORD *v130;
  const char *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  void *v135;
  const char *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  CMSignificantElevationSample *v141;
  _QWORD v142[6];
  _QWORD v143[6];
  _QWORD block[6];
  _QWORD v145[6];
  int v146;
  uint64_t v147;
  uint8_t buf[4];
  uint64_t v149;
  uint64_t v150;

  v150 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if ((*(_QWORD *)(v4 + 136) || *(_QWORD *)(v4 + 144)) && !*(_BYTE *)(v4 + 168))
  {
    v5 = _Block_copy(*(const void **)(v4 + 144));
    v6 = _Block_copy(*(const void **)(*(_QWORD *)(a1 + 32) + 136));
    v7 = (void *)MEMORY[0x1E0C99E60];
    v8 = objc_opt_class();
    v9 = objc_opt_class();
    v10 = objc_opt_class();
    v14 = (NSSet *)objc_msgSend_setWithObjects_(v7, v11, v8, v12, v13, v9, v10, 0);
    if (*a2 && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v14)) != 0)
    {
      v19 = DictionaryOfClasses;
      v20 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v16, (uint64_t)CFSTR("CMErrorMessage"), v17, v18);
      v24 = (void *)objc_msgSend_objectForKeyedSubscript_(v19, v21, (uint64_t)CFSTR("CMSignificantElevationKeySample"), v22, v23);
      if (v20)
      {
        v29 = *(_QWORD *)(a1 + 32);
        if (*(_QWORD *)(v29 + 144))
        {
          v30 = *(NSObject **)(v29 + 120);
          v145[0] = MEMORY[0x1E0C809B0];
          v145[1] = 3221225472;
          v145[2] = sub_18F4C49FC;
          v145[3] = &unk_1E2955B60;
          v145[4] = v20;
          v145[5] = v5;
          v31 = v145;
LABEL_26:
          dispatch_async(v30, v31);
          goto LABEL_32;
        }
        if (v6)
        {
          v30 = *(NSObject **)(v29 + 120);
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3221225472;
          block[2] = sub_18F4C4A5C;
          block[3] = &unk_1E2955B60;
          block[4] = v20;
          block[5] = v6;
          v31 = block;
          goto LABEL_26;
        }
LABEL_32:
        _Block_release(v6);
        _Block_release(v5);
        return;
      }
      v34 = v24;
      if (v24)
      {
        v35 = *(double *)(*(_QWORD *)(a1 + 32) + 152);
        if (v35 == -1.0
          || (v36 = (void *)objc_msgSend_elevationAscended(v24, v25, v26, v27, v28),
              objc_msgSend_doubleValue(v36, v37, v38, v39, v40),
              v35 > v41)
          || (v42 = *(double *)(*(_QWORD *)(a1 + 32) + 160),
              v43 = (void *)objc_msgSend_elevationDescended(v34, v25, v26, v27, v28),
              objc_msgSend_doubleValue(v43, v44, v45, v46, v47),
              v42 > v48))
        {
          v49 = (void *)objc_msgSend_elevationAscended(v34, v25, v26, v27, v28);
          objc_msgSend_doubleValue(v49, v50, v51, v52, v53);
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 152) = v54;
          v59 = (void *)objc_msgSend_elevationDescended(v34, v55, v56, v57, v58);
          objc_msgSend_doubleValue(v59, v60, v61, v62, v63);
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 160) = v64;
          goto LABEL_32;
        }
        v141 = [CMSignificantElevationSample alloc];
        v140 = objc_msgSend_recordId(v34, v75, v76, v77, v78);
        v83 = objc_msgSend_sourceId(v34, v79, v80, v81, v82);
        started = objc_msgSend_startDate(v34, v84, v85, v86, v87);
        v93 = objc_msgSend_endDate(v34, v89, v90, v91, v92);
        v94 = (void *)MEMORY[0x1E0CB37E8];
        v99 = (void *)objc_msgSend_elevationAscended(v34, v95, v96, v97, v98);
        objc_msgSend_doubleValue(v99, v100, v101, v102, v103);
        v109 = objc_msgSend_numberWithDouble_(v94, v105, v106, v107, v108, v104 - *(double *)(*(_QWORD *)(a1 + 32) + 152));
        v110 = (void *)MEMORY[0x1E0CB37E8];
        v115 = (void *)objc_msgSend_elevationDescended(v34, v111, v112, v113, v114);
        objc_msgSend_doubleValue(v115, v116, v117, v118, v119);
        v125 = objc_msgSend_numberWithDouble_(v110, v121, v122, v123, v124, v120 - *(double *)(*(_QWORD *)(a1 + 32) + 160));
        v127 = (void *)objc_msgSend_initWithRecordId_sourceId_startDate_endDate_elevationAscended_elevationDescended_(v141, v126, v140, v83, started, v93, v109, v125);
        v128 = *(_QWORD *)(a1 + 32);
        if (*(_QWORD *)(v128 + 144))
        {
          v129 = *(NSObject **)(v128 + 120);
          v143[0] = MEMORY[0x1E0C809B0];
          v143[1] = 3221225472;
          v143[2] = sub_18F4C4ABC;
          v143[3] = &unk_1E2955B60;
          v143[4] = v127;
          v143[5] = v5;
          v130 = v143;
        }
        else
        {
          if (!v6)
          {
LABEL_39:

            goto LABEL_32;
          }
          v129 = *(NSObject **)(v128 + 120);
          v142[0] = MEMORY[0x1E0C809B0];
          v142[1] = 3221225472;
          v142[2] = sub_18F4C4AD0;
          v142[3] = &unk_1E2955B38;
          v142[4] = v127;
          v142[5] = v6;
          v130 = v142;
        }
        dispatch_async(v129, v130);
        goto LABEL_39;
      }
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954368);
      v65 = off_1ECEDEE80;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
      {
        v70 = (void *)objc_msgSend_description(v19, v66, v67, v68, v69);
        *(_DWORD *)buf = 136446210;
        v149 = objc_msgSend_UTF8String(v70, v71, v72, v73, v74);
        _os_log_impl(&dword_18F1DC000, v65, OS_LOG_TYPE_FAULT, "Unable to parse message (%{public}s) when starting updates to queue", buf, 0xCu);
      }
      if (!sub_18F1FCA08(115, 0))
        goto LABEL_32;
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954368);
      v135 = (void *)objc_msgSend_description(v19, v131, v132, v133, v134);
      v146 = 136446210;
      v147 = objc_msgSend_UTF8String(v135, v136, v137, v138, v139);
    }
    else
    {
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954368);
      v32 = off_1ECEDEE80;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v32, OS_LOG_TYPE_ERROR, "Unable to parse message when starting updates to queue!", buf, 2u);
      }
      if (!sub_18F1FCA08(115, 0))
        goto LABEL_32;
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954368);
      LOWORD(v146) = 0;
    }
    v33 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMAltimeterInternal init]_block_invoke", "CoreLocation: %s\n", v33);
    if (v33 != (char *)buf)
      free(v33);
    goto LABEL_32;
  }
}

uint64_t sub_18F4C49FC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4C4A5C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4C4ABC(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

void sub_18F4C4AD0(uint64_t a1)
{
  CMElevationData *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  id v6;

  v2 = [CMElevationData alloc];
  v6 = (id)objc_msgSend_initWithSignificantElevationSample_(v2, v3, *(_QWORD *)(a1 + 32), v4, v5);
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_18F4C4B24(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  NSObject *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD block[6];
  std::__shared_weak_count *v12;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 120);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3321888768;
  block[2] = sub_18F4C4BDC;
  block[3] = &unk_1E2952AE8;
  v5 = *a2;
  v4 = (std::__shared_weak_count *)a2[1];
  block[4] = v2;
  block[5] = v5;
  v12 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  dispatch_async(v3, block);
  v8 = v12;
  if (v12)
  {
    v9 = (unint64_t *)&v12->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

uint64_t sub_18F4C4BDC(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  void *DictionaryOfClasses;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  double v32;
  double v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  double v43;
  uint64_t v44;
  float v45;
  uint64_t v46;
  void *v47;
  CMAltitudeData *v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *started;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[6];
  _QWORD v69[5];
  _QWORD v70[6];

  v1 = *(_QWORD *)(result + 32);
  if (*(_QWORD *)(v1 + 24) && *(_QWORD *)(v1 + 16) && !*(_BYTE *)(v1 + 184))
  {
    v2 = result;
    v3 = (void *)MEMORY[0x1E0C99E60];
    v4 = objc_opt_class();
    v5 = objc_opt_class();
    v6 = objc_opt_class();
    v10 = (NSSet *)objc_msgSend_setWithObjects_(v3, v7, v4, v8, v9, v5, v6, 0);
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)(v2 + 40), v10);
    v15 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v12, (uint64_t)CFSTR("CMErrorMessage"), v13, v14);
    v19 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v16, (uint64_t)CFSTR("CMFilteredElevationKeySample"), v17, v18);
    if (v15)
    {
      v24 = *(_QWORD *)(v2 + 32);
      v25 = *(void **)(v24 + 24);
      v70[0] = MEMORY[0x1E0C809B0];
      v70[1] = 3221225472;
      v70[2] = sub_18F4C4E34;
      v70[3] = &unk_1E29559D0;
      v70[4] = v15;
      v70[5] = v24;
      return objc_msgSend_addOperationWithBlock_(v25, v20, (uint64_t)v70, v22, v23);
    }
    else
    {
      v26 = v19;
      if (v19)
      {
        v27 = (void *)objc_msgSend_elevationAscended(v19, v20, v21, v22, v23);
        objc_msgSend_doubleValue(v27, v28, v29, v30, v31);
        v33 = v32;
        v38 = (void *)objc_msgSend_elevationDescended(v26, v34, v35, v36, v37);
        result = objc_msgSend_doubleValue(v38, v39, v40, v41, v42);
        v44 = *(_QWORD *)(v2 + 32);
        if (*(float *)(v44 + 56) <= 150.0)
        {
          v45 = v33 - v43;
          if (*(double *)(v44 + 176) == 3.40282347e38)
          {
            *(double *)(v44 + 176) = v45;
          }
          else
          {
            v48 = [CMAltitudeData alloc];
            started = (void *)objc_msgSend_startDate(v26, v49, v50, v51, v52);
            objc_msgSend_timeIntervalSinceReferenceDate(started, v54, v55, v56, v57);
            v62 = objc_msgSend_initWithTimestamp_pressure_relativeAltitude_(v48, v58, v59, v60, v61);
            v63 = *(_QWORD *)(v2 + 32);
            v64 = *(void **)(v63 + 24);
            v68[0] = MEMORY[0x1E0C809B0];
            v68[1] = 3221225472;
            v68[2] = sub_18F4C51E8;
            v68[3] = &unk_1E29559D0;
            v68[4] = v63;
            v68[5] = v62;
            return objc_msgSend_addOperationWithBlock_(v64, v65, (uint64_t)v68, v66, v67);
          }
        }
      }
      else
      {
        v46 = *(_QWORD *)(v2 + 32);
        v47 = *(void **)(v46 + 24);
        v69[0] = MEMORY[0x1E0C809B0];
        v69[1] = 3221225472;
        v69[2] = sub_18F4C5018;
        v69[3] = &unk_1E2955938;
        v69[4] = v46;
        return objc_msgSend_addOperationWithBlock_(v47, v20, (uint64_t)v69, v22, v23);
      }
    }
  }
  return result;
}

void sub_18F4C4E34(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  void *v15;
  int v16;
  const char *v17;
  uint64_t v18;
  int v19;
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D6C8 != -1)
    dispatch_once(&qword_1EE16D6C8, &unk_1E2959450);
  v2 = qword_1EE16D6C0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6C0, OS_LOG_TYPE_ERROR))
  {
    v7 = objc_msgSend_intValue(*(void **)(a1 + 32), v3, v4, v5, v6);
    v19 = 68289282;
    v20 = 0;
    v21 = 2082;
    v22 = "";
    v23 = 1026;
    v24 = v7;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Error receiving filtered elevation updates\", \"error\":%{public}d}", (uint8_t *)&v19, 0x18u);
    if (qword_1EE16D6C8 != -1)
      dispatch_once(&qword_1EE16D6C8, &unk_1E2959450);
  }
  v8 = qword_1EE16D6C0;
  if (os_signpost_enabled((os_log_t)qword_1EE16D6C0))
  {
    v13 = objc_msgSend_intValue(*(void **)(a1 + 32), v9, v10, v11, v12);
    v19 = 68289282;
    v20 = 0;
    v21 = 2082;
    v22 = "";
    v23 = 1026;
    v24 = v13;
    _os_signpost_emit_with_name_impl(&dword_18F1DC000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Error receiving filtered elevation updates", "{\"msg%{public}.0s\":\"Error receiving filtered elevation updates\", \"error\":%{public}d}", (uint8_t *)&v19, 0x18u);
  }
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16);
  if (v14)
  {
    v15 = (void *)MEMORY[0x1E0CB35C8];
    v16 = objc_msgSend_intValue(*(void **)(a1 + 32), v9, v10, v11, v12);
    v18 = objc_msgSend_errorWithDomain_code_userInfo_(v15, v17, (uint64_t)CFSTR("CMErrorDomain"), v16, 0);
    (*(void (**)(uint64_t, _QWORD, uint64_t))(v14 + 16))(v14, 0, v18);
  }
}

void sub_18F4C5018(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint8_t buf[1640];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (qword_1EE16D6C8 != -1)
    dispatch_once(&qword_1EE16D6C8, &unk_1E2959450);
  v2 = qword_1EE16D6C0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6C0, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "Received empty filtered elevation update", buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6C8 != -1)
      dispatch_once(&qword_1EE16D6C8, &unk_1E2959450);
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMAltimeterInternal init]_block_invoke", "CoreLocation: %s\n", v6);
    if (v6 != (char *)buf)
      free(v6);
  }
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
  if (v4)
  {
    v5 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], v3, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
    (*(void (**)(uint64_t, _QWORD, uint64_t))(v4 + 16))(v4, 0, v5);
  }
}

void sub_18F4C51E8(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
  if (v2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(v2 + 16))(v2, *(_QWORD *)(a1 + 40), 0);

}

uint64_t sub_18F4C5224(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t sub_18F4C5248(uint64_t a1)
{
  return sub_18F2A8438(a1 + 40);
}

void sub_18F4C5250(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;

  v5 = *(void **)(a1 + 32);
  v6 = (std::__shared_weak_count *)*((_QWORD *)a2 + 1);
  v12 = *(_QWORD *)a2;
  v13 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  objc_msgSend__handleAbsoluteAltitudeUpdate_(v5, a2, (uint64_t)&v12, a4, a5);
  v9 = v13;
  if (v13)
  {
    v10 = (unint64_t *)&v13->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void sub_18F4C52D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_18F2A8438((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_18F4C53D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_18F4C5448(_QWORD *result, const char *a2)
{
  uint64_t v2;
  _QWORD *v3;
  const void *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  const __CFString *v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v2 = result[4];
  if (*(_QWORD *)(v2 + 128))
  {
    v3 = result;
    v4 = *(const void **)(v2 + 136);
    if (v4)
    {
      _Block_release(v4);
      *(_QWORD *)(v3[4] + 136) = 0;
    }
    else
    {
      v16 = CFSTR("kCLConnectionMessageSubscribeKey");
      v17[0] = MEMORY[0x1E0C9AAB0];
      v13 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v17, (uint64_t)&v16, 1);
      sub_18F4C8BE8(&v14, &v13);
      v12 = v15;
      if (v15)
      {
        p_shared_owners = (unint64_t *)&v15->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
      }
      CLConnectionClient::sendMessage();
      if (v12)
      {
        v7 = (unint64_t *)&v12->__shared_owners_;
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v9 = v15;
      if (v15)
      {
        v10 = (unint64_t *)&v15->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
    result = _Block_copy((const void *)v3[5]);
    *(_QWORD *)(v3[4] + 136) = result;
    *(_BYTE *)(v3[4] + 168) = 0;
  }
  return result;
}

void sub_18F4C55B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  sub_18F2A8438((uint64_t)&a9);
  sub_18F2A8438((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void sub_18F4C5634(uint64_t a1, const char *a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  const __CFString *v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v14 = CFSTR("kCLConnectionMessageSubscribeKey");
  v15[0] = MEMORY[0x1E0C9AAA0];
  v11 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v15, (uint64_t)&v14, 1);
  sub_18F4C8BE8(&v12, &v11);
  v10 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v10)
  {
    v5 = (unint64_t *)&v10->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  _Block_release(*(const void **)(*(_QWORD *)(a1 + 32) + 136));
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 136) = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 152) = 0xBFF0000000000000;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 160) = 0xBFF0000000000000;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 168) = 1;
  v7 = v13;
  if (v13)
  {
    v8 = (unint64_t *)&v13->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_18F4C579C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4C5820(_QWORD *result, const char *a2)
{
  uint64_t v2;
  _QWORD *v3;
  const void *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  const __CFString *v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v2 = result[4];
  if (*(_QWORD *)(v2 + 128))
  {
    v3 = result;
    v4 = *(const void **)(v2 + 144);
    if (v4)
    {
      _Block_release(v4);
      *(_QWORD *)(v3[4] + 144) = 0;
    }
    else
    {
      v16 = CFSTR("kCLConnectionMessageSubscribeKey");
      v17[0] = MEMORY[0x1E0C9AAB0];
      v13 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v17, (uint64_t)&v16, 1);
      sub_18F4C8BE8(&v14, &v13);
      v12 = v15;
      if (v15)
      {
        p_shared_owners = (unint64_t *)&v15->__shared_owners_;
        do
          v6 = __ldxr(p_shared_owners);
        while (__stxr(v6 + 1, p_shared_owners));
      }
      CLConnectionClient::sendMessage();
      if (v12)
      {
        v7 = (unint64_t *)&v12->__shared_owners_;
        do
          v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      v9 = v15;
      if (v15)
      {
        v10 = (unint64_t *)&v15->__shared_owners_;
        do
          v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
    }
    result = _Block_copy((const void *)v3[5]);
    *(_QWORD *)(v3[4] + 144) = result;
    *(_BYTE *)(v3[4] + 168) = 0;
  }
  return result;
}

void sub_18F4C5990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  sub_18F2A8438((uint64_t)&a9);
  sub_18F2A8438((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void sub_18F4C5A0C(uint64_t a1, const char *a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  const __CFString *v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v14 = CFSTR("kCLConnectionMessageSubscribeKey");
  v15[0] = MEMORY[0x1E0C9AAA0];
  v11 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v15, (uint64_t)&v14, 1);
  sub_18F4C8BE8(&v12, &v11);
  v10 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v10)
  {
    v5 = (unint64_t *)&v10->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  _Block_release(*(const void **)(*(_QWORD *)(a1 + 32) + 144));
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 144) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 168) = 1;
  v7 = v13;
  if (v13)
  {
    v8 = (unint64_t *)&v13->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_18F4C5B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_18F4C5BE8(uint64_t a1)
{
  CMMotionTimeRange *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  double v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  void *started;
  const char *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  const __CFString *v31;
  _QWORD v32[2];

  v32[1] = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 128))
  {
    v2 = [CMMotionTimeRange alloc];
    objc_msgSend_timeIntervalSinceReferenceDate(*(void **)(a1 + 40), v3, v4, v5, v6);
    v8 = v7;
    objc_msgSend_timeIntervalSinceReferenceDate(*(void **)(a1 + 48), v9, v10, v11, v12);
    started = (void *)objc_msgSend_initWithStartDate_endDate_(v2, v13, v14, v15, v16, v8, v17);
    v31 = CFSTR("CMSignificantElevationKeyQueryTimeRange");
    v32[0] = started;
    v30 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v19, (uint64_t)v32, (uint64_t)&v31, 1);

    sub_18F40BDA4("kCLConnectionMessageSignificantElevationDeltaQuery", &v30, &v28);
    v27 = v29;
    if (v29)
    {
      p_shared_owners = (unint64_t *)&v29->__shared_owners_;
      do
        v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
    }
    CLConnectionClient::sendMessage();
    if (v27)
    {
      v22 = (unint64_t *)&v27->__shared_owners_;
      do
        v23 = __ldaxr(v22);
      while (__stlxr(v23 - 1, v22));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    v24 = v29;
    if (v29)
    {
      v25 = (unint64_t *)&v29->__shared_owners_;
      do
        v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
}

void sub_18F4C5DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4C5DCC(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  NSSet *v11;
  void *DictionaryOfClasses;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  _QWORD *v28;
  NSObject *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  double v41;
  void *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  double v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  char *v70;
  _QWORD block[5];
  _QWORD v72[6];
  _QWORD v73[5];
  _QWORD v74[6];
  int v75;
  uint64_t v76;
  uint8_t buf[4];
  uint64_t v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v11 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v9, v10, v6, v7, 0);
  if (!*a2 || (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v11)) == 0)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954368);
    v29 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v29, OS_LOG_TYPE_ERROR, "Unable to parse message when checking for availability!", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954368);
      LOWORD(v75) = 0;
      v70 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMAltimeterInternal _querySignificantElevationChangeFromDate:toDate:withHandler:]_block_invoke", "CoreLocation: %s\n", v70);
      if (v70 != (char *)buf)
        free(v70);
    }
    v30 = *(_QWORD *)(a1 + 40);
    v27 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 120);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F4C6344;
    block[3] = &unk_1E2955B10;
    block[4] = v30;
    v28 = block;
    goto LABEL_11;
  }
  v16 = DictionaryOfClasses;
  v17 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v13, (uint64_t)CFSTR("CMErrorMessage"), v14, v15);
  v21 = (void *)objc_msgSend_objectForKeyedSubscript_(v16, v18, (uint64_t)CFSTR("CMSignificantElevationKeySample"), v19, v20);
  if (v17)
  {
    v26 = *(_QWORD *)(a1 + 40);
    v27 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 120);
    v74[0] = MEMORY[0x1E0C809B0];
    v74[1] = 3221225472;
    v74[2] = sub_18F4C6284;
    v74[3] = &unk_1E2955B60;
    v74[4] = v17;
    v74[5] = v26;
    v28 = v74;
LABEL_11:
    dispatch_async(v27, v28);
    return;
  }
  v31 = v21;
  if (v21)
  {
    v32 = (void *)objc_msgSend_elevationAscended(v21, v22, v23, v24, v25);
    objc_msgSend_doubleValue(v32, v33, v34, v35, v36);
    if (v41 == 0.0
      && (v42 = (void *)objc_msgSend_elevationDescended(v31, v37, v38, v39, v40),
          objc_msgSend_doubleValue(v42, v43, v44, v45, v46),
          v47 == 0.0))
    {
      v48 = *(_QWORD *)(a1 + 40);
      v27 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 120);
      v73[0] = MEMORY[0x1E0C809B0];
      v73[1] = 3221225472;
      v73[2] = sub_18F4C62E4;
      v73[3] = &unk_1E2955B10;
      v73[4] = v48;
      v28 = v73;
    }
    else
    {
      v49 = *(_QWORD *)(a1 + 40);
      v27 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 120);
      v72[0] = MEMORY[0x1E0C809B0];
      v72[1] = 3221225472;
      v72[2] = sub_18F4C6330;
      v72[3] = &unk_1E2955B60;
      v72[4] = v31;
      v72[5] = v49;
      v28 = v72;
    }
    goto LABEL_11;
  }
  if (qword_1ECEDEE88 != -1)
    dispatch_once(&qword_1ECEDEE88, &unk_1E2954368);
  v50 = off_1ECEDEE80;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
  {
    v55 = (void *)objc_msgSend_description(v16, v51, v52, v53, v54);
    *(_DWORD *)buf = 136446210;
    v78 = objc_msgSend_UTF8String(v55, v56, v57, v58, v59);
    _os_log_impl(&dword_18F1DC000, v50, OS_LOG_TYPE_FAULT, "Unable to parse message (%{public}s) for query response", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954368);
    v64 = (void *)objc_msgSend_description(v16, v60, v61, v62, v63);
    v75 = 136446210;
    v76 = objc_msgSend_UTF8String(v64, v65, v66, v67, v68);
    v69 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMAltimeterInternal _querySignificantElevationChangeFromDate:toDate:withHandler:]_block_invoke", "CoreLocation: %s\n", v69);
    if (v69 != (char *)buf)
      free(v69);
  }
}

uint64_t sub_18F4C6284(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4C62E4(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 109, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F4C6330(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_18F4C6344(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F4C63F4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  std::__shared_weak_count *v34;
  uint64_t v35;
  std::__shared_weak_count *v36;
  _QWORD v37[3];
  int v38;
  uint64_t v39;
  _QWORD v40[4];
  _QWORD v41[5];

  v41[4] = *MEMORY[0x1E0C80C00];
  v40[0] = CFSTR("CMElevationProfileKeyQueryStartTime");
  v6 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend_timeIntervalSinceReferenceDate(*(void **)(a1 + 32), a2, a3, a4, a5);
  v41[0] = objc_msgSend_numberWithDouble_(v6, v7, v8, v9, v10);
  v40[1] = CFSTR("CMElevationProfileKeyQueryEndTime");
  v11 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend_timeIntervalSinceReferenceDate(*(void **)(a1 + 40), v12, v13, v14, v15);
  v41[1] = objc_msgSend_numberWithDouble_(v11, v16, v17, v18, v19);
  v40[2] = CFSTR("CMElevationProfileKeyQueryBatchSize");
  v41[2] = objc_msgSend_numberWithUnsignedInteger_(MEMORY[0x1E0CB37E8], v20, *(_QWORD *)(a1 + 64), v21, v22);
  v40[3] = CFSTR("CMElevationProfileKeyQueryFromRecordId");
  v41[3] = objc_msgSend_numberWithInt_(MEMORY[0x1E0CB37E8], v23, *(unsigned int *)(a1 + 72), v24, v25);
  v39 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v26, (uint64_t)v41, (uint64_t)v40, 4);
  v37[0] = 0;
  v37[1] = v37;
  v37[2] = 0x2020000000;
  v38 = *(_DWORD *)(a1 + 72);
  sub_18F35C128("kCLConnectionMessageElevationProfileQuery", &v39, &v35);
  v34 = v36;
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      v28 = __ldxr(p_shared_owners);
    while (__stxr(v28 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v34)
  {
    v29 = (unint64_t *)&v34->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  v31 = v36;
  if (v36)
  {
    v32 = (unint64_t *)&v36->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  _Block_object_dispose(v37, 8);
}

void sub_18F4C6630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  va_list va1;
  uint64_t v18;
  va_list va2;

  va_start(va2, a12);
  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v16 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Block_object_dispose(va2, 8);
  _Unwind_Resume(a1);
}

void sub_18F4C6668(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  NSSet *v12;
  void *DictionaryOfClasses;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  uint64_t v45;
  NSObject *v46;
  char *v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  uint64_t v51;
  const char *v52;
  char *v53;
  _QWORD v54[5];
  _QWORD v55[6];
  char v56;
  __int16 v57;
  _QWORD block[6];
  uint8_t buf[1640];
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v12 = (NSSet *)objc_msgSend_setWithObjects_(v4, v9, v5, v10, v11, v6, v7, v8, 0);
  if (*a2 && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v12)) != 0)
  {
    v17 = DictionaryOfClasses;
    v18 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, (uint64_t)CFSTR("CMErrorMessage"), v15, v16);
    v22 = objc_msgSend_objectForKeyedSubscript_(v17, v19, (uint64_t)CFSTR("CMElevationProfileKeyAltitudeArray"), v20, v21);
    v26 = (void *)objc_msgSend_objectForKeyedSubscript_(v17, v23, (uint64_t)CFSTR("CMElevationProfileKeyLastBatch"), v24, v25);
    v31 = objc_msgSend_BOOLValue(v26, v27, v28, v29, v30);
    v35 = (void *)objc_msgSend_objectForKeyedSubscript_(v17, v32, (uint64_t)CFSTR("CMElevationProfileKeyQueryFromRecordId"), v33, v34);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = objc_msgSend_intValue(v35, v36, v37, v38, v39);
    objc_msgSend_description(v17, v40, v41, v42, v43);
    if (v18)
    {
      v44 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 120);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = sub_18F4C6B0C;
      block[3] = &unk_1E2955B60;
      v45 = *(_QWORD *)(a1 + 56);
      block[4] = v18;
      block[5] = v45;
      dispatch_async(v44, block);
      if (qword_1EE16D488[0] != -1)
        dispatch_once(qword_1EE16D488, &unk_1E2959470);
      v46 = qword_1EE16D480;
      if (os_log_type_enabled((os_log_t)qword_1EE16D480, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v46, OS_LOG_TYPE_FAULT, "Unable to parse message for query response", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D488[0] != -1)
          dispatch_once(qword_1EE16D488, &unk_1E2959470);
        v57 = 0;
        v47 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMAltimeterInternal _queryElevationProfileFromDate:toDate:withBatchSize:fromRecordId:withHandler:]_block_invoke", "CoreLocation: %s\n", v47);
        if (v47 != (char *)buf)
          free(v47);
      }
    }
    else
    {
      v50 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 120);
      v55[0] = MEMORY[0x1E0C809B0];
      v55[1] = 3221225472;
      v55[2] = sub_18F4C6B70;
      v55[3] = &unk_1E29575F8;
      v51 = *(_QWORD *)(a1 + 56);
      v55[4] = v22;
      v55[5] = v51;
      v56 = v31;
      dispatch_async(v50, v55);
      if ((v31 & 1) == 0)
        objc_msgSend__queryElevationProfileFromDate_toDate_withBatchSize_fromRecordId_withHandler_(*(void **)(a1 + 32), v52, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 72), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24), *(_QWORD *)(a1 + 56));
    }
  }
  else
  {
    if (qword_1EE16D488[0] != -1)
      dispatch_once(qword_1EE16D488, &unk_1E2959470);
    v48 = qword_1EE16D480;
    if (os_log_type_enabled((os_log_t)qword_1EE16D480, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v48, OS_LOG_TYPE_ERROR, "Unable to parse message when checking for availability.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D488[0] != -1)
        dispatch_once(qword_1EE16D488, &unk_1E2959470);
      v57 = 0;
      v53 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMAltimeterInternal _queryElevationProfileFromDate:toDate:withBatchSize:fromRecordId:withHandler:]_block_invoke", "CoreLocation: %s\n", v53);
      if (v53 != (char *)buf)
        free(v53);
    }
    v49 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 120);
    v54[0] = MEMORY[0x1E0C809B0];
    v54[1] = 3221225472;
    v54[2] = sub_18F4C6B88;
    v54[3] = &unk_1E2955B10;
    v54[4] = *(_QWORD *)(a1 + 56);
    dispatch_async(v49, v54);
  }
}

uint64_t sub_18F4C6B0C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_integerValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(v6 + 16))(v6, 0, 0, v9);
}

uint64_t sub_18F4C6B70(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), a1 + 48, 0);
}

uint64_t sub_18F4C6B88(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(v2 + 16))(v2, 0, 0, v3);
}

_QWORD *sub_18F4C6C38(_QWORD *a1, const char *a2)
{
  _QWORD *result;

  result = (_QWORD *)a1[4];
  if (result[16])
    return (_QWORD *)objc_msgSend__queryElevationProfileFromDate_toDate_withBatchSize_fromRecordId_withHandler_(result, a2, a1[5], a1[6], a1[8], 0, a1[7]);
  return result;
}

void sub_18F4C6ED8(uint64_t a1, const char *a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  const __CFString *v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v14 = CFSTR("kCLConnectionMessageSubscribeKey");
  v15[0] = MEMORY[0x1E0C9AAB0];
  v11 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v15, (uint64_t)&v14, 1);
  sub_18F39E62C("kCLConnectionMessageFilteredElevationUpdate", &v11, &v12);
  v10 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v10)
  {
    v5 = (unint64_t *)&v10->__shared_owners_;
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 184) = 0;
  v7 = v13;
  if (v13)
  {
    v8 = (unint64_t *)&v13->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_18F4C7020(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4C70D8(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD block[7];

  v2 = *(id *)(a1 + 32);
  v3 = _Block_copy(*(const void **)(a1 + 48));
  v5 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  v6 = *(NSObject **)(v4 + 112);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_18F4C7154;
  block[3] = &unk_1E2955BD8;
  block[4] = v4;
  block[5] = v5;
  block[6] = v3;
  dispatch_async(v6, block);
}

void sub_18F4C7154(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v5;
  const char *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  const __CFString *v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v5 = (_QWORD *)(a1 + 32);
  objc_msgSend__releaseHandlerObjects(*(void **)(a1 + 32), a2, a3, a4, a5);
  *(_QWORD *)(*v5 + 192) = v5[1];
  *(_QWORD *)(*v5 + 200) = v5[2];
  v18 = CFSTR("kCLConnectionMessageSubscribeKey");
  v19[0] = MEMORY[0x1E0C9AAB0];
  v15 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v6, (uint64_t)v19, (uint64_t)&v18, 1);
  sub_18F3E4CEC("kCLConnectionMessageAbsoluteAltitudeUpdate", &v15, &v16);
  v14 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v14)
  {
    v9 = (unint64_t *)&v14->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  v11 = v17;
  if (v17)
  {
    v12 = (unint64_t *)&v17->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_18F4C72B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4C7330(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 112);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_18F4C7388;
  block[3] = &unk_1E2955938;
  block[4] = v1;
  dispatch_async(v2, block);
}

void sub_18F4C7388(uint64_t a1, const char *a2)
{
  unint64_t *p_shared_owners;
  unint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  const __CFString *v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v18 = CFSTR("kCLConnectionMessageSubscribeKey");
  v19[0] = MEMORY[0x1E0C9AAA0];
  v15 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v19, (uint64_t)&v18, 1);
  sub_18F3E4CEC("kCLConnectionMessageAbsoluteAltitudeUpdate", &v15, &v16);
  v14 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v14)
  {
    v9 = (unint64_t *)&v14->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  objc_msgSend__releaseHandlerObjects(*(void **)(a1 + 32), v5, v6, v7, v8);
  v11 = v17;
  if (v17)
  {
    v12 = (unint64_t *)&v17->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_18F4C74D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_18F4C7A70(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[6];

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 192) && (v3 = *(const void **)(v2 + 200)) != 0)
  {
    v4 = _Block_copy(v3);
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(void **)(*(_QWORD *)(a1 + 32) + 192);
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v10[2] = sub_18F4C7B04;
    v10[3] = &unk_1E2955B60;
    v10[4] = v5;
    v10[5] = v4;
    objc_msgSend_addOperationWithBlock_(v6, v7, (uint64_t)v10, v8, v9);
  }
  else
  {

  }
}

void sub_18F4C7B04(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  _Block_release(*(const void **)(a1 + 40));

}

uint64_t sub_18F4C7B58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a2, sel_onFilteredPressure_, a1, a4, a5);
}

void sub_18F4C7C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4C7CA8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_initPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = result;
  return result;
}

void sub_18F4C7DE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4C7DFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), sel_deallocPrivate, a3, a4, a5);
}

uint64_t sub_18F4C7E9C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](a1[4], sel_startRelativeAltitudeUpdatesPrivateToQueue_withHandler_, a1[5], a1[6], a5);
}

uint64_t sub_18F4C7EAC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend_stopRelativeAltitudeUpdatesPrivate(*(void **)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_18F4C7F68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__startSignificantElevationUpdatesWithHandler_, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4C7FD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__stopSignificantElevationUpdates, a3, a4, a5);
}

uint64_t sub_18F4C8124(_QWORD *a1)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1[4] + 8), sel__querySignificantElevationChangeFromDate_toDate_withHandler_, a1[5], a1[6], a1[7]);
}

void sub_18F4C8578(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_18F4C85A0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_18F4C891C(_QWORD *a1)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1[4] + 8), sel__queryElevationProfileFromDate_toDate_withBatchSize_withHandler_, a1[5], a1[6], a1[8]);
}

uint64_t sub_18F4C8A14(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__teardown(*(void **)(*(_QWORD *)(a1 + 32) + 8), a2, a3, a4, a5);
}

uint64_t sub_18F4C8AEC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v6 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel__startElevationUpdatesWithHandler_, *(_QWORD *)(a1 + 40), v7, v8);
}

uint64_t sub_18F4C8B70(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v5, sel__stopElevationUpdates, v6, v7, v8);
}

os_log_t sub_18F4C8B90()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Pressure");
  qword_1EE16D6C0 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4C8BBC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Altimeter");
  qword_1EE16D480 = (uint64_t)result;
  return result;
}

void sub_18F4C8BE8(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v4;
  void *__p[2];
  char v6;

  v4 = operator new(0x70uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_1E2952688;
  sub_18F270374(__p, "kCLConnectionMessageSignificantElevationUpdate");
  MEMORY[0x19400103C](v4 + 3, __p, *a2);
  if (v6 < 0)
    operator delete(__p[0]);
  *a1 = v4 + 3;
  a1[1] = v4;
}

void sub_18F4C8C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  std::__shared_weak_count *v15;
  void *v17;

  if (a15 < 0)
    operator delete(__p);
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v17);
  _Unwind_Resume(a1);
}

void sub_18F4C8DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  if (a25 < 0)
    operator delete(__p);
  MEMORY[0x194001438](v25, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

void sub_18F4C8E18(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  void *DictionaryOfClasses;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  char *v23;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v10)) != 0
    && (v15 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v12, (uint64_t)CFSTR("CMErrorMessage"), v13, v14)) != 0)
  {
    v20 = objc_msgSend_intValue(v15, v16, v17, v18, v19);
  }
  else
  {
    v20 = 103;
  }
  if (qword_1EE16D7F8 != -1)
    dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
  v21 = qword_1EE16D800;
  if (os_log_type_enabled((os_log_t)qword_1EE16D800, OS_LOG_TYPE_FAULT))
  {
    v22 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 67240448;
    v25 = v20;
    v26 = 2048;
    v27 = v22;
    _os_log_impl(&dword_18F1DC000, v21, OS_LOG_TYPE_FAULT, "Failed with CMError code %{public}d, %p", buf, 0x12u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D7F8 != -1)
      dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
    v23 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMSwimTrackerInternal init]_block_invoke", "CoreLocation: %s\n", v23);
    if (v23 != (char *)buf)
      free(v23);
  }
}

void sub_18F4C9050(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t ExecutablePathFromPid;
  uint64_t v7;
  NSObject *v8;
  pid_t v9;
  uint64_t v10;
  int v11;
  char *v12;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  pid_t v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = getpid();
  ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2, v4, v5);
  if (ExecutablePathFromPid)
  {
    v7 = ExecutablePathFromPid;
    if (qword_1EE16D7F8 != -1)
      dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
    v8 = qword_1EE16D800;
    if (os_log_type_enabled((os_log_t)qword_1EE16D800, OS_LOG_TYPE_INFO))
    {
      v9 = getpid();
      v10 = *(_QWORD *)(a1 + 32);
      v11 = *(unsigned __int8 *)(v10 + 24);
      *(_DWORD *)buf = 138413058;
      v14 = v7;
      v15 = 1024;
      v16 = v9;
      v17 = 1024;
      v18 = v11;
      v19 = 2048;
      v20 = v10;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "Client connection interrupt, %@, %d, %d, %p", buf, 0x22u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D7F8 != -1)
        dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
      getpid();
      v12 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSwimTrackerInternal init]_block_invoke", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf)
        free(v12);
    }
  }
}

void sub_18F4C9364(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  id v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  CMSwimData *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  const char *v20;
  uint64_t v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  unint64_t v26;
  const char *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  _QWORD v39[6];
  void *__p;
  std::__shared_weak_count *v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t (*v45)(uint64_t, uint64_t *);
  void *v46;
  uint64_t v47;
  uint64_t v48;
  std::__shared_weak_count *v49;
  uint64_t v50;
  std::__shared_weak_count *v51;
  uint64_t v52;
  const __CFString *v53;
  uint64_t v54;
  const __CFString *v55;
  void *v56;
  const __CFString *v57;
  _QWORD v58[2];

  v58[1] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void **)(v2 + 32);
  if (v3 != *(void **)(a1 + 48) || !*(_BYTE *)(v2 + 24))
  {

    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) = *(id *)(a1 + 48);
    objc_msgSend__resetOffsets(*(void **)(a1 + 32), v4, v5, v6, v7);
    v52 = 0;
    v9 = *(_QWORD *)(a1 + 40);
    if (v9)
    {
      v57 = CFSTR("CMSwimKeyDataRecord");
      v58[0] = v9;
      v52 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v8, (uint64_t)v58, (uint64_t)&v57, 1);
    }
    else
    {
      v10 = objc_alloc(MEMORY[0x1E0CB3A28]);
      v14 = (void *)objc_msgSend_initWithUUIDString_(v10, v11, (uint64_t)CFSTR("00000000-0000-0000-0000-000000000000"), v12, v13);
      v15 = [CMSwimData alloc];
      v19 = (void *)objc_msgSend_initWithSessionId_(v15, v16, (uint64_t)v14, v17, v18);
      v55 = CFSTR("CMSwimKeyDataRecord");
      v56 = v19;
      v52 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v20, (uint64_t)&v56, (uint64_t)&v55, 1);

    }
    sub_18F489C98("kCLConnectionMessageSwimDataQuery", &v52, &v50);
    v21 = *(_QWORD *)(a1 + 32);
    v48 = v50;
    v49 = v51;
    if (v51)
    {
      p_shared_owners = (unint64_t *)&v51->__shared_owners_;
      do
        v23 = __ldxr(p_shared_owners);
      while (__stxr(v23 + 1, p_shared_owners));
      v21 = *(_QWORD *)(a1 + 32);
    }
    v24 = MEMORY[0x1E0C809B0];
    v43 = MEMORY[0x1E0C809B0];
    v44 = 3221225472;
    v45 = sub_18F4C9744;
    v46 = &unk_1E2955DD8;
    v47 = v21;
    CLConnectionClient::sendMessage();
    if (v49)
    {
      v25 = &v49->__shared_owners_;
      do
        v26 = __ldaxr((unint64_t *)v25);
      while (__stlxr(v26 - 1, (unint64_t *)v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
      }
    }
    sub_18F270374(&__p, "kCLConnectionMessageSwimDataUpdate");
    v39[1] = v24;
    v39[2] = 3221225472;
    v39[3] = sub_18F4C9814;
    v39[4] = &unk_1E2955DD8;
    v39[5] = *(_QWORD *)(a1 + 32);
    CLConnectionClient::setHandlerForMessage();
    if (v42 < 0)
      operator delete(__p);
    v53 = CFSTR("kCLConnectionMessageSubscribeKey");
    v54 = MEMORY[0x1E0C9AAB0];
    v39[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v27, (uint64_t)&v54, (uint64_t)&v53, 1);
    sub_18F41EBF4("kCLConnectionMessageSwimDataUpdate", v39, &__p);
    v38 = v41;
    if (v41)
    {
      v28 = (unint64_t *)&v41->__shared_owners_;
      do
        v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }
    CLConnectionClient::sendMessage();
    if (v38)
    {
      v30 = (unint64_t *)&v38->__shared_owners_;
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 24) = 1;
    v32 = v41;
    if (v41)
    {
      v33 = (unint64_t *)&v41->__shared_owners_;
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    v35 = v51;
    if (v51)
    {
      v36 = (unint64_t *)&v51->__shared_owners_;
      do
        v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
  }
}

void sub_18F4C96E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,char a31)
{
  sub_18F2A8438((uint64_t)&a10);
  sub_18F2A8438((uint64_t)&__p);
  sub_18F2A8438((uint64_t)&a31);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4C9744(uint64_t result, uint64_t *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  NSSet *v12;
  uint64_t v13;
  uint64_t v14;

  if (*(_QWORD *)(*(_QWORD *)(result + 32) + 32))
  {
    v3 = result;
    v4 = (void *)MEMORY[0x1E0C99E60];
    v5 = objc_opt_class();
    v6 = objc_opt_class();
    v7 = objc_opt_class();
    v8 = objc_opt_class();
    v12 = (NSSet *)objc_msgSend_setWithObjects_(v4, v9, v5, v10, v11, v6, v7, v8, 0);
    result = *a2;
    if (*a2)
    {
      result = CLConnectionMessage::getDictionaryOfClasses((CLConnectionMessage *)result, v12);
      if (result)
        return MEMORY[0x1E0DE7D20](*(_QWORD *)(v3 + 32), sel__handleUpdates_, result, v13, v14);
    }
  }
  return result;
}

void sub_18F4C9814(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  id v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  NSSet *v17;
  uint64_t DictionaryOfClasses;
  uint64_t v19;
  uint64_t v20;
  _QWORD block[5];

  v6 = *(void **)(*(_QWORD *)(a1 + 32) + 32);
  if (v6)
  {
    v8 = (id)objc_msgSend_copy(v6, a2, a3, a4, a5);
    v9 = (void *)MEMORY[0x1E0C99E60];
    v10 = objc_opt_class();
    v11 = objc_opt_class();
    v12 = objc_opt_class();
    v13 = objc_opt_class();
    v17 = (NSSet *)objc_msgSend_setWithObjects_(v9, v14, v10, v15, v16, v11, v12, v13, 0);
    if (*(_QWORD *)a2
      && (DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v17)) != 0)
    {
      MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleUpdates_, DictionaryOfClasses, v19, v20);
    }
    else
    {
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = sub_18F4C993C;
      block[3] = &unk_1E2955B10;
      block[4] = v8;
      dispatch_async(MEMORY[0x1E0C80D38], block);
    }
  }
}

uint64_t sub_18F4C993C(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F4C99E0(uint64_t a1, const char *a2)
{
  unint64_t *v3;
  unint64_t v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  std::__shared_weak_count *v18;
  const __CFString *v19;
  uint64_t v20;
  _QWORD v21[2];
  int buf;
  _BYTE buf_4[12];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 24))
  {
    v19 = CFSTR("kCLConnectionMessageSubscribeKey");
    v20 = MEMORY[0x1E0C9AAA0];
    v21[0] = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)&v20, (uint64_t)&v19, 1);
    sub_18F41EBF4("kCLConnectionMessageSwimDataUpdate", v21, &buf);
    v18 = *(std::__shared_weak_count **)&buf_4[4];
    if (*(_QWORD *)&buf_4[4])
    {
      v3 = (unint64_t *)(*(_QWORD *)&buf_4[4] + 8);
      do
        v4 = __ldxr(v3);
      while (__stxr(v4 + 1, v3));
    }
    CLConnectionClient::sendMessage();
    if (v18)
    {
      p_shared_owners = (unint64_t *)&v18->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 24) = 0;
    objc_msgSend__resetOffsets(*(void **)(a1 + 32), v5, v6, v7, v8);
    v11 = *(std::__shared_weak_count **)&buf_4[4];
    if (*(_QWORD *)&buf_4[4])
    {
      v12 = (unint64_t *)(*(_QWORD *)&buf_4[4] + 8);
      do
        v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
  }
  else
  {
    if (qword_1EE16D7F8 != -1)
      dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
    v14 = qword_1EE16D800;
    if (os_log_type_enabled((os_log_t)qword_1EE16D800, OS_LOG_TYPE_INFO))
    {
      v15 = *(_QWORD *)(a1 + 32);
      buf = 134217984;
      *(_QWORD *)buf_4 = v15;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_INFO, "Unable to stop swim data updates as we are are not receiving updates, %p", (uint8_t *)&buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1EE16D7F8 != -1)
        dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
      v16 = *(_QWORD *)(a1 + 32);
      LODWORD(v21[0]) = 134217984;
      *(_QWORD *)((char *)v21 + 4) = v16;
      v17 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMSwimTrackerInternal _stopUpdates]_block_invoke", "CoreLocation: %s\n", v17);
      if (v17 != (char *)&buf)
        free(v17);
    }
  }
}

void sub_18F4C9CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_18F4C9D28(uint64_t a1, const char *a2)
{
  uint64_t v2;
  id v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  CMSwimData *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const char *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  const __CFString *v25;
  void *v26;
  const __CFString *v27;
  _QWORD v28[2];

  v28[1] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v27 = CFSTR("CMSwimKeyDataRecord");
    v28[0] = v2;
    v24 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v28, (uint64_t)&v27, 1);
  }
  else
  {
    v3 = objc_alloc(MEMORY[0x1E0CB3A28]);
    v7 = (void *)objc_msgSend_initWithUUIDString_(v3, v4, (uint64_t)CFSTR("00000000-0000-0000-0000-000000000000"), v5, v6);
    v8 = [CMSwimData alloc];
    v12 = (void *)objc_msgSend_initWithSessionId_(v8, v9, (uint64_t)v7, v10, v11);
    v25 = CFSTR("CMSwimKeyDataRecord");
    v26 = v12;
    v24 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v13, (uint64_t)&v26, (uint64_t)&v25, 1);

  }
  sub_18F489C98("kCLConnectionMessageSwimDataQuery", &v24, &v22);
  v21 = v23;
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  CLConnectionClient::sendMessage();
  if (v21)
  {
    v16 = (unint64_t *)&v21->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  v18 = v23;
  if (v23)
  {
    v19 = (unint64_t *)&v23->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
}

void sub_18F4C9F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4C9F38(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  NSSet *v16;
  void *DictionaryOfClasses;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  _QWORD v32[5];
  _QWORD v33[6];
  _QWORD v34[6];
  _QWORD block[5];
  int v36;
  uint64_t v37;
  uint8_t buf[4];
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v7 = (id)objc_msgSend_copy(*(void **)(a1 + 40), a2, a3, a4, a5);
  v8 = (void *)MEMORY[0x1E0C99E60];
  v9 = objc_opt_class();
  v10 = objc_opt_class();
  v11 = objc_opt_class();
  v12 = objc_opt_class();
  v16 = (NSSet *)objc_msgSend_setWithObjects_(v8, v13, v9, v14, v15, v10, v11, v12, 0);
  if (*(_QWORD *)a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v16)) != 0)
  {
    v21 = DictionaryOfClasses;
    v22 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v18, (uint64_t)CFSTR("CMErrorMessage"), v19, v20);
    v26 = objc_msgSend_objectForKeyedSubscript_(v21, v23, (uint64_t)CFSTR("CMSwimKeyDataArray"), v24, v25);
    if (v22)
    {
      v34[0] = MEMORY[0x1E0C809B0];
      v34[1] = 3221225472;
      v34[2] = sub_18F4CA2DC;
      v34[3] = &unk_1E2955B60;
      v34[4] = v22;
      v34[5] = v7;
      v27 = v34;
    }
    else if (v26)
    {
      v33[0] = MEMORY[0x1E0C809B0];
      v33[1] = 3221225472;
      v33[2] = sub_18F4CA33C;
      v33[3] = &unk_1E2955B60;
      v33[4] = v26;
      v33[5] = v7;
      v27 = v33;
    }
    else
    {
      if (qword_1EE16D7F8 != -1)
        dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
      v28 = qword_1EE16D800;
      if (os_log_type_enabled((os_log_t)qword_1EE16D800, OS_LOG_TYPE_FAULT))
      {
        v29 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)buf = 134217984;
        v39 = v29;
        _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_FAULT, "Unable to parse query message, %p", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D7F8 != -1)
          dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
        v30 = *(_QWORD *)(a1 + 32);
        v36 = 134217984;
        v37 = v30;
        v31 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMSwimTrackerInternal _querySwimUpdatesFromRecord:handler:]_block_invoke", "CoreLocation: %s\n", v31);
        if (v31 != (char *)buf)
          free(v31);
      }
      v32[0] = MEMORY[0x1E0C809B0];
      v32[1] = 3221225472;
      v32[2] = sub_18F4CA350;
      v32[3] = &unk_1E2955B10;
      v32[4] = v7;
      v27 = v32;
    }
  }
  else
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F4CA290;
    block[3] = &unk_1E2955B10;
    block[4] = v7;
    v27 = block;
  }
  dispatch_async(MEMORY[0x1E0C80D38], v27);
}

uint64_t sub_18F4CA290(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F4CA2DC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4CA33C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_18F4CA350(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F4CA5A8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  id v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  std::__shared_weak_count *v16;
  _QWORD block[5];
  uint64_t v18;
  const __CFString *v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    v19 = CFSTR("CMSwimSWOLFSessionIdKey");
    v20[0] = v5;
    v18 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], a2, (uint64_t)v20, (uint64_t)&v19, 1);
    sub_18F35C128("kCLConnectionMessageSwimSWOLFSessionQuery", &v18, &v15);
    v14 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        v7 = __ldxr(p_shared_owners);
      while (__stxr(v7 + 1, p_shared_owners));
    }
    CLConnectionClient::sendMessage();
    if (v14)
    {
      v8 = (unint64_t *)&v14->__shared_owners_;
      do
        v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    v10 = v16;
    if (v16)
    {
      v11 = (unint64_t *)&v16->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  else
  {
    v13 = (id)objc_msgSend_copy(*(void **)(a1 + 48), a2, a3, a4, a5);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F4CA790;
    block[3] = &unk_1E2955B10;
    block[4] = v13;
    dispatch_async(MEMORY[0x1E0C80D38], block);
  }
}

void sub_18F4CA76C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4CA790(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 107, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F4CA7DC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  void *DictionaryOfClasses;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  NSObject *v26;
  char *v27;
  _QWORD v28[5];
  __int16 v29;
  _QWORD v30[6];
  _QWORD v31[6];
  _QWORD block[5];
  uint8_t buf[1640];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v6 = (id)objc_msgSend_copy(*(void **)(a1 + 32), a2, a3, a4, a5);
  v7 = (void *)MEMORY[0x1E0C99E60];
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  v10 = objc_opt_class();
  v14 = (NSSet *)objc_msgSend_setWithObjects_(v7, v11, v8, v12, v13, v9, v10, 0);
  if (*(_QWORD *)a2
    && (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*(CLConnectionMessage **)a2, v14)) != 0)
  {
    v19 = DictionaryOfClasses;
    v20 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v16, (uint64_t)CFSTR("CMErrorMessage"), v17, v18);
    v24 = objc_msgSend_objectForKeyedSubscript_(v19, v21, (uint64_t)CFSTR("CMSwimSWOLFDataKey"), v22, v23);
    if (v20)
    {
      v31[0] = MEMORY[0x1E0C809B0];
      v31[1] = 3221225472;
      v31[2] = sub_18F4CAB40;
      v31[3] = &unk_1E2955B60;
      v31[4] = v20;
      v31[5] = v6;
      v25 = v31;
    }
    else if (v24)
    {
      v30[0] = MEMORY[0x1E0C809B0];
      v30[1] = 3221225472;
      v30[2] = sub_18F4CABA0;
      v30[3] = &unk_1E2955B60;
      v30[4] = v24;
      v30[5] = v6;
      v25 = v30;
    }
    else
    {
      if (qword_1EE16D7F8 != -1)
        dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
      v26 = qword_1EE16D800;
      if (os_log_type_enabled((os_log_t)qword_1EE16D800, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_FAULT, "Unable to parse kCLConnectionMessageSwimSWOLFSessionQuery message.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D7F8 != -1)
          dispatch_once(&qword_1EE16D7F8, &unk_1E2955408);
        v29 = 0;
        v27 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "-[CMSwimTrackerInternal _querySWOLFSummaryWithSessionID:handler:]_block_invoke", "CoreLocation: %s\n", v27);
        if (v27 != (char *)buf)
          free(v27);
      }
      v28[0] = MEMORY[0x1E0C809B0];
      v28[1] = 3221225472;
      v28[2] = sub_18F4CABB4;
      v28[3] = &unk_1E2955B10;
      v28[4] = v6;
      v25 = v28;
    }
  }
  else
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F4CAAF4;
    block[3] = &unk_1E2955B10;
    block[4] = v6;
    v25 = block;
  }
  dispatch_async(MEMORY[0x1E0C80D38], v25);
}

uint64_t sub_18F4CAAF4(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F4CAB40(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4CABA0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_18F4CABB4(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F4CB980(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  v5 = (void *)MEMORY[0x1E0CB35C8];
  v6 = *(_QWORD *)(a1 + 40);
  v7 = objc_msgSend_intValue(*(void **)(a1 + 32), a2, a3, a4, a5);
  v9 = objc_msgSend_errorWithDomain_code_userInfo_(v5, v8, (uint64_t)CFSTR("CMErrorDomain"), v7, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, 0, v9);
}

uint64_t sub_18F4CB9E0(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F4CBA2C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_18F4CBB30(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_18F4CBC20(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  const char *v7;
  uint64_t v8;

  v6 = (void *)objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return objc_msgSend__startUpdatesFromRecord_handler_(v6, v7, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), v8);
}

uint64_t sub_18F4CBCA4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v5, sel__stopUpdates, v6, v7, v8);
}

uint64_t sub_18F4CBD90(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, (uint64_t)CFSTR("com.apple.locationd.activity"), a4, a5);
  qword_1ECEDFD50 = result;
  return result;
}

uint64_t sub_18F4CBE90(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;

  result = objc_msgSend_isAuthorizedForEntitlement_(CMMotionUtils, a2, (uint64_t)CFSTR("com.apple.locationd.activity"), a4, a5);
  qword_1ECEDFD60 = result;
  return result;
}

os_log_t sub_18F4CBEC4()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Swimming");
  qword_1EE16D800 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4CC710()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "MotionAlarm");
  qword_1EE16D3F0 = (uint64_t)result;
  return result;
}

double sub_18F4CD9F8()
{
  uint64_t v0;

  v0 = mach_continuous_time();
  return sub_18F1FD20C(v0);
}

_QWORD *sub_18F4CE95C(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[5];

  *a1 = &off_1E29442B8;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  v2 = sub_18F204AE4();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = sub_18F4CE9EC;
  v4[3] = &unk_1E2955738;
  v4[4] = a1;
  sub_18F1F5E28(v2, (uint64_t)v4);
  return a1;
}

void sub_18F4CE9D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_18F2A8438(v1);
  _Unwind_Resume(a1);
}

BOOL sub_18F4CE9EC(uint64_t a1)
{
  return sub_18F4CE9F4(*(_QWORD *)(a1 + 32));
}

BOOL sub_18F4CE9F4(uint64_t a1)
{
  _BOOL8 v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  NSObject *v7;
  char *v9;
  uint64_t v10;
  char v11;
  __int16 v12;
  uint8_t buf[1640];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  sub_18F204AE4();
  sub_18F3DE6D4();
  v2 = +[CMOdometryManager isAvailable]_0();
  if (v2)
  {
    if (!*(_QWORD *)(a1 + 8))
    {
      v3 = (_QWORD *)sub_18F1E0F30();
      v10 = 0x160000FF0CLL;
      v11 = 0;
      sub_18F1E9BC8(v3, (uint64_t)&v10, (uint64_t *)buf);
      sub_18F346DC8(a1 + 8, (__int128 *)buf);
      v4 = *(std::__shared_weak_count **)&buf[8];
      if (*(_QWORD *)&buf[8])
      {
        v5 = (unint64_t *)(*(_QWORD *)&buf[8] + 8);
        do
          v6 = __ldaxr(v5);
        while (__stlxr(v6 - 1, v5));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      sub_18F203148(*(_QWORD *)(a1 + 8), (uint64_t)sub_18F4CEC98, a1);
    }
  }
  else
  {
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E29543C8);
    v7 = qword_1EE16D920;
    if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "Service unavailable.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D918 != -1)
        dispatch_once(&qword_1EE16D918, &unk_1E29543C8);
      v12 = 0;
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "BOOL CLSPUInertialOdometryInterface::openHidDevice()", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
  }
  return v2;
}

_QWORD *sub_18F4CEC28(_QWORD *a1)
{
  *a1 = &off_1E29442B8;
  sub_18F2A8438((uint64_t)(a1 + 1));
  return a1;
}

void sub_18F4CEC58(_QWORD *a1)
{
  *a1 = &off_1E29442B8;
  sub_18F2A8438((uint64_t)(a1 + 1));
  JUMPOUT(0x194001438);
}

void sub_18F4CEC98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v4;
  uint8_t *v5;
  NSObject *v6;
  uint8_t buf[4];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    IOHIDEventGetVendorDefinedData();
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E29543C8);
    v4 = qword_1EE16D920;
    if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_INFO, "Empty payload, returning", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D918 != -1)
        dispatch_once(&qword_1EE16D918, &unk_1E29543C8);
      v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLSPUInertialOdometryInterface::onIoHidEvent(IOHIDEventRef)", "CoreLocation: %s\n");
LABEL_19:
      if (v5 != buf)
        free(v5);
    }
  }
  else
  {
    if (qword_1EE16D918 != -1)
      dispatch_once(&qword_1EE16D918, &unk_1E29543C8);
    v6 = qword_1EE16D920;
    if (os_log_type_enabled((os_log_t)qword_1EE16D920, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "Event ref invalid", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D918 != -1)
        dispatch_once(&qword_1EE16D918, &unk_1E29543C8);
      v5 = (uint8_t *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLSPUInertialOdometryInterface::onIoHidEvent(IOHIDEventRef)", "CoreLocation: %s\n");
      goto LABEL_19;
    }
  }
}

os_log_t sub_18F4CF3A8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "InertialOdometry");
  qword_1EE16D920 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4CF3D4(_QWORD *a1)
{
  *a1 = &off_1E2949BA8;
  sub_18F1DEFD8((uint64_t)a1);
  return sub_18F4D370C((uint64_t)a1);
}

void sub_18F4CF40C(_QWORD *a1)
{
  sub_18F4CF3D4(a1);
  JUMPOUT(0x194001438);
}

void sub_18F4CF7E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_18F2A8438((uint64_t)&a10);
  sub_18F2A8438((uint64_t)&__p);
  _Unwind_Resume(a1);
}

void sub_18F4CF864(uint64_t a1, CLConnectionMessage **a2)
{
  void *Dictionary;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  char *v14;
  uint8_t buf[4];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  v7 = (void *)objc_msgSend_objectForKeyedSubscript_(Dictionary, v4, (uint64_t)CFSTR("CMBatchedSensorAvailable"), v5, v6);
  v12 = objc_msgSend_BOOLValue(v7, v8, v9, v10, v11);
  if (qword_1EE16D948 != -1)
    dispatch_once(&qword_1EE16D948, &unk_1E2944F00);
  v13 = qword_1EE16D950;
  if (os_log_type_enabled((os_log_t)qword_1EE16D950, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    v16 = v12;
    _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEFAULT, "[framework] received availability update %{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D948 != -1)
      dispatch_once(&qword_1EE16D948, &unk_1E2944F00);
    v14 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMBatchedSensorManagerInternal _connect]_block_invoke", "CoreLocation: %s\n", v14);
    if (v14 != (char *)buf)
      free(v14);
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 32) = v12;
}

void sub_18F4CFA34(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  NSSet *v9;
  void *DictionaryOfClasses;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  char *v27;
  _QWORD v28[5];
  int v29;
  _QWORD block[5];
  int v31;
  int v32;
  int v33;
  uint8_t buf[4];
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v9 = (NSSet *)objc_msgSend_setWithObjects_(v4, v6, v5, v7, v8, 0);
  DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v9);
  v14 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v11, (uint64_t)CFSTR("CMErrorMessage"), v12, v13);
  v19 = objc_msgSend_intValue(v14, v15, v16, v17, v18);
  if (qword_1EE16D948 != -1)
    dispatch_once(&qword_1EE16D948, &unk_1E2944F00);
  v20 = qword_1EE16D950;
  if (os_log_type_enabled((os_log_t)qword_1EE16D950, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    v35 = v19;
    _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_DEFAULT, "[framework] received error %{public}d", buf, 8u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D948 != -1)
      dispatch_once(&qword_1EE16D948, &unk_1E2944F00);
    v32 = 67240192;
    v33 = v19;
    v27 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMBatchedSensorManagerInternal _connect]_block_invoke", "CoreLocation: %s\n", v27);
    if (v27 != (char *)buf)
      free(v27);
  }
  v21 = *(_QWORD **)(a1 + 32);
  v22 = v21[5];
  v23 = MEMORY[0x1E0C809B0];
  if (v22)
  {
    v24 = v21[3];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F4CFCAC;
    block[3] = &unk_1E2955A80;
    block[4] = v22;
    v31 = v19;
    dispatch_async(v24, block);
    v21 = *(_QWORD **)(a1 + 32);
  }
  v25 = v21[7];
  if (v25)
  {
    v26 = v21[3];
    v28[0] = v23;
    v28[1] = 3221225472;
    v28[2] = sub_18F4CFCFC;
    v28[3] = &unk_1E2955A80;
    v28[4] = v25;
    v29 = v19;
    dispatch_async(v26, v28);
  }
}

uint64_t sub_18F4CFCAC(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), *(unsigned int *)(a1 + 40), 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

uint64_t sub_18F4CFCFC(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), *(unsigned int *)(a1 + 40), 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F4CFE7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F4D0498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  sub_18F2A8438((uint64_t)&a12);
  sub_18F2A8438((uint64_t)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4D04D4(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 109, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F4D0520(uint64_t a1, uint64_t *a2)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  char *v22;
  _QWORD block[6];
  __int16 v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint8_t buf[1640];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = (void *)objc_opt_class();
  v8 = (std::__shared_weak_count *)a2[1];
  v25 = *a2;
  v26 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v14 = (void *)objc_msgSend__newArrayByUnpackingAccelerometerBatch_(v4, v5, (uint64_t)&v25, v6, v7);
  v15 = v26;
  if (v26)
  {
    v16 = (unint64_t *)&v26->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = *(_QWORD **)(a1 + 32);
  v19 = v18[5];
  if (v19)
  {
    if (qword_1EE16D948 != -1)
      dispatch_once(&qword_1EE16D948, &unk_1E2944F00);
    v20 = qword_1EE16D950;
    if (os_log_type_enabled((os_log_t)qword_1EE16D950, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_INFO, "[framework-accel] invoking client handler", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D948 != -1)
        dispatch_once(&qword_1EE16D948, &unk_1E2944F00);
      v24 = 0;
      v22 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMBatchedSensorManagerInternal _startAccelerometerUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf)
        free(v22);
    }
    v21 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F4D07A0;
    block[3] = &unk_1E2955B60;
    block[4] = v14;
    block[5] = v19;
    dispatch_async(v21, block);
    v18 = *(_QWORD **)(a1 + 32);
  }
  objc_msgSend_setAccelBatch_(v18, v11, (uint64_t)v14, v12, v13);

}

void sub_18F4D0784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4D07A0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

void sub_18F4D0A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4D16C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  sub_18F2A8438((uint64_t)&a12);
  sub_18F2A8438((uint64_t)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4D1704(uint64_t a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], a2, (uint64_t)CFSTR("CMErrorDomain"), 109, 0);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v2 + 16))(v2, 0, v3);
}

void sub_18F4D1750(uint64_t a1, uint64_t *a2)
{
  void *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  char *v22;
  _QWORD block[6];
  __int16 v24;
  uint64_t v25;
  std::__shared_weak_count *v26;
  uint8_t buf[1640];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = (void *)objc_opt_class();
  v8 = (std::__shared_weak_count *)a2[1];
  v25 = *a2;
  v26 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v14 = (void *)objc_msgSend__newArrayByUnpackingDeviceMotionBatch_(v4, v5, (uint64_t)&v25, v6, v7);
  v15 = v26;
  if (v26)
  {
    v16 = (unint64_t *)&v26->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = *(_QWORD **)(a1 + 32);
  v19 = v18[7];
  if (v19)
  {
    if (qword_1EE16D948 != -1)
      dispatch_once(&qword_1EE16D948, &unk_1E2944F00);
    v20 = qword_1EE16D950;
    if (os_log_type_enabled((os_log_t)qword_1EE16D950, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_INFO, "[framework-dm] invoking client handler", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D948 != -1)
        dispatch_once(&qword_1EE16D948, &unk_1E2944F00);
      v24 = 0;
      v22 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMBatchedSensorManagerInternal _startDeviceMotionUpdatesWithHandler:]_block_invoke", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf)
        free(v22);
    }
    v21 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = sub_18F4D19D0;
    block[3] = &unk_1E2955B60;
    block[4] = v14;
    block[5] = v19;
    dispatch_async(v21, block);
    v18 = *(_QWORD **)(a1 + 32);
  }
  objc_msgSend_setDeviceMotionBatch_(v18, v11, (uint64_t)v14, v12, v13);

}

void sub_18F4D19B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4D19D0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), 0);
}

void sub_18F4D1CCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4D24BC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3, a4, a5);
}

void sub_18F4D2540(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(v1 + 8) + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_18F4D259C;
  block[3] = &unk_1E2955938;
  block[4] = v1;
  dispatch_async(v2, block);
}

uint64_t sub_18F4D259C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__startAccelerometerUpdates, a3, a4, a5);
}

void sub_18F4D2604(uint64_t a1)
{
  __int128 v1;
  NSObject *v2;
  _QWORD v3[4];
  __int128 v4;

  v3[0] = MEMORY[0x1E0C809B0];
  v1 = *(_OWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 16);
  v3[1] = 3221225472;
  v3[2] = sub_18F4D2664;
  v3[3] = &unk_1E2955B38;
  v4 = v1;
  dispatch_async(v2, v3);
}

uint64_t sub_18F4D2664(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__startAccelerometerUpdatesWithHandler_, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4D26CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__stopAccelerometerUpdates, a3, a4, a5);
}

void sub_18F4D275C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(v1 + 8) + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = sub_18F4D27B8;
  block[3] = &unk_1E2955938;
  block[4] = v1;
  dispatch_async(v2, block);
}

uint64_t sub_18F4D27B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__startDeviceMotionUpdates, a3, a4, a5);
}

void sub_18F4D2820(uint64_t a1)
{
  __int128 v1;
  NSObject *v2;
  _QWORD v3[4];
  __int128 v4;

  v3[0] = MEMORY[0x1E0C809B0];
  v1 = *(_OWORD *)(a1 + 32);
  v2 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 16);
  v3[1] = 3221225472;
  v3[2] = sub_18F4D2880;
  v3[3] = &unk_1E2955B38;
  v4 = v1;
  dispatch_async(v2, v3);
}

uint64_t sub_18F4D2880(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__startDeviceMotionUpdatesWithHandler_, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4D28E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__stopDeviceMotionUpdates, a3, a4, a5);
}

os_log_t sub_18F4D28FC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "BatchedSensor");
  qword_1EE16D950 = (uint64_t)result;
  return result;
}

void sub_18F4D2928(uint64_t a1, const char *a2)
{
  sub_18F204B88(a2);
}

uint64_t sub_18F4D2930(uint64_t a1)
{
  __CFRunLoopTimer *v2;
  void **v4;

  *(_QWORD *)a1 = &off_1E294A480;
  v2 = *(__CFRunLoopTimer **)(a1 + 56);
  if (v2)
  {
    CFRunLoopTimerInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 56));
  }
  sub_18F4D2994(a1);
  v4 = (void **)(a1 + 8);
  sub_18F4D4CBC(&v4);
  return a1;
}

void sub_18F4D2994(uint64_t a1)
{
  CFRunLoopRef Current;
  const char *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  char *v8;
  uint8_t buf[4];
  int v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v5 = off_1ECEDEE90;
    v3 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v10 = 0;
      v11 = 2082;
      v12 = "";
      v13 = 2082;
      v14 = "assert";
      v15 = 2081;
      v16 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLIoHidInterface] closeHid should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v6 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      *(_DWORD *)buf = 68289539;
      v10 = 0;
      v11 = 2082;
      v12 = "";
      v13 = 2082;
      v14 = "assert";
      v15 = 2081;
      v16 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLIoHidInterface] closeHid should be running on motion thread", "{\"msg%{public}.0s\":\"[CLIoHidInterface] closeHid should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v7 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v10 = 0;
      v11 = 2082;
      v12 = "";
      v13 = 2082;
      v14 = "assert";
      v15 = 2081;
      v16 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLIoHidInterface] closeHid should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
    goto LABEL_20;
  }
  if (*(_QWORD *)(a1 + 40))
  {
    sub_18F204AE4();
    IOHIDEventSystemClientUnscheduleWithRunLoop();
    IOHIDEventSystemClientUnregisterEventCallback();
    IOHIDEventSystemClientUnregisterResetCallback();
    IOHIDEventSystemClientUnregisterDeviceMatchingCallback();
    CFRelease(*(CFTypeRef *)(a1 + 40));
    *(_QWORD *)(a1 + 40) = 0;
  }
  v3 = (const char *)CMVO2MaxRetrocomputeState;
  if (qword_1ECEDEE98 != -1)
LABEL_20:
    dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
  v4 = off_1ECEDEE90;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_DEFAULT, "[CLIoHidInterface] Hid interface closed", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (*((_QWORD *)v3 + 467) != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v8 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLIoHidInterface::closeHid()", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf)
      free(v8);
  }
}

void sub_18F4D2DC0(uint64_t a1)
{
  sub_18F4D2930(a1);
  JUMPOUT(0x194001438);
}

void sub_18F4D2DE4(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  char *v4;
  uint8_t buf[8];
  uint64_t v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE98 != -1)
    dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
  v2 = off_1ECEDEE90;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_DEFAULT, "[CLIoHidInterface] It looks like our HID event system just become available (again)", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v4 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLIoHidInterface::onEventSystemReset(void *)", "CoreLocation: %s\n", v4);
    if (v4 != (char *)buf)
      free(v4);
  }
  v3 = sub_18F204AE4();
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  v6 = 3221225472;
  v7 = sub_18F4D3618;
  v8 = &unk_1E2955738;
  v9 = a1;
  sub_18F1F6514(v3, (uint64_t)buf);
}

void sub_18F4D2FB0(uint64_t a1, char *a2, __IOHIDServiceClient *a3)
{
  uint64_t *v5;
  uint64_t *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_weak_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  std::__shared_weak_count *v12;
  id v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  id v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  NSObject *v32;
  unint64_t *p_shared_owners;
  unint64_t v34;
  char *v35;
  void *context;
  uint8_t buf[4];
  uint64_t v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a2 == "REMOVED")
  {
    context = (void *)MEMORY[0x194001B4C]();
    v6 = *(uint64_t **)(a1 + 8);
    v5 = *(uint64_t **)(a1 + 16);
    if (v6 != v5)
    {
      while (1)
      {
        v7 = (std::__shared_weak_count *)v6[1];
        if (v7)
          break;
LABEL_34:
        v6 += 2;
        if (v6 == v5)
          goto LABEL_45;
      }
      v8 = *v6;
      p_shared_weak_owners = (unint64_t *)&v7->__shared_weak_owners_;
      do
        v10 = __ldxr(p_shared_weak_owners);
      while (__stxr(v10 + 1, p_shared_weak_owners));
      v11 = std::__shared_weak_count::lock(v7);
      if (!v11)
      {
LABEL_33:
        std::__shared_weak_count::__release_weak(v7);
        goto LABEL_34;
      }
      v12 = v11;
      if (v8 && *(_QWORD *)(v8 + 80) && (__IOHIDServiceClient *)sub_18F1FBD7C(v8) == a3)
      {
        v13 = (id)IOHIDServiceClientCopyProperty(a3, CFSTR("PrimaryUsagePage"));
        v18 = objc_msgSend_intValue(v13, v14, v15, v16, v17);
        v19 = (id)IOHIDServiceClientCopyProperty(a3, CFSTR("PrimaryUsage"));
        v24 = objc_msgSend_intValue(v19, v20, v21, v22, v23);
        if (qword_1ECEDEE98 != -1)
          dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
        v25 = off_1ECEDEE90;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEFAULT))
        {
          v26 = *(_QWORD *)(v8 + 152);
          *(_DWORD *)buf = 134284291;
          v38 = (uint64_t)a3;
          v39 = 1026;
          v40 = v18;
          v41 = 1026;
          v42 = v24;
          v43 = 2113;
          v44 = v26;
          _os_log_impl(&dword_18F1DC000, v25, OS_LOG_TYPE_DEFAULT, "[CLIoHidInterface] onServiceRemoval - IOHIDServiceClientRef for service %{private}p with usage pair {%{public}d, %{public}d} and property %{private}@ will be removed.", buf, 0x22u);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE98 != -1)
            dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
          v35 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLIoHidInterface::onServiceRemoval(void *, IOHIDServiceClientRef)", "CoreLocation: %s\n", v35);
          if (v35 != (char *)buf)
            free(v35);
        }
        (*(void (**)(_QWORD))(v8 + 80))(*(_QWORD *)(v8 + 88));
        sub_18F1F383C(v8, v27);
        sub_18F1F393C(a1, a3);
        if (sub_18F1FBD7C(v8))
        {
          sub_18F204B88((const char *)a1);
          if (qword_1ECEDEE98 != -1)
            dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
          v28 = off_1ECEDEE90;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEFAULT))
          {
            v29 = sub_18F1FBD7C(v8);
            v30 = *(_QWORD *)(v8 + 152);
            *(_DWORD *)buf = 134284291;
            v38 = v29;
            v39 = 1026;
            v40 = v18;
            v41 = 1026;
            v42 = v24;
            v43 = 2113;
            v44 = v30;
            _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_DEFAULT, "[CLIoHidInterface] onServiceRemoval - successfully switch to service %{private}p with usage pair {%{public}d, %{public}d} and property %{private}@.", buf, 0x22u);
          }
          if (!sub_18F1FCA08(115, 2))
            goto LABEL_29;
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE98 != -1)
            dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
          sub_18F1FBD7C(v8);
          v31 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLIoHidInterface::onServiceRemoval(void *, IOHIDServiceClientRef)", "CoreLocation: %s\n", v31);
        }
        else
        {
          if (qword_1ECEDEE98 != -1)
            dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
          v32 = off_1ECEDEE90;
          if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v32, OS_LOG_TYPE_DEFAULT, "[CLIoHidInterface] onServiceRemoval - no available alternatives", buf, 2u);
          }
          if (!sub_18F1FCA08(115, 2))
            goto LABEL_29;
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE98 != -1)
            dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
          v31 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLIoHidInterface::onServiceRemoval(void *, IOHIDServiceClientRef)", "CoreLocation: %s\n", v31);
        }
        if (v31 != (char *)buf)
          free(v31);
      }
LABEL_29:
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v34 = __ldaxr(p_shared_owners);
      while (__stlxr(v34 - 1, p_shared_owners));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
      goto LABEL_33;
    }
LABEL_45:
    objc_autoreleasePoolPop(context);
  }
}

void sub_18F4D35B0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v5;

  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::__shared_weak_count::__release_weak(v1);
  _Unwind_Resume(a1);
}

void sub_18F4D3618(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_weak_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  void (*v10)(_QWORD);
  unint64_t *p_shared_owners;
  unint64_t v12;

  v1 = *(_QWORD *)(a1 + 32);
  sub_18F1F393C((const char *)v1, 0);
  v2 = *(uint64_t **)(v1 + 8);
  v3 = *(uint64_t **)(v1 + 16);
  while (v2 != v3)
  {
    v4 = (std::__shared_weak_count *)v2[1];
    if (v4)
    {
      v5 = *v2;
      p_shared_weak_owners = (unint64_t *)&v4->__shared_weak_owners_;
      do
        v7 = __ldxr(p_shared_weak_owners);
      while (__stxr(v7 + 1, p_shared_weak_owners));
      v8 = std::__shared_weak_count::lock(v4);
      if (v8)
      {
        v9 = v8;
        if (v5)
        {
          v10 = *(void (**)(_QWORD))(v5 + 96);
          if (v10)
            v10(*(_QWORD *)(v5 + 104));
        }
        p_shared_owners = (unint64_t *)&v9->__shared_owners_;
        do
          v12 = __ldaxr(p_shared_owners);
        while (__stlxr(v12 - 1, p_shared_owners));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
      }
      std::__shared_weak_count::__release_weak(v4);
    }
    v2 += 2;
  }
}

void sub_18F4D36F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__shared_weak_count *v9;

  sub_18F2A8438((uint64_t)&a9);
  std::__shared_weak_count::__release_weak(v9);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4D370C(uint64_t a1)
{
  const void *v2;

  *(_QWORD *)a1 = &off_1E294C200;

  *(_QWORD *)(a1 + 160) = 0;
  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);

  *(_QWORD *)(a1 + 152) = 0;
  return a1;
}

void sub_18F4D3764(uint64_t a1)
{
  sub_18F4D370C(a1);
  JUMPOUT(0x194001438);
}

uint64_t sub_18F4D3788(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current;
  uint64_t result;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  int v12;
  int v13;
  NSObject *v14;
  int v15;
  int v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  result = sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v8 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      v10 = *(_DWORD *)(a1 + 16);
      v9 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v9;
      v23 = 1026;
      v24 = v10;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setNewServiceCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v11 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      v13 = *(_DWORD *)(a1 + 16);
      v12 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v12;
      v23 = 1026;
      v24 = v13;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLIoHidInterface] setNewServiceCallback should be called from motion thread", "{\"msg%{public}.0s\":\"[CLIoHidInterface] setNewServiceCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v14 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      v16 = *(_DWORD *)(a1 + 16);
      v15 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v15;
      v23 = 1026;
      v24 = v16;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setNewServiceCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
    }
    abort_report_np();
  }
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  return result;
}

uint64_t sub_18F4D3A58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current;
  uint64_t result;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  int v12;
  int v13;
  NSObject *v14;
  int v15;
  int v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v8 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      v10 = *(_DWORD *)(a1 + 16);
      v9 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v9;
      v23 = 1026;
      v24 = v10;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setServiceRemovalCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v11 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      v13 = *(_DWORD *)(a1 + 16);
      v12 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v12;
      v23 = 1026;
      v24 = v13;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLIoHidInterface] setServiceRemovalCallback should be called from motion thread", "{\"msg%{public}.0s\":\"[CLIoHidInterface] setServiceRemovalCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v14 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      v16 = *(_DWORD *)(a1 + 16);
      v15 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v15;
      v23 = 1026;
      v24 = v16;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setServiceRemovalCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
    }
    abort_report_np();
  }
  *(_QWORD *)(a1 + 80) = a2;
  *(_QWORD *)(a1 + 88) = a3;
  result = *(_QWORD *)(a1 + 24);
  if (result)
    return IOHIDServiceClientRegisterRemovalCallback();
  return result;
}

uint64_t sub_18F4D3D78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFRunLoopRef Current;
  uint64_t result;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  int v12;
  int v13;
  NSObject *v14;
  int v15;
  int v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  result = sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v8 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      v10 = *(_DWORD *)(a1 + 16);
      v9 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v9;
      v23 = 1026;
      v24 = v10;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setIoHidResetCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v11 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      v13 = *(_DWORD *)(a1 + 16);
      v12 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v12;
      v23 = 1026;
      v24 = v13;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLIoHidInterface] setIoHidResetCallback should be called from motion thread", "{\"msg%{public}.0s\":\"[CLIoHidInterface] setIoHidResetCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v14 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      v16 = *(_DWORD *)(a1 + 16);
      v15 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 1026;
      v22 = v15;
      v23 = 1026;
      v24 = v16;
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setIoHidResetCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
    }
    abort_report_np();
  }
  *(_QWORD *)(a1 + 96) = a2;
  *(_QWORD *)(a1 + 104) = a3;
  return result;
}

uint64_t sub_18F4D4048(uint64_t a1)
{
  CFRunLoopRef Current;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  uint8_t buf[4];
  int v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v4 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLIoHidInterface] should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v5 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      *(_DWORD *)buf = 68289539;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLIoHidInterface] should be running on motion thread", "{\"msg%{public}.0s\":\"[CLIoHidInterface] should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v6 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLIoHidInterface] should be running on motion thread\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
LABEL_25:
    abort_report_np();
  }
  sub_18F2044F4(*(_QWORD *)(a1 + 32));
  if (!*(_DWORD *)(a1 + 144))
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v7 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "eventType > 0";
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLIoHidInterface] must have event type set\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v8 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      *(_DWORD *)buf = 68289539;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "eventType > 0";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLIoHidInterface] must have event type set", "{\"msg%{public}.0s\":\"[CLIoHidInterface] must have event type set\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v9 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v11 = 0;
      v12 = 2082;
      v13 = "";
      v14 = 2082;
      v15 = "assert";
      v16 = 2081;
      v17 = "eventType > 0";
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLIoHidInterface] must have event type set\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_25;
  }
  return IOHIDServiceClientCopyEvent();
}

void sub_18F4D4518(uint64_t a1, const char *a2, NSObject *a3)
{
  CFRunLoopRef Current;
  const char *v7;
  NSObject *v8;
  const char *v9;
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  int v15;
  NSObject *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  char *v21;
  uint8_t buf[4];
  _BYTE v23[14];
  __int16 v24;
  int v25;
  __int16 v26;
  _BYTE v27[14];
  __int16 v28;
  const char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v13 = off_1ECEDEE90;
    v7 = "";
    a2 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      v15 = *(_DWORD *)(a1 + 16);
      v14 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      *(_DWORD *)v23 = 0;
      *(_WORD *)&v23[4] = 2082;
      *(_QWORD *)&v23[6] = "";
      v24 = 1026;
      v25 = v14;
      v26 = 1026;
      *(_DWORD *)v27 = v15;
      *(_WORD *)&v27[4] = 2082;
      *(_QWORD *)&v27[6] = "assert";
      v28 = 2081;
      v29 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setRegistryIDChangedCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v16 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      v18 = *(_DWORD *)(a1 + 16);
      v17 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      *(_DWORD *)v23 = 0;
      *(_WORD *)&v23[4] = 2082;
      *(_QWORD *)&v23[6] = "";
      v24 = 1026;
      v25 = v17;
      v26 = 1026;
      *(_DWORD *)v27 = v18;
      *(_WORD *)&v27[4] = 2082;
      *(_QWORD *)&v27[6] = "assert";
      v28 = 2081;
      v29 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLIoHidInterface] setRegistryIDChangedCallback should be called from motion thread", "{\"msg%{public}.0s\":\"[CLIoHidInterface] setRegistryIDChangedCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    a3 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      v20 = *(_DWORD *)(a1 + 16);
      v19 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)buf = 68290051;
      *(_DWORD *)v23 = 0;
      *(_WORD *)&v23[4] = 2082;
      *(_QWORD *)&v23[6] = "";
      v24 = 1026;
      v25 = v19;
      v26 = 1026;
      *(_DWORD *)v27 = v20;
      *(_WORD *)&v27[4] = 2082;
      *(_QWORD *)&v27[6] = "assert";
      v28 = 2081;
      v29 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, a3, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setRegistryIDChangedCallback should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
    }
    abort_report_np();
LABEL_23:
    dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    goto LABEL_5;
  }
  if (*(const char **)(a1 + 112) == a2 && *(NSObject **)(a1 + 120) == a3)
    return;
  v7 = (const char *)CMVO2MaxRetrocomputeState;
  if (qword_1ECEDEE98 != -1)
    goto LABEL_23;
LABEL_5:
  v8 = off_1ECEDEE90;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
  {
    v9 = "Opening";
    if (!*(_QWORD *)(a1 + 112))
      v9 = "Closing";
    v11 = *(_DWORD *)(a1 + 16);
    v10 = *(_DWORD *)(a1 + 20);
    v12 = *(_QWORD *)(a1 + 24);
    *(_DWORD *)buf = 136446979;
    *(_QWORD *)v23 = v9;
    *(_WORD *)&v23[8] = 1026;
    *(_DWORD *)&v23[10] = v10;
    v24 = 1026;
    v25 = v11;
    v26 = 2049;
    *(_QWORD *)v27 = v12;
    _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "%{public}s hid driver interface for usage pair {%{public}d, %{public}d}, hidServiceRef %{private}p", buf, 0x22u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (*((_QWORD *)v7 + 467) != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLIoHidInterface::Device::setRegistryIDChangedCallback(OnRegistryIDChanged, void *)", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
  }
  *(_QWORD *)(a1 + 112) = a2;
  *(_QWORD *)(a1 + 120) = a3;
}

uint64_t sub_18F4D49D8(_DWORD *a1, int a2)
{
  CFRunLoopRef Current;
  uint64_t result;
  NSObject *v6;
  int v7;
  int v8;
  NSObject *v9;
  int v10;
  int v11;
  NSObject *v12;
  int v13;
  int v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  result = sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    v6 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
    {
      v8 = a1[4];
      v7 = a1[5];
      *(_DWORD *)buf = 68290051;
      v16 = 0;
      v17 = 2082;
      v18 = "";
      v19 = 1026;
      v20 = v7;
      v21 = 1026;
      v22 = v8;
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setEventType should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v9 = off_1ECEDEE90;
    if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
    {
      v11 = a1[4];
      v10 = a1[5];
      *(_DWORD *)buf = 68290051;
      v16 = 0;
      v17 = 2082;
      v18 = "";
      v19 = 1026;
      v20 = v10;
      v21 = 1026;
      v22 = v11;
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "[CLIoHidInterface] setEventType should be called from motion thread", "{\"msg%{public}.0s\":\"[CLIoHidInterface] setEventType should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2945248);
    }
    v12 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
    {
      v14 = a1[4];
      v13 = a1[5];
      *(_DWORD *)buf = 68290051;
      v16 = 0;
      v17 = 2082;
      v18 = "";
      v19 = 1026;
      v20 = v13;
      v21 = 1026;
      v22 = v14;
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()";
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"[CLIoHidInterface] setEventType should be called from motion thread\", \"usagePage\":%{public}d, \"usage\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x32u);
    }
    abort_report_np();
  }
  a1[36] = a2;
  return result;
}

uint64_t sub_18F4D4CA4(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(_QWORD);

  v1 = *(_QWORD *)(result + 32);
  v2 = *(uint64_t (**)(_QWORD))(v1 + 64);
  if (v2)
    return v2(*(_QWORD *)(v1 + 72));
  return result;
}

void sub_18F4D4CBC(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_18F4D4CFC((uint64_t *)v2);
    operator delete(**a1);
  }
}

void sub_18F4D4CFC(uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  std::__shared_weak_count *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 16)
  {
    v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
  }
  a1[1] = v2;
}

void sub_18F4D5AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4D5F38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  sub_18F2A8438((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void sub_18F4D6294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  sub_18F2A8438((uint64_t)va);
  _Unwind_Resume(a1);
}

os_log_t sub_18F4D62D0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Kappa");
  qword_1EE16D840 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4D62FC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Fall");
  qword_1EE16D830 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4D6328()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Igneous");
  qword_1EE16D960 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4D660C()
{
  uint64_t v0;
  uint64_t v1;

  qword_1ECEDFD80 = (uint64_t)objc_alloc_init(MEMORY[0x1E0CB3578]);
  return MEMORY[0x1E0DE7D20](qword_1ECEDFD80, sel_setDateFormat_, CFSTR("yyyy-MM-dd HH:mm:ss Z"), v0, v1);
}

uint64_t sub_18F4D6638()
{
  if (qword_1EE16E8A0 != -1)
    dispatch_once(&qword_1EE16E8A0, &unk_1E2954488);
  return qword_1EE16E898;
}

void sub_18F4D6678()
{
  uint64_t v0;

  v0 = operator new();
  *(_QWORD *)v0 = 0;
  *(_QWORD *)(v0 + 16) = 0;
  *(_DWORD *)(v0 + 24) = 0;
  *(_QWORD *)(v0 + 32) = 0;
  sub_18F270374((_QWORD *)(v0 + 40), "");
  *(_OWORD *)(v0 + 64) = 0u;
  *(_OWORD *)(v0 + 80) = 0u;
  *(_DWORD *)(v0 + 96) = 1065353216;
  *(_OWORD *)(v0 + 104) = 0u;
  *(_OWORD *)(v0 + 120) = 0u;
  *(_DWORD *)(v0 + 136) = 1065353216;
  *(_OWORD *)(v0 + 144) = 0u;
  *(_OWORD *)(v0 + 160) = 0u;
  *(_DWORD *)(v0 + 176) = 1065353216;
  *(_OWORD *)(v0 + 184) = 0u;
  *(_OWORD *)(v0 + 200) = 0u;
  *(_DWORD *)(v0 + 216) = 1065353216;
  sub_18F4D679C(v0);
  qword_1EE16E898 = v0;
}

void sub_18F4D6740(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_18F4DD264(v5);
  sub_18F4DD264(v4);
  sub_18F4DD264(v6);
  sub_18F4DD264(v3);
  if (*(char *)(v1 + 63) < 0)
    operator delete(*v2);
  MEMORY[0x194001438](v1, 0x10B2C400E532B5FLL);
  _Unwind_Resume(a1);
}

void sub_18F4D679C(uint64_t a1)
{
  int v2;
  int v3;
  NSObject *v4;
  char *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  if (*(_QWORD *)(a1 + 8))
  {
    BTAccessoryManagerDeregisterCustomMessageClient();
    BTAccessoryManagerRemoveCallbacks();
    *(_QWORD *)(a1 + 8) = 0;
  }
  *(_QWORD *)a1 = 0;
  v2 = BTSessionAttachWithQueue();
  if (v2)
  {
    v3 = v2;
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v4 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      v7 = v3;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] Failed to register BT session callback. Error: %{public}d", buf, 8u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v5 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::attachBTSession()", "CoreLocation: %s\n", v5);
      if (v5 != (char *)buf)
        free(v5);
    }
  }
}

void sub_18F4D69AC(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  char *v6;
  char *v7;
  char __str[8];
  uint64_t v9;
  __int16 v10;
  uint8_t buf[4];
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *(_QWORD *)__str = 0;
    v9 = 0;
    v10 = 0;
    snprintf(__str, 0x12uLL, "%02x:%02x:%02x:%02x:%02x:%02x", a2, BYTE1(a2), BYTE2(a2), BYTE3(a2), BYTE4(a2), BYTE5(a2));
    MEMORY[0x1940012AC](a1 + 40, __str);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v3 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      v4 = a1 + 40;
      if (*(char *)(a1 + 63) < 0)
        v4 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 136380675;
      v12 = v4;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] BT address of the current device is %{private}s", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::setBTAddress(uint64_t)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
    sub_18F4D6D24(a1);
  }
  else
  {
    MEMORY[0x1940012AC](a1 + 40, "");
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v5 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] clear the BT address", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      *(_WORD *)__str = 0;
      v7 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::setBTAddress(uint64_t)", "CoreLocation: %s\n", v7);
      if (v7 != (char *)buf)
        free(v7);
    }

    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
}

void sub_18F4D6D24(uint64_t a1)
{
  CFRunLoopRef Current;
  uint64_t v3;
  _QWORD *v4;
  int v5;
  NSObject *v6;
  int v7;
  int v8;
  NSObject *v9;
  _QWORD *v10;
  NSObject *v11;
  uint64_t v12;
  char *v13;
  int v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  int DeviceId;
  int v19;
  NSObject *v20;
  uint64_t **i;
  char *v22;
  char *v23;
  _QWORD v24[5];
  int v25;
  _QWORD *v26;
  __int16 v27;
  int v28;
  uint8_t buf[4];
  _QWORD *v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    v3 = sub_18F204AE4();
    v24[0] = MEMORY[0x1E0C809B0];
    v24[1] = 3221225472;
    v24[2] = sub_18F4D74D4;
    v24[3] = &unk_1E2955738;
    v24[4] = a1;
    sub_18F1F5E28(v3, (uint64_t)v24);
    return;
  }
  if (!*(_QWORD *)a1)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v6 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] refresh device handle - invalid BT session", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      LOWORD(v25) = 0;
      goto LABEL_39;
    }
    return;
  }
  v4 = (_QWORD *)(a1 + 40);
  v5 = *(char *)(a1 + 63);
  if (v5 < 0)
  {
    if (*(_QWORD *)(a1 + 48) == 17)
      goto LABEL_17;
  }
  else if (v5 == 17)
  {
LABEL_17:
    v7 = BTDeviceAddressFromString();
    if (v7)
    {
      v8 = v7;
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v9 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
      {
        v10 = (_QWORD *)(a1 + 40);
        if (*(char *)(a1 + 63) < 0)
          v10 = (_QWORD *)*v4;
        *(_DWORD *)buf = 136380931;
        v30 = v10;
        v31 = 1026;
        v32 = v8;
        _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] refresh device handle - Failed to convert %{private}s into a valid BT address. Error: %{public}d", buf, 0x12u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        if (*(char *)(a1 + 63) < 0)
          v4 = (_QWORD *)*v4;
        v25 = 136380931;
        v26 = v4;
        v27 = 1026;
        v28 = v8;
        v22 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::refreshBTDevice()", "CoreLocation: %s\n", v22);
        if (v22 != (char *)buf)
          free(v22);
      }
      if (v8 == 1)
        sub_18F4D679C(a1);
      return;
    }
    v14 = BTDeviceFromAddress();
    if (v14)
    {
      v15 = v14;
      *(_QWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v16 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
      {
        v17 = a1 + 40;
        if (*(char *)(a1 + 63) < 0)
          v17 = *v4;
        *(_DWORD *)buf = 136380931;
        v30 = (_QWORD *)v17;
        v31 = 1026;
        v32 = v15;
        _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] refresh device handle - Failed to get the device handle with BT address %{private}s. Error: %{public}d", buf, 0x12u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        if (*(char *)(a1 + 63) < 0)
          v4 = (_QWORD *)*v4;
        v25 = 136380931;
        v26 = v4;
        v27 = 1026;
        v28 = v15;
LABEL_39:
        v13 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::refreshBTDevice()", "CoreLocation: %s\n", v13);
        if (v13 != (char *)buf)
          free(v13);
        return;
      }
    }
    else
    {
      DeviceId = BTDeviceGetDeviceId();
      if (DeviceId)
      {
        v19 = DeviceId;
        *(_DWORD *)(a1 + 24) = 0;
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v20 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          LODWORD(v30) = v19;
          _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] refresh device handle - Failed to get the product ID. Error: %{public}d", buf, 8u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          v25 = 67240192;
          LODWORD(v26) = v19;
          v23 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::refreshBTDevice()", "CoreLocation: %s\n", v23);
          if (v23 != (char *)buf)
            free(v23);
        }
      }
      sub_18F4D74DC(a1);
      for (i = *(uint64_t ***)(a1 + 160); i; i = (uint64_t **)*i)
        ((void (*)(_QWORD, uint64_t *))i[3])(0, i[2]);
    }
    return;
  }
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
  v11 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
  {
    v12 = a1 + 40;
    if (*(char *)(a1 + 63) < 0)
      v12 = *v4;
    *(_DWORD *)buf = 136380675;
    v30 = (_QWORD *)v12;
    _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] refresh device handle - invalid BT address %{private}s", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    if (*(char *)(a1 + 63) < 0)
      v4 = (_QWORD *)*v4;
    v25 = 136380675;
    v26 = v4;
    goto LABEL_39;
  }
}

uint64_t sub_18F4D74D4(uint64_t a1)
{
  return sub_18F4D6D24(*(_QWORD *)(a1 + 32));
}

void sub_18F4D74DC(uint64_t a1)
{
  CFRunLoopRef Current;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  const char *v10;
  const char *v11;
  int v12;
  NSObject *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  NSObject *v17;
  const char *v18;
  char *v19;
  const char *v20;
  const char *v21;
  char *v22;
  const char *v23;
  const char *v24;
  char *v25;
  _QWORD v26[5];
  int v27;
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  int v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    v3 = sub_18F204AE4();
    v26[0] = MEMORY[0x1E0C809B0];
    v26[1] = 3221225472;
    v26[2] = sub_18F4D896C;
    v26[3] = &unk_1E2955738;
    v26[4] = a1;
    sub_18F1F5E28(v3, (uint64_t)v26);
    return;
  }
  if (*(_QWORD *)(a1 + 16))
  {
    if (*(char *)(a1 + 63) < 0)
      v4 = *(_QWORD *)(a1 + 48);
    else
      v4 = *(unsigned __int8 *)(a1 + 63);
    if (v4 == 17)
    {
      v6 = *(_QWORD *)(a1 + 88);
      v7 = *(_QWORD *)(a1 + 128);
      v8 = BTAccessoryManagerRemoteTimeSyncEnable();
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v9 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
      {
        v10 = "disable";
        if (v6)
          v10 = "enable";
        *(_DWORD *)buf = 136446722;
        v34 = v10;
        if (v8)
          v11 = "failed";
        else
          v11 = "succeeded";
        v35 = 2082;
        v36 = v11;
        v37 = 1026;
        v38 = v8;
        _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] %{public}s high precision TimeSync %{public}s. Status: %{public}d", buf, 0x1Cu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v20 = "disable";
        if (v6)
          v20 = "enable";
        v27 = 136446722;
        v28 = v20;
        if (v8)
          v21 = "failed";
        else
          v21 = "succeeded";
        v29 = 2082;
        v30 = v21;
        v31 = 1026;
        v32 = v8;
        v22 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::updateTimeSync()", "CoreLocation: %s\n", v22);
        if (v22 != (char *)buf)
          free(v22);
      }
      if (!v6)
      {
        v12 = BTAccessoryManagerSensorStreamTimeSyncEnable();
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v13 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
        {
          v14 = "disable";
          if (v7)
            v14 = "enable";
          *(_DWORD *)buf = 136446722;
          v34 = v14;
          if (v12)
            v15 = "failed";
          else
            v15 = "succeeded";
          v35 = 2082;
          v36 = v15;
          v37 = 1026;
          v38 = v12;
          _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] %{public}s low precision TimeSync %{public}s. Status: %{public}d", buf, 0x1Cu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          v23 = "disable";
          if (v7)
            v23 = "enable";
          v27 = 136446722;
          v28 = v23;
          if (v12)
            v24 = "failed";
          else
            v24 = "succeeded";
          v29 = 2082;
          v30 = v24;
          v31 = 1026;
          v32 = v12;
          v25 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::updateTimeSync()", "CoreLocation: %s\n", v25);
          if (v25 != (char *)buf)
            free(v25);
        }
        if (!v7)
        {

          *(_QWORD *)(a1 + 32) = 0;
        }
      }
      return;
    }
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v16 = (const char *)(a1 + 40);
    v17 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      v18 = (const char *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0)
        v18 = *(const char **)v16;
      *(_DWORD *)buf = 136380675;
      v34 = v18;
      _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] update TimeSync failed due to invalid BT address %{private}s", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      if (*(char *)(a1 + 63) < 0)
        v16 = *(const char **)v16;
      v27 = 136380675;
      v28 = v16;
LABEL_52:
      v19 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::updateTimeSync()", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf)
        free(v19);
    }
  }
  else
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v5 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] update TimeSync failed due to invalid BT device", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      LOWORD(v27) = 0;
      goto LABEL_52;
    }
  }
}

uint64_t sub_18F4D7BF0(_QWORD *a1, uint64_t a2)
{
  NSObject *v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v6;
  char *v7;
  char *v8;
  uint8_t buf[4];
  char *v10;
  char __str[8];
  uint64_t v12;
  __int16 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!*a1)
    return 1;
  *(_QWORD *)__str = 0;
  v12 = 0;
  v13 = 0;
  snprintf(__str, 0x12uLL, "%02x:%02x:%02x:%02x:%02x:%02x", a2, BYTE1(a2), BYTE2(a2), BYTE3(a2), BYTE4(a2), BYTE5(a2));
  if (BTDeviceAddressFromString())
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v2 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136380675;
      v10 = __str;
      _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] isSpatialAudioSupported - Failed to convert %{private}s into a valid BT address", buf, 0xCu);
    }
    if (!sub_18F1FCA08(115, 0))
      return 1;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 == -1)
      goto LABEL_28;
LABEL_30:
    dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
LABEL_28:
    v8 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "BOOL CLAudioAccessoryInterface::isSpatialAudioSupported(uint64_t) const", "CoreLocation: %s\n", v8);
    if (v8 != (char *)buf)
      free(v8);
    return 1;
  }
  if (BTDeviceFromAddress())
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v3 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136380675;
      v10 = __str;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] isSpatialAudioSupported - Failed to get the device handle with BT address %{private}s", buf, 0xCu);
    }
    if (!sub_18F1FCA08(115, 0))
      return 1;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 == -1)
      goto LABEL_28;
    goto LABEL_30;
  }
  BTAccessoryManagerGetSpatialAudioPlatformSupport();
  v4 = 0;
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
  v6 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136380675;
    v10 = __str;
    _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] isSpatialAudioSupported - not supported for device %{private}s", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v7 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CLAudioAccessoryInterface::isSpatialAudioSupported(uint64_t) const", "CoreLocation: %s\n", v7);
    if (v7 != (char *)buf)
      free(v7);
  }
  return v4;
}

void sub_18F4D8088(uint64_t a1, uint64_t a2, int a3)
{
  CFRunLoopRef Current;
  uint64_t v7;
  float *v8;
  _QWORD v9[6];
  char v10;
  uint64_t v11;

  v11 = a2;
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current == *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (a3)
    {
      sub_18F4DD2AC((_QWORD *)(a1 + 104), &v11);
      v8 = (float *)(a1 + 64);
    }
    else
    {
      sub_18F4DD2AC((_QWORD *)(a1 + 64), &v11);
      v8 = (float *)(a1 + 104);
    }
    sub_18F4DD540(v8, &v11, &v11);
    sub_18F4D74DC(a1);
  }
  else
  {
    v7 = sub_18F204AE4();
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = sub_18F4D8160;
    v9[3] = &unk_1E2958D58;
    v9[4] = a1;
    v9[5] = a2;
    v10 = a3;
    sub_18F1F5E28(v7, (uint64_t)v9);
  }
}

uint64_t sub_18F4D8160(uint64_t a1)
{
  return sub_18F4D8088(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(unsigned __int8 *)(a1 + 48));
}

void sub_18F4D8170(uint64_t a1, uint64_t a2)
{
  CFRunLoopRef Current;
  uint64_t v5;
  _QWORD v6[6];
  uint64_t v7;

  v7 = a2;
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current == *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    sub_18F4DD2AC((_QWORD *)(a1 + 64), &v7);
    sub_18F4DD2AC((_QWORD *)(a1 + 104), &v7);
    sub_18F4D74DC(a1);
  }
  else
  {
    v5 = sub_18F204AE4();
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = sub_18F4D8224;
    v6[3] = &unk_1E2958238;
    v6[4] = a1;
    v6[5] = a2;
    sub_18F1F5E28(v5, (uint64_t)v6);
  }
}

uint64_t sub_18F4D8224(uint64_t a1)
{
  return sub_18F4D8170(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void sub_18F4D8230(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5)
{
  sub_18F4D98CC(a5, a3, a2, a4);
}

void sub_18F4D8244(uint64_t a1, uint64_t a2, int a3, _BYTE *a4, unint64_t a5, uint64_t a6)
{
  if (a3 == 1024)
    sub_18F4DA3DC(a6, a2, a4, a5);
}

void sub_18F4D8260(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  int Default;
  int v12;
  NSObject *v13;
  int v14;
  int v15;
  NSObject *v16;
  int v17;
  int v18;
  NSObject *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  uint8_t buf[4];
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2(MEMORY[0x1E0C80D38]);
  if ((a2 & 0xFFFFFFFD) != 0)
    return;
  if (a2 == 2 || !a2 && a3)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v8 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      v9 = "attaching BT session failed";
      if (a3 == 2)
        v9 = "BT session terminated";
      *(_DWORD *)buf = 136446210;
      v25 = v9;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] %{public}s. Re-attaching......", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v21 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::btSessionEventHandler(BTSession, BTSessionEvent, BTResult)", "CoreLocation: %s\n", v21);
      if (v21 != (char *)buf)
        free(v21);
    }
    sub_18F4D679C((uint64_t)a4);
    return;
  }
  *a4 = a1;
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
  v10 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] BT session attached", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v22 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::btSessionEventHandler(BTSession, BTSessionEvent, BTResult)", "CoreLocation: %s\n", v22);
    if (v22 != (char *)buf)
      free(v22);
  }
  Default = BTAccessoryManagerGetDefault();
  if (Default)
  {
    v12 = Default;
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v13 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v25) = v12;
      _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] Accessory Mananger unavailable. Status %{public}d", buf, 8u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 == -1)
      {
LABEL_40:
        v20 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::btSessionEventHandler(BTSession, BTSessionEvent, BTResult)", "CoreLocation: %s\n", v20);
        if (v20 != (char *)buf)
          free(v20);
        return;
      }
LABEL_55:
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      goto LABEL_40;
    }
  }
  else
  {
    sub_18F4D74DC((uint64_t)a4);
    v14 = BTAccessoryManagerAddCallbacks();
    if (v14)
    {
      v15 = v14;
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v16 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67240192;
        LODWORD(v25) = v15;
        _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] Failed to register BT accessory callback.  Status %{public}d", buf, 8u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v23 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::btSessionEventHandler(BTSession, BTSessionEvent, BTResult)", "CoreLocation: %s\n", v23);
        if (v23 != (char *)buf)
          free(v23);
      }
    }
    v17 = BTAccessoryManagerRegisterCustomMessageClient();
    if (!v17)
    {
      sub_18F4D6D24((uint64_t)a4);
      return;
    }
    v18 = v17;
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v19 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v25) = v18;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] Failed to register for custom callback. BTResult: %{public}d", buf, 8u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 == -1)
        goto LABEL_40;
      goto LABEL_55;
    }
  }
}

uint64_t sub_18F4D896C(uint64_t a1)
{
  return sub_18F4D74DC(*(_QWORD *)(a1 + 32));
}

uint64_t sub_18F4D8974(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v6;
  const char *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  double v12;
  NSObject *v13;
  NSObject *v14;
  char *v15;
  uint8_t buf[1640];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = *(void **)(a1 + 32);
  if (v6 && objc_msgSend_lockState(v6, a2, a3, a4, a5) == 2)
  {
    *(_DWORD *)buf = 0;
    return objc_msgSend_convertFromDomainToMachAbsoluteTime_withFlags_(*(void **)(a1 + 32), v8, (uint64_t)a2, (uint64_t)buf, v9);
  }
  v11 = mach_continuous_time();
  v12 = sub_18F1FD20C(v11);
  if (v12 - *(double *)&qword_1EE16E890 <= 1.0)
    return 0;
  if (!*(_QWORD *)(a1 + 32))
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v14 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] TimeSync error! No TimeSync clock", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_19;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 == -1)
      goto LABEL_21;
    goto LABEL_23;
  }
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
  v13 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] TimeSync error! Clock not locked", buf, 2u);
  }
  if (!sub_18F1FCA08(115, 0))
    goto LABEL_19;
  bzero(buf, 0x65CuLL);
  if (qword_1ECEDEE38 != -1)
LABEL_23:
    dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
LABEL_21:
  v15 = (char *)_os_log_send_and_compose_impl();
  sub_18F419700("Generic", 1, 0, 0, "uint64_t CLAudioAccessoryInterface::convertTimeSyncTimestamp(uint64_t) const", "CoreLocation: %s\n", v15);
  if (v15 != (char *)buf)
    free(v15);
LABEL_19:
  result = 0;
  qword_1EE16E890 = *(_QWORD *)&v12;
  return result;
}

void sub_18F4D8C40(uint64_t a1, int *a2, int *a3)
{
  uint64_t v6;
  NSObject *v7;
  int v8;
  int v9;
  NSObject *v10;
  NSObject *v11;
  const __CFString *v12;
  int v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  const __CFString *v18;
  uint64_t v19;
  const __CFString *v20;
  unsigned int v21;
  char *v22;
  char *v23;
  char *v24;
  uint8_t buf[4];
  const __CFString *v26;
  __int16 v27;
  const __CFString *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *a3 = 3;
  *a2 = 3;
  if (*(_QWORD *)(a1 + 16))
  {
    if (*(char *)(a1 + 63) < 0)
      v6 = *(_QWORD *)(a1 + 48);
    else
      v6 = *(unsigned __int8 *)(a1 + 63);
    if (v6 == 17)
    {
      v8 = BTAccessoryManagerGetInEarDetectionEnable();
      if (v8)
      {
        v9 = v8;
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v10 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67240192;
          LODWORD(v26) = v9;
          _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] in ear status - failed to get IED setting. Error: %{public}d", buf, 8u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 == -1)
          {
LABEL_52:
            v22 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::getInEarStatus(BTAccessoryInEarStatus &, BTAccessoryInEarStatus &) const", "CoreLocation: %s\n", v22);
            if (v22 != (char *)buf)
              free(v22);
            return;
          }
LABEL_62:
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          goto LABEL_52;
        }
      }
      else
      {
        v13 = BTAccessoryManagerGetInEarStatus();
        if (v13)
        {
          v14 = v13;
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          v15 = qword_1ECEDEE30;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67240192;
            LODWORD(v26) = v14;
            _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] in ear status - failed to get inear status. Error: %{public}d", buf, 8u);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            v23 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::getInEarStatus(BTAccessoryInEarStatus &, BTAccessoryInEarStatus &) const", "CoreLocation: %s\n", v23);
            if (v23 != (char *)buf)
              free(v23);
          }
          *a3 = 3;
          *a2 = 3;
        }
        else
        {
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          v16 = qword_1ECEDEE30;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
          {
            v17 = *a2;
            if (v17 > 3)
              v18 = CFSTR("?");
            else
              v18 = off_1E2959538[v17];
            v19 = *a3;
            if (v19 > 3)
              v20 = CFSTR("?");
            else
              v20 = off_1E2959538[v19];
            *(_DWORD *)buf = 138543618;
            v26 = v18;
            v27 = 2114;
            v28 = v20;
            _os_log_impl(&dword_18F1DC000, v16, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] in ear status - Primary:%{public}@, Secondary:%{public}@", buf, 0x16u);
          }
          if (sub_18F1FCA08(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            v24 = (char *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::getInEarStatus(BTAccessoryInEarStatus &, BTAccessoryInEarStatus &) const", "CoreLocation: %s\n", v24);
            if (v24 != (char *)buf)
              free(v24);
          }
          if (!*a2)
          {
            v21 = *(_DWORD *)(a1 + 24) - 8202;
            if (v21 <= 0x15 && ((1 << v21) & 0x202001) != 0)
              *a3 = 0;
          }
        }
      }
    }
    else
    {
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v11 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
      {
        v12 = (const __CFString *)(a1 + 40);
        if (*(char *)(a1 + 63) < 0)
          v12 = *(const __CFString **)(a1 + 40);
        *(_DWORD *)buf = 136380675;
        v26 = v12;
        _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] in ear status - invalid BT address %{private}s", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 == -1)
          goto LABEL_52;
        goto LABEL_62;
      }
    }
  }
  else
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v7 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] in ear status - invalid BT device", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 == -1)
        goto LABEL_52;
      goto LABEL_62;
    }
  }
}

BOOL sub_18F4D94F4()
{
  int v1;
  int v2;

  if (qword_1EE16E8A0 != -1)
    dispatch_once(&qword_1EE16E8A0, &unk_1E2954488);
  v2 = 0;
  v1 = 0;
  sub_18F4D8C40(qword_1EE16E898, &v2, &v1);
  return v2 == 0;
}

uint64_t sub_18F4D955C(uint64_t a1)
{
  int AdaptiveLatencyJitterBufferLevel;
  int v3;
  NSObject *v4;
  uint8_t *v5;
  NSObject *v6;
  uint8_t buf[4];
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  AdaptiveLatencyJitterBufferLevel = BTAccessoryManagerGetAdaptiveLatencyJitterBufferLevel();
  if (AdaptiveLatencyJitterBufferLevel)
  {
    v3 = AdaptiveLatencyJitterBufferLevel;
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v4 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67240192;
      v9 = v3;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] Failed to get jitter buffer level. Error: %{public}d", buf, 8u);
    }
    if (!sub_18F1FCA08(115, 0))
      return 0xFFFFLL;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v5 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "uint16_t CLAudioAccessoryInterface::getAdaptiveLatencyJitterBufferLevel() const", "CoreLocation: %s\n");
LABEL_21:
    if (v5 != buf)
      free(v5);
    return 0xFFFFLL;
  }
  if (*(_QWORD *)(a1 + 16) != 4294901761)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v6 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] Received jitter buffer level for unexpected BT device", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      return 0xFFFFLL;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v5 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "uint16_t CLAudioAccessoryInterface::getAdaptiveLatencyJitterBufferLevel() const", "CoreLocation: %s\n");
    goto LABEL_21;
  }
  return 0xFFFFLL;
}

_QWORD *sub_18F4D9864(uint64_t a1, uint64_t (*a2)(_QWORD, uint64_t), uint64_t a3)
{
  _QWORD *result;
  uint64_t v6;
  uint64_t *v7;

  v6 = a3;
  v7 = &v6;
  result = sub_18F4DD96C((float *)(a1 + 144), &v6, (uint64_t)&unk_18F506652, &v7);
  result[3] = a2;
  if (*(_QWORD *)(a1 + 16))
    return (_QWORD *)a2(0, v6);
  return result;
}

void sub_18F4D98CC(uint64_t a1, uint64_t a2, int a3, int a4)
{
  CFRunLoopRef Current;
  uint64_t v9;
  NSObject *v10;
  uint64_t **i;
  NSObject *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int TimeSyncId;
  int v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t **j;
  NSObject *v22;
  void *v23;
  NSObject *v24;
  uint8_t *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  id v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  _QWORD v43[6];
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  uint64_t v51;
  uint8_t buf[4];
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    v9 = sub_18F204AE4();
    v43[0] = MEMORY[0x1E0C809B0];
    v43[1] = 3221225472;
    v43[2] = sub_18F4DA3CC;
    v43[3] = &unk_1E2956F80;
    v43[4] = a1;
    v43[5] = a2;
    v44 = a3;
    v45 = a4;
    sub_18F1F5E28(v9, (uint64_t)v43);
    return;
  }
  switch(a3)
  {
    case 5:
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v10 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134283521;
        v53 = a2;
        _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] BT_ACCESSORY_SETTINGS_CHANGED device:%{private}p", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v46 = 134283521;
        v47 = a2;
        v39 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::accessoryEventHandler(BTDevice, BTAccessoryEvent, BTAccessoryState)", "CoreLocation: %s\n", v39);
        if (v39 != (char *)buf)
          free(v39);
      }
      for (i = *(uint64_t ***)(a1 + 160); i; i = (uint64_t **)*i)
        ((void (*)(_QWORD, uint64_t *))i[3])(0, i[2]);
      return;
    case 6:
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v20 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134283521;
        v53 = a2;
        _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] BT_ACCESSORY_IN_EAR_STATUS_CHANGED device:%{private}p", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v46 = 134283521;
        v47 = a2;
        v41 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::accessoryEventHandler(BTDevice, BTAccessoryEvent, BTAccessoryState)", "CoreLocation: %s\n", v41);
        if (v41 != (char *)buf)
          free(v41);
      }
      for (j = *(uint64_t ***)(a1 + 160); j; j = (uint64_t **)*j)
        ((void (*)(_QWORD, uint64_t *))j[3])(0, j[2]);
      return;
    case 7:
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v12 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134283521;
        v53 = a2;
        _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] TIMESYNC_AVAILABLE device:%{private}p", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v46 = 134283521;
        v47 = a2;
        v40 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::accessoryEventHandler(BTDevice, BTAccessoryEvent, BTAccessoryState)", "CoreLocation: %s\n", v40);
        if (v40 != (char *)buf)
          free(v40);
      }
      if (objc_msgSend_sharedClockManager(MEMORY[0x1E0DBF0E0], v13, v14, v15, v16))
      {
        TimeSyncId = BTAccessoryManagerGetTimeSyncId();
        if (TimeSyncId)
        {
          v18 = TimeSyncId;
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          v19 = qword_1ECEDEE30;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67240192;
            LODWORD(v53) = v18;
            _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] Get TimeSync ID failed result:%{public}d", buf, 8u);
          }
          if (sub_18F1FCA08(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            v46 = 67240192;
            LODWORD(v47) = v18;
LABEL_51:
            v25 = (uint8_t *)_os_log_send_and_compose_impl();
            sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::accessoryEventHandler(BTDevice, BTAccessoryEvent, BTAccessoryState)", "CoreLocation: %s\n");
LABEL_52:
            if (v25 != buf)
              free(v25);
          }
        }
        else
        {

          v30 = (void *)objc_msgSend_sharedClockManager(MEMORY[0x1E0DBF0E0], v26, v27, v28, v29);
          v34 = (id)objc_msgSend_clockWithClockIdentifier_(v30, v31, 0, v32, v33);
          *(_QWORD *)(a1 + 32) = v34;
          if (v34)
          {
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            v35 = qword_1ECEDEE30;
            if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
            {
              v36 = *(_QWORD *)(a1 + 32);
              *(_DWORD *)buf = 134284033;
              v53 = a2;
              v54 = 2049;
              v55 = 0;
              v56 = 2049;
              v57 = v36;
              _os_log_impl(&dword_18F1DC000, v35, OS_LOG_TYPE_DEFAULT, "[CLAudioAccessoryInterface] Got TimeSync ID device:%{private}p tsID:0x%{private}llx clock:%{private}p", buf, 0x20u);
            }
            if (sub_18F1FCA08(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE38 != -1)
                dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
              v37 = *(_QWORD *)(a1 + 32);
              v46 = 134284033;
              v47 = a2;
              v48 = 2049;
              v49 = 0;
              v50 = 2049;
              v51 = v37;
              v25 = (uint8_t *)_os_log_send_and_compose_impl();
              sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::accessoryEventHandler(BTDevice, BTAccessoryEvent, BTAccessoryState)", "CoreLocation: %s\n");
              goto LABEL_52;
            }
          }
          else
          {
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            v38 = qword_1ECEDEE30;
            if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18F1DC000, v38, OS_LOG_TYPE_ERROR, "[CLAuDioAccessoryInterface] Failed to get the TimeSync clock", buf, 2u);
            }
            if (sub_18F1FCA08(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1ECEDEE38 != -1)
                dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
              LOWORD(v46) = 0;
              goto LABEL_51;
            }
          }
        }
      }
      else
      {
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v24 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v24, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] Failed to get the TimeSync clock manager", buf, 2u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          LOWORD(v46) = 0;
          goto LABEL_51;
        }
      }
      return;
    case 8:
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v22 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134283521;
        v53 = a2;
        _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_ERROR, "[CLAudioAccessoryInterface] TIMESYNC_NOT_AVAILABLE device:%{private}p", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v46 = 134283521;
        v47 = a2;
        v42 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::accessoryEventHandler(BTDevice, BTAccessoryEvent, BTAccessoryState)", "CoreLocation: %s\n", v42);
        if (v42 != (char *)buf)
          free(v42);
      }
      v23 = *(void **)(a1 + 32);
      if (v23)
      {

        *(_QWORD *)(a1 + 32) = 0;
      }
      return;
    default:
      return;
  }
}

uint64_t sub_18F4DA3CC(uint64_t a1)
{
  return sub_18F4D98CC(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52));
}

void sub_18F4DA3DC(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t a4)
{
  NSObject *v4;
  _BYTE *v5;
  const char *v6;
  int v8;
  int v9;
  __int16 v10;
  int v11;
  int v12;
  NSObject *v14;
  NSObject *v15;
  unsigned __int16 v16;
  const void *v17;
  size_t v18;
  size_t v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  const char *v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  uint64_t v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  const char *v78;
  uint64_t v79;
  uint64_t v80;
  const char *v81;
  uint64_t v82;
  uint64_t v83;
  const char *v84;
  uint64_t v85;
  uint64_t v86;
  const char *v87;
  uint64_t v88;
  uint64_t v89;
  const char *v90;
  uint64_t v91;
  uint64_t v92;
  const char *v93;
  uint64_t v94;
  uint64_t v95;
  const char *v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  uint64_t v100;
  uint64_t v101;
  const char *v102;
  uint64_t v103;
  uint64_t v104;
  const char *v105;
  uint64_t v106;
  uint64_t v107;
  const char *v108;
  uint64_t v109;
  uint64_t v110;
  const char *v111;
  uint64_t v112;
  uint64_t v113;
  const char *v114;
  uint64_t v115;
  uint64_t v116;
  const char *v117;
  uint64_t v118;
  uint64_t v119;
  const char *v120;
  uint64_t v121;
  uint64_t v122;
  const char *v123;
  uint64_t v124;
  uint64_t v125;
  const char *v126;
  uint64_t v127;
  uint64_t v128;
  const char *v129;
  uint64_t v130;
  uint64_t v131;
  const char *v132;
  uint64_t v133;
  uint64_t v134;
  const char *v135;
  uint64_t v136;
  uint64_t v137;
  const char *v138;
  uint64_t v139;
  uint64_t v140;
  const char *v141;
  uint64_t v142;
  uint64_t v143;
  const char *v144;
  uint64_t v145;
  uint64_t v146;
  const char *v147;
  uint64_t v148;
  uint64_t v149;
  const char *v150;
  uint64_t v151;
  uint64_t v152;
  const char *v153;
  uint64_t v154;
  uint64_t v155;
  const char *v156;
  uint64_t v157;
  uint64_t v158;
  const char *v159;
  uint64_t v160;
  uint64_t v161;
  const char *v162;
  uint64_t v163;
  uint64_t v164;
  const char *v165;
  uint64_t v166;
  uint64_t v167;
  const char *v168;
  uint64_t v169;
  uint64_t v170;
  const char *v171;
  uint64_t v172;
  uint64_t v173;
  const char *v174;
  uint64_t v175;
  uint64_t v176;
  const char *v177;
  uint64_t v178;
  uint64_t v179;
  const char *v180;
  uint64_t v181;
  uint64_t v182;
  const char *v183;
  uint64_t v184;
  uint64_t v185;
  const char *v186;
  uint64_t v187;
  uint64_t v188;
  const char *v189;
  uint64_t v190;
  uint64_t v191;
  const char *v192;
  uint64_t v193;
  uint64_t v194;
  const char *v195;
  uint64_t v196;
  uint64_t v197;
  const char *v198;
  uint64_t v199;
  uint64_t v200;
  const char *v201;
  uint64_t v202;
  uint64_t v203;
  const char *v204;
  uint64_t v205;
  uint64_t v206;
  const char *v207;
  uint64_t v208;
  uint64_t v209;
  const char *v210;
  uint64_t v211;
  uint64_t v212;
  const char *v213;
  uint64_t v214;
  uint64_t v215;
  const char *v216;
  uint64_t v217;
  uint64_t v218;
  const char *v219;
  uint64_t v220;
  uint64_t v221;
  const char *v222;
  uint64_t v223;
  uint64_t v224;
  const char *v225;
  uint64_t v226;
  uint64_t v227;
  const char *v228;
  uint64_t v229;
  uint64_t v230;
  const char *v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  uint64_t v235;
  uint64_t v236;
  const char *v237;
  uint64_t v238;
  uint64_t v239;
  const char *v240;
  uint64_t v241;
  uint64_t v242;
  const char *v243;
  uint64_t v244;
  uint64_t v245;
  const char *v246;
  uint64_t v247;
  uint64_t v248;
  const char *v249;
  uint64_t v250;
  uint64_t v251;
  const char *v252;
  uint64_t v253;
  uint64_t v254;
  const char *v255;
  uint64_t v256;
  uint64_t v257;
  const char *v258;
  uint64_t v259;
  uint64_t v260;
  const char *v261;
  uint64_t v262;
  uint64_t v263;
  const char *v264;
  uint64_t v265;
  uint64_t v266;
  const char *v267;
  uint64_t v268;
  uint64_t v269;
  const char *v270;
  uint64_t v271;
  uint64_t v272;
  const char *v273;
  uint64_t v274;
  uint64_t v275;
  const char *v276;
  uint64_t v277;
  uint64_t v278;
  const char *v279;
  uint64_t v280;
  uint64_t v281;
  const char *v282;
  uint64_t v283;
  uint64_t v284;
  const char *v285;
  uint64_t v286;
  uint64_t v287;
  const char *v288;
  uint64_t v289;
  uint64_t v290;
  const char *v291;
  uint64_t v292;
  uint64_t v293;
  const char *v294;
  uint64_t v295;
  uint64_t v296;
  const char *v297;
  uint64_t v298;
  uint64_t v299;
  const char *v300;
  uint64_t v301;
  uint64_t v302;
  const char *v303;
  uint64_t v304;
  uint64_t v305;
  const char *v306;
  uint64_t v307;
  uint64_t v308;
  const char *v309;
  uint64_t v310;
  uint64_t v311;
  const char *v312;
  uint64_t v313;
  uint64_t v314;
  const char *v315;
  uint64_t v316;
  uint64_t v317;
  const char *v318;
  uint64_t v319;
  uint64_t v320;
  const char *v321;
  uint64_t v322;
  uint64_t v323;
  const char *v324;
  uint64_t v325;
  uint64_t v326;
  const char *v327;
  uint64_t v328;
  uint64_t v329;
  const char *v330;
  uint64_t v331;
  uint64_t v332;
  const char *v333;
  uint64_t v334;
  uint64_t v335;
  const char *v336;
  uint64_t v337;
  uint64_t v338;
  const char *v339;
  uint64_t v340;
  uint64_t v341;
  const char *v342;
  uint64_t v343;
  uint64_t v344;
  const char *v345;
  uint64_t v346;
  uint64_t v347;
  const char *v348;
  uint64_t v349;
  uint64_t v350;
  const char *v351;
  uint64_t v352;
  uint64_t v353;
  const char *v354;
  uint64_t v355;
  uint64_t v356;
  const char *v357;
  uint64_t v358;
  uint64_t v359;
  const char *v360;
  uint64_t v361;
  uint64_t v362;
  const char *v363;
  uint64_t v364;
  uint64_t v365;
  const char *v366;
  uint64_t v367;
  uint64_t v368;
  const char *v369;
  uint64_t v370;
  uint64_t v371;
  const char *v372;
  uint64_t v373;
  uint64_t v374;
  const char *v375;
  uint64_t v376;
  uint64_t v377;
  const char *v378;
  uint64_t v379;
  uint64_t v380;
  const char *v381;
  uint64_t v382;
  uint64_t v383;
  const char *v384;
  uint64_t v385;
  uint64_t v386;
  const char *v387;
  uint64_t v388;
  uint64_t v389;
  const char *v390;
  uint64_t v391;
  uint64_t v392;
  const char *v393;
  uint64_t v394;
  uint64_t v395;
  const char *v396;
  uint64_t v397;
  uint64_t v398;
  const char *v399;
  uint64_t v400;
  uint64_t v401;
  const char *v402;
  uint64_t v403;
  uint64_t v404;
  const char *v405;
  uint64_t v406;
  uint64_t v407;
  const char *v408;
  uint64_t v409;
  uint64_t v410;
  const char *v411;
  uint64_t v412;
  uint64_t v413;
  const char *v414;
  uint64_t v415;
  uint64_t v416;
  const char *v417;
  uint64_t v418;
  uint64_t v419;
  const char *v420;
  uint64_t v421;
  uint64_t v422;
  const char *v423;
  uint64_t v424;
  uint64_t v425;
  const char *v426;
  uint64_t v427;
  uint64_t v428;
  const char *v429;
  uint64_t v430;
  uint64_t v431;
  const char *v432;
  uint64_t v433;
  uint64_t v434;
  const char *v435;
  uint64_t v436;
  uint64_t v437;
  const char *v438;
  uint64_t v439;
  uint64_t v440;
  const char *v441;
  uint64_t v442;
  uint64_t v443;
  const char *v444;
  uint64_t v445;
  uint64_t v446;
  const char *v447;
  uint64_t v448;
  uint64_t v449;
  const char *v450;
  uint64_t v451;
  uint64_t v452;
  const char *v453;
  uint64_t v454;
  uint64_t v455;
  const char *v456;
  uint64_t v457;
  uint64_t v458;
  const char *v459;
  uint64_t v460;
  uint64_t v461;
  const char *v462;
  uint64_t v463;
  uint64_t v464;
  const char *v465;
  uint64_t v466;
  uint64_t v467;
  const char *v468;
  uint64_t v469;
  uint64_t v470;
  const char *v471;
  uint64_t v472;
  uint64_t v473;
  const char *v474;
  uint64_t v475;
  uint64_t v476;
  const char *v477;
  uint64_t v478;
  uint64_t v479;
  const char *v480;
  uint64_t v481;
  uint64_t v482;
  const char *v483;
  uint64_t v484;
  uint64_t v485;
  const char *v486;
  uint64_t v487;
  uint64_t v488;
  const char *v489;
  uint64_t v490;
  uint64_t v491;
  const char *v492;
  uint64_t v493;
  uint64_t v494;
  const char *v495;
  uint64_t v496;
  uint64_t v497;
  const char *v498;
  uint64_t v499;
  uint64_t v500;
  const char *v501;
  uint64_t v502;
  uint64_t v503;
  const char *v504;
  uint64_t v505;
  uint64_t v506;
  const char *v507;
  uint64_t v508;
  uint64_t v509;
  const char *v510;
  uint64_t v511;
  const char *v512;
  uint64_t v513;
  uint64_t v514;
  void *v515;
  const char *v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  unsigned __int16 *v520;
  uint64_t v521;
  const char *v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  const char *v526;
  uint64_t v527;
  const char *v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  const char *v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  const char *v536;
  uint64_t v537;
  const char *v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  const char *v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  const char *v546;
  uint64_t v547;
  const char *v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  const char *v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  const char *v556;
  uint64_t v557;
  const char *v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  const char *v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  const char *v566;
  uint64_t v567;
  unsigned int v568;
  const char *v569;
  uint64_t v570;
  uint64_t v571;
  uint64_t v572;
  const char *v573;
  uint64_t v574;
  uint64_t v575;
  uint64_t v576;
  const char *v577;
  uint64_t v578;
  uint64_t v579;
  const char *v580;
  uint64_t v581;
  const char *v582;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  const char *v586;
  uint64_t v587;
  const char *v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  const char *v592;
  uint64_t v593;
  const char *v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  const char *v598;
  uint64_t v599;
  const char *v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  const char *v604;
  uint64_t v605;
  const char *v606;
  uint64_t v607;
  uint64_t v608;
  uint64_t v609;
  const char *v610;
  uint64_t v611;
  const char *v612;
  uint64_t v613;
  uint64_t v614;
  uint64_t v615;
  const char *v616;
  uint64_t v617;
  uint64_t v618;
  id v619;
  const char *v620;
  uint64_t v621;
  uint64_t v622;
  void *v623;
  const char *v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  const char *v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  const char *v632;
  uint64_t v633;
  uint64_t v634;
  int AccessoryInfo;
  const char *v636;
  void *v637;
  const char *v638;
  uint64_t v639;
  uint64_t v640;
  void *v641;
  const char *v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  const char *v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t v649;
  const char *v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  const char *v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  const char *v658;
  uint64_t v659;
  const char *v660;
  uint64_t v661;
  const char *v662;
  uint64_t v663;
  NSObject *v664;
  NSObject *v665;
  NSObject *v666;
  NSObject *v667;
  NSObject *v668;
  NSObject *v669;
  _BYTE *v670;
  NSObject *v671;
  NSObject *v672;
  NSObject *v673;
  NSObject *v674;
  NSObject *v675;
  NSObject *v676;
  uint64_t **i;
  NSObject *v678;
  uint64_t *v679;
  uint64_t *v680;
  char *v681;
  char *v682;
  char *v683;
  char *v684;
  char *v685;
  uint64_t v687;
  _BYTE __dst[9];
  unsigned __int16 v689;
  unsigned __int16 v690;
  unsigned __int16 v691;
  unsigned __int16 v692;
  unsigned __int16 v693;
  unsigned __int16 v694;
  unsigned __int16 v695;
  unsigned __int16 v696;
  unsigned __int16 v697;
  unsigned __int16 v698;
  unsigned __int16 v699;
  unsigned __int16 v700;
  unsigned __int16 v701;
  unsigned __int16 v702;
  unsigned __int16 v703;
  unsigned __int8 v704;
  unsigned __int8 v705;
  unsigned __int8 v706;
  char v707;
  char v708;
  char v709;
  char v710;
  unsigned int v711;
  unsigned int v712;
  unsigned __int16 v713;
  unsigned __int8 v714;
  unsigned int v715;
  unsigned __int16 v716;
  unsigned __int16 v717;
  unsigned __int16 v718;
  unsigned __int16 v719;
  unsigned __int16 v720;
  unsigned __int16 v721;
  unsigned __int16 v722;
  unsigned __int16 v723;
  unsigned __int16 v724;
  unsigned __int16 v725;
  unsigned __int16 v726;
  unsigned __int16 v727;
  unsigned __int8 v728;
  unsigned __int8 v729;
  unsigned __int8 v730;
  char v731;
  char v732;
  char v733;
  char v734;
  unsigned int v735;
  unsigned int v736;
  unsigned __int16 v737;
  unsigned __int8 v738;
  unsigned int v739;
  unsigned __int16 v740;
  unsigned __int16 v741;
  unsigned __int16 v742;
  unsigned __int16 v743;
  unsigned __int16 v744;
  unsigned __int16 v745;
  unsigned __int16 v746;
  unsigned __int16 v747;
  unsigned __int16 v748;
  unsigned __int16 v749;
  unsigned __int16 v750;
  unsigned __int16 v751;
  unsigned __int16 v752;
  unsigned __int16 v753;
  unsigned __int16 v754;
  unsigned __int16 v755;
  unsigned __int16 v756;
  unsigned int v757;
  unsigned __int16 v758;
  unsigned __int8 v759;
  unsigned __int16 v760;
  unsigned __int16 v761;
  char v762;
  char v763;
  char v764;
  char v765;
  unsigned __int16 v766;
  char v767;
  char v768;
  unsigned int v769;
  unsigned __int16 v770;
  unsigned __int16 v771;
  unsigned __int16 v772;
  unsigned __int16 v773;
  unsigned __int16 v774;
  unsigned __int16 v775;
  unsigned __int16 v776;
  unsigned __int16 v777;
  unsigned __int16 v778;
  unsigned __int16 v779;
  unsigned __int16 v780;
  _DWORD v781[6];
  unsigned __int16 v782;
  unsigned __int16 v783;
  unsigned __int16 v784;
  unsigned __int16 v785;
  unsigned __int16 v786;
  unsigned __int16 v787;
  _WORD v788[3];
  int v789;
  int v790;
  int v791;
  int v792;
  int v793;
  int v794;
  int v795;
  _BYTE v796[18];
  unsigned int v797;
  unsigned __int16 v798;
  unsigned __int16 v799;
  unsigned __int16 v800;
  unsigned __int16 v801;
  _WORD v802[3];
  int v803;
  int v804;
  int v805;
  int v806;
  int v807;
  int v808;
  int v809;
  _BYTE v810[18];
  unsigned int v811;
  unsigned int v812;
  unsigned int v813;
  unsigned int v814;
  unsigned int v815;
  unsigned int v816;
  unsigned int v817;
  unsigned __int16 v818;
  unsigned __int16 v819;
  unsigned __int16 v820;
  unsigned __int16 v821;
  unsigned __int16 v822;
  unsigned __int16 v823;
  unsigned __int16 v824;
  unsigned __int16 v825;
  unsigned __int16 v826;
  unsigned __int16 v827;
  unsigned __int16 v828;
  unsigned __int16 v829;
  unsigned __int16 v830;
  unsigned __int16 v831;
  unsigned int v832;
  unsigned int v833;
  unsigned int v834;
  unsigned int v835;
  unsigned int v836;
  unsigned int v837;
  unsigned int v838;
  unsigned int v839;
  unsigned int v840;
  unsigned int v841;
  unsigned int v842;
  unsigned int v843;
  unsigned int v844;
  unsigned int v845;
  unsigned __int8 v846;
  unsigned __int8 v847;
  unsigned int v848;
  unsigned __int8 v849;
  unsigned __int8 v850;
  unsigned __int8 v851;
  unsigned __int8 v852;
  unsigned __int8 v853;
  unsigned int v854;
  unsigned __int8 v855;
  _BYTE v856[72];
  _BYTE v857[32];
  const __CFString *v858;
  const __CFString *v859;
  const __CFString *v860;
  const __CFString *v861;
  const __CFString *v862;
  const __CFString *v863;
  const __CFString *v864;
  const __CFString *v865;
  const __CFString *v866;
  const __CFString *v867;
  const __CFString *v868;
  const __CFString *v869;
  const __CFString *v870;
  const __CFString *v871;
  const __CFString *v872;
  const __CFString *v873;
  const __CFString *v874;
  const __CFString *v875;
  const __CFString *v876;
  const __CFString *v877;
  const __CFString *v878;
  const __CFString *v879;
  const __CFString *v880;
  const __CFString *v881;
  const __CFString *v882;
  const __CFString *v883;
  const __CFString *v884;
  const __CFString *v885;
  const __CFString *v886;
  const __CFString *v887;
  const __CFString *v888;
  const __CFString *v889;
  const __CFString *v890;
  const __CFString *v891;
  const __CFString *v892;
  const __CFString *v893;
  const __CFString *v894;
  const __CFString *v895;
  const __CFString *v896;
  const __CFString *v897;
  const __CFString *v898;
  const __CFString *v899;
  const __CFString *v900;
  const __CFString *v901;
  const __CFString *v902;
  const __CFString *v903;
  const __CFString *v904;
  const __CFString *v905;
  const __CFString *v906;
  const __CFString *v907;
  const __CFString *v908;
  const __CFString *v909;
  const __CFString *v910;
  const __CFString *v911;
  const __CFString *v912;
  const __CFString *v913;
  const __CFString *v914;
  const __CFString *v915;
  const __CFString *v916;
  const __CFString *v917;
  const __CFString *v918;
  const __CFString *v919;
  const __CFString *v920;
  const __CFString *v921;
  const __CFString *v922;
  const __CFString *v923;
  const __CFString *v924;
  const __CFString *v925;
  const __CFString *v926;
  const __CFString *v927;
  const __CFString *v928;
  const __CFString *v929;
  const __CFString *v930;
  const __CFString *v931;
  const __CFString *v932;
  const __CFString *v933;
  const __CFString *v934;
  const __CFString *v935;
  const __CFString *v936;
  const __CFString *v937;
  const __CFString *v938;
  const __CFString *v939;
  const __CFString *v940;
  const __CFString *v941;
  const __CFString *v942;
  const __CFString *v943;
  const __CFString *v944;
  const __CFString *v945;
  const __CFString *v946;
  const __CFString *v947;
  const __CFString *v948;
  const __CFString *v949;
  const __CFString *v950;
  const __CFString *v951;
  const __CFString *v952;
  const __CFString *v953;
  const __CFString *v954;
  const __CFString *v955;
  const __CFString *v956;
  const __CFString *v957;
  const __CFString *v958;
  const __CFString *v959;
  const __CFString *v960;
  const __CFString *v961;
  const __CFString *v962;
  const __CFString *v963;
  const __CFString *v964;
  const __CFString *v965;
  const __CFString *v966;
  const __CFString *v967;
  const __CFString *v968;
  const __CFString *v969;
  const __CFString *v970;
  const __CFString *v971;
  const __CFString *v972;
  const __CFString *v973;
  const __CFString *v974;
  const __CFString *v975;
  const __CFString *v976;
  const __CFString *v977;
  const __CFString *v978;
  const __CFString *v979;
  const __CFString *v980;
  const __CFString *v981;
  const __CFString *v982;
  const __CFString *v983;
  const __CFString *v984;
  const __CFString *v985;
  const __CFString *v986;
  const __CFString *v987;
  const __CFString *v988;
  const __CFString *v989;
  const __CFString *v990;
  const __CFString *v991;
  const __CFString *v992;
  const __CFString *v993;
  const __CFString *v994;
  const __CFString *v995;
  const __CFString *v996;
  const __CFString *v997;
  const __CFString *v998;
  const __CFString *v999;
  const __CFString *v1000;
  const __CFString *v1001;
  const __CFString *v1002;
  const __CFString *v1003;
  const __CFString *v1004;
  const __CFString *v1005;
  const __CFString *v1006;
  const __CFString *v1007;
  const __CFString *v1008;
  const __CFString *v1009;
  const __CFString *v1010;
  const __CFString *v1011;
  const __CFString *v1012;
  const __CFString *v1013;
  const __CFString *v1014;
  const __CFString *v1015;
  const __CFString *v1016;
  _BYTE buf[32];
  uint64_t v1018;
  uint64_t v1019;
  uint64_t v1020;
  uint64_t v1021;
  uint64_t v1022;
  uint64_t v1023;
  uint64_t v1024;
  uint64_t v1025;
  uint64_t v1026;
  uint64_t v1027;
  uint64_t v1028;
  uint64_t v1029;
  uint64_t v1030;
  uint64_t v1031;
  uint64_t v1032;
  uint64_t v1033;
  uint64_t v1034;
  uint64_t v1035;
  uint64_t v1036;
  uint64_t v1037;
  uint64_t v1038;
  uint64_t v1039;
  uint64_t v1040;
  uint64_t v1041;
  uint64_t v1042;
  uint64_t v1043;
  uint64_t v1044;
  uint64_t v1045;
  uint64_t v1046;
  uint64_t v1047;
  uint64_t v1048;
  uint64_t v1049;
  uint64_t v1050;
  uint64_t v1051;
  uint64_t v1052;
  uint64_t v1053;
  uint64_t v1054;
  uint64_t v1055;
  uint64_t v1056;
  uint64_t v1057;
  uint64_t v1058;
  uint64_t v1059;
  uint64_t v1060;
  uint64_t v1061;
  uint64_t v1062;
  uint64_t v1063;
  uint64_t v1064;
  uint64_t v1065;
  uint64_t v1066;
  uint64_t v1067;
  uint64_t v1068;
  uint64_t v1069;
  uint64_t v1070;
  uint64_t v1071;
  uint64_t v1072;
  uint64_t v1073;
  uint64_t v1074;
  uint64_t v1075;
  uint64_t v1076;
  uint64_t v1077;
  uint64_t v1078;
  uint64_t v1079;
  uint64_t v1080;
  uint64_t v1081;
  uint64_t v1082;
  uint64_t v1083;
  uint64_t v1084;
  uint64_t v1085;
  uint64_t v1086;
  uint64_t v1087;
  uint64_t v1088;
  uint64_t v1089;
  uint64_t v1090;
  uint64_t v1091;
  uint64_t v1092;
  uint64_t v1093;
  uint64_t v1094;
  uint64_t v1095;
  uint64_t v1096;
  uint64_t v1097;
  uint64_t v1098;
  uint64_t v1099;
  uint64_t v1100;
  uint64_t v1101;
  uint64_t v1102;
  uint64_t v1103;
  uint64_t v1104;
  uint64_t v1105;
  uint64_t v1106;
  uint64_t v1107;
  uint64_t v1108;
  uint64_t v1109;
  uint64_t v1110;
  uint64_t v1111;
  uint64_t v1112;
  uint64_t v1113;
  uint64_t v1114;
  uint64_t v1115;
  uint64_t v1116;
  uint64_t v1117;
  uint64_t v1118;
  uint64_t v1119;
  uint64_t v1120;
  uint64_t v1121;
  uint64_t v1122;
  uint64_t v1123;
  uint64_t v1124;
  uint64_t v1125;
  uint64_t v1126;
  uint64_t v1127;
  uint64_t v1128;
  uint64_t v1129;
  uint64_t v1130;
  uint64_t v1131;
  uint64_t v1132;
  uint64_t v1133;
  uint64_t v1134;
  uint64_t v1135;
  uint64_t v1136;
  uint64_t v1137;
  uint64_t v1138;
  uint64_t v1139;
  uint64_t v1140;
  uint64_t v1141;
  uint64_t v1142;
  uint64_t v1143;
  uint64_t v1144;
  uint64_t v1145;
  uint64_t v1146;
  uint64_t v1147;
  uint64_t v1148;
  uint64_t v1149;
  uint64_t v1150;
  uint64_t v1151;
  uint64_t v1152;
  uint64_t v1153;
  uint64_t v1154;
  uint64_t v1155;
  uint64_t v1156;
  uint64_t v1157;
  uint64_t v1158;
  uint64_t v1159;
  uint64_t v1160;
  uint64_t v1161;
  uint64_t v1162;
  uint64_t v1163;
  uint64_t v1164;
  uint64_t v1165;
  uint64_t v1166;
  uint64_t v1167;
  uint64_t v1168;
  uint64_t v1169;
  uint64_t v1170;
  uint64_t v1171;
  uint64_t v1172;
  uint64_t v1173;
  uint64_t v1174;
  uint64_t v1175;
  uint64_t v1176;
  uint64_t v1177;

  v1177 = *MEMORY[0x1E0C80C00];
  if (a4 <= 5)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v4 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_ERROR, "[HeadphoneUsage] isValidDailyUsageMessage: Invalid header size", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      *(_WORD *)v857 = 0;
LABEL_10:
      v5 = (_BYTE *)_os_log_send_and_compose_impl();
      v6 = "static BOOL BT::CLAudioAccessoryHelper::isValidDailyUsageMessage(BTData _Nonnull, size_t)";
LABEL_11:
      sub_18F419700("Generic", 1, 0, 0, v6, "CoreLocation: %s\n");
      goto LABEL_59;
    }
    return;
  }
  if (*a3 != 4)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v664 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v664, OS_LOG_TYPE_DEBUG, "[HeadphoneUsage] Ignoring, not an AACP Log Message ", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    *(_WORD *)v857 = 0;
LABEL_58:
    v5 = (_BYTE *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "static BOOL BT::CLAudioAccessoryHelper::isValidDailyUsageMessage(BTData _Nonnull, size_t)", "CoreLocation: %s\n");
LABEL_59:
    if (v5 != buf)
      free(v5);
    return;
  }
  v8 = a3[3] & 0x3F;
  if (v8 != 1)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v665 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v8;
      _os_log_impl(&dword_18F1DC000, v665, OS_LOG_TYPE_DEBUG, "[HeadphoneUsage] isValidDailyUsageMessage: Ignoring message type (%d) that is not DailyUsage", buf, 8u);
    }
    if (!sub_18F1FCA08(115, 2))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    *(_DWORD *)v857 = 67109120;
    *(_DWORD *)&v857[4] = v8;
    goto LABEL_58;
  }
  v9 = a3[5];
  if ((v9 - 7) > 1)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v666 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v9;
      _os_log_impl(&dword_18F1DC000, v666, OS_LOG_TYPE_INFO, "[HeadphoneUsage] Unexpected AWD version %d", buf, 8u);
    }
    if (!sub_18F1FCA08(115, 2))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    *(_DWORD *)v857 = 67109120;
    *(_DWORD *)&v857[4] = v9;
    goto LABEL_58;
  }
  v10 = a4;
  v11 = word_18F509C5E[15 * a3[5] + 1];
  v12 = (unsigned __int16)(a4 - 4);
  if (v12 == v11)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v14 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_DEBUG, "[HeadphoneUsage] Bluetooth message passed sanity checks.", buf, 2u);
    }
    v687 = a1;
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      *(_WORD *)v857 = 0;
      v682 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static BOOL BT::CLAudioAccessoryHelper::isValidDailyUsageMessage(BTData _Nonnull, size_t)", "CoreLocation: %s\n", v682);
      if (v682 != buf)
        free(v682);
    }
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v15 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_DEFAULT, "[HeadphoneUsage] Interface: Bluetooth daily usage event received. Parsing data.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      *(_WORD *)v857 = 0;
      v683 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::dailyUsageEventHandler(BTDevice, BTData, size_t)", "CoreLocation: %s\n", v683);
      if (v683 != buf)
        free(v683);
    }
    v16 = v10 - 4;
    v17 = a3 + 4;
    v18 = (unsigned __int16)(v10 - 4);
    if (v18 <= 0x2D4)
      v19 = 725 - v16;
    else
      v19 = 0;
    bzero(&__dst[v16], v19);
    memcpy(__dst, v17, v18);
    v20 = (void *)MEMORY[0x1E0C99E08];
    *(_QWORD *)v857 = CFSTR("bud_type");
    *(_QWORD *)buf = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v21, __dst[0], v22, v23);
    *(_QWORD *)&v857[8] = CFSTR("awd_length");
    *(_QWORD *)&buf[8] = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v24, *(unsigned __int16 *)&__dst[3], v25, v26);
    *(_QWORD *)&v857[16] = CFSTR("awd_version");
    *(_QWORD *)&buf[16] = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v27, __dst[1], v28, v29);
    *(_QWORD *)&v857[24] = CFSTR("status");
    *(_QWORD *)&buf[24] = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v30, __dst[2], v31, v32);
    v858 = CFSTR("signature");
    v1018 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v33, *(unsigned __int16 *)&__dst[5], v34, v35);
    v859 = CFSTR("product_id");
    v1019 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v36, *(unsigned __int16 *)&__dst[7], v37, v38);
    v860 = CFSTR("sw_version");
    v1020 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v39, v689, v40, v41);
    v861 = CFSTR("case_hw_version");
    v1021 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v42, v690, v43, v44);
    v862 = CFSTR("case_sw_version");
    v1022 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v45, v691, v46, v47);
    v863 = CFSTR("a2dp_time_mode_off_l");
    v1023 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v48, v692, v49, v50);
    v864 = CFSTR("a2dp_time_mode_anc_l");
    v1024 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v51, v693, v52, v53);
    v865 = CFSTR("a2dp_time_mode_trcy_l");
    v1025 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v54, v694, v55, v56);
    v866 = CFSTR("a2dp_time_mode_unused_l");
    v1026 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v57, v695, v58, v59);
    v867 = CFSTR("hfp_time_off_l");
    v1027 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v60, v696, v61, v62);
    v868 = CFSTR("hfp_time_anc_l");
    v1028 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v63, v697, v64, v65);
    v869 = CFSTR("hfp_time_trcy_l");
    v1029 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v66, v698, v67, v68);
    v870 = CFSTR("hfp_time_unused_l");
    v1030 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v69, v699, v70, v71);
    v871 = CFSTR("idle_time_off_l");
    v1031 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v72, v700, v73, v74);
    v872 = CFSTR("idle_time_anc_l");
    v1032 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v75, v701, v76, v77);
    v873 = CFSTR("idle_time_trcy_l");
    v1033 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v78, v702, v79, v80);
    v874 = CFSTR("idle_time_unused_l");
    v1034 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v81, v703, v82, v83);
    v875 = CFSTR("a2dp_battery_usage_l");
    v1035 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v84, v704, v85, v86);
    v876 = CFSTR("hfp_battery_usage_l");
    v1036 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v87, v705, v88, v89);
    v877 = CFSTR("idle_battery_usage_l");
    v1037 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v90, v706, v91, v92);
    v878 = CFSTR("a2dp_bud_temp_max_l");
    v1038 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v93, v707, v94, v95);
    v879 = CFSTR("hfp_bud_temp_max_l");
    v1039 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v96, v708, v97, v98);
    v880 = CFSTR("a2dp_bud_temp_avg_l");
    v1040 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v99, v709, v100, v101);
    v881 = CFSTR("hfp_bud_temp_avg_l");
    v1041 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v102, v710, v103, v104);
    v882 = CFSTR("time_out_of_ear_idle_l");
    v1042 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v105, v711, v106, v107);
    v883 = CFSTR("time_out_of_ear_incase_l");
    v1043 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v108, v712, v109, v110);
    v884 = CFSTR("ied_activated_count_l");
    v1044 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v111, v713, v112, v113);
    v885 = CFSTR("fw_update_retry_count_l");
    v1045 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v114, v714, v115, v116);
    v886 = CFSTR("bud_charging_cycle_l");
    v1046 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v117, v715, v118, v119);
    v887 = CFSTR("a2dp_time_mode_off_r");
    v1047 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v120, v716, v121, v122);
    v888 = CFSTR("a2dp_time_mode_anc_r");
    v1048 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v123, v717, v124, v125);
    v889 = CFSTR("a2dp_time_mode_trcy_r");
    v1049 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v126, v718, v127, v128);
    v890 = CFSTR("a2dp_time_mode_unused_r");
    v1050 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v129, v719, v130, v131);
    v891 = CFSTR("hfp_time_off_r");
    v1051 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v132, v720, v133, v134);
    v892 = CFSTR("hfp_time_anc_r");
    v1052 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v135, v721, v136, v137);
    v893 = CFSTR("hfp_time_trcy_r");
    v1053 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v138, v722, v139, v140);
    v894 = CFSTR("hfp_time_unused_r");
    v1054 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v141, v723, v142, v143);
    v895 = CFSTR("idle_time_off_r");
    v1055 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v144, v724, v145, v146);
    v896 = CFSTR("idle_time_anc_r");
    v1056 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v147, v725, v148, v149);
    v897 = CFSTR("idle_time_trcy_r");
    v1057 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v150, v726, v151, v152);
    v898 = CFSTR("idle_time_unused_r");
    v1058 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v153, v727, v154, v155);
    v899 = CFSTR("a2dp_battery_usage_r");
    v1059 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v156, v728, v157, v158);
    v900 = CFSTR("hfp_battery_usage_r");
    v1060 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v159, v729, v160, v161);
    v901 = CFSTR("idle_battery_usage_r");
    v1061 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v162, v730, v163, v164);
    v902 = CFSTR("a2dp_bud_temp_max_r");
    v1062 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v165, v731, v166, v167);
    v903 = CFSTR("hfp_bud_temp_max_r");
    v1063 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v168, v732, v169, v170);
    v904 = CFSTR("a2dp_bud_temp_avg_r");
    v1064 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v171, v733, v172, v173);
    v905 = CFSTR("hfp_bud_temp_avg_r");
    v1065 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v174, v734, v175, v176);
    v906 = CFSTR("time_out_of_ear_idle_r");
    v1066 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v177, v735, v178, v179);
    v907 = CFSTR("time_out_of_ear_incase_r");
    v1067 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v180, v736, v181, v182);
    v908 = CFSTR("ied_activated_count_r");
    v1068 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v183, v737, v184, v185);
    v909 = CFSTR("fw_update_retry_count_r");
    v1069 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v186, v738, v187, v188);
    v910 = CFSTR("bud_charging_cycle_r");
    v1070 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v189, v739, v190, v191);
    v911 = CFSTR("a2dp_time_both_in_ear_off");
    v1071 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v192, v740, v193, v194);
    v912 = CFSTR("a2dp_time_both_in_ear_anc");
    v1072 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v195, v741, v196, v197);
    v913 = CFSTR("a2dp_time_both_in_ear_trcy");
    v1073 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v198, v742, v199, v200);
    v914 = CFSTR("a2dp_time_both_in_ear_unused");
    v1074 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v201, v743, v202, v203);
    v915 = CFSTR("hfp_time_both_in_ear_off");
    v1075 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v204, v744, v205, v206);
    v916 = CFSTR("hfp_time_both_in_ear_anc");
    v1076 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v207, v745, v208, v209);
    v917 = CFSTR("hfp_time_both_in_ear_trcy");
    v1077 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v210, v746, v211, v212);
    v918 = CFSTR("hfp_time_both_in_ear_unused");
    v1078 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v213, v747, v214, v215);
    v919 = CFSTR("idle_time_both_in_ear_off");
    v1079 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v216, v748, v217, v218);
    v920 = CFSTR("idle_time_both_in_ear_anc");
    v1080 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v219, v749, v220, v221);
    v921 = CFSTR("idle_time_both_in_ear_trcy");
    v1081 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v222, v750, v223, v224);
    v922 = CFSTR("idle_time_both_in_ear_unused");
    v1082 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v225, v751, v226, v227);
    v923 = CFSTR("time_both_out_of_ear_idle");
    v1083 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v228, v752, v229, v230);
    v924 = CFSTR("time_out_of_ear_both_incase");
    v1084 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v231, v753, v232, v233);
    v925 = CFSTR("hs_on_acc_cnt");
    v1085 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v234, v754, v235, v236);
    v926 = CFSTR("siri_on_source_cnt");
    v1086 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v237, v755, v238, v239);
    v927 = CFSTR("siri_on_accessory_cnt");
    v1087 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v240, v756, v241, v242);
    v928 = CFSTR("total_time_in_connect_session");
    v1088 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v243, v757, v244, v245);
    v929 = CFSTR("bud_swap_count");
    v1089 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v246, v758, v247, v248);
    v930 = CFSTR("bud_daily_charging_soc_delta_l");
    v1090 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v249, v760, v250, v251);
    v931 = CFSTR("bud_daily_charging_soc_delta_r");
    v1091 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v252, v761, v253, v254);
    v932 = CFSTR("bud_max_daily_temp_during_chr_l");
    v1092 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v255, v762, v256, v257);
    v933 = CFSTR("bud_max_daily_temp_during_chr_r");
    v1093 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v258, v763, v259, v260);
    v934 = CFSTR("bud_avg_daily_temp_during_chr_l");
    v1094 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v261, v764, v262, v263);
    v935 = CFSTR("bud_avg_daily_temp_during_chr_r");
    v1095 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v264, v765, v265, v266);
    v936 = CFSTR("case_soc_delta_bud_chr");
    v1096 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v267, v766, v268, v269);
    v937 = CFSTR("case_temp_max_while_discharging");
    v1097 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v270, v767, v271, v272);
    v938 = CFSTR("case_temp_avg_daily");
    v1098 = objc_msgSend_numberWithChar_(MEMORY[0x1E0CB37E8], v273, v768, v274, v275);
    v939 = CFSTR("case_at_maxchr_time_in_day");
    v1099 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v276, v769, v277, v278);
    v940 = CFSTR("case_charging_cycle");
    v1100 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v279, v770, v280, v281);
    v941 = CFSTR("source_conn_productid_1");
    v1101 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v282, v771, v283, v284);
    v942 = CFSTR("source_conn_productid_2");
    v1102 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v285, v772, v286, v287);
    v943 = CFSTR("source_conn_productid_3");
    v1103 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v288, v773, v289, v290);
    v944 = CFSTR("source_conn_productid_4");
    v1104 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v291, v774, v292, v293);
    v945 = CFSTR("source_conn_productid_5");
    v1105 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v294, v775, v295, v296);
    v946 = CFSTR("source_conn_time_1");
    v1106 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v297, v776, v298, v299);
    v947 = CFSTR("source_conn_time_2");
    v1107 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v300, v777, v301, v302);
    v948 = CFSTR("source_conn_time_3");
    v1108 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v303, v778, v304, v305);
    v949 = CFSTR("source_conn_time_4");
    v1109 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v306, v779, v307, v308);
    v950 = CFSTR("source_conn_time_5");
    v1110 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v309, v780, v310, v311);
    v951 = CFSTR("sw_version_ext");
    v1111 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v312, v781[5], v313, v314);
    v952 = CFSTR("triangle_conn_time");
    v1112 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v315, v782, v316, v317);
    v953 = CFSTR("hw_version");
    v1113 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v318, v783, v319, v320);
    v954 = CFSTR("double_tap_cnt_l");
    v1114 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v321, v784, v322, v323);
    v955 = CFSTR("single_tap_cnt_l");
    v1115 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v324, v785, v325, v326);
    v956 = CFSTR("press_hold_l");
    v1116 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v327, v786, v328, v329);
    v957 = CFSTR("ied_detect_l");
    v1117 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v330, v787, v331, v332);
    v958 = CFSTR("crash_cnt_l");
    v1118 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v333, v788[2], v334, v335);
    v959 = CFSTR("bud_mileage_l");
    v1119 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v336, *(unsigned int *)&v796[14], v337, v338);
    v960 = CFSTR("first_time_use_l");
    v1120 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v339, v797, v340, v341);
    v961 = CFSTR("double_tap_cnt_r");
    v1121 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v342, v798, v343, v344);
    v962 = CFSTR("single_tap_cnt_r");
    v1122 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v345, v799, v346, v347);
    v963 = CFSTR("press_hold_r");
    v1123 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v348, v800, v349, v350);
    v964 = CFSTR("ied_detect_r");
    v1124 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v351, v801, v352, v353);
    v965 = CFSTR("crash_cnt_r");
    v1125 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v354, v802[2], v355, v356);
    v966 = CFSTR("bud_mileage_r");
    v1126 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v357, *(unsigned int *)&v810[14], v358, v359);
    v967 = CFSTR("first_time_use_r");
    v1127 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v360, v811, v361, v362);
    v968 = CFSTR("scp_active_time");
    v1128 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v363, v812, v364, v365);
    v969 = CFSTR("scp_ohd_time");
    v1129 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v366, v813, v367, v368);
    v970 = CFSTR("scp_fwup_time");
    v1130 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v369, v814, v370, v371);
    v971 = CFSTR("scp_idle_time");
    v1131 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v372, v815, v373, v374);
    v972 = CFSTR("scp_ttop_time");
    v1132 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v375, v816, v376, v377);
    v973 = CFSTR("scp_prioff_time");
    v1133 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v378, v817, v379, v380);
    v974 = CFSTR("scp_up_to_active");
    v1134 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v381, v818, v382, v383);
    v975 = CFSTR("scp_up_to_ohd");
    v1135 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v384, v819, v385, v386);
    v976 = CFSTR("scp_up_to_fwup");
    v1136 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v387, v820, v388, v389);
    v977 = CFSTR("scp_up_to_idle");
    v1137 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v390, v821, v391, v392);
    v978 = CFSTR("scp_up_to_ttop");
    v1138 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v393, v822, v394, v395);
    v979 = CFSTR("scp_down_to_ohd");
    v1139 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v396, v823, v397, v398);
    v980 = CFSTR("scp_down_to_fwup");
    v1140 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v399, v824, v400, v401);
    v981 = CFSTR("scp_down_to_idle");
    v1141 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v402, v825, v403, v404);
    v982 = CFSTR("scp_down_to_ttop");
    v1142 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v405, v826, v406, v407);
    v983 = CFSTR("scp_down_to_prioff");
    v1143 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v408, v827, v409, v410);
    v984 = CFSTR("scp_bt_disc");
    v1144 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v411, v828, v412, v413);
    v985 = CFSTR("scp_bt_conn");
    v1145 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v414, v829, v415, v416);
    v986 = CFSTR("scp_bt_a2dp");
    v1146 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v417, v830, v418, v419);
    v987 = CFSTR("scp_bt_call");
    v1147 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v420, v831, v421, v422);
    v988 = CFSTR("scp_scp_b2p_timeout");
    v1148 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v423, v832, v424, v425);
    v989 = CFSTR("scp_scp_b2p_tx_retry");
    v1149 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v426, v833, v427, v428);
    v990 = CFSTR("scp_scp_b2p_rx_error");
    v1150 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v429, v834, v430, v431);
    v991 = CFSTR("scp_scp_b2p_tx_raw");
    v1151 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v432, v835, v433, v434);
    v992 = CFSTR("scp_scp_b2p_rx_raw");
    v1152 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v435, v836, v436, v437);
    v993 = CFSTR("scp_pri_b2p_timeout");
    v1153 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v438, v837, v439, v440);
    v994 = CFSTR("scp_pri_b2p_tx_retry");
    v1154 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v441, v838, v442, v443);
    v995 = CFSTR("scp_pri_b2p_rx_error");
    v1155 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v444, v839, v445, v446);
    v996 = CFSTR("scp_pri_b2p_tx_raw");
    v1156 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v447, v840, v448, v449);
    v997 = CFSTR("scp_pri_b2p_rx_raw");
    v1157 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v450, v841, v451, v452);
    v998 = CFSTR("scp_chun_tx_error");
    v1158 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v453, v842, v454, v455);
    v999 = CFSTR("scp_chun_rx_error");
    v1159 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v456, v843, v457, v458);
    v1000 = CFSTR("scp_chun_unlock");
    v1160 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v459, v844, v460, v461);
    v1001 = CFSTR("scp_chun_missed_frame");
    v1161 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v462, v845, v463, v464);
    v1002 = CFSTR("appleID_paired_count");
    v1162 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v465, v846, v466, v467);
    v1003 = CFSTR("uvlo_count_l");
    v1163 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v468, v847, v469, v470);
    v1004 = CFSTR("time_since_last_uvlo_l");
    v1164 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v471, v848, v472, v473);
    v1005 = CFSTR("low_batt_signal_count_l");
    v1165 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v474, v849, v475, v476);
    v1006 = CFSTR("num_sessions_l");
    v1166 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v477, v850, v478, v479);
    v1007 = CFSTR("flash_pe_count_l");
    v1167 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v480, v851, v481, v482);
    v1008 = CFSTR("bud_color_l");
    v1168 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v483, v852, v484, v485);
    v1009 = CFSTR("uvlo_count_r");
    v1169 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v486, v853, v487, v488);
    v1010 = CFSTR("time_since_last_uvlo_r");
    v1170 = objc_msgSend_numberWithUnsignedInt_(MEMORY[0x1E0CB37E8], v489, v854, v490, v491);
    v1011 = CFSTR("low_batt_signal_count_r");
    v1171 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v492, v855, v493, v494);
    v1012 = CFSTR("num_sessions_r");
    v1172 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v495, v856[58], v496, v497);
    v1013 = CFSTR("flash_pe_count_r");
    v1173 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v498, v856[59], v499, v500);
    v1014 = CFSTR("bud_color_r");
    v1174 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v501, v856[60], v502, v503);
    v1015 = CFSTR("case_charge_event_count");
    v1175 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v504, v759, v505, v506);
    v1016 = CFSTR("system_color");
    v1176 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v507, v856[61], v508, v509);
    v511 = objc_msgSend_dictionaryWithObjects_forKeys_count_(MEMORY[0x1E0C99D80], v510, (uint64_t)buf, (uint64_t)v857, 163);
    v515 = (void *)objc_msgSend_dictionaryWithDictionary_(v20, v512, v511, v513, v514);
    sub_18F4DCFCC((uint64_t)CFSTR("array_rfu"), (const char *)5, 4u, (uint64_t)v781, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("ied_histogram_l"), (const char *)2, 2u, (uint64_t)v788, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("a2dp_time_ext_l"), (const char *)4, 2u, (uint64_t)&v789, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("hfp_time_ext_l"), (const char *)4, 2u, (uint64_t)&v790, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("idle_time_ext_l"), (const char *)4, 2u, (uint64_t)&v791, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("a2dp_battery_usage_ext_l"), (const char *)8, 2u, (uint64_t)&v792, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("hfp_battery_usage_ext_l"), (const char *)8, 2u, (uint64_t)&v793, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("idle_battery_usage_ext_l"), (const char *)8, 2u, (uint64_t)&v794, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("array_rfu_l"), (const char *)5, 4u, (uint64_t)&v795, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("volume_his_l"), (const char *)7, 2u, (uint64_t)v796, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("ied_histogram_r"), (const char *)2, 2u, (uint64_t)v802, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("a2dp_time_ext_r"), (const char *)4, 2u, (uint64_t)&v803, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("hfp_time_ext_r"), (const char *)4, 2u, (uint64_t)&v804, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("idle_time_ext_r"), (const char *)4, 2u, (uint64_t)&v805, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("a2dp_battery_usage_ext_r"), (const char *)8, 2u, (uint64_t)&v806, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("hfp_battery_usage_ext_r"), (const char *)8, 2u, (uint64_t)&v807, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("idle_battery_usage_ext_r"), (const char *)8, 2u, (uint64_t)&v808, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("array_rfu_r"), (const char *)5, 4u, (uint64_t)&v809, v515);
    sub_18F4DCFCC((uint64_t)CFSTR("volume_his_r"), (const char *)7, 2u, (uint64_t)v810, v515);
    v519 = 0;
    v520 = (unsigned __int16 *)v856;
    do
    {
      v521 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v516, *((unsigned __int8 *)v520 - 71), v517, v518);
      v525 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v522, (uint64_t)CFSTR("bud_start_soc_at_undock_l_%u"), v523, v524, v519);
      objc_msgSend_setObject_forKeyedSubscript_(v515, v526, v521, v525, v527);
      v531 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v528, *((unsigned __int8 *)v520 - 70), v529, v530);
      v535 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v532, (uint64_t)CFSTR("bud_end_soc_at_dock_l_%u"), v533, v534, v519);
      objc_msgSend_setObject_forKeyedSubscript_(v515, v536, v531, v535, v537);
      v541 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v538, *(unsigned __int16 *)((char *)v520 - 69), v539, v540);
      v545 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v542, (uint64_t)CFSTR("length_of_session_l_%u"), v543, v544, v519);
      objc_msgSend_setObject_forKeyedSubscript_(v515, v546, v541, v545, v547);
      v551 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v548, *((unsigned __int8 *)v520 - 2), v549, v550);
      v555 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v552, (uint64_t)CFSTR("bud_start_soc_at_undock_r_%u"), v553, v554, v519);
      objc_msgSend_setObject_forKeyedSubscript_(v515, v556, v551, v555, v557);
      v561 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v558, *((unsigned __int8 *)v520 - 1), v559, v560);
      v565 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v562, (uint64_t)CFSTR("bud_end_soc_at_dock_r_%u"), v563, v564, v519);
      objc_msgSend_setObject_forKeyedSubscript_(v515, v566, v561, v565, v567);
      v568 = *v520;
      v520 += 2;
      v572 = objc_msgSend_numberWithUnsignedShort_(MEMORY[0x1E0CB37E8], v569, v568, v570, v571);
      v576 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v573, (uint64_t)CFSTR("length_of_session_r_%u"), v574, v575, v519);
      objc_msgSend_setObject_forKeyedSubscript_(v515, v577, v572, v576, v578);
      ++v519;
    }
    while (v519 != 15);
    v579 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v516, v856[62], v517, v518);
    objc_msgSend_setObject_forKeyedSubscript_(v515, v580, v579, (uint64_t)CFSTR("case_hw_version_maj"), v581);
    v585 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v582, v856[63], v583, v584);
    objc_msgSend_setObject_forKeyedSubscript_(v515, v586, v585, (uint64_t)CFSTR("case_hw_version_min"), v587);
    v591 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v588, v856[64], v589, v590);
    objc_msgSend_setObject_forKeyedSubscript_(v515, v592, v591, (uint64_t)CFSTR("case_hw_version_rev"), v593);
    v597 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v594, v856[65], v595, v596);
    objc_msgSend_setObject_forKeyedSubscript_(v515, v598, v597, (uint64_t)CFSTR("case_sw_version_maj"), v599);
    v603 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v600, v856[66], v601, v602);
    objc_msgSend_setObject_forKeyedSubscript_(v515, v604, v603, (uint64_t)CFSTR("case_sw_version_min"), v605);
    v609 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v606, v856[67], v607, v608);
    objc_msgSend_setObject_forKeyedSubscript_(v515, v610, v609, (uint64_t)CFSTR("case_sw_version_rev"), v611);
    v615 = objc_msgSend_numberWithUnsignedChar_(MEMORY[0x1E0CB37E8], v612, v856[68], v613, v614);
    objc_msgSend_setObject_forKeyedSubscript_(v515, v616, v615, (uint64_t)CFSTR("appleID_hijack_cnt"), v617);
    if (!v515)
    {
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v668 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18F1DC000, v668, OS_LOG_TYPE_ERROR, "[HeadphoneUsage] Error forming metric dictionary, aborting.", buf, 2u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        *(_WORD *)v857 = 0;
        v5 = (_BYTE *)_os_log_send_and_compose_impl();
        v6 = "void CLAudioAccessoryInterface::dailyUsageEventHandler(BTDevice, BTData, size_t)";
        goto LABEL_11;
      }
      return;
    }
    v618 = v687;
    if (*(_QWORD *)(v687 + 8))
    {
      v619 = objc_alloc(MEMORY[0x1E0C99DF0]);
      v623 = (void *)objc_msgSend_initWithLength_(v619, v620, 1000, v621, v622);
      *(_QWORD *)__dst = 0;
      objc_msgSend_mutableBytes(v623, v624, v625, v626, v627);
      objc_msgSend_length(v623, v628, v629, v630, v631);
      AccessoryInfo = BTAccessoryManagerGetAccessoryInfo();
      if (AccessoryInfo || !*(_QWORD *)__dst)
      {

        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        v671 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = AccessoryInfo;
          *(_WORD *)&buf[8] = 2048;
          *(_QWORD *)&buf[10] = *(_QWORD *)__dst;
          _os_log_impl(&dword_18F1DC000, v671, OS_LOG_TYPE_ERROR, "[HeadphoneUsage] Error: Unable to retrieve data,status:%d,infoLen:%zu", buf, 0x12u);
        }
        if (!sub_18F1FCA08(115, 0))
          goto LABEL_122;
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
        *(_DWORD *)v857 = 67109376;
        *(_DWORD *)&v857[4] = AccessoryInfo;
        *(_WORD *)&v857[8] = 2048;
        *(_QWORD *)&v857[10] = *(_QWORD *)__dst;
      }
      else
      {
        objc_msgSend_setLength_(v623, v632, *(uint64_t *)__dst, v633, v634);
        v637 = (void *)objc_msgSend_JSONObjectWithData_options_error_(MEMORY[0x1E0CB36D8], v636, (uint64_t)v623, 0, 0);

        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v641 = (void *)objc_msgSend_objectForKeyedSubscript_(v637, v638, (uint64_t)CFSTR("AACPVersionInfo"), v639, v640);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0
            && (unint64_t)objc_msgSend_count(v641, v642, v643, v644, v645) >= 0xA)
          {
            v649 = objc_msgSend_objectAtIndex_(v641, v646, 3, v647, v648);
            v653 = objc_msgSend_objectAtIndex_(v641, v650, 8, v651, v652);
            v657 = objc_msgSend_objectAtIndex_(v641, v654, 9, v655, v656);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0)
              {
                objc_opt_class();
                if ((objc_opt_isKindOfClass() & 1) != 0)
                {
                  objc_msgSend_setObject_forKeyedSubscript_(v515, v658, v649, (uint64_t)CFSTR("serial_number_system"), v659);
                  objc_msgSend_setObject_forKeyedSubscript_(v515, v660, v653, (uint64_t)CFSTR("serial_number_left"), v661);
                  objc_msgSend_setObject_forKeyedSubscript_(v515, v662, v657, (uint64_t)CFSTR("serial_number_right"), v663);
LABEL_127:
                  if (qword_1ECEDEE38 != -1)
                    dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
                  v676 = qword_1ECEDEE30;
                  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_INFO))
                  {
                    *(_DWORD *)buf = 138477827;
                    *(_QWORD *)&buf[4] = v515;
                    _os_log_impl(&dword_18F1DC000, v676, OS_LOG_TYPE_INFO, "[HeadphoneUsage] Interface: Parsed metrics: %{private}@", buf, 0xCu);
                  }
                  if (sub_18F1FCA08(115, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_1ECEDEE38 != -1)
                      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
                    *(_DWORD *)v857 = 138477827;
                    *(_QWORD *)&v857[4] = v515;
                    v684 = (char *)_os_log_send_and_compose_impl();
                    sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::dailyUsageEventHandler(BTDevice, BTData, size_t)", "CoreLocation: %s\n", v684);
                    if (v684 != buf)
                      free(v684);
                    v618 = v687;
                  }
                  for (i = *(uint64_t ***)(v618 + 200); i; i = (uint64_t **)*i)
                  {
                    if (qword_1ECEDEE38 != -1)
                      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
                    v678 = qword_1ECEDEE30;
                    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
                    {
                      v679 = i[2];
                      *(_DWORD *)buf = 67109378;
                      *(_DWORD *)&buf[4] = 1;
                      *(_WORD *)&buf[8] = 2112;
                      *(_QWORD *)&buf[10] = v679;
                      _os_log_impl(&dword_18F1DC000, v678, OS_LOG_TYPE_DEBUG, "[HeadphoneUsage] notifyClientsWithData,event %d,client %@", buf, 0x12u);
                    }
                    if (sub_18F1FCA08(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_1ECEDEE38 != -1)
                        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
                      v680 = i[2];
                      *(_QWORD *)v857 = 0x104000202;
                      *(_WORD *)&v857[8] = 2112;
                      *(_QWORD *)&v857[10] = v680;
                      v681 = (char *)_os_log_send_and_compose_impl();
                      sub_18F419700("Generic", 1, 0, 2, "void CLAudioAccessoryInterface::notifyClientsWithData(Event, NSDictionary *)", "CoreLocation: %s\n", v681);
                      if (v681 != buf)
                        free(v681);
                    }
                    ((void (*)(uint64_t, void *, uint64_t *))i[3])(1, v515, i[2]);
                  }
                  return;
                }
              }
            }
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            v674 = qword_1ECEDEE30;
            if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18F1DC000, v674, OS_LOG_TYPE_ERROR, "[HeadphoneUsage] Error: Expected serial number as NSString*, got different type.", buf, 2u);
            }
            if (!sub_18F1FCA08(115, 0))
            {
LABEL_122:
              if (qword_1ECEDEE38 != -1)
                dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
              v675 = qword_1ECEDEE30;
              if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_18F1DC000, v675, OS_LOG_TYPE_ERROR, "[HeadphoneUsage] Error retrieving serial numbers, will omit from message.", buf, 2u);
              }
              if (sub_18F1FCA08(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1ECEDEE38 != -1)
                  dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
                *(_WORD *)v857 = 0;
                v685 = (char *)_os_log_send_and_compose_impl();
                sub_18F419700("Generic", 1, 0, 0, "void CLAudioAccessoryInterface::dailyUsageEventHandler(BTDevice, BTData, size_t)", "CoreLocation: %s\n", v685);
                if (v685 != buf)
                  free(v685);
                v618 = v687;
              }
              goto LABEL_127;
            }
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            *(_WORD *)v857 = 0;
          }
          else
          {
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            v673 = qword_1ECEDEE30;
            if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18F1DC000, v673, OS_LOG_TYPE_ERROR, "[HeadphoneUsage] Error: AACPVersionInfo array of unexpected type or size.", buf, 2u);
            }
            if (!sub_18F1FCA08(115, 0))
              goto LABEL_122;
            bzero(buf, 0x65CuLL);
            if (qword_1ECEDEE38 != -1)
              dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
            *(_WORD *)v857 = 0;
          }
        }
        else
        {
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          v672 = qword_1ECEDEE30;
          if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18F1DC000, v672, OS_LOG_TYPE_ERROR, "[HeadphoneUsage] Error: Accessory info dictionary is of unexpected class.", buf, 2u);
          }
          if (!sub_18F1FCA08(115, 0))
            goto LABEL_122;
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
          *(_WORD *)v857 = 0;
        }
      }
      v670 = (_BYTE *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "static BOOL BT::CLAudioAccessoryHelper::addSerialNumbersToDict(BTAccessoryManager _Nonnull, BTDevice _Nonnull, NSMutableDictionary * _Nonnull)", "CoreLocation: %s\n");
    }
    else
    {
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v669 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = a2;
        _os_log_impl(&dword_18F1DC000, v669, OS_LOG_TYPE_DEBUG, "[HeadphoneUsage] BT Accessory Manager no longer exists, cannot retrieve serial numbers,device:%@", buf, 0xCu);
      }
      if (!sub_18F1FCA08(115, 2))
        goto LABEL_122;
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      *(_DWORD *)v857 = 138412290;
      *(_QWORD *)&v857[4] = a2;
      v670 = (_BYTE *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static BOOL BT::CLAudioAccessoryHelper::addSerialNumbersToDict(BTAccessoryManager _Nonnull, BTDevice _Nonnull, NSMutableDictionary * _Nonnull)", "CoreLocation: %s\n");
    }
    if (v670 != buf)
      free(v670);
    v618 = v687;
    goto LABEL_122;
  }
  if (qword_1ECEDEE38 != -1)
    dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
  v667 = qword_1ECEDEE30;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v9;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = 1;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = v11;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v12;
    _os_log_impl(&dword_18F1DC000, v667, OS_LOG_TYPE_FAULT, "[HeadphoneUsage] Unexpected AWD data length for AWDVersion %d: type %d expected len %d actual %d. Header mismatch with Bluetooth likely.", buf, 0x1Au);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    *(_DWORD *)v857 = 67109888;
    *(_DWORD *)&v857[4] = v9;
    *(_WORD *)&v857[8] = 1024;
    *(_DWORD *)&v857[10] = 1;
    *(_WORD *)&v857[14] = 1024;
    *(_DWORD *)&v857[16] = v11;
    *(_WORD *)&v857[20] = 1024;
    *(_DWORD *)&v857[22] = v12;
    goto LABEL_10;
  }
}

os_log_t sub_18F4DCFA0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1ECEDEE30 = (uint64_t)result;
  return result;
}

void sub_18F4DCFCC(uint64_t a1, const char *a2, unsigned int a3, uint64_t a4, void *a5)
{
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  NSObject *v19;
  char *v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  void *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a1 && a4 && a5)
  {
    v9 = 0;
    v10 = a3 * (_DWORD)a2;
    do
    {
      switch(a3)
      {
        case 4u:
          v11 = objc_msgSend_numberWithUnsignedLongLong_(MEMORY[0x1E0CB37E8], a2, *(unsigned int *)(a4 + v9), a4, (uint64_t)a5);
          break;
        case 3u:
          v11 = objc_msgSend_numberWithUnsignedLongLong_(MEMORY[0x1E0CB37E8], a2, *(unsigned __int16 *)(a4 + v9) | ((unint64_t)*(unsigned __int8 *)(a4 + v9 + 2) << 16), a4, (uint64_t)a5);
          break;
        case 2u:
          v11 = objc_msgSend_numberWithUnsignedLongLong_(MEMORY[0x1E0CB37E8], a2, *(unsigned __int16 *)(a4 + v9), a4, (uint64_t)a5);
          break;
        default:
          v11 = objc_msgSend_numberWithUnsignedLongLong_(MEMORY[0x1E0CB37E8], a2, 0, a4, (uint64_t)a5);
          break;
      }
      v15 = v11;
      v16 = objc_msgSend_stringWithFormat_(MEMORY[0x1E0CB3940], v12, (uint64_t)CFSTR("%@_%u"), v13, v14, a1, v9 / a3);
      objc_msgSend_setObject_forKey_(a5, v17, v15, v16, v18);
      v9 += a3;
    }
    while (v9 < v10);
  }
  else
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
    v19 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412802;
      v22 = a1;
      v23 = 2048;
      v24 = a4;
      v25 = 2112;
      v26 = a5;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_ERROR, "[HeadphoneUsage] addExpandedArrayToDictionary: Invalid parameters. arrayName: %@, array: %p, dict: %@", buf, 0x20u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2959518);
      v20 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "static void BT::CLAudioAccessoryHelper::addExpandedArrayToDictionary(NSString * _Nonnull, uint32_t, uint8_t, uint8_t * _Nonnull, NSMutableDictionary * _Nonnull, BOOL)", "CoreLocation: %s\n", v20);
      if (v20 != (char *)buf)
        free(v20);
    }
  }
}

uint64_t sub_18F4DD264(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t *sub_18F4DD2AC(_QWORD *a1, _QWORD *a2)
{
  uint64_t *result;

  result = sub_18F4DD2E0(a1, a2);
  if (result)
  {
    sub_18F4DD3CC(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

_QWORD *sub_18F4DD2E0(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t sub_18F4DD3CC(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  void *v3;
  void *__p;

  v2 = *a2;
  sub_18F4DD40C(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    operator delete(v3);
  return v2;
}

_QWORD *sub_18F4DD40C@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

_QWORD *sub_18F4DD540(float *a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  int8x8_t prime;
  void *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint8x8_t v25;
  unint64_t v26;
  uint8x8_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  _QWORD *v35;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v15 = a1[8];
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      prime = (int8x8_t)v18;
    else
      prime = (int8x8_t)v17;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v9 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v9)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v9)
    {
      v26 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (v27 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        v26 = std::__next_prime(v26);
      }
      else
      {
        v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2)
          v26 = v28;
      }
      if (*(_QWORD *)&prime <= v26)
        prime = (int8x8_t)v26;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            sub_18F26F97C();
          v20 = operator new(8 * *(_QWORD *)&prime);
          v21 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v20;
          if (v21)
            operator delete(v21);
          v22 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v22++) = 0;
          while (*(_QWORD *)&prime != v22);
          v23 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v23)
          {
            v24 = v23[1];
            v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(_QWORD *)&prime)
                v24 %= *(_QWORD *)&prime;
            }
            else
            {
              v24 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = a1 + 4;
            v29 = (_QWORD *)*v23;
            if (*v23)
            {
              do
              {
                v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(_QWORD *)&prime)
                    v30 %= *(_QWORD *)&prime;
                }
                else
                {
                  v30 &= *(_QWORD *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v30))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *v23 = *v29;
                  *v29 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v30);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v30) = v29;
                  v29 = v23;
                }
                v30 = v24;
LABEL_55:
                v23 = v29;
                v29 = (_QWORD *)*v29;
                v24 = v30;
              }
              while (v29);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        v35 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v35)
          operator delete(v35);
        v9 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v31 = *(_QWORD **)a1;
  v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v32)
  {
    *i = *v32;
LABEL_72:
    *v32 = i;
    goto LABEL_73;
  }
  *i = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = i;
  v31[v3] = a1 + 4;
  if (*i)
  {
    v33 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v33 >= v9)
        v33 %= v9;
    }
    else
    {
      v33 &= v9 - 1;
    }
    v32 = (_QWORD *)(*(_QWORD *)a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return i;
}

void sub_18F4DD958(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_18F4DD96C(float *a1, _QWORD *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  _QWORD **v12;
  _QWORD *i;
  unint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  int8x8_t prime;
  void *v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint8x8_t v26;
  unint64_t v27;
  uint8x8_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v34;
  _QWORD *v36;

  v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  v10 = *((_QWORD *)a1 + 1);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10)
        v4 = v9 % v10;
    }
    else
    {
      v4 = v9 & (v10 - 1);
    }
    v12 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      for (i = *v12; i; i = (_QWORD *)*i)
      {
        v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10)
              v14 %= v10;
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  v15 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v16 = a1[8];
  if (!v10 || (float)(v16 * (float)v10) < v15)
  {
    v17 = 1;
    if (v10 >= 3)
      v17 = (v10 & (v10 - 1)) != 0;
    v18 = v17 | (2 * v10);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      prime = (int8x8_t)v19;
    else
      prime = (int8x8_t)v18;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v10 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v10)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v10)
    {
      v27 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v10 < 3 || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        v27 = std::__next_prime(v27);
      }
      else
      {
        v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2)
          v27 = v29;
      }
      if (*(_QWORD *)&prime <= v27)
        prime = (int8x8_t)v27;
      if (*(_QWORD *)&prime >= v10)
      {
        v10 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            sub_18F26F97C();
          v21 = operator new(8 * *(_QWORD *)&prime);
          v22 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v21;
          if (v22)
            operator delete(v22);
          v23 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v23++) = 0;
          while (*(_QWORD *)&prime != v23);
          v24 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v24)
          {
            v25 = v24[1];
            v26 = (uint8x8_t)vcnt_s8(prime);
            v26.i16[0] = vaddlv_u8(v26);
            if (v26.u32[0] > 1uLL)
            {
              if (v25 >= *(_QWORD *)&prime)
                v25 %= *(_QWORD *)&prime;
            }
            else
            {
              v25 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = a1 + 4;
            v30 = (_QWORD *)*v24;
            if (*v24)
            {
              do
              {
                v31 = v30[1];
                if (v26.u32[0] > 1uLL)
                {
                  if (v31 >= *(_QWORD *)&prime)
                    v31 %= *(_QWORD *)&prime;
                }
                else
                {
                  v31 &= *(_QWORD *)&prime - 1;
                }
                if (v31 != v25)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v31))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v31) = v24;
                    goto LABEL_55;
                  }
                  *v24 = *v30;
                  *v30 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v31);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v31) = v30;
                  v30 = v24;
                }
                v31 = v25;
LABEL_55:
                v24 = v30;
                v30 = (_QWORD *)*v30;
                v25 = v31;
              }
              while (v30);
            }
          }
          v10 = (unint64_t)prime;
          goto LABEL_59;
        }
        v36 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v36)
          operator delete(v36);
        v10 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v32 = *(_QWORD **)a1;
  v33 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v33)
  {
    *i = *v33;
LABEL_72:
    *v33 = i;
    goto LABEL_73;
  }
  *i = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = i;
  v32[v4] = a1 + 4;
  if (*i)
  {
    v34 = *(_QWORD *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v34 >= v10)
        v34 %= v10;
    }
    else
    {
      v34 &= v10 - 1;
    }
    v33 = (_QWORD *)(*(_QWORD *)a1 + 8 * v34);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return i;
}

void sub_18F4DDD88(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4DDD9C(uint64_t a1)
{
  NSObject *v2;
  float32x4_t v3;
  char *v5;
  uint8_t buf[1640];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0x3F80000000000000;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0x4000000000;
  *(_BYTE *)(a1 + 3648) = 1;
  *(_QWORD *)(a1 + 3668) = 0;
  *(_QWORD *)(a1 + 3660) = 0;
  *(_QWORD *)(a1 + 3676) = 0x800000000;
  *(_QWORD *)(a1 + 3716) = 0;
  *(_DWORD *)(a1 + 3724) = 0;
  *(_QWORD *)(a1 + 3728) = 0xBF8000003F800000;
  *(_QWORD *)(a1 + 3736) = 0;
  *(_QWORD *)(a1 + 3744) = 0x3F80000000000000;
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E29544A8);
  v2 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "[CMHeadToHeadsetAttitudeEstimator] Created the online H2H estimator.", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E29544A8);
    v5 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "CMHeadToHeadsetAttitudeEstimator::CMHeadToHeadsetAttitudeEstimator()", "CoreLocation: %s\n", v5);
    if (v5 != (char *)buf)
      free(v5);
  }
  sub_18F4DDF94(a1, v3);
  return a1;
}

void sub_18F4DDF94(uint64_t a1, float32x4_t a2)
{
  __int32 v3;
  unint64_t v4;
  NSObject *v5;
  char *v6;
  _OWORD v7[2];
  int v8;
  float32x4_t buf;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 16) = 0;
  a2.f32[0] = -*(float *)(a1 + 3744);
  v3 = *(_DWORD *)(a1 + 3748);
  *(float32x2_t *)buf.f32 = vneg_f32(*(float32x2_t *)(a1 + 3736));
  buf.i32[2] = a2.i32[0];
  buf.i32[3] = v3;
  sub_18F1FFE94(&buf, a2);
  v4 = 0;
  *(float32x4_t *)a1 = buf;
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  do
  {
    *(_DWORD *)sub_18F3558C8((uint64_t)v7, v4, v4) = 949990671;
    ++v4;
  }
  while (v4 != 3);
  sub_18F45C8CC(a1 + 20, (uint64_t)v7);
  *(_QWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 3668) = 0;
  *(_QWORD *)(a1 + 3660) = 0;
  *(_DWORD *)(a1 + 3676) = 0;
  *(_BYTE *)(a1 + 3648) = 1;
  *(_QWORD *)(a1 + 3716) = 0;
  *(_DWORD *)(a1 + 3724) = 0;
  *(_QWORD *)(a1 + 3728) = 0xBF8000003F800000;
  if (qword_1EE16D818 != -1)
    dispatch_once(&qword_1EE16D818, &unk_1E29544A8);
  v5 = qword_1EE16D820;
  if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
  {
    buf.i16[0] = 0;
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "[CMHeadToHeadsetAttitudeEstimator]:[reset] Reset.", (uint8_t *)&buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E29544A8);
    v6 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMHeadToHeadsetAttitudeEstimator::reset()", "CoreLocation: %s\n", v6);
    if (v6 != (char *)&buf)
      free(v6);
  }
}

void sub_18F4DE1C8(uint64_t a1, float32x2_t *a2, float32x4_t a3)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  NSObject *v8;
  double v9;
  double v10;
  double v11;
  double v12;
  unint64_t v13;
  double v14;
  double v15;
  double v16;
  char *v17;
  unsigned __int32 v18;
  unint64_t v19;
  __int16 v20;
  double v21;
  __int16 v22;
  double v23;
  __int16 v24;
  double v25;
  uint8_t buf[4];
  double v27;
  __int16 v28;
  double v29;
  __int16 v30;
  double v31;
  __int16 v32;
  double v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 16))
    goto LABEL_5;
  sub_18F3D381C(a2, a1 + 3736, (float32x4_t *)buf, a3);
  a3.f32[0] = sub_18F3D3B4C((float32x4_t *)buf);
  v5 = 0;
  v18 = a3.i32[0];
  v19 = __PAIR64__(v7, v6);
  a3.i32[0] = 0;
  do
  {
    a3.f32[0] = a3.f32[0] + (float)(*(float *)((char *)&v18 + v5) * *(float *)((char *)&v18 + v5));
    v5 += 4;
  }
  while (v5 != 12);
  a3.f32[0] = sqrtf(a3.f32[0]);
  if (a3.f32[0] >= 0.000001)
  {
LABEL_5:
    if ((float32x2_t *)(a1 + 3736) != a2)
    {
      a3 = *(float32x4_t *)a2->f32;
      *(_OWORD *)(a1 + 3736) = *(_OWORD *)a2->f32;
    }
    sub_18F4DDF94(a1, a3);
    *(_BYTE *)(a1 + 16) = 1;
    if (qword_1EE16D818 != -1)
      dispatch_once(&qword_1EE16D818, &unk_1E29544A8);
    v8 = qword_1EE16D820;
    if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_INFO))
    {
      v9 = *(float *)a1;
      v10 = *(float *)(a1 + 4);
      v11 = *(float *)(a1 + 8);
      v12 = *(float *)(a1 + 12);
      *(_DWORD *)buf = 134349824;
      v27 = v9;
      v28 = 2050;
      v29 = v10;
      v30 = 2050;
      v31 = v11;
      v32 = 2050;
      v33 = v12;
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "[CMHeadToHeadsetAttitudeEstimator]:[setDefaultQHeadToHeadset] Default qFB: %{public}.7f %{public}.7f %{public}.7f %{public}.7f", buf, 0x2Au);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E29544A8);
      *(double *)&v13 = *(float *)a1;
      v14 = *(float *)(a1 + 4);
      v15 = *(float *)(a1 + 8);
      v16 = *(float *)(a1 + 12);
      v18 = 134349824;
      v19 = v13;
      v20 = 2050;
      v21 = v14;
      v22 = 2050;
      v23 = v15;
      v24 = 2050;
      v25 = v16;
      v17 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMHeadToHeadsetAttitudeEstimator::setDefaultQHeadToHeadset(const CMOQuaternion &)", "CoreLocation: %s\n", v17);
      if (v17 != (char *)buf)
        free(v17);
    }
  }
}

void sub_18F4DE460(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4, double a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  NSObject *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unint64_t v30;
  uint64_t v31;
  float v32;
  uint64_t v33;
  float v34;
  unint64_t i;
  unint64_t v36;
  float v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t j;
  float v43;
  float v44;
  float *v45;
  unint64_t k;
  unint64_t v47;
  float v48;
  float v49;
  float v50;
  unint64_t m;
  float v52;
  float v53;
  unint64_t n;
  unint64_t v55;
  float v56;
  float v57;
  float v58;
  unint64_t ii;
  float v60;
  float v61;
  unint64_t v62;
  float v63;
  float v64;
  float *v65;
  unint64_t jj;
  float v67;
  float v68;
  float *v69;
  NSObject *v70;
  float v71;
  float v72;
  float32x2_t v73;
  float v74;
  _OWORD v75[2];
  int v76;
  uint64_t v77;
  int v78;
  __int128 v79;
  __int128 v80;
  _OWORD v81[2];
  int v82;
  int v83;
  unint64_t v84;
  _BYTE buf[12];
  __int16 v86;
  unint64_t v87;
  float v88[3];
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 16))
    return;
  v8 = *(unsigned __int16 *)(a1 + 58);
  if (*(_WORD *)(a1 + 58))
  {
    v9 = a1 + 64;
    v10 = *(unsigned __int16 *)(a1 + 56);
    v11 = v8 + v10 - 1;
    v12 = *(unsigned int *)(a1 + 60);
    if (v11 >= v12)
      v13 = *(unsigned int *)(a1 + 60);
    else
      v13 = 0;
    if (*(_QWORD *)(v9 + 56 * (v11 - v13)) >= a4)
    {
      if (qword_1EE16D818 != -1)
        dispatch_once(&qword_1EE16D818, &unk_1E29544A8);
      v14 = qword_1EE16D820;
      if (os_log_type_enabled((os_log_t)qword_1EE16D820, OS_LOG_TYPE_ERROR))
      {
        v15 = *(unsigned __int16 *)(a1 + 56) + (unint64_t)*(unsigned __int16 *)(a1 + 58) - 1;
        v16 = *(unsigned int *)(a1 + 60);
        if (v15 < v16)
          v16 = 0;
        v17 = *(_QWORD *)(v9 + 56 * (v15 - v16));
        *(_DWORD *)buf = 134349312;
        *(_QWORD *)&buf[4] = v17;
        v86 = 2050;
        v87 = a4;
        _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_ERROR, "[CMHeadToHeadsetAttitudeEstimator]:[feedIMUData] Backwards or repeated IMU timestamp. Previous: %{public}llu us, this: %{public}llu us", buf, 0x16u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1EE16D818 != -1)
          dispatch_once(&qword_1EE16D818, &unk_1E29544A8);
        v18 = *(unsigned __int16 *)(a1 + 56) + (unint64_t)*(unsigned __int16 *)(a1 + 58) - 1;
        v19 = *(unsigned int *)(a1 + 60);
        if (v18 < v19)
          v19 = 0;
        v20 = *(_QWORD *)(v9 + 56 * (v18 - v19));
        LODWORD(v81[0]) = 134349312;
        *(_QWORD *)((char *)v81 + 4) = v20;
        WORD6(v81[0]) = 2050;
        *(_QWORD *)((char *)v81 + 14) = a4;
        v21 = (_BYTE *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void CMHeadToHeadsetAttitudeEstimator::feedIMUData(const CMRelDM::IMUData &, const CMRelDM::IMUData &, const double, const uint64_t)", "CoreLocation: %s\n");
LABEL_69:
        if (v21 != buf)
          free(v21);
        return;
      }
      return;
    }
  }
  else
  {
    v12 = *(unsigned int *)(a1 + 60);
    v10 = *(unsigned __int16 *)(a1 + 56);
  }
  v22 = *(_OWORD *)(a2 + 56);
  v23 = *(_OWORD *)(a3 + 7);
  v79 = v23;
  v80 = v22;
  v24 = *a3;
  v77 = *a3;
  v25 = *((_DWORD *)a3 + 2);
  v78 = v25;
  v26 = v10 + v8;
  if (v26 >= v12)
    v27 = v12;
  else
    v27 = 0;
  v28 = a1 + 56 * (v26 - v27);
  *(_QWORD *)(v28 + 64) = a4;
  *(_OWORD *)(v28 + 72) = v22;
  *(_OWORD *)(v28 + 88) = v23;
  *(_DWORD *)(v28 + 112) = v25;
  *(_QWORD *)(v28 + 104) = v24;
  v29 = *(unsigned __int16 *)(a1 + 58);
  if (v12 <= v29)
  {
    v30 = *(unsigned __int16 *)(a1 + 56) + 1;
    if (v30 < v12)
      LOWORD(v12) = 0;
    *(_WORD *)(a1 + 56) = v30 - v12;
  }
  else
  {
    *(_WORD *)(a1 + 58) = v29 + 1;
  }
  v31 = 0;
  v32 = 0.0;
  do
  {
    v32 = v32 + (float)(*(float *)(a2 + v31) * *(float *)(a2 + v31));
    v31 += 4;
  }
  while (v31 != 12);
  *(_DWORD *)buf = sqrtf(v32);
  sub_18F33D300(a1 + 3648, (float *)buf);
  v33 = a1 + 20;
  v34 = sub_18F4DF968(a1 + 20, 0, 0);
  for (i = 1; i != 3; ++i)
    v34 = v34 + sub_18F4DF968(a1 + 20, i, i);
  if (v34 < 0.27416)
  {
    v36 = 0;
    v37 = a5;
    v72 = v37;
    v82 = 0;
    memset(v81, 0, sizeof(v81));
    do
    {
      *(_DWORD *)sub_18F3558C8((uint64_t)v81, v36, v36) = 1065353216;
      ++v36;
    }
    while (v36 != 3);
    v38 = 0;
    v75[0] = v81[0];
    v75[1] = v81[1];
    v76 = v82;
    do
      *(_DWORD *)sub_18F33D3D0((uint64_t)buf, v38++) = 1008981770;
    while (v38 != 3);
    v39 = 0;
    v73 = vmul_n_f32(*(float32x2_t *)buf, v72);
    v74 = *(float *)&buf[8] * v72;
    v40 = a1 + 32;
    do
    {
      v41 = 2;
      do
      {
        for (j = 0; j != v41; ++j)
        {
          v43 = *(float *)sub_18F3558C8((uint64_t)v81, v39, j);
          v44 = *(float *)sub_18F45D6FC(v40, j, v41);
          v45 = (float *)sub_18F3558C8((uint64_t)v81, v39, v41);
          *v45 = *v45 + (float)(v43 * v44);
        }
        --v41;
      }
      while (v41);
      ++v39;
    }
    while (v39 != 3);
    for (k = 2; ; --k)
    {
      v47 = 0;
      v88[k] = 0.0;
      v48 = 0.0;
      do
      {
        v49 = *(float *)sub_18F3558C8((uint64_t)v81, k, v47);
        v50 = v49 * *(float *)sub_18F3558C8((uint64_t)v81, k, v47);
        v48 = v48 + (float)(v50 * *(float *)sub_18F45DA54(v33, v47));
        v88[k] = v48;
        ++v47;
      }
      while (v47 != 3);
      for (m = 0; m != 3; ++m)
      {
        v52 = *(float *)sub_18F3558C8((uint64_t)v75, k, m);
        v53 = v52 * *(float *)sub_18F3558C8((uint64_t)v75, k, m);
        v48 = v48 + (float)(v53 * sub_18F3551B0((uint64_t)&v73, m));
        v88[k] = v48;
      }
      if (v48 <= 0.0)
        break;
      if (!k)
      {
        do
        {
          v71 = v88[k];
          *(float *)sub_18F45DA54(v33, k++) = v71;
        }
        while (k != 3);
        return;
      }
      for (n = 0; n != k; ++n)
      {
        v55 = 0;
        v56 = 0.0;
        do
        {
          v57 = *(float *)sub_18F3558C8((uint64_t)v81, n, v55);
          v58 = v57 * *(float *)sub_18F45DA54(v33, v55);
          v56 = v56 + (float)(v58 * *(float *)sub_18F3558C8((uint64_t)v81, k, v55++));
        }
        while (v55 != 3);
        for (ii = 0; ii != 3; ++ii)
        {
          v60 = *(float *)sub_18F3558C8((uint64_t)v75, n, ii);
          v61 = v60 * sub_18F3551B0((uint64_t)&v73, ii);
          v56 = v56 + (float)(v61 * *(float *)sub_18F3558C8((uint64_t)v75, k, ii));
        }
        v62 = 0;
        *(float *)sub_18F45D6FC(v40, n, k) = v56 / v48;
        do
        {
          v63 = *(float *)sub_18F45D6FC(v40, n, k);
          v64 = *(float *)sub_18F3558C8((uint64_t)v81, k, v62);
          v65 = (float *)sub_18F3558C8((uint64_t)v81, n, v62);
          *v65 = *v65 - (float)(v63 * v64);
          ++v62;
        }
        while (v62 != 3);
        for (jj = 0; jj != 3; ++jj)
        {
          v67 = *(float *)sub_18F45D6FC(v40, n, k);
          v68 = *(float *)sub_18F3558C8((uint64_t)v75, k, jj);
          v69 = (float *)sub_18F3558C8((uint64_t)v75, n, jj);
          *v69 = *v69 - (float)(v67 * v68);
        }
      }
    }
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954868);
    v70 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = k;
      _os_log_impl(&dword_18F1DC000, v70, OS_LOG_TYPE_DEBUG, "D[%zu] <= 0, matrix ! positive definite", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954868);
      v83 = 134217984;
      v84 = k;
      v21 = (_BYTE *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMFactoredMatrix<float, 3>::thorntonTemporalUpdate(CMMatrix<T, N, N> &, CMMatrix<T, N, M> &, const CMVector<T, M> &) [T = float, N = 3, M = 3UL]", "CoreLocation: %s\n");
      goto LABEL_69;
    }
  }
}

void sub_18F4DEC74(uint64_t a1, float32x2_t *a2, unint64_t a3, float a4)
{
  unint64_t v4;
  BOOL v5;
  float v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v4 = *(_QWORD *)(a1 + 48);
  if (v4)
    v5 = v4 >= a3;
  else
    v5 = 0;
  if (!v5 && *(_BYTE *)(a1 + 16) && *(_WORD *)(a1 + 58))
  {
    v8 = (float)a3;
    v9 = a1 + 64;
    v10 = *(unsigned __int16 *)(a1 + 58) + (unint64_t)*(unsigned __int16 *)(a1 + 56) - 1;
    v11 = *(unsigned int *)(a1 + 60);
    if (v10 < v11)
      v11 = 0;
    if ((float)((float)*(unint64_t *)(v9 + 56 * (v10 - v11)) + 5000.0) >= v8
      && (float)(v8 + 5000.0) >= (float)*(unint64_t *)(v9 + 56 * *(unsigned __int16 *)(a1 + 56)))
    {
      *(float *)(a1 + 3732) = a4;
      sub_18F4DED50(a1, a3, a2);
      if ((float32x2_t *)(a1 + 3716) != a2)
        *(_OWORD *)(a1 + 3716) = *(_OWORD *)a2->f32;
      *(_QWORD *)(a1 + 48) = a3;
    }
  }
}

void sub_18F4DED50(uint64_t a1, unint64_t a2, float32x2_t *a3)
{
  unsigned __int16 *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int8 v11;
  unint64_t v13;
  unsigned __int8 v14;
  unint64_t v15;
  unint64_t v16;
  float *v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  float32x4_t v21;

  v6 = (unsigned __int16 *)(a1 + 56);
  v7 = a1 + 64;
  v8 = *(unsigned __int16 *)(a1 + 58);
  v9 = *(unsigned __int16 *)(a1 + 56) + v8 - 1;
  v10 = *(unsigned int *)(a1 + 60);
  if (v9 < v10)
    v10 = 0;
  if (*(_QWORD *)(v7 + 56 * (v9 - v10)) >= a2)
  {
    if ((_DWORD)v8 == 1 || *(_QWORD *)(v7 + 56 * *(unsigned __int16 *)(a1 + 56)) > a2)
      goto LABEL_16;
    v13 = 0;
    v14 = 0;
    do
    {
      if (*(_QWORD *)sub_18F4DFC20(v6, v13) >= a2)
        break;
      v13 = ++v14;
    }
    while ((unint64_t)*(unsigned __int16 *)(a1 + 58) - 1 > v14);
    if (!v14)
    {
LABEL_16:
      v11 = 0;
    }
    else
    {
      v15 = a2 - *(_QWORD *)sub_18F4DFC20(v6, v14 - 1);
      if (v15 >= *(_QWORD *)sub_18F4DFC20(v6, v13) - a2)
        v11 = v14;
      else
        v11 = v14 - 1;
    }
  }
  else
  {
    v11 = v8 - 1;
  }
  v16 = v11;
  v17 = (float *)(sub_18F4DFC20(v6, v11) + 8);
  v18 = sub_18F4DFC20(v6, v16);
  sub_18F4DEF14(a1, v19, v17, (float *)(v18 + 24), (float *)a3);
  v20 = (float *)(sub_18F4DFC20(v6, v16) + 40);
  sub_18F4DF3C8(a1, a2, a3, v20, v21);
}

float sub_18F4DEEB8(float32x2_t *a1, float32x4_t a2)
{
  float v2;
  uint64_t v3;
  int v4;
  int v5;
  float v6;
  float32x4_t v8;
  _DWORD v9[3];

  sub_18F3D381C(a1, (uint64_t)&a1[467], &v8, a2);
  v2 = sub_18F3D3B4C(&v8);
  v3 = 0;
  *(float *)v9 = v2;
  v9[1] = v4;
  v9[2] = v5;
  v6 = 0.0;
  do
  {
    v6 = v6 + (float)(*(float *)&v9[v3] * *(float *)&v9[v3]);
    ++v3;
  }
  while (v3 != 3);
  return sqrtf(v6);
}

void sub_18F4DEF14(uint64_t a1, uint64_t a2, float *a3, float *a4, float *a5)
{
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float32x4_t v16;
  float32x4_t v17;
  __int32 v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 v31;
  unint64_t i;
  float v33;
  unint64_t j;
  float v35;
  float v36;
  float *v37;
  unint64_t v38;
  float v39;
  float v40;
  float32x4_t v41;
  float v42;
  float v43;
  uint64_t v44;
  float v45;
  float v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int v56;
  __int128 v57;
  __int128 v58;
  int v59;
  _OWORD v60[2];
  int v61;
  float v62[3];
  float32x4_t v63;
  float32x4_t v64;
  float v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  float32x4_t v69;
  __int128 v70;
  int v71;
  _OWORD v72[2];
  int v73;
  float32x4_t v74;

  v8 = sub_18F200A14(a4);
  v11 = sub_18F3D39F4((float *)a1, v8, v9, v10);
  v13 = v12;
  v15 = v14;
  v65 = (float)(180.0 - *(float *)(a1 + 3732)) * -0.017453;
  v66 = 0;
  *(double *)v16.i64 = sub_18F3D3AA8(&v64, &v65);
  *(double *)v17.i64 = sub_18F3D3764((uint64_t)&v64, a5, &v63, v16);
  v18 = v63.i32[3];
  v17.i32[0] = v63.i32[2];
  v19 = -v63.f32[2];
  *(float *)&v52 = -v63.f32[0];
  *((float *)&v52 + 1) = -v63.f32[1];
  v74.f32[0] = -v63.f32[0];
  v74.f32[1] = -v63.f32[1];
  v74.f32[2] = -v63.f32[2];
  v74.i32[3] = v63.i32[3];
  sub_18F1FFE94(&v74, v17);
  v20 = sub_18F200A14(a3);
  v23 = sub_18F3D39F4(v74.f32, v20, v21, v22);
  v25 = v24;
  v27 = v26;
  v28 = 0;
  v62[0] = v23 - v11;
  v62[1] = v24 - v13;
  v62[2] = v26 - v15;
  LODWORD(v57) = 0;
  *((float *)&v57 + 1) = v15;
  *((float *)&v57 + 2) = -v13;
  *((float *)&v57 + 3) = -v15;
  LODWORD(v58) = 0;
  *(_QWORD *)((char *)&v58 + 4) = __PAIR64__(LODWORD(v13), LODWORD(v11));
  *((float *)&v58 + 3) = -v11;
  v59 = 0;
  do
  {
    *(float *)((char *)&v57 + v28) = *(float *)((char *)&v57 + v28) + *(float *)((char *)&v57 + v28);
    v28 += 4;
  }
  while (v28 != 36);
  v60[0] = v57;
  v60[1] = v58;
  v29 = *(_QWORD *)(a1 + 20);
  v61 = v59;
  v53 = v29;
  v54 = *(_DWORD *)(a1 + 28);
  v55 = *(_QWORD *)(a1 + 32);
  v56 = *(_DWORD *)(a1 + 40);
  memset(&v74, 0, 108);
  v69.i64[0] = v52;
  v69.i64[1] = __PAIR64__(v18, LODWORD(v19));
  sub_18F1FFE94(&v69, (float32x4_t)HIDWORD(v52));
  sub_18F3D4B74(v69.f32, (float *)v72, 1.0);
  sub_18F4DF8B0((uint64_t)v72, (uint64_t)&v74, 0);
  sub_18F3D4B74((float *)a1, (float *)v72, 1.0);
  sub_18F4DF8B0((uint64_t)v72, (uint64_t)&v74, 3);
  v30 = 0;
  v69.i32[0] = 0;
  v69.f32[1] = v27;
  v69.f32[2] = -v25;
  v69.f32[3] = -v27;
  LODWORD(v70) = 0;
  *(_QWORD *)((char *)&v70 + 4) = __PAIR64__(LODWORD(v25), LODWORD(v23));
  *((float *)&v70 + 3) = -v23;
  v71 = 0;
  do
  {
    v69.f32[v30] = v69.f32[v30] + v69.f32[v30];
    ++v30;
  }
  while (v30 != 9);
  v72[0] = v69;
  v72[1] = v70;
  v73 = v71;
  sub_18F4DF8B0((uint64_t)v72, (uint64_t)&v74, 6);
  v31 = atomic_load((unsigned __int8 *)qword_1ECEDFD90);
  if ((v31 & 1) == 0 && __cxa_guard_acquire(qword_1ECEDFD90))
  {
    xmmword_1ECEDFDA0 = (__int128)vdupq_n_s32(0x3D20D97Cu);
    unk_1ECEDFDB0 = xmmword_18F509EF0;
    dword_1ECEDFDC0 = 1040583314;
    __cxa_guard_release(qword_1ECEDFD90);
  }
  for (i = 0; i != 3; ++i)
  {
    v33 = sub_18F38339C((uint64_t)&v74, i, 0) * *(float *)&xmmword_1ECEDFDA0;
    *(float *)sub_18F33D3D0((uint64_t)v72, i) = v33;
    for (j = 1; j != 9; ++j)
    {
      v35 = sub_18F38339C((uint64_t)&v74, i, j);
      v36 = sub_18F37D2D4((uint64_t)&xmmword_1ECEDFDA0, j);
      v37 = (float *)sub_18F33D3D0((uint64_t)v72, i);
      *v37 = *v37 + (float)(v35 * v36);
    }
  }
  v38 = 0;
  v67 = *(_QWORD *)&v72[0];
  v68 = DWORD2(v72[0]);
  do
  {
    v39 = sub_18F3551B0((uint64_t)&v67, v38);
    v40 = v39 * sub_18F3551B0((uint64_t)&v67, v38);
    *(float *)sub_18F33D3D0((uint64_t)v72, v38++) = v40;
  }
  while (v38 != 3);
  v74.i64[0] = *(_QWORD *)&v72[0];
  v74.i32[2] = DWORD2(v72[0]);
  sub_18F45D164((float *)(a1 + 20), (uint64_t)v60, (uint64_t)&v74, (uint64_t)v62);
  v44 = 0;
  *(_QWORD *)&v72[0] = __PAIR64__(LODWORD(v42), v41.u32[0]);
  *((float *)v72 + 2) = v43;
  v45 = 0.0;
  do
  {
    v45 = v45 + (float)(*(float *)((char *)v72 + v44) * *(float *)((char *)v72 + v44));
    v44 += 4;
  }
  while (v44 != 12);
  if ((float)(sqrtf(v45) * 57.296) > 15.0)
  {
    *(_QWORD *)(a1 + 20) = v53;
    *(_DWORD *)(a1 + 28) = v54;
    *(_QWORD *)(a1 + 32) = v55;
    *(_DWORD *)(a1 + 40) = v56;
    __asm { FMOV            V2.2S, #16.0 }
    *(float32x2_t *)v69.f32 = vmul_f32(*(float32x2_t *)v74.f32, _D2);
    v69.f32[2] = v74.f32[2] * 16.0;
    sub_18F45D164((float *)(a1 + 20), (uint64_t)v60, (uint64_t)&v69, (uint64_t)v62);
  }
  v51 = (float)((float)(v15 * v43) + (float)(v42 * v13)) + (float)(v41.f32[0] * v11);
  *(float *)v72 = v41.f32[0] - (float)(v11 * v51);
  *((float *)v72 + 1) = v42 - (float)(v13 * v51);
  v41.f32[0] = v43 - (float)(v15 * v51);
  *((float *)v72 + 2) = v41.f32[0];
  sub_18F4DF798((float *)a1, (unsigned __int32 *)v72, v41);
}

void sub_18F4DF3C8(uint64_t a1, unint64_t a2, float32x2_t *a3, float *a4, float32x4_t a5)
{
  uint64_t v9;
  uint64_t v10;
  float v11;
  __int32 v12;
  float32x4_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  float v25;
  uint64_t v26;
  float v27;
  uint64_t v28;
  float v29;
  float v30;
  uint64_t v31;
  float v32;
  float v33;
  uint64_t v34;
  unsigned int v35;
  float32_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  float32x4_t v42;
  int v48;
  int v49;
  float32x2_t v50;
  float v51;
  __int32 v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  float32x2_t v59;
  float v60;
  float32x4_t v61;
  float32x4_t v62;
  int v63;
  float32x4_t v64[2];
  int v65;
  float v66[3];
  _DWORD v67[3];
  float32x4_t v68;

  if (*(_BYTE *)(a1 + 16) && *(_DWORD *)(a1 + 3680) == *(unsigned __int16 *)(a1 + 3678))
  {
    v9 = a1 + 3648;
    if (*(_BYTE *)(a1 + 3648))
      sub_18F33FB38(v9);
    if (*(float *)(a1 + 3652) <= 0.017453)
    {
      v10 = *(_QWORD *)(a1 + 48);
      if (v10)
      {
        v11 = (float)(a2 - v10) * 0.000001;
        if (v11 <= 0.25)
        {
          v12 = a3[1].i32[1];
          a5.f32[0] = -a3[1].f32[0];
          *(float32x2_t *)v64[0].f32 = vneg_f32(*a3);
          v64[0].i64[1] = __PAIR64__(v12, a5.u32[0]);
          v13 = sub_18F1FFE94(v64, a5);
          sub_18F3D3764((uint64_t)v64, (float *)(a1 + 3716), &v68, v13);
          v14 = sub_18F3D3B4C(&v68) / v11;
          v16 = v15 / v11;
          v18 = v17 / v11;
          *(float *)v67 = v14;
          *(float *)&v67[1] = v16;
          *(float *)&v67[2] = v18;
          v19 = (float)a2;
          v20 = a1 + 64;
          v21 = *(unsigned __int16 *)(a1 + 56) + (unint64_t)*(unsigned __int16 *)(a1 + 58) - 1;
          v22 = *(unsigned int *)(a1 + 60);
          if (v21 < v22)
            v22 = 0;
          if ((float)((float)*(unint64_t *)(v20 + 56 * (v21 - v22)) + 50000.0) >= v19)
          {
            v23 = *(_QWORD *)(v20 + 56 * *(unsigned __int16 *)(a1 + 56));
            if (v23 < 0xC351 || (float)((float)v23 + -50000.0) <= v19)
            {
              v24 = 0;
              v25 = 0.0;
              do
              {
                v25 = v25 + (float)(a4[v24] * a4[v24]);
                ++v24;
              }
              while (v24 != 3);
              if (sqrtf(v25) >= 0.17453)
              {
                v26 = 0;
                v27 = 0.0;
                do
                {
                  v27 = v27 + (float)(a4[v26] * a4[v26]);
                  ++v26;
                }
                while (v26 != 3);
                v28 = 0;
                v29 = sqrtf(v27) * 0.1;
                v30 = 0.0;
                do
                {
                  v30 = v30 + (float)(a4[v28] * a4[v28]);
                  ++v28;
                }
                while (v28 != 3);
                v31 = 0;
                v32 = 0.0;
                do
                {
                  v32 = v32 + (float)(*(float *)&v67[v31] * *(float *)&v67[v31]);
                  ++v31;
                }
                while (v31 != 3);
                if (v29 < 0.087266)
                  v29 = 0.087266;
                if (vabds_f32(sqrtf(v30), sqrtf(v32)) <= v29)
                {
                  v33 = sub_18F3D39F4((float *)a1, *a4, a4[1], a4[2]);
                  v34 = 0;
                  v66[0] = v14 - v33;
                  v66[1] = v16 - *(float *)&v35;
                  v66[2] = v18 - v36;
                  v61.i32[0] = 0;
                  v61.f32[1] = v36;
                  v61.f32[2] = -*(float *)&v35;
                  v61.f32[3] = -v36;
                  v62.i32[0] = 0;
                  *(uint64_t *)((char *)v62.i64 + 4) = __PAIR64__(v35, LODWORD(v33));
                  v62.f32[3] = -v33;
                  v63 = 0;
                  do
                  {
                    v61.f32[v34] = v61.f32[v34] + v61.f32[v34];
                    ++v34;
                  }
                  while (v34 != 9);
                  v64[0] = v61;
                  v64[1] = v62;
                  v65 = v63;
                  v59 = (float32x2_t)vdup_n_s32(0x3E8C5E23u);
                  v37 = *(_QWORD *)(a1 + 20);
                  v60 = 0.27416;
                  v55 = v37;
                  v38 = *(_QWORD *)(a1 + 32);
                  v56 = *(_DWORD *)(a1 + 28);
                  v57 = v38;
                  v58 = *(_DWORD *)(a1 + 40);
                  sub_18F45D164((float *)(a1 + 20), (uint64_t)v64, (uint64_t)&v59, (uint64_t)v66);
                  v39 = 0;
                  v52 = v42.i32[0];
                  v53 = v40;
                  v54 = v41;
                  v42.i32[0] = 0;
                  do
                  {
                    v42.f32[0] = v42.f32[0] + (float)(*(float *)((char *)&v52 + v39) * *(float *)((char *)&v52 + v39));
                    v39 += 4;
                  }
                  while (v39 != 12);
                  v42.f32[0] = sqrtf(v42.f32[0]) * 57.296;
                  if (v42.f32[0] > 15.0)
                  {
                    *(_QWORD *)(a1 + 20) = v55;
                    *(_DWORD *)(a1 + 28) = v56;
                    *(_QWORD *)(a1 + 32) = v57;
                    *(_DWORD *)(a1 + 40) = v58;
                    __asm { FMOV            V2.2S, #16.0 }
                    v50 = vmul_f32(v59, _D2);
                    v51 = v60 * 16.0;
                    sub_18F45D164((float *)(a1 + 20), (uint64_t)v64, (uint64_t)&v50, (uint64_t)v66);
                    v52 = v42.i32[0];
                    v53 = v48;
                    v54 = v49;
                  }
                  sub_18F4DF798((float *)a1, (unsigned __int32 *)&v52, v42);
                }
              }
            }
          }
        }
      }
    }
  }
}

double sub_18F4DF798(float *a1, unsigned __int32 *a2, float32x4_t a3)
{
  uint64_t v4;
  unsigned __int32 v5;
  unsigned __int32 v6;
  float v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  uint64_t i;
  uint64_t v13;
  float v14;
  float32x4_t v15;
  double result;
  float32x4_t v17;
  float32x4_t v18;
  _DWORD v19[3];

  v4 = 0;
  a3.i32[0] = *a2;
  v5 = a2[1];
  v6 = a2[2];
  v19[0] = *a2;
  v19[1] = v5;
  v19[2] = v6;
  v7 = 0.0;
  do
  {
    v7 = v7 + (float)(*(float *)&v19[v4] * *(float *)&v19[v4]);
    ++v4;
  }
  while (v4 != 3);
  v8 = 0;
  v9 = 0.0;
  do
  {
    v9 = v9 + (float)(*(float *)&v19[v8] * *(float *)&v19[v8]);
    ++v8;
  }
  while (v8 != 3);
  v10 = 1.0 - (float)(sqrtf(v7) * sqrtf(v9));
  v11 = 0.0;
  if (v10 > 0.0)
  {
    for (i = 0; i != 3; ++i)
      v11 = v11 + (float)(*(float *)&v19[i] * *(float *)&v19[i]);
    v13 = 0;
    v14 = 0.0;
    do
    {
      v14 = v14 + (float)(*(float *)&v19[v13] * *(float *)&v19[v13]);
      ++v13;
    }
    while (v13 != 3);
    v11 = 1.0 - (float)(sqrtf(v11) * sqrtf(v14));
  }
  v18.i64[0] = __PAIR64__(v5, a3.u32[0]);
  a3.f32[0] = sqrtf(v11);
  v18.i64[1] = __PAIR64__(a3.u32[0], v6);
  v15 = sub_18F1FFE94(&v18, a3);
  sub_18F3D3764((uint64_t)&v18, a1, &v17, v15);
  result = *(double *)v17.i64;
  *(float32x4_t *)a1 = v17;
  return result;
}

float *sub_18F4DF8B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t i;
  unint64_t j;
  float v8;
  float *result;

  for (i = 0; i != 3; ++i)
  {
    for (j = 0; j != 3; ++j)
    {
      v8 = sub_18F37D890(a1, i, j);
      result = (float *)sub_18F37DBEC(a2, i, a3 + j);
      *result = v8 + *result;
    }
  }
  return result;
}

os_log_t sub_18F4DF93C()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "RelativeDeviceMotion");
  qword_1EE16D820 = (uint64_t)result;
  return result;
}

float sub_18F4DF968(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  float v4;
  uint64_t v8;
  float v9;
  float v10;

  if (a2 <= a3)
    v3 = a3;
  else
    v3 = a2;
  v4 = 0.0;
  if (v3 <= 2)
  {
    v8 = a1 + 12;
    do
    {
      v9 = 1.0;
      v10 = 1.0;
      if (a3 != v3)
      {
        v10 = 0.0;
        if (v3 > a3)
          v10 = sub_18F4DFA38(v8, a3, v3);
      }
      if (a2 != v3)
      {
        v9 = 0.0;
        if (v3 > a2)
          v9 = sub_18F4DFA38(v8, a2, v3);
      }
      v4 = v4 + (float)((float)(v9 * *(float *)(a1 + 4 * v3++)) * v10);
    }
    while (v3 != 3);
  }
  return v4;
}

float sub_18F4DFA38(uint64_t a1, unint64_t a2, unint64_t a3)
{
  NSObject *v7;
  char *v8;
  uint8_t buf[4];
  unint64_t v10;
  __int16 v11;
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a3 <= a2)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954868);
    v7 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218240;
      v10 = a3;
      v11 = 2048;
      v12 = a2;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: col > row, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/Math/CMFactoredMatrix.h, line 232,invalid element %zu <= %zu.", buf, 0x16u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954868);
      v8 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "T CMFactoredMatrix<float, 3>::UnitaryUpperTriangularMatrix::operator()(size_t, size_t) const [T = float, N = 3]", "CoreLocation: %s\n", v8);
      if (v8 != (char *)buf)
        free(v8);
    }
  }
  return *(float *)(a1 + 4 * (a2 + (((a3 - 1) * a3) >> 1)));
}

uint64_t sub_18F4DFC20(unsigned __int16 *a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  NSObject *v7;
  int v8;
  char *v9;
  uint8_t buf[4];
  unint64_t v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E2954868);
    v7 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
    {
      v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)buf = 134218240;
      v11 = a2;
      v12 = 1024;
      v13 = v8;
      _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocationFramework/Oscar/CMQueue.h, line 233,i,%zu,capacity,%u.", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954868);
      v9 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "const T &CMQueue<CMHeadToHeadsetAttitudeEstimator::SrcAuxIMUDataPair>::operator[](const size_t) const [T = CMHeadToHeadsetAttitudeEstimator::SrcAuxIMUDataPair]", "CoreLocation: %s\n", v9);
      if (v9 != (char *)buf)
        free(v9);
    }
  }
  v4 = *a1 + a2;
  v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5)
    v5 = 0;
  return (uint64_t)&a1[28 * (v4 - v5) + 4];
}

uint64_t sub_18F4E0194()
{
  if (qword_1ECEDFDD0 != -1)
    dispatch_once(&qword_1ECEDFDD0, &unk_1E29544C8);
  return qword_1ECEDFDC8;
}

void sub_18F4E01D4()
{
  NSObject *v0;
  char *v1;
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  uint8_t buf[8];
  _BYTE v21[32];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((sub_18F1F7BFC() & 4) != 0)
  {
    v2 = operator new();
    sub_18F1E61EC(v2, (uint64_t)"CLGestureService", 1);
    *(_QWORD *)v2 = &off_1E294A440;
    *(_OWORD *)(v2 + 36) = 0u;
    *(_OWORD *)(v2 + 52) = 0u;
    *(_QWORD *)(v2 + 65) = 0;
    if ((sub_18F1F7BFC() & 4) == 0)
    {
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      v17 = qword_1ECEDEE10;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 68289539;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v21 = 2082;
        *(_QWORD *)&v21[2] = "";
        *(_WORD *)&v21[10] = 2082;
        *(_QWORD *)&v21[12] = "assert";
        *(_WORD *)&v21[20] = 2081;
        *(_QWORD *)&v21[22] = "isGestureServiceAvailable()";
        _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Service required to send command\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        if (qword_1ECEDEE18 != -1)
          dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      }
      v18 = qword_1ECEDEE10;
      if (os_signpost_enabled((os_log_t)qword_1ECEDEE10))
      {
        *(_DWORD *)buf = 68289539;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v21 = 2082;
        *(_QWORD *)&v21[2] = "";
        *(_WORD *)&v21[10] = 2082;
        *(_QWORD *)&v21[12] = "assert";
        *(_WORD *)&v21[20] = 2081;
        *(_QWORD *)&v21[22] = "isGestureServiceAvailable()";
        _os_signpost_emit_with_name_impl(&dword_18F1DC000, v18, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Service required to send command", "{\"msg%{public}.0s\":\"Service required to send command\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        if (qword_1ECEDEE18 != -1)
          dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      }
      v19 = qword_1ECEDEE10;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 68289539;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v21 = 2082;
        *(_QWORD *)&v21[2] = "";
        *(_WORD *)&v21[10] = 2082;
        *(_QWORD *)&v21[12] = "assert";
        *(_WORD *)&v21[20] = 2081;
        *(_QWORD *)&v21[22] = "isGestureServiceAvailable()";
        _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Service required to send command\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      }
      abort_report_np();
      __break(1u);
    }
    v3 = sub_18F204AE4();
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)v21 = 3221225472;
    *(_QWORD *)&v21[8] = sub_18F4E0668;
    *(_QWORD *)&v21[16] = &unk_1E2955738;
    *(_QWORD *)&v21[24] = v2;
    sub_18F1F5E28(v3, (uint64_t)buf);
    v8 = (void *)objc_msgSend_processInfo(MEMORY[0x1E0CB3898], v4, v5, v6, v7);
    v13 = (void *)objc_msgSend_processName(v8, v9, v10, v11, v12);
    *(_BYTE *)(v2 + 72) = objc_msgSend_isEqualToString_(v13, v14, (uint64_t)CFSTR("SurfBoard"), v15, v16);
    qword_1ECEDFDC8 = v2;
  }
  else
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v0 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_DEFAULT, "#Warning Gesture service is not available on this platform", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      v1 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "static void CLGestureService::create()", "CoreLocation: %s\n", v1);
      if (v1 != (char *)buf)
        free(v1);
    }
  }
}

void sub_18F4E0624(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10F1C40D044DD44);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4E0668(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v6;
  char v7;
  __int128 v8;

  v1 = *(_QWORD *)(a1 + 32);
  if (qword_1ECEDFDE8 != -1)
    dispatch_once(&qword_1ECEDFDE8, &unk_1E2953A08);
  v6 = 0x30000FF0CLL;
  v7 = 0;
  sub_18F1E9BC8((_QWORD *)qword_1ECEDFDE0, (uint64_t)&v6, (uint64_t *)&v8);
  sub_18F346DC8(v1 + 40, &v8);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  sub_18F203148(*(_QWORD *)(v1 + 40), (uint64_t)sub_18F4E0768, v1);
  sub_18F4D4518(*(_QWORD *)(v1 + 40), (const char *)sub_18F4E0CEC, v1);
  sub_18F4D3D78(*(_QWORD *)(v1 + 40), (uint64_t)sub_18F4E0CEC, v1);
  return sub_18F4D3788(*(_QWORD *)(v1 + 40), (uint64_t)sub_18F4E0CEC, v1);
}

void sub_18F4E0768()
{
  NSObject *v0;
  char *v1;
  int __dst;
  uint8_t buf[4];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  IOHIDEventGetVendorDefinedData();
  if (qword_1EE16D430 != -1)
    dispatch_once(&qword_1EE16D430, &unk_1E2945288);
  v0 = qword_1EE16D420;
  if (os_log_type_enabled((os_log_t)qword_1EE16D420, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v0, OS_LOG_TYPE_FAULT, "Empty payload", buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D430 != -1)
      dispatch_once(&qword_1EE16D430, &unk_1E2945288);
    LOWORD(__dst) = 0;
    v1 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "static void CLGestureService::onGestureServiceIohidEvent(void *, void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v1);
    if (v1 != (char *)buf)
      free(v1);
  }
}

void sub_18F4E0CEC(uint64_t *a1)
{
  sub_18F4E1A54(a1);
  sub_18F4E0D78(a1);
}

_QWORD *sub_18F4E0D10(_QWORD *a1)
{
  uint64_t v2;

  *a1 = &off_1E294A440;
  v2 = (uint64_t)(a1 + 5);
  sub_18F3A4658(a1 + 5);
  sub_18F2A8438(v2);
  return sub_18F3DB8A0(a1);
}

void sub_18F4E0D54(_QWORD *a1)
{
  sub_18F4E0D10(a1);
  JUMPOUT(0x194001438);
}

void sub_18F4E0D78(uint64_t *a1)
{
  CFRunLoopRef Current;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  __IOHIDServiceClient *v6;
  __IOHIDServiceClient *v7;
  const __CFNumber *RegistryID;
  mach_port_t v9;
  const __CFDictionary *v10;
  io_service_t MatchingService;
  io_service_t v12;
  const __CFAllocator *v13;
  const __CFUUID *v14;
  const __CFUUID *v15;
  kern_return_t v16;
  mach_error_t v17;
  NSObject *v18;
  char *v19;
  NSObject *v20;
  uint8_t *v21;
  NSObject *v22;
  IOCFPlugInInterface **v23;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  const __CFUUID *v25;
  CFUUIDBytes v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  _QWORD v42[5];
  SInt32 theScore;
  uint64_t v44;
  IOCFPlugInInterface **theInterface;
  uint64_t valuePtr;
  int v47;
  _BYTE v48[18];
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  IOCFPlugInInterface **v52;
  __int16 v53;
  uint64_t v54;
  uint8_t buf[4];
  _BYTE v56[18];
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  IOCFPlugInInterface **v60;
  __int16 v61;
  uint64_t v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v3 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v3, OS_LOG_TYPE_FAULT, "openHidDriverInterface should be called from motion thread", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      LOWORD(v47) = 0;
      v33 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLGestureService::openHidDriverInterface()", "CoreLocation: %s\n", v33);
      if (v33 != (char *)buf)
        free(v33);
    }
    v4 = sub_18F204AE4();
    v42[0] = MEMORY[0x1E0C809B0];
    v42[1] = 3221225472;
    v42[2] = sub_18F4E1A4C;
    v42[3] = &unk_1E2955738;
    v42[4] = a1;
    sub_18F1F5E28(v4, (uint64_t)v42);
    return;
  }
  if (!a1[5])
    return;
  if (qword_1ECEDEE18 != -1)
    dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
  v5 = qword_1ECEDEE10;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v5, OS_LOG_TYPE_INFO, "Open hid driver interface", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    LOWORD(v47) = 0;
    v34 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLGestureService::openHidDriverInterface()", "CoreLocation: %s\n", v34);
    if (v34 != (char *)buf)
      free(v34);
  }
  theInterface = 0;
  valuePtr = 0;
  v44 = 0;
  v6 = (__IOHIDServiceClient *)sub_18F1FBD7C(a1[5]);
  if (!v6)
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v20 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v20, OS_LOG_TYPE_INFO, "IoHidDevice is not ready!", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    LOWORD(v47) = 0;
    v21 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLGestureService::openHidDriverInterface()", "CoreLocation: %s\n");
LABEL_40:
    if (v21 != buf)
      free(v21);
    return;
  }
  v7 = v6;
  RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(v6);
  CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
  theScore = 0;
  v9 = *MEMORY[0x1E0CBBAA8];
  v10 = IORegistryEntryIDMatching(valuePtr);
  MatchingService = IOServiceGetMatchingService(v9, v10);
  if (!MatchingService)
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v22 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v22, OS_LOG_TYPE_FAULT, "Service doesn't exist", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      return;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    LOWORD(v47) = 0;
    v21 = (uint8_t *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "void CLGestureService::openHidDriverInterface()", "CoreLocation: %s\n");
    goto LABEL_40;
  }
  v12 = MatchingService;
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE30];
  v14 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 0x3Bu, 0xC5u, 0xCCu, 0x87u, 0x84u, 0x5Eu, 0x48u, 0xABu, 0xA9u, 0xC2u, 0x94u, 0x36u, 0, 0x1Bu, 0xA6u, 0x8Au);
  v15 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  v16 = IOCreatePlugInInterfaceForService(v12, v14, v15, &theInterface, &theScore);
  if (v16)
  {
    v17 = v16;
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v18 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
    {
      v19 = mach_error_string(v17);
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v56 = v19;
      _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_FAULT, "Unable to create plugin interface %s", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      v35 = mach_error_string(v17);
      v47 = 136315138;
      *(_QWORD *)v48 = v35;
      v36 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLGestureService::openHidDriverInterface()", "CoreLocation: %s\n", v36);
      if (v36 != (char *)buf)
        free(v36);
    }
    IOObjectRelease(v12);
    return;
  }
  IOObjectRelease(v12);
  v23 = theInterface;
  QueryInterface = (*theInterface)->QueryInterface;
  v25 = CFUUIDGetConstantUUIDWithBytes(v13, 0x6Eu, 0xBEu, 0xBAu, 0x6Eu, 9u, 0x1Eu, 0x45u, 0x2Eu, 0x82u, 0xEAu, 0x29u, 0x79u, 0x81u, 0x6Fu, 0xB1u, 0xB5u);
  v26 = CFUUIDGetUUIDBytes(v25);
  if (((unsigned int (*)(IOCFPlugInInterface **, _QWORD, _QWORD, uint64_t *))QueryInterface)(v23, *(_QWORD *)&v26.byte0, *(_QWORD *)&v26.byte8, &v44))
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v27 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v27, OS_LOG_TYPE_FAULT, "Unable to set up query interface", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      LOWORD(v47) = 0;
      v37 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLGestureService::openHidDriverInterface()", "CoreLocation: %s\n", v37);
      if (v37 != (char *)buf)
        free(v37);
    }
LABEL_48:
    if (theInterface)
    {
      ((void (*)(IOCFPlugInInterface **))(*theInterface)->Release)(theInterface);
      IODestroyPlugInInterface(theInterface);
    }
    return;
  }
  if ((*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v44 + 64))(v44, 0))
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v28 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240450;
      *(_DWORD *)v56 = 0;
      *(_WORD *)&v56[4] = 2114;
      *(_QWORD *)&v56[6] = v7;
      _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_FAULT, "Unable to create plugin interface: kr:%{public}x service:%{public}@", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      v47 = 67240450;
      *(_DWORD *)v48 = 0;
      *(_WORD *)&v48[4] = 2114;
      *(_QWORD *)&v48[6] = v7;
      v38 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLGestureService::openHidDriverInterface()", "CoreLocation: %s\n", v38);
      if (v38 != (char *)buf)
        free(v38);
    }
    if (v44)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v44 + 72))(v44, 0);
    goto LABEL_48;
  }
  if (qword_1ECEDEE18 != -1)
    dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
  v29 = qword_1ECEDEE10;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
  {
    v30 = a1[7];
    v31 = a1[8];
    *(_DWORD *)buf = 134219008;
    *(_QWORD *)v56 = valuePtr;
    *(_WORD *)&v56[8] = 2048;
    *(_QWORD *)&v56[10] = v30;
    v57 = 2048;
    v58 = v31;
    v59 = 2048;
    v60 = theInterface;
    v61 = 2048;
    v62 = v44;
    _os_log_impl(&dword_18F1DC000, v29, OS_LOG_TYPE_INFO, "Opened hid driver interface, registryID %llx, {cfPlugInInterface, hidDriverInterface} was then {%p,%p}, is now {%p,%p}", buf, 0x34u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v39 = a1[7];
    v40 = a1[8];
    v47 = 134219008;
    *(_QWORD *)v48 = valuePtr;
    *(_WORD *)&v48[8] = 2048;
    *(_QWORD *)&v48[10] = v39;
    v49 = 2048;
    v50 = v40;
    v51 = 2048;
    v52 = theInterface;
    v53 = 2048;
    v54 = v44;
    v41 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLGestureService::openHidDriverInterface()", "CoreLocation: %s\n", v41);
    if (v41 != (char *)buf)
      free(v41);
  }
  *(_QWORD *)(a1[5] + 8) = valuePtr;
  v32 = v44;
  a1[7] = (uint64_t)theInterface;
  a1[8] = v32;
}

uint64_t sub_18F4E1A4C(uint64_t a1)
{
  return sub_18F4E0D78(*(_QWORD *)(a1 + 32));
}

void sub_18F4E1A54(_QWORD *a1)
{
  NSObject *v2;
  CFRunLoopRef Current;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  IOCFPlugInInterface **v7;
  uint64_t v8;
  _QWORD *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  _QWORD v18[5];
  int v19;
  IOCFPlugInInterface **v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint8_t buf[4];
  IOCFPlugInInterface **v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE18 != -1)
    dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
  v2 = qword_1ECEDEE10;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v2, OS_LOG_TYPE_INFO, "Close hid driver interface", buf, 2u);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    LOWORD(v19) = 0;
    v13 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLGestureService::closeHidDriverInterface()", "CoreLocation: %s\n", v13);
    if (v13 != (char *)buf)
      free(v13);
  }
  Current = CFRunLoopGetCurrent();
  sub_18F204AE4();
  if (Current != *(CFRunLoopRef *)qword_1ECEDFE08)
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v4 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "closeHidDriverInterface should be called from motion thread", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
      LOWORD(v19) = 0;
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "void CLGestureService::closeHidDriverInterface()", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
    }
    v5 = sub_18F204AE4();
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = sub_18F4E1F58;
    v18[3] = &unk_1E2955738;
    v18[4] = a1;
    sub_18F1F5E28(v5, (uint64_t)v18);
    return;
  }
  v6 = a1[5];
  if (!v6)
    return;
  v7 = (IOCFPlugInInterface **)a1[7];
  v8 = a1[8];
  v9 = a1 + 7;
  if (v8)
  {
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v8 + 72))(a1[8], 0);
    if (!v7)
      goto LABEL_19;
  }
  else if (!v7)
  {
    *(_QWORD *)(v6 + 8) = 0;
    *v9 = 0;
    a1[8] = 0;
    return;
  }
  ((void (*)(IOCFPlugInInterface **))(*v7)->Release)(v7);
  IODestroyPlugInInterface(v7);
LABEL_19:
  *(_QWORD *)(a1[5] + 8) = 0;
  *v9 = 0;
  a1[8] = 0;
  if (qword_1ECEDEE18 != -1)
    dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
  v10 = qword_1ECEDEE10;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
  {
    v11 = a1[7];
    v12 = a1[8];
    *(_DWORD *)buf = 134218752;
    v28 = v7;
    v29 = 2048;
    v30 = v8;
    v31 = 2048;
    v32 = v11;
    v33 = 2048;
    v34 = v12;
    _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_INFO, "Closed hid driver interface, {cfPlugInInterface, hidDriverInterface} was then {%p,%p}, is now {%p,%p}", buf, 0x2Au);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v15 = a1[7];
    v16 = a1[8];
    v19 = 134218752;
    v20 = v7;
    v21 = 2048;
    v22 = v8;
    v23 = 2048;
    v24 = v15;
    v25 = 2048;
    v26 = v16;
    v17 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CLGestureService::closeHidDriverInterface()", "CoreLocation: %s\n", v17);
    if (v17 != (char *)buf)
      free(v17);
  }
}

uint64_t sub_18F4E1F58(uint64_t a1)
{
  return sub_18F4E1A54(*(_QWORD *)(a1 + 32));
}

void sub_18F4E1F60(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(v1 + 36);
  *(_DWORD *)(v1 + 36) = v2 + 1;
  if (!v2)
  {
    if (sub_18F1FBD7C(*(_QWORD *)(v1 + 40)))
      sub_18F4E1A54((_QWORD *)v1);
    sub_18F4E0D78((uint64_t *)v1);
  }
}

void sub_18F4E1FB0(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(v1 + 36) - 1;
  *(_DWORD *)(v1 + 36) = v2;
  if (!v2)
  {
    if (sub_18F1FBD7C(*(_QWORD *)(v1 + 40)))
      sub_18F4E1A54((_QWORD *)v1);
  }
}

BOOL sub_18F4E1FF8(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  void *v4;
  __objc2_class *v5;
  uint64_t v6;
  uint64_t v10;
  Class isa;
  int v12;
  __objc2_class *v13;
  NSObject *v14;
  char *v15;
  _BOOL8 v16;
  char *v17;
  char *v18;
  NSObject *v19;
  uint64_t v21;
  NSObject *v23;
  NSObject *v24;
  uint64_t v25;
  int v26;
  int v27;
  char *v28;
  __int16 v29;
  int v30;
  _BYTE buf[1640];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if ((sub_18F1F7BFC() & 4) == 0)
  {
    v13 = CMVO2MaxRetrocomputeState;
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v23 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = "assert";
      *(_WORD *)&buf[28] = 2081;
      *(_QWORD *)&buf[30] = "isGestureServiceAvailable()";
      _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Service required to send gesture command\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    }
    v24 = qword_1ECEDEE10;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE10))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = "assert";
      *(_WORD *)&buf[28] = 2081;
      *(_QWORD *)&buf[30] = "isGestureServiceAvailable()";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Service required to send gesture command", "{\"msg%{public}.0s\":\"Service required to send gesture command\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    }
    a1 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = "assert";
      *(_WORD *)&buf[28] = 2081;
      *(_QWORD *)&buf[30] = "isGestureServiceAvailable()";
      _os_log_impl(&dword_18F1DC000, a1, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Service required to send gesture command\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
LABEL_36:
    dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    goto LABEL_5;
  }
  v10 = sub_18F204AE4();
  v3 = MEMORY[0x1E0C809B0];
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  v6 = 3221225472;
  *(_QWORD *)&buf[8] = 3221225472;
  v4 = &unk_1E2955738;
  *(_QWORD *)&buf[16] = sub_18F4E1F60;
  *(_QWORD *)&buf[24] = &unk_1E2955738;
  *(_QWORD *)&buf[32] = a1;
  sub_18F1F5E28(v10, (uint64_t)buf);
  isa = a1[8].isa;
  if (!isa)
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v19 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_INFO, "gestureHidDriverInterface NULL", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 2))
      goto LABEL_17;
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    LOWORD(v27) = 0;
    v18 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL CLGestureService::sendGestureServiceCommand(const void *, size_t)", "CoreLocation: %s\n", v18);
    if (v18 == buf)
      goto LABEL_17;
LABEL_40:
    free(v18);
LABEL_17:
    v16 = 0;
    goto LABEL_24;
  }
  v26 = 0;
  v25 = 4;
  v12 = (*(uint64_t (**)(Class, uint64_t, uint64_t, int *, uint64_t *))(*(_QWORD *)isa + 80))(isa, a2, a3, &v26, &v25);
  if (!v12)
  {
    v16 = v25 == 4 && v26 != 0;
    goto LABEL_24;
  }
  LODWORD(v13) = v12;
  v5 = CMVO2MaxRetrocomputeState;
  if (qword_1ECEDEE18 != -1)
    goto LABEL_36;
LABEL_5:
  v14 = qword_1ECEDEE10;
  if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
  {
    v15 = mach_error_string((mach_error_t)v13);
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v15;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = (_DWORD)v13;
    _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_FAULT, "sendGestureServiceCommand() = %s (0x%x)", buf, 0x12u);
  }
  v16 = 0;
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (v5[90].superclass != (__objc2_class *)-1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v17 = mach_error_string((mach_error_t)v13);
    v27 = 136315394;
    v28 = v17;
    v29 = 1024;
    v30 = (int)v13;
    v18 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "BOOL CLGestureService::sendGestureServiceCommand(const void *, size_t)", "CoreLocation: %s\n", v18);
    if (v18 == buf)
      goto LABEL_17;
    goto LABEL_40;
  }
LABEL_24:
  v21 = sub_18F204AE4();
  *(_QWORD *)buf = v3;
  *(_QWORD *)&buf[8] = v6;
  *(_QWORD *)&buf[16] = sub_18F4E1FB0;
  *(_QWORD *)&buf[24] = v4;
  *(_QWORD *)&buf[32] = a1;
  sub_18F1F5E28(v21, (uint64_t)buf);
  return v16;
}

BOOL sub_18F4E25FC(uint64_t a1, int a2, int a3)
{
  _BOOL8 result;
  int v7;

  v7 = 5;
  BYTE1(v7) = a2;
  BYTE2(v7) = a3;
  result = sub_18F4E1FF8(a1, (uint64_t)&v7, 4);
  if (a2 == 8 && result)
    *(_BYTE *)(a1 + 32) = a3 != 0;
  return result;
}

void sub_18F4E2664(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v4;
  void (*v5)(uint64_t);
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint8_t buf[8];
  _BYTE v10[32];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE18 != -1)
      dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    v6 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v10 = 2082;
      *(_QWORD *)&v10[2] = "";
      *(_WORD *)&v10[10] = 2082;
      *(_QWORD *)&v10[12] = "assert";
      *(_WORD *)&v10[20] = 2081;
      *(_QWORD *)&v10[22] = "notification == kNotificationGestureReport";
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    }
    v7 = qword_1ECEDEE10;
    if (os_signpost_enabled((os_log_t)qword_1ECEDEE10))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v10 = 2082;
      *(_QWORD *)&v10[2] = "";
      *(_WORD *)&v10[10] = 2082;
      *(_QWORD *)&v10[12] = "assert";
      *(_WORD *)&v10[20] = 2081;
      *(_QWORD *)&v10[22] = "notification == kNotificationGestureReport";
      _os_signpost_emit_with_name_impl(&dword_18F1DC000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Assertion failed", "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      if (qword_1ECEDEE18 != -1)
        dispatch_once(&qword_1ECEDEE18, &unk_1E2954DE8);
    }
    v8 = qword_1ECEDEE10;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE10, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v10 = 2082;
      *(_QWORD *)&v10[2] = "";
      *(_WORD *)&v10[10] = 2082;
      *(_QWORD *)&v10[12] = "assert";
      *(_WORD *)&v10[20] = 2081;
      *(_QWORD *)&v10[22] = "notification == kNotificationGestureReport";
      _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Assertion failed\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    abort_report_np();
  }
  if (a3)
  {
    v4 = sub_18F204AE4();
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    v5 = sub_18F4E1F60;
  }
  else
  {
    v4 = sub_18F204AE4();
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    v5 = sub_18F4E1FB0;
  }
  *(_QWORD *)v10 = 3221225472;
  *(_QWORD *)&v10[8] = v5;
  *(_QWORD *)&v10[16] = &unk_1E2955738;
  *(_QWORD *)&v10[24] = a1;
  sub_18F1F5E28(v4, (uint64_t)buf);
}

os_log_t sub_18F4E2928()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "WakeGesture");
  qword_1ECEDEE10 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4E2954()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "AOP");
  qword_1EE16D420 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4E2980()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Oversize");
  qword_1EE16D890 = (uint64_t)result;
  return result;
}

double sub_18F4E29AC()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  sub_18F1E61EC(v0, (uint64_t)"CLAccessoryGyro", 2);
  *(_WORD *)(v0 + 28) = 256;
  *(_BYTE *)(v0 + 30) = 0;
  *(_QWORD *)(v0 + 40) = 0;
  *(_QWORD *)(v0 + 48) = 0;
  *(_QWORD *)(v0 + 32) = 0;
  *(_QWORD *)(v0 + 56) = 0x7A00000020;
  result = 0.0;
  *(_OWORD *)(v0 + 64) = 0u;
  *(_OWORD *)(v0 + 80) = 0u;
  *(_QWORD *)v0 = &off_1E2949C20;
  *(_DWORD *)(v0 + 100) = 0x800000;
  qword_1EE16EA08 = v0;
  return result;
}

void sub_18F4E2A38(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x10F1C40E7E486F4);
  _Unwind_Resume(a1);
}

void sub_18F4E2A60(_QWORD *a1)
{
  sub_18F4A2ABC(a1);
  JUMPOUT(0x194001438);
}

double sub_18F4E2A84(uint64_t a1, int a2, double *a3)
{
  NSObject *v4;
  double v5;
  char *v6;
  NSObject *v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  char *v14;
  uint8_t buf[4];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
    v4 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v16) = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "[AccessoryGyro] Unrecognized update interval notification %{public}d", buf, 8u);
    }
    v5 = 0.0;
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryGyro::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
  else
  {
    sub_18F4A461C(a1);
    if (*a3 > 0.0)
    {
      (*(void (**)(double))(**(_QWORD **)(a1 + 32) + 16))(*a3);
      (*(void (**)(void))(**(_QWORD **)(a1 + 32) + 16))();
      *(_BYTE *)(a1 + 30) = 0;
    }
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
    v9 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_INFO))
    {
      v10 = *(_QWORD *)a3;
      *(_DWORD *)buf = 134349056;
      v16 = v10;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "[AccessoryGyro] Setting update interval to %{public}f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
      v14 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryGyro::minimumUpdateIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v14);
      if (v14 != (char *)buf)
        free(v14);
    }
    v11 = rint(*a3 * 1000000.0);
    if (*a3 < 0.0)
      v12 = 0;
    else
      v12 = (uint64_t)v11;
    sub_18F203AF8(*(_QWORD *)(a1 + 32), v12);
    return *a3;
  }
  return v5;
}

double sub_18F4E2E4C(uint64_t a1, int a2, double *a3)
{
  NSObject *v4;
  double v5;
  char *v6;
  NSObject *v9;
  double v10;
  char *v12;
  uint8_t buf[4];
  double v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
    v4 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 67240192;
      LODWORD(v14) = a2;
      _os_log_impl(&dword_18F1DC000, v4, OS_LOG_TYPE_FAULT, "[AccessoryGyro] Unrecognized batch interval notification %{public}d", buf, 8u);
    }
    v5 = 0.0;
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
      v6 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "virtual CFTimeInterval CLAccessoryGyro::minimumBatchIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v6);
      if (v6 != (char *)buf)
        free(v6);
    }
  }
  else
  {
    sub_18F4A461C(a1);
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
    v9 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_INFO))
    {
      v10 = *a3;
      *(_DWORD *)buf = 134349056;
      v14 = v10;
      _os_log_impl(&dword_18F1DC000, v9, OS_LOG_TYPE_INFO, "[AccessoryGyro] Setting batch interval to %{public}f", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
      v12 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual CFTimeInterval CLAccessoryGyro::minimumBatchIntervalChanged(int, const CFTimeInterval &)", "CoreLocation: %s\n", v12);
      if (v12 != (char *)buf)
        free(v12);
    }
    sub_18F203A68(*(_QWORD *)(a1 + 32), *a3);
    return *a3;
  }
  return v5;
}

void sub_18F4E3174(uint64_t a1)
{
  double v2;
  float v3;
  double v4;
  float v5;
  double v6;
  float v7;
  unint64_t TimeStamp;
  double v9;
  unsigned __int16 IntegerValue;
  uint64_t v11;
  float v12;
  NSObject *v13;
  NSObject *v14;
  double v15;
  double v16;
  double v17;
  NSObject *v18;
  char *v19;
  _BYTE *v20;
  _BYTE *v21;
  char *v22;
  char *v23;
  double v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  unsigned __int16 v29;
  float v30;
  NSObject v31;
  _BYTE v32[10];
  __int16 v33;
  double v34;
  __int16 v35;
  _BYTE v36[10];
  double v37;
  __int16 v38;
  _BYTE v39[10];
  double v40;
  int v41;
  int v42;
  __int16 v43;
  _BYTE *v44;
  __int16 v45;
  _BYTE *v46;
  uint8_t buf[4];
  int isa;
  __int16 v49;
  double v50;
  __int16 v51;
  double v52;
  __int16 v53;
  double v54;
  __int16 v55;
  double v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  double v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (IOHIDEventGetType() == 20)
  {
    IOHIDEventGetFloatValue();
    v3 = v2;
    v25 = v3;
    IOHIDEventGetFloatValue();
    v5 = v4;
    v26 = v5;
    IOHIDEventGetFloatValue();
    v7 = v6;
    v27 = v7;
    TimeStamp = IOHIDEventGetTimeStamp();
    v9 = sub_18F1FD20C(TimeStamp);
    v24 = v9;
    IntegerValue = IOHIDEventGetIntegerValue();
    v29 = IntegerValue;
    v11 = sub_18F4E3A64();
    v28 = v11;
    v12 = *(float *)(a1 + 100);
    v30 = v12;
    if (qword_1ECEDEE38 != -1)
      dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
    v13 = qword_1ECEDEE30;
    if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67241728;
      isa = IntegerValue;
      v49 = 2050;
      v50 = v3;
      v51 = 2050;
      v52 = v5;
      v53 = 2050;
      v54 = v7;
      v55 = 2050;
      v56 = v12;
      v57 = 2050;
      v58 = v11;
      v59 = 2050;
      v60 = v9;
      _os_log_impl(&dword_18F1DC000, v13, OS_LOG_TYPE_DEBUG, "[AccessoryGyro] seq,%{public}d,x,%{public}20.20f,y,%{public}20.20f,z,%{public}20.20f,temp,%{public}20.20f,sensorTime,%{public}llu,timestamp,%{public}20.20f", buf, 0x44u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
      LODWORD(v31.isa) = 67241728;
      HIDWORD(v31.isa) = IntegerValue;
      *(_WORD *)v32 = 2050;
      *(double *)&v32[2] = v3;
      v33 = 2050;
      v34 = v5;
      v35 = 2050;
      *(double *)v36 = v7;
      *(_WORD *)&v36[8] = 2050;
      v37 = v12;
      v38 = 2050;
      *(_QWORD *)v39 = v11;
      *(_WORD *)&v39[8] = 2050;
      v40 = v9;
      v19 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "virtual void CLAccessoryGyro::onEventData(void *, void *, IOHIDEventRef)", "CoreLocation: %s\n", v19);
      if (v19 != (char *)buf)
        free(v19);
    }
    sub_18F1FD2C8(a1, 0, (uint64_t)&v24, 40);
    if (!*(_BYTE *)(a1 + 30))
    {
      *(_BYTE *)(a1 + 30) = 1;
      LODWORD(v31.isa) = 0;
      sub_18F270374(v32, "N/A");
      sub_18F270374(&v36[2], "N/A");
      *(_DWORD *)&v39[6] = 0;
      if (sub_18F4A4B24((const char *)a1, &v31))
      {
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
        v14 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
        {
          if (v36[1] >= 0)
            v15 = COERCE_DOUBLE(v32);
          else
            v15 = *(double *)v32;
          if (v39[5] >= 0)
            v16 = COERCE_DOUBLE(&v36[2]);
          else
            v16 = *(double *)&v36[2];
          *(_DWORD *)buf = 67240707;
          isa = (int)v31.isa;
          v49 = 2081;
          v50 = v15;
          v51 = 2081;
          v52 = v16;
          _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_DEBUG, "[AccessoryGyro] config,side,%{public}d,configuration,%{private}s,serialNumber,%{private}s", buf, 0x1Cu);
        }
        if (sub_18F1FCA08(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
          if (v36[1] >= 0)
            v20 = v32;
          else
            v20 = *(_BYTE **)v32;
          if (v39[5] >= 0)
            v21 = &v36[2];
          else
            v21 = *(_BYTE **)&v36[2];
          v41 = 67240707;
          v42 = (int)v31.isa;
          v43 = 2081;
          v44 = v20;
          v45 = 2081;
          v46 = v21;
          v22 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 2, "void CLAccessoryGyro::onGyroData(const Sample &)", "CoreLocation: %s\n", v22);
          if (v22 != (char *)buf)
            free(v22);
        }
        sub_18F1FD2C8(a1, 1, (uint64_t)&v31, 64);
      }
      else
      {
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
        v18 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_FAULT, "[AccessoryGyro] Service not found!", buf, 2u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E29548E8);
          LOWORD(v41) = 0;
          v23 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "void CLAccessoryGyro::onGyroData(const Sample &)", "CoreLocation: %s\n", v23);
          if (v23 != (char *)buf)
            free(v23);
        }
      }
      if ((v39[5] & 0x80000000) != 0)
        operator delete(*(void **)&v36[2]);
      if ((v36[1] & 0x80000000) != 0)
        operator delete(*(void **)v32);
    }
  }
  else if (IOHIDEventGetType() == 15)
  {
    IOHIDEventGetFloatValue();
    *(float *)&v17 = v17;
    *(_DWORD *)(a1 + 100) = LODWORD(v17);
  }
}

void sub_18F4E380C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  sub_18F3CB298((uint64_t)&a17);
  _Unwind_Resume(a1);
}

os_log_t sub_18F4E3848()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1ECEDEE30 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4E3A64()
{
  const __CFArray *Children;
  const __CFArray *v1;
  uint64_t IntegerValue;
  uint64_t DataValue;
  uint64_t v4;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  char *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  Children = (const __CFArray *)IOHIDEventGetChildren();
  if (!Children || (v1 = Children, !CFArrayGetCount(Children)))
  {
    if (qword_1EE16D6D8 != -1)
      dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
    v6 = qword_1EE16D6D0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6D0, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_FAULT, "Event has no children", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      return 0;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6D8 == -1)
      goto LABEL_33;
LABEL_46:
    dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
LABEL_33:
    v11 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "uint64_t sensorTimeFromHidChildEvent(IOHIDEventRef)", "CoreLocation: %s\n", v11);
    if (v11 != (char *)buf)
      free(v11);
    return 0;
  }
  CFArrayGetValueAtIndex(v1, 0);
  IntegerValue = IOHIDEventGetIntegerValue();
  if (IOHIDEventGetIntegerValue() == 65301 && IntegerValue == 2)
  {
    DataValue = IOHIDEventGetDataValue();
    v4 = IOHIDEventGetIntegerValue();
    if (DataValue)
    {
      if (v4 == 8)
        return *(_QWORD *)DataValue;
      if (qword_1EE16D6D8 != -1)
        dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
      v12 = qword_1EE16D6D0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D6D0, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 68289539;
        v16 = 0;
        v17 = 2082;
        v18 = "";
        v19 = 2082;
        v20 = "assert";
        v21 = 2081;
        v22 = "length == sensorTimeSize";
        _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Unexpected sensor time length!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        if (qword_1EE16D6D8 != -1)
          dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
      }
      v13 = qword_1EE16D6D0;
      if (os_signpost_enabled((os_log_t)qword_1EE16D6D0))
      {
        *(_DWORD *)buf = 68289539;
        v16 = 0;
        v17 = 2082;
        v18 = "";
        v19 = 2082;
        v20 = "assert";
        v21 = 2081;
        v22 = "length == sensorTimeSize";
        _os_signpost_emit_with_name_impl(&dword_18F1DC000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Unexpected sensor time length!", "{\"msg%{public}.0s\":\"Unexpected sensor time length!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        if (qword_1EE16D6D8 != -1)
          dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
      }
      v14 = qword_1EE16D6D0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D6D0, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 68289539;
        v16 = 0;
        v17 = 2082;
        v18 = "";
        v19 = 2082;
        v20 = "assert";
        v21 = 2081;
        v22 = "length == sensorTimeSize";
        _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Unexpected sensor time length!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      }
    }
    else
    {
      if (qword_1EE16D6D8 != -1)
        dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
      v8 = qword_1EE16D6D0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D6D0, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 68289539;
        v16 = 0;
        v17 = 2082;
        v18 = "";
        v19 = 2082;
        v20 = "assert";
        v21 = 2081;
        v22 = "payload";
        _os_log_impl(&dword_18F1DC000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Invalid child event payload!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        if (qword_1EE16D6D8 != -1)
          dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
      }
      v9 = qword_1EE16D6D0;
      if (os_signpost_enabled((os_log_t)qword_1EE16D6D0))
      {
        *(_DWORD *)buf = 68289539;
        v16 = 0;
        v17 = 2082;
        v18 = "";
        v19 = 2082;
        v20 = "assert";
        v21 = 2081;
        v22 = "payload";
        _os_signpost_emit_with_name_impl(&dword_18F1DC000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Invalid child event payload!", "{\"msg%{public}.0s\":\"Invalid child event payload!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
        if (qword_1EE16D6D8 != -1)
          dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
      }
      v10 = qword_1EE16D6D0;
      if (os_log_type_enabled((os_log_t)qword_1EE16D6D0, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 68289539;
        v16 = 0;
        v17 = 2082;
        v18 = "";
        v19 = 2082;
        v20 = "assert";
        v21 = 2081;
        v22 = "payload";
        _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Invalid child event payload!\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
      }
    }
    abort_report_np();
  }
  if (qword_1EE16D6D8 != -1)
    dispatch_once(&qword_1EE16D6D8, &unk_1E2954508);
  v7 = qword_1EE16D6D0;
  if (os_log_type_enabled((os_log_t)qword_1EE16D6D0, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18F1DC000, v7, OS_LOG_TYPE_FAULT, "Event has no timestamp", buf, 2u);
  }
  if (sub_18F1FCA08(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D6D8 == -1)
      goto LABEL_33;
    goto LABEL_46;
  }
  return 0;
}

const __CFArray *sub_18F4E4168(uint64_t a1, _BYTE *a2)
{
  const __CFArray *Children;
  const __CFArray *v4;
  CFIndex v5;
  uint64_t IntegerValue;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  char *v11;
  uint64_t v12;
  double v13;
  NSObject *v14;
  char *v16;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  Children = (const __CFArray *)IOHIDEventGetChildren();
  v4 = Children;
  *a2 = 0;
  if (Children)
  {
    if (!CFArrayGetCount(Children))
      return 0;
    *a2 = 1;
    if (CFArrayGetCount(v4) < 1)
      return 0;
    v5 = 0;
    while (1)
    {
      CFArrayGetValueAtIndex(v4, v5);
      IntegerValue = IOHIDEventGetIntegerValue();
      v7 = IOHIDEventGetIntegerValue();
      v8 = IOHIDEventGetIntegerValue();
      v9 = v8;
      if (v7 == 65301 && IntegerValue == 4 && v8 == 8)
        break;
      if (qword_1ECEDEE38 != -1)
        dispatch_once(&qword_1ECEDEE38, &unk_1E2943800);
      v10 = qword_1ECEDEE30;
      if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134284033;
        v18 = v7;
        v19 = 2049;
        v20 = IntegerValue;
        v21 = 2049;
        v22 = v9;
        _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEBUG, "[AccessoryDeviceMotion] Invalid child event for BTC timestamp: usage page 0x%{private}lx usage 0x%{private}lx length %{private}zu", buf, 0x20u);
      }
      if (sub_18F1FCA08(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2943800);
        v11 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 2, "uint64_t btcTimeFromHidChildEvent(IOHIDEventRef, BOOL &)", "CoreLocation: %s\n", v11);
        if (v11 != (char *)buf)
          free(v11);
      }
      if (++v5 >= CFArrayGetCount(v4))
        return 0;
    }
    v4 = *(const __CFArray **)IOHIDEventGetDataValue();
    v12 = mach_continuous_time();
    v13 = sub_18F1FD20C(v12);
    if (!v4)
    {
      if (v13 - *(double *)&qword_1EE16E8A8 > 1.0)
      {
        qword_1EE16E8A8 = *(_QWORD *)&v13;
        if (qword_1ECEDEE38 != -1)
          dispatch_once(&qword_1ECEDEE38, &unk_1E2943800);
        v14 = qword_1ECEDEE30;
        if (os_log_type_enabled((os_log_t)qword_1ECEDEE30, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18F1DC000, v14, OS_LOG_TYPE_ERROR, "[AccessoryDeviceMotion] Invalid child BTC timestamp", buf, 2u);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE38 != -1)
            dispatch_once(&qword_1ECEDEE38, &unk_1E2943800);
          v16 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "uint64_t btcTimeFromHidChildEvent(IOHIDEventRef, BOOL &)", "CoreLocation: %s\n", v16);
          if (v16 != (char *)buf)
            free(v16);
        }
      }
      return 0;
    }
  }
  return v4;
}

BOOL sub_18F4E4568(void *a1, IOHIDServiceClientRef service, CFStringRef key)
{
  CFTypeRef v5;
  const void *v6;
  CFTypeID TypeID;
  BOOL v8;
  _BOOL8 v9;
  NSObject *v10;
  NSObject *v11;
  char *v13;
  char *v14;
  uint8_t buf[4];
  CFStringRef v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v5 = IOHIDServiceClientCopyProperty(service, key);
  if (v5)
  {
    v6 = v5;
    TypeID = CFNumberGetTypeID();
    v8 = TypeID == CFGetTypeID(v6);
    v9 = v8;
    if (v8)
    {
      CFNumberGetValue((CFNumberRef)v6, kCFNumberIntType, a1);
    }
    else
    {
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
      v11 = off_1ECEDEE90;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        v16 = key;
        _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_ERROR, "Invalid type for key %{public}@!", buf, 0xCu);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE98 != -1)
          dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
        v14 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "BOOL getIntFromHIDService(int *, IOHIDServiceClientRef, CFStringRef)", "CoreLocation: %s\n", v14);
        if (v14 != (char *)buf)
          free(v14);
      }
    }
    CFRelease(v6);
  }
  else
  {
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
    v10 = off_1ECEDEE90;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      v16 = key;
      _os_log_impl(&dword_18F1DC000, v10, OS_LOG_TYPE_DEFAULT, "#Warning Key %{public}@ not found!", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
      v13 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "BOOL getIntFromHIDService(int *, IOHIDServiceClientRef, CFStringRef)", "CoreLocation: %s\n", v13);
      if (v13 != (char *)buf)
        free(v13);
    }
    return 0;
  }
  return v9;
}

uint64_t sub_18F4E48BC(uint64_t a1, IOHIDServiceClientRef service, CFStringRef key)
{
  const __CFData *v5;
  const __CFData *v6;
  CFTypeID TypeID;
  UInt8 *BytePtr;
  CFIndex Length;
  size_t v10;
  NSObject *v11;
  uint64_t v12;
  CFTypeID v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  char *v21;
  char *v22;
  uint8_t buf[16];
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = (const __CFData *)IOHIDServiceClientCopyProperty(service, key);
  if (v5)
  {
    v6 = v5;
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v6))
    {
      BytePtr = (UInt8 *)CFDataGetBytePtr(v6);
      Length = CFDataGetLength(v6);
      v10 = 0;
      if (Length)
      {
        while (BytePtr[v10])
        {
          if (Length == ++v10)
          {
            v10 = Length;
            break;
          }
        }
      }
      sub_18F371394(buf, BytePtr, v10);
      if (*(char *)(a1 + 23) < 0)
        operator delete(*(void **)a1);
      *(_OWORD *)a1 = *(_OWORD *)buf;
      *(_QWORD *)(a1 + 16) = v24;
    }
    else
    {
      v13 = CFStringGetTypeID();
      if (v13 != CFGetTypeID(v6))
      {
        if (qword_1ECEDEE98 != -1)
          dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
        v19 = off_1ECEDEE90;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          *(_QWORD *)&buf[4] = key;
          _os_log_impl(&dword_18F1DC000, v19, OS_LOG_TYPE_ERROR, "Invalid type for key %{public}@!", buf, 0xCu);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1ECEDEE98 != -1)
            dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
          v22 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "BOOL getStringFromHIDService(std::string &, IOHIDServiceClientRef, CFStringRef)", "CoreLocation: %s\n", v22);
          if (v22 != (char *)buf)
            free(v22);
        }
        v12 = 0;
        goto LABEL_25;
      }
      v18 = objc_msgSend_UTF8String(v6, v14, v15, v16, v17);
      MEMORY[0x1940012AC](a1, v18);
    }
    v12 = 1;
LABEL_25:
    CFRelease(v6);
    return v12;
  }
  if (qword_1ECEDEE98 != -1)
    dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
  v11 = off_1ECEDEE90;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)&buf[4] = key;
    _os_log_impl(&dword_18F1DC000, v11, OS_LOG_TYPE_DEFAULT, "#Warning Key %{public}@ not found!", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL getStringFromHIDService(std::string &, IOHIDServiceClientRef, CFStringRef)", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
  }
  return 0;
}

NSObject *sub_18F4E4C90(void *a1, IOHIDServiceClientRef service, __CFString *key, size_t a4)
{
  __CFString *v5;
  CFTypeRef v7;
  void *v8;
  CFTypeID TypeID;
  BOOL v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  NSObject *v21;
  const char *v22;
  NSObject *v23;
  char *v25;
  NSObject *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint8_t buf[4];
  _BYTE v57[14];
  __int16 v58;
  uint64_t v59;
  __int16 v60;
  uint64_t v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  const char *v65;
  uint64_t v66;

  v5 = key;
  v66 = *MEMORY[0x1E0C80C00];
  v7 = IOHIDServiceClientCopyProperty(service, key);
  if (v7)
  {
    v8 = (void *)v7;
    TypeID = CFDataGetTypeID();
    v10 = TypeID == CFGetTypeID(v8);
    v15 = v10;
    if (v10)
    {
      if (objc_msgSend_length(v8, v11, v12, v13, v14) == a4)
      {
        v20 = (const void *)objc_msgSend_bytes(v8, v16, v17, v18, v19);
        memcpy(a1, v20, a4);
LABEL_16:
        CFRelease(v8);
        return v15;
      }
      if (qword_1ECEDEE98 != -1)
        dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
      v26 = off_1ECEDEE90;
      v22 = "[data length] == expected_length";
      if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)v57 = 0;
        *(_WORD *)&v57[4] = 2082;
        *(_QWORD *)&v57[6] = "";
        v58 = 2082;
        v59 = objc_msgSend_UTF8String(v5, v27, v28, v29, v30);
        v60 = 2050;
        v61 = objc_msgSend_length(v8, v31, v32, v33, v34);
        v62 = 2082;
        v63 = "assert";
        v64 = 2081;
        v65 = "[data length] == expected_length";
        _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Unexpected length!\", \"key\":%{public, location:escape_only}s, \"length\":%{public}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (qword_1ECEDEE98 != -1)
          dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
      }
      v35 = off_1ECEDEE90;
      if (os_signpost_enabled((os_log_t)off_1ECEDEE90))
      {
        v40 = objc_msgSend_UTF8String(v5, v36, v37, v38, v39);
        v45 = objc_msgSend_length(v8, v41, v42, v43, v44);
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)v57 = 0;
        *(_WORD *)&v57[4] = 2082;
        *(_QWORD *)&v57[6] = "";
        v58 = 2082;
        v59 = v40;
        v60 = 2050;
        v61 = v45;
        v62 = 2082;
        v63 = "assert";
        v64 = 2081;
        v65 = "[data length] == expected_length";
        _os_signpost_emit_with_name_impl(&dword_18F1DC000, v35, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Unexpected length!", "{\"msg%{public}.0s\":\"Unexpected length!\", \"key\":%{public, location:escape_only}s, \"length\":%{public}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (qword_1ECEDEE98 != -1)
          dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
      }
      v15 = off_1ECEDEE90;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_INFO))
      {
        v5 = (__CFString *)objc_msgSend_UTF8String(v5, v46, v47, v48, v49);
        v54 = objc_msgSend_length(v8, v50, v51, v52, v53);
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)v57 = 0;
        *(_WORD *)&v57[4] = 2082;
        *(_QWORD *)&v57[6] = "";
        v58 = 2082;
        v59 = (uint64_t)v5;
        v60 = 2050;
        v61 = v54;
        v62 = 2082;
        v63 = "assert";
        v64 = 2081;
        v65 = "[data length] == expected_length";
        _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Unexpected length!\", \"key\":%{public, location:escape_only}s, \"length\":%{public}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      }
      abort_report_np();
    }
    else
    {
      v22 = (const char *)CMVO2MaxRetrocomputeState;
      if (qword_1ECEDEE98 == -1)
      {
LABEL_13:
        v23 = off_1ECEDEE90;
        if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138543362;
          *(_QWORD *)v57 = v5;
          _os_log_impl(&dword_18F1DC000, v23, OS_LOG_TYPE_ERROR, "Invalid type for key %{public}@!", buf, 0xCu);
        }
        if (sub_18F1FCA08(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (*((_QWORD *)v22 + 467) != -1)
            dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
          v55 = (char *)_os_log_send_and_compose_impl();
          sub_18F419700("Generic", 1, 0, 0, "BOOL getBytesFromHIDService(void *, IOHIDServiceClientRef, CFStringRef, size_t)", "CoreLocation: %s\n", v55);
          if (v55 != (char *)buf)
            free(v55);
        }
        goto LABEL_16;
      }
    }
    dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
    goto LABEL_13;
  }
  if (qword_1ECEDEE98 != -1)
    dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
  v21 = off_1ECEDEE90;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE90, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)v57 = v5;
    _os_log_impl(&dword_18F1DC000, v21, OS_LOG_TYPE_DEFAULT, "#Warning Key %{public}@ not found!", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE98 != -1)
      dispatch_once(&qword_1ECEDEE98, &unk_1E2954C08);
    v25 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "BOOL getBytesFromHIDService(void *, IOHIDServiceClientRef, CFStringRef, size_t)", "CoreLocation: %s\n", v25);
    if (v25 != (char *)buf)
      free(v25);
  }
  return 0;
}

os_log_t sub_18F4E5274()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Sensors");
  qword_1EE16D6D0 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4E52A0()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Accessory");
  qword_1ECEDEE30 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4E5BF8(uint64_t a1)
{
  int32x2_t v2;
  uint64_t v3;
  int32x2_t v4;
  int64x2_t v5;
  float32x2_t v6;
  __float2 v7;
  __float2 v8;
  float *v9;
  float64x2_t v11;
  float64x2_t v12;
  float v13;
  float32x2x2_t v14;

  *(_QWORD *)(a1 + 144) = a1 + 152;
  *(_QWORD *)(a1 + 8) = 256;
  *(_DWORD *)a1 = 8;
  v2 = (int32x2_t)0x100000000;
  v3 = 152;
  v11 = (float64x2_t)vdupq_n_s64(0x3F80000000000000uLL);
  v12 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
  do
  {
    v4 = vneg_s32(v2);
    v5.i64[0] = v4.i32[0];
    v5.i64[1] = v4.i32[1];
    v6 = vcvt_f32_f64(vmulq_f64(vmulq_f64(vcvtq_f64_s64(v5), v12), v11));
    v13 = v6.f32[0];
    v7 = __sincosf_stret(v6.f32[1]);
    v8 = __sincosf_stret(v13);
    v14.val[1] = (float32x2_t)__PAIR64__(LODWORD(v7.__sinval), LODWORD(v8.__sinval));
    v14.val[0] = (float32x2_t)__PAIR64__(LODWORD(v7.__cosval), LODWORD(v8.__cosval));
    v9 = (float *)(a1 + v3);
    vst2_f32(v9, v14);
    v2 = vadd_s32(v2, (int32x2_t)0x200000002);
    v3 += 16;
  }
  while (v3 != 2200);
  sub_18F4E5CE8(256, (int *)(a1 + 16));
  return a1;
}

uint64_t sub_18F4E5CE8(uint64_t result, int *a2)
{
  float v2;
  int v3;
  int v4;

  v2 = sqrtf((float)(int)result);
  v3 = 4;
  do
  {
    while ((int)result % v3)
    {
      v4 = v3 + 2;
      if (v3 == 2)
        v4 = 3;
      if (v3 == 4)
        v3 = 2;
      else
        v3 = v4;
      if (v2 < (float)v3)
        v3 = result;
    }
    result = ((int)result / v3);
    *a2 = v3;
    a2[1] = result;
    a2 += 2;
  }
  while ((int)result > 1);
  return result;
}

void sub_18F4E5D40(uint64_t a1, _DWORD *a2, unsigned __int16 *a3)
{
  int *v5;
  unint64_t v6;
  float v7;
  uint64_t v8;
  float *v9;
  float32x2_t *v10;
  float32x2_t v11;
  float v12;
  _QWORD v13[256];

  v13[255] = *MEMORY[0x1E0C80C00];
  v5 = (int *)(a1 + 8);
  bzero(&v12, 8 * *(int *)(a1 + 8));
  sub_18F4E5E20(&v12, a3, 0, 1, 1u, v5 + 2, (uint64_t)v5);
  *a2 = 0;
  v6 = *v5;
  if ((int)v6 >= 4)
  {
    v7 = (float)(int)v6;
    v8 = (v6 >> 1) - 1;
    v9 = (float *)(a2 + 1);
    v10 = (float32x2_t *)v13;
    do
    {
      v11 = *v10++;
      *v9++ = sqrtf(vaddv_f32(vmul_f32(v11, v11)) / v7);
      --v8;
    }
    while (v8);
  }
}

void sub_18F4E5E20(float *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, unsigned int a5, int *a6, uint64_t a7)
{
  float *v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float *v14;
  unint64_t v15;
  int *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float *v22;
  float *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  float *v27;
  float *v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float *v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float *v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float *v60;
  uint64_t v61;
  float *v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  NSObject *v70;
  char *v71;
  int v73;
  uint8_t buf[4];
  int v77;
  uint64_t v78;

  v9 = a1;
  v78 = *MEMORY[0x1E0C80C00];
  v10 = a6[1];
  v11 = v10 * *a6;
  v73 = *a6;
  if (v10 == 1)
  {
    v12 = a4 * a5;
    v13 = 8 * v11;
    v14 = a1;
    do
    {
      *v14 = *(float *)sub_18F3410E0(a2, (int)a3);
      v14 += 2;
      LODWORD(a3) = a3 + v12;
      v13 -= 8;
    }
    while (v13);
  }
  else
  {
    v15 = 0;
    v16 = a6 + 2;
    v17 = *a6 * a4;
    v18 = a4 * a5;
    v19 = 8 * v11;
    do
    {
      sub_18F4E5E20(&v9[v15 / 4], a2, a3, v17, a5, v16, a7);
      a3 = (a3 + v18);
      v15 += 8 * v10;
    }
    while (v19 != v15);
  }
  if (v73 == 2)
  {
    v60 = (float *)(*(_QWORD *)(a7 + 136) + 4);
    v61 = 2 * v10;
    do
    {
      v62 = &v9[v61];
      v63 = *(v60 - 1);
      v64 = v9[v61];
      v65 = v9[v61 + 1];
      v66 = (float)(v64 * v63) - (float)(v65 * *v60);
      v67 = (float)(v63 * v65) + (float)(v64 * *v60);
      v68 = v9[1] - v67;
      *v62 = *v9 - v66;
      v62[1] = v68;
      v69 = v67 + v9[1];
      *v9 = v66 + *v9;
      v9[1] = v69;
      v9 += 2;
      v60 += 2 * a4;
      --v10;
    }
    while (v10);
  }
  else
  {
    v20 = v10;
    if (v73 == 4)
    {
      v21 = 2 * v10;
      v22 = v9 + 1;
      v23 = (float *)(*(_QWORD *)(a7 + 136) + 4);
      v24 = 4 * v10;
      v25 = *(_DWORD *)(a7 + 4);
      v26 = 6 * v10;
      v27 = v23;
      v28 = v23;
      do
      {
        v29 = &v22[v21];
        v30 = *(v23 - 1);
        v31 = v22[v21 - 1];
        v32 = v22[2 * v10];
        v33 = (float)(v31 * v30) - (float)(v32 * *v23);
        v34 = (float)(v30 * v32) + (float)(v31 * *v23);
        v35 = &v22[v24];
        v36 = *(v27 - 1);
        v37 = v22[v24 - 1];
        v38 = v22[4 * v10];
        v39 = (float)(v37 * v36) - (float)(v38 * *v27);
        v40 = (float)(v36 * v38) + (float)(v37 * *v27);
        v41 = &v22[v26];
        v42 = *(v28 - 1);
        v43 = v22[v26 - 1];
        v44 = v22[6 * v10];
        v45 = (float)(v43 * v42) - (float)(v44 * *v28);
        v46 = (float)(v42 * v44) + (float)(v43 * *v28);
        v47 = *(v22 - 1);
        v48 = v47 - v39;
        v49 = *v22 - v40;
        v50 = v39 + v47;
        v51 = v40 + *v22;
        *(v22 - 1) = v50;
        *v22 = v51;
        v52 = v34 + v46;
        v53 = v33 - v45;
        v54 = v34 - v46;
        *(v35 - 1) = v50 - (float)(v33 + v45);
        *v35 = v51 - v52;
        v55 = v52 + *v22;
        *(v22 - 1) = (float)(v33 + v45) + *(v22 - 1);
        *v22 = v55;
        if (v25)
        {
          v56 = v48 + v54;
          v57 = v49 - v53;
          v58 = v48 - v54;
          v59 = v49 + v53;
        }
        else
        {
          v58 = v48 + v54;
          v59 = v49 - v53;
          v56 = v48 - v54;
          v57 = v49 + v53;
        }
        v22[2 * v10] = v59;
        v22[6 * v10] = v57;
        v22 += 2;
        v28 += 6 * a4;
        *(v29 - 1) = v58;
        v27 += 4 * a4;
        v23 += 2 * a4;
        *(v41 - 1) = v56;
        --v20;
      }
      while (v20);
    }
    else
    {
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E2954548);
      v70 = off_1ECEDEE80;
      if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 67109120;
        v77 = v73;
        _os_log_impl(&dword_18F1DC000, v70, OS_LOG_TYPE_FAULT, "Error in FFT,p,%d", buf, 8u);
      }
      if (sub_18F1FCA08(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1ECEDEE88 != -1)
          dispatch_once(&qword_1ECEDEE88, &unk_1E2954548);
        v71 = (char *)_os_log_send_and_compose_impl();
        sub_18F419700("Generic", 1, 0, 0, "void kf_work(kiss_fft_cpx *, const CMQueue<scalar_32> &, int, const size_t, int, const int *, const kiss_fft_state *)", "CoreLocation: %s\n", v71);
        if (v71 != (char *)buf)
          free(v71);
      }
    }
  }
}

uint64_t sub_18F4E6234(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E294B868;
  a1[25] = &unk_1E294B8D0;
  v2 = a1 + 25;
  sub_18F1EA9E8(a1);
  sub_18F3D5D4C(a1 + 37);
  sub_18F352FB4(v2);
  return sub_18F4B2E54((uint64_t)a1);
}

uint64_t sub_18F4E6288(uint64_t a1)
{
  return sub_18F4E6234((_QWORD *)(a1 - 200));
}

void sub_18F4E6290(_QWORD *a1)
{
  sub_18F4E6234(a1);
  JUMPOUT(0x194001438);
}

void sub_18F4E62B4(uint64_t a1)
{
  sub_18F4E6234((_QWORD *)(a1 - 200));
  JUMPOUT(0x194001438);
}

void sub_18F4E62DC(uint64_t a1, float32x2_t *a2, float *a3)
{
  sub_18F1F57A8(a1 + 296, a2, a3);
}

uint64_t sub_18F4E62E4(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v5;

  v1 = *(_QWORD *)(a1 + 32);
  sub_18F209E74(v1 + 200, *(double *)(v1 + 24));
  if (!*(_QWORD *)(v1 + 288))
  {
    v2 = (_QWORD *)operator new();
    *v2 = off_1E294C238;
    *v2 = &off_1E294C820;
    v2[1] = 0;
    v2[2] = nullsub_6;
    v2[3] = v1;
    *(_QWORD *)(v1 + 288) = v2;
    v3 = sub_18F1EF73C();
    sub_18F1F4F0C(v3, 0, *(_QWORD *)(v1 + 288), 1.0);
  }
  sub_18F209F30(v1 + 200);
  v5 = 2;
  return sub_18F1E5858(v1, &v5);
}

void sub_18F4E63A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194001438](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

os_log_t sub_18F4E6CC8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "CyclingPower");
  qword_1EE16D930 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4E7278()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Core", "Notifier");
  qword_1EE16D440 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4E79AC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Core", "Notifier");
  qword_1EE16D440 = (uint64_t)result;
  return result;
}

uint64_t sub_18F4E7CE8()
{
  return 1;
}

void sub_18F4E7CF0(uint64_t a1, int a2, uint64_t a3)
{
  NSObject *v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned __int8 *v11;
  int v12;
  void (*v13)(uint64_t, uint64_t);
  int v14;
  NSObject *v15;
  char *v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  int v20;
  char *v21;
  char *v22;
  char *v23;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (qword_1ECEDEE88 != -1)
    dispatch_once(&qword_1ECEDEE88, &unk_1E29545E8);
  v6 = off_1ECEDEE80;
  if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
  {
    v7 = *(unsigned __int8 *)(a1 + 16);
    *(_DWORD *)buf = 67109376;
    v25 = v7;
    v26 = 1024;
    v27 = a2;
    _os_log_impl(&dword_18F1DC000, v6, OS_LOG_TYPE_DEBUG, "signal,from,%d,event,%d", buf, 0xEu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E29545E8);
    v21 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "void CMFiniteStateMachine::signal(uint8_t, const void *)", "CoreLocation: %s\n", v21);
    if (v21 != (char *)buf)
      free(v21);
  }
  v8 = *(_QWORD *)(a1 + 8);
  if (!v8)
  {
LABEL_23:
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E29545E8);
    v17 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v17, OS_LOG_TYPE_DEBUG, "no transition", buf, 2u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E29545E8);
      v22 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMFiniteStateMachine::signal(uint8_t, const void *)", "CoreLocation: %s\n", v22);
      if (v22 != (char *)buf)
        free(v22);
    }
    return;
  }
  v9 = 0;
  v10 = 0;
  while (1)
  {
    v11 = (unsigned __int8 *)(*(_QWORD *)a1 + v9);
    if (*v11 != *(unsigned __int8 *)(a1 + 16) || v11[1] != a2)
      goto LABEL_17;
    v12 = v11[2];
    v13 = (void (*)(uint64_t, uint64_t))*((_QWORD *)v11 + 2);
    v14 = (*((uint64_t (**)(uint64_t, uint64_t))v11 + 1))(a1, a3);
    if (qword_1ECEDEE88 != -1)
      dispatch_once(&qword_1ECEDEE88, &unk_1E29545E8);
    v15 = off_1ECEDEE80;
    if (os_log_type_enabled((os_log_t)off_1ECEDEE80, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109376;
      v25 = v10;
      v26 = 1024;
      v27 = v14;
      _os_log_impl(&dword_18F1DC000, v15, OS_LOG_TYPE_DEBUG, "guard check,arc,%d,passed,%d", buf, 0xEu);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1ECEDEE88 != -1)
        dispatch_once(&qword_1ECEDEE88, &unk_1E29545E8);
      v16 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMFiniteStateMachine::signal(uint8_t, const void *)", "CoreLocation: %s\n", v16);
      if (v16 != (char *)buf)
        free(v16);
    }
    if ((v14 & 1) != 0)
      break;
    v8 = *(_QWORD *)(a1 + 8);
LABEL_17:
    ++v10;
    v9 += 24;
    if (v8 <= v10)
      goto LABEL_23;
  }
  if (*(unsigned __int8 *)(a1 + 17) <= 1u && *(unsigned __int8 *)(a1 + 16) != v12)
  {
    if (qword_1EE16D8A8 != -1)
      dispatch_once(&qword_1EE16D8A8, &unk_1E2954828);
    v18 = qword_1EE16D8B0;
    if (os_log_type_enabled((os_log_t)qword_1EE16D8B0, OS_LOG_TYPE_DEFAULT))
    {
      v19 = *(unsigned __int8 *)(a1 + 17);
      v20 = *(unsigned __int8 *)(a1 + 16);
      *(_DWORD *)buf = 67109888;
      v25 = v19;
      v26 = 1024;
      v27 = a2;
      v28 = 1024;
      v29 = v20;
      v30 = 1024;
      v31 = v12;
      _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_DEFAULT, "[FSM] %u,event,%u,transition,from,%u,to,%u", buf, 0x1Au);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D8A8 != -1)
        dispatch_once(&qword_1EE16D8A8, &unk_1E2954828);
      v23 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "void CMFiniteStateMachine::signal(uint8_t, const void *)", "CoreLocation: %s\n", v23);
      if (v23 != (char *)buf)
        free(v23);
    }
  }
  *(_BYTE *)(a1 + 16) = v12;
  v13(a1, a3);
}

os_log_t sub_18F4E8384()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "FSM");
  qword_1EE16D8B0 = (uint64_t)result;
  return result;
}

void sub_18F4E8508(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  if (*(char *)(v2 - 49) < 0)
    operator delete(*(void **)(v2 - 72));
  MEMORY[0x194001438](v1, 0xB0C40BC2CC919);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4E8544(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t DictionaryOfClasses;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  v10 = objc_opt_class();
  v14 = (NSSet *)objc_msgSend_setWithObjects_(v4, v11, v5, v12, v13, v6, v7, v8, v9, v10, 0);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v14);
  else
    DictionaryOfClasses = 0;
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonEvent_, DictionaryOfClasses, v15, v16);
}

void sub_18F4E861C(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t ExecutablePathFromPid;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  pid_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  uint8_t buf[4];
  uint64_t v37;
  __int16 v38;
  pid_t v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v2 = getpid();
  ExecutablePathFromPid = objc_msgSend_getExecutablePathFromPid_(CMMotionUtils, v3, v2, v4, v5);
  if (ExecutablePathFromPid)
  {
    v11 = ExecutablePathFromPid;
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954608);
    v12 = qword_1EE16D880;
    if (os_log_type_enabled((os_log_t)qword_1EE16D880, OS_LOG_TYPE_DEFAULT))
    {
      v13 = getpid();
      v14 = *(_QWORD *)(a1 + 32);
      v15 = *(_QWORD *)(v14 + 72);
      *(_DWORD *)buf = 138413058;
      v37 = v11;
      v38 = 1024;
      v39 = v13;
      v40 = 2048;
      v41 = v15;
      v42 = 2048;
      v43 = v14;
      _os_log_impl(&dword_18F1DC000, v12, OS_LOG_TYPE_DEFAULT, "Workout, client connection interrupt, %@, %d, %ld, %p", buf, 0x26u);
    }
    if (sub_18F1FCA08(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D878 != -1)
        dispatch_once(&qword_1EE16D878, &unk_1E2954608);
      getpid();
      v35 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 2, "-[CMWorkoutManagerInternal init]_block_invoke", "CoreLocation: %s\n", v35);
      if (v35 != (char *)buf)
        free(v35);
    }
  }
  v16 = (void *)objc_msgSend_copy(*(void **)(*(_QWORD *)(a1 + 32) + 40), v7, v8, v9, v10);
  v22 = (void *)objc_msgSend_copy(*(void **)(*(_QWORD *)(a1 + 32) + 48), v17, v18, v19, v20);
  v23 = *(_QWORD *)(a1 + 32);
  v24 = *(_QWORD *)(v23 + 72);
  if (v24 == 2)
  {
    objc_msgSend__beginWorkoutSession_withWorkout_enableWorkoutChangeDetection_((void *)v23, v21, *(_QWORD *)(v23 + 56), (uint64_t)v16, *(unsigned __int8 *)(v23 + 64));
    if (v22 && objc_msgSend_type(v22, v31, v32, v33, v34) == 33)
      objc_msgSend__setCurrentWorkoutType_isManualTransition_(*(void **)(a1 + 32), v31, (uint64_t)v22, 1, v34);
    objc_msgSend__pauseWorkout_(*(void **)(a1 + 32), v31, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48), v33, v34);
  }
  else if (v24 == 1)
  {
    objc_msgSend__beginWorkoutSession_withWorkout_enableWorkoutChangeDetection_((void *)v23, v21, *(_QWORD *)(v23 + 56), (uint64_t)v16, *(unsigned __int8 *)(v23 + 64));
    if (v22)
    {
      if (objc_msgSend_type(v22, v25, v26, v27, v28) == 33)
        objc_msgSend__setCurrentWorkoutType_isManualTransition_(*(void **)(a1 + 32), v29, (uint64_t)v22, 1, v30);
    }
  }

}

void sub_18F4E89EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18F4E9204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4E9228(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DictionaryOfClasses;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
  else
    DictionaryOfClasses = 0;
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonResponse_, DictionaryOfClasses, v11, v12);
}

void sub_18F4E956C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_18F4E9924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  sub_18F2A8438((uint64_t)&a17);
  sub_18F2A8438((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4E9974(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DictionaryOfClasses;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
  else
    DictionaryOfClasses = 0;
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonResponse_, DictionaryOfClasses, v11, v12);
}

void sub_18F4EC484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  sub_18F2A8438((uint64_t)&a10);
  sub_18F2A8438((uint64_t)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4EC4C0(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  uint64_t DictionaryOfClasses;
  uint64_t v16;
  uint64_t v17;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  v10 = objc_opt_class();
  v14 = (NSSet *)objc_msgSend_setWithObjects_(v4, v11, v5, v12, v13, v6, v7, v8, v9, v10, 0);
  DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v14);
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonEvent_, DictionaryOfClasses, v16, v17);
}

void sub_18F4EC730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  sub_18F2A8438((uint64_t)&a10);
  sub_18F2A8438((uint64_t)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4EC76C(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  NSSet *v14;
  uint64_t DictionaryOfClasses;
  uint64_t v16;
  uint64_t v17;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  v10 = objc_opt_class();
  v14 = (NSSet *)objc_msgSend_setWithObjects_(v4, v11, v5, v12, v13, v6, v7, v8, v9, v10, 0);
  DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v14);
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonEvent_, DictionaryOfClasses, v16, v17);
}

void sub_18F4EC990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  va_list va;

  va_start(va, a6);
  sub_18F2A8438((uint64_t)va);
  sub_18F2A8438(v6 - 40);
  _Unwind_Resume(a1);
}

void *sub_18F4EC9AC(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  NSSet *v11;
  void *DictionaryOfClasses;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *result;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  NSObject *v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint8_t buf[4];
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v11 = (NSSet *)objc_msgSend_setWithObjects_(v4, v8, v5, v9, v10, v6, v7, 0);
  if (!*a2 || (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v11)) == 0)
  {
    if (qword_1EE16D6A0 != -1)
      dispatch_once(&qword_1EE16D6A0, &unk_1E2943B70);
    v40 = qword_1EE16D6A8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v40, OS_LOG_TYPE_ERROR, "Prompts needed response invalid.", buf, 2u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6A0 != -1)
        dispatch_once(&qword_1EE16D6A0, &unk_1E2943B70);
      v44 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMWorkoutManagerInternal _getPromptsNeededForWorkoutType:handler:]_block_invoke", "CoreLocation: %s\n", v44);
      if (v44 != (char *)buf)
        free(v44);
    }
    v35 = *(_QWORD *)(a1 + 32);
    v39 = objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], v41, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
    return (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v35 + 16))(v35, 0, v39);
  }
  v16 = DictionaryOfClasses;
  v17 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v13, (uint64_t)CFSTR("CMErrorMessage"), v14, v15);
  result = (void *)objc_msgSend_objectForKeyedSubscript_(v16, v18, (uint64_t)CFSTR("CMReturnCode"), v19, v20);
  if (v17)
  {
    if (qword_1EE16D6A0 != -1)
      dispatch_once(&qword_1EE16D6A0, &unk_1E2943B70);
    v26 = qword_1EE16D6A8;
    if (os_log_type_enabled((os_log_t)qword_1EE16D6A8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134349056;
      v51 = objc_msgSend_integerValue(v17, v27, v28, v29, v30);
      _os_log_impl(&dword_18F1DC000, v26, OS_LOG_TYPE_ERROR, "Querying for calibration prompts encountered an error: %{public}ld.", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D6A0 != -1)
        dispatch_once(&qword_1EE16D6A0, &unk_1E2943B70);
      objc_msgSend_integerValue(v17, v45, v46, v47, v48);
      v49 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMWorkoutManagerInternal _getPromptsNeededForWorkoutType:handler:]_block_invoke", "CoreLocation: %s\n", v49);
      if (v49 != (char *)buf)
        free(v49);
    }
    v35 = *(_QWORD *)(a1 + 32);
    v36 = (void *)MEMORY[0x1E0CB35C8];
    v37 = objc_msgSend_integerValue(v17, v31, v32, v33, v34);
    v39 = objc_msgSend_errorWithDomain_code_userInfo_(v36, v38, (uint64_t)CFSTR("CMErrorDomain"), v37, 0);
    return (void *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(v35 + 16))(v35, 0, v39);
  }
  if (result)
  {
    v42 = *(_QWORD *)(a1 + 32);
    v43 = objc_msgSend_unsignedIntegerValue(result, v22, v23, v24, v25);
    return (void *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(v42 + 16))(v42, v43, 0);
  }
  return result;
}

void sub_18F4ED250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  sub_18F2A8438((uint64_t)&a17);
  sub_18F2A8438((uint64_t)&a59);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4ED274(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DictionaryOfClasses;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
  else
    DictionaryOfClasses = 0;
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonResponse_, DictionaryOfClasses, v11, v12);
}

void sub_18F4ED698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_18F2A8438((uint64_t)&a16);
  sub_18F2A8438((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4ED6BC(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DictionaryOfClasses;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
  else
    DictionaryOfClasses = 0;
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonResponse_, DictionaryOfClasses, v11, v12);
}

void sub_18F4EDB00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_18F2A8438((uint64_t)&a16);
  sub_18F2A8438((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4EDB24(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DictionaryOfClasses;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
  else
    DictionaryOfClasses = 0;
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonResponse_, DictionaryOfClasses, v11, v12);
}

void sub_18F4EDEF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_18F2A8438((uint64_t)&a16);
  sub_18F2A8438((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4EDF1C(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DictionaryOfClasses;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
  else
    DictionaryOfClasses = 0;
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonResponse_, DictionaryOfClasses, v11, v12);
}

void sub_18F4EE2F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  sub_18F2A8438((uint64_t)&a16);
  sub_18F2A8438((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4EE314(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t DictionaryOfClasses;

  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2)
    DictionaryOfClasses = CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
  else
    DictionaryOfClasses = 0;
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__handleDaemonResponse_, DictionaryOfClasses, v11, v12);
}

void sub_18F4EE834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  sub_18F2A8438((uint64_t)&a17);
  sub_18F2A8438((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_18F4EE884(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  void *DictionaryOfClasses;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  const char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t (*v46)(void);
  uint64_t v48;
  NSObject *v49;
  char *v50;
  char *v51;
  uint8_t buf[4];
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v12 = (char *)objc_msgSend_setWithObjects_(v4, v9, v5, v10, v11, v6, v7, v8, 0);
  if (!*a2 || (DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, (NSSet *)v12)) == 0)
  {
    objc_msgSend_errorWithDomain_code_userInfo_(MEMORY[0x1E0CB35C8], v12, (uint64_t)CFSTR("CMErrorDomain"), 103, 0);
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954608);
    v45 = qword_1EE16D880;
    if (os_log_type_enabled((os_log_t)qword_1EE16D880, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18F1DC000, v45, OS_LOG_TYPE_ERROR, "[snapshot] error, nil event dictionary", buf, 2u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_17;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954608);
    goto LABEL_27;
  }
  v16 = DictionaryOfClasses;
  if (objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v12, (uint64_t)CFSTR("CMErrorMessage"), v14, v15))
  {
    v20 = (void *)MEMORY[0x1E0CB35C8];
    v21 = (void *)objc_msgSend_objectForKeyedSubscript_(v16, v17, (uint64_t)CFSTR("CMErrorMessage"), v18, v19);
    v26 = objc_msgSend_integerValue(v21, v22, v23, v24, v25);
    objc_msgSend_errorWithDomain_code_userInfo_(v20, v27, (uint64_t)CFSTR("CMErrorDomain"), v26, 0);
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954608);
    v28 = qword_1EE16D880;
    if (os_log_type_enabled((os_log_t)qword_1EE16D880, OS_LOG_TYPE_ERROR))
    {
      v32 = (void *)objc_msgSend_objectForKeyedSubscript_(v16, v29, (uint64_t)CFSTR("CMErrorMessage"), v30, v31);
      *(_DWORD *)buf = 67109120;
      LODWORD(v53) = objc_msgSend_intValue(v32, v33, v34, v35, v36);
      _os_log_impl(&dword_18F1DC000, v28, OS_LOG_TYPE_ERROR, "[snapshot] error, %d", buf, 8u);
    }
    if (!sub_18F1FCA08(115, 0))
      goto LABEL_17;
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954608);
    v40 = (void *)objc_msgSend_objectForKeyedSubscript_(v16, v37, (uint64_t)CFSTR("CMErrorMessage"), v38, v39);
    objc_msgSend_intValue(v40, v41, v42, v43, v44);
LABEL_27:
    v50 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 0, "-[CMWorkoutManagerInternal _snapshotWithCompletion:]_block_invoke", "CoreLocation: %s\n", v50);
    if (v50 != (char *)buf)
      free(v50);
LABEL_17:
    v46 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
    return v46();
  }
  v48 = objc_msgSend_objectForKeyedSubscript_(v16, v17, (uint64_t)CFSTR("CMWorkoutSnapshotData"), v18, v19);
  if (qword_1EE16D878 != -1)
    dispatch_once(&qword_1EE16D878, &unk_1E2954608);
  v49 = qword_1EE16D880;
  if (os_log_type_enabled((os_log_t)qword_1EE16D880, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    v53 = v48;
    _os_log_impl(&dword_18F1DC000, v49, OS_LOG_TYPE_INFO, "[snapshot] reporting workout snapshot %@", buf, 0xCu);
  }
  if (sub_18F1FCA08(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954608);
    v51 = (char *)_os_log_send_and_compose_impl();
    sub_18F419700("Generic", 1, 0, 2, "-[CMWorkoutManagerInternal _snapshotWithCompletion:]_block_invoke", "CoreLocation: %s\n", v51);
    if (v51 != (char *)buf)
      free(v51);
  }
  v46 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16);
  return v46();
}

void sub_18F4EF294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  sub_18F2A8438((uint64_t)&a16);
  sub_18F2A8438((uint64_t)&a29);
  _Unwind_Resume(a1);
}

void sub_18F4EF2B8(uint64_t a1, CLConnectionMessage **a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSSet *v10;
  uint64_t v11;
  uint64_t v12;
  void *DictionaryOfClasses;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  char *v38;
  uint8_t buf[4];
  uint64_t v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x1E0C99E60];
  v5 = objc_opt_class();
  v6 = objc_opt_class();
  v10 = (NSSet *)objc_msgSend_setWithObjects_(v4, v7, v5, v8, v9, v6, 0);
  if (*a2)
  {
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a2, v10);
    v17 = objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v14, (uint64_t)CFSTR("CMErrorMessage"), v15, v16);
  }
  else
  {
    DictionaryOfClasses = 0;
    v17 = objc_msgSend_objectForKeyedSubscript_(0, (const char *)v10, (uint64_t)CFSTR("CMErrorMessage"), v11, v12);
  }
  if (v17)
  {
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954608);
    v18 = qword_1EE16D880;
    if (os_log_type_enabled((os_log_t)qword_1EE16D880, OS_LOG_TYPE_ERROR))
    {
      v22 = *(_QWORD *)(a1 + 32);
      v23 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v19, (uint64_t)CFSTR("CMErrorMessage"), v20, v21);
      *(_DWORD *)buf = 134218240;
      v40 = v22;
      v41 = 1024;
      v42 = objc_msgSend_intValue(v23, v24, v25, v26, v27);
      _os_log_impl(&dword_18F1DC000, v18, OS_LOG_TYPE_ERROR, "Workout, reminder mute settings, error muting reminder for type, %ld, error, %d", buf, 0x12u);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D878 != -1)
        dispatch_once(&qword_1EE16D878, &unk_1E2954608);
      v31 = (void *)objc_msgSend_objectForKeyedSubscript_(DictionaryOfClasses, v28, (uint64_t)CFSTR("CMErrorMessage"), v29, v30);
      objc_msgSend_intValue(v31, v32, v33, v34, v35);
LABEL_21:
      v38 = (char *)_os_log_send_and_compose_impl();
      sub_18F419700("Generic", 1, 0, 0, "-[CMWorkoutManagerInternal _muteReminderType:mute:]_block_invoke", "CoreLocation: %s\n", v38);
      if (v38 != (char *)buf)
        free(v38);
    }
  }
  else
  {
    if (qword_1EE16D878 != -1)
      dispatch_once(&qword_1EE16D878, &unk_1E2954608);
    v36 = qword_1EE16D880;
    if (os_log_type_enabled((os_log_t)qword_1EE16D880, OS_LOG_TYPE_ERROR))
    {
      v37 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 134217984;
      v40 = v37;
      _os_log_impl(&dword_18F1DC000, v36, OS_LOG_TYPE_ERROR, "Workout, reminder mute settings, error (unspecified) muting reminder for type %ld", buf, 0xCu);
    }
    if (sub_18F1FCA08(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1EE16D878 != -1)
        dispatch_once(&qword_1EE16D878, &unk_1E2954608);
      goto LABEL_21;
    }
  }
}

uint64_t sub_18F4EFCBC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__teardown(*(void **)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_18F4EFD20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__registerForWorkoutEvents, a3, a4, a5);
}

uint64_t sub_18F4EFE34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__startWorkout_, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4EFEF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__stopWorkout_, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4F00A4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;

  v6 = objc_msgSend__internal(*(void **)(a1 + 32), a2, a3, a4, a5);
  return MEMORY[0x1E0DE7D20](v6, sel__getPromptsNeededForWorkoutType_handler_, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 40), v7);
}

uint64_t sub_18F4F0188(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__setSuggestedStopTimeout_, a3, a4, a5);
}

uint64_t sub_18F4F01F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__userDismissedWorkoutAlert, a3, a4, a5);
}

uint64_t sub_18F4F02B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__triggerWorkoutLocationUpdateForTesting_, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4F031C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__muteReminderType_mute_, *(_QWORD *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), a5);
}

uint64_t sub_18F4F0444(uint64_t a1, const char *a2)
{
  return objc_msgSend__beginWorkoutSession_withWorkout_enableWorkoutChangeDetection_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 56));
}

uint64_t sub_18F4F0514(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__setCurrentWorkoutType_isManualTransition_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), a5);
}

uint64_t sub_18F4F05D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__endWorkoutSession_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4F0698(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return objc_msgSend__pauseWorkout_(*(void **)(a1 + 32), a2, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4F0758(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(a1 + 32), sel__resumeWorkout_, *(_QWORD *)(a1 + 40), a4, a5);
}

uint64_t sub_18F4F07C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return MEMORY[0x1E0DE7D20](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), sel__snapshotWithCompletion_, *(_QWORD *)(a1 + 40), a4, a5);
}

os_log_t sub_18F4F07CC()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Workout");
  qword_1EE16D880 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4F07F8()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Calorimetry");
  qword_1EE16D6A8 = (uint64_t)result;
  return result;
}

os_log_t sub_18F4F0824()
{
  os_log_t result;

  result = os_log_create("com.apple.locationd.Motion", "Swimming");
  qword_1EE16D800 = (uint64_t)result;
  return result;
}

void sub_18F4F0850()
{
  __assert_rtn("setFlushTimeoutSeconds_block_invoke", "MSLWriter.cpp", 56, "(fFd == -1) && (\"Writer::setFlushTimeout() must be called before ::open().\")");
}

void sub_18F4F0878(uint64_t a1, _QWORD *a2, os_log_t log)
{
  int v3;
  _QWORD *v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (*(char *)(a1 + 39) < 0)
    a2 = (_QWORD *)*a2;
  v3 = 136446210;
  v4 = a2;
  _os_log_error_impl(&dword_18F1DC000, log, OS_LOG_TYPE_ERROR, "Unable to create directory at path: %{public}s", (uint8_t *)&v3, 0xCu);
}

uint64_t sub_18F4F08FC(os_log_t log)
{
  int v2;
  const char *v3;
  __int16 v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = 136315650;
  v3 = "assert";
  v4 = 2080;
  v5 = "fValid";
  v6 = 2080;
  v7 = "On call to writeItem client should check if the logger was opened";
  _os_log_fault_impl(&dword_18F1DC000, log, OS_LOG_TYPE_FAULT, "Event: %s\n Condition: %s\n Message: %s", (uint8_t *)&v2, 0x20u);
  if (qword_1EE16E700 == -1)
    return 1;
  dispatch_once(&qword_1EE16E700, &unk_1E2952C28);
  return 0;
}

uint64_t sub_18F4F09D0()
{
  return MEMORY[0x1E0DF2240]();
}

uint64_t sub_18F4F09DC()
{
  return MEMORY[0x1E0DF2248]();
}

uint64_t sub_18F4F09E8()
{
  return MEMORY[0x1E0DF2258]();
}

uint64_t sub_18F4F09F4()
{
  return MEMORY[0x1E0DEA5F8]();
}

uint64_t sub_18F4F0A00()
{
  return MEMORY[0x1E0DEA850]();
}

uint64_t sub_18F4F0A0C()
{
  return MEMORY[0x1E0CB1AE8]();
}

uint64_t sub_18F4F0A18()
{
  return MEMORY[0x1E0DF05B8]();
}

uint64_t sub_18F4F0A24()
{
  return MEMORY[0x1E0DF0A40]();
}

uint64_t sub_18F4F0A30()
{
  return MEMORY[0x1E0DF0A68]();
}

uint64_t sub_18F4F0A3C()
{
  return MEMORY[0x1E0DF0A70]();
}

uint64_t sub_18F4F0A48()
{
  return MEMORY[0x1E0DF0A88]();
}

uint64_t sub_18F4F0A54()
{
  return MEMORY[0x1E0DF0AA0]();
}

uint64_t sub_18F4F0A60()
{
  return MEMORY[0x1E0DF0AD8]();
}

uint64_t sub_18F4F0A6C()
{
  return MEMORY[0x1E0DF2270]();
}

uint64_t sub_18F4F0A78()
{
  return MEMORY[0x1E0DF2280]();
}

uint64_t sub_18F4F0A84()
{
  return MEMORY[0x1E0DF2290]();
}

uint64_t sub_18F4F0A90()
{
  return MEMORY[0x1E0DEBC20]();
}

uint64_t sub_18F4F0A9C()
{
  return MEMORY[0x1E0DEBC90]();
}

uint64_t sub_18F4F0AA8()
{
  return MEMORY[0x1E0DEC2B0]();
}

uint64_t sub_18F4F0AB4()
{
  return MEMORY[0x1E0DEC588]();
}

uint64_t sub_18F4F0AC0()
{
  return MEMORY[0x1E0DECBE0]();
}

uint64_t sub_18F4F0ACC()
{
  return MEMORY[0x1E0DECD18]();
}

uint64_t sub_18F4F0AD8()
{
  return MEMORY[0x1E0DECD70]();
}

uint64_t ADClientAddValueForScalarKey()
{
  return MEMORY[0x1E0CF6398]();
}

uint64_t ADClientPushValueForDistributionKey()
{
  return MEMORY[0x1E0CF63C0]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1E0D15430]();
}

void AudioServicesPlaySystemSound(SystemSoundID inSystemSoundID)
{
  MEMORY[0x1E0C92150](*(_QWORD *)&inSystemSoundID);
}

uint64_t BKSHIDServicesRequestEstimatedProximityEvents()
{
  return MEMORY[0x1E0D00B78]();
}

uint64_t BTAccessoryManagerAddCallbacks()
{
  return MEMORY[0x1E0D4E0F0]();
}

uint64_t BTAccessoryManagerDeregisterCustomMessageClient()
{
  return MEMORY[0x1E0D4E0F8]();
}

uint64_t BTAccessoryManagerGetAccessoryInfo()
{
  return MEMORY[0x1E0D4E108]();
}

uint64_t BTAccessoryManagerGetAdaptiveLatencyJitterBufferLevel()
{
  return MEMORY[0x1E0D4E110]();
}

uint64_t BTAccessoryManagerGetDefault()
{
  return MEMORY[0x1E0D4E130]();
}

uint64_t BTAccessoryManagerGetInEarDetectionEnable()
{
  return MEMORY[0x1E0D4E148]();
}

uint64_t BTAccessoryManagerGetInEarStatus()
{
  return MEMORY[0x1E0D4E150]();
}

uint64_t BTAccessoryManagerGetSpatialAudioPlatformSupport()
{
  return MEMORY[0x1E0D4E160]();
}

uint64_t BTAccessoryManagerGetTimeSyncId()
{
  return MEMORY[0x1E0D4E168]();
}

uint64_t BTAccessoryManagerRegisterCustomMessageClient()
{
  return MEMORY[0x1E0D4E170]();
}

uint64_t BTAccessoryManagerRemoteTimeSyncEnable()
{
  return MEMORY[0x1E0D4E178]();
}

uint64_t BTAccessoryManagerRemoveCallbacks()
{
  return MEMORY[0x1E0D4E180]();
}

uint64_t BTAccessoryManagerSensorStreamTimeSyncEnable()
{
  return MEMORY[0x1E0D4E190]();
}

uint64_t BTDeviceAddressFromString()
{
  return MEMORY[0x1E0D4E198]();
}

uint64_t BTDeviceFromAddress()
{
  return MEMORY[0x1E0D4E1D0]();
}

uint64_t BTDeviceGetDeviceId()
{
  return MEMORY[0x1E0D4E218]();
}

uint64_t BTSessionAttachWithQueue()
{
  return MEMORY[0x1E0D4E3B0]();
}

void BZ2_bzWrite(int *bzerror, BZFILE *b, void *buf, int len)
{
  MEMORY[0x1E0DE4168](bzerror, b, buf, *(_QWORD *)&len);
}

void BZ2_bzWriteClose(int *bzerror, BZFILE *b, int abandon, unsigned int *nbytes_in, unsigned int *nbytes_out)
{
  MEMORY[0x1E0DE4170](bzerror, b, *(_QWORD *)&abandon, nbytes_in, nbytes_out);
}

BZFILE *__cdecl BZ2_bzWriteOpen(int *bzerror, FILE *f, int blockSize100k, int verbosity, int workFactor)
{
  return (BZFILE *)MEMORY[0x1E0DE4178](bzerror, f, *(_QWORD *)&blockSize100k, *(_QWORD *)&verbosity, *(_QWORD *)&workFactor);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x1E0C97CE8](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x1E0C97D00](theArray, range.location, range.length, applier, context);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x1E0C97E90](arg);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1E0C980D0](allocator, bundleURL);
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0C98180](bundle, key);
}

uint64_t CFCopyHomeDirectoryURLForUser()
{
  return MEMORY[0x1E0C98368]();
}

uint64_t CFCopyUserName()
{
  return MEMORY[0x1E0C98388]();
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98538](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x1E0C985D8](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1E0C98660](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1E0C98670](err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

uint64_t CFGetUserName()
{
  return MEMORY[0x1E0C98740]();
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988D0]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  MEMORY[0x1E0C988E0](center, name, object, userInfo, deliverImmediately);
}

void CFNotificationCenterRemoveEveryObserver(CFNotificationCenterRef center, const void *observer)
{
  MEMORY[0x1E0C988F0](center, observer);
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x1E0C98900](center, observer, name, object);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1E0C989A8](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1E0C989D0](number);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)MEMORY[0x1E0C98A50](applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A60](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A70](key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetMultiple(CFDictionaryRef keysToSet, CFArrayRef keysToRemove, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  MEMORY[0x1E0C98A88](keysToSet, keysToRemove, applicationID, userName, hostName);
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  MEMORY[0x1E0C98A90](key, value, applicationID, userName, hostName);
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1E0C98A98](applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C98AA0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return MEMORY[0x1E0C98AF8](propertyList, stream, format, options, error);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BE8](rl, observer, mode);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BF8](rl, source, mode);
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C00](rl, timer, mode);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C30]();
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C40]();
}

CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context)
{
  return (CFRunLoopObserverRef)MEMORY[0x1E0C98C60](allocator, activities, repeats, order, callout, context);
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  MEMORY[0x1E0C98C80](rl, mode, block);
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C88](rl, observer, mode);
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C90](rl, source, mode);
}

void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98CA0](rl, timer, mode);
}

void CFRunLoopRun(void)
{
  MEMORY[0x1E0C98CA8]();
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0C98CC8](allocator, order, context);
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x1E0C98D08](allocator, flags, order, callout, context, fireDate, interval);
}

CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void *block)
{
  return (CFRunLoopTimerRef)MEMORY[0x1E0C98D10](allocator, flags, order, block, fireDate, interval);
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
  MEMORY[0x1E0C98D48](timer);
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
  MEMORY[0x1E0C98D58](timer, fireDate);
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D68](rl);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x1E0C98F68](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x1E0C99558](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1;
  uint64_t v2;
  CFUUIDBytes result;

  v1 = MEMORY[0x1E0C99568](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

SInt32 CFUserNotificationDisplayNotice(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle)
{
  return MEMORY[0x1E0C995D0](flags, iconURL, soundURL, localizationURL, alertHeader, alertMessage, defaultButtonTitle, timeout);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  MEMORY[0x1E0C99600](stream);
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  return (CFTypeRef)MEMORY[0x1E0C99610](stream, propertyName);
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  return (CFWriteStreamRef)MEMORY[0x1E0C99620](alloc, bufferAllocator);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1E0C99650](stream);
}

IOReturn IOAllowPowerChange(io_connect_t kernelPort, intptr_t notificationID)
{
  return MEMORY[0x1E0CBAD20](*(_QWORD *)&kernelPort, notificationID);
}

kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
{
  return MEMORY[0x1E0CBAE08](*(_QWORD *)&service, pluginType, interfaceType, theInterface, theScore);
}

IOReturn IODeregisterForSystemPower(io_object_t *notifier)
{
  return MEMORY[0x1E0CBAE38](notifier);
}

kern_return_t IODestroyPlugInInterface(IOCFPlugInInterface **interface)
{
  return MEMORY[0x1E0CBAE40](interface);
}

uint64_t IOHIDEventConformsTo()
{
  return MEMORY[0x1E0CBB010]();
}

uint64_t IOHIDEventGetChildren()
{
  return MEMORY[0x1E0CBB0F8]();
}

uint64_t IOHIDEventGetDataValue()
{
  return MEMORY[0x1E0CBB100]();
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x1E0CBB128]();
}

uint64_t IOHIDEventGetIntegerValue()
{
  return MEMORY[0x1E0CBB130]();
}

uint64_t IOHIDEventGetTimeStamp()
{
  return MEMORY[0x1E0CBB158]();
}

uint64_t IOHIDEventGetType()
{
  return MEMORY[0x1E0CBB168]();
}

uint64_t IOHIDEventGetVendorDefinedData()
{
  return MEMORY[0x1E0CBB178]();
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  return (CFArrayRef)MEMORY[0x1E0CBB1E8](client);
}

uint64_t IOHIDEventSystemClientCreateWithType()
{
  return MEMORY[0x1E0CBB1F8]();
}

uint64_t IOHIDEventSystemClientRegisterDeviceMatchingCallback()
{
  return MEMORY[0x1E0CBB210]();
}

uint64_t IOHIDEventSystemClientRegisterEventCallback()
{
  return MEMORY[0x1E0CBB220]();
}

uint64_t IOHIDEventSystemClientRegisterResetCallback()
{
  return MEMORY[0x1E0CBB240]();
}

uint64_t IOHIDEventSystemClientScheduleWithRunLoop()
{
  return MEMORY[0x1E0CBB250]();
}

uint64_t IOHIDEventSystemClientSetMatchingMultiple()
{
  return MEMORY[0x1E0CBB270]();
}

Boolean IOHIDEventSystemClientSetProperty(IOHIDEventSystemClientRef client, CFStringRef key, CFTypeRef property)
{
  return MEMORY[0x1E0CBB278](client, key, property);
}

uint64_t IOHIDEventSystemClientUnregisterDeviceMatchingCallback()
{
  return MEMORY[0x1E0CBB288]();
}

uint64_t IOHIDEventSystemClientUnregisterEventCallback()
{
  return MEMORY[0x1E0CBB298]();
}

uint64_t IOHIDEventSystemClientUnregisterResetCallback()
{
  return MEMORY[0x1E0CBB2B0]();
}

uint64_t IOHIDEventSystemClientUnscheduleWithRunLoop()
{
  return MEMORY[0x1E0CBB2C0]();
}

BOOLean_t IOHIDServiceClientConformsTo(IOHIDServiceClientRef service, uint32_t usagePage, uint32_t usage)
{
  return MEMORY[0x1E0CBB490](service, *(_QWORD *)&usagePage, *(_QWORD *)&usage);
}

uint64_t IOHIDServiceClientCopyEvent()
{
  return MEMORY[0x1E0CBB498]();
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0CBB4B0](service, key);
}

uint64_t IOHIDServiceClientFastPathCopyEventWithStatus()
{
  return MEMORY[0x1E0CBB4B8]();
}

uint64_t IOHIDServiceClientFastPathInit()
{
  return MEMORY[0x1E0CBB4C0]();
}

uint64_t IOHIDServiceClientFastPathInvalidate()
{
  return MEMORY[0x1E0CBB4C8]();
}

CFTypeRef IOHIDServiceClientGetRegistryID(IOHIDServiceClientRef service)
{
  return (CFTypeRef)MEMORY[0x1E0CBB4D0](service);
}

uint64_t IOHIDServiceClientRegisterRemovalCallback()
{
  return MEMORY[0x1E0CBB4E8]();
}

Boolean IOHIDServiceClientSetProperty(IOHIDServiceClientRef service, CFStringRef key, CFTypeRef property)
{
  return MEMORY[0x1E0CBB4F0](service, key, property);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x1E0CBB668](*(_QWORD *)&iterator);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x1E0CBB698](*(_QWORD *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  MEMORY[0x1E0CBB6A0](notify);
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0CBB6B0](notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  MEMORY[0x1E0CBB6B8](notify, queue);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1E0CBB6F0](*(_QWORD *)&object);
}

io_connect_t IORegisterForSystemPower(void *refcon, IONotificationPortRef *thePortRef, IOServiceInterestCallback callback, io_object_t *notifier)
{
  return MEMORY[0x1E0CBB8D8](refcon, thePortRef, callback, notifier);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB900](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return MEMORY[0x1E0CBB958](*(_QWORD *)&entry, plane, parent);
}

CFMutableDictionaryRef IORegistryEntryIDMatching(uint64_t entryID)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBB990](entryID);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB9A0](*(_QWORD *)&entry, plane, key, allocator, *(_QWORD *)&options);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x1E0CBB9C0](notifyPort, *(_QWORD *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x1E0CBB9C8](notifyPort, notificationType, matching, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x1E0CBB9D0](*(_QWORD *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x1E0CBB9E0](*(_QWORD *)&mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x1E0CBB9F0](*(_QWORD *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBBA00](name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBBA08](name);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1E0DE2B20]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1E0DE2B50]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1E0DE2B70]();
}

uint64_t MGIsDeviceOfType()
{
  return MEMORY[0x1E0DE2B88]();
}

uint64_t MGIsDeviceOneOfType()
{
  return MEMORY[0x1E0DE2B90]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

uint64_t NSPopAutoreleasePool()
{
  return MEMORY[0x1E0CB3038]();
}

uint64_t NSPushAutoreleasePool()
{
  return MEMORY[0x1E0CB3120]();
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1E0CB3200](aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x1E0CB3230](aSelector);
}

uint64_t PLLogTimeSensitiveRegisteredEvent()
{
  return MEMORY[0x1E0D7FE30]();
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1E0CD65F0](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1E0CD6610](allocator);
}

uint64_t TCCAccessPreflight()
{
  return MEMORY[0x1E0DB0FF0]();
}

uint64_t TCCAccessRequest()
{
  return MEMORY[0x1E0DB1018]();
}

uint64_t TCCAccessRestricted()
{
  return MEMORY[0x1E0DB1048]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x1E0C80940](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

uint64_t _CFCopyServerVersionDictionary()
{
  return MEMORY[0x1E0C9A0C0]();
}

uint64_t _CFCopySystemVersionDictionary()
{
  return MEMORY[0x1E0C9A0D0]();
}

uint64_t _CFGetProgname()
{
  return MEMORY[0x1E0C9A1C0]();
}

uint64_t _CFRunLoopSetPerCalloutAutoreleasepoolEnabled()
{
  return MEMORY[0x1E0C9A488]();
}

int _NSGetExecutablePath(char *buf, uint32_t *bufsize)
{
  return MEMORY[0x1E0C809D8](buf, bufsize);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

uint64_t CLConnectionClient::sendMessage()
{
  return MEMORY[0x1E0D44578]();
}

{
  return MEMORY[0x1E0D44580]();
}

uint64_t CLConnectionClient::sendMessageSync()
{
  return MEMORY[0x1E0D44588]();
}

uint64_t CLConnectionClient::setHandlerForMessage()
{
  return MEMORY[0x1E0D44590]();
}

uint64_t CLConnectionClient::setInterruptionHandler()
{
  return MEMORY[0x1E0D44598]();
}

uint64_t CLConnectionClient::setDefaultMessageHandler()
{
  return MEMORY[0x1E0D445A0]();
}

uint64_t CLConnectionClient::start(CLConnectionClient *this)
{
  return MEMORY[0x1E0D445B0](this);
}

uint64_t CLConnectionClient::CLConnectionClient()
{
  return MEMORY[0x1E0D445B8]();
}

void CLConnectionClient::~CLConnectionClient(CLConnectionClient *this)
{
  MEMORY[0x1E0D445C0](this);
}

uint64_t CLConnectionMessage::setFileDescriptor(CLConnectionMessage *this)
{
  return MEMORY[0x1E0D445C8](this);
}

uint64_t CLConnectionMessage::CLConnectionMessage()
{
  return MEMORY[0x1E0D445D0]();
}

{
  return MEMORY[0x1E0D445D8]();
}

void CLConnectionMessage::~CLConnectionMessage(CLConnectionMessage *this)
{
  MEMORY[0x1E0D445E0](this);
}

uint64_t PB::TextFormatter::beginObject(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x1E0D82EC0](this, a2);
}

uint64_t PB::TextFormatter::format()
{
  return MEMORY[0x1E0D82EC8]();
}

{
  return MEMORY[0x1E0D82ED0]();
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x1E0D82ED8](this, a2);
}

{
  return MEMORY[0x1E0D82EF0](this, a2);
}

{
  return MEMORY[0x1E0D82EF8](this, a2);
}

{
  return MEMORY[0x1E0D82F00](this, a2);
}

{
  return MEMORY[0x1E0D82F08](this, a2);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, double a3)
{
  return MEMORY[0x1E0D82EE0](this, a2, a3);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, float a3)
{
  return MEMORY[0x1E0D82EE8](this, a2, a3);
}

uint64_t PB::TextFormatter::endObject(PB::TextFormatter *this)
{
  return MEMORY[0x1E0D82F10](this);
}

void PB::Base::~Base(PB::Base *this)
{
  MEMORY[0x1E0D82F18](this);
}

uint64_t PB::Reader::recallMark()
{
  return MEMORY[0x1E0D82F38]();
}

uint64_t PB::Reader::read()
{
  return MEMORY[0x1E0D82F40]();
}

{
  return MEMORY[0x1E0D82F48]();
}

uint64_t PB::Reader::skip(PB::Reader *this)
{
  return MEMORY[0x1E0D82F58](this);
}

uint64_t PB::Reader::placeMark()
{
  return MEMORY[0x1E0D82F60]();
}

uint64_t PB::Reader::Reader(PB::Reader *this, const unsigned __int8 *a2)
{
  return MEMORY[0x1E0D82F68](this, a2);
}

uint64_t PB::Writer::writeVarInt(PB::Writer *this)
{
  return MEMORY[0x1E0D82F88](this);
}

{
  return MEMORY[0x1E0D82F90](this);
}

{
  return MEMORY[0x1E0D82F98](this);
}

{
  return MEMORY[0x1E0D82FA0](this);
}

uint64_t PB::Writer::writeSubmessage(PB::Writer *this, const PB::Base *a2)
{
  return MEMORY[0x1E0D82FA8](this, a2);
}

uint64_t PB::Writer::write()
{
  return MEMORY[0x1E0D82FB0]();
}

{
  return MEMORY[0x1E0D82FB8]();
}

uint64_t PB::Writer::write(PB::Writer *this)
{
  return MEMORY[0x1E0D82FC8](this);
}

uint64_t PB::Writer::write(PB::Writer *this, double a2)
{
  return MEMORY[0x1E0D82FD0](this, a2);
}

uint64_t PB::Writer::write(PB::Writer *this, float a2)
{
  return MEMORY[0x1E0D82FD8](this, a2);
}

uint64_t PB::Writer::writeSInt(PB::Writer *this)
{
  return MEMORY[0x1E0D82FE0](this);
}

{
  return MEMORY[0x1E0D82FE8](this);
}

uint64_t PB::Writer::Writer(PB::Writer *this)
{
  return MEMORY[0x1E0D82FF0](this);
}

void PB::Writer::~Writer(PB::Writer *this)
{
  MEMORY[0x1E0D82FF8](this);
}

uint64_t CLConnectionMessage::getDictionary(CLConnectionMessage *this)
{
  return MEMORY[0x1E0D445E8](this);
}

uint64_t CLConnectionMessage::getRawPayload(CLConnectionMessage *this)
{
  return MEMORY[0x1E0D445F0](this);
}

uint64_t CLConnectionMessage::getObjectOfClass(CLConnectionMessage *this, objc_class *a2)
{
  return MEMORY[0x1E0D445F8](this, a2);
}

uint64_t CLConnectionMessage::getObjectOfClasses(CLConnectionMessage *this, NSSet *a2)
{
  return MEMORY[0x1E0D44600](this, a2);
}

uint64_t CLConnectionMessage::getDictionaryOfClasses(CLConnectionMessage *this, NSSet *a2)
{
  return MEMORY[0x1E0D44608](this, a2);
}

uint64_t CLConnectionMessage::name(CLConnectionMessage *this)
{
  return MEMORY[0x1E0D44610](this);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x1E0DE41D8](this, __s);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1E0DE41F0]();
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x1E0DE4240](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

uint64_t std::time_put<char,std::ostreambuf_iterator<char>>::put()
{
  return MEMORY[0x1E0DE4268]();
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4288](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1E0DE4388](this);
}

std::regex_error *__cdecl std::regex_error::regex_error(std::regex_error *this, std::regex_constants::error_type __ecode)
{
  return (std::regex_error *)MEMORY[0x1E0DE43B0](this, *(_QWORD *)&__ecode);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4420](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1E0DE4428](this, __s, __n);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1E0DE4440](this, __s);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x1E0DE44B8](this, __c);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1E0DE44D8](this, __str);
}

std::string *__cdecl std::string::operator=(std::string *this, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x1E0DE44E0](this, __c);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1E0DE46C8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE46E8]();
}

{
  return MEMORY[0x1E0DE4738]();
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x1E0DE47C8](__s, __icase);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1E0DE48F8](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x1E0DE4910](retstr, __s);
}

void std::mutex::lock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA0](this);
}

void std::mutex::unlock(std::mutex *this)
{
  MEMORY[0x1E0DE4AA8](this);
}

uint64_t std::__sort<std::__less<double,double> &,double *>()
{
  return MEMORY[0x1E0DE4AE0]();
}

uint64_t std::__sort<std::__less<float,float> &,float *>()
{
  return MEMORY[0x1E0DE4AE8]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1E0DE4B48]();
}

time_t std::chrono::system_clock::to_time_t(const std::chrono::system_clock::time_point *__t)
{
  return MEMORY[0x1E0DE4B50](__t);
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1E0DE4B88](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1E0DE4B90](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x1E0DE4C50](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1E0DE4DD8](this);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E2942B88();
}

void operator delete(void *__p)
{
  off_1E2942B90(__p);
}

uint64_t operator delete()
{
  return off_1E2942B98();
}

uint64_t operator new[]()
{
  return off_1E2942BA0();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E2942BA8(__sz);
}

uint64_t operator new()
{
  return off_1E2942BB0();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1E0C80A98](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x1E0DE50A0](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x1E0DE50B0](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x1E0DE50D0]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x1E0DE50E0](lpsrc, lpstype, lpdtype, s2d);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

__double2 __sincos_stret(double a1)
{
  double v1;
  double v2;
  __double2 result;

  MEMORY[0x1E0C80BC8](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x1E0C80BD0](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

const mach_header *__cdecl _dyld_get_image_header(uint32_t image_index)
{
  return (const mach_header *)MEMORY[0x1E0C80E60](*(_QWORD *)&image_index);
}

const char *__cdecl _dyld_get_image_name(uint32_t image_index)
{
  return (const char *)MEMORY[0x1E0C80E68](*(_QWORD *)&image_index);
}

uint32_t _dyld_image_count(void)
{
  return MEMORY[0x1E0C80EB8]();
}

os_activity_t _os_activity_create(void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1E0C80FC0](dso, description, activity, *(_QWORD *)&flags);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1E0C81068]();
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C810D0](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

uint64_t abort_report_np()
{
  return MEMORY[0x1E0C813B0]();
}

float acosf(float a1)
{
  float result;

  MEMORY[0x1E0C81508](a1);
  return result;
}

uint32_t arc4random(void)
{
  return MEMORY[0x1E0C81570]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1E0C81588](*(_QWORD *)&__upper_bound);
}

long double asin(long double __x)
{
  long double result;

  MEMORY[0x1E0C81598](__x);
  return result;
}

float asinf(float a1)
{
  float result;

  MEMORY[0x1E0C815A0](a1);
  return result;
}

long double atan(long double __x)
{
  long double result;

  MEMORY[0x1E0C81618](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  long double result;

  MEMORY[0x1E0C81620](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C81628](a1, a2);
  return result;
}

float atanf(float a1)
{
  float result;

  MEMORY[0x1E0C81630](a1);
  return result;
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1E0C816B8](a1, *(_QWORD *)&a2);
}

char *__cdecl basename(char *a1)
{
  return (char *)MEMORY[0x1E0C816D8](a1);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

void clearerr(FILE *a1)
{
  MEMORY[0x1E0C82648](a1);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

long double cos(long double __x)
{
  long double result;

  MEMORY[0x1E0C82B40](__x);
  return result;
}

float cosf(float a1)
{
  float result;

  MEMORY[0x1E0C82B48](a1);
  return result;
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x1E0DE92C0](strm, *(_QWORD *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x1E0DE92D0](strm);
}

int deflateInit_(z_streamp strm, int level, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE92E0](strm, *(_QWORD *)&level, version, *(_QWORD *)&stream_size);
}

int deflateReset(z_streamp strm)
{
  return MEMORY[0x1E0DE92F8](strm);
}

void dispatch_activate(dispatch_object_t object)
{
  MEMORY[0x1E0C82BC0](object);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1E0C82C60](flags, block);
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82C98](block, timeout);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1E0C82CB0](buffer, size, queue, destructor);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x1E0C82D08](key);
}

void dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
{
  MEMORY[0x1E0C82D50](channel, barrier);
}

dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void *cleanup_handler)
{
  return (dispatch_io_t)MEMORY[0x1E0C82D60](type, *(_QWORD *)&fd, queue, cleanup_handler);
}

void dispatch_io_write(dispatch_io_t channel, off_t offset, dispatch_data_t data, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  MEMORY[0x1E0C82DA0](channel, offset, data, queue, io_handler);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  MEMORY[0x1E0C82E10](predicate, context, function);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E28](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  MEMORY[0x1E0C82E80](queue, key, context, destructor);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA8](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  MEMORY[0x1E0C82F08](object, queue);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1E0C83028](a1, a2);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

uint64_t espresso_context_destroy()
{
  return MEMORY[0x1E0D1FF18]();
}

uint64_t espresso_create_context()
{
  return MEMORY[0x1E0D1FF30]();
}

uint64_t espresso_create_plan()
{
  return MEMORY[0x1E0D1FF48]();
}

uint64_t espresso_network_bind_buffer()
{
  return MEMORY[0x1E0D1FFC0]();
}

uint64_t espresso_plan_add_network()
{
  return MEMORY[0x1E0D200B8]();
}

uint64_t espresso_plan_build()
{
  return MEMORY[0x1E0D200C0]();
}

uint64_t espresso_plan_destroy()
{
  return MEMORY[0x1E0D200F0]();
}

uint64_t espresso_plan_execute_sync()
{
  return MEMORY[0x1E0D200F8]();
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x1E0C83280](__x);
  return result;
}

float expf(float a1)
{
  float result;

  MEMORY[0x1E0C83298](a1);
  return result;
}

long double expm1(long double __x)
{
  long double result;

  MEMORY[0x1E0C832A0](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int feof(FILE *a1)
{
  return MEMORY[0x1E0C83340](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x1E0C83348](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

int fgetpos(FILE *a1, fpos_t *a2)
{
  return MEMORY[0x1E0C83398](a1, a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1E0C83488](*(_QWORD *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1E0C83490](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C834A0](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

int fsync(int a1)
{
  return MEMORY[0x1E0C83578](*(_QWORD *)&a1);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x1E0C83580](a1);
}

FILE *__cdecl funopen(const void *a1, int (__cdecl *a2)(void *, char *, int), int (__cdecl *a3)(void *, const char *, int), fpos_t (__cdecl *a4)(void *, fpos_t, int), int (__cdecl *a5)(void *))
{
  return (FILE *)MEMORY[0x1E0C835C8](a1, a2, a3, a4, a5);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

gid_t getgid(void)
{
  return MEMORY[0x1E0C83678]();
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

passwd *__cdecl getpwnam(const char *a1)
{
  return (passwd *)MEMORY[0x1E0C83790](a1);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1E0C83820](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1E0C83828]();
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x1E0DE93A0](strm, *(_QWORD *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x1E0DE93B8](strm);
}

int inflateInit_(z_streamp strm, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE93D0](strm, version, *(_QWORD *)&stream_size);
}

int inflateReset(z_streamp strm)
{
  return MEMORY[0x1E0DE93D8](strm);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

int lchmod(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C83B30](a1, a2);
}

int lchown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1E0C83B38](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1E0C83BA8](a1);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1E0C83C38](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C83C40](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x1E0C83C70]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1E0C83C80](*(_QWORD *)&error_value);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1E0C83EE0](ptr);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x1E0C840B8](__b, __pattern16, __len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C84160](a1, a2);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1E0C84220](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1E0C843E8](*(_QWORD *)&token, state64);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x1E0C84400](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7C38](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1E0DE7CD0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1E0DE7CE0](location, val);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1E0DE7D00](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)((uint64_t (*)(id, SEL))MEMORY[0x1E0DE7D20])(a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1E0DE7D50]();
}

uint64_t objc_opt_self()
{
  return MEMORY[0x1E0DE7D58]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E68](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1E0DE7E70](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F88](self, _cmd, newValue, offset);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F90](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F98](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7FA0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FB8](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1E0DE7FC8](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1E0DE7FD0](obj);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1E0C84488](a1, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
  MEMORY[0x1E0C84510](activity, state);
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
  MEMORY[0x1E0C84518](state);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1E0C84920](log);
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1E0C84970]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C84998](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

void perror(const char *a1)
{
  MEMORY[0x1E0C84AF0](a1);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C84BC0](a1, a2);
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1E0C84BC8](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1E0C84C50](*(_QWORD *)&pid, buffer, *(_QWORD *)&buffersize);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CC8](a1);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x1E0C84CE8](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1E0C84D50](a1, a2, a3, a4);
}

uint64_t pthread_dependency_fulfill_np()
{
  return MEMORY[0x1E0C84D60]();
}

uint64_t pthread_dependency_init_np()
{
  return MEMORY[0x1E0C84D68]();
}

uint64_t pthread_dependency_wait_np()
{
  return MEMORY[0x1E0C84D70]();
}

int pthread_getschedparam(pthread_t a1, int *a2, sched_param *a3)
{
  return MEMORY[0x1E0C84DB8](a1, a2, a3);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E40](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E48](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1E0C84E60](a1, *(_QWORD *)&a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1E0C84ED8]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1E0C84F08](a1);
}

int pthread_setschedparam(pthread_t a1, int a2, const sched_param *a3)
{
  return MEMORY[0x1E0C84F10](a1, *(_QWORD *)&a2, a3);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1E0C84F68](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

int rand(void)
{
  return MEMORY[0x1E0C84FB0]();
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x1E0C85100](__from, __to, __ec);
}

int sched_get_priority_max(int a1)
{
  return MEMORY[0x1E0C85260](*(_QWORD *)&a1);
}

int setvbuf(FILE *a1, char *a2, int a3, size_t a4)
{
  return MEMORY[0x1E0C85398](a1, a2, *(_QWORD *)&a3, a4);
}

long double sin(long double __x)
{
  long double result;

  MEMORY[0x1E0C85418](__x);
  return result;
}

float sinf(float a1)
{
  float result;

  MEMORY[0x1E0C85420](a1);
  return result;
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1E0C85438](*(_QWORD *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  return MEMORY[0x1E0C85448](a1, a2, a3, a4);
}

int sqlite3_close(sqlite3 *a1)
{
  return MEMORY[0x1E0DE8650](a1);
}

int sqlite3_close_v2(sqlite3 *a1)
{
  return MEMORY[0x1E0DE8658](a1);
}

double sqlite3_column_double(sqlite3_stmt *a1, int iCol)
{
  double result;

  MEMORY[0x1E0DE8688](a1, *(_QWORD *)&iCol);
  return result;
}

int sqlite3_column_int(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1E0DE8690](a1, *(_QWORD *)&iCol);
}

sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1E0DE8698](a1, *(_QWORD *)&iCol);
}

const unsigned __int8 *__cdecl sqlite3_column_text(sqlite3_stmt *a1, int iCol)
{
  return (const unsigned __int8 *)MEMORY[0x1E0DE86B8](a1, *(_QWORD *)&iCol);
}

const char *__cdecl sqlite3_errmsg(sqlite3 *a1)
{
  return (const char *)MEMORY[0x1E0DE8788](a1);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1E0DE87C8](pStmt);
}

int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs)
{
  return MEMORY[0x1E0DE8870](filename, ppDb, *(_QWORD *)&flags, zVfs);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return MEMORY[0x1E0DE8880](db, zSql, *(_QWORD *)&nByte, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1E0DE88B0](pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return MEMORY[0x1E0DE89A8](a1);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C85498](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B0](__dst, __src, __n);
}

uint64_t swift_allocObject()
{
  return MEMORY[0x1E0DEEAB0]();
}

uint64_t swift_arrayDestroy()
{
  return MEMORY[0x1E0DEEAD8]();
}

uint64_t swift_bridgeObjectRelease()
{
  return MEMORY[0x1E0DEEB08]();
}

uint64_t swift_bridgeObjectRelease_n()
{
  return MEMORY[0x1E0DEEB10]();
}

uint64_t swift_bridgeObjectRetain()
{
  return MEMORY[0x1E0DEEB18]();
}

uint64_t swift_bridgeObjectRetain_n()
{
  return MEMORY[0x1E0DEEB20]();
}

uint64_t swift_deallocObject()
{
  return MEMORY[0x1E0DEEB60]();
}

uint64_t swift_errorRelease()
{
  return MEMORY[0x1E0DEEBF0]();
}

uint64_t swift_errorRetain()
{
  return MEMORY[0x1E0DEEBF8]();
}

uint64_t swift_getEnumTagSinglePayloadGeneric()
{
  return MEMORY[0x1E0DEEC48]();
}

uint64_t swift_getObjCClassMetadata()
{
  return MEMORY[0x1E0DEECD8]();
}

uint64_t swift_getObjectType()
{
  return MEMORY[0x1E0DEECE0]();
}

uint64_t swift_getSingletonMetadata()
{
  return MEMORY[0x1E0DEECF8]();
}

uint64_t swift_getTypeByMangledNameInContext2()
{
  return MEMORY[0x1E0DEED38]();
}

uint64_t swift_getTypeByMangledNameInContextInMetadataState2()
{
  return MEMORY[0x1E0DEED40]();
}

uint64_t swift_getWitnessTable()
{
  return MEMORY[0x1E0DEED50]();
}

uint64_t swift_initStructMetadata()
{
  return MEMORY[0x1E0DEED88]();
}

uint64_t swift_isUniquelyReferenced_nonNull_native()
{
  return MEMORY[0x1E0DEEDD0]();
}

uint64_t swift_once()
{
  return MEMORY[0x1E0DEEE00]();
}

uint64_t swift_release()
{
  return MEMORY[0x1E0DEEE30]();
}

uint64_t swift_retain()
{
  return MEMORY[0x1E0DEEE48]();
}

uint64_t swift_slowAlloc()
{
  return MEMORY[0x1E0DEEE78]();
}

uint64_t swift_slowDealloc()
{
  return MEMORY[0x1E0DEEE80]();
}

uint64_t swift_storeEnumTagSinglePayloadGeneric()
{
  return MEMORY[0x1E0DEEEA0]();
}

uint64_t swift_task_alloc()
{
  return MEMORY[0x1E0DF1000]();
}

uint64_t swift_task_dealloc()
{
  return MEMORY[0x1E0DF1010]();
}

uint64_t swift_task_switch()
{
  return MEMORY[0x1E0DF1050]();
}

uint64_t swift_unknownObjectRetain()
{
  return MEMORY[0x1E0DEEED0]();
}

uint64_t swift_willThrowTypedImpl()
{
  return MEMORY[0x1E0DEEFC8]();
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1E0C857A0](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x1E0C857D0](*(_QWORD *)&a1, a2);
}

long double tan(long double __x)
{
  long double result;

  MEMORY[0x1E0C857E8](__x);
  return result;
}

int unlink(const char *a1)
{
  return MEMORY[0x1E0C859B8](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1E0C859E0](*(_QWORD *)&a1);
}

void uuid_clear(uuid_t uu)
{
  MEMORY[0x1E0C85A00](uu);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
  MEMORY[0x1E0C85A10](dst, src);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x1E0C85A38](in, uu);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1E0C85B98](__str, __size, __format, a4);
}

const xmlChar *__cdecl xmlBufferContent(const xmlBuffer *buf)
{
  return (const xmlChar *)MEMORY[0x1E0DE8C78](buf);
}

xmlBufferPtr xmlBufferCreate(void)
{
  return (xmlBufferPtr)MEMORY[0x1E0DE8C80]();
}

void xmlBufferFree(xmlBufferPtr buf)
{
  MEMORY[0x1E0DE8C88](buf);
}

int xmlBufferLength(const xmlBuffer *buf)
{
  return MEMORY[0x1E0DE8C90](buf);
}

void xmlFreeTextWriter(xmlTextWriterPtr writer)
{
  MEMORY[0x1E0DE8D60](writer);
}

xmlTextWriterPtr xmlNewTextWriterMemory(xmlBufferPtr buf, int compression)
{
  return (xmlTextWriterPtr)MEMORY[0x1E0DE8E48](buf, *(_QWORD *)&compression);
}

int xmlTextWriterFlush(xmlTextWriterPtr writer)
{
  return MEMORY[0x1E0DE90D8](writer);
}

int xmlTextWriterWriteBase64(xmlTextWriterPtr writer, const char *data, int start, int len)
{
  return MEMORY[0x1E0DE9110](writer, data, *(_QWORD *)&start, *(_QWORD *)&len);
}

void xpc_connection_activate(xpc_connection_t connection)
{
  MEMORY[0x1E0C85F50](connection);
}

void xpc_connection_cancel(xpc_connection_t connection)
{
  MEMORY[0x1E0C85F68](connection);
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1E0C85F90](name, targetq);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FA0](endpoint);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FB0](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x1E0C86018](connection);
}

void xpc_connection_send_barrier(xpc_connection_t connection, dispatch_block_t barrier)
{
  MEMORY[0x1E0C86020](connection, barrier);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x1E0C86030](connection, message);
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
  MEMORY[0x1E0C86038](connection, message, replyq, handler);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x1E0C86080](connection, handler);
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
  MEMORY[0x1E0C860C8](connection, targetq);
}

void xpc_connection_suspend(xpc_connection_t connection)
{
  MEMORY[0x1E0C860E0](connection);
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1E0C86178](bytes, length);
}

size_t xpc_data_get_bytes(xpc_object_t xdata, void *buffer, size_t off, size_t length)
{
  return MEMORY[0x1E0C86190](xdata, buffer, off, length);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1E0C86198](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1E0C861A8](xdata);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1E0C86228](original);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1E0C862C8](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C862E0](xdict, key);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
  MEMORY[0x1E0C86330](xdict, key, bytes, length);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x1E0C863B8](xdict, key, value);
}

xpc_endpoint_t xpc_endpoint_create(xpc_connection_t connection)
{
  return (xpc_endpoint_t)MEMORY[0x1E0C863F0](connection);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

xpc_object_t xpc_string_create(const char *string)
{
  return (xpc_object_t)MEMORY[0x1E0C86720](string);
}

