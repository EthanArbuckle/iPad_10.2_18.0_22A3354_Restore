void sub_180DF8664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DF867C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

BOOL std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    if (v4 != *((unsigned __int8 *)a1 + 23))
      return 0;
    return memcmp(a1, __s, v4) == 0;
  }
  if (v4 == a1[1])
  {
    if (v4 == -1)
      std::string::__throw_out_of_range[abi:ne180100]();
    a1 = (_QWORD *)*a1;
    return memcmp(a1, __s, v4) == 0;
  }
  return 0;
}

uint64_t mlir::OpBuilder::create<mlir::mps::PadOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::PaddingMode>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  _QWORD v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad", (const unsigned __int8 *)7, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.pad";
    v25[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::PadOp::build(a1, (uint64_t)v28, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::PadOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PadOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180DF88B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DF88C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void **std::vector<std::string>::~vector[abi:ne180100](void **a1)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = (void **)*a1;
  if (*a1)
  {
    v3 = (void **)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0)
          operator delete(*(v3 - 3));
        v3 -= 3;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t MILToMLIR::CropPattern::matchAndRewrite(MILToMLIR::CropPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void **v7;
  const void ***v8;
  const void **v9;
  const void ***v10;
  BOOL v11;
  char *v12;
  char **v13;
  char *v14;
  char *v15;
  char **v16;
  char *v17;
  char *v18;
  unint64_t v19;
  int v20;
  char *v21;
  size_t v22;
  _BOOL4 v23;
  int v24;
  char **v25;
  char *v26;
  _QWORD *v27;
  unint64_t v28;
  int v29;
  unint64_t v30;
  char *v31;
  char *v32;
  size_t v33;
  _BOOL4 v34;
  int v35;
  _BOOL4 v36;
  uint64_t v37;
  _QWORD *v39;
  char **v40;
  char *v41;
  char **v42;
  char *v43;
  unint64_t v44;
  int v45;
  const void *v46;
  size_t v47;
  _BOOL4 v48;
  int v49;
  _BOOL4 v50;
  char **v51;
  char *v52;
  _QWORD *v53;
  unint64_t v54;
  int v55;
  unint64_t v56;
  char *v57;
  char *v58;
  size_t v59;
  _BOOL4 v60;
  int v61;
  _BOOL4 v62;
  _QWORD *v63;
  uint64_t ParameterValue;
  uint64_t Data;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t Context;
  uint64_t v73;
  uint64_t **v74;
  uint64_t InterfaceFor;
  const char *v76;
  int v77;
  const char *v78;
  const char *v79;
  uint64_t v80;
  mlir::GenericProgramPoint *v81;
  uint64_t v82;
  const char *v83;
  int v84;
  const char *v85;
  const char *v86;
  uint64_t v87;
  mlir::GenericProgramPoint *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void *v93;
  const char *v94;
  int v95;
  const char *v96;
  const char *v97;
  const char *v98;
  int v99;
  const char *v100;
  const char *v101;
  mlir::OpBuilder *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  _BYTE __s2[24];
  char **v108;
  char *v109[2];
  uint64_t ArgValue;
  uint64_t v111;
  _QWORD v112[2];

  v112[1] = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v111 = 0;
  v112[0] = 0;
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v109[0] = 0;
  v109[1] = 0;
  v108 = v109;
  v8 = v6 + 1;
  v7 = *v6;
  if (*v6 == (const void **)(v6 + 1))
    goto LABEL_46;
  v102 = (mlir::OpBuilder *)(a3 + 13);
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v108, (uint64_t *)v109, v7 + 4, (uint64_t)(v7 + 4));
    v9 = (const void **)v7[1];
    if (v9)
    {
      do
      {
        v10 = (const void ***)v9;
        v9 = (const void **)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        v10 = (const void ***)v7[2];
        v11 = *v10 == v7;
        v7 = (const void **)v10;
      }
      while (!v11);
    }
    v7 = (const void **)v10;
  }
  while (v10 != v8);
  v103 = LocationForOp;
  v12 = v109[0];
  __s2[23] = 11;
  strcpy(__s2, "crop_height");
  if (!v109[0])
    goto LABEL_46;
  v13 = v109;
  v14 = v109[0];
  do
  {
    v15 = v14;
    v16 = v13;
    v18 = v14 + 32;
    v17 = (char *)*((_QWORD *)v14 + 4);
    v19 = v14[55];
    v20 = (char)v19;
    if ((v19 & 0x80u) != 0)
      v19 = *((_QWORD *)v15 + 5);
    if (v20 >= 0)
      v21 = v18;
    else
      v21 = v17;
    if (v19 >= 0xB)
      v22 = 11;
    else
      v22 = v19;
    v23 = v19 < 0xB;
    v24 = memcmp(v21, __s2, v22);
    if (v24)
      v23 = v24 < 0;
    if (v23)
      v25 = (char **)(v15 + 8);
    else
      v25 = (char **)v15;
    if (v23)
      v13 = v16;
    else
      v13 = (char **)v15;
    v14 = *v25;
  }
  while (v14);
  if (v13 == v109)
    goto LABEL_46;
  v26 = (char *)(v16 + 4);
  if (v23)
    v27 = v16;
  else
    v27 = v15;
  if (!v23)
    v26 = v18;
  v28 = *((unsigned __int8 *)v13 + 55);
  v29 = (char)v28;
  v31 = (char *)v27[4];
  v30 = v27[5];
  if ((v28 & 0x80u) != 0)
    v28 = v30;
  if (v29 >= 0)
    v32 = v26;
  else
    v32 = v31;
  if (v28 >= 0xB)
    v33 = 11;
  else
    v33 = v28;
  v34 = v28 > 0xB;
  v35 = memcmp(__s2, v32, v33);
  v36 = v35 < 0;
  if (!v35)
    v36 = v34;
  if (v36)
  {
LABEL_46:
    *(_QWORD *)__s2 = operator new(0x38uLL);
    *(_OWORD *)&__s2[8] = xmmword_181286A70;
    strcpy(*(char **)__s2, "Could not find parameter with name 'crop_height'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
LABEL_47:
    if ((__s2[23] & 0x80000000) != 0)
      operator delete(*(void **)__s2);
    v37 = 0;
    goto LABEL_50;
  }
  if (v23)
    v39 = v16;
  else
    v39 = v15;
  if (v39[8] - v39[7] != 16)
  {
    *(_QWORD *)__s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181286A60;
    strcpy(*(char **)__s2, "Unexpected argument size for 'crop_height'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  __s2[23] = 10;
  strcpy(__s2, "crop_width");
  v40 = v109;
  do
  {
    v41 = v12;
    v42 = v40;
    v43 = v12 + 32;
    v44 = v12[55];
    v45 = (char)v44;
    if ((v44 & 0x80u) != 0)
      v44 = *((_QWORD *)v12 + 5);
    if (v45 >= 0)
      v46 = v12 + 32;
    else
      v46 = (const void *)*((_QWORD *)v12 + 4);
    if (v44 >= 0xA)
      v47 = 10;
    else
      v47 = v44;
    v48 = v44 < 0xA;
    v49 = memcmp(v46, __s2, v47);
    if (v49)
      v50 = v49 < 0;
    else
      v50 = v48;
    if (v50)
      v51 = (char **)(v41 + 8);
    else
      v51 = (char **)v41;
    if (v50)
      v40 = v42;
    else
      v40 = (char **)v41;
    v12 = *v51;
  }
  while (*v51);
  if (v40 == v109)
    goto LABEL_91;
  v52 = (char *)(v42 + 4);
  if (v50)
    v53 = v42;
  else
    v53 = v41;
  if (!v50)
    v52 = v43;
  v54 = *((unsigned __int8 *)v40 + 55);
  v55 = (char)v54;
  v57 = (char *)v53[4];
  v56 = v53[5];
  if ((v54 & 0x80u) != 0)
    v54 = v56;
  if (v55 >= 0)
    v58 = v52;
  else
    v58 = v57;
  if (v54 >= 0xA)
    v59 = 10;
  else
    v59 = v54;
  v60 = v54 > 0xA;
  v61 = memcmp(__s2, v58, v59);
  v62 = v61 < 0;
  if (!v61)
    v62 = v60;
  if (v62)
  {
LABEL_91:
    *(_QWORD *)__s2 = operator new(0x38uLL);
    *(_OWORD *)&__s2[8] = xmmword_1812674A0;
    strcpy(*(char **)__s2, "Could not find parameter with name 'crop_width'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  if (v50)
    v63 = v42;
  else
    v63 = v41;
  if (v63[8] - v63[7] != 16)
  {
    *(_QWORD *)__s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_1812674D0;
    strcpy(*(char **)__s2, "Unexpected argument size for 'crop_width'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  __s2[23] = 11;
  strcpy(__s2, "crop_height");
  ParameterValue = MIL::IROperation::TryGetParameterValue();
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  (*(void (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
  Data = MIL::IRTensorValue::GetDataView<int>();
  if (v66 != 2)
  {
    *(_QWORD *)__s2 = operator new(0x28uLL);
    *(_OWORD *)&__s2[8] = xmmword_181268740;
    strcpy(*(char **)__s2, "Unexpected length for 'crop_height'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  v67 = Data;
  __s2[23] = 10;
  strcpy(__s2, "crop_width");
  v68 = MIL::IROperation::TryGetParameterValue();
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  (*(void (**)(uint64_t))(*(_QWORD *)v68 + 40))(v68);
  v69 = MIL::IRTensorValue::GetDataView<int>();
  if (v70 != 2)
  {
    std::string::basic_string[abi:ne180100]<0>(__s2, "Unexpected length for 'crop_width'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_47;
  }
  v71 = v69;
  LODWORD(v112[0]) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v69, 2uLL, 0);
  HIDWORD(v112[0]) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v67, 2uLL, 0);
  LODWORD(v111) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v71, 2uLL, 1uLL);
  HIDWORD(v111) = *(_DWORD *)MIL::Util::Span<int const,18446744073709551615ul>::operator[](v67, 2uLL, 1uLL);
  *(_QWORD *)__s2 = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  Context = mlir::Attribute::getContext((mlir::Attribute *)__s2);
  v73 = mlir::IntegerType::get(Context, 0x20u, 1u);
  v74 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v73, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74))
  {
    v76 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v77 = 566;
    v78 = "Casting.h";
    v79 = "cast";
LABEL_132:
    __assert_rtn(v79, v78, v77, v76);
  }
  if (v74)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74);
    if (!InterfaceFor)
    {
      v76 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v77 = 98;
      v78 = "InterfaceSupport.h";
      v79 = "Interface";
      goto LABEL_132;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  LODWORD(v105) = -1;
  v80 = mlir::DenseElementsAttr::getFromRawBuffer(v74, InterfaceFor, &v105, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof(v80))
  {
    v94 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v95 = 566;
    v96 = "Casting.h";
    v97 = "cast";
    goto LABEL_135;
  }
  *(_QWORD *)__s2 = v80;
  v81 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v102, v103, (uint64_t **)__s2);
  if (!*((_DWORD *)v81 + 9))
  {
    v94 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v95 = 984;
    v96 = "Operation.h";
    v97 = "getOpResultImpl";
LABEL_135:
    __assert_rtn(v97, v96, v95, v94);
  }
  v106 = (uint64_t)v81 - 16;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74))
  {
    v83 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v84 = 566;
    v85 = "Casting.h";
    v86 = "cast";
LABEL_137:
    __assert_rtn(v86, v85, v84, v83);
  }
  if (v74)
  {
    v82 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74);
    if (!v82)
    {
      v83 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v84 = 98;
      v85 = "InterfaceSupport.h";
      v86 = "Interface";
      goto LABEL_137;
    }
  }
  else
  {
    v82 = 0;
  }
  LODWORD(v104) = -2;
  v87 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v82, &v104, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof(v87))
  {
    v98 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v99 = 566;
    v100 = "Casting.h";
    v101 = "cast";
    goto LABEL_140;
  }
  *(_QWORD *)__s2 = v87;
  v88 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v102, v103, (uint64_t **)__s2);
  if (!*((_DWORD *)v88 + 9))
  {
    v98 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v99 = 984;
    v100 = "Operation.h";
    v101 = "getOpResultImpl";
LABEL_140:
    __assert_rtn(v101, v100, v99, v98);
  }
  v105 = (uint64_t)v88 - 16;
  v89 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,int &,int &>(v102, v103, &ArgValue, &v106, (unsigned int *)v112, (unsigned int *)&v111);
  if (!*(_DWORD *)(v89 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v104 = v89 - 16;
  v90 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,int &,int &>(v102, v103, &v104, &v105, (unsigned int *)v112 + 1, (unsigned int *)&v111 + 1);
  if (!*(_DWORD *)(v90 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  (*(void (**)(_BYTE *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__s2, a2);
  MILToMLIRRewriter::setValue((uint64_t)a3, *(__int128 **)__s2, v90 - 16);
  v91 = *(_QWORD *)__s2;
  if (*(_QWORD *)__s2)
  {
    v92 = *(_QWORD *)&__s2[8];
    v93 = *(void **)__s2;
    if (*(_QWORD *)&__s2[8] != *(_QWORD *)__s2)
    {
      do
      {
        if (*(char *)(v92 - 1) < 0)
          operator delete(*(void **)(v92 - 24));
        v92 -= 24;
      }
      while (v92 != v91);
      v93 = *(void **)__s2;
    }
    *(_QWORD *)&__s2[8] = v91;
    operator delete(v93);
  }
  v37 = 1;
LABEL_50:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v108, v109[0]);
  return v37;
}

void sub_180DF92A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char a18, char *a19)
{
  std::vector<std::string>::~vector[abi:ne180100](&a15);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a18, a19);
  _Unwind_Resume(a1);
}

void sub_180DF92C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,char *a22)
{
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a21, a22);
  _Unwind_Resume(a1);
}

uint64_t mlir::DenseIntElementsAttr::get<int>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = mlir::DenseElementsAttr::getFromRawBuffer(a1, a2, a3, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v3) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  return v3;
}

uint64_t mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,int &,int &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  uint64_t v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.crop";
    v25[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::CropOp::build(a1, v28, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::CropOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180DF9558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DF9570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::UpsampleBilinearPattern::matchAndRewrite(MILToMLIR::UpsampleBilinearPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void **v7;
  const void ***v8;
  const void **v9;
  const void ***v10;
  BOOL v11;
  char *v12;
  char **v13;
  char *v14;
  char **v15;
  char *v16;
  char *v17;
  unint64_t v18;
  int v19;
  char *v20;
  size_t v21;
  _BOOL4 v22;
  int v23;
  char **v24;
  char *v25;
  _QWORD *v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  char *v30;
  char *v31;
  size_t v32;
  _BOOL4 v33;
  int v34;
  _BOOL4 v35;
  uint64_t v36;
  _QWORD *v38;
  MIL::IRValueType *ParameterType;
  uint64_t v40;
  _QWORD *v41;
  unint64_t v42;
  mlir::GenericProgramPoint *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t Context;
  uint64_t v47;
  uint64_t **v48;
  uint64_t InterfaceFor;
  const char *v50;
  int v51;
  const char *v52;
  const char *v53;
  uint64_t v54;
  mlir::GenericProgramPoint *v55;
  uint64_t v56;
  uint64_t ParameterValue;
  float *v58;
  float v59;
  int *v60;
  MIL::Fp16 *v61;
  float v62;
  uint64_t v63;
  float *v64;
  float v65;
  int *v66;
  MIL::Fp16 *v67;
  float v68;
  mlir::Float32Type *v69;
  mlir::MLIRContext *v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  const char *v76;
  int v77;
  const char *v78;
  const char *v79;
  mlir::OpBuilder *v80;
  uint64_t v81;
  unsigned __int8 v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t ConstantOpFromScalar;
  uint64_t v94;
  unsigned int v95;
  unsigned int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  unsigned int v101;
  uint64_t v102;
  _BYTE __s2[24];
  char **v104;
  char *v105[2];
  char v106;
  uint64_t ArgValue;
  void *v108[2];
  uint64_t v109;
  uint64_t v110;

  v110 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v105[1] = 0;
  v105[0] = 0;
  v104 = v105;
  v8 = v6 + 1;
  v7 = *v6;
  if (*v6 == (const void **)(v6 + 1))
    goto LABEL_43;
  v106 = 0;
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v104, (uint64_t *)v105, v7 + 4, (uint64_t)(v7 + 4));
    v9 = (const void **)v7[1];
    if (v9)
    {
      do
      {
        v10 = (const void ***)v9;
        v9 = (const void **)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        v10 = (const void ***)v7[2];
        v11 = *v10 == v7;
        v7 = (const void **)v10;
      }
      while (!v11);
    }
    v7 = (const void **)v10;
  }
  while (v10 != v8);
  v80 = (mlir::OpBuilder *)(a3 + 13);
  v81 = LocationForOp;
  v12 = v105[0];
  __s2[23] = 13;
  strcpy(__s2, "align_corners");
  if (!v105[0])
    goto LABEL_43;
  v13 = v105;
  do
  {
    v14 = v12;
    v15 = v13;
    v17 = v12 + 32;
    v16 = (char *)*((_QWORD *)v12 + 4);
    v18 = v14[55];
    v19 = (char)v18;
    if ((v18 & 0x80u) != 0)
      v18 = *((_QWORD *)v14 + 5);
    if (v19 >= 0)
      v20 = v17;
    else
      v20 = v16;
    if (v18 >= 0xD)
      v21 = 13;
    else
      v21 = v18;
    v22 = v18 < 0xD;
    v23 = memcmp(v20, __s2, v21);
    if (v23)
      v22 = v23 < 0;
    v24 = (char **)(v14 + 8);
    if (v22)
    {
      v13 = v15;
    }
    else
    {
      v24 = (char **)v14;
      v13 = (char **)v14;
    }
    v12 = *v24;
  }
  while (v12);
  if (v13 == v105)
    goto LABEL_43;
  v25 = (char *)(v15 + 4);
  if (v22)
    v26 = v15;
  else
    v26 = v14;
  if (!v22)
    v25 = v17;
  v27 = *((unsigned __int8 *)v13 + 55);
  v28 = (char)v27;
  v30 = (char *)v26[4];
  v29 = v26[5];
  if ((v27 & 0x80u) != 0)
    v27 = v29;
  if (v28 >= 0)
    v31 = v25;
  else
    v31 = v30;
  if (v27 >= 0xD)
    v32 = 13;
  else
    v32 = v27;
  v33 = v27 > 0xD;
  v34 = memcmp(__s2, v31, v32);
  v35 = v34 < 0;
  if (!v34)
    v35 = v33;
  if (v35)
  {
LABEL_43:
    *(_QWORD *)__s2 = operator new(0x38uLL);
    *(_OWORD *)&__s2[8] = xmmword_1812674B0;
    strcpy(*(char **)__s2, "Could not find parameter with name 'align_corners'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
LABEL_44:
    if ((__s2[23] & 0x80000000) != 0)
      operator delete(*(void **)__s2);
    v36 = 0;
    goto LABEL_47;
  }
  if (v22)
    v38 = v15;
  else
    v38 = v14;
  if (v38[8] - v38[7] != 16)
  {
    *(_QWORD *)__s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181267490;
    strcpy(*(char **)__s2, "Unexpected argument size for 'align_corners'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  __s2[23] = 13;
  strcpy(__s2, "align_corners");
  MIL::IROperation::GetParameterValue();
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  v106 = MIL::IRValue::GetScalar<BOOL>();
  __s2[23] = 1;
  strcpy(__s2, "x");
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  v40 = MIL::IRValueType::AsTensorType(ParameterType);
  v41 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v40 + 96))(v40);
  v42 = v41[1] - *v41;
  if (v42 <= 0xF)
  {
    *(_QWORD *)__s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_1812674D0;
    strcpy(*(char **)__s2, "upsample_bilinear rank < 2 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  if (v42 >= 0x21)
  {
    *(_QWORD *)__s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_1812674D0;
    strcpy(*(char **)__s2, "upsample_bilinear rank > 4 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 1)
  {
    *(_QWORD *)__s2 = operator new(0x40uLL);
    *(_OWORD *)&__s2[8] = xmmword_18125E6C0;
    strcpy(*(char **)__s2, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  v43 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>(v80, v81, &ArgValue);
  if (!*((_DWORD *)v43 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v102 = (uint64_t)v43 - 16;
  v101 = -1;
  v100 = 1;
  *(_DWORD *)__s2 = -1;
  v44 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>(v80, v81, &v102, &v101, (unsigned int *)__s2, &v100);
  if (!*(_DWORD *)(v44 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v99 = v44 - 16;
  *(_DWORD *)__s2 = -2;
  v45 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>(v80, v81, &v102, &v101, (unsigned int *)__s2, &v100);
  if (!*(_DWORD *)(v45 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v98 = v45 - 16;
  *(_QWORD *)__s2 = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  Context = mlir::Attribute::getContext((mlir::Attribute *)__s2);
  v47 = mlir::IntegerType::get(Context, 0x20u, 1u);
  v48 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v47, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v48))
  {
    v50 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v51 = 566;
    v52 = "Casting.h";
    v53 = "cast";
LABEL_107:
    __assert_rtn(v53, v52, v51, v50);
  }
  if (v48)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v48);
    if (!InterfaceFor)
    {
      v50 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v51 = 98;
      v52 = "InterfaceSupport.h";
      v53 = "Interface";
      goto LABEL_107;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  LODWORD(v108[0]) = -1;
  v54 = mlir::DenseElementsAttr::getFromRawBuffer(v48, InterfaceFor, v108, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof(v54))
  {
    v76 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v77 = 566;
    v78 = "Casting.h";
    v79 = "cast";
    goto LABEL_110;
  }
  *(_QWORD *)__s2 = v54;
  v55 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v80, v81, (uint64_t **)__s2);
  if (!*((_DWORD *)v55 + 9))
  {
    v76 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v77 = 984;
    v78 = "Operation.h";
    v79 = "getOpResultImpl";
LABEL_110:
    __assert_rtn(v79, v78, v77, v76);
  }
  v97 = (uint64_t)v55 - 16;
  v95 = 2;
  v96 = 0;
  v56 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &>(v80, v81, &v102, &v97, &v96, &v95);
  if (!*(_DWORD *)(v56 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  __s2[23] = 19;
  strcpy(__s2, "scale_factor_height");
  ParameterValue = MIL::IROperation::GetParameterValue();
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  v58 = (float *)MEMORY[0x186DA1188](ParameterValue);
  if (v58)
  {
    v59 = *v58;
  }
  else
  {
    v60 = (int *)MEMORY[0x186DA1194](ParameterValue);
    if (v60)
    {
      v59 = (float)*v60;
    }
    else
    {
      v61 = (MIL::Fp16 *)MEMORY[0x186DA117C](ParameterValue);
      if (!v61)
      {
        std::string::basic_string[abi:ne180100]<0>(__s2, "unexpected type for scale_factor_height");
        MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
        goto LABEL_44;
      }
      MIL::Fp16::GetFloat(v61);
      v59 = v62;
    }
  }
  __s2[23] = 18;
  strcpy(__s2, "scale_factor_width");
  v63 = MIL::IROperation::GetParameterValue();
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  v64 = (float *)MEMORY[0x186DA1188](v63);
  if (v64)
  {
    v65 = *v64;
  }
  else
  {
    v66 = (int *)MEMORY[0x186DA1194](v63);
    if (v66)
    {
      v65 = (float)*v66;
    }
    else
    {
      v67 = (MIL::Fp16 *)MEMORY[0x186DA117C](v63);
      if (!v67)
      {
        std::string::basic_string[abi:ne180100]<0>(__s2, "unexpected type for scale_factor_width");
        MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
        goto LABEL_44;
      }
      MIL::Fp16::GetFloat(v67);
      v65 = v68;
    }
  }
  *(_QWORD *)__s2 = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  v69 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__s2);
  v94 = mlir::Float32Type::get(v69, v70);
  *(_QWORD *)__s2 = 1;
  v71 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)__s2, 1, v94, 0);
  ConstantOpFromScalar = createConstantOpFromScalar(v80, v81, v71, v65);
  v92 = createConstantOpFromScalar(v80, v81, v71, v59);
  v91 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>((mlir::UnknownLoc **)v80, v81, &v99, &v94);
  v90 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>((mlir::UnknownLoc **)v80, v81, &v98, &v94);
  v89 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>((mlir::Float32Type **)v80, v81, (uint64_t)&v91, &ConstantOpFromScalar);
  v88 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>((mlir::Float32Type **)v80, v81, (uint64_t)&v90, &v92);
  v87 = mlir::IntegerType::get(*(_QWORD *)v80, 0x20u, 1u);
  v86 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>(v80, v81, (uint64_t)&v89);
  v85 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>(v80, v81, (uint64_t)&v88);
  v72 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>((mlir::UnknownLoc **)v80, v81, (uint64_t)&v86, &v87);
  v73 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>((mlir::UnknownLoc **)v80, v81, (uint64_t)&v85, &v87);
  v108[0] = (void *)(v56 - 16);
  if (!*(_DWORD *)(v73 + 36) || (v108[1] = (void *)(v73 - 16), !*(_DWORD *)(v72 + 36)))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v109 = v72 - 16;
  std::vector<mlir::Value>::vector[abi:ne180100](__s2, v108, 3uLL);
  LOBYTE(v108[0]) = 0;
  v84 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v80, v81, (uint64_t *)__s2, &v97, (unsigned __int8 *)v108);
  v83 = 1;
  v82 = 1;
  std::string::basic_string[abi:ne180100]<0>(v108, "half_pixel_centers");
  v74 = MIL::IROperation::TryGetParameterValue();
  if (SHIBYTE(v109) < 0)
    operator delete(v108[0]);
  if (v74)
    v82 = MIL::IRValue::GetScalar<BOOL>();
  v75 = mlir::OpBuilder::create<mlir::mps::ResizeOp,mlir::Value &,mlir::mps::ConcatOp &,decltype(nullptr),decltype(nullptr),mlir::mps::SamplingMode &,BOOL &,BOOL &,decltype(nullptr)>((mlir::UnitAttr **)v80, v81, &ArgValue, (uint64_t)&v84, &v83, &v82, &v106);
  if (!*(_DWORD *)(v75 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v108, a2);
  MILToMLIRRewriter::setValue((uint64_t)a3, (__int128 *)v108[0], v75 - 16);
  std::vector<std::string>::~vector[abi:ne180100](v108);
  if (*(_QWORD *)__s2)
  {
    *(_QWORD *)&__s2[8] = *(_QWORD *)__s2;
    operator delete(*(void **)__s2);
  }
  v36 = 1;
LABEL_47:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v104, v105[0]);
  return v36;
}

void sub_180DFA0A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,char *a36)
{
  if (a34 < 0)
    operator delete(a29);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a35, a36);
  _Unwind_Resume(a1);
}

void sub_180DFA1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  uint64_t v32;

  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a32, *(char **)(v32 + 44));
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  uint64_t v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180DFA394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DFA3AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  uint64_t v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.crop";
    v25[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::CropOp::build(a1, v28, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::CropOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180DFA550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DFA568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.cast";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DFA6F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DFA70C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *(_QWORD *)a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DFA8C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DFA8E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.floor";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *(_QWORD *)a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_10;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::FloorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::FloorOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_10:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DFAA94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DFAAAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.cast";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::CastOp::build(a1, (uint64_t)v24, *(_QWORD *)a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DFAC68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DFAC80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<mlir::Value>::vector[abi:ne180100](_QWORD *a1, const void *a2, unint64_t a3)
{
  size_t v5;
  char *v6;
  char *v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 61)
      std::vector<long>::__throw_length_error[abi:ne180100]();
    v5 = 8 * a3;
    v6 = (char *)operator new(8 * a3);
    *a1 = v6;
    a1[1] = v6;
    v7 = &v6[v5];
    a1[2] = &v6[v5];
    memmove(v6, a2, v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_180DFAD08(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  unint64_t v26[2];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.concat";
    v23[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v11);
  mlir::ValueRange::ValueRange(v26, *a3, (a3[1] - *a3) >> 3);
  mlir::mps::ConcatOp::build(a1, (uint64_t)v27, v26[0], v26[1], *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v27);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ConcatOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConcatOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v14;
}

void sub_180DFAEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void sub_180DFAED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ResizeOp,mlir::Value &,mlir::mps::ConcatOp &,decltype(nullptr),decltype(nullptr),mlir::mps::SamplingMode &,BOOL &,BOOL &,decltype(nullptr)>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned int *a5, unsigned __int8 *a6, char *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v18;
  const char *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _BYTE v29[40];
  _QWORD v30[39];

  v30[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.resize", (const unsigned __int8 *)0xA, Context);
  if (!v16)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mps.resize";
    v27[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v15);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ResizeOp::build(a1, (uint64_t)v30, *a3, *(_QWORD *)a4 - 16, 0, 0, *a5, *a6, *a7, 0);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (!v17)
  {
    v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v21 = 662;
    v22 = "Casting.h";
    v23 = "dyn_cast";
    goto LABEL_10;
  }
  v18 = llvm::DefaultDoCastIfPossible<mlir::mps::ResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ResizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    v20 = "result && \"builder didn't return the right type\"";
    v21 = 497;
    v22 = "Builders.h";
    v23 = "create";
LABEL_10:
    __assert_rtn(v23, v22, v21, v20);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v18;
}

void sub_180DFB0CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void sub_180DFB0E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::ResizePattern::matchAndRewrite(MILToMLIR::ResizePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  _QWORD *v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  BOOL v11;
  unsigned int v12;
  const void ***v13;
  const void **v14;
  const void ***v15;
  char *v16;
  char **v17;
  char *v18;
  char **v19;
  char *v20;
  char *v21;
  unint64_t v22;
  int v23;
  char *v24;
  size_t v25;
  _BOOL4 v26;
  int v27;
  char **v28;
  char *v29;
  _QWORD *v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  char *v34;
  char *v35;
  size_t v36;
  _BOOL4 v37;
  int v38;
  _BOOL4 v39;
  uint64_t v40;
  const void **v41;
  const void ***v42;
  _QWORD *v43;
  int v44;
  BOOL v45;
  BOOL v47;
  char **v50;
  int v52;
  int v53;
  char **v55;
  char *v56;
  uint64_t v57;
  char v59;
  MIL::IRValueType *ParameterType;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const void *v64;
  int64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  mlir::GenericProgramPoint *v70;
  unint64_t v71;
  uint64_t Context;
  uint64_t v73;
  uint64_t **v74;
  uint64_t InterfaceFor;
  const char *v76;
  int v77;
  const char *v78;
  const char *v79;
  uint64_t v81;
  mlir::GenericProgramPoint *v82;
  uint64_t v83;
  _QWORD *v84;
  uint64_t v85;
  __int128 *v86;
  char *v87;
  uint64_t *v88;
  void **v89;
  void **v90;
  void *v91;
  const char *v92;
  int v93;
  const char *v94;
  const char *v95;
  unsigned int v96;
  void *v97;
  void **v98;
  unsigned int v99;
  uint64_t v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  _BYTE __p[24];
  char *__s2[3];
  char **v107;
  char *v108[2];
  __int16 v109;
  uint64_t ArgValue;
  __int128 *v111;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v7 = (_QWORD *)((char *)this + 8);
  v8 = *((char *)this + 31);
  if (v8 < 0)
  {
    if (*((_QWORD *)this + 2) != 15)
    {
LABEL_12:
      v12 = 0;
      goto LABEL_13;
    }
    v7 = (_QWORD *)*v7;
  }
  else if (v8 != 15)
  {
    goto LABEL_12;
  }
  v9 = (_QWORD *)*v7;
  v10 = *(_QWORD *)((char *)v7 + 7);
  v11 = v9 == (_QWORD *)0x625F657A69736572 && v10 == 0x7261656E696C6962;
  v12 = v11;
LABEL_13:
  v109 = 1;
  v13 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v108[0] = 0;
  v108[1] = 0;
  v107 = v108;
  v15 = v13 + 1;
  v14 = *v13;
  if (*v13 != (const void **)(v13 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v107, (uint64_t *)v108, v14 + 4, (uint64_t)(v14 + 4));
      v41 = (const void **)v14[1];
      if (v41)
      {
        do
        {
          v42 = (const void ***)v41;
          v41 = (const void **)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          v42 = (const void ***)v14[2];
          v11 = *v42 == v14;
          v14 = (const void **)v42;
        }
        while (!v11);
      }
      v14 = (const void **)v42;
    }
    while (v42 != v15);
  }
  if (!v12)
    goto LABEL_131;
  v96 = v12;
  HIBYTE(__s2[2]) = 13;
  strcpy((char *)__s2, "sampling_mode");
  v16 = v108[0];
  if (!v108[0])
    goto LABEL_51;
  v17 = v108;
  do
  {
    v18 = v16;
    v19 = v17;
    v21 = v16 + 32;
    v20 = (char *)*((_QWORD *)v16 + 4);
    v22 = v16[55];
    v23 = (char)v22;
    if ((v22 & 0x80u) != 0)
      v22 = *((_QWORD *)v18 + 5);
    if (v23 >= 0)
      v24 = v21;
    else
      v24 = v20;
    if (v22 >= 0xD)
      v25 = 13;
    else
      v25 = v22;
    v26 = v22 < 0xD;
    v27 = memcmp(v24, __s2, v25);
    if (v27)
      v26 = v27 < 0;
    if (v26)
      v28 = (char **)(v18 + 8);
    else
      v28 = (char **)v18;
    if (v26)
      v17 = v19;
    else
      v17 = (char **)v18;
    v16 = *v28;
  }
  while (v16);
  if (v17 == v108)
    goto LABEL_51;
  v29 = (char *)(v19 + 4);
  if (v26)
    v30 = v19;
  else
    v30 = v18;
  if (!v26)
    v29 = v21;
  v31 = *((unsigned __int8 *)v17 + 55);
  v32 = (char)v31;
  v34 = (char *)v30[4];
  v33 = v30[5];
  if ((v31 & 0x80u) != 0)
    v31 = v33;
  if (v32 >= 0)
    v35 = v29;
  else
    v35 = v34;
  if (v31 >= 0xD)
    v36 = 13;
  else
    v36 = v31;
  v37 = v31 > 0xD;
  v38 = memcmp(__s2, v35, v36);
  v39 = v38 < 0;
  if (!v38)
    v39 = v37;
  if (v39)
  {
LABEL_51:
    __s2[0] = (char *)operator new(0x38uLL);
    *(_OWORD *)&__s2[1] = xmmword_1812674B0;
    strcpy(__s2[0], "Could not find parameter with name 'sampling_mode'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__s2);
    goto LABEL_52;
  }
  if (v26)
    v43 = v19;
  else
    v43 = v18;
  if (v43[8] - v43[7] != 16)
  {
    __s2[0] = (char *)operator new(0x30uLL);
    *(_OWORD *)&__s2[1] = xmmword_181267490;
    strcpy(__s2[0], "Unexpected argument size for 'sampling_mode'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__s2);
LABEL_52:
    if (SHIBYTE(__s2[2]) < 0)
      operator delete(__s2[0]);
LABEL_54:
    v40 = 0;
    goto LABEL_153;
  }
  __p[23] = 13;
  strcpy(__p, "sampling_mode");
  MIL::IROperation::GetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  v12 = v96;
  v44 = HIBYTE(__s2[2]);
  if ((HIBYTE(__s2[2]) & 0x80) != 0)
  {
    if (__s2[1] != (char *)7)
    {
      if (__s2[1] == (char *)13)
      {
        if (*(_QWORD *)__s2[0] != 0x4F435F4E47494C41 || *(_QWORD *)(__s2[0] + 5) != 0x5352454E524F435FLL)
          goto LABEL_110;
      }
      else
      {
        if (__s2[1] != (char *)20)
          goto LABEL_110;
        v47 = *(_QWORD *)__s2[0] == 0x415F544349525453 && *((_QWORD *)__s2[0] + 1) == 0x524F435F4E47494CLL;
        if (!v47 || *((_DWORD *)__s2[0] + 4) != 1397900622)
          goto LABEL_110;
      }
      goto LABEL_104;
    }
    v50 = (char **)__s2[0];
LABEL_106:
    v52 = *(_DWORD *)v50;
    v53 = *(_DWORD *)((char *)v50 + 3);
    if (v52 == 1095124292 && v53 == 1414288705)
    {
      v109 = 0;
      goto LABEL_114;
    }
    goto LABEL_110;
  }
  switch(HIBYTE(__s2[2]))
  {
    case 7u:
      v50 = __s2;
      goto LABEL_106;
    case 0xDu:
      if (__s2[0] != (char *)0x4F435F4E47494C41 || *(char **)((char *)__s2 + 5) != (char *)0x5352454E524F435FLL)
        break;
LABEL_104:
      v109 = 257;
      goto LABEL_114;
    case 0x14u:
      v45 = __s2[0] == (char *)0x415F544349525453 && __s2[1] == (char *)0x524F435F4E47494CLL;
      if (v45 && LODWORD(__s2[2]) == 1397900622)
        goto LABEL_104;
      break;
  }
LABEL_110:
  if (!std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(__s2, "OFFSET_CORNERS"))
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "Unexpected value for 'sampling_mode'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    goto LABEL_125;
  }
  v109 = 1;
  v44 = HIBYTE(__s2[2]);
LABEL_114:
  if ((v44 & 0x80) != 0)
  {
    if (__s2[1] != (char *)14)
    {
LABEL_123:
      v59 = 1;
      goto LABEL_128;
    }
    v55 = (char **)__s2[0];
  }
  else
  {
    if (v44 != 14)
      goto LABEL_131;
    v55 = __s2;
  }
  v56 = *v55;
  v57 = *(uint64_t *)((char *)v55 + 6);
  if (v56 != (char *)0x435F54455346464FLL || v57 != 0x5352454E524F435FLL)
    goto LABEL_123;
  *(_QWORD *)__p = operator new(0x38uLL);
  *(_OWORD *)&__p[8] = xmmword_1812674B0;
  strcpy(*(char **)__p, "OFFSET_CORNERS not yet supported in resize_bilinear");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
LABEL_125:
  if ((__p[23] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  v59 = 0;
LABEL_128:
  if (SHIBYTE(__s2[2]) < 0)
    operator delete(__s2[0]);
  if ((v59 & 1) == 0)
    goto LABEL_54;
LABEL_131:
  HIBYTE(__s2[2]) = 1;
  strcpy((char *)__s2, "x");
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(__s2[2]) < 0)
    operator delete(__s2[0]);
  v61 = MIL::IRValueType::AsTensorType(ParameterType);
  v62 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v61 + 96))(v61);
  memset(__s2, 0, sizeof(__s2));
  v64 = *(const void **)v62;
  v63 = *(_QWORD *)(v62 + 8);
  v65 = v63 - *(_QWORD *)v62;
  if (v63 == *(_QWORD *)v62)
  {
    v66 = 0;
LABEL_136:
    *(_QWORD *)__p = operator new(0x28uLL);
    *(_OWORD *)&__p[8] = xmmword_181261450;
    strcpy(*(char **)__p, "resize_bilinear rank < 2 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    goto LABEL_149;
  }
  if (v65 < 0)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v66 = (char *)operator new(v63 - *(_QWORD *)v62);
  __s2[0] = v66;
  __s2[2] = &v66[8 * (v65 >> 3)];
  memcpy(v66, v64, v65);
  __s2[1] = &v66[8 * (v65 >> 3)];
  v67 = 8 * (v65 >> 3);
  if ((unint64_t)v67 <= 0x17)
    goto LABEL_136;
  if ((unint64_t)v67 >= 0x21)
  {
    *(_QWORD *)__p = operator new(0x28uLL);
    *(_OWORD *)&__p[8] = xmmword_181261450;
    strcpy(*(char **)__p, "resize_bilinear rank > 4 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    goto LABEL_149;
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    if ((unint64_t)((v67 >> 3) - 3) < 2)
    {
      v68 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "target_size_width");
      v69 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "target_size_height");
      v70 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
      if (!*((_DWORD *)v70 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v71 = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
      v104 = (uint64_t)v70 - 16;
      *(_QWORD *)__p = v71;
      Context = mlir::Attribute::getContext((mlir::Attribute *)__p);
      v73 = mlir::IntegerType::get(Context, 0x20u, 1u);
      v74 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v73, 0);
      if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74))
      {
        if (v74)
        {
          InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74);
          if (!InterfaceFor)
          {
            v76 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v77 = 98;
            v78 = "InterfaceSupport.h";
            v79 = "Interface";
            goto LABEL_173;
          }
        }
        else
        {
          InterfaceFor = 0;
        }
        LODWORD(v97) = -1;
        v81 = mlir::DenseElementsAttr::getFromRawBuffer(v74, InterfaceFor, &v97, 4, 4, 1, 1);
        if (mlir::DenseIntElementsAttr::classof(v81))
        {
          *(_QWORD *)__p = v81;
          v82 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)__p);
          if (*((_DWORD *)v82 + 9))
          {
            v103 = (uint64_t)v82 - 16;
            v101 = 2;
            v102 = 0;
            v83 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v104, &v103, &v102, &v101);
            if (!*(_DWORD *)(v83 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v84 = operator new(0x18uLL);
            *(_QWORD *)&__p[8] = v84 + 3;
            *(_QWORD *)&__p[16] = v84 + 3;
            *v84 = v83 - 16;
            v84[1] = v69;
            v84[2] = v68;
            *(_QWORD *)__p = v84;
            LOBYTE(v97) = 0;
            v100 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>(a3 + 13, LocationForOp, (uint64_t *)__p, &v103, (unsigned __int8 *)&v97);
            v99 = v12;
            v85 = mlir::OpBuilder::create<mlir::mps::ResizeOp,mlir::Value &,mlir::mps::ConcatOp &,decltype(nullptr),decltype(nullptr),mlir::mps::SamplingMode &,BOOL &,BOOL &,decltype(nullptr)>(a3 + 13, LocationForOp, &ArgValue, (uint64_t)&v100, &v99, (unsigned __int8 *)&v109, (char *)&v109 + 1);
            if (!*(_DWORD *)(v85 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&v97, a2);
            v86 = (__int128 *)v97;
            v87 = (char *)operator new(8uLL);
            *(_QWORD *)v87 = v85 - 16;
            v111 = v86;
            v88 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v86, (uint64_t)&std::piecewise_construct, &v111);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v88 + 5, v87, v87 + 8, 1uLL);
            operator delete(v87);
            v89 = (void **)v97;
            if (v97)
            {
              v90 = v98;
              v91 = v97;
              if (v98 != v97)
              {
                do
                {
                  if (*((char *)v90 - 1) < 0)
                    operator delete(*(v90 - 3));
                  v90 -= 3;
                }
                while (v90 != v89);
                v91 = v97;
              }
              v98 = v89;
              operator delete(v91);
            }
            if (*(_QWORD *)__p)
            {
              *(_QWORD *)&__p[8] = *(_QWORD *)__p;
              operator delete(*(void **)__p);
            }
            v40 = 1;
            if (v66)
              goto LABEL_152;
            goto LABEL_153;
          }
          v92 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
          v93 = 984;
          v94 = "Operation.h";
          v95 = "getOpResultImpl";
        }
        else
        {
          v92 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          v93 = 566;
          v94 = "Casting.h";
          v95 = "cast";
        }
        __assert_rtn(v95, v94, v93, v92);
      }
      v76 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v77 = 566;
      v78 = "Casting.h";
      v79 = "cast";
LABEL_173:
      __assert_rtn(v79, v78, v77, v76);
    }
    *(_QWORD *)__p = operator new(0x28uLL);
    *(_OWORD *)&__p[8] = xmmword_181286A40;
    strcpy(*(char **)__p, "Unsupported rank for input tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  }
  else
  {
    *(_QWORD *)__p = operator new(0x40uLL);
    *(_OWORD *)&__p[8] = xmmword_18125E6C0;
    strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  }
LABEL_149:
  if ((__p[23] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  v40 = 0;
  if (v66)
LABEL_152:
    operator delete(v66);
LABEL_153:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v107, v108[0]);
  return v40;
}

void sub_180DFBC9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,char *a32)
{
  if (a24 < 0)
    operator delete(__p);
  if (a30 < 0)
  {
    operator delete(a25);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
    _Unwind_Resume(a1);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::UpsampleNearestNeighborPattern::matchAndRewrite(MILToMLIR::UpsampleNearestNeighborPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void ***v7;
  const void **v8;
  MIL::IRValueType *ParameterType;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  const void **v13;
  const void ***v14;
  BOOL v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t Context;
  uint64_t v20;
  uint64_t **v21;
  uint64_t InterfaceFor;
  const char *v23;
  int v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  void *v29;
  mlir::GenericProgramPoint *v30;
  uint64_t v31;
  uint64_t ParameterValue;
  int *v33;
  double v34;
  float *v35;
  float v36;
  MIL::Fp16 *v37;
  uint64_t v38;
  int *v39;
  double v40;
  float *v41;
  float v42;
  MIL::Fp16 *v43;
  mlir::Float32Type *v44;
  mlir::MLIRContext *v45;
  _QWORD *v46;
  int MPSDataType;
  float v48;
  void *v49;
  uint64_t ConstantOp;
  int v51;
  float v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  char v61;
  mlir::GenericProgramPoint *v62;
  uint64_t v63;
  __int128 *v64;
  char *v65;
  uint64_t *v66;
  void **v67;
  void **v68;
  void *v69;
  const char *v70;
  int v71;
  const char *v72;
  const char *v73;
  const char *v74;
  int v75;
  const char *v76;
  const char *v77;
  void *v78;
  void *v79;
  _QWORD *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t v98;
  char **v99;
  char *v100[2];
  uint64_t ArgValue;
  uint64_t v102;
  const char *v103;
  __int16 v104;
  uint64_t v105[4];
  __int16 v106;
  __int128 *v107[5];
  void *__p[40];

  __p[39] = *(void **)MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v100[0] = 0;
  v100[1] = 0;
  v99 = v100;
  v7 = v6 + 1;
  v8 = *v6;
  if (*v6 != (const void **)(v6 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v99, (uint64_t *)v100, v8 + 4, (uint64_t)(v8 + 4));
      v13 = (const void **)v8[1];
      if (v13)
      {
        do
        {
          v14 = (const void ***)v13;
          v13 = (const void **)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          v14 = (const void ***)v8[2];
          v15 = *v14 == v8;
          v8 = (const void **)v14;
        }
        while (!v15);
      }
      v8 = (const void **)v14;
    }
    while (v14 != v7);
  }
  HIBYTE(__p[2]) = 1;
  LOWORD(__p[0]) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  v10 = MIL::IRValueType::AsTensorType(ParameterType);
  v11 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 96))(v10);
  v12 = v11[1] - *v11;
  if (v12 <= 0xF)
  {
    __p[0] = operator new(0x30uLL);
    *(_OWORD *)&__p[1] = xmmword_1812674D0;
    strcpy((char *)__p[0], "upsample_bilinear rank < 2 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
LABEL_24:
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    v27 = 0;
    goto LABEL_27;
  }
  if (v12 >= 0x21)
  {
    __p[0] = operator new(0x30uLL);
    *(_OWORD *)&__p[1] = xmmword_1812674D0;
    strcpy((char *)__p[0], "upsample_bilinear rank > 4 not supported.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
    goto LABEL_24;
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 1)
  {
    __p[0] = operator new(0x40uLL);
    *(_OWORD *)&__p[1] = xmmword_18125E6C0;
    strcpy((char *)__p[0], "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
    goto LABEL_24;
  }
  v16 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
  if (!*((_DWORD *)v16 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v98 = (uint64_t)v16 - 16;
  v96 = 1;
  v97 = -1;
  LODWORD(__p[0]) = -1;
  v17 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v98, &v97, (unsigned int *)__p, &v96);
  if (!*(_DWORD *)(v17 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v95 = v17 - 16;
  LODWORD(__p[0]) = -2;
  v18 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int &,int,int &>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v98, &v97, (unsigned int *)__p, &v96);
  if (!*(_DWORD *)(v18 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v94 = v18 - 16;
  __p[0] = (void *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  Context = mlir::Attribute::getContext((mlir::Attribute *)__p);
  v20 = mlir::IntegerType::get(Context, 0x20u, 1u);
  v21 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v20, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v21))
  {
    v23 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v24 = 566;
    v25 = "Casting.h";
    v26 = "cast";
LABEL_75:
    __assert_rtn(v26, v25, v24, v23);
  }
  if (v21)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v21);
    if (!InterfaceFor)
    {
      v23 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v24 = 98;
      v25 = "InterfaceSupport.h";
      v26 = "Interface";
      goto LABEL_75;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  LODWORD(v107[0]) = -1;
  v29 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v21, InterfaceFor, v107, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v29))
  {
    v70 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v71 = 566;
    v72 = "Casting.h";
    v73 = "cast";
    goto LABEL_78;
  }
  __p[0] = v29;
  v30 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)__p);
  if (!*((_DWORD *)v30 + 9))
  {
    v70 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v71 = 984;
    v72 = "Operation.h";
    v73 = "getOpResultImpl";
LABEL_78:
    __assert_rtn(v73, v72, v71, v70);
  }
  v93 = (uint64_t)v30 - 16;
  v91 = 2;
  v92 = 0;
  v31 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v98, &v93, &v92, &v91);
  if (!*(_DWORD *)(v31 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  HIBYTE(__p[2]) = 19;
  strcpy((char *)__p, "scale_factor_height");
  ParameterValue = MIL::IROperation::GetParameterValue();
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  v33 = (int *)MEMORY[0x186DA1194](ParameterValue);
  if (v33)
  {
    v34 = (double)*v33;
  }
  else
  {
    v35 = (float *)MEMORY[0x186DA1188](ParameterValue);
    if (v35)
    {
      v36 = *v35;
    }
    else
    {
      v37 = (MIL::Fp16 *)MEMORY[0x186DA117C](ParameterValue);
      if (!v37)
      {
        std::string::basic_string[abi:ne180100]<0>(__p, "unexpected type for scale_factor_height");
        MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
        goto LABEL_24;
      }
      MIL::Fp16::GetFloat(v37);
    }
    v34 = v36;
  }
  HIBYTE(__p[2]) = 18;
  strcpy((char *)__p, "scale_factor_width");
  v38 = MIL::IROperation::GetParameterValue();
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  v39 = (int *)MEMORY[0x186DA1194](v38);
  if (v39)
  {
    v40 = (double)*v39;
  }
  else
  {
    v41 = (float *)MEMORY[0x186DA1188](v38);
    if (v41)
    {
      v42 = *v41;
    }
    else
    {
      v43 = (MIL::Fp16 *)MEMORY[0x186DA117C](v38);
      if (!v43)
      {
        std::string::basic_string[abi:ne180100]<0>(__p, "unexpected type for scale_factor_width");
        MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
        goto LABEL_24;
      }
      MIL::Fp16::GetFloat(v43);
    }
    v40 = v42;
  }
  __p[0] = (void *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  v44 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__p);
  v90 = mlir::Float32Type::get(v44, v45);
  __p[0] = (void *)1;
  v46 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)__p, 1, v90, 0);
  MPSDataType = getMPSDataType(v46);
  v48 = v40;
  getConstantDataForScalar(MPSDataType, v48);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  ConstantOp = createConstantOp((mlir::OpBuilder *)(a3 + 13), LocationForOp, v49, v46, 1);

  v89 = ConstantOp;
  v51 = getMPSDataType(v46);
  v52 = v34;
  getConstantDataForScalar(v51, v52);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  v54 = createConstantOp((mlir::OpBuilder *)(a3 + 13), LocationForOp, v53, v46, 1);

  v88 = v54;
  v87 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>(a3 + 13, LocationForOp, &v95, &v90);
  v86 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::FloatType &>(a3 + 13, LocationForOp, &v94, &v90);
  v85 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>(a3 + 13, LocationForOp, (uint64_t)&v87, &v89);
  v84 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>(a3 + 13, LocationForOp, (uint64_t)&v86, &v88);
  v83 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
  v82 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t)&v85);
  v81 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::mps::MultiplyOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t)&v84);
  v55 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>(a3 + 13, LocationForOp, (uint64_t)&v82, &v83);
  v56 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::FloorOp &,mlir::IntegerType &>(a3 + 13, LocationForOp, (uint64_t)&v81, &v83);
  if (!*(_DWORD *)(v56 + 36) || !*(_DWORD *)(v55 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v57 = operator new(0x18uLL);
  v79 = v57 + 3;
  v80 = v57 + 3;
  *v57 = v31 - 16;
  v57[1] = v56 - 16;
  v57[2] = v55 - 16;
  v78 = v57;
  LOBYTE(__p[0]) = 0;
  v58 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>(a3 + 13, LocationForOp, (uint64_t *)&v78, &v93, (unsigned __int8 *)__p);
  v102 = LocationForOp;
  v59 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v102);
  v60 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.resize", (const unsigned __int8 *)0xA, v59);
  if (!v61)
  {
    v106 = 1283;
    v105[2] = (uint64_t)"mps.resize";
    v105[3] = 10;
           "y the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-"
           "dialects-management";
    v104 = 259;
    llvm::operator+(v105, (uint64_t *)&v103, (uint64_t)v107);
    llvm::report_fatal_error((llvm::Twine *)v107, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v60);
  if (!*(_DWORD *)(v58 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ResizeOp::build(a3 + 13, (uint64_t)__p, ArgValue, v58 - 16, 0, 0, 0, 1, 0, 0);
  v62 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)__p);
  if (!v62)
  {
    v74 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v75 = 662;
    v76 = "Casting.h";
    v77 = "dyn_cast";
    goto LABEL_84;
  }
  v63 = llvm::DefaultDoCastIfPossible<mlir::mps::ResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ResizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v62);
  if (!v63)
  {
    v74 = "result && \"builder didn't return the right type\"";
    v75 = 497;
    v76 = "Builders.h";
    v77 = "create";
LABEL_84:
    __assert_rtn(v77, v76, v75, v74);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (!*(_DWORD *)(v63 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
  v64 = (__int128 *)__p[0];
  v65 = (char *)operator new(8uLL);
  *(_QWORD *)v65 = v63 - 16;
  v107[0] = v64;
  v66 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v64, (uint64_t)&std::piecewise_construct, v107);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v66 + 5, v65, v65 + 8, 1uLL);
  operator delete(v65);
  v67 = (void **)__p[0];
  if (__p[0])
  {
    v68 = (void **)__p[1];
    v69 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v68 - 1) < 0)
          operator delete(*(v68 - 3));
        v68 -= 3;
      }
      while (v68 != v67);
      v69 = __p[0];
    }
    __p[1] = v67;
    operator delete(v69);
  }
  if (v78)
  {
    v79 = v78;
    operator delete(v78);
  }
  v27 = 1;
LABEL_27:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v99, v100[0]);
  return v27;
}

void sub_180DFC928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,char *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0)
  {
    operator delete(__p);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
    _Unwind_Resume(a1);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::SplitPattern::matchAndRewrite(MILToMLIR::SplitPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  const MIL::IROperation *v4;
  uint64_t LocationForOp;
  MIL::IRValue *ParameterValue;
  MIL::IRValueType *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t Data;
  unint64_t v13;
  int *v14;
  int *v15;
  int *end;
  int *v17;
  int v18;
  std::vector<int>::pointer begin;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  int64_t v23;
  unint64_t v24;
  _BYTE *v25;
  int *v26;
  int64_t v27;
  unint64_t v28;
  int *v29;
  int v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _OWORD *v34;
  int *v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  MILToMLIRRewriter *v39;
  uint64_t v40;
  unsigned int v41;
  char *v42;
  uint64_t v43;
  mlir::mps::ConstantOp *v44;
  const char *v45;
  const char *v46;
  const char *v47;
  std::vector<int>::pointer v48;
  uint64_t *Context;
  uint64_t v50;
  char v51;
  mlir::GenericProgramPoint *v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  const char *v56;
  const char *v57;
  char *v58;
  int64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  _BYTE *v65;
  uint64_t *v66;
  uint64_t v67;
  int64_t v68;
  unint64_t v69;
  char *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _OWORD *v75;
  char *v76;
  uint64_t v77;
  __int128 v78;
  int v79;
  MIL::IRValueType *ParameterType;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const void *v84;
  int64_t v85;
  char *v86;
  char *v87;
  char v88;
  unint64_t v89;
  void *v90;
  unint64_t v91;
  int v92;
  unint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  BOOL v98;
  uint64_t OutputType;
  char *v100;
  uint64_t v101;
  char *v102;
  uint64_t *v103;
  void **v104;
  void **v105;
  void *v106;
  uint64_t v107;
  MILToMLIRRewriter *v108;
  uint64_t v109;
  void *v110;
  int64_t v111;
  uint64_t *v112;
  void **v113;
  void **v114;
  void *v115;
  void *v116;
  int v118;
  MILToMLIRRewriter *v119;
  mlir::mps::ConstantOp *v120;
  const MIL::IROperation *v121;
  int v122;
  unint64_t v123;
  unsigned int v124;
  uint64_t v125;
  uint64_t ArgValue;
  void *v127;
  char *v128;
  char *v129;
  void *v130;
  char *v131;
  char *v132;
  std::vector<int> v133;
  uint64_t v134;
  const char *v135;
  __int16 v136;
  uint64_t v137[4];
  __int16 v138;
  std::vector<int>::value_type __u[10];
  void *__p[40];

  v4 = a2;
  __p[38] = *(void **)MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, v4, "x");
  HIBYTE(__p[2]) = 4;
  strcpy((char *)__p, "axis");
  ParameterValue = (MIL::IRValue *)MIL::IROperation::GetParameterValue();
  v7 = (MIL::IRValueType *)(*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)ParameterValue + 32))(ParameterValue);
  v8 = MIL::IRValueType::AsTensorType(v7);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 88))(v8) == 11)
  {
    MIL::IRValue::AsTensor(ParameterValue);
    v9 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
    strcpy((char *)__p, "num_splits");
    v10 = MIL::IROperation::TryGetParameterValue();
    v124 = v9;
    HIBYTE(__p[2]) = 11;
    strcpy((char *)__p, "split_sizes");
    v11 = MIL::IROperation::TryGetParameterValue();
    memset(&v133, 0, sizeof(v133));
    v119 = (MILToMLIRRewriter *)a3;
    v121 = v4;
    v125 = LocationForOp;
    if (v11)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
      Data = MIL::IRTensorValue::GetDataView<int>();
      if (v13)
      {
        v14 = (int *)Data;
        v123 = v13;
        v15 = (int *)(Data + 4 * v13);
        end = v133.__end_;
        while (1)
        {
          v18 = *v14;
          if (end >= v133.__end_cap_.__value_)
            break;
          *end = v18;
          v17 = end + 1;
LABEL_6:
          v133.__end_ = v17;
          ++v14;
          end = v17;
          if (v14 == v15)
          {
            v39 = v119;
            v4 = v121;
            v40 = v125;
            v130 = 0;
            v131 = 0;
            v132 = 0;
            goto LABEL_38;
          }
        }
        begin = v133.__begin_;
        v20 = (char *)end - (char *)v133.__begin_;
        v21 = end - v133.__begin_;
        v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 62)
          std::vector<int>::__throw_length_error[abi:ne180100]();
        v23 = (char *)v133.__end_cap_.__value_ - (char *)v133.__begin_;
        if (((char *)v133.__end_cap_.__value_ - (char *)v133.__begin_) >> 1 > v22)
          v22 = v23 >> 1;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL)
          v24 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        if (v24)
        {
          if (v24 >> 62)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v25 = operator new(4 * v24);
          v26 = (int *)&v25[4 * v21];
          *v26 = v18;
          v17 = v26 + 1;
          v27 = (char *)end - (char *)begin;
          if (end == begin)
            goto LABEL_22;
        }
        else
        {
          v25 = 0;
          v26 = (int *)(4 * v21);
          *(_DWORD *)(4 * v21) = v18;
          v17 = (int *)(4 * v21 + 4);
          v27 = (char *)end - (char *)begin;
          if (end == begin)
            goto LABEL_22;
        }
        v28 = v27 - 4;
        if (v28 >= 0xBC)
        {
          v31 = ((char *)(end - 1) - (char *)begin) & 0xFFFFFFFFFFFFFFFCLL;
          if (&v25[v20 - 4 - v31] > &v25[v20 - 4])
          {
            v29 = end;
          }
          else if ((int *)((char *)end - v31 - 4) > end - 1)
          {
            v29 = end;
          }
          else if ((unint64_t)((char *)end - v25 - v20) >= 0x20)
          {
            v32 = (v28 >> 2) + 1;
            v33 = 4 * (v32 & 0x7FFFFFFFFFFFFFF8);
            v29 = &end[v33 / 0xFFFFFFFFFFFFFFFCLL];
            v26 = (int *)((char *)v26 - v33);
            v34 = &v25[4 * v21 - 16];
            v35 = end - 4;
            v36 = v32 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              v37 = *(_OWORD *)v35;
              *(v34 - 1) = *((_OWORD *)v35 - 1);
              *v34 = v37;
              v34 -= 2;
              v35 -= 8;
              v36 -= 8;
            }
            while (v36);
            if (v32 == (v32 & 0x7FFFFFFFFFFFFFF8))
            {
LABEL_22:
              v133.__begin_ = v26;
              v133.__end_ = v17;
              v133.__end_cap_.__value_ = (int *)&v25[4 * v24];
              if (begin)
                operator delete(begin);
              goto LABEL_6;
            }
          }
          else
          {
            v29 = end;
          }
        }
        else
        {
          v29 = end;
        }
        do
        {
          v30 = *--v29;
          *--v26 = v30;
        }
        while (v29 != begin);
        goto LABEL_22;
      }
      v89 = 0;
      v42 = 0;
      v130 = 0;
      v131 = 0;
      v88 = 1;
      v132 = 0;
LABEL_95:
      if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)v4 + 192))(v4) == v89)
      {
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(__p, v4);
        if ((v88 & 1) != 0)
        {
LABEL_100:
          v98 = 0;
        }
        else
        {
          v96 = 0;
          v97 = 0;
          v98 = 1;
          while (1)
          {
            OutputType = MIL::IROperation::GetOutputType(v4);
            if (!(*(uint64_t (**)(uint64_t))(*(_QWORD *)OutputType + 24))(OutputType))
              break;
            v100 = (char *)__p[0];
            v101 = *((_QWORD *)v130 + v97);
            v102 = (char *)operator new(8uLL);
            *(_QWORD *)v102 = v101;
            *(_QWORD *)__u = &v100[v96];
            v103 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v119 + 64, (uint64_t)&v100[v96], (uint64_t)&std::piecewise_construct, (__int128 **)__u);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v103 + 5, v102, v102 + 8, 1uLL);
            operator delete(v102);
            v98 = ++v97 < v89;
            v96 += 24;
            if (v89 == v97)
              goto LABEL_100;
          }
          *(_QWORD *)__u = operator new(0x28uLL);
          *(_OWORD *)&__u[2] = xmmword_181268740;
          strcpy(*(char **)__u, "Expected num_splits tensor outputs.");
          MILToMLIRRewriter::notifyFailure((uint64_t)v119, (uint64_t)v4, (const std::string::value_type *)__u);
          if (SHIBYTE(__u[5]) < 0)
            operator delete(*(void **)__u);
        }
        v104 = (void **)__p[0];
        if (__p[0])
        {
          v105 = (void **)__p[1];
          v106 = __p[0];
          if (__p[1] != __p[0])
          {
            do
            {
              if (*((char *)v105 - 1) < 0)
                operator delete(*(v105 - 3));
              v105 -= 3;
            }
            while (v105 != v104);
            v106 = __p[0];
          }
          __p[1] = v104;
          operator delete(v106);
        }
        if (!v98)
          goto LABEL_127;
      }
      else
      {
        if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)v4 + 192))(v4) == 1)
        {
          v107 = MIL::IROperation::GetOutputType(v4);
          v108 = v119;
          v109 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v107 + 40))(v107);
          if (v109)
          {
            if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v109 + 16))(v109) == v89)
            {
              (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(__p, v4);
              v110 = __p[0];
              v128 = 0;
              v129 = 0;
              v127 = 0;
              v111 = v42 - (_BYTE *)v130;
              if (v42 != v130)
              {
                if (v111 < 0)
                  std::vector<long>::__throw_length_error[abi:ne180100]();
                v127 = operator new(v42 - (_BYTE *)v130);
                v129 = (char *)v127 + 8 * (v111 >> 3);
                memcpy(v127, v130, v111);
                v128 = v129;
                v108 = v119;
              }
              *(_QWORD *)__u = v110;
              v112 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v108 + 64, (uint64_t)v110, (uint64_t)&std::piecewise_construct, (__int128 **)__u)+ 5;
              if (v112 != (uint64_t *)&v127)
                std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v112, (char *)v127, v128, (v128 - (_BYTE *)v127) >> 3);
              if (v127)
              {
                v128 = (char *)v127;
                operator delete(v127);
              }
              v113 = (void **)__p[0];
              if (__p[0])
              {
                v114 = (void **)__p[1];
                v115 = __p[0];
                if (__p[1] != __p[0])
                {
                  do
                  {
                    if (*((char *)v114 - 1) < 0)
                      operator delete(*(v114 - 3));
                    v114 -= 3;
                  }
                  while (v114 != v113);
                  v115 = __p[0];
                }
                __p[1] = v113;
                operator delete(v115);
                v38 = 1;
                v116 = v130;
                if (!v130)
                  goto LABEL_137;
                goto LABEL_136;
              }
LABEL_127:
              v38 = 1;
              v116 = v130;
              if (!v130)
              {
LABEL_137:
                if (v133.__begin_)
                {
                  v133.__end_ = v133.__begin_;
                  operator delete(v133.__begin_);
                }
                return v38;
              }
LABEL_136:
              operator delete(v116);
              goto LABEL_137;
            }
            __p[0] = operator new(0x28uLL);
            *(_OWORD *)&__p[1] = xmmword_181286A40;
            strcpy((char *)__p[0], "Unexpected number of tuple values.");
            MILToMLIRRewriter::notifyFailure((uint64_t)v119, (uint64_t)v4, (const std::string::value_type *)__p);
          }
          else
          {
            __p[0] = operator new(0x30uLL);
            *(_OWORD *)&__p[1] = xmmword_181286A90;
            strcpy((char *)__p[0], "Expected tuple with num_splits tensor values.");
            MILToMLIRRewriter::notifyFailure((uint64_t)v119, (uint64_t)v4, (const std::string::value_type *)__p);
          }
        }
        else
        {
          __p[0] = operator new(0x78uLL);
          *(_OWORD *)&__p[1] = xmmword_181286A80;
          strcpy((char *)__p[0], "Return types of split must be either a tuple with num_splits tensor values, or num_splits distinct tensor values.");
          MILToMLIRRewriter::notifyFailure((uint64_t)v119, (uint64_t)v4, (const std::string::value_type *)__p);
        }
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
      }
      v38 = 0;
      v116 = v130;
      if (!v130)
        goto LABEL_137;
      goto LABEL_136;
    }
    if (!v10)
    {
      __p[0] = operator new(0x40uLL);
      *(_OWORD *)&__p[1] = xmmword_181286AA0;
      strcpy((char *)__p[0], "Either 'num_splits' or a 'split_sizes' tensor must be provided.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)__p);
      if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
      {
LABEL_92:
        v38 = 0;
        goto LABEL_137;
      }
      v90 = __p[0];
LABEL_91:
      operator delete(v90);
      goto LABEL_92;
    }
    v79 = MIL::IRValue::GetScalar<int>();
    HIBYTE(__p[2]) = 1;
    LOWORD(__p[0]) = 120;
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
    v81 = MIL::IRValueType::AsTensorType(ParameterType);
    v82 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v81 + 96))(v81);
    memset(__p, 0, 24);
    v84 = *(const void **)v82;
    v83 = *(_QWORD *)(v82 + 8);
    v85 = v83 - *(_QWORD *)v82;
    if (v83 == *(_QWORD *)v82)
    {
      v86 = 0;
      v87 = 0;
    }
    else
    {
      if (v85 < 0)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      v86 = (char *)operator new(v83 - *(_QWORD *)v82);
      v87 = &v86[8 * (v85 >> 3)];
      __p[0] = v86;
      __p[2] = v87;
      memcpy(v86, v84, v85);
    }
    v91 = (v87 - v86) >> 3;
    v40 = LocationForOp;
    v92 = v91 & (v9 >> 31);
    v93 = (v92 + v9);
    v39 = v119;
    if (v92 + v9 < 0 || v91 <= v93)
    {
      HIBYTE(__u[5]) = 12;
      strcpy((char *)__u, "Invalid axis");
      MILToMLIRRewriter::notifyFailure((uint64_t)v119, (uint64_t)v4, (const std::string::value_type *)__u);
      if (SHIBYTE(__u[5]) < 0)
        operator delete(*(void **)__u);
    }
    v124 = v93;
    v94 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)&v86[8 * (int)v93] + 16))(*(_QWORD *)&v86[8 * (int)v93]);
    if (!v94)
    {
      *(_QWORD *)__u = operator new(0x30uLL);
      *(_OWORD *)&__u[2] = xmmword_181286A60;
      strcpy(*(char **)__u, "Input shape must be constant along 'axis'.");
      MILToMLIRRewriter::notifyFailure((uint64_t)v119, (uint64_t)v4, (const std::string::value_type *)__u);
      goto LABEL_88;
    }
    v95 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v94 + 48))(v94);
    if (v95 % (unint64_t)v79)
    {
      *(_QWORD *)__u = operator new(0x40uLL);
      *(_OWORD *)&__u[2] = xmmword_18125E6C0;
      strcpy(*(char **)__u, "Input shape must be divisible by 'num_splits' along 'axis'.");
      MILToMLIRRewriter::notifyFailure((uint64_t)v119, (uint64_t)v4, (const std::string::value_type *)__u);
LABEL_88:
      if (SHIBYTE(__u[5]) < 0)
        operator delete(*(void **)__u);
      v90 = v86;
      goto LABEL_91;
    }
    __u[0] = v95 / (unint64_t)v79;
    v123 = v79;
    std::vector<int>::assign(&v133, v79, __u);
    operator delete(v86);
    v130 = 0;
    v131 = 0;
    v132 = 0;
    if (!v79)
    {
      v89 = 0;
      v42 = 0;
      v88 = 1;
      goto LABEL_95;
    }
LABEL_38:
    v41 = 0;
    v42 = 0;
    v43 = 0;
    v44 = (MILToMLIRRewriter *)((char *)v39 + 104);
    v45 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v46 = "Casting.h";
    v47 = "dyn_cast";
    v120 = (MILToMLIRRewriter *)((char *)v39 + 104);
    while (1)
    {
      while (1)
      {
        v48 = v133.__begin_;
        v134 = v40;
        Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v134);
        v50 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
        if (!v51)
        {
          v138 = 1283;
          v137[2] = (uint64_t)"mps.slice";
          v137[3] = 9;
                 "dded by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-wh"
                 "ats-up-with-dialects-management";
          v136 = 259;
          llvm::operator+(v137, (uint64_t *)&v135, (uint64_t)__u);
          llvm::report_fatal_error((llvm::Twine *)__u, 1);
        }
        mlir::OperationState::OperationState(__p, v40, v50);
        mlir::mps::SliceOp::build(v44, (uint64_t *)__p, ArgValue, v124, v41, v48[v43]);
        v52 = mlir::OpBuilder::create(v44, (const mlir::OperationState *)__p);
        if (!v52)
        {
          v118 = 662;
          goto LABEL_146;
        }
        v53 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v52);
        if (!v53)
        {
          v118 = 497;
          v47 = "create";
          v46 = "Builders.h";
          v45 = "result && \"builder didn't return the right type\"";
LABEL_146:
          __assert_rtn(v47, v46, v118, v45);
        }
        mlir::OperationState::~OperationState((mlir::OperationState *)__p);
        if (!*(_DWORD *)(v53 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v54 = v133.__begin_[v43];
        v55 = v53 - 16;
        if (v42 >= v132)
          break;
        *(_QWORD *)v42 = v55;
        v42 += 8;
        v40 = v125;
        v41 += v54;
        v131 = v42;
        if (++v43 == v123)
          goto LABEL_75;
      }
      v56 = v46;
      v57 = v45;
      v58 = (char *)v130;
      v59 = v42 - (_BYTE *)v130;
      v60 = (v42 - (_BYTE *)v130) >> 3;
      v61 = v60 + 1;
      if ((unint64_t)(v60 + 1) >> 61)
        std::vector<long>::__throw_length_error[abi:ne180100]();
      v62 = v132 - (_BYTE *)v130;
      if ((v132 - (_BYTE *)v130) >> 2 > v61)
        v61 = v62 >> 2;
      if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8)
        v63 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v63 = v61;
      v122 = v133.__begin_[v43];
      if (v63)
      {
        if (v63 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v64 = v63;
        v65 = operator new(8 * v63);
        v63 = v64;
        v66 = (uint64_t *)&v65[8 * v60];
        *v66 = v55;
        v67 = (uint64_t)(v66 + 1);
        v68 = v42 - v58;
        if (v42 == v58)
        {
LABEL_59:
          v40 = v125;
          v45 = v57;
          v46 = v56;
          goto LABEL_60;
        }
      }
      else
      {
        v65 = 0;
        v66 = (uint64_t *)(8 * v60);
        *(_QWORD *)(8 * v60) = v55;
        v67 = 8 * v60 + 8;
        v68 = v42 - v58;
        if (v42 == v58)
          goto LABEL_59;
      }
      v69 = v68 - 8;
      v40 = v125;
      if (v69 < 0x168
        || (v72 = (v42 - 8 - v58) & 0xFFFFFFFFFFFFFFF8, &v65[v59 - 8 - v72] > &v65[v59 - 8])
        || &v42[-v72 - 8] > v42 - 8
        || (unint64_t)(v42 - v65 - v59) < 0x20)
      {
        v70 = v42;
        v45 = v57;
        v46 = v56;
      }
      else
      {
        v73 = (v69 >> 3) + 1;
        v74 = 8 * (v73 & 0x3FFFFFFFFFFFFFFCLL);
        v70 = &v42[-v74];
        v66 = (uint64_t *)((char *)v66 - v74);
        v75 = &v65[8 * v60 - 16];
        v76 = v42 - 16;
        v77 = v73 & 0x3FFFFFFFFFFFFFFCLL;
        v46 = v56;
        do
        {
          v78 = *(_OWORD *)v76;
          *(v75 - 1) = *((_OWORD *)v76 - 1);
          *v75 = v78;
          v75 -= 2;
          v76 -= 32;
          v77 -= 4;
        }
        while (v77);
        v45 = v57;
        if (v73 == (v73 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_57;
      }
      do
      {
        v71 = *((_QWORD *)v70 - 1);
        v70 -= 8;
        *--v66 = v71;
      }
      while (v70 != v58);
LABEL_57:
      v42 = (char *)v130;
LABEL_60:
      v47 = "dyn_cast";
      v130 = v66;
      v131 = (char *)v67;
      v132 = &v65[8 * v63];
      v44 = v120;
      if (v42)
        operator delete(v42);
      v42 = (char *)v67;
      v4 = v121;
      v41 += v122;
      v131 = v42;
      if (++v43 == v123)
      {
LABEL_75:
        v88 = 0;
        v89 = v123;
        goto LABEL_95;
      }
    }
  }
  __p[0] = operator new(0x20uLL);
  *(_OWORD *)&__p[1] = xmmword_18125D370;
  strcpy((char *)__p[0], "unexpected type for axis");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)__p);
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  return 0;
}

void sub_180DFD8EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,uint64_t a45,void *__p,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  if (a51 < 0)
    operator delete(__p);
  if (a21)
    operator delete(a21);
  if (!a24)
    _Unwind_Resume(exception_object);
  operator delete(a24);
  _Unwind_Resume(exception_object);
}

void std::vector<int>::assign(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __u)
{
  uint64_t value;
  int *begin;
  int *v8;
  std::vector<int>::size_type v9;
  BOOL v10;
  unint64_t v11;
  uint64_t v12;
  int *v13;
  int *v14;
  std::vector<int>::value_type v15;
  std::vector<int>::size_type v16;
  int *v17;
  std::vector<int>::size_type v18;
  int32x4_t v19;
  int32x4_t *v20;
  uint64_t v21;
  std::vector<int>::pointer end;
  int64_t v23;
  unint64_t v24;
  std::vector<int>::size_type v25;
  float32x4_t v26;
  float32x4_t *v27;
  unint64_t v28;
  BOOL v29;
  std::vector<int>::size_type v30;
  int *v31;
  unint64_t v32;
  std::vector<int>::size_type v33;
  uint64_t v34;
  int *v35;
  float32x4_t v36;
  float32x4_t *v37;
  uint64_t v38;

  value = (uint64_t)this->__end_cap_.__value_;
  begin = this->__begin_;
  v8 = begin;
  if (__n > (value - (uint64_t)begin) >> 2)
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n >> 62)
      goto LABEL_38;
    v9 = value >> 1;
    if (value >> 1 <= __n)
      v9 = __n;
    v10 = (unint64_t)value >= 0x7FFFFFFFFFFFFFFCLL;
    v11 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v10)
      v11 = v9;
    if (v11 >> 62)
LABEL_38:
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v12 = v11;
    v13 = (int *)operator new(4 * v11);
    this->__begin_ = v13;
    this->__end_cap_.__value_ = &v13[v12];
    v14 = &v13[__n];
    v15 = *__u;
    v16 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
    v17 = v13;
    if (v16 < 7)
      goto LABEL_41;
    v18 = v16 + 1;
    v17 = &v13[v18 & 0x7FFFFFFFFFFFFFF8];
    v19 = vdupq_n_s32(v15);
    v20 = (int32x4_t *)(v13 + 4);
    v21 = v18 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v20[-1] = v19;
      *v20 = v19;
      v20 += 2;
      v21 -= 8;
    }
    while (v21);
    if (v18 != (v18 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_41:
      do
        *v17++ = v15;
      while (v17 != v14);
    }
    goto LABEL_37;
  }
  end = this->__end_;
  v23 = (char *)end - (char *)begin;
  v24 = end - begin;
  if (v24 >= __n)
    v25 = __n;
  else
    v25 = end - begin;
  if (v25)
  {
    if (v25 < 8 || begin < __u + 1 && &begin[v25] > __u)
      goto LABEL_42;
    v8 = &begin[v25 & 0xFFFFFFFFFFFFFFF8];
    v26 = vld1q_dup_f32((const float *)__u);
    v27 = (float32x4_t *)(begin + 4);
    v28 = v25 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      v27[-1] = v26;
      *v27 = v26;
      v27 += 2;
      v28 -= 8;
    }
    while (v28);
    v29 = v25 == (v25 & 0xFFFFFFFFFFFFFFF8);
    v25 &= 7u;
    if (!v29)
    {
LABEL_42:
      do
      {
        *v8++ = *__u;
        --v25;
      }
      while (v25);
    }
  }
  v10 = __n >= v24;
  v30 = __n - v24;
  if (v30 == 0 || !v10)
  {
    v14 = &begin[__n];
LABEL_37:
    this->__end_ = v14;
    return;
  }
  v31 = &end[v30];
  v32 = v23 & 0xFFFFFFFFFFFFFFFCLL;
  v33 = 4 * __n - (v23 & 0xFFFFFFFFFFFFFFFCLL) - 4;
  if (v33 < 0x4C || end < __u + 1 && (int *)((char *)&end[__n] - v32) > __u)
    goto LABEL_43;
  v34 = (v33 >> 2) + 1;
  v35 = &end[v34 & 0x7FFFFFFFFFFFFFF8];
  v36 = vld1q_dup_f32((const float *)__u);
  v37 = (float32x4_t *)(end + 4);
  v38 = v34 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    v37[-1] = v36;
    *v37 = v36;
    v37 += 2;
    v38 -= 8;
  }
  while (v38);
  end = v35;
  if (v34 != (v34 & 0x7FFFFFFFFFFFFFF8))
  {
LABEL_43:
    do
      *end++ = *__u;
    while (end != v31);
  }
  this->__end_ = v31;
}

uint64_t MILToMLIR::StackPattern::matchAndRewrite(MILToMLIR::StackPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  MIL::IRValue *ParameterValue;
  MIL::IRValueType *v7;
  uint64_t v8;
  mlir::UnitAttr **v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  mlir::GenericProgramPoint *v13;
  void **v14;
  void **v15;
  uint64_t v16;
  mlir::GenericProgramPoint *v17;
  char *v18;
  _BYTE *v19;
  mlir::UnitAttr **v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _BYTE *v29;
  _QWORD *v30;
  int64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  _OWORD *v37;
  __int128 *v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  void **v43;
  uint64_t v45;
  __int128 *v46;
  char *v47;
  uint64_t *v48;
  void **v49;
  void **v50;
  void *v51;
  const MIL::IROperation *v52;
  MILToMLIRRewriter *v53;
  void *v54;
  void **v55;
  uint64_t v56;
  void *__p;
  __int128 v58;
  uint64_t ArgValue;
  void *v60;
  void **v61;
  __int128 *v62;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  MILToMLIRRewriter::getArgValues((int8x8_t *)a3, a2, "values", &v60);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  HIBYTE(v58) = 4;
  strcpy((char *)&__p, "axis");
  ParameterValue = (MIL::IRValue *)MIL::IROperation::GetParameterValue();
  v7 = (MIL::IRValueType *)(*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)ParameterValue + 32))(ParameterValue);
  v8 = MIL::IRValueType::AsTensorType(v7);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 88))(v8) == 11)
  {
    MIL::IRValue::AsTensor(ParameterValue);
    v9 = a3 + 13;
    v10 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
    v11 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v12 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v11, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v12, v10);
    v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
    if (!*((_DWORD *)v13 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v52 = a2;
    v53 = (MILToMLIRRewriter *)a3;
    v56 = (uint64_t)v13 - 16;
    __p = 0;
    v58 = 0uLL;
    v14 = (void **)v60;
    v15 = v61;
    while (1)
    {
      if (v14 == v15)
      {
        LOBYTE(v54) = 0;
        v45 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>(v9, LocationForOp, (uint64_t *)&__p, &v56, (unsigned __int8 *)&v54);
        (*(void (**)(void **__return_ptr))(*(_QWORD *)v52 + 200))(&v54);
        if (!*(_DWORD *)(v45 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v46 = (__int128 *)v54;
        v47 = (char *)operator new(8uLL);
        *(_QWORD *)v47 = v45 - 16;
        v62 = v46;
        v48 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v53 + 64, (uint64_t)v46, (uint64_t)&std::piecewise_construct, &v62);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v48 + 5, v47, v47 + 8, 1uLL);
        operator delete(v47);
        v49 = (void **)v54;
        if (v54)
        {
          v50 = v55;
          v51 = v54;
          if (v55 != v54)
          {
            do
            {
              if (*((char *)v50 - 1) < 0)
                operator delete(*(v50 - 3));
              v50 -= 3;
            }
            while (v50 != v49);
            v51 = v54;
          }
          v55 = v49;
          operator delete(v51);
        }
        if (__p)
        {
          *(_QWORD *)&v58 = __p;
          operator delete(__p);
        }
        v42 = 1;
        v43 = (void **)v60;
        if (!v60)
          return v42;
LABEL_33:
        v61 = v43;
        operator delete(v43);
        return v42;
      }
      v54 = *v14;
      v17 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, (uint64_t *)&v54, &ArgValue);
      if (!*((_DWORD *)v17 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v18 = (char *)v17 - 16;
      v19 = (_BYTE *)v58;
      if ((unint64_t)v58 < *((_QWORD *)&v58 + 1))
      {
        *(_QWORD *)v58 = v18;
        v16 = (uint64_t)(v19 + 8);
        goto LABEL_5;
      }
      v20 = v9;
      v21 = LocationForOp;
      v22 = __p;
      v23 = v58 - (_QWORD)__p;
      v24 = (uint64_t)(v58 - (_QWORD)__p) >> 3;
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61)
        std::vector<long>::__throw_length_error[abi:ne180100]();
      v26 = *((_QWORD *)&v58 + 1) - (_QWORD)__p;
      if ((uint64_t)(*((_QWORD *)&v58 + 1) - (_QWORD)__p) >> 2 > v25)
        v25 = v26 >> 2;
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
        v27 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v27 = v25;
      if (v27)
      {
        if (v27 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v28 = v27;
        v29 = operator new(8 * v27);
        v27 = v28;
        v30 = &v29[8 * v24];
        *v30 = v18;
        v16 = (uint64_t)(v30 + 1);
        v31 = v19 - v22;
        if (v19 != v22)
        {
LABEL_18:
          v32 = v31 - 8;
          if (v32 < 0x58)
          {
            LocationForOp = v21;
            v9 = v20;
            goto LABEL_27;
          }
          v33 = v19 - &v29[v23];
          LocationForOp = v21;
          v9 = v20;
          if (v33 < 0x20)
            goto LABEL_55;
          v34 = (v32 >> 3) + 1;
          v35 = 8 * (v34 & 0x3FFFFFFFFFFFFFFCLL);
          v36 = &v19[-v35];
          v30 = (_QWORD *)((char *)v30 - v35);
          v37 = &v29[8 * v24 - 16];
          v38 = (__int128 *)(v19 - 16);
          v39 = v34 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v40 = *v38;
            *(v37 - 1) = *(v38 - 1);
            *v37 = v40;
            v37 -= 2;
            v38 -= 2;
            v39 -= 4;
          }
          while (v39);
          v19 = v36;
          if (v34 != (v34 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_55:
            do
            {
LABEL_27:
              v41 = *((_QWORD *)v19 - 1);
              v19 -= 8;
              *--v30 = v41;
            }
            while (v19 != v22);
          }
          v19 = __p;
          __p = v30;
          *(_QWORD *)&v58 = v16;
          *((_QWORD *)&v58 + 1) = &v29[8 * v27];
          if (!v19)
            goto LABEL_5;
LABEL_29:
          operator delete(v19);
          goto LABEL_5;
        }
      }
      else
      {
        v29 = 0;
        v30 = (_QWORD *)(8 * v24);
        *(_QWORD *)(8 * v24) = v18;
        v16 = 8 * v24 + 8;
        v31 = v19 - v22;
        if (v19 != v22)
          goto LABEL_18;
      }
      LocationForOp = v21;
      v9 = v20;
      __p = v30;
      *(_QWORD *)&v58 = v16;
      *((_QWORD *)&v58 + 1) = &v29[8 * v27];
      if (v19)
        goto LABEL_29;
LABEL_5:
      *(_QWORD *)&v58 = v16;
      ++v14;
    }
  }
  __p = operator new(0x20uLL);
  v58 = xmmword_18125D370;
  strcpy((char *)__p, "unexpected type for axis");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v58) < 0)
    operator delete(__p);
  v42 = 0;
  v43 = (void **)v60;
  if (v60)
    goto LABEL_33;
  return v42;
}

void sub_180DFE1A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24)
{
  if (__p)
    operator delete(__p);
  if (a23)
    operator delete(a23);
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::InversePattern::matchAndRewrite(MILToMLIR::InversePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  mlir::MLIRContext *v7;
  uint64_t v8;
  uint64_t *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v12;
  mlir::GenericProgramPoint *v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  mlir::GenericProgramPoint *v21;
  void *__p;
  __int128 v23;
  uint64_t OptionalArgValue;
  uint64_t v25;
  __int128 *v26;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v25 = ArgValue;
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "epsilon");
  if (!OptionalArgValue)
  {
    v8 = mlir::Float32Type::get(a3[13], v7);
    __p = (void *)1;
    v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v8, 0);
    __p = (void *)mlir::mps::getConstantAttr<double>(v9, 0.0001);
    v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
    if (!*((_DWORD *)v10 + 9))
      goto LABEL_19;
    OptionalArgValue = (uint64_t)v10 - 16;
  }
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
  v12 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &OptionalArgValue, (uint64_t *)&__p);
  if (!*((_DWORD *)v12 + 9))
LABEL_19:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  OptionalArgValue = (uint64_t)v12 - 16;
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v21 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &v25, &OptionalArgValue);
    v13 = mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v21);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v13 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v14 = (__int128 *)__p;
    v15 = (char *)operator new(8uLL);
    *(_QWORD *)v15 = (char *)v13 - 16;
    v26 = v14;
    v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, &v26);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
    operator delete(v15);
    v17 = (void **)__p;
    if (__p)
    {
      v18 = (void **)v23;
      v19 = __p;
      if ((void *)v23 != __p)
      {
        do
        {
          if (*((char *)v18 - 1) < 0)
            operator delete(*(v18 - 3));
          v18 -= 3;
        }
        while (v18 != v17);
        v19 = __p;
      }
      *(_QWORD *)&v23 = v17;
      operator delete(v19);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v23 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v23) < 0)
      operator delete(__p);
    return 0;
  }
}

void sub_180DFE4F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::LogarithmPattern::matchAndRewrite(MILToMLIR::LogarithmPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  mlir::MLIRContext *v7;
  uint64_t v8;
  uint64_t *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v12;
  mlir::GenericProgramPoint *v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  mlir::GenericProgramPoint *v21;
  void *__p;
  __int128 v23;
  uint64_t OptionalArgValue;
  uint64_t v25;
  __int128 *v26;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v25 = ArgValue;
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "epsilon");
  if (!OptionalArgValue)
  {
    v8 = mlir::Float32Type::get(a3[13], v7);
    __p = (void *)1;
    v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v8, 0);
    __p = (void *)mlir::mps::getConstantAttr<double>(v9, 1.0e-45);
    v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
    if (!*((_DWORD *)v10 + 9))
      goto LABEL_19;
    OptionalArgValue = (uint64_t)v10 - 16;
  }
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
  v12 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &OptionalArgValue, (uint64_t *)&__p);
  if (!*((_DWORD *)v12 + 9))
LABEL_19:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  OptionalArgValue = (uint64_t)v12 - 16;
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v21 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &v25, &OptionalArgValue);
    v13 = mlir::OpBuilder::create<mlir::mps::LogarithmOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v21);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v13 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v14 = (__int128 *)__p;
    v15 = (char *)operator new(8uLL);
    *(_QWORD *)v15 = (char *)v13 - 16;
    v26 = v14;
    v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, &v26);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
    operator delete(v15);
    v17 = (void **)__p;
    if (__p)
    {
      v18 = (void **)v23;
      v19 = __p;
      if ((void *)v23 != __p)
      {
        do
        {
          if (*((char *)v18 - 1) < 0)
            operator delete(*(v18 - 3));
          v18 -= 3;
        }
        while (v18 != v17);
        v19 = __p;
      }
      *(_QWORD *)&v23 = v17;
      operator delete(v19);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v23 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v23) < 0)
      operator delete(__p);
    return 0;
  }
}

void sub_180DFE7FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::RsqrtPattern::matchAndRewrite(MILToMLIR::RsqrtPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  mlir::MLIRContext *v7;
  uint64_t v8;
  uint64_t *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v12;
  mlir::GenericProgramPoint *v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  mlir::GenericProgramPoint *v21;
  void *__p;
  __int128 v23;
  uint64_t OptionalArgValue;
  uint64_t v25;
  __int128 *v26;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v25 = ArgValue;
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "epsilon");
  if (!OptionalArgValue)
  {
    v8 = mlir::Float32Type::get(a3[13], v7);
    __p = (void *)1;
    v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v8, 0);
    __p = (void *)mlir::mps::getConstantAttr<double>(v9, 1.0e-12);
    v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
    if (!*((_DWORD *)v10 + 9))
      goto LABEL_19;
    OptionalArgValue = (uint64_t)v10 - 16;
  }
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
  v12 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &OptionalArgValue, (uint64_t *)&__p);
  if (!*((_DWORD *)v12 + 9))
LABEL_19:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  OptionalArgValue = (uint64_t)v12 - 16;
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v21 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &v25, &OptionalArgValue);
    v13 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v21);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v13 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v14 = (__int128 *)__p;
    v15 = (char *)operator new(8uLL);
    *(_QWORD *)v15 = (char *)v13 - 16;
    v26 = v14;
    v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, &v26);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
    operator delete(v15);
    v17 = (void **)__p;
    if (__p)
    {
      v18 = (void **)v23;
      v19 = __p;
      if ((void *)v23 != __p)
      {
        do
        {
          if (*((char *)v18 - 1) < 0)
            operator delete(*(v18 - 3));
          v18 -= 3;
        }
        while (v18 != v17);
        v19 = __p;
      }
      *(_QWORD *)&v23 = v17;
      operator delete(v19);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v23 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v23) < 0)
      operator delete(__p);
    return 0;
  }
}

void sub_180DFEB00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::Range1dPattern::matchAndRewrite(MILToMLIR::Range1dPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  uint64_t *v7;
  mlir::GenericProgramPoint *v8;
  mlir::GenericProgramPoint *v9;
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t IntegerType;
  uint64_t **v20;
  uint64_t InterfaceFor;
  void *v22;
  mlir::GenericProgramPoint *v23;
  mlir::GenericProgramPoint *v24;
  uint64_t v25;
  mlir::GenericProgramPoint *v26;
  mlir::GenericProgramPoint *v27;
  mlir::GenericProgramPoint *v28;
  __int128 *v29;
  char *v30;
  uint64_t *v31;
  void **v32;
  void **v33;
  void *v34;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  uint64_t v40;
  uint64_t ElementTypeOrSelf;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t ArgValue;
  uint64_t v46;
  uint64_t v47[4];
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  __int128 *v51[5];
  void *__p;
  void **v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "start");
  v44 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "end");
  v43 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "step");
  v6 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &v44, &ArgValue);
  if (!*((_DWORD *)v6 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v42 = (uint64_t)v6 - 16;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v6 - 16);
  if (mlir::Type::isIntOrIndex((mlir::Type *)&ElementTypeOrSelf))
  {
    __p = (void *)1;
    v7 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v7, 1);
    v8 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
    v9 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &v42, &v43);
    if (!*((_DWORD *)v9 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v46 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v46);
    v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
    if (!v12)
    {
      v50 = 1283;
      v49[2] = (uint64_t)"mps.subtract";
      v49[3] = 12;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v48 = 259;
      llvm::operator+(v49, v47, (uint64_t)v51);
      llvm::report_fatal_error((llvm::Twine *)v51, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v11);
    if (!*((_DWORD *)v8 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, (uint64_t)v9 - 16, (uint64_t)v8 - 16);
    v13 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v13)
    {
      v14 = llvm::DefaultDoCastIfPossible<mlir::mps::SubtractOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SubtractOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
      if (v14)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (!*(_DWORD *)(v14 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        __p = (void *)(v14 - 16);
        v15 = mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, (uint64_t *)&__p, &v43);
        if (!*((_DWORD *)v15 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        goto LABEL_14;
      }
      v36 = "result && \"builder didn't return the right type\"";
      v37 = 497;
      v38 = "Builders.h";
      v39 = "create";
    }
    else
    {
      v36 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v37 = 662;
      v38 = "Casting.h";
      v39 = "dyn_cast";
    }
    __assert_rtn(v39, v38, v37, v36);
  }
  v16 = mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &v42, &v43);
  if (!*((_DWORD *)v16 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  __p = (char *)v16 - 16;
  v17 = mlir::OpBuilder::create<mlir::mps::CeilOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t *)&__p);
  if (!*(_DWORD *)(v17 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v51[0] = (__int128 *)(v17 - 16);
  v18 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
  v49[0] = mlir::TypeAttr::get(v18);
  v15 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, (uint64_t *)v51, v49);
  if (!*((_DWORD *)v15 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_14:
  v40 = (uint64_t)v15 - 16;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v20 = (uint64_t **)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20))
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  if (v20)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20);
    if (!InterfaceFor)
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  }
  else
  {
    InterfaceFor = 0;
  }
  LODWORD(v51[0]) = 0;
  v22 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v20, InterfaceFor, v51, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v22) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  __p = v22;
  v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v23 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v49[0] = (uint64_t)v23 - 16;
  v24 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>((uint64_t *)a3 + 13, LocationForOp, &v40, v49);
  if (!*((_DWORD *)v24 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v47[0] = (uint64_t)v24 - 16;
  v25 = mlir::getElementTypeOrSelf((uint64_t)v24 - 16);
  if (ElementTypeOrSelf != v25)
  {
    v26 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 13, LocationForOp, v47, &ElementTypeOrSelf);
    if (!*((_DWORD *)v26 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v47[0] = (uint64_t)v26 - 16;
  }
  v27 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &v43, v47);
  if (!*((_DWORD *)v27 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v46 = (uint64_t)v27 - 16;
  v28 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &v46, &ArgValue);
  if (!*((_DWORD *)v28 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
  v29 = (__int128 *)__p;
  v30 = (char *)operator new(8uLL);
  *(_QWORD *)v30 = (char *)v28 - 16;
  v51[0] = v29;
  v31 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v29, (uint64_t)&std::piecewise_construct, v51);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v31 + 5, v30, v30 + 8, 1uLL);
  operator delete(v30);
  v32 = (void **)__p;
  if (__p)
  {
    v33 = v53;
    v34 = __p;
    if (v53 != __p)
    {
      do
      {
        if (*((char *)v33 - 1) < 0)
          operator delete(*(v33 - 3));
        v33 -= 3;
      }
      while (v33 != v32);
      v34 = __p;
    }
    v53 = v32;
    operator delete(v34);
  }
  return 1;
}

void sub_180DFF27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  std::vector<std::string>::~vector[abi:ne180100](&a32);
  _Unwind_Resume(a1);
}

void sub_180DFF290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  void *v32;

  operator delete(v32);
  std::vector<std::string>::~vector[abi:ne180100](&a32);
  _Unwind_Resume(a1);
}

void sub_180DFF2AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

void sub_180DFF2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CeilOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.ceil", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.ceil";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::CeilOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CeilOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DFF448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180DFF460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::RandomPattern::matchAndRewrite(MILToMLIR::RandomPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  mlir::OpBuilder *v13;
  uint64_t IntegerType;
  uint64_t **v15;
  uint64_t InterfaceFor;
  void *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v19;
  uint64_t **v20;
  uint64_t v21;
  void *v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v24;
  uint64_t **v25;
  uint64_t v26;
  void *v27;
  mlir::GenericProgramPoint *v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  int64_t size;
  std::string *v33;
  char *v34;
  int64_t v35;
  std::string *v36;
  char *v37;
  uint64_t ElementTypeOrSelf;
  int v40;
  int64_t v41;
  std::string *v42;
  char *v43;
  mlir::MLIRContext *v44;
  uint64_t v46;
  uint64_t *v47;
  mlir::GenericProgramPoint *v48;
  mlir::MLIRContext *v49;
  uint64_t v50;
  uint64_t *v51;
  mlir::GenericProgramPoint *v52;
  uint64_t v53;
  uint64_t *v54;
  mlir::GenericProgramPoint *v55;
  uint64_t *v56;
  mlir::GenericProgramPoint *v57;
  mlir::GenericProgramPoint *v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  char v62;
  mlir::GenericProgramPoint *v63;
  uint64_t v64;
  std::string *v65;
  char *v66;
  uint64_t ParameterValue;
  float *v69;
  float v70;
  int *v71;
  MIL::Fp16 *v72;
  float v73;
  uint64_t v74;
  float *v75;
  float v76;
  int *v77;
  MIL::Fp16 *v78;
  float v79;
  uint64_t v80;
  uint64_t v81;
  llvm::APFloatBase *v82;
  void *v83;
  uint64_t *Context;
  uint64_t v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  void *v89;
  llvm::APFloatBase *v90;
  void *v91;
  uint64_t v92;
  mlir::GenericProgramPoint *v93;
  uint64_t v94;
  __int128 *v95;
  uint64_t v96;
  char *v97;
  uint64_t *v98;
  void **v99;
  void **v100;
  void *v101;
  uint64_t v102;
  const char *v104;
  int v105;
  const char *v106;
  const char *v107;
  const char *v108;
  int v109;
  const char *v110;
  const char *v111;
  MILToMLIRRewriter *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  std::string v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t ArgValue;
  uint64_t v122;
  uint64_t v123[4];
  __int16 v124;
  uint64_t v125;
  void *v126;
  uint64_t v127;
  uint64_t v128;
  void *v129;
  uint64_t v130;
  void *__p;
  void **v132;
  char v133;
  const char *v134;
  void *v135;
  const char *v136;
  uint64_t v137;
  __int16 v138;
  uint64_t v139;
  void *v140;
  _QWORD v141[5];

  v141[3] = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "shape");
  v133 = 4;
  strcpy((char *)&__p, "seed");
  MIL::IROperation::TryGetParameterValue();
  v6 = MIL::IRValue::GetScalar<int>();
  v112 = (MILToMLIRRewriter *)a3;
  srand48(v6);
  v7 = mrand48();
  v8 = mrand48();
  v9 = mrand48();
  v10 = mrand48();
  v11 = mrand48();
  v12 = mrand48();
  v13 = (mlir::OpBuilder *)(a3 + 13);
  v139 = 1;
  IntegerType = mlir::Builder::getIntegerType((MILToMLIRRewriter *)((char *)v112 + 104), 0x40u, 1);
  v15 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v139, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v15))
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  if (v15)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v15);
    if (!InterfaceFor)
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  }
  else
  {
    InterfaceFor = 0;
  }
  v134 = (const char *)(v8 | (unint64_t)(v7 << 32));
  v17 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v15, InterfaceFor, &v134, 8, 8, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v17) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  __p = v17;
  v18 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v18 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v120 = (uint64_t)v18 - 16;
  v139 = 1;
  v19 = mlir::Builder::getIntegerType(v13, 0x40u, 1);
  v20 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v139, 1, v19, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20))
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  if (v20)
  {
    v21 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v20);
    if (!v21)
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  }
  else
  {
    v21 = 0;
  }
  v134 = (const char *)(v10 | (unint64_t)(v9 << 32));
  v22 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v20, v21, &v134, 8, 8, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v22) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  __p = v22;
  v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v23 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v119 = (uint64_t)v23 - 16;
  v139 = 1;
  v24 = mlir::Builder::getIntegerType(v13, 0x40u, 1);
  v25 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v139, 1, v24, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v25))
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  if (v25)
  {
    v26 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v25);
    if (!v26)
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  }
  else
  {
    v26 = 0;
  }
  v134 = (const char *)(v12 | (unint64_t)(v11 << 32));
  v27 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v25, v26, &v134, 8, 8, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v27) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  __p = v27;
  v28 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v28 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v118 = (uint64_t)v28 - 16;
  v29 = mlir::OpBuilder::create<mlir::mps::InitRandomPhiloxStateOp,mlir::Value &,mlir::Value &,mlir::Value &>((uint64_t *)v13, LocationForOp, &v120, &v119, &v118);
  if (!*(_DWORD *)(v29 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v117 = v29 - 16;
  v30 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
  if (*(char *)(v30 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v116, *(const std::string::value_type **)v30, *(_QWORD *)(v30 + 8));
  }
  else
  {
    v31 = *(_OWORD *)v30;
    v116.__r_.__value_.__r.__words[2] = *(_QWORD *)(v30 + 16);
    *(_OWORD *)&v116.__r_.__value_.__l.__data_ = v31;
  }
  v115 = 0;
  if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v116.__r_.__value_.__r.__words[2]);
  else
    size = v116.__r_.__value_.__l.__size_;
  if ((v116.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v33 = &v116;
  else
    v33 = (std::string *)v116.__r_.__value_.__r.__words[0];
  v34 = (char *)v33 + size;
  if (size <= 13)
    goto LABEL_69;
  v35 = size;
  v36 = v33;
  while (1)
  {
    v37 = (char *)memchr(v36, 114, v35 - 13);
    if (!v37)
      goto LABEL_44;
    if (*(_QWORD *)v37 == 0x755F6D6F646E6172 && *(_QWORD *)(v37 + 6) == 0x6D726F66696E755FLL)
      break;
    v36 = (std::string *)(v37 + 1);
    v35 = v34 - (char *)v36;
    if (v34 - (char *)v36 < 14)
      goto LABEL_44;
  }
  if (v37 != v34 && v37 - (char *)v33 != -1)
  {
    v125 = 0;
    v122 = 0;
    v113 = 0;
    v114 = 0;
    v125 = MILToMLIRRewriter::getArgValue((int8x8_t *)v112, a2, "low");
    v122 = MILToMLIRRewriter::getArgValue((int8x8_t *)v112, a2, "high");
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(v125);
    v40 = 0;
    goto LABEL_58;
  }
LABEL_44:
  if (size < 16)
    goto LABEL_69;
  v41 = size;
  v42 = v33;
  while (1)
  {
    v43 = (char *)memchr(v42, 114, v41 - 15);
    if (!v43)
      goto LABEL_69;
    if (*(_QWORD *)v43 == 0x625F6D6F646E6172 && *((_QWORD *)v43 + 1) == 0x696C6C756F6E7265)
      break;
    v42 = (std::string *)(v43 + 1);
    v41 = v34 - (char *)v42;
    if (v34 - (char *)v42 < 16)
      goto LABEL_69;
  }
  if (v43 == v34 || v43 - (char *)v33 == -1)
  {
LABEL_69:
    if (size < 13)
      goto LABEL_116;
    v65 = v33;
    while (1)
    {
      v66 = (char *)memchr(v65, 114, size - 12);
      if (!v66)
        goto LABEL_116;
      if (*(_QWORD *)v66 == 0x6E5F6D6F646E6172 && *(_QWORD *)(v66 + 5) == 0x6C616D726F6E5F6DLL)
        break;
      v65 = (std::string *)(v66 + 1);
      size = v34 - (char *)v65;
      if (v34 - (char *)v65 < 13)
        goto LABEL_116;
    }
    if (v66 == v34 || v66 - (char *)v33 == -1)
      goto LABEL_116;
    v133 = 4;
    strcpy((char *)&__p, "mean");
    ParameterValue = MIL::IROperation::GetParameterValue();
    if (v133 < 0)
      operator delete(__p);
    v69 = (float *)MEMORY[0x186DA1188](ParameterValue);
    if (v69)
    {
      v70 = *v69;
    }
    else
    {
      v71 = (int *)MEMORY[0x186DA1194](ParameterValue);
      if (v71)
      {
        v70 = (float)*v71;
      }
      else
      {
        v72 = (MIL::Fp16 *)MEMORY[0x186DA117C](ParameterValue);
        if (!v72)
        {
          std::string::basic_string[abi:ne180100]<0>(&__p, "unexpected type for mean");
          MILToMLIRRewriter::notifyFailure((uint64_t)v112, (uint64_t)a2, (const std::string::value_type *)&__p);
          goto LABEL_129;
        }
        MIL::Fp16::GetFloat(v72);
        v70 = v73;
      }
    }
    v133 = 6;
    strcpy((char *)&__p, "stddev");
    v74 = MIL::IROperation::GetParameterValue();
    if (v133 < 0)
      operator delete(__p);
    v75 = (float *)MEMORY[0x186DA1188](v74);
    if (v75)
    {
      v76 = *v75;
      goto LABEL_96;
    }
    v77 = (int *)MEMORY[0x186DA1194](v74);
    if (v77)
    {
      v76 = (float)*v77;
      goto LABEL_96;
    }
    v78 = (MIL::Fp16 *)MEMORY[0x186DA117C](v74);
    if (v78)
    {
      MIL::Fp16::GetFloat(v78);
      v76 = v79;
LABEL_96:
      v80 = MILToMLIRRewriter::getArgValue((int8x8_t *)v112, a2, "mean");
      v81 = mlir::getElementTypeOrSelf(v80);
      v82 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&__p, v70);
      v83 = llvm::APFloatBase::IEEEsingle(v82);
      llvm::APFloat::Storage::Storage(&v129, &__p, v83);
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p);
      llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&__p, v76);
      llvm::APFloat::Storage::Storage(&v126, &__p, v83);
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p);
      v122 = LocationForOp;
      Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v122);
      v85 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_normal", (const unsigned __int8 *)0x11, Context);
      if (!v86)
      {
        v138 = 1283;
        v136 = "mps.random_normal";
        v137 = 17;
                           "n't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered"
                           "-loaded-dependent-whats-up-with-dialects-management";
        v124 = 259;
        llvm::operator+((uint64_t *)&v134, v123, (uint64_t)&v139);
        llvm::report_fatal_error((llvm::Twine *)&v139, 1);
      }
      mlir::OperationState::OperationState(&__p, LocationForOp, v85);
      v87 = v117;
      v88 = ArgValue;
      v89 = v129;
      v91 = llvm::APFloatBase::PPCDoubleDouble(v90);
      if (v91 == v89)
      {
        v92 = v81;
        llvm::detail::DoubleAPFloat::DoubleAPFloat(&v140, &v129);
      }
      else
      {
        v92 = v81;
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v140, (uint64_t)&v129);
      }
      if (v91 == v126)
        llvm::detail::DoubleAPFloat::DoubleAPFloat(&v135, &v126);
      else
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v135, (uint64_t)&v126);
      mlir::mps::RandomNormalOp::build((mlir::Float32Type **)v13, (uint64_t)&__p, v87, v88, v92, (uint64_t)&v139, (uint64_t)&v134, 0);
      if (v91 == v135)
      {
        std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v136);
        if (v91 != v140)
          goto LABEL_105;
      }
      else
      {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v135);
        if (v91 != v140)
        {
LABEL_105:
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v140);
          goto LABEL_108;
        }
      }
      std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v141);
LABEL_108:
      v93 = mlir::OpBuilder::create(v13, (const mlir::OperationState *)&__p);
      if (v93)
      {
        v94 = llvm::DefaultDoCastIfPossible<mlir::mps::RandomNormalOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RandomNormalOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v93);
        if (v94)
        {
          mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
          if (!*(_DWORD *)(v94 + 36))
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          v115 = v94 - 16;
          if (v91 == v126)
          {
            std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v127);
            if (v91 != v129)
              goto LABEL_113;
          }
          else
          {
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v126);
            if (v91 != v129)
            {
LABEL_113:
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v129);
              goto LABEL_116;
            }
          }
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v130);
          goto LABEL_116;
        }
        v104 = "result && \"builder didn't return the right type\"";
        v105 = 497;
        v106 = "Builders.h";
        v107 = "create";
      }
      else
      {
        v104 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
        v105 = 662;
        v106 = "Casting.h";
        v107 = "dyn_cast";
      }
      __assert_rtn(v107, v106, v105, v104);
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, "unexpected type for stddev");
    MILToMLIRRewriter::notifyFailure((uint64_t)v112, (uint64_t)a2, (const std::string::value_type *)&__p);
LABEL_129:
    if (v133 < 0)
      operator delete(__p);
    v102 = 0;
    if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_125;
    return v102;
  }
  v125 = 0;
  v122 = 0;
  v113 = 0;
  v114 = 0;
  v46 = mlir::Float16Type::get(*(mlir::Float16Type **)v13, v44);
  __p = (void *)1;
  v47 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v46, 0);
  __p = (void *)mlir::mps::getConstantAttr<float>(v47, 0.0);
  v48 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v48 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v125 = (uint64_t)v48 - 16;
  v50 = mlir::Float16Type::get(*(mlir::Float16Type **)v13, v49);
  __p = (void *)1;
  v51 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v50, 0);
  __p = (void *)mlir::mps::getConstantAttr<float>(v51, 1.0);
  v52 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v52 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v122 = (uint64_t)v52 - 16;
  v114 = MILToMLIRRewriter::getArgValue((int8x8_t *)v112, a2, "prob");
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v114);
  v40 = 1;
LABEL_58:
  v113 = ElementTypeOrSelf;
  v53 = mlir::OpBuilder::create<mlir::mps::RandomUniformOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type &>(v13, LocationForOp, &v117, &ArgValue, &v125, &v122, &v113);
  if (!*(_DWORD *)(v53 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v115 = v53 - 16;
  if (v40)
  {
    __p = (void *)1;
    v54 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v113, 0);
    __p = (void *)mlir::mps::getConstantAttr<float>(v54, 0.0);
    v55 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
    __p = (void *)1;
    v56 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v113, 0);
    __p = (void *)mlir::mps::getConstantAttr<float>(v56, 1.0);
    v57 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v13, LocationForOp, (uint64_t **)&__p);
    v58 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v13, LocationForOp, &v115, &v113);
    if (!*((_DWORD *)v58 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v115 = (uint64_t)v58 - 16;
    v59 = mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>(v13, LocationForOp, &v115, &v114);
    v128 = LocationForOp;
    v60 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v128);
    v61 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v60);
    if (!v62)
    {
      v138 = 1283;
      v136 = "mps.select";
      v137 = 10;
                         "t been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loa"
                         "ded-dependent-whats-up-with-dialects-management";
      v124 = 259;
      llvm::operator+((uint64_t *)&v134, v123, (uint64_t)&v139);
      llvm::report_fatal_error((llvm::Twine *)&v139, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v61);
    if (!*(_DWORD *)(v59 + 36) || !*((_DWORD *)v57 + 9) || !*((_DWORD *)v55 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::SelectOp::build((uint64_t)v13, (uint64_t)&__p, v59 - 16, (uint64_t)v57 - 16, (uint64_t)v55 - 16);
    v63 = mlir::OpBuilder::create(v13, (const mlir::OperationState *)&__p);
    if (v63)
    {
      v64 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v63);
      if (v64)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (!*(_DWORD *)(v64 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v115 = v64 - 16;
        goto LABEL_116;
      }
      v108 = "result && \"builder didn't return the right type\"";
      v109 = 497;
      v110 = "Builders.h";
      v111 = "create";
    }
    else
    {
      v108 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v109 = 662;
      v110 = "Casting.h";
      v111 = "dyn_cast";
    }
    __assert_rtn(v111, v110, v109, v108);
  }
LABEL_116:
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
  v95 = (__int128 *)__p;
  v96 = v115;
  v97 = (char *)operator new(8uLL);
  *(_QWORD *)v97 = v96;
  v139 = (uint64_t)v95;
  v98 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v112 + 64, (uint64_t)v95, (uint64_t)&std::piecewise_construct, (__int128 **)&v139);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v98 + 5, v97, v97 + 8, 1uLL);
  operator delete(v97);
  v99 = (void **)__p;
  if (__p)
  {
    v100 = v132;
    v101 = __p;
    if (v132 != __p)
    {
      do
      {
        if (*((char *)v100 - 1) < 0)
          operator delete(*(v100 - 3));
        v100 -= 3;
      }
      while (v100 != v99);
      v101 = __p;
    }
    v132 = v99;
    operator delete(v101);
  }
  v102 = 1;
  if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
LABEL_125:
    operator delete(v116.__r_.__value_.__l.__data_);
  return v102;
}

void sub_180E004A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a43 < 0)
    operator delete(__p);
  if (a18 < 0)
  {
    operator delete(a13);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::InitRandomPhiloxStateOp,mlir::Value &,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.init_random_philox_state", (const unsigned __int8 *)0x1C, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.init_random_philox_state";
    v23[3] = 28;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::InitRandomPhiloxStateOp::build(a1, (uint64_t)v26, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::InitRandomPhiloxStateOp,mlir::Operation *,llvm::CastInfo<mlir::mps::InitRandomPhiloxStateOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E00798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E007B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::RandomUniformOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v18;
  const char *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _BYTE v29[40];
  _QWORD v30[39];

  v30[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_uniform", (const unsigned __int8 *)0x12, Context);
  if (!v16)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mps.random_uniform";
    v27[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v15);
  mlir::mps::RandomUniformOp::build((uint64_t)a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (!v17)
  {
    v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v21 = 662;
    v22 = "Casting.h";
    v23 = "dyn_cast";
    goto LABEL_8;
  }
  v18 = llvm::DefaultDoCastIfPossible<mlir::mps::RandomUniformOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RandomUniformOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    v20 = "result && \"builder didn't return the right type\"";
    v21 = 497;
    v22 = "Builders.h";
    v23 = "create";
LABEL_8:
    __assert_rtn(v23, v22, v21, v20);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v18;
}

void sub_180E00964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0097C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.less", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.less";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::LessThanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LessThanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E00B08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E00B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::ReversePattern::matchAndRewrite(MILToMLIR::ReversePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  void *__p;
  void **v15;
  uint64_t OptionalArgValue;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "axes");
  if (OptionalArgValue)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &OptionalArgValue);
    if (*(_DWORD *)(v6 + 36))
      goto LABEL_3;
LABEL_13:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  v6 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t)&ArgValue);
  if (!*(_DWORD *)(v6 + 36))
    goto LABEL_13;
LABEL_3:
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
  v7 = (__int128 *)__p;
  v8 = (char *)operator new(8uLL);
  *(_QWORD *)v8 = v6 - 16;
  v18 = v7;
  v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
  operator delete(v8);
  v10 = (void **)__p;
  if (__p)
  {
    v11 = v15;
    v12 = __p;
    if (v15 != __p)
    {
      do
      {
        if (*((char *)v11 - 1) < 0)
          operator delete(*(v11 - 3));
        v11 -= 3;
      }
      while (v11 != v10);
      v12 = __p;
    }
    v15 = v10;
    operator delete(v12);
  }
  return 1;
}

void sub_180E00CB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void sub_180E00CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  void *v10;

  operator delete(v10);
  std::vector<std::string>::~vector[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reverse", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.reverse";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ReverseOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::ReverseOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReverseOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E00E5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E00E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reverse", (const unsigned __int8 *)0xB, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reverse";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ReverseOp::build((uint64_t)a1, (uint64_t)v22, a3, 1, 0, 0);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ReverseOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReverseOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E01004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0101C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::Flatten2DPattern::matchAndRewrite(MILToMLIR::Flatten2DPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t IntegerType;
  uint64_t **v7;
  uint64_t InterfaceFor;
  void *v9;
  mlir::GenericProgramPoint *v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  __int128 *v13;
  char *v14;
  uint64_t *v15;
  void **v16;
  void **v17;
  void *v18;
  uint64_t v20;
  void *__p;
  void **v22;
  char v23;
  int v24;
  uint64_t ArgValue;
  __int128 *v26;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v24 = 1;
  v23 = 4;
  strcpy((char *)&__p, "axis");
  if (MIL::IROperation::TryGetParameterValue())
    v24 = MIL::IRValue::GetScalar<int>();
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v7 = (uint64_t **)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v7))
    goto LABEL_20;
  if (v7)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v7);
    if (!InterfaceFor)
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  }
  else
  {
    InterfaceFor = 0;
  }
  v9 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v7, InterfaceFor, &v24, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v9) & 1) == 0)
LABEL_20:
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  __p = v9;
  v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
  if (!*((_DWORD *)v10 + 9)
    || (v20 = (uint64_t)v10 - 16,
        v11 = mlir::OpBuilder::create<mlir::mps::Flatten2DOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v20), !*((_DWORD *)v11 + 9)))
  {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  v12 = v11;
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
  v13 = (__int128 *)__p;
  v14 = (char *)operator new(8uLL);
  *(_QWORD *)v14 = (char *)v12 - 16;
  v26 = v13;
  v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v13, (uint64_t)&std::piecewise_construct, &v26);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v15 + 5, v14, v14 + 8, 1uLL);
  operator delete(v14);
  v16 = (void **)__p;
  if (__p)
  {
    v17 = v22;
    v18 = __p;
    if (v22 != __p)
    {
      do
      {
        if (*((char *)v17 - 1) < 0)
          operator delete(*(v17 - 3));
        v17 -= 3;
      }
      while (v17 != v16);
      v18 = __p;
    }
    v22 = v16;
    operator delete(v18);
  }
  return 1;
}

void sub_180E012AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  std::vector<std::string>::~vector[abi:ne180100](&__p);
  _Unwind_Resume(a1);
}

BOOL MILToMLIR::TopKPattern::matchAndRewrite(MILToMLIR::TopKPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  std::string::size_type LocationForOp;
  uint64_t ArgValue;
  unsigned int v7;
  int v8;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v10;
  uint64_t v11;
  char v13;
  uint64_t v14;
  uint64_t *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v17;
  char IntOrFloatBitWidth;
  uint64_t **v19;
  uint64_t InterfaceFor;
  const char *v21;
  unint64_t v22;
  void *v23;
  uint64_t v24;
  std::string *v25;
  std::string *v26;
  std::string::size_type v27;
  void *v28;
  llvm::APFloatBase *v29;
  std::string *v30;
  std::string *v31;
  std::string::size_type v32;
  void *v33;
  llvm::APFloatBase *v34;
  void *v35;
  mlir::GenericProgramPoint *v36;
  mlir::GenericProgramPoint *v37;
  uint64_t IntegerType;
  uint64_t *v39;
  mlir::GenericProgramPoint *v40;
  uint64_t *Context;
  uint64_t v42;
  char v43;
  mlir::GenericProgramPoint *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t OutputType;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t ParameterValue;
  uint64_t v54;
  void *v55;
  const char *v56;
  char *v57;
  uint64_t *v58;
  void **v59;
  void **v60;
  void *v61;
  char v62;
  void **v63;
  mlir::GenericProgramPoint *v64;
  void *v65;
  const char *v66;
  char *v67;
  char *v68;
  uint64_t *v69;
  void *v70;
  std::string::size_type v71;
  char *v72;
  uint64_t *v73;
  void **v74;
  _BOOL8 isF16;
  void *v82;
  std::string *v84;
  std::string::size_type size;
  std::string *v86;
  std::string::size_type v87;
  void *v88;
  void *v89;
  const char *v90;
  int v91;
  const char *v92;
  const char *v93;
  unsigned int v94;
  _BOOL4 isSignedInteger;
  unint64_t v96;
  uint64_t ElementTypeOrSelf;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  std::string v102;
  uint64_t Value;
  uint64_t v104;
  std::string v105;
  __int16 v106;
  void *__p[5];
  void *v108;
  uint64_t v109;
  const char *v110;
  void *v111;
  _QWORD v112[2];
  __int16 v113;
  std::string v114;
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v101 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "k");
  strcpy((char *)__p, "axis");
  MIL::IROperation::GetParameterValue();
  v7 = MIL::IRValue::GetScalar<int>();
  v100 = v7;
  strcpy((char *)__p, "ascending");
  MIL::IROperation::GetParameterValue();
  v8 = MIL::IRValue::GetScalar<BOOL>();
  HIBYTE(__p[2]) = 1;
  LOWORD(__p[0]) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  v10 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v98 = 0;
  v99 = ArgValue;
  v11 = MIL::IRTensorValueType::Rank(v10) - 1;
  _ZF = v7 == -1 || v11 == v7;
  v13 = _ZF;
  if (!_ZF)
  {
    LODWORD(__p[0]) = -1;
    v14 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v99, &v100, (unsigned int *)__p);
    if (!*(_DWORD *)(v14 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v99 = v14 - 16;
  }
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  if (v8)
  {
    if (mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf))
    {
      __p[0] = (void *)1;
      v15 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, ElementTypeOrSelf, 0);
      __p[0] = (void *)mlir::mps::getConstantAttr<int>(v15, -1);
      v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)__p);
      if (!*((_DWORD *)v16 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v98 = (uint64_t)v16 - 16;
      v17 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &v98, &v99);
      if (!*(_DWORD *)(v17 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_69:
      v99 = v17 - 16;
      goto LABEL_70;
    }
    if (!mlir::Type::isUnsignedInteger((mlir::Type *)&ElementTypeOrSelf))
    {
      v17 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v99);
      if (!*(_DWORD *)(v17 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      goto LABEL_69;
    }
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf);
    __p[0] = (void *)1;
    v19 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, ElementTypeOrSelf, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v19))
      __assert_rtn("cast", "Casting.h", 572, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
    if (v19)
    {
      InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v19);
      if (!InterfaceFor)
        __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
    }
    else
    {
      InterfaceFor = 0;
    }
    v21 = (const char *)mlir::getElementTypeOrSelf(v19);
    if (!v21)
      __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
    if (!*(_QWORD *)v21)
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    v22 = 0xFFFFFFFFFFFFFFFFLL >> -IntOrFloatBitWidth;
    v23 = *(void **)(*(_QWORD *)v21 + 136);
    if (v23 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
      && v23 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      if (v23 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
        if (mlir::Type::isInteger((mlir::Type *)&v114, 1))
        {
          LOBYTE(__p[0]) = 1;
          v34 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((uint64_t)v19, InterfaceFor, __p, 1);
          if ((mlir::DenseIntElementsAttr::classof((uint64_t)v34) & 1) == 0)
            __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
        }
        else
        {
          v94 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v114);
          isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v114);
          LODWORD(__p[1]) = v94;
          if (v94 > 0x40)
          {
            llvm::APInt::initSlowCase((llvm::APInt *)__p, v22, isSignedInteger);
          }
          else
          {
            v96 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v94;
            if (!v94)
              v96 = 0;
            __p[0] = (void *)(v96 & v22);
          }
          v34 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((uint64_t)v19, InterfaceFor, (llvm::APInt *)__p, 1);
          if ((mlir::DenseIntElementsAttr::classof((uint64_t)v34) & 1) == 0)
            __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
          if (LODWORD(__p[1]) >= 0x41 && __p[0])
            MEMORY[0x186DA165C](__p[0], 0x1000C8000313F17);
        }
        goto LABEL_67;
      }
      if (v23 != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
        llvm::llvm_unreachable_internal((llvm *)"unexpected element type kind", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/IR/MPSOps.h", (const char *)0x143);
      v104 = (uint64_t)v21;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v104);
      if (!mlir::Type::isF32((mlir::Type *)&Value))
      {
        isF16 = mlir::Type::isF16((mlir::Type *)&Value);
        if (!isF16)
          llvm::llvm_unreachable_internal((llvm *)"unexpected complex element float type kind", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/IR/MPSOps.h", (const char *)0x140);
        _S0 = (float)v22;
        __asm { FCVT            H8, S0 }
        v82 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
        __asm { FCVT            S0, H8; __val }
        std::to_string(&v105, _S0);
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v84 = &v105;
        else
          v84 = (std::string *)v105.__r_.__value_.__r.__words[0];
        if ((v105.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(v105.__r_.__value_.__r.__words[2]);
        else
          size = v105.__r_.__value_.__l.__size_;
        llvm::APFloat::APFloat((llvm::APFloatBase *)&v114, v82, (unsigned __int8 *)v84, size);
        std::to_string(&v102, 0.0);
        if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v86 = &v102;
        else
          v86 = (std::string *)v102.__r_.__value_.__r.__words[0];
        if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v87 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
        else
          v87 = v102.__r_.__value_.__l.__size_;
        llvm::APFloat::APFloat((llvm::APFloatBase *)&v110, v82, (unsigned __int8 *)v86, v87);
        std::complex<llvm::APFloat>::complex[abi:ne180100]((llvm::APFloatBase *)__p, (uint64_t)&v114, (uint64_t)&v110);
        v34 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((llvm::APFloatBase *)v19, InterfaceFor, (uint64_t)__p, 1);
        v88 = v108;
        v89 = llvm::APFloatBase::PPCDoubleDouble(v34);
        if (v89 == v88)
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v109);
        else
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v108);
        if (v89 == __p[1])
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&__p[2]);
        else
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p[1]);
        if (v89 == v111)
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v112);
        else
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v111);
        if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v102.__r_.__value_.__l.__data_);
        if (v89 == (void *)v114.__r_.__value_.__l.__size_)
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v114.__r_.__value_.__r.__words[2]);
        else
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v114.__r_.__value_.__r.__words[1]);
        if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v105.__r_.__value_.__l.__data_);
        goto LABEL_67;
      }
      *(float *)&v114.__r_.__value_.__l.__data_ = (float)v22;
      HIDWORD(v114.__r_.__value_.__r.__words[0]) = 0;
      v24 = mlir::DenseElementsAttr::getFromRawBuffer(v19, InterfaceFor, &v114, 8, 8, 0, 1);
      goto LABEL_66;
    }
    v110 = v21;
    if (mlir::Type::isF16((mlir::Type *)&v110))
    {
      v25 = std::to_string(&v114, v22);
      if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v26 = &v114;
      else
        v26 = (std::string *)v114.__r_.__value_.__r.__words[0];
      if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v27 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
      else
        v27 = v114.__r_.__value_.__l.__size_;
      v28 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)v25);
      llvm::APFloat::APFloat((llvm::APFloatBase *)__p, v28, (unsigned __int8 *)v26, v27);
      v29 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((llvm::APFloatBase *)v19, InterfaceFor, (uint64_t)__p, 1);
    }
    else
    {
      if (!mlir::Type::isBF16((mlir::Type *)&v110))
      {
        if (mlir::Type::isF32((mlir::Type *)&v110))
        {
          *(float *)__p = (float)v22;
          v24 = mlir::DenseElementsAttr::getFromRawBuffer(v19, InterfaceFor, __p, 4, 4, 0, 1);
        }
        else
        {
          if (!mlir::Type::isF64((mlir::Type *)&v110))
            llvm::llvm_unreachable_internal((llvm *)"unexpected element float type kind", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/IR/MPSOps.h", (const char *)0x126);
          *(double *)__p = (double)v22;
          v24 = mlir::DenseElementsAttr::getFromRawBuffer(v19, InterfaceFor, __p, 8, 8, 0, 1);
        }
LABEL_66:
        v34 = (llvm::APFloatBase *)v24;
        goto LABEL_67;
      }
      v30 = std::to_string(&v114, v22);
      if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v31 = &v114;
      else
        v31 = (std::string *)v114.__r_.__value_.__r.__words[0];
      if ((v114.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v32 = HIBYTE(v114.__r_.__value_.__r.__words[2]);
      else
        v32 = v114.__r_.__value_.__l.__size_;
      v33 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)v30);
      llvm::APFloat::APFloat((llvm::APFloatBase *)__p, v33, (unsigned __int8 *)v31, v32);
      v29 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get((llvm::APFloatBase *)v19, InterfaceFor, (uint64_t)__p, 1);
    }
    v34 = v29;
    v35 = __p[1];
    if (llvm::APFloatBase::PPCDoubleDouble(v29) == v35)
    {
      std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&__p[2]);
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
LABEL_61:
        operator delete(v114.__r_.__value_.__l.__data_);
    }
    else
    {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p[1]);
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_61;
    }
LABEL_67:
    __p[0] = v34;
    v36 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)__p);
    if (!*((_DWORD *)v36 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v98 = (uint64_t)v36 - 16;
    v17 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &v98, &v99);
    if (!*(_DWORD *)(v17 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    goto LABEL_69;
  }
LABEL_70:
  __p[0] = (void *)mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v37 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 13, LocationForOp, &v101, (uint64_t *)__p);
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v39 = (uint64_t *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  __p[0] = (void *)mlir::mps::getConstantAttr<int>(v39, -1);
  v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)__p);
  v102.__r_.__value_.__r.__words[0] = LocationForOp;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v102);
  v42 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.top_k", (const unsigned __int8 *)9, Context);
  if (!v43)
  {
    v113 = 1283;
    v112[0] = "mps.top_k";
    v112[1] = 9;
                                                                "y not be loaded or this operation hasn't been added by t"
                                                                "he dialect. See also https://mlir.llvm.org/getting_start"
                                                                "ed/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
    v106 = 259;
    llvm::operator+((uint64_t *)&v110, (uint64_t *)&v105, (uint64_t)&v114);
    llvm::report_fatal_error((llvm::Twine *)&v114, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v42);
  if (!*((_DWORD *)v40 + 9) || !*((_DWORD *)v37 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::TopKOp::build(a3 + 13, (uint64_t)__p, v99, (uint64_t)v40 - 16, (uint64_t)v37 - 16, 0);
  v44 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)__p);
  if (!v44)
  {
    v90 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v91 = 662;
    v92 = "Casting.h";
    v93 = "dyn_cast";
    goto LABEL_149;
  }
  v45 = llvm::DefaultDoCastIfPossible<mlir::mps::TopKOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TopKOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v44);
  if (!v45)
  {
    v90 = "result && \"builder didn't return the right type\"";
    v91 = 497;
    v92 = "Builders.h";
    v93 = "create";
LABEL_149:
    __assert_rtn(v93, v92, v91, v90);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  v104 = v45;
  v110 = (const char *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v104);
  v105.__r_.__value_.__r.__words[0] = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v104);
  if ((v13 & 1) == 0)
  {
    LODWORD(__p[0]) = -1;
    v46 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, (uint64_t *)&v110, &v100, (unsigned int *)__p);
    LODWORD(__p[0]) = -1;
    v47 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, (uint64_t *)&v105, &v100, (unsigned int *)__p);
    if (!*(_DWORD *)(v46 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v110 = (const char *)(v46 - 16);
    if (!*(_DWORD *)(v47 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v105.__r_.__value_.__r.__words[0] = v47 - 16;
  }
  if (v8)
  {
    if (v98)
    {
      v48 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &v98, (uint64_t *)&v110);
      if (!*(_DWORD *)(v48 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    else
    {
      v48 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t *)&v110);
      if (!*(_DWORD *)(v48 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    v110 = (const char *)(v48 - 16);
  }
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 2)
  {
    HIBYTE(__p[2]) = 14;
    strcpy((char *)__p, "return_indices");
    ParameterValue = MIL::IROperation::TryGetParameterValue();
    v54 = ParameterValue;
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
      if (!v54)
        goto LABEL_103;
    }
    else if (!ParameterValue)
    {
LABEL_103:
      __p[0] = operator new(0x38uLL);
      *(_OWORD *)&__p[1] = xmmword_181286AB0;
      strcpy((char *)__p[0], "Return types of topk must be 2 distinct tensor values.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
      return 0;
    }
    if ((MIL::IRValue::GetScalar<BOOL>() & 1) == 0
      && (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
    {
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
      v55 = __p[0];
      v56 = v110;
      v57 = (char *)operator new(8uLL);
      *(_QWORD *)v57 = v56;
      v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v55;
      v58 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v55, (uint64_t)&std::piecewise_construct, (__int128 **)&v114);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v58 + 5, v57, v57 + 8, 1uLL);
      operator delete(v57);
      v59 = (void **)__p[0];
      if (__p[0])
      {
        v60 = (void **)__p[1];
        v61 = __p[0];
        if (__p[1] != __p[0])
        {
          do
          {
            if (*((char *)v60 - 1) < 0)
              operator delete(*(v60 - 3));
            v60 -= 3;
          }
          while (v60 != v59);
          v61 = __p[0];
        }
        __p[1] = v59;
        operator delete(v61);
      }
      return 1;
    }
    goto LABEL_103;
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
  OutputType = MIL::IROperation::GetOutputType(a2);
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)OutputType + 24))(OutputType))
  {
    v50 = MIL::IROperation::GetOutputType(a2);
    if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v50 + 24))(v50))
    {
      *((_BYTE *)&v114.__r_.__value_.__s + 23) = 20;
      strcpy((char *)&v114, "output_indices_dtype");
      v51 = MIL::IROperation::TryGetParameterValue();
      v52 = v51;
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v114.__r_.__value_.__l.__data_);
        if (!v52)
          goto LABEL_115;
      }
      else if (!v51)
      {
        goto LABEL_115;
      }
      MIL::IRValue::GetScalar<std::string>();
      v102.__r_.__value_.__r.__words[0] = MILToMLIRRewriter::getMLIRElemType((uint64_t)a3, (uint64_t)&v114);
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v114.__r_.__value_.__l.__data_);
      v64 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, (uint64_t *)&v105, (uint64_t *)&v102);
      if (!*((_DWORD *)v64 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v105.__r_.__value_.__r.__words[0] = (std::string::size_type)v64 - 16;
LABEL_115:
      v65 = __p[0];
      v66 = v110;
      v67 = (char *)operator new(8uLL);
      *(_QWORD *)v67 = v66;
      v68 = (char *)(a3 + 8);
      v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v65;
      v69 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v68, (uint64_t)v65, (uint64_t)&std::piecewise_construct, (__int128 **)&v114);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v69 + 5, v67, v67 + 8, 1uLL);
      operator delete(v67);
      v70 = __p[0];
      v71 = v105.__r_.__value_.__r.__words[0];
      v72 = (char *)operator new(8uLL);
      *(_QWORD *)v72 = v71;
      v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v70 + 24;
      v73 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v68, (uint64_t)v70 + 24, (uint64_t)&std::piecewise_construct, (__int128 **)&v114);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v73 + 5, v72, v72 + 8, 1uLL);
      operator delete(v72);
      v62 = 1;
      v63 = (void **)__p[0];
      if (__p[0])
        goto LABEL_116;
      return (v62 & 1) != 0;
    }
  }
  v114.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
  *(_OWORD *)&v114.__r_.__value_.__r.__words[1] = xmmword_181286AC0;
  strcpy(v114.__r_.__value_.__l.__data_, "Expected values tensor output.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&v114);
  if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v114.__r_.__value_.__l.__data_);
  v62 = 0;
  v63 = (void **)__p[0];
  if (__p[0])
  {
LABEL_116:
    v74 = (void **)__p[1];
    if (__p[1] == v63)
    {
      __p[1] = v63;
      operator delete(v63);
      if ((v62 & 1) != 0)
        return 1;
    }
    else
    {
      do
      {
        if (*((char *)v74 - 1) < 0)
          operator delete(*(v74 - 3));
        v74 -= 3;
      }
      while (v74 != v63);
      __p[1] = v63;
      operator delete(__p[0]);
      if ((v62 & 1) != 0)
        return 1;
    }
    return 0;
  }
  return (v62 & 1) != 0;
}

void sub_180E024CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *a30,int a31,int a32,int a33,__int16 a34,char a35,char a36)
{
  uint64_t v36;

  std::complex<llvm::APFloat>::~complex(&a30);
  llvm::APFloat::~APFloat((llvm::APFloat *)(v36 - 200));
  if (a19 < 0)
  {
    operator delete(__p);
    llvm::APFloat::~APFloat((llvm::APFloat *)(v36 - 160));
    if ((a27 & 0x80000000) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else
  {
    llvm::APFloat::~APFloat((llvm::APFloat *)(v36 - 160));
    if ((a27 & 0x80000000) == 0)
      goto LABEL_6;
  }
  operator delete(a22);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int &,int>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  uint64_t v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.transpose";
    v23[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::TransposeOp::build(a1, v26, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::TransposeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TransposeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E02820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E02838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.negative";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::NegativeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NegativeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E029BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E029D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::CropResizePattern::matchAndRewrite(MILToMLIR::CropResizePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ParameterValue;
  uint64_t v8;
  uint64_t v9;
  int v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  int v17;
  uint64_t v27;
  uint64_t v28;
  unsigned int v30;
  void *v43;
  _DWORD *v46;
  uint64_t IntegerType;
  uint64_t **v48;
  uint64_t InterfaceFor;
  const char *v50;
  int v51;
  const char *v52;
  const char *v53;
  uint64_t *v54;
  mlir::GenericProgramPoint *v55;
  llvm::APFloatBase *v56;
  void *v57;
  uint64_t *Context;
  uint64_t v59;
  char v60;
  uint64_t v61;
  void *v62;
  llvm::APFloatBase *v63;
  void *v64;
  mlir::GenericProgramPoint *v65;
  uint64_t v66;
  uint64_t *v67;
  char *v68;
  uint64_t *v69;
  void **v70;
  void **v71;
  void *v72;
  const char *v74;
  int v75;
  const char *v76;
  const char *v77;
  unsigned int v78;
  int v79;
  unsigned int v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  const char *v84;
  __int16 v85;
  uint64_t v86[4];
  __int16 v87;
  void *v88;
  uint64_t v89;
  void *__p[38];
  uint64_t *v91;
  void *v92;
  _QWORD v93[6];

  v93[3] = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v82 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "roi");
  strcpy((char *)__p, "target_height");
  if (MIL::IROperation::TryGetParameterValue())
    v81 = MIL::IRValue::GetScalar<int>();
  else
    v81 = 1;
  strcpy((char *)__p, "target_width");
  if (MIL::IROperation::TryGetParameterValue())
    v80 = MIL::IRValue::GetScalar<int>();
  else
    v80 = 1;
  strcpy((char *)__p, "normalized_coordinates");
  if (MIL::IROperation::TryGetParameterValue())
    v79 = MIL::IRValue::GetScalar<BOOL>();
  else
    v79 = 0;
  HIBYTE(__p[2]) = 13;
  strcpy((char *)__p, "spatial_scale");
  ParameterValue = MIL::IROperation::TryGetParameterValue();
  if (!ParameterValue)
  {
    v12 = 1.0;
    goto LABEL_19;
  }
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
  if (v8)
  {
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 32))(v8);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 88))(v9);
    if (v10 == 4)
    {
      LOWORD(__p[0]) = MIL::IRValue::GetScalar<MIL::Fp16>();
      MIL::Fp16::GetFloat((MIL::Fp16 *)__p);
      goto LABEL_18;
    }
    if (v10 == 5)
    {
      MIL::IRValue::GetScalar<float>();
LABEL_18:
      v12 = v11;
LABEL_19:
      HIBYTE(__p[2]) = 19;
      strcpy((char *)__p, "box_coordinate_mode");
      v13 = MIL::IROperation::TryGetParameterValue();
      v14 = v13;
      if (SHIBYTE(__p[2]) < 0)
      {
        operator delete(__p[0]);
        if (!v14)
        {
LABEL_74:
          v17 = 0;
          goto LABEL_75;
        }
      }
      else if (!v13)
      {
        goto LABEL_74;
      }
      MIL::IRValue::GetScalar<std::string>();
      if (SHIBYTE(__p[2]) < 0)
      {
        switch((unint64_t)__p[1])
        {
          case 0x13uLL:
            if (*(_QWORD *)__p[0] != 0x5F5352454E524F43
              || *((_QWORD *)__p[0] + 1) != 0x49465F4854444957
              || *(_QWORD *)((char *)__p[0] + 11) != 0x54535249465F4854)
            {
              goto LABEL_198;
            }
            v17 = 1;
            operator delete(__p[0]);
            break;
          case 0x14uLL:
            if (*(_QWORD *)__p[0] != 0x5F5352454E524F43
              || *((_QWORD *)__p[0] + 1) != 0x465F544847494548
              || *((_DWORD *)__p[0] + 4) != 1414746697)
            {
              goto LABEL_198;
            }
            v17 = 0;
            operator delete(__p[0]);
            break;
          case 0x17uLL:
            if (*(_QWORD *)__p[0] != 0x535F5245544E4543
              || *((_QWORD *)__p[0] + 1) != 0x544449575F455A49
              || *(_QWORD *)((char *)__p[0] + 15) != 0x54535249465F4854)
            {
              goto LABEL_198;
            }
            v17 = 3;
            operator delete(__p[0]);
            break;
          case 0x18uLL:
            if (*(_QWORD *)__p[0] != 0x535F5245544E4543
              || *((_QWORD *)__p[0] + 1) != 0x474945485F455A49
              || *((_QWORD *)__p[0] + 2) != 0x54535249465F5448)
            {
              goto LABEL_198;
            }
            v17 = 2;
            operator delete(__p[0]);
            break;
          default:
LABEL_198:
            __assert_rtn("matchAndRewrite", "MILToMLIRCustomPatterns.mm", 1951, "0 && \"Unknown coordinate mode\"");
        }
      }
      else
      {
        switch(HIBYTE(__p[2]))
        {
          case 0x13:
            if (__p[0] != (void *)0x5F5352454E524F43
              || __p[1] != (void *)0x49465F4854444957
              || *(void **)((char *)&__p[1] + 3) != (void *)0x54535249465F4854)
            {
              goto LABEL_198;
            }
            v17 = 1;
            break;
          case 0x14:
            if (__p[0] != (void *)0x5F5352454E524F43
              || __p[1] != (void *)0x465F544847494548
              || LODWORD(__p[2]) != 1414746697)
            {
              goto LABEL_198;
            }
            goto LABEL_74;
          case 0x17:
            if (__p[0] != (void *)0x535F5245544E4543
              || __p[1] != (void *)0x544449575F455A49
              || *(void **)((char *)&__p[1] + 7) != (void *)0x54535249465F4854)
            {
              goto LABEL_198;
            }
            v17 = 3;
            break;
          case 0x18:
            if (__p[0] != (void *)0x535F5245544E4543
              || __p[1] != (void *)0x474945485F455A49
              || __p[2] != (void *)0x54535249465F5448)
            {
              goto LABEL_198;
            }
            v17 = 2;
            break;
          default:
            goto LABEL_198;
        }
      }
LABEL_75:
      HIBYTE(__p[2]) = 13;
      strcpy((char *)__p, "sampling_mode");
      v27 = MIL::IROperation::TryGetParameterValue();
      v28 = v27;
      if (SHIBYTE(__p[2]) < 0)
      {
        operator delete(__p[0]);
        v78 = v17;
        if (!v28)
        {
LABEL_86:
          v30 = 0;
LABEL_156:
          v46 = operator new(0xCuLL);
          *(_QWORD *)v46 = 0x300000001;
          v46[2] = 4;
          __p[0] = (void *)3;
          IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
          v48 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, IntegerType, 0);
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v48))
            goto LABEL_190;
          if (v48)
          {
            InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v48);
            if (!InterfaceFor)
            {
              v50 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              v51 = 98;
              v52 = "InterfaceSupport.h";
              v53 = "Interface";
              goto LABEL_191;
            }
          }
          else
          {
            InterfaceFor = 0;
          }
          v54 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v48, InterfaceFor, v46, 12, 4, 1, 1);
          if ((mlir::DenseIntElementsAttr::classof((uint64_t)v54) & 1) == 0)
          {
LABEL_190:
            v50 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
            v51 = 566;
            v52 = "Casting.h";
            v53 = "cast";
LABEL_191:
            __assert_rtn(v53, v52, v51, v50);
          }
          v91 = v54;
          __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v91);
          v55 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v82, __p);
          if (!*((_DWORD *)v55 + 9))
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          operator delete(v46);
          v56 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)__p, v12);
          v57 = llvm::APFloatBase::IEEEsingle(v56);
          llvm::APFloat::Storage::Storage(&v88, __p, v57);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)__p);
          v83 = LocationForOp;
          Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v83);
          v59 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop_resize", (const unsigned __int8 *)0xF, Context);
          if (!v60)
          {
            v87 = 1283;
            v86[2] = (uint64_t)"mps.crop_resize";
            v86[3] = 15;
                  "added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-"
                  "whats-up-with-dialects-management";
            v85 = 259;
            llvm::operator+(v86, (uint64_t *)&v84, (uint64_t)&v91);
            llvm::report_fatal_error((llvm::Twine *)&v91, 1);
          }
          mlir::OperationState::OperationState(__p, LocationForOp, v59);
          v61 = ArgValue;
          v62 = v88;
          v64 = llvm::APFloatBase::PPCDoubleDouble(v63);
          if (v64 == v62)
            llvm::detail::DoubleAPFloat::DoubleAPFloat(&v92, &v88);
          else
            llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v92, (uint64_t)&v88);
          mlir::mps::CropResizeOp::build((mlir::Builder *)(a3 + 13), (uint64_t)__p, v61, (uint64_t)v55 - 16, v81, v80, v79, (uint64_t)&v91, 1u, v30, v78);
          if (v64 == v92)
            std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v93);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v92);
          v65 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)__p);
          if (v65)
          {
            v66 = llvm::DefaultDoCastIfPossible<mlir::mps::CropResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropResizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v65);
            if (v66)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)__p);
              if (!*(_DWORD *)(v66 + 36))
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              if (v64 == v88)
                std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v89);
              else
                llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v88);
              (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
              v67 = (uint64_t *)__p[0];
              v68 = (char *)operator new(8uLL);
              *(_QWORD *)v68 = v66 - 16;
              v91 = v67;
              v69 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v67, (uint64_t)&std::piecewise_construct, (__int128 **)&v91);
              std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v69 + 5, v68, v68 + 8, 1uLL);
              operator delete(v68);
              v70 = (void **)__p[0];
              if (__p[0])
              {
                v71 = (void **)__p[1];
                v72 = __p[0];
                if (__p[1] != __p[0])
                {
                  do
                  {
                    if (*((char *)v71 - 1) < 0)
                      operator delete(*(v71 - 3));
                    v71 -= 3;
                  }
                  while (v71 != v70);
                  v72 = __p[0];
                }
                __p[1] = v70;
                operator delete(v72);
              }
              return 1;
            }
            v74 = "result && \"builder didn't return the right type\"";
            v75 = 497;
            v76 = "Builders.h";
            v77 = "create";
          }
          else
          {
            v74 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            v75 = 662;
            v76 = "Casting.h";
            v77 = "dyn_cast";
          }
          __assert_rtn(v77, v76, v75, v74);
        }
      }
      else
      {
        v78 = v17;
        if (!v27)
          goto LABEL_86;
      }
      MIL::IRValue::GetScalar<std::string>();
      if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
      {
        switch(HIBYTE(__p[2]))
        {
          case 7:
            if (LODWORD(__p[0]) != 1095124292 || *(_DWORD *)((char *)__p + 3) != 1414288705)
              goto LABEL_189;
            goto LABEL_86;
          case 0xD:
            if (__p[0] != (void *)0x4F435F4E47494C41 || *(void **)((char *)__p + 5) != (void *)0x5352454E524F435FLL)
              goto LABEL_189;
            goto LABEL_113;
          case 0xE:
            if (__p[0] != (void *)0x435F54455346464FLL || *(void **)((char *)__p + 6) != (void *)0x5352454E524F435FLL)
              goto LABEL_189;
            v30 = 2;
            goto LABEL_156;
          case 0x14:
            if (__p[0] != (void *)0x415F544349525453
              || __p[1] != (void *)0x524F435F4E47494CLL
              || LODWORD(__p[2]) != 1397900622)
            {
              goto LABEL_189;
            }
LABEL_113:
            v30 = 1;
            goto LABEL_156;
          default:
            goto LABEL_189;
        }
      }
      switch((unint64_t)__p[1])
      {
        case 7uLL:
          if (*(_DWORD *)__p[0] != 1095124292 || *(_DWORD *)((char *)__p[0] + 3) != 1414288705)
            goto LABEL_189;
          v30 = 0;
          operator delete(__p[0]);
          break;
        case 0xDuLL:
          v43 = __p[0];
          if (*(_QWORD *)__p[0] != 0x4F435F4E47494C41 || *(_QWORD *)((char *)__p[0] + 5) != 0x5352454E524F435FLL)
            goto LABEL_189;
          goto LABEL_155;
        case 0xEuLL:
          if (*(_QWORD *)__p[0] != 0x435F54455346464FLL || *(_QWORD *)((char *)__p[0] + 6) != 0x5352454E524F435FLL)
            goto LABEL_189;
          v30 = 2;
          operator delete(__p[0]);
          break;
        case 0x14uLL:
          v43 = __p[0];
          if (*(_QWORD *)__p[0] != 0x415F544349525453
            || *((_QWORD *)__p[0] + 1) != 0x524F435F4E47494CLL
            || *((_DWORD *)__p[0] + 4) != 1397900622)
          {
            goto LABEL_189;
          }
LABEL_155:
          v30 = 1;
          operator delete(v43);
          break;
        default:
LABEL_189:
          __assert_rtn("matchAndRewrite", "MILToMLIRCustomPatterns.mm", 1964, "0 && \"Unknown coordinate mode\"");
      }
      goto LABEL_156;
    }
    __p[0] = operator new(0x20uLL);
    *(_OWORD *)&__p[1] = xmmword_181268750;
    strcpy((char *)__p[0], "Unexpected MIL element type.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)__p);
  }
  else
  {
    __p[0] = operator new(0x38uLL);
    *(_OWORD *)&__p[1] = xmmword_181286AB0;
    strcpy((char *)__p[0], "Failed to materialize constant: value is not a tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)__p);
  }
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  return 0;
}

void sub_180E03770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E0383C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E0386C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  llvm::APFloat::~APFloat((llvm::APFloat *)va);
  _Unwind_Resume(a1);
}

void sub_180E03880(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<int>::vector[abi:ne180100](_QWORD *a1, const void *a2, unint64_t a3)
{
  size_t v5;
  char *v6;
  char *v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v5 = 4 * a3;
    v6 = (char *)operator new(4 * a3);
    *a1 = v6;
    a1[1] = v6;
    v7 = &v6[v5];
    a1[2] = &v6[v5];
    memmove(v6, a2, v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_180E03908(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::DenseIntElementsAttr::get<std::vector<int> &>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = mlir::DenseElementsAttr::getFromRawBuffer(a1, a2, a3, a4 - a3, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v4) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  return v4;
}

uint64_t MILToMLIR::ConstExpressionPattern::matchAndRewrite(MILToMLIR::ConstExpressionPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  std::string *v8;
  int64_t size;
  int64_t v10;
  std::string *v11;
  char *v12;
  int64_t v13;
  std::string *v14;
  char *v15;
  MIL::IRValue *Attribute;
  mlir::GenericProgramPoint *v18;
  std::vector<int>::pointer begin;
  char *v20;
  uint64_t *v21;
  int *v22;
  std::vector<int>::pointer end;
  std::vector<int>::pointer v24;
  std::string *v25;
  char *v26;
  BOOL v27;
  BOOL v28;
  uint64_t v30;
  std::string *v31;
  char *v32;
  std::string *v33;
  char *v34;
  BOOL v35;
  BOOL v36;
  uint64_t v38;
  std::string *v39;
  std::string *v40;
  char *v41;
  std::string *v42;
  char *v43;
  BOOL v44;
  char *v46;
  int64_t v47;
  std::string *v48;
  char *v49;
  BOOL v50;
  uint64_t ArgValue;
  uint64_t OptionalArgValue;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  mlir::MLIRContext **v58;
  std::string *v59;
  char *v60;
  MIL::IRValue *v65;
  uint64_t v66;
  MIL::IRValue *v67;
  uint64_t v68;
  MIL::IRValue *v69;
  uint64_t v70;
  uint64_t ElementTypeOrSelf;
  MIL::IRValue *v72;
  uint64_t v73;
  uint64_t IntegerType;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t *Context;
  uint64_t v79;
  char v80;
  mlir::GenericProgramPoint *v81;
  uint64_t v82;
  int *v83;
  char *v84;
  uint64_t *v85;
  void **v86;
  void **v87;
  void *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  std::vector<int>::pointer v92;
  char *v93;
  char *v94;
  uint64_t *v95;
  int *v96;
  std::vector<int>::pointer v97;
  std::vector<int>::pointer v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  mlir::GenericProgramPoint *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  char v107;
  mlir::GenericProgramPoint *v108;
  uint64_t v109;
  int *v110;
  char *v111;
  uint64_t *v112;
  void **v113;
  BOOL v116;
  const MIL::IRValue *v117;
  uint64_t MLIRElemTypeFromMILValue;
  uint64_t v119;
  int v120;
  MIL::IRValue *v121;
  MIL::IRValue *v122;
  unint64_t v123;
  uint64_t Value;
  unint64_t v125;
  unint64_t v126;
  uint64_t v127;
  MIL::IRValue *ParameterValue;
  MIL::IRValueType *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t *v135;
  uint64_t v136;
  mlir::GenericProgramPoint *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t Data;
  int *v141;
  std::vector<int>::size_type v142;
  void *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  std::vector<int>::pointer v149;
  std::vector<int>::size_type v150;
  unint64_t v151;
  uint64_t v152;
  __int128 *v153;
  std::vector<int>::pointer v154;
  unint64_t v155;
  __int128 v156;
  int *v157;
  int *v158;
  std::vector<int>::size_type v159;
  int v160;
  int *v161;
  int v162;
  int v163;
  mlir::GenericProgramPoint *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  void *v168;
  char *v169;
  uint64_t *v170;
  void **v171;
  void **v172;
  void *v173;
  std::__shared_weak_count *v174;
  unint64_t *v175;
  unint64_t v176;
  std::vector<int>::pointer v177;
  char *v178;
  uint64_t *v179;
  int *v180;
  std::vector<int>::pointer v181;
  std::vector<int>::pointer v182;
  char *v183;
  char *v184;
  void *v185;
  std::__shared_weak_count *v186;
  unint64_t *p_shared_owners;
  unint64_t v188;
  const char *v190;
  int v191;
  const char *v192;
  const char *v193;
  const char *v194;
  int v195;
  const char *v196;
  const char *v197;
  const char *v198;
  int v199;
  const char *v200;
  const char *v201;
  int v202;
  const char *v203;
  const char *v204;
  std::runtime_error *exception;
  mlir::UnknownLoc **v206;
  const MIL::IROperation *v207;
  mlir::StringAttr **v208;
  uint64_t v209;
  uint64_t *v210;
  unint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t LocationForOp;
  std::string v215;
  uint64_t MLIRElemType;
  const char *v217;
  uint64_t v218;
  __int16 v219;
  void *v220[2];
  const char *v221;
  uint64_t v222;
  __int16 v223;
  void *__p[38];
  std::vector<int> v225;
  uint64_t v226;

  v226 = *MEMORY[0x1E0C80C00];
  v5 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v215, *(const std::string::value_type **)v5, *(_QWORD *)(v5 + 8));
  }
  else
  {
    v6 = *(_OWORD *)v5;
    v215.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 16);
    *(_OWORD *)&v215.__r_.__value_.__l.__data_ = v6;
  }
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v206 = a3 + 13;
  v207 = a2;
  v7 = HIBYTE(v215.__r_.__value_.__r.__words[2]);
  size = v215.__r_.__value_.__l.__size_;
  v8 = (std::string *)v215.__r_.__value_.__r.__words[0];
  if ((v215.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v10 = HIBYTE(v215.__r_.__value_.__r.__words[2]);
  else
    v10 = v215.__r_.__value_.__l.__size_;
  if ((v215.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &v215;
  else
    v11 = (std::string *)v215.__r_.__value_.__r.__words[0];
  v208 = a3;
  if (v10 >= 14)
  {
    v12 = (char *)v11 + v10;
    v13 = v10;
    v14 = v11;
    while (1)
    {
      v15 = (char *)memchr(v14, 99, v13 - 13);
      if (!v15)
        goto LABEL_32;
      if (*(_QWORD *)v15 == 0x70786574736E6F63 && *(_QWORD *)(v15 + 6) == 0x747361635F727078)
        break;
      v14 = (std::string *)(v15 + 1);
      v13 = v12 - (char *)v14;
      if (v12 - (char *)v14 < 14)
        goto LABEL_32;
    }
    if (v15 != v12 && v15 - (char *)v11 != -1)
    {
      HIBYTE(__p[2]) = 10;
      strcpy((char *)__p, "source_val");
      Attribute = (MIL::IRValue *)MIL::IRObject::GetAttribute();
      v217 = (const char *)MILToMLIRRewriter::materializeConstant((uint64_t)a3, Attribute, &LocationForOp);
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
      HIBYTE(v225.__end_cap_.__value_) = 12;
      strcpy((char *)&v225, "output_dtype");
      MIL::IRObject::GetAttribute();
      MIL::IRValue::GetScalar<std::string>();
      if (SHIBYTE(v225.__end_cap_.__value_) < 0)
        operator delete(v225.__begin_);
      MLIRElemType = MILToMLIRRewriter::getMLIRElemType((uint64_t)a3, (uint64_t)__p);
      v18 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v206, LocationForOp, (uint64_t *)&v217, &MLIRElemType);
      (*(void (**)(std::vector<int> *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&v225, a2);
      if (!*((_DWORD *)v18 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      begin = v225.__begin_;
      v20 = (char *)operator new(8uLL);
      *(_QWORD *)v20 = (char *)v18 - 16;
      v220[0] = begin;
      v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v208 + 8), (uint64_t)begin, (uint64_t)&std::piecewise_construct, (__int128 **)v220);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v21 + 5, v20, v20 + 8, 1uLL);
      operator delete(v20);
      v22 = v225.__begin_;
      if (v225.__begin_)
      {
        end = v225.__end_;
        v24 = v225.__begin_;
        if (v225.__end_ != v225.__begin_)
        {
          do
          {
            if (*((char *)end - 1) < 0)
              operator delete(*((void **)end - 3));
            end -= 6;
          }
          while (end != v22);
          v24 = v225.__begin_;
        }
        v225.__end_ = v22;
        operator delete(v24);
      }
      if ((SHIBYTE(__p[2]) & 0x80000000) == 0)
        goto LABEL_187;
      v88 = __p[0];
      goto LABEL_186;
    }
LABEL_32:
    if (v10 >= 27)
    {
      v25 = v11;
      while (1)
      {
        v26 = (char *)memchr(v25, 99, v10 - 26);
        if (!v26)
          goto LABEL_46;
        v27 = *(_QWORD *)v26 == 0x70786574736E6F63 && *((_QWORD *)v26 + 1) == 0x656E696666615F72;
        v28 = v27 && *((_QWORD *)v26 + 2) == 0x746E61757165645FLL;
        if (v28 && *(_QWORD *)(v26 + 19) == 0x657A69746E617571)
          break;
        v25 = (std::string *)(v26 + 1);
        v10 = v12 - (char *)v25;
        if (v12 - (char *)v25 < 27)
          goto LABEL_46;
      }
      if (v26 != v12 && v26 - (char *)v11 != -1)
      {
        HIBYTE(__p[2]) = 14;
        strcpy((char *)__p, "quantized_data");
        v65 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
        v66 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v65, &LocationForOp);
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
        HIBYTE(__p[2]) = 10;
        strcpy((char *)__p, "zero_point");
        v67 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
        v68 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v67, &LocationForOp);
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
        HIBYTE(__p[2]) = 5;
        strcpy((char *)__p, "scale");
        v69 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
        v70 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v69, &LocationForOp);
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(v70);
        v213 = mlir::getElementTypeOrSelf(v68);
        if (mlir::Type::isInteger((mlir::Type *)&v213, 8) || mlir::Type::isInteger((mlir::Type *)&v213, 4))
        {
          HIBYTE(__p[2]) = 4;
          strcpy((char *)__p, "axis");
          v72 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
          if (SHIBYTE(__p[2]) < 0)
            operator delete(__p[0]);
          MIL::IRValue::AsTensor(v72);
          v73 = *(int *)MIL::IRTensorValue::GetDataView<int>();
          IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v206, 0x20u, 1);
          v75 = LocationForOp;
          v76 = mlir::TypeAttr::get(ElementTypeOrSelf);
          v77 = mlir::IntegerAttr::get(IntegerType, v73);
          MLIRElemType = v75;
          Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&MLIRElemType);
          v79 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
          if (!v80)
          {
            v223 = 1283;
            v221 = "mps.dequantize";
            v222 = 14;
                   " added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependen"
                   "t-whats-up-with-dialects-management";
            v219 = 259;
            llvm::operator+((uint64_t *)v220, (uint64_t *)&v217, (uint64_t)&v225);
            llvm::report_fatal_error((llvm::Twine *)&v225, 1);
          }
          mlir::OperationState::OperationState(__p, v75, v79);
          mlir::mps::DequantizeOp::build(v206, (uint64_t *)__p, v66, v70, v68, v76, v77);
          v81 = mlir::OpBuilder::create((mlir::OpBuilder *)v206, (const mlir::OperationState *)__p);
          if (v81)
          {
            v82 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v81);
            if (v82)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)__p);
              (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
              if (!*(_DWORD *)(v82 + 36))
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              v83 = (int *)__p[0];
              v84 = (char *)operator new(8uLL);
              *(_QWORD *)v84 = v82 - 16;
              v225.__begin_ = v83;
              v85 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v208 + 8), (uint64_t)v83, (uint64_t)&std::piecewise_construct, (__int128 **)&v225);
              std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v85 + 5, v84, v84 + 8, 1uLL);
              operator delete(v84);
              v86 = (void **)__p[0];
              if (!__p[0])
                goto LABEL_187;
              v87 = (void **)__p[1];
              v88 = __p[0];
              if (__p[1] == __p[0])
                goto LABEL_185;
              do
              {
                if (*((char *)v87 - 1) < 0)
                  operator delete(*(v87 - 3));
                v87 -= 3;
              }
              while (v87 != v86);
LABEL_184:
              v88 = __p[0];
LABEL_185:
              __p[1] = v86;
LABEL_186:
              operator delete(v88);
              goto LABEL_187;
            }
            v201 = "result && \"builder didn't return the right type\"";
            v202 = 497;
            v203 = "Builders.h";
            v204 = "create";
          }
          else
          {
            v201 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            v202 = 662;
            v203 = "Casting.h";
            v204 = "dyn_cast";
          }
          __assert_rtn(v204, v203, v202, v201);
        }
        v7 = HIBYTE(v215.__r_.__value_.__r.__words[2]);
        size = v215.__r_.__value_.__l.__size_;
        v8 = (std::string *)v215.__r_.__value_.__r.__words[0];
      }
    }
  }
LABEL_46:
  if ((v7 & 0x80u) == 0)
    v30 = v7;
  else
    v30 = size;
  if ((v7 & 0x80u) == 0)
    v31 = &v215;
  else
    v31 = v8;
  if (v30 >= 31)
  {
    v32 = (char *)v31 + v30;
    v33 = v31;
    while (1)
    {
      v34 = (char *)memchr(v33, 99, v30 - 30);
      if (!v34)
        goto LABEL_66;
      v35 = *(_QWORD *)v34 == 0x70786574736E6F63 && *((_QWORD *)v34 + 1) == 0x776B636F6C625F72;
      v36 = v35 && *((_QWORD *)v34 + 2) == 0x666968735F657369;
      if (v36 && *(_QWORD *)(v34 + 23) == 0x656C6163735F7466)
        break;
      v33 = (std::string *)(v34 + 1);
      v30 = v32 - (char *)v33;
      if (v32 - (char *)v33 < 31)
        goto LABEL_66;
    }
    if (v34 != v32 && v34 - (char *)v31 != -1)
    {
      ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
      OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "offset");
      v54 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "scale");
      v55 = mlir::getElementTypeOrSelf(ArgValue);
      v56 = mlir::getElementTypeOrSelf(v54);
      v213 = 0;
      if (OptionalArgValue)
      {
        v57 = mlir::getElementTypeOrSelf(OptionalArgValue);
      }
      else
      {
        v100 = LocationForOp;
        __p[0] = (void *)1;
        v101 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v55, 0);
        __p[0] = (void *)mlir::mps::getConstantAttr<float>(v101, 0.0);
        v102 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v206, v100, (uint64_t **)__p);
        if (!*((_DWORD *)v102 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        OptionalArgValue = (uint64_t)v102 - 16;
        v57 = mlir::getElementTypeOrSelf((uint64_t)v102 - 16);
      }
      v213 = v57;
      if (mlir::Type::isInteger((mlir::Type *)&v213, 8) || mlir::Type::isInteger((mlir::Type *)&v213, 4))
      {
        v103 = LocationForOp;
        v104 = mlir::TypeAttr::get(v56);
        MLIRElemType = v103;
        v105 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&MLIRElemType);
        v106 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, v105);
        if (!v107)
        {
          v223 = 1283;
          v221 = "mps.dequantize";
          v222 = 14;
                 "dded by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-wh"
                 "ats-up-with-dialects-management";
          v219 = 259;
          llvm::operator+((uint64_t *)v220, (uint64_t *)&v217, (uint64_t)&v225);
          llvm::report_fatal_error((llvm::Twine *)&v225, 1);
        }
        mlir::OperationState::OperationState(__p, v103, v106);
        mlir::mps::DequantizeOp::build(v206, (uint64_t *)__p, ArgValue, v54, OptionalArgValue, v104, 0);
        v108 = mlir::OpBuilder::create((mlir::OpBuilder *)v206, (const mlir::OperationState *)__p);
        if (v108)
        {
          v109 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v108);
          if (v109)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)__p);
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
            if (!*(_DWORD *)(v109 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v110 = (int *)__p[0];
            v111 = (char *)operator new(8uLL);
            *(_QWORD *)v111 = v109 - 16;
            v225.__begin_ = v110;
            v112 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v208 + 8), (uint64_t)v110, (uint64_t)&std::piecewise_construct, (__int128 **)&v225);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v112 + 5, v111, v111 + 8, 1uLL);
            operator delete(v111);
            v86 = (void **)__p[0];
            if (!__p[0])
              goto LABEL_187;
            v113 = (void **)__p[1];
            v88 = __p[0];
            if (__p[1] == __p[0])
              goto LABEL_185;
            do
            {
              if (*((char *)v113 - 1) < 0)
                operator delete(*(v113 - 3));
              v113 -= 3;
            }
            while (v113 != v86);
            goto LABEL_184;
          }
          v194 = "result && \"builder didn't return the right type\"";
          v195 = 497;
          v196 = "Builders.h";
          v197 = "create";
        }
        else
        {
          v194 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          v195 = 662;
          v196 = "Casting.h";
          v197 = "dyn_cast";
        }
        __assert_rtn(v197, v196, v195, v194);
      }
      v7 = HIBYTE(v215.__r_.__value_.__r.__words[2]);
      size = v215.__r_.__value_.__l.__size_;
      v8 = (std::string *)v215.__r_.__value_.__r.__words[0];
    }
  }
LABEL_66:
  if ((v7 & 0x80u) == 0)
    v38 = v7;
  else
    v38 = size;
  if ((v7 & 0x80u) == 0)
    v39 = &v215;
  else
    v39 = v8;
  if (v38 < 22)
  {
LABEL_73:
    if ((v7 & 0x80u) != 0)
    {
      v40 = v8;
    }
    else
    {
      size = v7;
      v40 = &v215;
    }
    if (size > 22)
      goto LABEL_92;
LABEL_260:
    v166 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 64))(a2);
    (*(void (**)(std::vector<int> *__return_ptr, uint64_t, const MIL::IROperation *))(*(_QWORD *)v166 + 112))(&v225, v166, a2);
    if (v225.__begin_)
    {
      v167 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, (MIL::IRValue *)v225.__begin_, &LocationForOp);
      if (v167)
      {
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
        v168 = __p[0];
        v169 = (char *)operator new(8uLL);
        *(_QWORD *)v169 = v167;
        v220[0] = v168;
        v170 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v208 + 8), (uint64_t)v168, (uint64_t)&std::piecewise_construct, (__int128 **)v220);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v170 + 5, v169, v169 + 8, 1uLL);
        operator delete(v169);
        v171 = (void **)__p[0];
        if (__p[0])
        {
          v172 = (void **)__p[1];
          v173 = __p[0];
          if (__p[1] != __p[0])
          {
            do
            {
              if (*((char *)v172 - 1) < 0)
                operator delete(*(v172 - 3));
              v172 -= 3;
            }
            while (v172 != v171);
            v173 = __p[0];
          }
          __p[1] = v171;
          operator delete(v173);
        }
        v99 = 1;
      }
      else
      {
        v99 = 0;
      }
    }
    else
    {
      __p[0] = operator new(0x30uLL);
      *(_OWORD *)&__p[1] = xmmword_181267490;
      strcpy((char *)__p[0], "Couldn't get constant value for constExpr op");
      v99 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
    }
    v174 = (std::__shared_weak_count *)v225.__end_;
    if (v225.__end_)
    {
      v175 = (unint64_t *)(v225.__end_ + 2);
      do
        v176 = __ldaxr(v175);
      while (__stlxr(v176 - 1, v175));
      if (!v176)
      {
        ((void (*)(std::__shared_weak_count *))v174->__on_zero_shared)(v174);
        std::__shared_weak_count::__release_weak(v174);
      }
    }
    goto LABEL_302;
  }
  v41 = (char *)v39 + v38;
  v42 = v39;
  while (1)
  {
    v43 = (char *)memchr(v42, 99, v38 - 21);
    if (!v43)
    {
LABEL_88:
      if ((v7 & 0x80u) != 0)
      {
        v40 = v8;
      }
      else
      {
        size = v7;
        v40 = &v215;
      }
      if (size <= 22)
        goto LABEL_260;
LABEL_92:
      v46 = (char *)v40 + size;
      v47 = size;
      v48 = v40;
      while (1)
      {
        v49 = (char *)memchr(v48, 99, v47 - 22);
        if (!v49)
          goto LABEL_114;
        v50 = *(_QWORD *)v49 == 0x70786574736E6F63 && *((_QWORD *)v49 + 1) == 0x6F745F74756C5F72;
        if (v50 && *(_QWORD *)(v49 + 15) == 0x6573726170735F6FLL)
          break;
        v48 = (std::string *)(v49 + 1);
        v47 = v46 - (char *)v48;
        if (v46 - (char *)v48 < 23)
          goto LABEL_114;
      }
      if (v49 == v46 || v49 - (char *)v40 == -1)
      {
LABEL_114:
        if (size >= 38)
        {
          v59 = v40;
          while (1)
          {
            v60 = (char *)memchr(v59, 99, size - 37);
            if (!v60)
              break;
            if (*(_QWORD *)v60 == 0x70786574736E6F63
              && *((_QWORD *)v60 + 1) == 0x6573726170735F72
              && *((_QWORD *)v60 + 2) == 0x69776B636F6C625FLL
              && *((_QWORD *)v60 + 3) == 0x74666968735F6573
              && *(_QWORD *)(v60 + 30) == 0x656C6163735F7466)
            {
              if (v60 == v46 || v60 - (char *)v40 == -1)
                goto LABEL_260;
              goto LABEL_156;
            }
            v59 = (std::string *)(v60 + 1);
            size = v46 - (char *)v59;
            if (v46 - (char *)v59 < 38)
              goto LABEL_260;
          }
        }
        goto LABEL_260;
      }
LABEL_156:
      v89 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 64))(a2);
      (*(void (**)(void **__return_ptr, uint64_t, const MIL::IROperation *))(*(_QWORD *)v89 + 248))(__p, v89, a2);
      if ((void *)((char *)__p[1] - (char *)__p[0]) == (void *)32)
      {
        v90 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, *(MIL::IRValue **)__p[0], &LocationForOp);
        v91 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, *((MIL::IRValue **)__p[0] + 2), &LocationForOp);
        (*(void (**)(std::vector<int> *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&v225, a2);
        v92 = v225.__begin_;
        v93 = (char *)operator new(8uLL);
        *(_QWORD *)v93 = v90;
        v94 = (char *)(a3 + 8);
        v220[0] = v92;
        v95 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v92, (uint64_t)&std::piecewise_construct, (__int128 **)v220);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v95 + 5, v93, v93 + 8, 1uLL);
        operator delete(v93);
        v96 = v225.__begin_;
        if (v225.__begin_)
        {
          v97 = v225.__end_;
          v98 = v225.__begin_;
          if (v225.__end_ != v225.__begin_)
          {
            do
            {
              if (*((char *)v97 - 1) < 0)
                operator delete(*((void **)v97 - 3));
              v97 -= 6;
            }
            while (v97 != v96);
            v98 = v225.__begin_;
          }
          v225.__end_ = v96;
          operator delete(v98);
        }
        (*(void (**)(std::vector<int> *__return_ptr))(*(_QWORD *)v207 + 200))(&v225);
        v177 = v225.__begin_;
        v178 = (char *)operator new(8uLL);
        *(_QWORD *)v178 = v91;
        v220[0] = v177 + 6;
        v179 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v94, (uint64_t)(v177 + 6), (uint64_t)&std::piecewise_construct, (__int128 **)v220);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v179 + 5, v178, v178 + 8, 1uLL);
        operator delete(v178);
        v180 = v225.__begin_;
        if (v225.__begin_)
        {
          v181 = v225.__end_;
          v182 = v225.__begin_;
          if (v225.__end_ != v225.__begin_)
          {
            do
            {
              if (*((char *)v181 - 1) < 0)
                operator delete(*((void **)v181 - 3));
              v181 -= 6;
            }
            while (v181 != v180);
            v182 = v225.__begin_;
          }
          v225.__end_ = v180;
          operator delete(v182);
        }
        v99 = 1;
      }
      else
      {
        v225.__begin_ = (std::vector<int>::pointer)operator new(0x30uLL);
        *(_OWORD *)&v225.__end_ = xmmword_181286A90;
        strcpy((char *)v225.__begin_, "Couldn't get constant values for constExpr op");
        v99 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&v225);
        if (SHIBYTE(v225.__end_cap_.__value_) < 0)
          operator delete(v225.__begin_);
      }
      v183 = (char *)__p[0];
      if (__p[0])
      {
        v184 = (char *)__p[1];
        v185 = __p[0];
        if (__p[1] != __p[0])
        {
          do
          {
            v186 = (std::__shared_weak_count *)*((_QWORD *)v184 - 1);
            if (v186)
            {
              p_shared_owners = (unint64_t *)&v186->__shared_owners_;
              do
                v188 = __ldaxr(p_shared_owners);
              while (__stlxr(v188 - 1, p_shared_owners));
              if (!v188)
              {
                ((void (*)(std::__shared_weak_count *))v186->__on_zero_shared)(v186);
                std::__shared_weak_count::__release_weak(v186);
              }
            }
            v184 -= 16;
          }
          while (v184 != v183);
          v185 = __p[0];
        }
        __p[1] = v183;
        goto LABEL_301;
      }
      goto LABEL_302;
    }
    v44 = *(_QWORD *)v43 == 0x70786574736E6F63 && *((_QWORD *)v43 + 1) == 0x6F745F74756C5F72;
    if (v44 && *(_QWORD *)(v43 + 14) == 0x65736E65645F6F74)
      break;
    v42 = (std::string *)(v43 + 1);
    v38 = v41 - (char *)v42;
    if (v41 - (char *)v42 < 22)
      goto LABEL_88;
  }
  if (v43 == v41 || v43 - (char *)v39 == -1)
    goto LABEL_73;
  if ((v7 & 0x80) == 0)
  {
    v58 = a3 + 13;
    if ((_DWORD)v7 == 28)
    {
      v8 = &v215;
      goto LABEL_189;
    }
LABEL_205:
    MLIRElemType = 0;
    v212 = 0;
    v213 = 0;
    goto LABEL_206;
  }
  v58 = a3 + 13;
  if (size != 28)
    goto LABEL_205;
LABEL_189:
  v116 = v8->__r_.__value_.__r.__words[0] == 0x6F632E3831736F69
      && v8->__r_.__value_.__l.__size_ == 0x5F7270786574736ELL
      && v8->__r_.__value_.__r.__words[2] == 0x645F6F745F74756CLL
      && LODWORD(v8[1].__r_.__value_.__l.__data_) == 1702063717;
  MLIRElemType = 0;
  v212 = 0;
  v213 = 0;
  if (v116)
  {
    HIBYTE(__p[2]) = 7;
    strcpy((char *)__p, "indices");
    v117 = (const MIL::IRValue *)(*(uint64_t (**)(const MIL::IROperation *, void **, _QWORD))(*(_QWORD *)a2 + 128))(a2, __p, 0);
    MLIRElemTypeFromMILValue = getMLIRElemTypeFromMILValue(v117, *v58);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    if (MLIRElemTypeFromMILValue)
      v213 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
    v119 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "lut");
    v212 = v119;
    v120 = 1;
  }
  else
  {
LABEL_206:
    HIBYTE(__p[2]) = 7;
    strcpy((char *)__p, "indices");
    v121 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
    v213 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v121, &LocationForOp);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    HIBYTE(__p[2]) = 3;
    LODWORD(__p[0]) = 7632236;
    v122 = (MIL::IRValue *)MIL::IRObject::GetAttribute();
    v119 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, v122, &LocationForOp);
    v212 = v119;
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
      v119 = v212;
    }
    v120 = 0;
  }
  v123 = *(_QWORD *)(v119 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v123)
  {
    v190 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v191 = 650;
    v192 = "Casting.h";
    v193 = "dyn_cast";
    goto LABEL_315;
  }
  if (!*(_QWORD *)v123)
  {
    v190 = "abstractType && \"Malformed type storage object.\"";
    v191 = 160;
    v192 = "TypeSupport.h";
    v193 = "getAbstractType";
LABEL_315:
    __assert_rtn(v193, v192, v191, v190);
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v123 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v123 = 0;
  v211 = v123;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v211);
  if (!v120)
  {
    if (v125)
    {
      if (*(_QWORD *)(Value + 8 * v125 - 8) == 256)
      {
        HIBYTE(__p[2]) = 5;
        strcpy((char *)__p, "shape");
        v139 = MIL::IRObject::TryGetAttribute();
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
        if (!v139)
        {
          std::string::basic_string[abi:ne180100]<0>(__p, "Couldn't get value for parameter: \"shape\"");
          v99 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
          if (SHIBYTE(__p[2]) < 0)
          {
            v185 = __p[0];
LABEL_301:
            operator delete(v185);
          }
          goto LABEL_302;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v139 + 40))(v139);
        Data = MIL::IRTensorValue::GetDataView<unsigned int>();
        v142 = (std::vector<int>::size_type)v141;
        v225.__begin_ = v141;
        llvm::SmallVector<long long,4u>::SmallVector(__p, &v225, 1);
        v143 = __p[0];
        v144 = LODWORD(__p[1]);
        v225.__begin_ = (std::vector<int>::pointer)(*(_QWORD *)(v212 + 8) & 0xFFFFFFFFFFFFFFF8);
        v145 = mlir::Attribute::getContext((mlir::Attribute *)&v225);
        v146 = mlir::IntegerType::get(v145, 0x20u, 1u);
        v220[0] = (void *)mlir::RankedTensorType::get((uint64_t)v143, v144, v146, 0);
        v217 = (const char *)mlir::Type::cast<mlir::ShapedType>((uint64_t **)v220);
        v218 = v147;
        memset(&v225, 0, sizeof(v225));
        std::vector<int>::resize(&v225, v142);
        if (v142 != 1)
        {
          v148 = 0;
          v149 = v225.__begin_;
          v150 = v142 - 2;
          if (v142 < v142 - 2)
            v150 = v142;
          v151 = v150 + 1;
          if (v151 >= 9 && (unint64_t)v225.__begin_ - Data > 0x1F)
          {
            v152 = v151 & 7;
            if ((v151 & 7) == 0)
              v152 = 8;
            v148 = v151 - v152;
            v153 = (__int128 *)(Data + 16);
            v154 = v225.__begin_ + 4;
            v155 = v148;
            do
            {
              v156 = *v153;
              *((_OWORD *)v154 - 1) = *(v153 - 1);
              *(_OWORD *)v154 = v156;
              v153 += 2;
              v154 += 8;
              v155 -= 8;
            }
            while (v155);
          }
          v157 = (int *)(Data + 4 * v148);
          v158 = &v149[v148];
          v159 = v142 - v148;
          do
          {
            if (!v159)
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              std::runtime_error::runtime_error(exception, "index out of bounds");
              exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
              __cxa_throw(exception, (struct type_info *)off_1E0DF5DB8, MEMORY[0x1E0DE42B0]);
            }
            v160 = *v157++;
            *v158++ = v160;
            --v159;
          }
          while (v159 != 1);
        }
        v161 = (int *)MIL::Util::Span<unsigned int const,18446744073709551615ul>::operator[](Data, v142, v142 - 1);
        v162 = *v161;
        v225.__begin_[v142 - 1] = *v161;
        v163 = *(_DWORD *)MIL::Util::Span<unsigned int const,18446744073709551615ul>::operator[](Data, v142, v142 - 1);
        if (v162 == v163)
        {
          v210 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v217, v218, v225.__begin_, 4 * v142, 4, 1, 1);
          v209 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>((mlir::OpBuilder *)v206, LocationForOp, (uint64_t *)&v217, &v210);
          v164 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(v206, LocationForOp, &v213, &v209);
          if (!*((_DWORD *)v164 + 9))
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          v213 = (uint64_t)v164 - 16;
          v165 = mlir::OpBuilder::create<mlir::mps::DequantizeLUTOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &>(v206, LocationForOp, &v213, &v212, &MLIRElemType);
          if (!*(_DWORD *)(v165 + 36))
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v220, a2);
          MILToMLIRRewriter::setValue((uint64_t)a3, (__int128 *)v220[0], v165 - 16);
          std::vector<std::string>::~vector[abi:ne180100](v220);
        }
        if (v225.__begin_)
        {
          v225.__end_ = v225.__begin_;
          operator delete(v225.__begin_);
        }
        if (__p[0] != &__p[2])
          free(__p[0]);
        if (v162 == v163)
        {
LABEL_187:
          v99 = 1;
          goto LABEL_302;
        }
      }
LABEL_256:
      size = v215.__r_.__value_.__l.__size_;
      if ((v215.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      {
        v40 = (std::string *)v215.__r_.__value_.__r.__words[0];
      }
      else
      {
        size = HIBYTE(v215.__r_.__value_.__r.__words[2]);
        v40 = &v215;
      }
      if (size <= 22)
        goto LABEL_260;
      goto LABEL_92;
    }
    v198 = "!empty()";
    v199 = 175;
    v200 = "back";
LABEL_323:
    __assert_rtn(v200, "ArrayRef.h", v199, v198);
  }
  if (v125 <= 1)
  {
    v198 = "Index < Length && \"Invalid index!\"";
    v199 = 257;
    v200 = "operator[]";
    goto LABEL_323;
  }
  v126 = Value + 8 * v125;
  if (*(_QWORD *)(v126 - 8) != 1)
    goto LABEL_256;
  v127 = *(_QWORD *)(v126 - 16);
  if (v127 != 256 && v127 != 16)
    goto LABEL_256;
  std::string::basic_string[abi:ne180100]<0>(__p, "vector_axis");
  ParameterValue = (MIL::IRValue *)MIL::IROperation::TryGetParameterValue();
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  if (!ParameterValue)
  {
LABEL_225:
    LODWORD(v225.__begin_) = -1;
    std::vector<int>::vector[abi:ne180100](__p, &v225, 1uLL);
    v220[0] = (void *)1;
    v133 = mlir::Builder::getIntegerType((mlir::Builder *)v206, 0x20u, 1);
    v225.__begin_ = (std::vector<int>::pointer)mlir::RankedTensorType::get((uint64_t)v220, 1, v133, 0);
    v134 = LocationForOp;
    v135 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v225);
    v217 = (const char *)mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v135, v136, (uint64_t)__p[0], (uint64_t)__p[1]);
    v220[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v206, v134, (uint64_t **)&v217);
    v137 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)v206, LocationForOp, &v212, v220);
    if (!*((_DWORD *)v137 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v212 = (uint64_t)v137 - 16;
    MLIRElemType = 0;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v138 = mlir::OpBuilder::create<mlir::mps::DequantizeLUTOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &>(v206, LocationForOp, &v213, &v212, &MLIRElemType);
    if (!*(_DWORD *)(v138 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
    MILToMLIRRewriter::setValue((uint64_t)a3, (__int128 *)__p[0], v138 - 16);
    std::vector<std::string>::~vector[abi:ne180100](__p);
    goto LABEL_187;
  }
  v129 = (MIL::IRValueType *)(*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)ParameterValue + 32))(ParameterValue);
  v130 = MIL::IRValueType::AsTensorType(v129);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v130 + 88))(v130) == 11)
  {
    MIL::IRValue::AsTensor(ParameterValue);
    v131 = *(int *)MIL::IRTensorValue::GetDataView<int>();
    v132 = mlir::Builder::getIntegerType((mlir::Builder *)v206, 0x20u, 1);
    MLIRElemType = mlir::IntegerAttr::get(v132, v131);
    goto LABEL_225;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, "unexpected type for axis");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
  v99 = 0;
LABEL_302:
  if (SHIBYTE(v215.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v215.__r_.__value_.__l.__data_);
  return v99;
}

void sub_180E05314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a41 < 0)
    operator delete(__p);
  if (a24 < 0)
    operator delete(a19);
  _Unwind_Resume(exception_object);
}

uint64_t mlir::Type::dyn_cast<mlir::RankedTensorType>(uint64_t result)
{
  if (!result)
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  if (!*(_QWORD *)result)
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  if (*(_UNKNOWN **)(*(_QWORD *)result + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    return 0;
  return result;
}

uint64_t mlir::OpBuilder::create<mlir::mps::DequantizeLUTOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize_lut", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.dequantize_lut";
    v23[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::DequantizeLUTOp::build(a1, (uint64_t)v26, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeLUTOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeLUTOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E057E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E057F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

_QWORD *llvm::SmallVector<long long,4u>::SmallVector(_QWORD *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x400000000;
  llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)a1, a2, &a2[8 * a3]);
  return a1;
}

void sub_180E05848(_Unwind_Exception *exception_object)
{
  void **v1;
  void *v2;
  void *v3;

  v3 = v2;
  if (*v1 != v3)
    free(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t MIL::Util::Span<unsigned int const,18446744073709551615ul>::operator[](uint64_t a1, unint64_t a2, unint64_t a3)
{
  std::runtime_error *exception;

  if (a2 <= a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::range_error::range_error[abi:ne180100](exception);
    __cxa_throw(exception, (struct type_info *)off_1E0DF5DB8, MEMORY[0x1E0DE42B0]);
  }
  return a1 + 4 * a3;
}

void sub_180E058B4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<MIL::IRValue const>>::~vector[abi:ne180100](void **a1)
{
  char *v2;
  char *v3;
  void *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        v5 = (std::__shared_weak_count *)*((_QWORD *)v3 - 1);
        if (v5)
        {
          p_shared_owners = (unint64_t *)&v5->__shared_owners_;
          do
            v7 = __ldaxr(p_shared_owners);
          while (__stlxr(v7 - 1, p_shared_owners));
          if (!v7)
          {
            ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
            std::__shared_weak_count::__release_weak(v5);
          }
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t MILToMLIR::ReshapeLikePattern::matchAndRewrite(MILToMLIR::ReshapeLikePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  int v12;
  size_t v13;
  const void *v14;
  size_t v15;
  int v16;
  _BOOL4 v17;
  BOOL v18;
  uint64_t *v19;
  int v20;
  size_t v21;
  const void *v22;
  size_t v23;
  int v24;
  _BOOL4 v25;
  int v26;
  _QWORD *v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  uint64_t ParameterValue;
  uint64_t Data;
  uint64_t v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  unint64_t v42;
  int v43;
  int v44;
  uint64_t *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  char *v51;
  char *v52;
  char *v53;
  unint64_t v54;
  uint64_t *v55;
  uint64_t Value;
  unint64_t v57;
  int v58;
  int v59;
  int v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  _BYTE *v69;
  char *v70;
  int64_t v71;
  unint64_t v72;
  char *v73;
  int v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _OWORD *v78;
  __int128 *v79;
  uint64_t v80;
  __int128 v81;
  _BYTE *v82;
  uint64_t v83;
  uint64_t v84;
  mlir::OpBuilder *v85;
  uint64_t IntegerType;
  uint64_t **v87;
  uint64_t InterfaceFor;
  const char *v89;
  int v90;
  const char *v91;
  const char *v92;
  uint64_t *v93;
  mlir::GenericProgramPoint *v94;
  __int128 *v95;
  char *v96;
  uint64_t *v97;
  uint64_t *v98;
  uint64_t *v99;
  uint64_t *v100;
  int v102;
  const char *v103;
  const char *v104;
  const char *v105;
  uint64_t v106;
  MILToMLIRRewriter *v107;
  unint64_t v108;
  _QWORD *v109;
  unint64_t v110;
  const MIL::IROperation *v111;
  int v112;
  unint64_t v113;
  int v114;
  uint64_t v115;
  mlir::GenericProgramPoint *v116;
  uint64_t *v117[4];
  void *v118[2];
  char *v119;
  void *__p[2];
  char v121;
  void *v122[3];
  _QWORD *v123;
  _BYTE *v124;
  uint64_t ArgValue;
  __int128 *v126;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v107 = (MILToMLIRRewriter *)a3;
  MILToMLIRRewriter::getArgValues((int8x8_t *)a3, a2, "ref_tensors", &v123);
  v121 = 6;
  strcpy((char *)__p, "begins");
  v111 = a2;
  MILToMLIR::getVariadicConstants<int>((char **)v122, (uint64_t)a2, (uint64_t)__p);
  if (v121 < 0)
    operator delete(__p[0]);
  HIBYTE(v119) = 4;
  strcpy((char *)v118, "ends");
  MILToMLIR::getVariadicConstants<int>((char **)__p, (uint64_t)a2, (uint64_t)v118);
  if (SHIBYTE(v119) < 0)
    operator delete(v118[0]);
  v106 = LocationForOp;
  HIBYTE(v119) = 9;
  strcpy((char *)v118, "end_masks");
  v6 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v7 = v6 + 8;
  v8 = *(_QWORD *)(v6 + 8);
  if (!v8)
    goto LABEL_44;
  v9 = SHIBYTE(v119) >= 0 ? (void *)HIBYTE(v119) : v118[1];
  v10 = SHIBYTE(v119) >= 0 ? v118 : (void **)v118[0];
  v11 = v6 + 8;
  do
  {
    v12 = *(char *)(v8 + 55);
    if (v12 >= 0)
      v13 = *(unsigned __int8 *)(v8 + 55);
    else
      v13 = *(_QWORD *)(v8 + 40);
    if (v12 >= 0)
      v14 = (const void *)(v8 + 32);
    else
      v14 = *(const void **)(v8 + 32);
    if ((unint64_t)v9 >= v13)
      v15 = v13;
    else
      v15 = (size_t)v9;
    v16 = memcmp(v14, v10, v15);
    v17 = v13 < (unint64_t)v9;
    if (v16)
      v17 = v16 < 0;
    v18 = !v17;
    if (v17)
      v19 = (uint64_t *)(v8 + 8);
    else
      v19 = (uint64_t *)v8;
    if (v18)
      v11 = v8;
    v8 = *v19;
  }
  while (*v19);
  if (v11 == v7)
    goto LABEL_44;
  v20 = *(char *)(v11 + 55);
  if (v20 >= 0)
    v21 = *(unsigned __int8 *)(v11 + 55);
  else
    v21 = *(_QWORD *)(v11 + 40);
  if (v20 >= 0)
    v22 = (const void *)(v11 + 32);
  else
    v22 = *(const void **)(v11 + 32);
  if (v21 >= (unint64_t)v9)
    v23 = (size_t)v9;
  else
    v23 = v21;
  v24 = memcmp(v10, v22, v23);
  v25 = (unint64_t)v9 < v21;
  if (v24)
    v25 = v24 < 0;
  if (v25)
LABEL_44:
    v11 = v7;
  if (v11 != (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)v111 + 160))(v111) + 8)
  {
    v26 = (*(uint64_t (**)(const MIL::IROperation *, void **))(*(_QWORD *)v111 + 152))(v111, v118);
    if (v26)
    {
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      v112 = v26;
      while (1)
      {
        ParameterValue = MIL::IROperation::TryGetParameterValue();
        (*(void (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
        Data = MIL::IRTensorValue::GetDataView<BOOL>();
        v114 = v30;
        if (v34)
          break;
        v31 = v29;
LABEL_49:
        v30 = v114 + 1;
        v29 = v31;
        if (v114 + 1 == v112)
          goto LABEL_85;
      }
      v35 = (unsigned __int8 *)Data;
      v36 = (unsigned __int8 *)(Data + v34);
      while (1)
      {
        v37 = *v35;
        v31 = v29 + 1;
        v38 = v29 >> 6;
        if (v29 == v28 << 6)
        {
          if ((v31 & 0x8000000000000000) != 0)
            goto LABEL_177;
          if (v29 <= 0x3FFFFFFFFFFFFFFELL)
          {
            v39 = v28 << 7;
            if (v28 << 7 <= (v29 & 0xFFFFFFFFFFFFFFC0) + 64)
              v39 = (v29 & 0xFFFFFFFFFFFFFFC0) + 64;
            if (v29 >= v39)
              goto LABEL_81;
            if ((v39 & 0x8000000000000000) != 0)
LABEL_177:
              std::vector<int>::__throw_length_error[abi:ne180100]();
LABEL_62:
            v28 = ((v39 - 1) >> 6) + 1;
            v40 = operator new(8 * v28);
            v41 = v40;
            v42 = (v29 - 1) >> 6;
            if (v29 < 0x41)
              v42 = 0;
            v40[v42] = 0;
            if (v29 > 0x3F || (v29 & 0x3F) != 0)
            {
              v43 = 0;
              v44 = 0;
              v45 = v40;
              v46 = v27;
              do
              {
                v47 = 1 << v43;
                if (((*v46 >> v44) & 1) != 0)
                  v48 = *v45 | v47;
                else
                  v48 = *v45 & ~v47;
                *v45 = v48;
                v46 += v44 == 63;
                if (v44 == 63)
                  v44 = 0;
                else
                  ++v44;
                v45 += v43 == 63;
                if (v43 == 63)
                  v43 = 0;
                else
                  ++v43;
              }
              while (v44 != (v29 & 0x3F) || v46 != &v27[v38]);
            }
            if (v27)
              operator delete(v27);
            v27 = v41;
            goto LABEL_81;
          }
          v39 = 0x7FFFFFFFFFFFFFFFLL;
          if (v29 < 0x7FFFFFFFFFFFFFFFLL)
            goto LABEL_62;
        }
LABEL_81:
        v49 = 1 << v29;
        if (v37)
        {
          v27[v38] |= v49;
          ++v35;
          ++v29;
          if (v35 == v36)
            goto LABEL_49;
        }
        else
        {
          v27[v38] &= ~v49;
          ++v35;
          ++v29;
          if (v35 == v36)
            goto LABEL_49;
        }
      }
    }
  }
  v27 = 0;
  v31 = 0;
LABEL_85:
  if (SHIBYTE(v119) < 0)
  {
    operator delete(v118[0]);
    v118[0] = 0;
    v118[1] = 0;
    v119 = 0;
    v50 = v123;
    v109 = v27;
    if (v124 != (_BYTE *)v123)
      goto LABEL_87;
LABEL_137:
    v82 = 0;
    v53 = 0;
    goto LABEL_143;
  }
  v118[0] = 0;
  v118[1] = 0;
  v119 = 0;
  v50 = v123;
  v109 = v27;
  if (v124 == (_BYTE *)v123)
    goto LABEL_137;
LABEL_87:
  v51 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v108 = v31;
  do
  {
    v55 = (uint64_t *)(*(_QWORD *)(v50[v54] + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v55)
    {
      v102 = 650;
      v103 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v104 = "Casting.h";
      v105 = "dyn_cast";
      goto LABEL_173;
    }
    if (!*v55)
    {
      v102 = 160;
      v105 = "getAbstractType";
      v104 = "TypeSupport.h";
      v103 = "abstractType && \"Malformed type storage object.\"";
LABEL_173:
      __assert_rtn(v105, v104, v102, v103);
    }
    if (*(_UNKNOWN **)(*v55 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      v55 = 0;
    v117[0] = v55;
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v117);
    v58 = *((_DWORD *)__p[0] + v54);
    if (v31 && ((*(_QWORD *)((char *)v27 + ((v54 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v54) & 1) != 0)
      v58 = v57;
    v59 = *((_DWORD *)v122[0] + v54);
    v60 = v57 & (v59 >> 31);
    v61 = (v60 + v59);
    if (v60 + v59 < 0 || v57 <= v61)
    {
      v117[0] = (uint64_t *)operator new(0x19uLL);
      *(_OWORD *)&v117[1] = xmmword_181232CD0;
      v83 = MILToMLIRRewriter::notifyFailure((uint64_t)v107, (uint64_t *)v117);
LABEL_140:
      v84 = v83;
      if (SHIBYTE(v117[2]) < 0)
        operator delete(v117[0]);
      goto LABEL_159;
    }
    v62 = (v57 & (v58 >> 31)) + v58;
    if ((v62 & 0x80000000) != 0 || v57 < v62)
    {
      HIBYTE(v117[2]) = 21;
      v83 = MILToMLIRRewriter::notifyFailure((uint64_t)v107, (uint64_t *)v117);
      goto LABEL_140;
    }
    v110 = v54;
    if (v61 < v62)
    {
      if (v57 <= v61)
        v63 = (v60 + v59);
      else
        v63 = v57;
      v64 = v53;
      v113 = v63;
      v115 = Value;
      do
      {
        while (1)
        {
          if (v61 == v63)
            __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
          v65 = *(_QWORD *)(Value + 8 * v61);
          if (v64 >= v52)
            break;
          *(_DWORD *)v64 = v65;
          v64 += 4;
          v53 = v64;
          v118[1] = v64;
          if ((int)v62 <= (int)++v61)
            goto LABEL_88;
        }
        v66 = (v64 - v51) >> 2;
        v67 = v66 + 1;
        if ((unint64_t)(v66 + 1) >> 62)
          std::vector<int>::__throw_length_error[abi:ne180100]();
        if ((v52 - v51) >> 1 > v67)
          v67 = (v52 - v51) >> 1;
        if ((unint64_t)(v52 - v51) >= 0x7FFFFFFFFFFFFFFCLL)
          v68 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v68 = v67;
        if (v68)
        {
          if (v68 >> 62)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v69 = operator new(4 * v68);
          v70 = &v69[4 * v66];
          *(_DWORD *)v70 = v65;
          v53 = v70 + 4;
          v71 = v64 - v51;
          if (v64 == v51)
            goto LABEL_122;
        }
        else
        {
          v69 = 0;
          v70 = (char *)(4 * v66);
          *(_DWORD *)(4 * v66) = v65;
          v53 = (char *)(4 * v66 + 4);
          v71 = v64 - v51;
          if (v64 == v51)
            goto LABEL_122;
        }
        v72 = v71 - 4;
        if (v72 >= 0xBC)
        {
          v75 = (v64 - 4 - v51) & 0xFFFFFFFFFFFFFFFCLL;
          if (&v69[v64 - v51 - 4 - v75] > &v69[v64 - v51 - 4])
          {
            v73 = v64;
          }
          else if (&v64[-v75 - 4] > v64 - 4)
          {
            v73 = v64;
          }
          else if ((unint64_t)(v51 - v69) >= 0x20)
          {
            v76 = (v72 >> 2) + 1;
            v77 = 4 * (v76 & 0x7FFFFFFFFFFFFFF8);
            v73 = &v64[-v77];
            v70 -= v77;
            v78 = &v69[4 * v66 - 16];
            v79 = (__int128 *)(v64 - 16);
            v80 = v76 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              v81 = *v79;
              *(v78 - 1) = *(v79 - 1);
              *v78 = v81;
              v78 -= 2;
              v79 -= 2;
              v80 -= 8;
            }
            while (v80);
            if (v76 == (v76 & 0x7FFFFFFFFFFFFFF8))
              goto LABEL_122;
          }
          else
          {
            v73 = v64;
          }
        }
        else
        {
          v73 = v64;
        }
        do
        {
          v74 = *((_DWORD *)v73 - 1);
          v73 -= 4;
          *((_DWORD *)v70 - 1) = v74;
          v70 -= 4;
        }
        while (v73 != v51);
LABEL_122:
        v52 = &v69[4 * v68];
        v118[0] = v70;
        v118[1] = v53;
        v119 = v52;
        if (v51)
          operator delete(v51);
        v51 = v70;
        v63 = v113;
        Value = v115;
        v118[1] = v53;
        ++v61;
        v64 = v53;
      }
      while ((int)v62 > (int)v61);
    }
LABEL_88:
    v27 = v109;
    v54 = v110 + 1;
    v50 = v123;
    v31 = v108;
  }
  while (v110 + 1 < (v124 - (_BYTE *)v123) >> 3);
  v82 = v118[0];
LABEL_143:
  v85 = (MILToMLIRRewriter *)((char *)v107 + 104);
  v117[0] = (uint64_t *)((v53 - v82) >> 2);
  IntegerType = mlir::Builder::getIntegerType((MILToMLIRRewriter *)((char *)v107 + 104), 0x20u, 1);
  v87 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v117, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v87))
    goto LABEL_174;
  if (v87)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v87);
    if (!InterfaceFor)
    {
      v89 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v90 = 98;
      v91 = "InterfaceSupport.h";
      v92 = "Interface";
      goto LABEL_175;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v93 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v87, InterfaceFor, v82, v53 - v82, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v93) & 1) == 0)
  {
LABEL_174:
    v89 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v90 = 566;
    v91 = "Casting.h";
    v92 = "cast";
LABEL_175:
    __assert_rtn(v92, v91, v90, v89);
  }
  v117[0] = v93;
  v116 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v85, v106, v117);
  v94 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::UnitAttr **)v85, v106, &ArgValue, &v116);
  (*(void (**)(uint64_t **__return_ptr))(*(_QWORD *)v111 + 200))(v117);
  if (!*((_DWORD *)v94 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v95 = (__int128 *)v117[0];
  v96 = (char *)operator new(8uLL);
  *(_QWORD *)v96 = (char *)v94 - 16;
  v126 = v95;
  v97 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v107 + 64, (uint64_t)v95, (uint64_t)&std::piecewise_construct, &v126);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v97 + 5, v96, v96 + 8, 1uLL);
  operator delete(v96);
  v98 = v117[0];
  if (v117[0])
  {
    v99 = v117[1];
    v100 = v117[0];
    if (v117[1] != v117[0])
    {
      do
      {
        if (*((char *)v99 - 1) < 0)
          operator delete((void *)*(v99 - 3));
        v99 -= 3;
      }
      while (v99 != v98);
      v100 = v117[0];
    }
    v117[1] = v98;
    operator delete(v100);
  }
  v84 = 1;
  v27 = v109;
LABEL_159:
  if (v118[0])
    operator delete(v118[0]);
  if (v27)
    operator delete(v27);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v122[0])
  {
    v122[1] = v122[0];
    operator delete(v122[0]);
  }
  if (v123)
  {
    v124 = v123;
    operator delete(v123);
  }
  return v84;
}

void sub_180E06388(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39)
{
  uint64_t v39;
  void *v41;

  if (a24 < 0)
    operator delete(__p);
  if (a26)
    operator delete(a26);
  if (a13)
    operator delete(a13);
  if (a32)
    operator delete(a32);
  if (a38)
    operator delete(a38);
  v41 = *(void **)(v39 - 136);
  if (v41)
  {
    *(_QWORD *)(v39 - 128) = v41;
    operator delete(v41);
  }
  _Unwind_Resume(exception_object);
}

void MILToMLIR::getVariadicConstants<int>(char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  size_t v8;
  const void *v9;
  uint64_t v10;
  int v11;
  size_t v12;
  const void *v13;
  size_t v14;
  int v15;
  _BOOL4 v16;
  BOOL v17;
  uint64_t *v18;
  int v19;
  size_t v20;
  const void *v21;
  size_t v22;
  int v23;
  _BOOL4 v24;
  int v25;
  char *v26;
  char *v27;
  char *v28;
  int v29;
  uint64_t v30;
  uint64_t ParameterValue;
  uint64_t Data;
  uint64_t v33;
  int *v34;
  int *v35;
  int v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  _BYTE *v40;
  char *v41;
  int64_t v42;
  unint64_t v43;
  char *v44;
  int v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _OWORD *v49;
  char *v50;
  uint64_t v51;
  __int128 v52;
  int v53;
  int *v56;
  int v57;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 160))(a2);
  v5 = v4 + 8;
  v6 = *(_QWORD *)(v4 + 8);
  if (!v6)
    goto LABEL_40;
  v7 = *(char *)(a3 + 23);
  v8 = v7 >= 0 ? *(unsigned __int8 *)(a3 + 23) : *(_QWORD *)(a3 + 8);
  v9 = v7 >= 0 ? (const void *)a3 : *(const void **)a3;
  v10 = v4 + 8;
  do
  {
    v11 = *(char *)(v6 + 55);
    if (v11 >= 0)
      v12 = *(unsigned __int8 *)(v6 + 55);
    else
      v12 = *(_QWORD *)(v6 + 40);
    if (v11 >= 0)
      v13 = (const void *)(v6 + 32);
    else
      v13 = *(const void **)(v6 + 32);
    if (v8 >= v12)
      v14 = v12;
    else
      v14 = v8;
    v15 = memcmp(v13, v9, v14);
    v16 = v12 < v8;
    if (v15)
      v16 = v15 < 0;
    v17 = !v16;
    if (v16)
      v18 = (uint64_t *)(v6 + 8);
    else
      v18 = (uint64_t *)v6;
    if (v17)
      v10 = v6;
    v6 = *v18;
  }
  while (*v18);
  if (v10 == v5)
    goto LABEL_40;
  v19 = *(char *)(v10 + 55);
  if (v19 >= 0)
    v20 = *(unsigned __int8 *)(v10 + 55);
  else
    v20 = *(_QWORD *)(v10 + 40);
  if (v19 >= 0)
    v21 = (const void *)(v10 + 32);
  else
    v21 = *(const void **)(v10 + 32);
  if (v20 >= v8)
    v22 = v8;
  else
    v22 = v20;
  v23 = memcmp(v9, v21, v22);
  v24 = v8 < v20;
  if (v23)
    v24 = v23 < 0;
  if (v24)
LABEL_40:
    v10 = v5;
  if (v10 != (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 160))(a2) + 8)
  {
    v25 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 152))(a2, a3);
    if (v25)
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 0;
      v53 = v25;
      while (1)
      {
        ParameterValue = MIL::IROperation::TryGetParameterValue();
        (*(void (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
        Data = MIL::IRTensorValue::GetDataView<int>();
        if (v33)
          break;
        v30 = (uint64_t)v28;
LABEL_45:
        ++v29;
        v28 = (char *)v30;
        if (v29 == v53)
          return;
      }
      v34 = (int *)Data;
      v35 = (int *)(Data + 4 * v33);
      v57 = v29;
      v56 = v35;
      while (1)
      {
        while (1)
        {
          v36 = *v34;
          if (v28 >= v27)
            break;
          *(_DWORD *)v28 = v36;
          v28 += 4;
          v30 = (uint64_t)v28;
          a1[1] = v28;
          if (++v34 == v35)
            goto LABEL_45;
        }
        v37 = (v28 - v26) >> 2;
        v38 = v37 + 1;
        if ((unint64_t)(v37 + 1) >> 62)
          std::vector<int>::__throw_length_error[abi:ne180100]();
        if ((v27 - v26) >> 1 > v38)
          v38 = (v27 - v26) >> 1;
        if ((unint64_t)(v27 - v26) >= 0x7FFFFFFFFFFFFFFCLL)
          v39 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v39 = v38;
        if (v39)
        {
          if (v39 >> 62)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v40 = operator new(4 * v39);
          v41 = &v40[4 * v37];
          *(_DWORD *)v41 = v36;
          v30 = (uint64_t)(v41 + 4);
          v42 = v28 - v26;
          if (v28 == v26)
            goto LABEL_64;
        }
        else
        {
          v40 = 0;
          v41 = (char *)(4 * v37);
          *(_DWORD *)(4 * v37) = v36;
          v30 = 4 * v37 + 4;
          v42 = v28 - v26;
          if (v28 == v26)
            goto LABEL_64;
        }
        v43 = v42 - 4;
        if (v43 < 0xBC)
        {
          v44 = v28;
          goto LABEL_63;
        }
        v46 = (v28 - 4 - v26) & 0xFFFFFFFFFFFFFFFCLL;
        if (&v40[v28 - v26 - 4 - v46] > &v40[v28 - v26 - 4])
          break;
        if (&v28[-v46 - 4] > v28 - 4)
        {
          v44 = v28;
          goto LABEL_63;
        }
        if ((unint64_t)(v26 - v40) < 0x20)
        {
          v44 = v28;
          goto LABEL_63;
        }
        v47 = (v43 >> 2) + 1;
        v48 = 4 * (v47 & 0x7FFFFFFFFFFFFFF8);
        v44 = &v28[-v48];
        v41 -= v48;
        v49 = &v40[4 * v37 - 16];
        v50 = v28 - 16;
        v51 = v47 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v52 = *(_OWORD *)v50;
          *(v49 - 1) = *((_OWORD *)v50 - 1);
          *v49 = v52;
          v49 -= 2;
          v50 -= 32;
          v51 -= 8;
        }
        while (v51);
        if (v47 != (v47 & 0x7FFFFFFFFFFFFFF8))
          goto LABEL_63;
LABEL_64:
        v27 = &v40[4 * v39];
        *a1 = v41;
        a1[1] = (char *)v30;
        a1[2] = v27;
        if (v26)
          operator delete(v26);
        v26 = v41;
        v29 = v57;
        v35 = v56;
        a1[1] = (char *)v30;
        ++v34;
        v28 = (char *)v30;
        if (v34 == v56)
          goto LABEL_45;
      }
      v44 = v28;
      do
      {
LABEL_63:
        v45 = *((_DWORD *)v44 - 1);
        v44 -= 4;
        *((_DWORD *)v41 - 1) = v45;
        v41 -= 4;
      }
      while (v44 != v26);
      goto LABEL_64;
    }
  }
}

void sub_180E06838(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::QuantizePattern::matchAndRewrite(MILToMLIR::QuantizePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  const MIL::IROperation *v4;
  uint64_t v5;
  __int128 v6;
  uint64_t LocationForOp;
  _BOOL4 v8;
  unint64_t v9;
  std::string *v10;
  _BOOL4 v11;
  _BOOL4 v12;
  __int128 v14;
  std::string::size_type v19;
  std::string::size_type size;
  uint64_t v21;
  mlir::OpBuilder *v24;
  mlir::StringAttr **v25;
  uint64_t *v26;
  mlir::GenericProgramPoint *v27;
  uint64_t **v28;
  void *InterfaceFor;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  MIL::IRValue *v37;
  uint64_t v38;
  uint64_t **v39;
  void *v40;
  const char *v41;
  int v42;
  const char *v43;
  const char *v44;
  int v45;
  uint64_t **v46;
  uint64_t *v47;
  const char *v48;
  int v49;
  const char *v50;
  const char *v51;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  uint64_t v62;
  void *v63;
  const MIL::IROperation *v64;
  mlir::OpBuilder *v65;
  int64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  _BYTE *v70;
  _DWORD *v71;
  int64_t v72;
  unint64_t v73;
  char *v74;
  int v75;
  _DWORD *v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _OWORD *v80;
  char *v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  void *v85;
  int64_t v86;
  uint64_t **v87;
  uint64_t v88;
  const char *v89;
  int v90;
  const char *v91;
  const char *v92;
  uint64_t *v93;
  mlir::GenericProgramPoint *v94;
  mlir::GenericProgramPoint *v95;
  mlir::GenericProgramPoint *v96;
  uint64_t *v97;
  mlir::GenericProgramPoint *v98;
  _BOOL4 isSignedInteger;
  _BOOL4 v100;
  uint64_t *v101;
  mlir::GenericProgramPoint *v102;
  uint64_t v103;
  uint64_t *Context;
  uint64_t v105;
  char v106;
  mlir::GenericProgramPoint *v107;
  uint64_t v108;
  float v109;
  float v110;
  mlir::GenericProgramPoint *v111;
  uint64_t *v112;
  uint64_t v113;
  char v114;
  mlir::GenericProgramPoint *v115;
  uint64_t v116;
  uint64_t *v117;
  mlir::GenericProgramPoint *v118;
  uint64_t *v119;
  mlir::GenericProgramPoint *v120;
  uint64_t *v121;
  uint64_t v122;
  char v123;
  mlir::GenericProgramPoint *v124;
  uint64_t v125;
  uint64_t *v126;
  mlir::GenericProgramPoint *v127;
  uint64_t *v128;
  uint64_t v129;
  char v130;
  mlir::GenericProgramPoint *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t *v135;
  uint64_t v136;
  char v137;
  mlir::GenericProgramPoint *v138;
  uint64_t v139;
  mlir::GenericProgramPoint *v140;
  uint64_t *v141;
  uint64_t v142;
  char v143;
  mlir::GenericProgramPoint *v144;
  uint64_t v145;
  uint64_t *v146;
  char *v147;
  uint64_t v148;
  uint64_t *v149;
  void **v150;
  void **v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t *v155;
  uint64_t v156;
  char v157;
  mlir::GenericProgramPoint *v158;
  uint64_t v159;
  uint64_t *v160;
  uint64_t v161;
  char v162;
  mlir::GenericProgramPoint *v163;
  MILToMLIRRewriter *v164;
  uint64_t v165;
  uint64_t *v166;
  mlir::GenericProgramPoint *v167;
  uint64_t *v168;
  uint64_t v169;
  char v170;
  mlir::GenericProgramPoint *v171;
  uint64_t v172;
  uint64_t *v173;
  mlir::GenericProgramPoint *v174;
  uint64_t v175;
  uint64_t *v176;
  uint64_t v177;
  char v178;
  mlir::GenericProgramPoint *v179;
  uint64_t *v180;
  mlir::GenericProgramPoint *v181;
  uint64_t v182;
  uint64_t *v183;
  char *v184;
  uint64_t v185;
  uint64_t *v186;
  void **v187;
  void **v188;
  void *v189;
  uint64_t *ArgAttrsAttr;
  uint64_t v191;
  uint64_t v192;
  MIL::IRValue *ParameterValue;
  int v194;
  uint64_t IntegerType;
  std::string *v196;
  std::string::size_type v197;
  uint64_t v198;
  uint64_t v200;
  uint64_t v201;
  uint64_t *v202;
  char *v203;
  uint64_t *v204;
  void **v205;
  void **v206;
  void *v207;
  char *v208;
  uint64_t v209;
  char *v210;
  uint64_t *v211;
  void **v212;
  char *v213;
  char *v214;
  uint64_t *v215;
  void **v216;
  void **v217;
  void *v218;
  char *v219;
  uint64_t v220;
  char *v221;
  uint64_t *v222;
  void **v223;
  const char *v225;
  int v226;
  const char *v227;
  const char *v228;
  const char *v229;
  int v230;
  const char *v231;
  const char *v232;
  const char *v233;
  int v234;
  const char *v235;
  const char *v236;
  const char *v237;
  int v238;
  const char *v239;
  const char *v240;
  const char *v241;
  int v242;
  const char *v243;
  const char *v244;
  const char *v245;
  int v246;
  const char *v247;
  const char *v248;
  const char *v249;
  int v250;
  const char *v251;
  const char *v252;
  const char *v253;
  int v254;
  const char *v255;
  const char *v256;
  const char *v257;
  int v258;
  const char *v259;
  const char *v260;
  const char *v261;
  int v262;
  const char *v263;
  const char *v264;
  char v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t ElementTypeOrSelf;
  uint64_t v269;
  MILToMLIRRewriter *v270;
  mlir::GenericProgramPoint *v271;
  mlir::GenericProgramPoint *v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t MLIRElemType;
  uint64_t Value;
  uint64_t ArgValue;
  std::string v280;
  uint64_t v281;
  uint64_t v282[4];
  __int16 v283;
  uint64_t v284[2];
  const char *v285;
  uint64_t v286;
  __int16 v287;
  void *__p[38];
  uint64_t *v289[8];

  v4 = a2;
  v289[5] = *(uint64_t **)MEMORY[0x1E0C80C00];
  v5 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
  if (*(char *)(v5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v280, *(const std::string::value_type **)v5, *(_QWORD *)(v5 + 8));
  }
  else
  {
    v6 = *(_OWORD *)v5;
    v280.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 16);
    *(_OWORD *)&v280.__r_.__value_.__l.__data_ = v6;
  }
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, v4);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, v4, "input");
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  v270 = (MILToMLIRRewriter *)a3;
  MLIRElemType = 0;
  Value = ElementTypeOrSelf;
  v8 = 0;
  if ((SHIBYTE(v280.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    HIDWORD(v9) = SHIBYTE(v280.__r_.__value_.__r.__words[2]);
    LODWORD(v9) = (SHIBYTE(v280.__r_.__value_.__r.__words[2]) << 24) - 234881024;
    v10 = &v280;
    v11 = 0;
    v12 = 0;
    switch((v9 >> 25))
    {
      case 0u:
        v11 = 0;
        v12 = 0;
        v8 = v280.__r_.__value_.__r.__words[0] == 0x75712E3731736F69
          && *(std::string::size_type *)((char *)v280.__r_.__value_.__r.__words + 6) == 0x657A69746E617571;
        if (v8)
          goto LABEL_50;
        goto LABEL_49;
      case 1u:
        v8 = 0;
        v12 = 0;
        v11 = v280.__r_.__value_.__r.__words[0] == 0x65642E3731736F69
           && v280.__r_.__value_.__l.__size_ == 0x657A69746E617571;
        goto LABEL_49;
      case 2u:
      case 3u:
        goto LABEL_49;
      case 4u:
        goto LABEL_40;
      case 5u:
        v8 = 0;
        v12 = 0;
        v11 = v280.__r_.__value_.__r.__words[0] == 0x79642E3731736F69
           && v280.__r_.__value_.__l.__size_ == 0x65645F63696D616ELL
           && v280.__r_.__value_.__r.__words[2] == 0x657A69746E617571;
        goto LABEL_49;
      default:
        goto LABEL_38;
    }
  }
  *((_QWORD *)&v14 + 1) = v280.__r_.__value_.__l.__size_;
  *(_QWORD *)&v14 = v280.__r_.__value_.__l.__size_ - 14;
  v11 = 0;
  v12 = 0;
  switch((unint64_t)(v14 >> 1))
  {
    case 0uLL:
      v11 = 0;
      v12 = 0;
      v8 = *(_QWORD *)v280.__r_.__value_.__l.__data_ == 0x75712E3731736F69
        && *(_QWORD *)(v280.__r_.__value_.__r.__words[0] + 6) == 0x657A69746E617571;
      if (v8)
        goto LABEL_50;
      goto LABEL_49;
    case 1uLL:
      if (*(_QWORD *)v280.__r_.__value_.__l.__data_ == 0x65642E3731736F69
        && *(_QWORD *)(v280.__r_.__value_.__r.__words[0] + 8) == 0x657A69746E617571)
      {
        v11 = 1;
        v8 = 0;
      }
      else
      {
        v8 = 0;
        v11 = 0;
      }
      v12 = 0;
      goto LABEL_49;
    case 2uLL:
    case 3uLL:
      goto LABEL_49;
    case 4uLL:
      v10 = (std::string *)v280.__r_.__value_.__r.__words[0];
LABEL_40:
      v8 = 0;
      v11 = 0;
      v19 = v10->__r_.__value_.__r.__words[0];
      size = v10->__r_.__value_.__l.__size_;
      v21 = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 6);
      v12 = v19 == 0x79642E3731736F69 && size == 0x75715F63696D616ELL && v21 == 0x657A69746E617571;
      goto LABEL_49;
    case 5uLL:
      v11 = *(_QWORD *)v280.__r_.__value_.__l.__data_ == 0x79642E3731736F69
         && *(_QWORD *)(v280.__r_.__value_.__r.__words[0] + 8) == 0x65645F63696D616ELL
         && *(_QWORD *)(v280.__r_.__value_.__r.__words[0] + 16) == 0x657A69746E617571;
      v8 = 0;
      v12 = 0;
      goto LABEL_49;
    default:
LABEL_38:
      v11 = 0;
      v12 = 0;
LABEL_49:
      if (!v12)
        goto LABEL_53;
LABEL_50:
      HIBYTE(__p[2]) = 12;
      strcpy((char *)__p, "output_dtype");
      MIL::IROperation::TryGetParameterValue();
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
      MIL::IRValue::GetScalar<std::string>();
      MLIRElemType = MILToMLIRRewriter::getMLIRElemType((uint64_t)a3, (uint64_t)__p);
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&MLIRElemType);
      if (SHIBYTE(__p[2]) < 0)
      {
        operator delete(__p[0]);
        v24 = (mlir::OpBuilder *)(a3 + 13);
        if (v8 || v11)
        {
LABEL_54:
          v25 = a3;
          v284[0] = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, v4, "scale");
          v282[0] = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, v4, "zero_point");
          if (!v282[0])
          {
            __p[0] = (void *)1;
            v26 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, Value, 0);
            __p[0] = (void *)mlir::mps::getConstantAttr<int>(v26, 0);
            v27 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
            if (!*((_DWORD *)v27 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v282[0] = (uint64_t)v27 - 16;
          }
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(*(_QWORD *)(v284[0] + 8) & 0xFFFFFFFFFFFFFFF8)))
            goto LABEL_233;
          v28 = (uint64_t **)(*(_QWORD *)(v284[0] + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v28))
          {
            v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
            v31 = 566;
            v32 = "Casting.h";
            v33 = "cast";
LABEL_287:
            __assert_rtn(v33, v32, v31, v30);
          }
          if (v28)
          {
            InterfaceFor = (void *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v28);
            if (!InterfaceFor)
            {
              v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              v31 = 98;
              v32 = "InterfaceSupport.h";
              v33 = "Interface";
              goto LABEL_287;
            }
          }
          else
          {
            InterfaceFor = 0;
          }
          __p[0] = v28;
          __p[1] = InterfaceFor;
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)__p))
            goto LABEL_233;
          v39 = (uint64_t **)(*(_QWORD *)(v284[0] + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v39))
          {
            v41 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
            v42 = 566;
            v43 = "Casting.h";
            v44 = "cast";
LABEL_299:
            __assert_rtn(v44, v43, v42, v41);
          }
          if (v39)
          {
            v40 = (void *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v39);
            if (!v40)
            {
              v41 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              v42 = 98;
              v43 = "InterfaceSupport.h";
              v44 = "Interface";
              goto LABEL_299;
            }
          }
          else
          {
            v40 = 0;
          }
          __p[0] = v39;
          __p[1] = v40;
          ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)__p);
          if (v191)
          {
            v192 = *ArgAttrsAttr;
            v281 = 0;
            if (v192 <= 1)
            {
              v194 = 0;
            }
            else
            {
              HIBYTE(__p[2]) = 4;
              strcpy((char *)__p, "axis");
              ParameterValue = (MIL::IRValue *)MIL::IROperation::GetParameterValue();
              if (SHIBYTE(__p[2]) < 0)
                operator delete(__p[0]);
              MIL::IRValue::AsTensor(ParameterValue);
              v194 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
            }
          }
          else
          {
LABEL_233:
            v194 = 0;
            v281 = 0;
          }
          IntegerType = mlir::Builder::getIntegerType(v24, 0x20u, 1);
          v281 = mlir::IntegerAttr::get(IntegerType, v194);
          if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0)
          {
            if (v280.__r_.__value_.__l.__size_ != 14)
              goto LABEL_243;
            v196 = (std::string *)v280.__r_.__value_.__r.__words[0];
          }
          else
          {
            if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) != 14)
              goto LABEL_243;
            v196 = &v280;
          }
          v197 = v196->__r_.__value_.__r.__words[0];
          v198 = *(std::string::size_type *)((char *)v196->__r_.__value_.__r.__words + 6);
          if (v197 == 0x75712E3731736F69 && v198 == 0x657A69746E617571)
          {
            v201 = mlir::OpBuilder::create<mlir::mps::QuantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>((mlir::UnknownLoc **)v24, LocationForOp, &ArgValue, v284, v282, &MLIRElemType, &v281);
            if (!*(_DWORD *)(v201 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            goto LABEL_244;
          }
LABEL_243:
          v200 = mlir::getElementTypeOrSelf(v284[0]);
          MLIRElemType = mlir::TypeAttr::get(v200);
          v201 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>((mlir::Float32Type **)v24, LocationForOp, &ArgValue, v284, v282, &MLIRElemType, &v281);
          if (!*(_DWORD *)(v201 + 36))
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_244:
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(__p, v4);
          v202 = (uint64_t *)__p[0];
          v203 = (char *)operator new(8uLL);
          *(_QWORD *)v203 = v201 - 16;
          v289[0] = v202;
          v204 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v25 + 8), (uint64_t)v202, (uint64_t)&std::piecewise_construct, (__int128 **)v289);
          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v204 + 5, v203, v203 + 8, 1uLL);
          operator delete(v203);
          v205 = (void **)__p[0];
          if (!__p[0])
          {
LABEL_280:
            v38 = 1;
            goto LABEL_281;
          }
          v206 = (void **)__p[1];
          v207 = __p[0];
          if (__p[1] == __p[0])
          {
LABEL_279:
            __p[1] = v205;
            operator delete(v207);
            goto LABEL_280;
          }
          do
          {
            if (*((char *)v206 - 1) < 0)
              operator delete(*(v206 - 3));
            v206 -= 3;
          }
          while (v206 != v205);
LABEL_278:
          v207 = __p[0];
          goto LABEL_279;
        }
      }
      else
      {
LABEL_53:
        v24 = (mlir::OpBuilder *)(a3 + 13);
        if (v8 || v11)
          goto LABEL_54;
      }
      if (v12)
      {
        HIBYTE(__p[2]) = 14;
        strcpy((char *)__p, "has_zero_point");
        MIL::IROperation::TryGetParameterValue();
        v34 = MIL::IRValue::GetScalar<BOOL>();
        v35 = ElementTypeOrSelf;
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
        HIBYTE(__p[2]) = 4;
        strcpy((char *)__p, "axis");
        v36 = MIL::IROperation::TryGetParameterValue();
        v37 = (MIL::IRValue *)v36;
        if (SHIBYTE(__p[2]) < 0)
        {
          operator delete(__p[0]);
          v275 = 0;
          v276 = 0;
          if (!v37)
            goto LABEL_141;
        }
        else
        {
          v275 = 0;
          v276 = 0;
          if (!v36)
            goto LABEL_141;
        }
        memset(__p, 0, 24);
        MIL::IRValue::AsTensor(v37);
        v45 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
        v46 = (uint64_t **)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v46))
        {
          v48 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          v49 = 566;
          v50 = "Casting.h";
          v51 = "cast";
LABEL_297:
          __assert_rtn(v51, v50, v49, v48);
        }
        if (v46)
        {
          v47 = (uint64_t *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v46);
          if (!v47)
          {
            v48 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v49 = 98;
            v50 = "InterfaceSupport.h";
            v51 = "Interface";
            goto LABEL_297;
          }
        }
        else
        {
          v47 = 0;
        }
        v289[0] = (uint64_t *)v46;
        v289[1] = v47;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v289);
        v56 = v55;
        v265 = v34;
        v266 = LocationForOp;
        v57 = v55 & (v45 >> 31);
        v58 = (v57 + v45);
        if (v55)
        {
          v59 = 0;
          v60 = 0;
          v61 = 0;
          v62 = 0;
          v267 = (v57 + v45);
          while (1)
          {
            if (v62 == v58)
              goto LABEL_103;
            if (v61 >= v60)
              break;
            *(_DWORD *)v61 = v62;
            v63 = v61 + 4;
LABEL_102:
            __p[1] = v63;
            v61 = (char *)v63;
LABEL_103:
            if (++v62 == v56)
              goto LABEL_132;
          }
          v64 = v4;
          v65 = v24;
          v66 = v61 - v59;
          v67 = (v61 - v59) >> 2;
          v68 = v67 + 1;
          if ((unint64_t)(v67 + 1) >> 62)
            std::vector<int>::__throw_length_error[abi:ne180100]();
          if ((v60 - v59) >> 1 > v68)
            v68 = (v60 - v59) >> 1;
          if ((unint64_t)(v60 - v59) >= 0x7FFFFFFFFFFFFFFCLL)
            v69 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v69 = v68;
          if (v69)
          {
            if (v69 >> 62)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v70 = operator new(4 * v69);
            v71 = &v70[4 * v67];
            *v71 = v62;
            v63 = v71 + 1;
            v72 = v61 - v59;
            if (v61 != v59)
            {
LABEL_115:
              v73 = v72 - 4;
              if (v73 < 0xBC
                || (v77 = (v61 - 4 - v59) & 0xFFFFFFFFFFFFFFFCLL, &v70[v66 - 4 - v77] > &v70[v66 - 4])
                || &v61[-v77 - 4] > v61 - 4
                || (unint64_t)(v59 - v70) < 0x20)
              {
                v74 = v61;
                v24 = v65;
              }
              else
              {
                v78 = (v73 >> 2) + 1;
                v79 = 4 * (v78 & 0x7FFFFFFFFFFFFFF8);
                v74 = &v61[-v79];
                v71 = (_DWORD *)((char *)v71 - v79);
                v80 = &v70[v66 - 16];
                v81 = v61 - 16;
                v82 = v78 & 0x7FFFFFFFFFFFFFF8;
                do
                {
                  v83 = *(_OWORD *)v81;
                  *(v80 - 1) = *((_OWORD *)v81 - 1);
                  *v80 = v83;
                  v80 -= 2;
                  v81 -= 32;
                  v82 -= 8;
                }
                while (v82);
                v24 = v65;
                if (v78 == (v78 & 0x7FFFFFFFFFFFFFF8))
                {
LABEL_118:
                  v60 = &v70[4 * v69];
                  __p[0] = v71;
                  __p[1] = v63;
                  __p[2] = v60;
                  v4 = v64;
                  if (!v59)
                  {
LABEL_120:
                    v59 = (char *)v71;
                    v58 = v267;
                    goto LABEL_102;
                  }
LABEL_119:
                  operator delete(v59);
                  goto LABEL_120;
                }
              }
              do
              {
                v75 = *((_DWORD *)v74 - 1);
                v74 -= 4;
                *--v71 = v75;
              }
              while (v74 != v59);
              goto LABEL_118;
            }
          }
          else
          {
            v70 = 0;
            v71 = (_DWORD *)(4 * v67);
            v76 = (_DWORD *)(4 * v67);
            *v76 = v62;
            v63 = v76 + 1;
            v72 = v61 - v59;
            if (v61 != v59)
              goto LABEL_115;
          }
          v24 = v65;
          v60 = &v70[4 * v69];
          __p[0] = v71;
          __p[1] = v63;
          __p[2] = v60;
          v4 = v64;
          if (!v59)
            goto LABEL_120;
          goto LABEL_119;
        }
        v61 = 0;
LABEL_132:
        v84 = mlir::Builder::getIntegerType(v24, 0x20u, 1);
        LocationForOp = v266;
        v35 = ElementTypeOrSelf;
        v275 = mlir::IntegerAttr::get(v84, (int)v58);
        v85 = __p[0];
        v86 = v61 - (char *)__p[0];
        v289[0] = (uint64_t *)((v61 - (char *)__p[0]) >> 2);
        v87 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v289, 1, v84, 0);
        v34 = v265;
        if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v87))
        {
          if (v87)
          {
            v88 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v87);
            if (!v88)
            {
              v89 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              v90 = 98;
              v91 = "InterfaceSupport.h";
              v92 = "Interface";
              goto LABEL_289;
            }
          }
          else
          {
            v88 = 0;
          }
          v93 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v87, v88, v85, v86, 4, 1, 1);
          if ((mlir::DenseIntElementsAttr::classof((uint64_t)v93) & 1) != 0)
          {
            v289[0] = v93;
            v94 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, v266, v289);
            if (!*((_DWORD *)v94 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v276 = (uint64_t)v94 - 16;
            if (v85)
              operator delete(v85);
LABEL_141:
            LOBYTE(__p[0]) = 0;
            LOBYTE(v289[0]) = 0;
            v95 = mlir::OpBuilder::create<mlir::mps::ReductionMinOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::UnitAttr **)v24, LocationForOp, &ArgValue, &v276, (unsigned __int8 *)__p, (unsigned __int8 *)v289);
            if (!*((_DWORD *)v95 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v274 = (uint64_t)v95 - 16;
            LOBYTE(__p[0]) = 0;
            LOBYTE(v289[0]) = 0;
            v96 = mlir::OpBuilder::create<mlir::mps::ReductionMaxOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::UnitAttr **)v24, LocationForOp, &ArgValue, &v276, (unsigned __int8 *)__p, (unsigned __int8 *)v289);
            if (!*((_DWORD *)v96 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v273 = (uint64_t)v96 - 16;
            __p[0] = (void *)1;
            v97 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
            __p[0] = (void *)mlir::mps::getConstantAttr<double>(v97, 0.00392156863);
            v98 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
            __p[0] = (void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&MLIRElemType);
            isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)__p);
            v100 = isSignedInteger;
            if ((v34 & 1) != 0)
            {
              __p[0] = (void *)1;
              v101 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
              __p[0] = (void *)mlir::mps::getConstantAttr<double>(v101, 0.0);
              v102 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
              v272 = v102;
              v103 = mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::Float32Type **)v24, LocationForOp, &v273, (uint64_t)&v272);
              if (!*(_DWORD *)(v103 + 36))
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              v273 = v103 - 16;
              v281 = LocationForOp;
              Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
              v105 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, Context);
              if (!v106)
              {
                v287 = 1283;
                v285 = "mps.minimum";
                v286 = 11;
                                   "tion hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started"
                                   "/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                v283 = 259;
                llvm::operator+(v284, v282, (uint64_t)v289);
                llvm::report_fatal_error((llvm::Twine *)v289, 1);
              }
              mlir::OperationState::OperationState(__p, LocationForOp, v105);
              if (!*((_DWORD *)v102 + 9))
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, v274, (uint64_t)v102 - 16);
              v107 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
              if (v107)
              {
                v108 = llvm::DefaultDoCastIfPossible<mlir::mps::MinimumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MinimumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v107);
                if (v108)
                {
                  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                  if (!*(_DWORD *)(v108 + 36))
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  v274 = v108 - 16;
                  if (v100)
                    v109 = 127.0;
                  else
                    v109 = 255.0;
                  if (v100)
                    v110 = -128.0;
                  else
                    v110 = 0.0;
                  v111 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)v24, LocationForOp, &v273, &v274);
                  v281 = LocationForOp;
                  v112 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                  v113 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v112);
                  if (!v114)
                  {
                    v287 = 1283;
                    v285 = "mps.multiply";
                    v286 = 12;
                                       "peration hasn't been added by the dialect. See also https://mlir.llvm.org/getting"
                                       "_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                    v283 = 259;
                    llvm::operator+(v284, v282, (uint64_t)v289);
                    llvm::report_fatal_error((llvm::Twine *)v289, 1);
                  }
                  mlir::OperationState::OperationState(__p, LocationForOp, v113);
                  if (!*((_DWORD *)v98 + 9) || !*((_DWORD *)v111 + 9))
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, (uint64_t)v98 - 16, (uint64_t)v111 - 16);
                  v115 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                  if (v115)
                  {
                    v116 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v115);
                    if (v116)
                    {
                      mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                      __p[0] = (void *)1;
                      v117 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
                      __p[0] = (void *)mlir::mps::getConstantAttr<float>(v117, v110);
                      v118 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                      __p[0] = (void *)1;
                      v119 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
                      __p[0] = (void *)mlir::mps::getConstantAttr<float>(v119, v109);
                      v120 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                      v281 = LocationForOp;
                      v121 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                      v122 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, v121);
                      if (!v123)
                      {
                        v287 = 1283;
                        v285 = "mps.divide";
                        v286 = 10;
                                           "is operation hasn't been added by the dialect. See also https://mlir.llvm.org"
                                           "/getting_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                        v283 = 259;
                        llvm::operator+(v284, v282, (uint64_t)v289);
                        llvm::report_fatal_error((llvm::Twine *)v289, 1);
                      }
                      mlir::OperationState::OperationState(__p, LocationForOp, v122);
                      if (!*(_DWORD *)(v116 + 36))
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      v269 = v116 - 16;
                      mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, v274, v116 - 16);
                      v124 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                      if (v124)
                      {
                        v125 = llvm::DefaultDoCastIfPossible<mlir::mps::DivideOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DivideOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v124);
                        if (v125)
                        {
                          mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                          if (!*(_DWORD *)(v125 + 36))
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          v271 = (mlir::GenericProgramPoint *)(v125 - 16);
                          if (v100)
                          {
                            __p[0] = (void *)1;
                            v126 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
                            __p[0] = (void *)mlir::mps::getConstantAttr<double>(v126, 128.0);
                            v127 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                            v281 = LocationForOp;
                            v128 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                            v129 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, v128);
                            if (!v130)
                            {
                              v287 = 1283;
                              v285 = "mps.add";
                              v286 = 7;
                                                 " or this operation hasn't been added by the dialect. See also https://m"
                                                 "lir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-"
                                                 "with-dialects-management";
                              v283 = 259;
                              llvm::operator+(v284, v282, (uint64_t)v289);
                              llvm::report_fatal_error((llvm::Twine *)v289, 1);
                            }
                            mlir::OperationState::OperationState(__p, LocationForOp, v129);
                            if (!*((_DWORD *)v127 + 9))
                              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                            mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, (uint64_t)v271, (uint64_t)v127 - 16);
                            v131 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                            if (v131)
                            {
                              v132 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v131);
                              if (v132)
                              {
                                mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                                if (!*(_DWORD *)(v132 + 36))
                                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                                v271 = (mlir::GenericProgramPoint *)(v132 - 16);
                                goto LABEL_173;
                              }
                              v261 = "result && \"builder didn't return the right type\"";
                              v262 = 497;
                              v263 = "Builders.h";
                              v264 = "create";
                            }
                            else
                            {
                              v261 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                              v262 = 662;
                              v263 = "Casting.h";
                              v264 = "dyn_cast";
                            }
                            __assert_rtn(v264, v263, v262, v261);
                          }
LABEL_173:
                          v133 = mlir::OpBuilder::create<mlir::mps::RoundOp,mlir::Value &>(v24, LocationForOp, (uint64_t *)&v271);
                          if (!*(_DWORD *)(v133 + 36))
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          v271 = (mlir::GenericProgramPoint *)(v133 - 16);
                          v134 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>(v24, LocationForOp, (uint64_t *)&v271);
                          if (!*(_DWORD *)(v134 + 36))
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          v271 = (mlir::GenericProgramPoint *)(v134 - 16);
                          v281 = LocationForOp;
                          v135 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                          v136 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.clamp", (const unsigned __int8 *)9, v135);
                          if (!v137)
                          {
                            v287 = 1283;
                            v285 = "mps.clamp";
                            v286 = 9;
                                               "r this operation hasn't been added by the dialect. See also https://mlir."
                                               "llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-d"
                                               "ialects-management";
                            v283 = 259;
                            llvm::operator+(v284, v282, (uint64_t)v289);
                            llvm::report_fatal_error((llvm::Twine *)v289, 1);
                          }
                          mlir::OperationState::OperationState(__p, LocationForOp, v136);
                          if (!*((_DWORD *)v118 + 9) || !*((_DWORD *)v120 + 9))
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          mlir::mps::ClampOp::build((uint64_t)v24, (uint64_t)__p, (uint64_t)v271, (uint64_t)v118 - 16, (uint64_t)v120 - 16);
                          v138 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                          if (v138)
                          {
                            v139 = llvm::DefaultDoCastIfPossible<mlir::mps::ClampOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ClampOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v138);
                            if (v139)
                            {
                              mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                              if (!*(_DWORD *)(v139 + 36))
                                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                              v271 = (mlir::GenericProgramPoint *)(v139 - 16);
                              v140 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)v24, LocationForOp, (uint64_t *)&v271, &Value);
                              if (!*((_DWORD *)v140 + 9))
                                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                              v271 = (mlir::GenericProgramPoint *)((char *)v140 - 16);
                              v281 = LocationForOp;
                              v141 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                              v142 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.quantize", (const unsigned __int8 *)0xC, v141);
                              if (!v143)
                              {
                                v287 = 1283;
                                v285 = "mps.quantize";
                                v286 = 12;
                                                   "ed or this operation hasn't been added by the dialect. See also https"
                                                   "://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-wha"
                                                   "ts-up-with-dialects-management";
                                v283 = 259;
                                llvm::operator+(v284, v282, (uint64_t)v289);
                                llvm::report_fatal_error((llvm::Twine *)v289, 1);
                              }
                              mlir::OperationState::OperationState(__p, LocationForOp, v142);
                              if (!*(_DWORD *)(v116 + 36))
                                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                              mlir::mps::QuantizeOp::build((mlir::UnknownLoc **)v24, (uint64_t)__p, ArgValue, v269, (uint64_t)v271, MLIRElemType, v275);
                              v144 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                              if (v144)
                              {
                                v145 = llvm::DefaultDoCastIfPossible<mlir::mps::QuantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::QuantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v144);
                                if (v145)
                                {
                                  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                                  if (!*(_DWORD *)(v145 + 36))
                                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                                  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(__p, v4);
                                  v146 = (uint64_t *)__p[0];
                                  v147 = (char *)operator new(8uLL);
                                  *(_QWORD *)v147 = v145 - 16;
                                  v148 = (uint64_t)v270 + 64;
                                  v289[0] = v146;
                                  v149 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v270 + 64, (uint64_t)v146, (uint64_t)&std::piecewise_construct, (__int128 **)v289);
                                  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v149 + 5, v147, v147 + 8, 1uLL);
                                  operator delete(v147);
                                  v150 = (void **)__p[0];
                                  if (__p[0])
                                  {
                                    v151 = (void **)__p[1];
                                    v152 = __p[0];
                                    if (__p[1] != __p[0])
                                    {
                                      do
                                      {
                                        if (*((char *)v151 - 1) < 0)
                                          operator delete(*(v151 - 3));
                                        v151 -= 3;
                                      }
                                      while (v151 != v150);
                                      v152 = __p[0];
                                    }
                                    __p[1] = v150;
                                    operator delete(v152);
                                  }
                                  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(__p, v4);
                                  if (!*(_DWORD *)(v116 + 36))
                                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                                  v213 = (char *)__p[0];
                                  v214 = (char *)operator new(8uLL);
                                  *(_QWORD *)v214 = v269;
                                  v289[0] = (uint64_t *)(v213 + 24);
                                  v215 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v148, (uint64_t)(v213 + 24), (uint64_t)&std::piecewise_construct, (__int128 **)v289);
                                  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v215 + 5, v214, v214 + 8, 1uLL);
                                  operator delete(v214);
                                  v216 = (void **)__p[0];
                                  if (__p[0])
                                  {
                                    v217 = (void **)__p[1];
                                    v218 = __p[0];
                                    if (__p[1] != __p[0])
                                    {
                                      do
                                      {
                                        if (*((char *)v217 - 1) < 0)
                                          operator delete(*(v217 - 3));
                                        v217 -= 3;
                                      }
                                      while (v217 != v216);
                                      v218 = __p[0];
                                    }
                                    __p[1] = v216;
                                    operator delete(v218);
                                  }
                                  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(__p, v4);
                                  v219 = (char *)__p[0];
                                  v220 = (uint64_t)v271;
                                  v221 = (char *)operator new(8uLL);
                                  *(_QWORD *)v221 = v220;
                                  v289[0] = (uint64_t *)(v219 + 48);
                                  v222 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v148, (uint64_t)(v219 + 48), (uint64_t)&std::piecewise_construct, (__int128 **)v289);
                                  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v222 + 5, v221, v221 + 8, 1uLL);
                                  operator delete(v221);
                                  v205 = (void **)__p[0];
                                  if (!__p[0])
                                    goto LABEL_280;
                                  v223 = (void **)__p[1];
                                  v207 = __p[0];
                                  if (__p[1] == __p[0])
                                    goto LABEL_279;
                                  do
                                  {
                                    if (*((char *)v223 - 1) < 0)
                                      operator delete(*(v223 - 3));
                                    v223 -= 3;
                                  }
                                  while (v223 != v205);
                                  goto LABEL_278;
                                }
                                v241 = "result && \"builder didn't return the right type\"";
                                v242 = 497;
                                v243 = "Builders.h";
                                v244 = "create";
                              }
                              else
                              {
                                v241 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                                v242 = 662;
                                v243 = "Casting.h";
                                v244 = "dyn_cast";
                              }
                              __assert_rtn(v244, v243, v242, v241);
                            }
                            v237 = "result && \"builder didn't return the right type\"";
                            v238 = 497;
                            v239 = "Builders.h";
                            v240 = "create";
                          }
                          else
                          {
                            v237 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                            v238 = 662;
                            v239 = "Casting.h";
                            v240 = "dyn_cast";
                          }
                          __assert_rtn(v240, v239, v238, v237);
                        }
                        v233 = "result && \"builder didn't return the right type\"";
                        v234 = 497;
                        v235 = "Builders.h";
                        v236 = "create";
                      }
                      else
                      {
                        v233 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                        v234 = 662;
                        v235 = "Casting.h";
                        v236 = "dyn_cast";
                      }
                      __assert_rtn(v236, v235, v234, v233);
                    }
                    v229 = "result && \"builder didn't return the right type\"";
                    v230 = 497;
                    v231 = "Builders.h";
                    v232 = "create";
                  }
                  else
                  {
                    v229 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                    v230 = 662;
                    v231 = "Casting.h";
                    v232 = "dyn_cast";
                  }
                  __assert_rtn(v232, v231, v230, v229);
                }
                v225 = "result && \"builder didn't return the right type\"";
                v226 = 497;
                v227 = "Builders.h";
                v228 = "create";
              }
              else
              {
                v225 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                v226 = 662;
                v227 = "Casting.h";
                v228 = "dyn_cast";
              }
              __assert_rtn(v228, v227, v226, v225);
            }
            v272 = 0;
            if (isSignedInteger)
            {
              v153 = mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>(v24, LocationForOp, &v274);
              v154 = mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>(v24, LocationForOp, &v273);
              v281 = LocationForOp;
              v155 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
              v156 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater", (const unsigned __int8 *)0xB, v155);
              if (!v157)
              {
                v287 = 1283;
                v285 = "mps.greater";
                v286 = 11;
                                   "tion hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started"
                                   "/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                v283 = 259;
                llvm::operator+(v284, v282, (uint64_t)v289);
                llvm::report_fatal_error((llvm::Twine *)v289, 1);
              }
              mlir::OperationState::OperationState(__p, LocationForOp, v156);
              if (!*(_DWORD *)(v154 + 36) || !*(_DWORD *)(v153 + 36))
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              mlir::mps::EqualToOp::build((uint64_t)v24, (uint64_t)__p, v154 - 16, v153 - 16);
              v158 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
              if (v158)
              {
                v159 = llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v158);
                if (v159)
                {
                  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                  v281 = LocationForOp;
                  v160 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                  v161 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v160);
                  if (!v162)
                  {
                    v287 = 1283;
                    v285 = "mps.select";
                    v286 = 10;
                                       "peration hasn't been added by the dialect. See also https://mlir.llvm.org/getting"
                                       "_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                    v283 = 259;
                    llvm::operator+(v284, v282, (uint64_t)v289);
                    llvm::report_fatal_error((llvm::Twine *)v289, 1);
                  }
                  mlir::OperationState::OperationState(__p, LocationForOp, v161);
                  if (!*(_DWORD *)(v159 + 36) || !*(_DWORD *)(v154 + 36) || !*(_DWORD *)(v153 + 36))
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  mlir::mps::SelectOp::build((uint64_t)v24, (uint64_t)__p, v159 - 16, v154 - 16, v153 - 16);
                  v163 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                  v164 = v270;
                  if (v163)
                  {
                    v165 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v163);
                    if (v165)
                    {
                      mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                      __p[0] = (void *)1;
                      v166 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
                      __p[0] = (void *)mlir::mps::getConstantAttr<double>(v166, 0.00787401575);
                      v167 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                      v281 = LocationForOp;
                      v168 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
                      v169 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v168);
                      if (!v170)
                      {
                        v287 = 1283;
                        v285 = "mps.multiply";
                        v286 = 12;
                                           "is operation hasn't been added by the dialect. See also https://mlir.llvm.org"
                                           "/getting_started/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                        v283 = 259;
                        llvm::operator+(v284, v282, (uint64_t)v289);
                        llvm::report_fatal_error((llvm::Twine *)v289, 1);
                      }
                      mlir::OperationState::OperationState(__p, LocationForOp, v169);
                      if (!*((_DWORD *)v167 + 9) || !*(_DWORD *)(v165 + 36))
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, (uint64_t)v167 - 16, v165 - 16);
                      v171 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
                      if (v171)
                      {
                        v172 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v171);
                        if (v172)
                        {
                          mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                          if (!*(_DWORD *)(v172 + 36))
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_219:
                          v272 = (mlir::GenericProgramPoint *)(v172 - 16);
                          __p[0] = (void *)1;
                          v180 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, Value, 0);
                          __p[0] = (void *)mlir::mps::getConstantAttr<int>(v180, 0);
                          v181 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
                          if (!*((_DWORD *)v181 + 9))
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          v284[0] = (uint64_t)v181 - 16;
                          v182 = mlir::OpBuilder::create<mlir::mps::QuantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>((mlir::UnknownLoc **)v24, LocationForOp, &ArgValue, (uint64_t *)&v272, v284, &MLIRElemType, &v275);
                          if (!*(_DWORD *)(v182 + 36))
                            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(__p, v4);
                          v183 = (uint64_t *)__p[0];
                          v184 = (char *)operator new(8uLL);
                          *(_QWORD *)v184 = v182 - 16;
                          v185 = (uint64_t)v164 + 64;
                          v289[0] = v183;
                          v186 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v185, (uint64_t)v183, (uint64_t)&std::piecewise_construct, (__int128 **)v289);
                          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v186 + 5, v184, v184 + 8, 1uLL);
                          operator delete(v184);
                          v187 = (void **)__p[0];
                          if (__p[0])
                          {
                            v188 = (void **)__p[1];
                            v189 = __p[0];
                            if (__p[1] != __p[0])
                            {
                              do
                              {
                                if (*((char *)v188 - 1) < 0)
                                  operator delete(*(v188 - 3));
                                v188 -= 3;
                              }
                              while (v188 != v187);
                              v189 = __p[0];
                            }
                            __p[1] = v187;
                            operator delete(v189);
                          }
                          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(__p, v4);
                          v208 = (char *)__p[0];
                          v209 = (uint64_t)v272;
                          v210 = (char *)operator new(8uLL);
                          *(_QWORD *)v210 = v209;
                          v289[0] = (uint64_t *)(v208 + 24);
                          v211 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v185, (uint64_t)(v208 + 24), (uint64_t)&std::piecewise_construct, (__int128 **)v289);
                          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v211 + 5, v210, v210 + 8, 1uLL);
                          operator delete(v210);
                          v205 = (void **)__p[0];
                          if (!__p[0])
                            goto LABEL_280;
                          v212 = (void **)__p[1];
                          v207 = __p[0];
                          if (__p[1] == __p[0])
                            goto LABEL_279;
                          do
                          {
                            if (*((char *)v212 - 1) < 0)
                              operator delete(*(v212 - 3));
                            v212 -= 3;
                          }
                          while (v212 != v205);
                          goto LABEL_278;
                        }
                        v257 = "result && \"builder didn't return the right type\"";
                        v258 = 497;
                        v259 = "Builders.h";
                        v260 = "create";
                      }
                      else
                      {
                        v257 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                        v258 = 662;
                        v259 = "Casting.h";
                        v260 = "dyn_cast";
                      }
                      __assert_rtn(v260, v259, v258, v257);
                    }
                    v253 = "result && \"builder didn't return the right type\"";
                    v254 = 497;
                    v255 = "Builders.h";
                    v256 = "create";
                  }
                  else
                  {
                    v253 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                    v254 = 662;
                    v255 = "Casting.h";
                    v256 = "dyn_cast";
                  }
                  __assert_rtn(v256, v255, v254, v253);
                }
                v245 = "result && \"builder didn't return the right type\"";
                v246 = 497;
                v247 = "Builders.h";
                v248 = "create";
              }
              else
              {
                v245 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                v246 = 662;
                v247 = "Casting.h";
                v248 = "dyn_cast";
              }
              __assert_rtn(v248, v247, v246, v245);
            }
            __p[0] = (void *)1;
            v173 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v35, 0);
            __p[0] = (void *)mlir::mps::getConstantAttr<double>(v173, 0.0);
            v174 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v24, LocationForOp, (uint64_t **)__p);
            v271 = v174;
            v164 = v270;
            if (!*((_DWORD *)v174 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v274 = (uint64_t)v174 - 16;
            v175 = mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::Float32Type **)v24, LocationForOp, &v273, (uint64_t)&v271);
            if (!*(_DWORD *)(v175 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v273 = v175 - 16;
            v281 = LocationForOp;
            v176 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v281);
            v177 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v176);
            if (!v178)
            {
              v287 = 1283;
              v285 = "mps.multiply";
              v286 = 12;
                                 "on hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq"
                                 "/#registered-loaded-dependent-whats-up-with-dialects-management";
              v283 = 259;
              llvm::operator+(v284, v282, (uint64_t)v289);
              llvm::report_fatal_error((llvm::Twine *)v289, 1);
            }
            mlir::OperationState::OperationState(__p, LocationForOp, v177);
            if (!*((_DWORD *)v98 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            mlir::mps::ATan2Op::build((mlir::Float32Type **)v24, (uint64_t)__p, (uint64_t)v98 - 16, v273);
            v179 = mlir::OpBuilder::create(v24, (const mlir::OperationState *)__p);
            if (v179)
            {
              v172 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v179);
              if (v172)
              {
                mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                if (!*(_DWORD *)(v172 + 36))
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                goto LABEL_219;
              }
              v249 = "result && \"builder didn't return the right type\"";
              v250 = 497;
              v251 = "Builders.h";
              v252 = "create";
            }
            else
            {
              v249 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              v250 = 662;
              v251 = "Casting.h";
              v252 = "dyn_cast";
            }
            __assert_rtn(v252, v251, v250, v249);
          }
        }
        v89 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v90 = 566;
        v91 = "Casting.h";
        v92 = "cast";
LABEL_289:
        __assert_rtn(v92, v91, v90, v89);
      }
      __p[0] = operator new(0x20uLL);
      *(_OWORD *)&__p[1] = xmmword_181268710;
      strcpy((char *)__p[0], "Unknown quantization variant.");
      v38 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)__p);
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
LABEL_281:
      if (SHIBYTE(v280.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v280.__r_.__value_.__l.__data_);
      return v38;
  }
}

void sub_180E08BA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a45 < 0)
    operator delete(__p);
  if (a28 < 0)
    operator delete(a23);
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::QuantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v18;
  const char *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _BYTE v29[40];
  _QWORD v30[39];

  v30[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.quantize", (const unsigned __int8 *)0xC, Context);
  if (!v16)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mps.quantize";
    v27[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v15);
  mlir::mps::QuantizeOp::build(a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (!v17)
  {
    v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v21 = 662;
    v22 = "Casting.h";
    v23 = "dyn_cast";
    goto LABEL_8;
  }
  v18 = llvm::DefaultDoCastIfPossible<mlir::mps::QuantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::QuantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    v20 = "result && \"builder didn't return the right type\"";
    v21 = 497;
    v22 = "Builders.h";
    v23 = "create";
LABEL_8:
    __assert_rtn(v23, v22, v21, v20);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v18;
}

void sub_180E08F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E08F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr &,mlir::IntegerAttr &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v18;
  const char *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _BYTE v29[40];
  uint64_t v30[39];

  v30[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
  if (!v16)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mps.dequantize";
    v27[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v15);
  mlir::mps::DequantizeOp::build(a1, v30, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (!v17)
  {
    v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v21 = 662;
    v22 = "Casting.h";
    v23 = "dyn_cast";
    goto LABEL_8;
  }
  v18 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    v20 = "result && \"builder didn't return the right type\"";
    v21 = 497;
    v22 = "Builders.h";
    v23 = "create";
LABEL_8:
    __assert_rtn(v23, v22, v21, v20);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v18;
}

void sub_180E09120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E09138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.absolute", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.absolute";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::AbsoluteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AbsoluteOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E092BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E092D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.maximum", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.maximum";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MaximumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MaximumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E09490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E094A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::RoundOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.round", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.round";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::RoundOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RoundOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E0962C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E09644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::TensorBufferPattern::matchAndRewrite(MILToMLIR::TensorBufferPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  const MIL::IROperation *v4;
  uint64_t v6;
  __int128 v7;
  uint64_t LocationForOp;
  _QWORD *v9;
  int v10;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  int v18;
  MIL::IRValueType *ParameterType;
  MIL::IRMemoryLayoutValueType *v20;
  MIL::IRTensorBufferValueType *v21;
  MIL::IRTensorBufferValueType *v22;
  uint64_t InterleaveFactors;
  uint64_t v24;
  const void *v25;
  int64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t Shape;
  uint64_t v30;
  const void *v31;
  int64_t v32;
  char *v33;
  char *v34;
  _QWORD *Strides;
  uint64_t v36;
  uint64_t *v37;
  uint64_t *v38;
  mlir::StringAttr **v39;
  uint64_t *v40;
  unint64_t v41;
  unsigned int v42;
  uint64_t v43;
  int *v44;
  MIL::IRConstantProperty *v45;
  int ScalarDataType;
  uint64_t UInt8ScalarValue;
  int64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  _BYTE *v53;
  uint64_t *v54;
  uint64_t *v55;
  int64_t v56;
  uint64_t *v57;
  unint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  _DWORD *v63;
  int *v64;
  char *v65;
  _BYTE *v66;
  int64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  _BYTE *v74;
  _DWORD *v75;
  _DWORD *v76;
  int64_t v77;
  unint64_t v78;
  _DWORD *v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  _DWORD *v83;
  _OWORD *v84;
  __int128 *v85;
  uint64_t v86;
  __int128 v87;
  int v88;
  uint64_t v89;
  unint64_t v90;
  char *v91;
  int64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  _BYTE *v99;
  int *v100;
  int64_t v101;
  unint64_t v102;
  unsigned int *v103;
  char *v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  char *v108;
  char *v109;
  char *v110;
  uint64_t v111;
  __int128 v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  _OWORD *v117;
  uint64_t *v118;
  uint64_t v119;
  __int128 v120;
  uint64_t v121;
  std::vector<int>::pointer v122;
  char *v123;
  uint64_t *v124;
  int *v125;
  std::vector<int>::pointer end;
  std::vector<int>::pointer v127;
  _BYTE *v128;
  const float *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v134;
  int *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  MIL::IRConstantProperty *v140;
  uint64_t v142;
  int v143;
  int *begin;
  char v145;
  unint64_t v146;
  uint64_t v147;
  MIL::IRConstantProperty *v148;
  uint64_t v149;
  int v151;
  uint64_t v152;
  int v153;
  unint64_t v154;
  uint64_t v155;
  mlir::OpBuilder *i;
  uint64_t v157;
  std::vector<int>::pointer v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t Context;
  uint64_t v162;
  int *v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t *v169;
  uint64_t v170;
  mlir::GenericProgramPoint *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  int v176;
  int8x16_t v177;
  float32x2_t v178;
  int64x2_t v179;
  int64x2_t v180;
  int64x2_t v181;
  int64x2_t v182;
  int64x2_t v183;
  int32x4_t v184;
  int8x16_t *v185;
  int64x2_t v186;
  int32x4_t v187;
  int64x2_t v188;
  int32x4_t v189;
  uint64_t v190;
  int64x2_t v191;
  int64x2_t v192;
  uint64_t v193;
  int v194;
  int v195;
  int v196;
  uint64_t *v197;
  uint64_t v198;
  int v199;
  uint64_t *v200;
  uint64_t v201;
  uint64_t *v202;
  char v203;
  MILToMLIRRewriter *v204;
  const MIL::IROperation *v205;
  uint64_t *v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  char *v210;
  int v211;
  uint64_t *v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t *v215;
  void *v216;
  __int128 v217;
  void *__p;
  char *v219;
  char *v220;
  void *v221;
  __int128 v222;
  void *v223;
  int *v224;
  int *v225;
  _BYTE *v226;
  _DWORD *v227;
  unint64_t v228;
  uint64_t *v229;
  uint64_t *v230;
  uint64_t *v231;
  uint64_t ArgValue;
  std::string v233;
  uint64_t v234;
  std::vector<int> v235;
  uint64_t v236;

  v4 = a2;
  v236 = *MEMORY[0x1E0C80C00];
  v6 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 56))(a2);
  if (*(char *)(v6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&v233, *(const std::string::value_type **)v6, *(_QWORD *)(v6 + 8));
  }
  else
  {
    v7 = *(_OWORD *)v6;
    v233.__r_.__value_.__r.__words[2] = *(_QWORD *)(v6 + 16);
    *(_OWORD *)&v233.__r_.__value_.__l.__data_ = v7;
  }
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, v4);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, v4, "input");
  v9 = (_QWORD *)((char *)this + 8);
  v10 = *((char *)this + 31);
  if (v10 < 0)
  {
    if (*((_QWORD *)this + 2) != 23)
      goto LABEL_23;
    v9 = (_QWORD *)*v9;
  }
  else if (v10 != 23)
  {
    goto LABEL_23;
  }
  if (*v9 == 0x625F726F736E6574
    && v9[1] == 0x6F745F7265666675
    && *(_QWORD *)((char *)v9 + 15) == 0x726F736E65745F6FLL)
  {
    strcpy((char *)&v229, "input");
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
    v18 = 1;
    goto LABEL_26;
  }
  v13 = (_QWORD *)*v9;
  v14 = v9[1];
  v15 = *(_QWORD *)((char *)v9 + 15);
  if (v13 == (_QWORD *)0x745F726F736E6574 && v14 == 0x726F736E65745F6FLL && v15 == 0x7265666675625F72)
  {
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetOutputType(v4);
    v18 = 0;
    goto LABEL_26;
  }
LABEL_23:
  v18 = 0;
  ParameterType = 0;
LABEL_26:
  v230 = 0;
  v231 = 0;
  v226 = 0;
  v227 = 0;
  v228 = 0;
  v229 = 0;
  v223 = 0;
  v224 = 0;
  v225 = 0;
  v20 = (MIL::IRMemoryLayoutValueType *)MIL::IRValueType::TryCastAsMemoryLayoutType(ParameterType);
  if (v20)
  {
    v21 = (MIL::IRTensorBufferValueType *)MIL::IRMemoryLayoutValueType::TryAsTensorBufferType(v20);
    v22 = v21;
    if (v21)
    {
      InterleaveFactors = MIL::IRTensorBufferValueType::GetInterleaveFactors(v21);
      v221 = 0;
      v222 = 0uLL;
      v25 = *(const void **)InterleaveFactors;
      v24 = *(_QWORD *)(InterleaveFactors + 8);
      v26 = v24 - *(_QWORD *)InterleaveFactors;
      if (v24 == *(_QWORD *)InterleaveFactors)
      {
        v27 = 0;
        v209 = 0;
      }
      else
      {
        if (v26 < 0)
          std::vector<int>::__throw_length_error[abi:ne180100]();
        v27 = (uint64_t)operator new(v24 - *(_QWORD *)InterleaveFactors);
        v221 = (void *)v27;
        *((_QWORD *)&v222 + 1) = v27 + 8 * (v26 >> 3);
        memcpy((void *)v27, v25, v26);
        v209 = *((_QWORD *)&v222 + 1);
        *(_QWORD *)&v222 = *((_QWORD *)&v222 + 1);
      }
      Shape = MIL::IRTensorBufferValueType::GetShape(v22);
      __p = 0;
      v219 = 0;
      v220 = 0;
      v31 = *(const void **)Shape;
      v30 = *(_QWORD *)(Shape + 8);
      v32 = v30 - *(_QWORD *)Shape;
      v207 = LocationForOp;
      if (v30 == *(_QWORD *)Shape)
      {
        v33 = 0;
        v34 = 0;
      }
      else
      {
        if (v32 < 0)
          std::vector<int>::__throw_length_error[abi:ne180100]();
        v33 = (char *)operator new(v32);
        v34 = &v33[8 * (v32 >> 3)];
        __p = v33;
        v220 = v34;
        memcpy(v33, v31, v32);
        v219 = v34;
      }
      Strides = (_QWORD *)MIL::IRTensorBufferValueType::TryGetStrides(v22);
      v36 = (v34 - v33) >> 3;
      if (v36 != (v209 - v27) >> 3)
      {
        v235.__begin_ = (std::vector<int>::pointer)operator new(0x40uLL);
        *(_OWORD *)&v235.__end_ = xmmword_181286AD0;
        strcpy((char *)v235.__begin_, "Invalid op - bufShapeVals.size() != interleaveVals.size()");
        v43 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)&v235);
        goto LABEL_146;
      }
      if (Strides && v36 != (uint64_t)(Strides[1] - *Strides) >> 3)
      {
        v235.__begin_ = (std::vector<int>::pointer)operator new(0x38uLL);
        *(_OWORD *)&v235.__end_ = xmmword_181286AE0;
        strcpy((char *)v235.__begin_, "Invalid op - bufShapeVals.size() != strideVals.size()");
        v43 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)&v235);
        goto LABEL_146;
      }
      if (v209 == v27)
      {
        v121 = ArgValue;
        goto LABEL_132;
      }
      v37 = 0;
      v38 = 0;
      v39 = a3;
      v40 = 0;
      v41 = 0;
      v42 = 0;
      v204 = (MILToMLIRRewriter *)v39;
      v205 = v4;
      v200 = (uint64_t *)(v39 + 13);
      v201 = (uint64_t)Strides;
      v203 = 1;
      v208 = 1;
      v199 = v18;
      while (1)
      {
        v45 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)(v27 + 8 * v41));
        if (!v45)
        {
          while (1)
          {
            v41 = ++v42;
            if ((v209 - v27) >> 3 <= (unint64_t)v42)
              goto LABEL_145;
            v45 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)(v27 + 8 * v42));
            if (v45)
            {
              v203 = 0;
              break;
            }
          }
        }
        ScalarDataType = MIL::IRConstantProperty::GetScalarDataType(v45);
        if (ScalarDataType == 14)
        {
          UInt8ScalarValue = MIL::IRConstantProperty::GetUInt8ScalarValue(v45);
          if (v40 < v38)
            goto LABEL_67;
        }
        else if (ScalarDataType == 12)
        {
          UInt8ScalarValue = MIL::IRConstantProperty::GetInt64ScalarValue(v45);
          if (v40 < v38)
            goto LABEL_67;
        }
        else
        {
          UInt8ScalarValue = -1;
          if (v40 < v38)
          {
LABEL_67:
            *v40++ = UInt8ScalarValue;
            goto LABEL_75;
          }
        }
        v48 = (char *)v40 - (char *)v37;
        v49 = v40 - v37;
        v50 = v49 + 1;
        if ((unint64_t)(v49 + 1) >> 61)
          std::vector<long>::__throw_length_error[abi:ne180100]();
        if (((char *)v38 - (char *)v37) >> 2 > v50)
          v50 = ((char *)v38 - (char *)v37) >> 2;
        if ((unint64_t)((char *)v38 - (char *)v37) >= 0x7FFFFFFFFFFFFFF8)
          v51 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v51 = v50;
        if (v51)
        {
          if (v51 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v52 = UInt8ScalarValue;
          v53 = operator new(8 * v51);
          UInt8ScalarValue = v52;
          v54 = (uint64_t *)&v53[8 * v49];
          *v54 = UInt8ScalarValue;
          v55 = v54 + 1;
          v56 = (char *)v40 - (char *)v37;
          if (v40 == v37)
            goto LABEL_72;
        }
        else
        {
          v53 = 0;
          v54 = (uint64_t *)(8 * v49);
          v57 = (uint64_t *)(8 * v49);
          *v57 = UInt8ScalarValue;
          v55 = v57 + 1;
          v56 = (char *)v40 - (char *)v37;
          if (v40 == v37)
            goto LABEL_72;
        }
        v58 = v56 - 8;
        if (v58 >= 0x168)
        {
          v78 = ((char *)(v40 - 1) - (char *)v37) & 0xFFFFFFFFFFFFFFF8;
          if (&v53[v48 - 8 - v78] > &v53[v48 - 8])
          {
            v59 = v40;
          }
          else if ((uint64_t *)((char *)v40 - v78 - 8) > v40 - 1)
          {
            v59 = v40;
          }
          else if ((unint64_t)((char *)v37 - v53) >= 0x20)
          {
            v115 = (v58 >> 3) + 1;
            v116 = 8 * (v115 & 0x3FFFFFFFFFFFFFFCLL);
            v59 = &v40[v116 / 0xFFFFFFFFFFFFFFF8];
            v54 = (uint64_t *)((char *)v54 - v116);
            v117 = &v53[v48 - 16];
            v118 = v40 - 2;
            v119 = v115 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v120 = *(_OWORD *)v118;
              *(v117 - 1) = *((_OWORD *)v118 - 1);
              *v117 = v120;
              v117 -= 2;
              v118 -= 4;
              v119 -= 4;
            }
            while (v119);
            if (v115 == (v115 & 0x3FFFFFFFFFFFFFFCLL))
              goto LABEL_72;
          }
          else
          {
            v59 = v40;
          }
        }
        else
        {
          v59 = v40;
        }
        do
        {
          v60 = *--v59;
          *--v54 = v60;
        }
        while (v59 != v37);
LABEL_72:
        v38 = (uint64_t *)&v53[8 * v51];
        v229 = v54;
        v230 = v55;
        v231 = v38;
        if (v37)
        {
          v61 = UInt8ScalarValue;
          operator delete(v37);
          UInt8ScalarValue = v61;
          v27 = (uint64_t)v221;
          v209 = v222;
        }
        v37 = v54;
        v40 = v55;
LABEL_75:
        v230 = v40;
        v62 = (v209 - v27) >> 3;
        if (UInt8ScalarValue == 1 || v62 - 1 <= v41)
          goto LABEL_46;
        v206 = v38;
        v63 = v227;
        if ((unint64_t)v227 < v228)
        {
          *v227 = UInt8ScalarValue;
          v227 = v63 + 1;
          v65 = (char *)v224;
          v64 = v225;
          if (v224 >= v225)
            goto LABEL_104;
          goto LABEL_44;
        }
        v66 = v226;
        v67 = (char *)v227 - v226;
        v68 = ((char *)v227 - v226) >> 2;
        v69 = v68 + 1;
        if ((unint64_t)(v68 + 1) >> 62)
          std::vector<int>::__throw_length_error[abi:ne180100]();
        v70 = v228 - (_QWORD)v226;
        if ((uint64_t)(v228 - (_QWORD)v226) >> 1 > v69)
          v69 = v70 >> 1;
        if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFFCLL)
          v71 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v71 = v69;
        if (!v71)
        {
          v74 = 0;
          v75 = (_DWORD *)(4 * v68);
          v79 = (_DWORD *)(4 * v68);
          *v79 = UInt8ScalarValue;
          v76 = v79 + 1;
          v77 = (char *)v63 - v66;
          if (v63 == (_DWORD *)v66)
            goto LABEL_101;
LABEL_95:
          v80 = v77 - 4;
          if (v80 < 0x2C)
            goto LABEL_258;
          if ((unint64_t)((char *)v63 - v74 - v67) < 0x20)
            goto LABEL_258;
          v81 = (v80 >> 2) + 1;
          v82 = 4 * (v81 & 0x7FFFFFFFFFFFFFF8);
          v83 = &v63[v82 / 0xFFFFFFFFFFFFFFFCLL];
          v75 = (_DWORD *)((char *)v75 - v82);
          v84 = &v74[v67 - 16];
          v85 = (__int128 *)(v63 - 4);
          v86 = v81 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v87 = *v85;
            *(v84 - 1) = *(v85 - 1);
            *v84 = v87;
            v84 -= 2;
            v85 -= 2;
            v86 -= 8;
          }
          while (v86);
          v63 = v83;
          if (v81 != (v81 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_258:
            do
            {
              v88 = *--v63;
              *--v75 = v88;
            }
            while (v63 != (_DWORD *)v66);
          }
          goto LABEL_101;
        }
        if (v71 >> 62)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v72 = UInt8ScalarValue;
        v73 = v71;
        v74 = operator new(4 * v71);
        UInt8ScalarValue = v72;
        v62 = (v209 - v27) >> 3;
        v4 = v205;
        v71 = v73;
        v67 = (char *)v227 - v226;
        v75 = &v74[4 * v68];
        *v75 = UInt8ScalarValue;
        v76 = v75 + 1;
        v77 = (char *)v63 - v66;
        if (v63 != (_DWORD *)v66)
          goto LABEL_95;
LABEL_101:
        v226 = v75;
        v228 = (unint64_t)&v74[4 * v71];
        if (v66)
        {
          v89 = UInt8ScalarValue;
          operator delete(v66);
          UInt8ScalarValue = v89;
        }
        v227 = v76;
        v65 = (char *)v224;
        v64 = v225;
        if (v224 >= v225)
        {
LABEL_104:
          v202 = v40;
          v90 = v62;
          v91 = (char *)v223;
          v92 = v65 - (_BYTE *)v223;
          v93 = (v65 - (_BYTE *)v223) >> 2;
          v94 = v93 + 1;
          if ((unint64_t)(v93 + 1) >> 62)
            std::vector<int>::__throw_length_error[abi:ne180100]();
          v95 = (char *)v64 - (_BYTE *)v223;
          if (v95 >> 1 > v94)
            v94 = v95 >> 1;
          if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFFCLL)
            v96 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v96 = v94;
          if (v96)
          {
            if (v96 >> 62)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v97 = UInt8ScalarValue;
            v98 = v96;
            v99 = operator new(4 * v96);
            UInt8ScalarValue = v97;
            v96 = v98;
            v100 = (int *)&v99[4 * v93];
            *v100 = v42;
            v44 = v100 + 1;
            v101 = v65 - v91;
            if (v65 != v91)
            {
LABEL_113:
              v102 = v101 - 4;
              if (v102 < 0x2C)
              {
                v62 = v90;
                v40 = v202;
                v4 = v205;
                goto LABEL_121;
              }
              v104 = &v99[v92];
              v105 = v65 - &v99[v92];
              v62 = v90;
              v40 = v202;
              v4 = v205;
              if (v105 < 0x20)
                goto LABEL_259;
              v106 = (v102 >> 2) + 1;
              v107 = 4 * (v106 & 0x7FFFFFFFFFFFFFF8);
              v108 = &v65[-v107];
              v100 = (int *)((char *)v100 - v107);
              v109 = v104 - 16;
              v110 = v65 - 16;
              v111 = v106 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                v112 = *(_OWORD *)v110;
                *((_OWORD *)v109 - 1) = *((_OWORD *)v110 - 1);
                *(_OWORD *)v109 = v112;
                v109 -= 32;
                v110 -= 32;
                v111 -= 8;
              }
              while (v111);
              v65 = v108;
              if (v106 != (v106 & 0x7FFFFFFFFFFFFFF8))
              {
LABEL_259:
                do
                {
LABEL_121:
                  v113 = *((_DWORD *)v65 - 1);
                  v65 -= 4;
                  *--v100 = v113;
                }
                while (v65 != v91);
              }
LABEL_122:
              v223 = v100;
              v225 = (int *)&v99[4 * v96];
              if (v91)
              {
                v114 = UInt8ScalarValue;
                operator delete(v91);
                UInt8ScalarValue = v114;
              }
              goto LABEL_45;
            }
          }
          else
          {
            v99 = 0;
            v100 = (int *)(4 * v93);
            v103 = (unsigned int *)(4 * v93);
            *v103 = v42;
            v44 = (int *)(v103 + 1);
            v101 = v65 - v91;
            if (v65 != v91)
              goto LABEL_113;
          }
          v62 = v90;
          v40 = v202;
          v4 = v205;
          goto LABEL_122;
        }
LABEL_44:
        *(_DWORD *)v65 = v42;
        v44 = (int *)(v65 + 4);
LABEL_45:
        v224 = v44;
        v208 *= UInt8ScalarValue;
        v38 = v206;
LABEL_46:
        v41 = ++v42;
        if (v62 <= v42)
        {
          if ((v203 & 1) != 0)
          {
            if (v208 < 2)
            {
              v121 = ArgValue;
              a3 = (mlir::StringAttr **)v204;
            }
            else
            {
              v128 = __p;
              v129 = (const float *)v223;
              v130 = *((_QWORD *)__p + *(int *)v223);
              v131 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v130 + 16))(v130);
              v210 = v219;
              if (v131)
                v132 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v131 + 48))(v131);
              else
                v132 = -1;
              v134 = (uint64_t)v224;
              if (v223 != v224)
              {
                v135 = (int *)v223;
                while (1)
                {
                  v137 = *v135;
                  v138 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)__p + v137) + 16))(*((_QWORD *)__p + v137));
                  v139 = MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)(v27 + 8 * v137));
                  v140 = (MIL::IRConstantProperty *)v139;
                  if (v138 && v139 != 0)
                  {
                    v142 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v138 + 48))(v138);
                    v143 = MIL::IRConstantProperty::GetScalarDataType(v140);
                    if (v143 == 14)
                      v136 = MIL::IRConstantProperty::GetUInt8ScalarValue(v140);
                    else
                      v136 = v143 == 12 ? MIL::IRConstantProperty::GetInt64ScalarValue(v140) : -1;
                    if (v142 % v136)
                      break;
                  }
                  if (++v135 == v224)
                    goto LABEL_176;
                }
                v235.__begin_ = (std::vector<int>::pointer)operator new(0x28uLL);
                *(_OWORD *)&v235.__end_ = xmmword_181269AA0;
                strcpy((char *)v235.__begin_, "shape[dim] % interleave[dim] != 0");
                v43 = MILToMLIRRewriter::notifyFailure((uint64_t)v204, (uint64_t)v4, (const std::string::value_type *)&v235);
LABEL_146:
                v27 = v43;
                if (SHIBYTE(v235.__end_cap_.__value_) < 0)
                  operator delete(v235.__begin_);
LABEL_148:
                if (__p)
                  operator delete(__p);
                v28 = v221;
                if (v221)
LABEL_151:
                  operator delete(v28);
                goto LABEL_152;
              }
LABEL_176:
              if (v201)
              {
                std::vector<MIL::IRProperty const*>::vector(&v235, v201);
                begin = v235.__begin_;
                if ((std::vector<int>::pointer)((char *)v235.__end_ - (char *)v235.__begin_) == (std::vector<int>::pointer)16)
                {
                  v145 = 0;
                }
                else
                {
                  v146 = 0;
                  while (1)
                  {
                    v148 = (MIL::IRConstantProperty *)MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)&begin[2 * v146]);
                    v149 = MIL::IRProperty::TryAsConstant(*(MIL::IRProperty **)&v235.__begin_[2 * v146 + 2]);
                    v27 = v149;
                    if (v148 && v149 != 0)
                    {
                      v151 = MIL::IRConstantProperty::GetScalarDataType(v148);
                      if (v151 == 14)
                        v152 = MIL::IRConstantProperty::GetUInt8ScalarValue(v148);
                      else
                        v152 = v151 == 12 ? MIL::IRConstantProperty::GetInt64ScalarValue(v148) : -1;
                      v153 = MIL::IRConstantProperty::GetScalarDataType((MIL::IRConstantProperty *)v27);
                      if (v153 == 14)
                        v147 = MIL::IRConstantProperty::GetUInt8ScalarValue((MIL::IRConstantProperty *)v27);
                      else
                        v147 = v153 == 12
                             ? MIL::IRConstantProperty::GetInt64ScalarValue((MIL::IRConstantProperty *)v27)
                             : -1;
                      if (v152 % v147)
                        break;
                    }
                    ++v146;
                    begin = v235.__begin_;
                    if (v146 >= (((char *)v235.__end_ - (char *)v235.__begin_) >> 3) - 2)
                    {
                      v145 = 0;
                      goto LABEL_201;
                    }
                  }
                  v216 = operator new(0x20uLL);
                  v217 = xmmword_181286AC0;
                  strcpy((char *)v216, "strides[i] % strides[i+1] != 0");
                  v27 = MILToMLIRRewriter::notifyFailure((uint64_t)v204, (uint64_t)v4, (const std::string::value_type *)&v216);
                  if (SHIBYTE(v217) < 0)
                    operator delete(v216);
                  v145 = 1;
                  begin = v235.__begin_;
                }
LABEL_201:
                if (begin)
                {
                  v235.__end_ = begin;
                  operator delete(begin);
                }
                if ((v145 & 1) != 0)
                  goto LABEL_148;
              }
              if (v134 - (_QWORD)v129 == 4 && v132 == v208)
              {
                v154 = v210 - v128;
                v155 = (v210 - v128) >> 3;
                v235.__begin_ = (std::vector<int>::pointer)v155;
                i = (mlir::OpBuilder *)v200;
                v157 = mlir::IntegerType::get(*v200, 0x20u, 1u);
                a3 = (mlir::StringAttr **)v204;
                v216 = (void *)mlir::RankedTensorType::get((uint64_t)&v235, 1, v157, 0);
                std::vector<int>::vector(&v235, v155);
                if (v210 - v128 >= 1)
                {
                  v158 = v235.__begin_;
                  if (v155 <= 1)
                    v159 = 1;
                  else
                    v159 = (v210 - v128) >> 3;
                  if ((v199 & 1) != 0)
                  {
                    if (v159 < 8)
                    {
                      v160 = 0;
                      goto LABEL_233;
                    }
                    if (v235.__begin_ < (std::vector<int>::pointer)v129 + 1
                      && (std::vector<int>::pointer)v129 < &v235.__begin_[v159])
                    {
                      v160 = 0;
                      goto LABEL_233;
                    }
                    v160 = v159 & 0x7FFFFFFFFFFFFFF8;
                    v177 = (int8x16_t)vdupq_n_s32((v154 >> 3) - 1);
                    v178 = vld1_dup_f32(v129);
                    v179.i64[0] = v178.u32[0];
                    v179.i64[1] = v178.u32[1];
                    v180 = v179;
                    v179.i64[0] = v178.i32[0];
                    v179.i64[1] = v178.i32[1];
                    v181 = v179;
                    v182 = (int64x2_t)xmmword_181233290;
                    v183 = (int64x2_t)xmmword_181233120;
                    v184 = (int32x4_t)xmmword_181235170;
                    v185 = (int8x16_t *)(v235.__begin_ + 4);
                    v186 = vdupq_n_s64(4uLL);
                    v187.i64[0] = 0x400000004;
                    v187.i64[1] = 0x400000004;
                    v188 = vdupq_n_s64(8uLL);
                    v189.i64[0] = 0x800000008;
                    v189.i64[1] = 0x800000008;
                    v190 = v159 & 0x7FFFFFFFFFFFFFF8;
                    do
                    {
                      v191 = vaddq_s64(v183, v186);
                      v192 = vaddq_s64(v182, v186);
                      v185[-1] = vbslq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_s64(v183, v180), (int32x4_t)vceqq_s64(v182, v180)), v177, (int8x16_t)vaddq_s32(v184, vuzp1q_s32((int32x4_t)vcgtq_s64(v183, v181), (int32x4_t)vcgtq_s64(v182, v181))));
                      *v185 = vbslq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_s64(v191, v180), (int32x4_t)vceqq_s64(v192, v180)), v177, (int8x16_t)vaddq_s32(vaddq_s32(v184, v187), vuzp1q_s32((int32x4_t)vcgtq_s64(v191, v181), (int32x4_t)vcgtq_s64(v192, v181))));
                      v182 = vaddq_s64(v182, v188);
                      v183 = vaddq_s64(v183, v188);
                      v184 = vaddq_s32(v184, v189);
                      v185 += 2;
                      v190 -= 8;
                    }
                    while (v190);
                    a3 = (mlir::StringAttr **)v204;
                    for (i = (mlir::OpBuilder *)v200; v159 != v160; ++v160)
                    {
LABEL_233:
                      v193 = *(int *)v129;
                      if (v160 <= v193)
                        v194 = 0;
                      else
                        v194 = -1;
                      v195 = v160 + v194;
                      if (v160 == v193)
                        v196 = (v154 >> 3) - 1;
                      else
                        v196 = v195;
                      v158[v160] = v196;
                    }
                  }
                  else
                  {
                    v174 = 0;
                    do
                    {
                      v175 = *(int *)v129;
                      if (v174 == v175)
                        v176 = (v154 >> 3) - 1;
                      else
                        v176 = v174 - (v174 > v175);
                      v158[v176] = v174++;
                    }
                    while (v159 != v174);
                  }
                }
                v197 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v216);
                v234 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v197, v198, (uint64_t)v235.__begin_, (uint64_t)v235.__end_);
                v215 = (uint64_t *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(i, v207, (uint64_t **)&v234);
                v173 = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::mps::ConstantOp &>(i, v207, &ArgValue, (uint64_t)&v215);
                if (!*(_DWORD *)(v173 + 36))
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                if (v235.__begin_)
                {
                  v235.__end_ = v235.__begin_;
                  operator delete(v235.__begin_);
                }
              }
              else
              {
                v235.__begin_ = (std::vector<int>::pointer)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
                Context = mlir::Attribute::getContext((mlir::Attribute *)&v235);
                a3 = (mlir::StringAttr **)v204;
                v162 = mlir::IntegerType::get(Context, 0x20u, 1u);
                v163 = (int *)mlir::RankedTensorType::get(0, 0, v162, 0);
                v234 = (v134 - (uint64_t)v129) >> 2;
                v235.__begin_ = v163;
                v216 = (void *)mlir::RankedTensorType::get((uint64_t)&v234, 1, v162, 0);
                v164 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v216);
                v234 = mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v164, v165, (uint64_t)v129, v134);
                v166 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v216);
                v215 = (uint64_t *)mlir::DenseIntElementsAttr::get<std::vector<int> &>((uint64_t)v166, v167, (uint64_t)v226, (uint64_t)v227);
                v168 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::RankedTensorType &,mlir::DenseIntElementsAttr &>((mlir::OpBuilder *)v200, v207, (uint64_t *)&v216, (uint64_t **)&v234);
                if (!*(_DWORD *)(v168 + 36))
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                v214 = v168 - 16;
                v169 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v235);
                v211 = -1;
                v212 = (uint64_t *)mlir::DenseIntElementsAttr::get<int>((uint64_t)v169, v170, (uint64_t)&v211);
                v171 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v200, v207, &v212);
                if (!*((_DWORD *)v171 + 9))
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                v213 = (uint64_t)v171 - 16;
                v172 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::RankedTensorType &,mlir::DenseIntElementsAttr &>((mlir::OpBuilder *)v200, v207, (uint64_t *)&v216, &v215);
                if (!*(_DWORD *)(v172 + 36))
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                v212 = (uint64_t *)(v172 - 16);
                if (v199)
                {
                  LOBYTE(v211) = 1;
                  v173 = (uint64_t)mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)v200, v207, &ArgValue, &v214, &v213, (uint64_t *)&v212, (unsigned __int8 *)&v211);
                  if (!*(_DWORD *)(v173 + 36))
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                else
                {
                  LOBYTE(v211) = 1;
                  v173 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)v200, v207, &ArgValue, &v214, &v213, (uint64_t *)&v212, (unsigned __int8 *)&v211);
                  if (!*(_DWORD *)(v173 + 36))
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
              }
              v121 = v173 - 16;
            }
LABEL_132:
            (*(void (**)(std::vector<int> *__return_ptr, const MIL::IROperation *))(*(_QWORD *)v4 + 200))(&v235, v4);
            v122 = v235.__begin_;
            v123 = (char *)operator new(8uLL);
            *(_QWORD *)v123 = v121;
            v216 = v122;
            v124 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v122, (uint64_t)&std::piecewise_construct, (__int128 **)&v216);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v124 + 5, v123, v123 + 8, 1uLL);
            operator delete(v123);
            v125 = v235.__begin_;
            if (v235.__begin_)
            {
              end = v235.__end_;
              v127 = v235.__begin_;
              if (v235.__end_ != v235.__begin_)
              {
                do
                {
                  if (*((char *)end - 1) < 0)
                    operator delete(*((void **)end - 3));
                  end -= 6;
                }
                while (end != v125);
                v127 = v235.__begin_;
              }
              v235.__end_ = v125;
              operator delete(v127);
            }
            v27 = 1;
            goto LABEL_148;
          }
LABEL_145:
          v235.__begin_ = (std::vector<int>::pointer)operator new(0x30uLL);
          *(_OWORD *)&v235.__end_ = xmmword_181267480;
          strcpy((char *)v235.__begin_, "Non-constant interleave factor detected!");
          v43 = MILToMLIRRewriter::notifyFailure((uint64_t)v204, (uint64_t)v4, (const std::string::value_type *)&v235);
          goto LABEL_146;
        }
      }
    }
  }
  v221 = operator new(0x28uLL);
  v222 = xmmword_181261450;
  strcpy((char *)v221, "Expected \"input\" to be a tensor_buffer.");
  v27 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)v4, (const std::string::value_type *)&v221);
  if (SHIBYTE(v222) < 0)
  {
    v28 = v221;
    goto LABEL_151;
  }
LABEL_152:
  if (v223)
    operator delete(v223);
  if (v226)
    operator delete(v226);
  if (v229)
    operator delete(v229);
  if (SHIBYTE(v233.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v233.__r_.__value_.__l.__data_);
  return v27;
}

void sub_180E0A910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,void *a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,void *a41,uint64_t a42)
{
  uint64_t v42;
  void *v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  void *v48;

  if (a31 < 0)
    operator delete(__p);
  v44 = *(void **)(v42 - 128);
  if (v44)
  {
    *(_QWORD *)(v42 - 120) = v44;
    operator delete(v44);
  }
  if (a32)
    operator delete(a32);
  if (a35)
    operator delete(a35);
  if (a41)
  {
    operator delete(a41);
    v45 = v42 - 216;
    v46 = *(void **)(v42 - 216);
    if (!v46)
    {
LABEL_11:
      v47 = v42 - 216;
      v48 = *(void **)(v42 - 192);
      if (!v48)
      {
LABEL_16:
        if (*(char *)(v42 - 137) < 0)
          operator delete(*(void **)(v42 - 160));
        _Unwind_Resume(exception_object);
      }
LABEL_15:
      *(_QWORD *)(v47 + 32) = v48;
      operator delete(v48);
      goto LABEL_16;
    }
  }
  else
  {
    v45 = v42 - 216;
    v46 = *(void **)(v42 - 216);
    if (!v46)
      goto LABEL_11;
  }
  *(_QWORD *)(v45 + 8) = v46;
  operator delete(v46);
  v47 = v42 - 216;
  v48 = *(void **)(v42 - 192);
  if (!v48)
    goto LABEL_16;
  goto LABEL_15;
}

_QWORD *std::vector<MIL::IRProperty const*>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;
  char *v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    if (v5 < 0)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v6 = (char *)operator new(v3 - *(_QWORD *)a2);
    *a1 = v6;
    a1[1] = v6;
    v7 = &v6[8 * (v5 >> 3)];
    a1[2] = v7;
    memcpy(v6, v4, v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_180E0ABA8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::vector<int>::size_type v4;
  int *v5;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    if (__n >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v4 = __n;
    v5 = (int *)operator new(4 * __n);
    this->__begin_ = v5;
    this->__end_cap_.__value_ = &v5[__n];
    bzero(v5, 4 * __n);
    this->__end_ = &v5[v4];
  }
  return this;
}

void sub_180E0AC3C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.permute";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::PermuteOp::build((uint64_t)a1, (uint64_t)v24, *a3, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::PermuteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PermuteOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E0AE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0AE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::RankedTensorType &,mlir::DenseIntElementsAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t **a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t *v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.constant";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v9);
  v11 = *a3;
  v12 = mlir::Attribute::cast<mlir::ElementsAttr>(a4);
  mlir::mps::ConstantOp::build((uint64_t)a1, (uint64_t)v26, v11, v12);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ConstantOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConstantOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E0AFB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0AFCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::ResamplePattern::matchAndRewrite(MILToMLIR::ResamplePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::OpBuilder *v6;
  void *v7;
  _DWORD *v8;
  uint64_t Context;
  uint64_t v10;
  uint64_t **v11;
  uint64_t InterfaceFor;
  const char *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t ParameterValue;
  uint64_t v20;
  _BOOL4 v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v25;
  uint64_t v27;
  uint64_t v28;
  unsigned int v30;
  uint64_t v34;
  uint64_t v35;
  BOOL v36;
  _BOOL4 v40;
  mlir::Float32Type *v41;
  mlir::MLIRContext *v42;
  uint64_t v43;
  uint64_t *v44;
  mlir::GenericProgramPoint *v45;
  mlir::Float32Type *v46;
  mlir::MLIRContext *v47;
  uint64_t v48;
  uint64_t *v49;
  mlir::GenericProgramPoint *v50;
  mlir::GenericProgramPoint *v51;
  mlir::GenericProgramPoint *v52;
  void *v54;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  char v61;
  mlir::GenericProgramPoint *v62;
  uint64_t v63;
  uint64_t *v64;
  char *v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  const char *v73;
  int v74;
  const char *v75;
  const char *v76;
  int v77;
  uint64_t v78;
  uint64_t ArgValue;
  uint64_t v80;
  uint64_t v81;
  const char *v82;
  __int16 v83;
  uint64_t v84[4];
  __int16 v85;
  _BYTE __p[22];
  char v87;
  uint64_t *v88[7];

  v88[5] = *(uint64_t **)MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v80 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "coordinates");
  v87 = 18;
  strcpy(__p, "coordinates_format");
  v78 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "padding_value");
  v6 = (mlir::OpBuilder *)(a3 + 13);
  if (MIL::IROperation::TryGetParameterValue())
  {
    MIL::IRValue::GetScalar<std::string>();
    if (v87 < 0)
    {
      v7 = *(void **)__p;
      if (*(_QWORD *)&__p[8] != 2)
      {
LABEL_14:
        operator delete(v7);
        goto LABEL_15;
      }
      if (**(_WORD **)__p == 30841)
      {
        v8 = operator new(4uLL);
        *v8 = -1;
        v88[0] = (uint64_t *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
        Context = mlir::Attribute::getContext((mlir::Attribute *)v88);
        v10 = mlir::IntegerType::get(Context, 0x20u, 1u);
        v88[0] = (uint64_t *)1;
        v11 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v88, 1, v10, 0);
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v11))
        {
          v13 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          v14 = 566;
          v15 = "Casting.h";
          v16 = "cast";
LABEL_166:
          __assert_rtn(v16, v15, v14, v13);
        }
        if (v11)
        {
          InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v11);
          if (!InterfaceFor)
          {
            v13 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v14 = 98;
            v15 = "InterfaceSupport.h";
            v16 = "Interface";
            goto LABEL_166;
          }
        }
        else
        {
          InterfaceFor = 0;
        }
        v17 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v11, InterfaceFor, v8, 4, 4, 1, 1);
        if ((mlir::DenseIntElementsAttr::classof((uint64_t)v17) & 1) == 0)
          __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
        v88[0] = v17;
        v84[0] = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v6, LocationForOp, v88);
        v18 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::mps::ConstantOp &>(v6, LocationForOp, &v80, (uint64_t)v84);
        if (!*(_DWORD *)(v18 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v80 = v18 - 16;
        operator delete(v8);
        if (v87 < 0)
        {
          v7 = *(void **)__p;
          goto LABEL_14;
        }
      }
    }
  }
LABEL_15:
  v87 = 16;
  strcpy(__p, "coordinates_type");
  ParameterValue = MIL::IROperation::TryGetParameterValue();
  v20 = ParameterValue;
  if (v87 < 0)
  {
    operator delete(*(void **)__p);
    if (!v20)
    {
LABEL_22:
      v21 = 0;
      goto LABEL_27;
    }
  }
  else if (!ParameterValue)
  {
    goto LABEL_22;
  }
  MIL::IRValue::GetScalar<std::string>();
  if ((v87 & 0x80000000) == 0)
  {
    if (v87 == 8)
    {
      v21 = *(_QWORD *)__p == 0x65766974616C6572;
      goto LABEL_27;
    }
    goto LABEL_22;
  }
  v21 = *(_QWORD *)&__p[8] == 8 && **(_QWORD **)__p == 0x65766974616C6572;
  operator delete(*(void **)__p);
LABEL_27:
  v87 = 13;
  strcpy(__p, "sampling_mode");
  v22 = MIL::IROperation::TryGetParameterValue();
  v23 = v22;
  if (v87 < 0)
  {
    operator delete(*(void **)__p);
    v77 = v21;
    if (!v23)
      goto LABEL_39;
  }
  else
  {
    v77 = v21;
    if (!v22)
      goto LABEL_39;
  }
  MIL::IRValue::GetScalar<std::string>();
  if ((v87 & 0x80000000) == 0)
  {
    if (v87 == 7)
    {
      v25 = *(_DWORD *)__p != 1918985582 || *(_DWORD *)&__p[3] != 1953719666;
      goto LABEL_49;
    }
LABEL_39:
    v25 = 1;
    goto LABEL_49;
  }
  v25 = *(_QWORD *)&__p[8] != 7 || **(_DWORD **)__p != 1918985582 || *(_DWORD *)(*(_QWORD *)__p + 3) != 1953719666;
  operator delete(*(void **)__p);
LABEL_49:
  v87 = 12;
  strcpy(__p, "padding_mode");
  v27 = MIL::IROperation::TryGetParameterValue();
  v28 = v27;
  if (v87 < 0)
  {
    operator delete(*(void **)__p);
    if (!v28)
    {
LABEL_81:
      v30 = 0;
      goto LABEL_82;
    }
  }
  else if (!v27)
  {
    goto LABEL_81;
  }
  MIL::IRValue::GetScalar<std::string>();
  if (v87 < 0)
  {
    switch(*(_QWORD *)&__p[8])
    {
      case 6:
        if (**(_DWORD **)__p != 1685221218 || *(_WORD *)(*(_QWORD *)__p + 4) != 29285)
          goto LABEL_173;
        v30 = 3;
        operator delete(*(void **)__p);
        break;
      case 8:
        if (**(_QWORD **)__p != 0x746E6174736E6F63)
          goto LABEL_173;
        v30 = 0;
        operator delete(*(void **)__p);
        break;
      case 9:
        if (**(_QWORD **)__p != 0x697274656D6D7973 || *(_BYTE *)(*(_QWORD *)__p + 8) != 99)
          goto LABEL_173;
        v30 = 2;
        operator delete(*(void **)__p);
        break;
      case 0xALL:
        if (**(_QWORD **)__p != 0x697463656C666572 || *(_WORD *)(*(_QWORD *)__p + 8) != 28271)
          goto LABEL_173;
        v30 = 1;
        operator delete(*(void **)__p);
        break;
      default:
LABEL_173:
        __assert_rtn("matchAndRewrite", "MILToMLIRCustomPatterns.mm", 2589, "0 && \"Unknown padding mode\"");
    }
  }
  else
  {
    switch(v87)
    {
      case 6:
        if (*(_DWORD *)__p != 1685221218 || *(unsigned __int16 *)&__p[4] != 29285)
          goto LABEL_173;
        v30 = 3;
        break;
      case 8:
        if (*(_QWORD *)__p == 0x746E6174736E6F63)
          goto LABEL_81;
        goto LABEL_173;
      case 9:
        if (*(_QWORD *)__p != 0x697274656D6D7973 || __p[8] != 99)
          goto LABEL_173;
        v30 = 2;
        break;
      case 10:
        if (*(_QWORD *)__p != 0x697463656C666572 || *(unsigned __int16 *)&__p[8] != 28271)
          goto LABEL_173;
        v30 = 1;
        break;
      default:
        goto LABEL_173;
    }
  }
LABEL_82:
  v87 = 16;
  strcpy(__p, "coordinates_mode");
  v34 = MIL::IROperation::TryGetParameterValue();
  v35 = v34;
  if (v87 < 0)
  {
    operator delete(*(void **)__p);
    if (!v35)
      goto LABEL_130;
  }
  else if (!v34)
  {
    goto LABEL_130;
  }
  MIL::IRValue::GetScalar<std::string>();
  if ((v87 & 0x80000000) == 0)
  {
    if (v87 != 12)
    {
      if (v87 != 22)
        goto LABEL_130;
      v36 = *(_QWORD *)__p == 0x7A696C616D726F6ELL && *(_QWORD *)&__p[8] == 0x5F6F72657A5F6465;
      if (!v36 || *(_QWORD *)&__p[14] != 0x656E6F5F6F745F6FLL)
        goto LABEL_130;
LABEL_110:
      *(_QWORD *)__p = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
      v41 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__p);
      v43 = mlir::Float32Type::get(v41, v42);
      *(_QWORD *)__p = 1;
      v44 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v43, 0);
      *(_QWORD *)__p = mlir::mps::getConstantAttr<float>(v44, 1.0);
      v45 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v6, LocationForOp, (uint64_t **)__p);
      if (!*((_DWORD *)v45 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v88[0] = (uint64_t *)((char *)v45 - 16);
      *(_QWORD *)__p = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
      v46 = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)__p);
      v48 = mlir::Float32Type::get(v46, v47);
      *(_QWORD *)__p = 1;
      v49 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__p, 1, v48, 0);
      *(_QWORD *)__p = mlir::mps::getConstantAttr<float>(v49, 2.0);
      v50 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v6, LocationForOp, (uint64_t **)__p);
      if (!*((_DWORD *)v50 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      *(_QWORD *)__p = (char *)v50 - 16;
      v51 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v6, LocationForOp, &v80, (uint64_t *)__p);
      if (!*((_DWORD *)v51 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v80 = (uint64_t)v51 - 16;
      v52 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)v6, LocationForOp, &v80, (uint64_t *)v88);
      if (!*((_DWORD *)v52 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v80 = (uint64_t)v52 - 16;
      goto LABEL_130;
    }
    if (*(_QWORD *)__p != 0x6C616D726F6E6E75 || *(_DWORD *)&__p[8] != 1684372073)
      goto LABEL_130;
LABEL_127:
    v56 = 0;
    goto LABEL_131;
  }
  if (*(_QWORD *)&__p[8] == 12)
  {
    v54 = *(void **)__p;
    if (**(_QWORD **)__p == 0x6C616D726F6E6E75 && *(_DWORD *)(*(_QWORD *)__p + 8) == 1684372073)
    {
      operator delete(*(void **)__p);
      goto LABEL_127;
    }
  }
  else
  {
    if (*(_QWORD *)&__p[8] == 22)
    {
      v40 = **(_QWORD **)__p != 0x7A696C616D726F6ELL
         || *(_QWORD *)(*(_QWORD *)__p + 8) != 0x5F6F72657A5F6465
         || *(_QWORD *)(*(_QWORD *)__p + 14) != 0x656E6F5F6F745F6FLL;
      operator delete(*(void **)__p);
      if (v40)
        goto LABEL_130;
      goto LABEL_110;
    }
    v54 = *(void **)__p;
  }
  operator delete(v54);
LABEL_130:
  v56 = 1;
LABEL_131:
  v87 = 13;
  strcpy(__p, "align_corners");
  MIL::IROperation::GetParameterValue();
  if (v87 < 0)
    operator delete(*(void **)__p);
  v57 = MIL::IRValue::GetScalar<BOOL>();
  v58 = mlir::mps::NearestRoundingModeAttr::get(*(mlir::MLIRContext **)v6, 0);
  v81 = LocationForOp;
  v59 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v81);
  v60 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sample_grid", (const unsigned __int8 *)0xF, v59);
  if (!v61)
  {
    v85 = 1283;
    v84[2] = (uint64_t)"mps.sample_grid";
    v84[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v83 = 259;
    llvm::operator+(v84, (uint64_t *)&v82, (uint64_t)v88);
    llvm::report_fatal_error((llvm::Twine *)v88, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v60);
  mlir::mps::SampleGridOp::build((mlir::UnitAttr **)v6, (uint64_t)__p, ArgValue, v80, v78, v56, v77, v57, v30, v25, 0, v58);
  v62 = mlir::OpBuilder::create(v6, (const mlir::OperationState *)__p);
  if (!v62)
  {
    v73 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v74 = 662;
    v75 = "Casting.h";
    v76 = "dyn_cast";
    goto LABEL_163;
  }
  v63 = llvm::DefaultDoCastIfPossible<mlir::mps::SampleGridOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SampleGridOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v62);
  if (!v63)
  {
    v73 = "result && \"builder didn't return the right type\"";
    v74 = 497;
    v75 = "Builders.h";
    v76 = "create";
LABEL_163:
    __assert_rtn(v76, v75, v74, v73);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (!*(_DWORD *)(v63 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  (*(void (**)(_BYTE *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
  v64 = *(uint64_t **)__p;
  v65 = (char *)operator new(8uLL);
  *(_QWORD *)v65 = v63 - 16;
  v88[0] = v64;
  v66 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v64, (uint64_t)&std::piecewise_construct, (__int128 **)v88);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v66 + 5, v65, v65 + 8, 1uLL);
  operator delete(v65);
  v67 = *(_QWORD *)__p;
  if (*(_QWORD *)__p)
  {
    v68 = *(_QWORD *)&__p[8];
    v69 = *(void **)__p;
    if (*(_QWORD *)&__p[8] != *(_QWORD *)__p)
    {
      do
      {
        if (*(char *)(v68 - 1) < 0)
          operator delete(*(void **)(v68 - 24));
        v68 -= 24;
      }
      while (v68 != v67);
      v69 = *(void **)__p;
    }
    *(_QWORD *)&__p[8] = v67;
    operator delete(v69);
  }
  return 1;
}

void sub_180E0BC74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  void *v32;

  operator delete(v32);
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reverse", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.reverse";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ReverseOp::build((uint64_t)a1, (uint64_t)v24, *a3, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::ReverseOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReverseOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E0BEE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0BF00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::ArgSortPattern::matchAndRewrite(MILToMLIR::ArgSortPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  int v8;
  uint64_t *Context;
  uint64_t v10;
  char v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  uint64_t NextResultAtOffset;
  __int128 *v15;
  char *v16;
  uint64_t *v17;
  void **v18;
  void **v19;
  void *v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  __int128 *v31[5];
  void *__p[2];
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  v33 = 9;
  strcpy((char *)__p, "ascending");
  MIL::IROperation::GetParameterValue();
  v8 = MIL::IRValue::GetScalar<BOOL>();
  v26 = LocationForOp;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sort", (const unsigned __int8 *)8, Context);
  if (!v11)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"mps.sort";
    v29[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v10);
  mlir::mps::SortOp::build(a3 + 13, (uint64_t)__p, ArgValue, v7, v8 ^ 1);
  v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)__p);
  if (!v12)
  {
    v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v23 = 662;
    v24 = "Casting.h";
    v25 = "dyn_cast";
    goto LABEL_17;
  }
  v13 = llvm::DefaultDoCastIfPossible<mlir::mps::SortOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SortOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
  if (!v13)
  {
    v22 = "result && \"builder didn't return the right type\"";
    v23 = 497;
    v24 = "Builders.h";
    v25 = "create";
LABEL_17:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (*(_DWORD *)(v13 + 36) <= 1u)
    __assert_rtn("operator[]", "STLExtras.h", 1281, "Index < size() && \"invalid index for value range\"");
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v13 - 16, 1);
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
  v15 = (__int128 *)__p[0];
  v16 = (char *)operator new(8uLL);
  *(_QWORD *)v16 = NextResultAtOffset;
  v31[0] = v15;
  v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v15, (uint64_t)&std::piecewise_construct, v31);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
  operator delete(v16);
  v18 = (void **)__p[0];
  if (__p[0])
  {
    v19 = (void **)__p[1];
    v20 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v19 - 1) < 0)
          operator delete(*(v19 - 3));
        v19 -= 3;
      }
      while (v19 != v18);
      v20 = __p[0];
    }
    __p[1] = v18;
    operator delete(v20);
  }
  return 1;
}

void sub_180E0C20C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  std::vector<std::string>::~vector[abi:ne180100](&a26);
  _Unwind_Resume(a1);
}

void sub_180E0C220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0C234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t MILToMLIR::ReadStatePattern::matchAndRewrite(MILToMLIR::ReadStatePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  uint64_t v14;
  void *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v17;
  uint64_t v18;
  __int128 *v19;
  void *v20;
  char *v21;
  uint64_t *v22;
  void **v23;
  void **v24;
  void *v25;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  const char *v31;
  int v32;
  const char *v33;
  const char *v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  uint64_t ArgValue;
  uint64_t v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  __int128 *v45[5];
  void *__p;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "input");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::VariableFromTensorOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    v7 = v6;
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v8 = *(_QWORD *)(v6 - 8) & 0xFFFFFFFFFFFFFFF8;
    if (!*(_QWORD *)v8)
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    v9 = *(void **)(*(_QWORD *)v8 + 136);
    if (v9 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v9 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
    }
    v40 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v40);
    v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.read_variable", (const unsigned __int8 *)0x11, Context);
    if (!v13)
    {
      v44 = 1283;
      v43[2] = (uint64_t)"mps.read_variable";
      v43[3] = 17;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)v45);
      llvm::report_fatal_error((llvm::Twine *)v45, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (*(_DWORD *)(v7 + 36))
    {
      v14 = *(_QWORD *)(*(_QWORD *)(v7 - 8) & 0xFFFFFFFFFFFFFFF8);
      if (v14)
      {
        v15 = *(void **)(v14 + 136);
        if (v15 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
          || v15 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
        {
          mlir::anec::Broadcast::build((uint64_t)(a3 + 13), (uint64_t)&__p, v8, v7 - 16);
          v16 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
          if (v16)
          {
            v17 = llvm::DefaultDoCastIfPossible<mlir::mps::ReadVariableOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReadVariableOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v16);
            if (v17)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
              (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
              if (*(_DWORD *)(v17 + 36))
              {
                v18 = *(_QWORD *)(*(_QWORD *)(v17 - 8) & 0xFFFFFFFFFFFFFFF8);
                if (v18)
                {
                  v19 = (__int128 *)__p;
                  v20 = *(void **)(v18 + 136);
                  if (v20 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
                    || v20 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
                  {
                    v21 = (char *)operator new(8uLL);
                    *(_QWORD *)v21 = v17 - 16;
                    v45[0] = v19;
                    v22 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v19, (uint64_t)&std::piecewise_construct, v45);
                    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v22 + 5, v21, v21 + 8, 1uLL);
                    operator delete(v21);
                    v23 = (void **)__p;
                    if (__p)
                    {
                      v24 = (void **)v47;
                      v25 = __p;
                      if ((void *)v47 != __p)
                      {
                        do
                        {
                          if (*((char *)v24 - 1) < 0)
                            operator delete(*(v24 - 3));
                          v24 -= 3;
                        }
                        while (v24 != v23);
                        v25 = __p;
                      }
                      *(_QWORD *)&v47 = v23;
                      operator delete(v25);
                    }
                    return 1;
                  }
                  v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
                  v36 = 566;
                  v37 = "Casting.h";
                  v38 = "cast";
                }
                else
                {
                  v35 = "abstractType && \"Malformed type storage object.\"";
                  v36 = 160;
                  v37 = "TypeSupport.h";
                  v38 = "getAbstractType";
                }
              }
              else
              {
                v35 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
                v36 = 984;
                v37 = "Operation.h";
                v38 = "getOpResultImpl";
              }
              __assert_rtn(v38, v37, v36, v35);
            }
            v31 = "result && \"builder didn't return the right type\"";
            v32 = 497;
            v33 = "Builders.h";
            v34 = "create";
          }
          else
          {
            v31 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            v32 = 662;
            v33 = "Casting.h";
            v34 = "dyn_cast";
          }
          __assert_rtn(v34, v33, v32, v31);
        }
        v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v28 = 566;
        v29 = "Casting.h";
        v30 = "cast";
      }
      else
      {
        v27 = "abstractType && \"Malformed type storage object.\"";
        v28 = 160;
        v29 = "TypeSupport.h";
        v30 = "getAbstractType";
      }
    }
    else
    {
      v27 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
      v28 = 984;
      v29 = "Operation.h";
      v30 = "getOpResultImpl";
    }
    __assert_rtn(v30, v29, v28, v27);
  }
  __p = operator new(0x40uLL);
  v47 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v47) < 0)
    operator delete(__p);
  return 0;
}

void sub_180E0C738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::VariableFromTensorOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.variable_from_tensor", (const unsigned __int8 *)0x18, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.variable_from_tensor";
    v19[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::VariableFromTensorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::VariableFromTensorOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E0C928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0C940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::WriteStatePattern::matchAndRewrite(MILToMLIR::WriteStatePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  mlir::OpBuilder *v8;
  uint64_t v9;
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  void *v14;
  mlir::GenericProgramPoint *v16;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  const char *v21;
  int v22;
  const char *v23;
  const char *v24;
  uint64_t ArgValue;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _BYTE v31[40];
  void *__p;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "input");
  v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
  if (!(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2))
  {
    v8 = (mlir::OpBuilder *)(a3 + 13);
    v9 = mlir::OpBuilder::create<mlir::mps::VariableFromTensorOp,mlir::Value &>(v8, LocationForOp, &ArgValue);
    v26 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
    v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.assign_variable", (const unsigned __int8 *)0x13, Context);
    if (!v12)
    {
      v30 = 1283;
      v29[2] = (uint64_t)"mps.assign_variable";
      v29[3] = 19;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v28 = 259;
      llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
      llvm::report_fatal_error((llvm::Twine *)v31, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v11);
    if (*(_DWORD *)(v9 + 36))
    {
      v13 = *(_QWORD *)(*(_QWORD *)(v9 - 8) & 0xFFFFFFFFFFFFFFF8);
      if (v13)
      {
        v14 = *(void **)(v13 + 136);
        if (v14 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
          || v14 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
        {
          mlir::mps::AssignVariableOp::build((uint64_t)v8, (uint64_t)&__p, v9 - 16, v6);
          v16 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
          if (v16)
          {
            if (llvm::DefaultDoCastIfPossible<mlir::mps::AssignVariableOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AssignVariableOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v16))
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
              return 1;
            }
            v21 = "result && \"builder didn't return the right type\"";
            v22 = 497;
            v23 = "Builders.h";
            v24 = "create";
          }
          else
          {
            v21 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            v22 = 662;
            v23 = "Casting.h";
            v24 = "dyn_cast";
          }
          __assert_rtn(v24, v23, v22, v21);
        }
        v17 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v18 = 566;
        v19 = "Casting.h";
        v20 = "cast";
      }
      else
      {
        v17 = "abstractType && \"Malformed type storage object.\"";
        v18 = 160;
        v19 = "TypeSupport.h";
        v20 = "getAbstractType";
      }
    }
    else
    {
      v17 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
      v18 = 984;
      v19 = "Operation.h";
      v20 = "getOpResultImpl";
    }
    __assert_rtn(v20, v19, v18, v17);
  }
  __p = operator new(0x40uLL);
  v33 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v33) < 0)
    operator delete(__p);
  return 0;
}

void sub_180E0CC3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E0CC64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0CC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::SDPAPattern::matchAndRewrite(MILToMLIR::SDPAPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t OptionalArgValue;
  uint64_t v8;
  uint64_t **v9;
  uint64_t v10;
  uint64_t InterfaceFor;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  uint64_t ArgAttrsAttr;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v31;
  mlir::GenericProgramPoint *v32;
  uint64_t *v33;
  uint64_t v34;
  char v35;
  mlir::GenericProgramPoint *v36;
  uint64_t v37;
  uint64_t *v39;
  mlir::GenericProgramPoint *v40;
  uint64_t *v41;
  uint64_t v42;
  char v43;
  mlir::GenericProgramPoint *v44;
  uint64_t *v45;
  uint64_t v46;
  char v47;
  mlir::GenericProgramPoint *v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  char v52;
  mlir::GenericProgramPoint *v53;
  uint64_t v54;
  __int128 *v55;
  char *v56;
  uint64_t *v57;
  void **v58;
  void **v59;
  void *v60;
  const char *v61;
  int v62;
  const char *v63;
  const char *v64;
  const char *v65;
  int v66;
  const char *v67;
  const char *v68;
  const char *v69;
  int v70;
  const char *v71;
  const char *v72;
  const char *v73;
  int v74;
  const char *v75;
  const char *v76;
  const char *v77;
  int v78;
  const char *v79;
  const char *v80;
  const char *v81;
  int v82;
  const char *v83;
  const char *v84;
  uint64_t ElementTypeOrSelf;
  uint64_t **v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t ArgValue;
  uint64_t v91;
  uint64_t v92[4];
  __int16 v93;
  uint64_t v94[2];
  const char *v95;
  uint64_t v96;
  __int16 v97;
  __int128 *v98[5];
  void *__p;
  __int128 v100;
  uint64_t v101;

  v101 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "query");
  v89 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "key");
  v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "value");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "attn_mask");
  v88 = OptionalArgValue;
  v8 = *(_QWORD *)(ArgValue + 8);
  v9 = (uint64_t **)(v8 & 0xFFFFFFFFFFFFFFF8);
  if ((v8 & 0xFFFFFFFFFFFFFFF8) == 0)
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  v10 = OptionalArgValue;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v8 & 0xFFFFFFFFFFFFFFF8)))
  {
    v86 = 0;
    v87 = 0;
LABEL_16:
    __p = operator new(0x20uLL);
    v100 = xmmword_181261470;
    strcpy((char *)__p, "Query did not have a ShapedType");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    goto LABEL_35;
  }
  InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v9);
  if (!InterfaceFor)
    __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  v86 = v9;
  v87 = InterfaceFor;
  if (!v9)
    goto LABEL_16;
  LODWORD(__p) = -1;
  v12 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, (unsigned int *)&__p);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8));
  v13 = *(_QWORD *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13)
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  if (*(_UNKNOWN **)(v13 + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v86);
    if (!v22)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v23 = *(_QWORD *)(ArgAttrsAttr + 8 * v22 - 8);
    __p = (void *)1;
    v24 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
    __p = (void *)mlir::mps::getConstantAttr<float>(v24, 1.0 / sqrtf((float)v23));
    v20 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
    if (!*(_DWORD *)(v20 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    goto LABEL_19;
  }
  v91 = LocationForOp;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v91);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dimension_size", (const unsigned __int8 *)0x12, Context);
  if (!v16)
  {
    v97 = 1283;
    v95 = "mps.dimension_size";
    v96 = 18;
                      "een added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-de"
                      "pendent-whats-up-with-dialects-management";
    v93 = 259;
    llvm::operator+(v94, v92, (uint64_t)v98);
    llvm::report_fatal_error((llvm::Twine *)v98, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v15);
  if (!*((_DWORD *)v12 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::DimensionSizeOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue, (uint64_t)v12 - 16);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
  if (!v17)
  {
    v61 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v62 = 662;
    v63 = "Casting.h";
    v64 = "dyn_cast";
    goto LABEL_70;
  }
  v18 = llvm::DefaultDoCastIfPossible<mlir::mps::DimensionSizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DimensionSizeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
  if (!v18)
  {
    v61 = "result && \"builder didn't return the right type\"";
    v62 = 497;
    v63 = "Builders.h";
    v64 = "create";
LABEL_70:
    __assert_rtn(v64, v63, v62, v61);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  if (!*(_DWORD *)(v18 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  __p = (void *)(v18 - 16);
  v19 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 13, LocationForOp, (uint64_t *)&__p, &ElementTypeOrSelf);
  if (!*((_DWORD *)v19 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  __p = (char *)v19 - 16;
  v20 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t *)&__p);
  if (!*(_DWORD *)(v20 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_19:
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    LOBYTE(__p) = 0;
    LOBYTE(v98[0]) = 1;
    v25 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 13, LocationForOp, &ArgValue, &v89, (unsigned __int8 *)&__p, (unsigned __int8 *)v98);
    v91 = LocationForOp;
    v26 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v91);
    v27 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v26);
    if (!v28)
    {
      v97 = 1283;
      v95 = "mps.multiply";
      v96 = 12;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v93 = 259;
      llvm::operator+(v94, v92, (uint64_t)v98);
      llvm::report_fatal_error((llvm::Twine *)v98, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v27);
    if (!*(_DWORD *)(v25 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, v25 - 16, v20 - 16);
    v29 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v29)
    {
      v30 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v29);
      if (v30)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v10)
        {
          v31 = mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v10 + 8) & 0xFFFFFFFFFFFFFFF8));
          if (ElementTypeOrSelf != v31)
          {
            v32 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 13, LocationForOp, &v88, &ElementTypeOrSelf);
            if (!*((_DWORD *)v32 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v88 = (uint64_t)v32 - 16;
          }
          v91 = LocationForOp;
          v33 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v91);
          v34 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, v33);
          if (!v35)
          {
            v97 = 1283;
            v95 = "mps.add";
            v96 = 7;
                              "hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#regi"
                              "stered-loaded-dependent-whats-up-with-dialects-management";
            v93 = 259;
            llvm::operator+(v94, v92, (uint64_t)v98);
            llvm::report_fatal_error((llvm::Twine *)v98, 1);
          }
          mlir::OperationState::OperationState(&__p, LocationForOp, v34);
          if (!*(_DWORD *)(v30 + 36))
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, v30 - 16, v88);
          v36 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
          if (v36)
          {
            v37 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v36);
            if (v37)
            {
              mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
              if (!*(_DWORD *)(v37 + 36))
                __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
              goto LABEL_45;
            }
            v77 = "result && \"builder didn't return the right type\"";
            v78 = 497;
            v79 = "Builders.h";
            v80 = "create";
          }
          else
          {
            v77 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
            v78 = 662;
            v79 = "Casting.h";
            v80 = "dyn_cast";
          }
          __assert_rtn(v80, v79, v78, v77);
        }
        __p = (void *)1;
        v39 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
        __p = (void *)mlir::mps::getConstantAttr<float>(v39, 0.0);
        v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
        v91 = LocationForOp;
        v41 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v91);
        v42 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, v41);
        if (!v43)
        {
          v97 = 1283;
          v95 = "mps.add";
          v96 = 7;
                            "sn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#register"
                            "ed-loaded-dependent-whats-up-with-dialects-management";
          v93 = 259;
          llvm::operator+(v94, v92, (uint64_t)v98);
          llvm::report_fatal_error((llvm::Twine *)v98, 1);
        }
        mlir::OperationState::OperationState(&__p, LocationForOp, v42);
        if (!*(_DWORD *)(v30 + 36) || !*((_DWORD *)v40 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, v30 - 16, (uint64_t)v40 - 16);
        v44 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
        if (v44)
        {
          v37 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v44);
          if (v37)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
            if (!*(_DWORD *)(v37 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_45:
            v91 = LocationForOp;
            v45 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v91);
            v46 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softmax", (const unsigned __int8 *)0xB, v45);
            if (!v47)
            {
              v97 = 1283;
              v95 = "mps.softmax";
              v96 = 11;
                                "n hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#"
                                "registered-loaded-dependent-whats-up-with-dialects-management";
              v93 = 259;
              llvm::operator+(v94, v92, (uint64_t)v98);
              llvm::report_fatal_error((llvm::Twine *)v98, 1);
            }
            mlir::OperationState::OperationState(&__p, LocationForOp, v46);
            if (!*((_DWORD *)v12 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            mlir::mps::SoftmaxOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, v37 - 16, (uint64_t)v12 - 16);
            v48 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
            if (v48)
            {
              v49 = llvm::DefaultDoCastIfPossible<mlir::mps::SoftmaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SoftmaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v48);
              if (v49)
              {
                mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
                v91 = LocationForOp;
                v50 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v91);
                v51 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, v50);
                if (!v52)
                {
                  v97 = 1283;
                  v95 = "mps.matmul";
                  v96 = 10;
                                    "ation hasn't been added by the dialect. See also https://mlir.llvm.org/getting_start"
                                    "ed/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                  v93 = 259;
                  llvm::operator+(v94, v92, (uint64_t)v98);
                  llvm::report_fatal_error((llvm::Twine *)v98, 1);
                }
                mlir::OperationState::OperationState(&__p, LocationForOp, v51);
                if (!*(_DWORD *)(v49 + 36))
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                mlir::mps::MatMulOp::build(a3 + 13, (uint64_t)&__p, v49 - 16, v6, 0, 0);
                v53 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
                if (v53)
                {
                  v54 = llvm::DefaultDoCastIfPossible<mlir::mps::MatMulOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MatMulOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v53);
                  if (v54)
                  {
                    mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
                    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
                    if (!*(_DWORD *)(v54 + 36))
                      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                    v55 = (__int128 *)__p;
                    v56 = (char *)operator new(8uLL);
                    *(_QWORD *)v56 = v54 - 16;
                    v98[0] = v55;
                    v57 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v55, (uint64_t)&std::piecewise_construct, v98);
                    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v57 + 5, v56, v56 + 8, 1uLL);
                    operator delete(v56);
                    v58 = (void **)__p;
                    if (__p)
                    {
                      v59 = (void **)v100;
                      v60 = __p;
                      if ((void *)v100 != __p)
                      {
                        do
                        {
                          if (*((char *)v59 - 1) < 0)
                            operator delete(*(v59 - 3));
                          v59 -= 3;
                        }
                        while (v59 != v58);
                        v60 = __p;
                      }
                      *(_QWORD *)&v100 = v58;
                      operator delete(v60);
                    }
                    return 1;
                  }
                  v73 = "result && \"builder didn't return the right type\"";
                  v74 = 497;
                  v75 = "Builders.h";
                  v76 = "create";
                }
                else
                {
                  v73 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                  v74 = 662;
                  v75 = "Casting.h";
                  v76 = "dyn_cast";
                }
                __assert_rtn(v76, v75, v74, v73);
              }
              v69 = "result && \"builder didn't return the right type\"";
              v70 = 497;
              v71 = "Builders.h";
              v72 = "create";
            }
            else
            {
              v69 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              v70 = 662;
              v71 = "Casting.h";
              v72 = "dyn_cast";
            }
            __assert_rtn(v72, v71, v70, v69);
          }
          v81 = "result && \"builder didn't return the right type\"";
          v82 = 497;
          v83 = "Builders.h";
          v84 = "create";
        }
        else
        {
          v81 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          v82 = 662;
          v83 = "Casting.h";
          v84 = "dyn_cast";
        }
        __assert_rtn(v84, v83, v82, v81);
      }
      v65 = "result && \"builder didn't return the right type\"";
      v66 = 497;
      v67 = "Builders.h";
      v68 = "create";
    }
    else
    {
      v65 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v66 = 662;
      v67 = "Casting.h";
      v68 = "dyn_cast";
    }
    __assert_rtn(v68, v67, v66, v65);
  }
  __p = operator new(0x40uLL);
  v100 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
LABEL_35:
  if (SHIBYTE(v100) < 0)
    operator delete(__p);
  return 0;
}

void sub_180E0DA00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reciprocal_square_root";
    v19[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ReciprocalSquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReciprocalSquareRootOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E0DCBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0DCD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(mlir::BoolAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  _QWORD v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.matmul";
    v25[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::MatMulOp::build(a1, (uint64_t)v28, *a3, *a4, (mlir::MLIRContext *)*a5, (mlir::MLIRContext *)*a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::MatMulOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MatMulOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180E0DE78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0DE90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void MILToMLIR::ConvolutionPattern::~ConvolutionPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::PadPattern::~PadPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::CropPattern::~CropPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::UpsampleBilinearPattern::~UpsampleBilinearPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::ResizePattern::~ResizePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::UpsampleNearestNeighborPattern::~UpsampleNearestNeighborPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::SplitPattern::~SplitPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::StackPattern::~StackPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::InversePattern::~InversePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::LogarithmPattern::~LogarithmPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::RsqrtPattern::~RsqrtPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::Range1dPattern::~Range1dPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::RandomPattern::~RandomPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::ReversePattern::~ReversePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::Flatten2DPattern::~Flatten2DPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::TopKPattern::~TopKPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::CropResizePattern::~CropResizePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::ConstExpressionPattern::~ConstExpressionPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::ReshapeLikePattern::~ReshapeLikePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::QuantizePattern::~QuantizePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::TensorBufferPattern::~TensorBufferPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::ResamplePattern::~ResamplePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::ArgSortPattern::~ArgSortPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::ReadStatePattern::~ReadStatePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::WriteStatePattern::~WriteStatePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::SDPAPattern::~SDPAPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,int &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, unsigned int *a8, int *a9)
{
  uint64_t *Context;
  uint64_t v18;
  char v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  const char *v23;
  int v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  __int16 v29;
  uint64_t v30[4];
  __int16 v31;
  _BYTE v32[40];
  _QWORD v33[39];

  v33[38] = *MEMORY[0x1E0C80C00];
  v27 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, Context);
  if (!v19)
  {
    v31 = 1283;
    v30[2] = (uint64_t)"mps.depthwise_conv_3d";
    v30[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v29 = 259;
    llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v32);
    llvm::report_fatal_error((llvm::Twine *)v32, 1);
  }
  mlir::OperationState::OperationState(v33, a2, v18);
  mlir::mps::DepthwiseConv3DOp::build(a1, (uint64_t)v33, *a3, *a4, *a5, *a6, *a7, *a8, *a9);
  v20 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v33);
  if (!v20)
  {
    v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v24 = 662;
    v25 = "Casting.h";
    v26 = "dyn_cast";
    goto LABEL_8;
  }
  v21 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v20);
  if (!v21)
  {
    v23 = "result && \"builder didn't return the right type\"";
    v24 = 497;
    v25 = "Builders.h";
    v26 = "create";
LABEL_8:
    __assert_rtn(v26, v25, v24, v23);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v33);
  return v21;
}

void sub_180E0F0A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0F0B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::arrayToU64Attr(MILToMLIR *this, mlir::OpBuilder *a2, int *a3)
{
  uint64_t IntegerType;
  _QWORD *v6;
  uint64_t **v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t InterfaceFor;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  void *v20;
  uint64_t v21;
  _QWORD v22[7];

  v22[6] = *MEMORY[0x1E0C80C00];
  IntegerType = mlir::Builder::getIntegerType(this, 0x40u, 0);
  v6 = operator new(8uLL);
  *v6 = a3;
  v7 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v6, 1, IntegerType, 0);
  v8 = 0;
  v20 = v22;
  v21 = 0x600000000;
  v9 = 6;
  do
  {
    v11 = *(int *)a2;
    a2 = (mlir::OpBuilder *)((char *)a2 + 4);
    v10 = v11;
    if (v8 >= v9)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v8 + 1, 8);
      *((_QWORD *)v20 + v21) = v10;
      v12 = v21;
      v9 = HIDWORD(v21);
      if (v21 >= (unint64_t)HIDWORD(v21))
LABEL_7:
        __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
    }
    else
    {
      *((_QWORD *)v20 + v8) = v10;
      v12 = v21;
      v9 = HIDWORD(v21);
      if (v21 >= (unint64_t)HIDWORD(v21))
        goto LABEL_7;
    }
    v8 = v12 + 1;
    LODWORD(v21) = v8;
    a3 = (int *)((char *)a3 - 1);
  }
  while (a3);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v7))
    goto LABEL_17;
  if (v7)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v7);
    if (!InterfaceFor)
    {
      v14 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v15 = 98;
      v16 = "InterfaceSupport.h";
      v17 = "Interface";
      goto LABEL_18;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v18 = mlir::DenseElementsAttr::getFromRawBuffer(v7, InterfaceFor, v20, 8 * v21, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v18) & 1) == 0)
  {
LABEL_17:
    v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v15 = 566;
    v16 = "Casting.h";
    v17 = "cast";
LABEL_18:
    __assert_rtn(v17, v16, v15, v14);
  }
  if (v20 != v22)
    free(v20);
  operator delete(v6);
  return v18;
}

void sub_180E0F2B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  if (a10 != v11)
    free(a10);
  operator delete(v10);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value &,mlir::Value &,int &,int &,int &,int &,int &,int &,int &,int &,int &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, int *a6, int *a7, int *a8, int *a9, int *a10, int *a11, int *a12, int *a13, unsigned int *a14, unsigned int *a15, unsigned int *a16)
{
  uint64_t *Context;
  uint64_t v25;
  char v26;
  mlir::GenericProgramPoint *v27;
  uint64_t v28;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  uint64_t v34;
  const char *v35;
  __int16 v36;
  uint64_t v37[4];
  __int16 v38;
  _BYTE v39[40];
  _QWORD v40[39];

  v40[38] = *MEMORY[0x1E0C80C00];
  v34 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v34);
  v25 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v26)
  {
    v38 = 1283;
    v37[2] = (uint64_t)"mps.conv_2d";
    v37[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v36 = 259;
    llvm::operator+(v37, (uint64_t *)&v35, (uint64_t)v39);
    llvm::report_fatal_error((llvm::Twine *)v39, 1);
  }
  mlir::OperationState::OperationState(v40, a2, v25);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v40, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14, *a15, *a16);
  v27 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v40);
  if (!v27)
  {
    v30 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v31 = 662;
    v32 = "Casting.h";
    v33 = "dyn_cast";
    goto LABEL_8;
  }
  v28 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v27);
  if (!v28)
  {
    v30 = "result && \"builder didn't return the right type\"";
    v31 = 497;
    v32 = "Builders.h";
    v33 = "create";
LABEL_8:
    __assert_rtn(v33, v32, v31, v30);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v40);
  return v28;
}

void sub_180E0F4E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

void sub_180E0F4FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::BiasAddOp,mlir::Value &,mlir::Value &,mlir::mps::TensorDataLayout>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bias_add", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.bias_add";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::BiasAddOp::build(a1, (uint64_t)v26, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::BiasAddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BiasAddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E0F698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0F6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

_QWORD *llvm::SmallVector<int,4u>::SmallVector(_QWORD *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x400000000;
  llvm::SmallVectorImpl<int>::append<int const*,void>((uint64_t)a1, a2, &a2[4 * a3]);
  return a1;
}

void sub_180E0F700(_Unwind_Exception *exception_object)
{
  void **v1;
  void *v2;
  void *v3;

  v3 = v2;
  if (*v1 != v3)
    free(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t mlir::DenseIntElementsAttr::get<llvm::SmallVector<int,4u> &>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;

  v4 = mlir::DenseElementsAttr::getFromRawBuffer(a1, a2, a3, 4 * a4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v4) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  return v4;
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,int &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, unsigned int *a9, int *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  uint64_t v22;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  _BYTE v33[40];
  _QWORD v34[39];

  v34[38] = *MEMORY[0x1E0C80C00];
  v28 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_data_gradient", (const unsigned __int8 *)0x23, Context);
  if (!v20)
  {
    v32 = 1283;
    v31[2] = (uint64_t)"mps.depthwise_conv_3d_data_gradient";
    v31[3] = 35;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  mlir::mps::DepthwiseConv3DDataGradientOp::build(a1, (uint64_t)v34, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  v21 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v34);
  if (!v21)
  {
    v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v25 = 662;
    v26 = "Casting.h";
    v27 = "dyn_cast";
    goto LABEL_8;
  }
  v22 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    v24 = "result && \"builder didn't return the right type\"";
    v25 = 497;
    v26 = "Builders.h";
    v27 = "create";
LABEL_8:
    __assert_rtn(v27, v26, v25, v24);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v22;
}

void sub_180E0F934(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0F94C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv2DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,int &,int &,int &,int &,int &,int &,int &,int &,int &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, int *a6, int *a7, int *a8, int *a9, int *a10, int *a11, int *a12, int *a13, int *a14, unsigned int *a15, unsigned int *a16, unsigned int *a17)
{
  uint64_t *Context;
  uint64_t v26;
  char v27;
  mlir::GenericProgramPoint *v28;
  uint64_t v29;
  const char *v31;
  int v32;
  const char *v33;
  const char *v34;
  uint64_t v35;
  const char *v36;
  __int16 v37;
  uint64_t v38[4];
  __int16 v39;
  _BYTE v40[40];
  _QWORD v41[39];

  v41[38] = *MEMORY[0x1E0C80C00];
  v35 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v35);
  v26 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_data_gradient", (const unsigned __int8 *)0x19, Context);
  if (!v27)
  {
    v39 = 1283;
    v38[2] = (uint64_t)"mps.conv_2d_data_gradient";
    v38[3] = 25;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v37 = 259;
    llvm::operator+(v38, (uint64_t *)&v36, (uint64_t)v40);
    llvm::report_fatal_error((llvm::Twine *)v40, 1);
  }
  mlir::OperationState::OperationState(v41, a2, v26);
  mlir::mps::Conv2DDataGradientOp::build(a1, (uint64_t)v41, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14, *a15, *a16, *a17);
  v28 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v41);
  if (!v28)
  {
    v31 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v32 = 662;
    v33 = "Casting.h";
    v34 = "dyn_cast";
    goto LABEL_8;
  }
  v29 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v28);
  if (!v29)
  {
    v31 = "result && \"builder didn't return the right type\"";
    v32 = 497;
    v33 = "Builders.h";
    v34 = "create";
LABEL_8:
    __assert_rtn(v34, v33, v32, v31);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v41);
  return v29;
}

void sub_180E0FB54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a34);
  _Unwind_Resume(a1);
}

void sub_180E0FB6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a34);
  _Unwind_Resume(a1);
}

_QWORD *llvm::SmallVector<int,1u>::SmallVector(_QWORD *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x100000000;
  llvm::SmallVectorImpl<int>::append<int const*,void>((uint64_t)a1, a2, &a2[4 * a3]);
  return a1;
}

void sub_180E0FBBC(_Unwind_Exception *exception_object)
{
  void **v1;
  void *v2;
  void *v3;

  v3 = v2;
  if (*v1 != v3)
    free(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DOp,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, unsigned int *a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _BYTE v31[40];
  _QWORD v32[39];

  v32[38] = *MEMORY[0x1E0C80C00];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, Context);
  if (!v18)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"mps.depthwise_conv_3d";
    v29[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  mlir::mps::DepthwiseConv3DOp::build(a1, (uint64_t)v32, *a3, *a4, *a5, *a6, *a7, *a8, -4);
  v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v23 = 662;
    v24 = "Casting.h";
    v25 = "dyn_cast";
    goto LABEL_8;
  }
  v20 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    v22 = "result && \"builder didn't return the right type\"";
    v23 = 497;
    v24 = "Builders.h";
    v25 = "create";
LABEL_8:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180E0FD8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0FDA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

_QWORD *llvm::SmallVector<int,5u>::SmallVector(_QWORD *a1, _BYTE *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x500000000;
  llvm::SmallVectorImpl<int>::append<int const*,void>((uint64_t)a1, a2, &a2[4 * a3]);
  return a1;
}

void sub_180E0FDF4(_Unwind_Exception *exception_object)
{
  void **v1;
  void *v2;
  void *v3;

  v3 = v2;
  if (*v1 != v3)
    free(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, unsigned int *a9)
{
  uint64_t *Context;
  uint64_t v18;
  char v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  const char *v23;
  int v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  __int16 v29;
  uint64_t v30[4];
  __int16 v31;
  _BYTE v32[40];
  _QWORD v33[39];

  v33[38] = *MEMORY[0x1E0C80C00];
  v27 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_data_gradient", (const unsigned __int8 *)0x23, Context);
  if (!v19)
  {
    v31 = 1283;
    v30[2] = (uint64_t)"mps.depthwise_conv_3d_data_gradient";
    v30[3] = 35;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v29 = 259;
    llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v32);
    llvm::report_fatal_error((llvm::Twine *)v32, 1);
  }
  mlir::OperationState::OperationState(v33, a2, v18);
  mlir::mps::DepthwiseConv3DDataGradientOp::build(a1, (uint64_t)v33, *a3, *a4, *a5, *a6, *a7, *a8, *a9, -4);
  v20 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v33);
  if (!v20)
  {
    v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v24 = 662;
    v25 = "Casting.h";
    v26 = "dyn_cast";
    goto LABEL_8;
  }
  v21 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v20);
  if (!v21)
  {
    v23 = "result && \"builder didn't return the right type\"";
    v24 = 497;
    v25 = "Builders.h";
    v26 = "create";
LABEL_8:
    __assert_rtn(v26, v25, v24, v23);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v33);
  return v21;
}

void sub_180E0FFCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E0FFE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,long long &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  uint64_t v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.transpose";
    v23[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::TransposeOp::build(a1, v26, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::TransposeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TransposeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E10180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E10198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

char *llvm::SmallVectorImpl<int>::erase(uint64_t a1, char *__dst)
{
  uint64_t v2;
  unint64_t v3;
  char *v7;
  unint64_t v8;

  v2 = *(unsigned int *)(a1 + 8);
  v3 = *(_QWORD *)a1 + 4 * v2;
  if (*(_QWORD *)a1 > (unint64_t)__dst || v3 <= (unint64_t)__dst)
    __assert_rtn("erase", "SmallVector.h", 745, "this->isReferenceToStorage(CI) && \"Iterator to erase is out of bounds.\"");
  v7 = __dst + 4;
  if ((char *)v3 != v7)
  {
    memmove(__dst, v7, v3 - (_QWORD)v7);
    v2 = *(unsigned int *)(a1 + 8);
  }
  v8 = v2 - 1;
  if (v8 > *(unsigned int *)(a1 + 12))
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  *(_DWORD *)(a1 + 8) = v8;
  return __dst;
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value &,mlir::Value &,int &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,unsigned long &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, unsigned int *a14, unsigned int *a15, unsigned int *a16)
{
  uint64_t *Context;
  uint64_t v25;
  char v26;
  mlir::GenericProgramPoint *v27;
  uint64_t v28;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  uint64_t v34;
  const char *v35;
  __int16 v36;
  uint64_t v37[4];
  __int16 v38;
  _BYTE v39[40];
  _QWORD v40[39];

  v40[38] = *MEMORY[0x1E0C80C00];
  v34 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v34);
  v25 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v26)
  {
    v38 = 1283;
    v37[2] = (uint64_t)"mps.conv_2d";
    v37[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v36 = 259;
    llvm::operator+(v37, (uint64_t *)&v35, (uint64_t)v39);
    llvm::report_fatal_error((llvm::Twine *)v39, 1);
  }
  mlir::OperationState::OperationState(v40, a2, v25);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v40, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14, *a15, *a16);
  v27 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v40);
  if (!v27)
  {
    v30 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v31 = 662;
    v32 = "Casting.h";
    v33 = "dyn_cast";
    goto LABEL_8;
  }
  v28 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v27);
  if (!v28)
  {
    v30 = "result && \"builder didn't return the right type\"";
    v31 = 497;
    v32 = "Builders.h";
    v33 = "create";
LABEL_8:
    __assert_rtn(v33, v32, v31, v30);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v40);
  return v28;
}

void sub_180E10440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

void sub_180E10458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

uint64_t mlir::Type::dyn_cast_or_null<mlir::TensorType>(uint64_t result)
{
  void *v1;

  if (result)
  {
    if (!*(_QWORD *)result)
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    v1 = *(void **)(*(_QWORD *)result + 136);
    if (v1 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
      && v1 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      return 0;
    }
  }
  return result;
}

_QWORD *std::vector<unsigned long long>::vector[abi:ne180100](_QWORD *a1, const void *a2, unint64_t a3)
{
  size_t v5;
  char *v6;
  char *v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >> 61)
      std::vector<long>::__throw_length_error[abi:ne180100]();
    v5 = 8 * a3;
    v6 = (char *)operator new(8 * a3);
    *a1 = v6;
    a1[1] = v6;
    v7 = &v6[v5];
    a1[2] = &v6[v5];
    memmove(v6, a2, v5);
    a1[1] = v7;
  }
  return a1;
}

void sub_180E1053C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv3DOp,mlir::Value &,mlir::Value &,int &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9, unsigned int *a10, unsigned int *a11)
{
  uint64_t *Context;
  uint64_t v20;
  char v21;
  uint64_t v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v24;
  const char *v26;
  int v27;
  const char *v28;
  const char *v29;
  uint64_t v30;
  const char *v31;
  __int16 v32;
  uint64_t v33[4];
  __int16 v34;
  _BYTE v35[40];
  _QWORD v36[39];

  v36[38] = *MEMORY[0x1E0C80C00];
  v30 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
  v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d", (const unsigned __int8 *)0xB, Context);
  if (!v21)
  {
    v34 = 1283;
    v33[2] = (uint64_t)"mps.conv_3d";
    v33[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v32 = 259;
    llvm::operator+(v33, (uint64_t *)&v31, (uint64_t)v35);
    llvm::report_fatal_error((llvm::Twine *)v35, 1);
  }
  mlir::OperationState::OperationState(v36, a2, v20);
  mlir::mps::Conv3DOp::build(a1, (uint64_t)v36, *a3, *a4, *a5, *(uint64_t **)a6, (uint64_t)(*(_QWORD *)(a6 + 8) - *(_QWORD *)a6) >> 3, v22, *(uint64_t **)a7, (uint64_t)(*(_QWORD *)(a7 + 8) - *(_QWORD *)a7) >> 3, *(uint64_t **)a8, (uint64_t)(*(_QWORD *)(a8 + 8) - *(_QWORD *)a8) >> 3, *a9, *a10, *a11);
  v23 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v36);
  if (!v23)
  {
    v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v27 = 662;
    v28 = "Casting.h";
    v29 = "dyn_cast";
    goto LABEL_8;
  }
  v24 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv3DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v23);
  if (!v24)
  {
    v26 = "result && \"builder didn't return the right type\"";
    v27 = 497;
    v28 = "Builders.h";
    v29 = "create";
LABEL_8:
    __assert_rtn(v29, v28, v27, v26);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v36);
  return v24;
}

void sub_180E1073C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

void sub_180E10754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::Conv3DDataGradientOp,mlir::Value &,mlir::Value &,mlir::Value &,int &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,std::vector<unsigned long long> &,mlir::mps::PaddingStyle &,mlir::mps::TensorDataLayout &,mlir::mps::TensorDataLayout &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int *a10, unsigned int *a11, unsigned int *a12)
{
  uint64_t *Context;
  uint64_t v21;
  char v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v24;
  const char *v26;
  int v27;
  const char *v28;
  const char *v29;
  uint64_t v30;
  const char *v31;
  __int16 v32;
  uint64_t v33[4];
  __int16 v34;
  _BYTE v35[40];
  _QWORD v36[39];

  v36[38] = *MEMORY[0x1E0C80C00];
  v30 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
  v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_data_gradient", (const unsigned __int8 *)0x19, Context);
  if (!v22)
  {
    v34 = 1283;
    v33[2] = (uint64_t)"mps.conv_3d_data_gradient";
    v33[3] = 25;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v32 = 259;
    llvm::operator+(v33, (uint64_t *)&v31, (uint64_t)v35);
    llvm::report_fatal_error((llvm::Twine *)v35, 1);
  }
  mlir::OperationState::OperationState(v36, a2, v21);
  mlir::mps::Conv3DDataGradientOp::build(a1, (uint64_t)v36, *a3, *a4, *a5, *a6, *(uint64_t **)a7, (uint64_t)(*(_QWORD *)(a7 + 8) - *(_QWORD *)a7) >> 3, *(uint64_t **)a8, (uint64_t)(*(_QWORD *)(a8 + 8) - *(_QWORD *)a8) >> 3, *(uint64_t **)a9, (uint64_t)(*(_QWORD *)(a9 + 8) - *(_QWORD *)a9) >> 3, *a10, *a11, *a12);
  v23 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v36);
  if (!v23)
  {
    v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v27 = 662;
    v28 = "Casting.h";
    v29 = "dyn_cast";
    goto LABEL_8;
  }
  v24 = llvm::DefaultDoCastIfPossible<mlir::mps::Conv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v23);
  if (!v24)
  {
    v26 = "result && \"builder didn't return the right type\"";
    v27 = 497;
    v28 = "Builders.h";
    v29 = "create";
LABEL_8:
    __assert_rtn(v29, v28, v27, v26);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v36);
  return v24;
}

void sub_180E10950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

void sub_180E10968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x747065642E73706DLL
      && AttrData[1] == 0x6F635F6573697768
      && *(_QWORD *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.depthwise_conv_3d";
      v9[3] = 21;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x766E6F632E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x64325F766E6F632ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.conv_2d";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::BiasAddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BiasAddOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(_QWORD *)AttrData == 0x736169622E73706DLL && *(_DWORD *)(AttrData + 8) == 1684300127)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.bias_add";
      v8[3] = 12;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id)
  {
    return 0;
  }
  return result;
}

void llvm::SmallVectorImpl<int>::append<int const*,void>(uint64_t a1, _BYTE *__src, _BYTE *a3)
{
  size_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v13;
  unint64_t v14;

  if (__src == a3)
  {
    v7 = 0;
    v6 = 0;
    v9 = *(unsigned int *)(a1 + 8);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
    goto LABEL_12;
  }
  v6 = a3 - __src;
  v7 = (a3 - __src) >> 2;
  v8 = *(unsigned int *)(a1 + 8);
  v9 = v7 + v8;
  v10 = *(_QWORD *)a1;
  v11 = *(_QWORD *)a1 + 4 * v8;
  if (*(_QWORD *)a1 <= (unint64_t)__src && v11 > (unint64_t)__src)
  {
    if (v9 <= v8)
    {
      if (v10 + 4 * v9 <= (unint64_t)__src)
        goto LABEL_25;
    }
    else if (v9 > *(unsigned int *)(a1 + 12))
    {
      goto LABEL_25;
    }
  }
  v13 = (unint64_t)(a3 - 4);
  if (v10 <= (unint64_t)(a3 - 4) && v11 > v13)
  {
    if (v9 > v8)
    {
      if (v9 <= *(unsigned int *)(a1 + 12))
        goto LABEL_12;
LABEL_25:
      __assert_rtn("assertSafeToReferenceAfterResize", "SmallVector.h", 194, "isSafeToReferenceAfterResize(Elt, NewSize) && \"Attempting to reference an element of the vector in an operation \" \"that invalidates it\"");
    }
    if (v10 + 4 * v9 <= v13)
      goto LABEL_25;
  }
LABEL_12:
  if (v9 > *(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v9, 4);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
  }
  if (__src != a3)
  {
    memcpy((void *)(*(_QWORD *)a1 + 4 * v8), __src, v6);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
  }
  v14 = v7 + v8;
  if (v14 > *(unsigned int *)(a1 + 12))
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  *(_DWORD *)(a1 + 8) = v14;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v9;
  __int16 v10;
  uint64_t v11[4];
  __int16 v12;
  _QWORD v13[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v13[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v13);
    if (v4 == 35
      && *AttrData == 0x747065642E73706DLL
      && AttrData[1] == 0x6F635F6573697768
      && AttrData[2] == 0x61645F64335F766ELL
      && AttrData[3] == 0x69646172675F6174
      && *(_QWORD *)((char *)AttrData + 27) == 0x746E656964617267)
    {
      v12 = 1283;
      v11[0] = (uint64_t)"classof on '";
      v11[2] = (uint64_t)"mps.depthwise_conv_3d_data_gradient";
      v11[3] = 35;
      v9 = "' failed due to the operation not being registered";
      v10 = 259;
      llvm::operator+(v11, (uint64_t *)&v9, (uint64_t)v13);
      llvm::report_fatal_error((llvm::Twine *)v13, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v8;
  __int16 v9;
  uint64_t v10[4];
  __int16 v11;
  _QWORD v12[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 25
      && *(_QWORD *)AttrData == 0x766E6F632E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x617461645F64325FLL
      && *(_QWORD *)(AttrData + 16) == 0x6E6569646172675FLL
      && *(_BYTE *)(AttrData + 24) == 116)
    {
      v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"mps.conv_2d_data_gradient";
      v10[3] = 25;
      v8 = "' failed due to the operation not being registered";
      v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Conv3DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv3DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x766E6F632E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x64335F766E6F632ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.conv_3d";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Conv3DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv3DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v8;
  __int16 v9;
  uint64_t v10[4];
  __int16 v11;
  _QWORD v12[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 25
      && *(_QWORD *)AttrData == 0x766E6F632E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x617461645F64335FLL
      && *(_QWORD *)(AttrData + 16) == 0x6E6569646172675FLL
      && *(_BYTE *)(AttrData + 24) == 116)
    {
      v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"mps.conv_3d_data_gradient";
      v10[3] = 25;
      v8 = "' failed due to the operation not being registered";
      v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id)
  {
    return 0;
  }
  return result;
}

llvm::APFloatBase *std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100](llvm::APFloatBase *result)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  uint64_t v4;

  v1 = *(_QWORD *)result;
  *(_QWORD *)result = 0;
  if (v1)
  {
    v2 = *(_QWORD *)(v1 - 8);
    if (v2)
    {
      v3 = llvm::APFloatBase::PPCDoubleDouble(result);
      v4 = 32 * v2;
      do
      {
        while (v3 == *(void **)(v1 + v4 - 24))
        {
          std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100](v1 + v4 - 16, 0);
          v4 -= 32;
          if (!v4)
            goto LABEL_9;
        }
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)(v1 + v4 - 24));
        v4 -= 32;
      }
      while (v4);
    }
LABEL_9:
    JUMPOUT(0x186DA165CLL);
  }
  return result;
}

void llvm::SmallVectorImpl<long long>::append<long long const*,void>(uint64_t a1, _BYTE *__src, _BYTE *a3)
{
  size_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v13;
  unint64_t v14;

  if (__src == a3)
  {
    v7 = 0;
    v6 = 0;
    v9 = *(unsigned int *)(a1 + 8);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
    goto LABEL_12;
  }
  v6 = a3 - __src;
  v7 = (a3 - __src) >> 3;
  v8 = *(unsigned int *)(a1 + 8);
  v9 = v7 + v8;
  v10 = *(_QWORD *)a1;
  v11 = *(_QWORD *)a1 + 8 * v8;
  if (*(_QWORD *)a1 <= (unint64_t)__src && v11 > (unint64_t)__src)
  {
    if (v9 <= v8)
    {
      if (v10 + 8 * v9 <= (unint64_t)__src)
        goto LABEL_25;
    }
    else if (v9 > *(unsigned int *)(a1 + 12))
    {
      goto LABEL_25;
    }
  }
  v13 = (unint64_t)(a3 - 8);
  if (v10 <= (unint64_t)(a3 - 8) && v11 > v13)
  {
    if (v9 > v8)
    {
      if (v9 <= *(unsigned int *)(a1 + 12))
        goto LABEL_12;
LABEL_25:
      __assert_rtn("assertSafeToReferenceAfterResize", "SmallVector.h", 194, "isSafeToReferenceAfterResize(Elt, NewSize) && \"Attempting to reference an element of the vector in an operation \" \"that invalidates it\"");
    }
    if (v10 + 8 * v9 <= v13)
      goto LABEL_25;
  }
LABEL_12:
  if (v9 > *(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v9, 8);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
  }
  if (__src != a3)
  {
    memcpy((void *)(*(_QWORD *)a1 + 8 * v8), __src, v6);
    LODWORD(v8) = *(_DWORD *)(a1 + 8);
  }
  v14 = v7 + v8;
  if (v14 > *(unsigned int *)(a1 + 12))
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  *(_DWORD *)(a1 + 8) = v14;
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  char *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v14;
  uint64_t *v15;

  v6 = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__find_equal<std::string>(a1, a2, &v15, &v14, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = v6;
    v9 = (char *)operator new(0x50uLL);
    v7 = (uint64_t *)v9;
    if (*(char *)(a4 + 23) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v9 + 32), *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
    }
    else
    {
      *((_OWORD *)v9 + 2) = *(_OWORD *)a4;
      *((_QWORD *)v9 + 6) = *(_QWORD *)(a4 + 16);
    }
    std::vector<std::shared_ptr<MIL::IRArgument>>::vector(v7 + 7, a4 + 24);
    v10 = v15;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = (uint64_t)v10;
    *v8 = (uint64_t)v7;
    v11 = (uint64_t *)**a1;
    v12 = v7;
    if (v11)
    {
      *a1 = v11;
      v12 = (uint64_t *)*v8;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_180E114E4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E114F8(_Unwind_Exception *a1)
{
  char *v1;
  void **v2;

  if (v1[55] < 0)
    operator delete(*v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__find_equal<std::string>(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, const void **a5)
{
  uint64_t **v8;
  int v10;
  int v11;
  size_t v12;
  const void *v13;
  size_t v14;
  const void *v15;
  size_t v16;
  int v17;
  _BOOL4 v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  int v22;
  _BOOL4 v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  BOOL v27;
  int v28;
  int v29;
  size_t v30;
  const void *v31;
  size_t v32;
  const void *v33;
  size_t v34;
  int v35;
  _BOOL4 v36;
  uint64_t *v37;
  uint64_t **v38;
  _QWORD *v39;
  const void *v40;
  const void *v41;
  int v42;
  size_t v43;
  const void *v44;
  size_t v45;
  int v46;
  _BOOL4 v47;
  int v48;
  _BOOL4 v49;
  uint64_t *v50;
  int v51;
  size_t v52;
  uint64_t *v53;
  size_t v54;
  int v55;
  _BOOL4 v56;
  uint64_t *v57;
  uint64_t **v58;
  uint64_t **v59;
  _QWORD *v60;
  const void *v61;
  const void *v62;
  int v63;
  size_t v64;
  const void *v65;
  size_t v66;
  int v67;
  _BOOL4 v68;
  int v69;
  _BOOL4 v70;

  v8 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2)
    goto LABEL_20;
  v10 = *((char *)a2 + 55);
  v11 = *((char *)a5 + 23);
  if (v11 >= 0)
    v12 = *((unsigned __int8 *)a5 + 23);
  else
    v12 = (size_t)a5[1];
  if (v11 >= 0)
    v13 = a5;
  else
    v13 = *a5;
  if (v10 >= 0)
    v14 = *((unsigned __int8 *)a2 + 55);
  else
    v14 = a2[5];
  if (v10 >= 0)
    v15 = a2 + 4;
  else
    v15 = (const void *)a2[4];
  if (v14 >= v12)
    v16 = v12;
  else
    v16 = v14;
  v17 = memcmp(v13, v15, v16);
  v18 = v12 < v14;
  if (v17)
    v18 = v17 < 0;
  if (v18)
  {
LABEL_20:
    v19 = (uint64_t *)*a2;
    if (*a1 == a2)
    {
      v21 = a2;
LABEL_53:
      if (v19)
      {
        *a3 = v21;
        return v21 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v19)
    {
      v20 = (uint64_t *)*a2;
      do
      {
        v21 = v20;
        v20 = (uint64_t *)v20[1];
      }
      while (v20);
    }
    else
    {
      v26 = a2;
      do
      {
        v21 = (uint64_t *)v26[2];
        v27 = *v21 == (_QWORD)v26;
        v26 = v21;
      }
      while (v27);
    }
    v28 = *((char *)a5 + 23);
    v29 = *((char *)v21 + 55);
    if (v29 >= 0)
      v30 = *((unsigned __int8 *)v21 + 55);
    else
      v30 = v21[5];
    if (v29 >= 0)
      v31 = v21 + 4;
    else
      v31 = (const void *)v21[4];
    if (v28 >= 0)
      v32 = *((unsigned __int8 *)a5 + 23);
    else
      v32 = (size_t)a5[1];
    if (v28 >= 0)
      v33 = a5;
    else
      v33 = *a5;
    if (v32 >= v30)
      v34 = v30;
    else
      v34 = v32;
    v35 = memcmp(v31, v33, v34);
    v36 = v30 < v32;
    if (v35)
      v36 = v35 < 0;
    if (v36)
      goto LABEL_53;
    v37 = *v8;
    if (*v8)
    {
      do
      {
        while (1)
        {
          v38 = (uint64_t **)v37;
          v41 = (const void *)v37[4];
          v39 = v37 + 4;
          v40 = v41;
          v42 = *((char *)v39 + 23);
          if (v42 >= 0)
            v43 = *((unsigned __int8 *)v39 + 23);
          else
            v43 = v39[1];
          if (v42 >= 0)
            v44 = v39;
          else
            v44 = v40;
          if (v43 >= v32)
            v45 = v32;
          else
            v45 = v43;
          v46 = memcmp(v33, v44, v45);
          v47 = v32 < v43;
          if (v46)
            v47 = v46 < 0;
          if (!v47)
            break;
          v37 = *v38;
          v8 = v38;
          if (!*v38)
            goto LABEL_74;
        }
        v48 = memcmp(v44, v33, v45);
        v49 = v43 < v32;
        if (v48)
          v49 = v48 < 0;
        if (!v49)
          break;
        v8 = v38 + 1;
        v37 = v38[1];
      }
      while (v37);
    }
    else
    {
      v38 = v8;
    }
LABEL_74:
    *a3 = (uint64_t *)v38;
    return (uint64_t *)v8;
  }
  v22 = memcmp(v15, v13, v16);
  v23 = v14 < v12;
  if (v22)
    v23 = v22 < 0;
  if (!v23)
  {
    *a3 = a2;
    *a4 = a2;
    return (uint64_t *)a4;
  }
  v24 = a2[1];
  if (v24)
  {
    v25 = (uint64_t *)a2[1];
    do
    {
      a4 = (uint64_t **)v25;
      v25 = (uint64_t *)*v25;
    }
    while (v25);
  }
  else
  {
    v50 = a2;
    do
    {
      a4 = (uint64_t **)v50[2];
      v27 = *a4 == v50;
      v50 = (uint64_t *)a4;
    }
    while (!v27);
  }
  if (a4 != v8)
  {
    v51 = *((char *)a4 + 55);
    if (v51 >= 0)
      v52 = *((unsigned __int8 *)a4 + 55);
    else
      v52 = (size_t)a4[5];
    if (v51 >= 0)
      v53 = (uint64_t *)(a4 + 4);
    else
      v53 = a4[4];
    if (v52 >= v12)
      v54 = v12;
    else
      v54 = v52;
    v55 = memcmp(v13, v53, v54);
    v56 = v12 < v52;
    if (v55)
      v56 = v55 < 0;
    if (!v56)
    {
      v57 = *v8;
      if (*v8)
      {
        v58 = a3;
        do
        {
          while (1)
          {
            v59 = (uint64_t **)v57;
            v62 = (const void *)v57[4];
            v60 = v57 + 4;
            v61 = v62;
            v63 = *((char *)v60 + 23);
            if (v63 >= 0)
              v64 = *((unsigned __int8 *)v60 + 23);
            else
              v64 = v60[1];
            if (v63 >= 0)
              v65 = v60;
            else
              v65 = v61;
            if (v64 >= v12)
              v66 = v12;
            else
              v66 = v64;
            v67 = memcmp(v13, v65, v66);
            v68 = v12 < v64;
            if (v67)
              v68 = v67 < 0;
            if (!v68)
              break;
            v57 = *v59;
            v8 = v59;
            if (!*v59)
              goto LABEL_119;
          }
          v69 = memcmp(v65, v13, v66);
          v70 = v64 < v12;
          if (v69)
            v70 = v69 < 0;
          if (!v70)
            break;
          v8 = v59 + 1;
          v57 = v59[1];
        }
        while (v57);
      }
      else
      {
        v59 = v8;
        v58 = a3;
      }
LABEL_119:
      *v58 = (uint64_t *)v59;
      return (uint64_t *)v8;
    }
  }
  if (v24)
  {
    *a3 = (uint64_t *)a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return (uint64_t *)a4;
}

_QWORD *std::vector<std::shared_ptr<MIL::IRArgument>>::vector(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v3 = *(_QWORD **)a2;
  v4 = *(_QWORD **)(a2 + 8);
  v5 = (uint64_t)v4 - *(_QWORD *)a2;
  if (v4 != *(_QWORD **)a2)
  {
    if (v5 < 0)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v6 = operator new((size_t)v4 - *(_QWORD *)a2);
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[2 * (v5 >> 4)];
    do
    {
      v7 = v3[1];
      *v6 = *v3;
      v6[1] = v7;
      if (v7)
      {
        v8 = (unint64_t *)(v7 + 8);
        do
          v9 = __ldxr(v8);
        while (__stxr(v9 + 1, v8));
      }
      v3 += 2;
      v6 += 2;
    }
    while (v3 != v4);
    a1[1] = v6;
  }
  return a1;
}

void sub_180E119BC(_Unwind_Exception *exception_object)
{
  void **v1;
  char *v3;
  char *v4;
  void *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  v3 = (char *)*v1;
  if (*v1)
  {
    v4 = (char *)v1[1];
    v5 = *v1;
    if (v4 != v3)
    {
      do
      {
        v6 = (std::__shared_weak_count *)*((_QWORD *)v4 - 1);
        if (v6)
        {
          p_shared_owners = (unint64_t *)&v6->__shared_owners_;
          do
            v8 = __ldaxr(p_shared_owners);
          while (__stlxr(v8 - 1, p_shared_owners));
          if (!v8)
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }
        v4 -= 16;
      }
      while (v4 != v3);
      v5 = *v1;
    }
    v1[1] = v3;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(uint64_t a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(a1, *((_QWORD *)a2 + 1));
    v4 = *((_QWORD *)a2 + 7);
    if (v4)
    {
      v5 = *((_QWORD *)a2 + 8);
      v6 = (void *)*((_QWORD *)a2 + 7);
      if (v5 != v4)
      {
        do
        {
          v7 = *(std::__shared_weak_count **)(v5 - 8);
          if (v7)
          {
            p_shared_owners = (unint64_t *)&v7->__shared_owners_;
            do
              v9 = __ldaxr(p_shared_owners);
            while (__stlxr(v9 - 1, p_shared_owners));
            if (!v9)
            {
              ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
              std::__shared_weak_count::__release_weak(v7);
            }
          }
          v5 -= 16;
        }
        while (v5 != v4);
        v6 = (void *)*((_QWORD *)a2 + 7);
      }
      *((_QWORD *)a2 + 8) = v4;
      operator delete(v6);
    }
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

std::runtime_error *std::range_error::range_error[abi:ne180100](std::runtime_error *a1)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, "index out of bounds");
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
  return result;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x747361632E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.cast";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684300078)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.add";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    return 0;
  }
  return result;
}

llvm::APFloatBase *std::complex<llvm::APFloat>::complex[abi:ne180100](llvm::APFloatBase *a1, uint64_t a2, uint64_t a3)
{
  llvm::detail::DoubleAPFloat *v5;
  const llvm::detail::DoubleAPFloat *v6;
  void *v7;
  void *v8;
  llvm::detail::DoubleAPFloat *v9;
  const llvm::detail::DoubleAPFloat *v10;
  void *v11;
  void *v12;

  v5 = (llvm::APFloatBase *)((char *)a1 + 8);
  v6 = (const llvm::detail::DoubleAPFloat *)(a2 + 8);
  v7 = *(void **)(a2 + 8);
  v8 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v8 == v7)
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v5, v6);
    v9 = (llvm::APFloatBase *)((char *)a1 + 40);
    v12 = *(void **)(a3 + 8);
    v10 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
    if (v8 != v12)
      goto LABEL_3;
LABEL_5:
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v9, v10);
    return a1;
  }
  llvm::detail::IEEEFloat::IEEEFloat(v5, v6);
  v9 = (llvm::APFloatBase *)((char *)a1 + 40);
  v11 = *(void **)(a3 + 8);
  v10 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
  if (v8 == v11)
    goto LABEL_5;
LABEL_3:
  llvm::detail::IEEEFloat::IEEEFloat(v9, v10);
  return a1;
}

void sub_180E11DA8(_Unwind_Exception *a1)
{
  uint64_t v1;
  llvm::detail::IEEEFloat *v2;
  uint64_t v3;

  if (v3 == *(_QWORD *)v2)
  {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)(v1 + 16));
    _Unwind_Resume(a1);
  }
  llvm::detail::IEEEFloat::~IEEEFloat(v2);
  _Unwind_Resume(a1);
}

_QWORD *std::complex<llvm::APFloat>::~complex(_QWORD *a1)
{
  llvm::detail::IEEEFloat *v2;
  void *v3;
  void *v4;
  llvm::detail::IEEEFloat *v5;

  v2 = (llvm::detail::IEEEFloat *)(a1 + 5);
  v3 = (void *)a1[5];
  v4 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v4 == v3)
  {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)(a1 + 6));
    v5 = (llvm::detail::IEEEFloat *)(a1 + 1);
    if (v4 != (void *)a1[1])
      goto LABEL_3;
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat(v2);
    v5 = (llvm::detail::IEEEFloat *)(a1 + 1);
    if (v4 != (void *)a1[1])
    {
LABEL_3:
      llvm::detail::IEEEFloat::~IEEEFloat(v5);
      return a1;
    }
  }
  std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)(a1 + 2));
  return a1;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PadOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PadOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684107310)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.pad";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(_QWORD *)AttrData == 0x746C756D2E73706DLL && *(_DWORD *)(AttrData + 8) == 2037149801)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.multiply";
      v8[3] = 12;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::FloorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::FloorOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x6F6F6C662E73706DLL && *(_BYTE *)(AttrData + 8) == 114)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.floor";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::FloorOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ResizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(_QWORD *)AttrData == 0x697365722E73706DLL && *(_WORD *)(AttrData + 8) == 25978)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.resize";
      v8[3] = 10;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReciprocalOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReciprocalOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x696365722E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x6C61636F72706963)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.reciprocal";
      v8[3] = 14;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LogarithmOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LogarithmOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 13 && *AttrData == 0x61676F6C2E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x6D6874697261676FLL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.logarithm";
      v8[3] = 13;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LogarithmOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReciprocalSquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReciprocalSquareRootOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v8;
  __int16 v9;
  uint64_t v10[4];
  __int16 v11;
  _QWORD v12[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 26
      && *(_QWORD *)AttrData == 0x696365722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x735F6C61636F7270
      && *(_QWORD *)(AttrData + 16) == 0x6F725F6572617571
      && *(_WORD *)(AttrData + 24) == 29807)
    {
      v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"mps.reciprocal_square_root";
      v10[3] = 26;
      v8 = "' failed due to the operation not being registered";
      v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SubtractOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SubtractOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(_QWORD *)AttrData == 0x746275732E73706DLL && *(_DWORD *)(AttrData + 8) == 1952670066)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.subtract";
      v8[3] = 12;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DivideOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DivideOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(_QWORD *)AttrData == 0x697669642E73706DLL && *(_WORD *)(AttrData + 8) == 25956)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.divide";
      v8[3] = 10;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CeilOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CeilOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6C6965632E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.ceil";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CeilOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::InitRandomPhiloxStateOp,mlir::Operation *,llvm::CastInfo<mlir::mps::InitRandomPhiloxStateOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v8;
  __int16 v9;
  uint64_t v10[4];
  __int16 v11;
  _QWORD v12[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v12[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v12);
    if (v4 == 28
      && *(_QWORD *)AttrData == 0x74696E692E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x5F6D6F646E61725FLL
      && *(_QWORD *)(AttrData + 16) == 0x735F786F6C696870
      && *(_DWORD *)(AttrData + 24) == 1702125940)
    {
      v11 = 1283;
      v10[0] = (uint64_t)"classof on '";
      v10[2] = (uint64_t)"mps.init_random_philox_state";
      v10[3] = 28;
      v8 = "' failed due to the operation not being registered";
      v9 = 259;
      llvm::operator+(v10, (uint64_t *)&v8, (uint64_t)v12);
      llvm::report_fatal_error((llvm::Twine *)v12, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::InitRandomPhiloxStateOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::RandomUniformOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RandomUniformOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x646E61722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x6F66696E755F6D6FLL
      && *(_WORD *)(AttrData + 16) == 28018)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.random_uniform";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::RandomUniformOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LessThanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LessThanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x7373656C2E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.less";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LessThanOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(_QWORD *)AttrData == 0x656C65732E73706DLL && *(_WORD *)(AttrData + 8) == 29795)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.select";
      v8[3] = 10;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::RandomNormalOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RandomNormalOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(_QWORD *)AttrData == 0x646E61722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x616D726F6E5F6D6FLL
      && *(_BYTE *)(AttrData + 16) == 108)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.random_normal";
      v9[3] = 17;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::RandomNormalOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReverseOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReverseOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x657665722E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x657372657665722ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.reverse";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReverseOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::NegativeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NegativeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(_QWORD *)AttrData == 0x6167656E2E73706DLL && *(_DWORD *)(AttrData + 8) == 1702259060)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.negative";
      v8[3] = 12;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::NegativeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TopKOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TopKOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x5F706F742E73706DLL && *(_BYTE *)(AttrData + 8) == 107)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.top_k";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TopKOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CropResizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CropResizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x706F72632E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x657A697365725F70)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.crop_resize";
      v8[3] = 15;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x757165642E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x657A69746E617571)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.dequantize";
      v8[3] = 14;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeLUTOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeLUTOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x757165642E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x6C5F657A69746E61
      && *(_WORD *)(AttrData + 16) == 29813)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.dequantize_lut";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::QuantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::QuantizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(_QWORD *)AttrData == 0x6E6175712E73706DLL && *(_DWORD *)(AttrData + 8) == 1702521204)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.quantize";
      v8[3] = 12;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMinOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(_QWORD *)AttrData == 0x756465722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x696D5F6E6F697463
      && *(_BYTE *)(AttrData + 16) == 110)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_min";
      v9[3] = 17;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMinOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMaxOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(_QWORD *)AttrData == 0x756465722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x616D5F6E6F697463
      && *(_BYTE *)(AttrData + 16) == 120)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_max";
      v9[3] = 17;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::AbsoluteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AbsoluteOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 12 && *(_QWORD *)AttrData == 0x6F7362612E73706DLL && *(_DWORD *)(AttrData + 8) == 1702131052)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.absolute";
      v8[3] = 12;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x616572672E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x726574616572672ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.greater";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::MaximumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MaximumOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x6978616D2E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6D756D6978616D2ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.maximum";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::MaximumOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::MinimumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MinimumOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x696E696D2E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6D756D696E696D2ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.minimum";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::MinimumOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::RoundOp,mlir::Operation *,llvm::CastInfo<mlir::mps::RoundOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x6E756F722E73706DLL && *(_BYTE *)(AttrData + 8) == 100)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.round";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::RoundOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ClampOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ClampOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x6D616C632E73706DLL && *(_BYTE *)(AttrData + 8) == 112)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.clamp";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ClampOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::BatchToSpaceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BatchToSpaceOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x637461622E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x6170735F6F745F68
      && *(_WORD *)(AttrData + 16) == 25955)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.batch_to_space";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::BatchToSpaceOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SpaceToBatchOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SpaceToBatchOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x636170732E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x7461625F6F745F65
      && *(_WORD *)(AttrData + 16) == 26723)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.space_to_batch";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SpaceToBatchOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SampleGridOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SampleGridOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x706D61732E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x646972675F656C70)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.sample_grid";
      v8[3] = 15;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SampleGridOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SortOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SortOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x74726F732E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.sort";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SortOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DimensionSizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DimensionSizeOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x656D69642E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x69735F6E6F69736ELL
      && *(_WORD *)(AttrData + 16) == 25978)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.dimension_size";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DimensionSizeOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SoftmaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SoftmaxOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x74666F732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x78616D74666F732ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.softmax";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id)
  {
    return 0;
  }
  return result;
}

void ___ZN3GPU19EncodeCPUWorkHelper6encodeEPNS_16EncodeDescriptorENSt3__18functionIFvvEEE_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  id v5;

  v3 = a2;
  v4 = *(_QWORD *)(a1 + 56);
  v5 = v3;
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 48))(v4);
  objc_msgSend(v5, "setSignaledValue:", *(_QWORD *)(a1 + 64));

}

void sub_180E14040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c27_ZTSNSt3__18functionIFvvEEE(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)(a2 + 56);
  if (result)
  {
    if (result == a2 + 32)
    {
      *(_QWORD *)(a1 + 56) = a1 + 32;
      return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 56) + 24))(*(_QWORD *)(a2 + 56), a1 + 32);
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
      *(_QWORD *)(a1 + 56) = result;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 56) = 0;
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_32c27_ZTSNSt3__18functionIFvvEEE(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 + 32;
  result = *(_QWORD *)(a1 + 56);
  if (result == v1)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

GPU::BaseOpHandler *GPU::BaseOpHandler::BaseOpHandler(GPU::BaseOpHandler *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  const char *v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  void *v19;
  BOOL v20;
  uint64_t AttrData;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  uint64_t NextResultAtOffset;
  uint64_t v30;
  uint64_t **v31;
  uint64_t InterfaceFor;
  _QWORD *ArgAttrsAttr;
  uint64_t v34;
  uint64_t v35;
  char v36;
  void *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v42;
  const char *v43;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  const char *v48;
  char *v49;
  const char *v50;
  __int16 v51;
  uint64_t v52[4];
  __int16 v53;
  uint64_t **v54;
  uint64_t v55;

  *(_QWORD *)this = &off_1E0E1AF78;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = a3;
  *((_QWORD *)this + 4) = a4;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 10) = 0;
  v49 = (char *)this + 112;
  *((_QWORD *)this + 11) = (char *)this + 112;
  v5 = (_QWORD *)((char *)this + 88);
  *((_OWORD *)this + 6) = xmmword_181233120;
  if ((*((_BYTE *)a3 + 46) & 0x80) == 0 || (v6 = *((unsigned int *)a3 + 17), !(_DWORD)v6))
  {
    v9 = 1;
    v17 = *((_DWORD *)a3 + 9);
    if (!v17)
      goto LABEL_22;
LABEL_19:
    v18 = *((_QWORD *)a3 + 6);
    v19 = *(void **)(v18 + 16);
    if (v19 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v54 = *(uint64_t ***)(v18 + 8);
      AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v54);
      if (v22 == 12 && *(_QWORD *)AttrData == 0x736E6F632E73706DLL && *(_DWORD *)(AttrData + 8) == 1953390964)
      {
        v53 = 1283;
        v52[0] = (uint64_t)"classof on '";
        v52[2] = (uint64_t)"mps.constant";
        v52[3] = 12;
        v50 = "' failed due to the operation not being registered";
        v51 = 259;
        llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)&v54);
        llvm::report_fatal_error((llvm::Twine *)&v54, 1);
      }
      v20 = 1;
    }
    else
    {
      v20 = v19 != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id;
    }
    v24 = *((_QWORD *)this + 3);
    v25 = *(unsigned int *)(v24 + 36);
    *((_BYTE *)this + 57) = v20;
    if ((_DWORD)v25)
      v26 = v24 - 16;
    else
      v26 = 0;
    if (!(_DWORD)v25)
    {
      LOBYTE(v17) = 0;
      goto LABEL_52;
    }
    v27 = 0;
    v28 = 1;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v26, v27);
      v30 = *(_QWORD *)(NextResultAtOffset + 8);
      v31 = (uint64_t **)(v30 & 0xFFFFFFFFFFFFFFF8);
      if ((v30 & 0xFFFFFFFFFFFFFFF8) == 0)
      {
        v45 = 650;
        v46 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
        v47 = "Casting.h";
        v48 = "dyn_cast";
        goto LABEL_69;
      }
      if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v30 & 0xFFFFFFFFFFFFFFF8)))
      {
        InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v31);
        if (!InterfaceFor)
        {
          v45 = 98;
          v48 = "Interface";
          v47 = "InterfaceSupport.h";
          v46 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
LABEL_69:
          __assert_rtn(v48, v47, v45, v46);
        }
        v54 = v31;
        v55 = InterfaceFor;
        if (v31)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v54))
            goto LABEL_47;
          ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v54);
          if (v34)
          {
            v35 = 8 * v34;
            while (*ArgAttrsAttr != 0x8000000000000000)
            {
              ++ArgAttrsAttr;
              v35 -= 8;
              if (!v35)
                goto LABEL_48;
            }
LABEL_47:
            v28 = 0;
          }
        }
      }
      else
      {
        v54 = 0;
        v55 = 0;
      }
LABEL_48:
      if (!GPURegionRuntime::isSmallIntType(*((_QWORD *)this + 2), (uint64_t **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), 1))*((_BYTE *)this + 57) = 0;
      if (++v27 == v25)
      {
        LOBYTE(v17) = *(_DWORD *)(*((_QWORD *)this + 3) + 36) != 0;
        goto LABEL_53;
      }
    }
  }
  v7 = 0;
  v8 = *((_QWORD *)a3 + 9);
  v9 = 1;
  v10 = "dyn_cast";
  do
  {
    v11 = *(_QWORD *)(*(_QWORD *)(v8 + 32 * v7 + 24) + 8);
    v12 = (uint64_t **)(v11 & 0xFFFFFFFFFFFFFFF8);
    if ((v11 & 0xFFFFFFFFFFFFFFF8) == 0)
    {
      v42 = 650;
      v43 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v44 = "Casting.h";
      goto LABEL_66;
    }
    if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v11 & 0xFFFFFFFFFFFFFFF8)))
    {
      v13 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v12);
      if (!v13)
      {
        v42 = 98;
        v10 = "Interface";
        v44 = "InterfaceSupport.h";
        v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
LABEL_66:
        __assert_rtn(v10, v44, v42, v43);
      }
      v54 = v12;
      v55 = v13;
      if (v12)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v54))
          goto LABEL_4;
        v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v54);
        if (v15)
        {
          v16 = 8 * v15;
          while (*v14 != 0x8000000000000000)
          {
            ++v14;
            v16 -= 8;
            if (!v16)
              goto LABEL_5;
          }
LABEL_4:
          v9 = 0;
        }
      }
    }
    else
    {
      v54 = 0;
      v55 = 0;
    }
LABEL_5:
    ++v7;
  }
  while (v7 != v6);
  a3 = (mlir::Operation *)*((_QWORD *)this + 3);
  v17 = *((_DWORD *)a3 + 9);
  if (v17)
    goto LABEL_19;
LABEL_22:
  *((_BYTE *)this + 57) = 0;
LABEL_52:
  v28 = 1;
LABEL_53:
  v36 = v9 & v28 & 1;
  *((_BYTE *)this + 40) = v36;
  *((_BYTE *)this + 56) = v17 & (v28 ^ 1);
  *((_BYTE *)this + 41) = v36;
  v37 = (void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;

  *((_QWORD *)this + 9) = 0;
  v38 = *(unsigned int *)(*((_QWORD *)this + 3) + 36);
  v39 = *((_QWORD *)this + 12);
  if (v39 != v38)
  {
    v40 = *((_QWORD *)this + 13);
    if (v39 > v38)
    {
      if (v40 >= v38)
        goto LABEL_56;
LABEL_63:
      __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
    }
    if (v40 < v38)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v5, v49, *(unsigned int *)(*((_QWORD *)this + 3) + 36), 1);
      v39 = *((_QWORD *)this + 12);
    }
    if (v38 != v39)
      bzero((void *)(*v5 + v39), v38 - v39);
    if (*((_QWORD *)this + 13) < v38)
      goto LABEL_63;
LABEL_56:
    *((_QWORD *)this + 12) = v38;
  }
  return this;
}

void sub_180E14568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  uint64_t v9;
  void **v10;
  id *v12;

  if (*v10 != a9)
    free(*v10);
  v12 = *(id **)(v9 + 80);
  *(_QWORD *)(v9 + 80) = 0;
  if (v12)
  {

    MEMORY[0x186DA1680](v12, 0x1080C40CC6EE3FDLL);
  }

  _Unwind_Resume(a1);
}

void GPU::BaseOpHandler::encodeOp(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t NextResultAtOffset;
  void *v10;
  id v11;

  GPU::BaseOpHandler::_inferJITOutputTypes((uint64_t)this, a2);
  v4 = *((_QWORD *)this + 3);
  v5 = *(unsigned int *)(v4 + 36);
  v6 = v4 - 16;
  if ((_DWORD)v5)
    v7 = v6;
  else
    v7 = 0;
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", v5);
  v11 = (id)objc_claimAutoreleasedReturnValue();
  if ((_DWORD)v5)
  {
    for (i = 0; i != v5; ++i)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, i);
      (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2), NextResultAtOffset, *((_QWORD *)a2 + 1), 0, 0, 1);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "addObject:", v10);

    }
  }
  (*(void (**)(GPU::BaseOpHandler *, GPU::EncodeDescriptor *, id))(*(_QWORD *)this + 16))(this, a2, v11);

}

void sub_180E146D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_180E146E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_180E14700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_180E14714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t GPU::BaseOpHandler::_inferJITOutputTypes(uint64_t this, GPU::EncodeDescriptor *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t NextResultAtOffset;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char v18;
  _QWORD *v19;
  uint64_t DefiningOp;
  uint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _BYTE *v28;
  uint64_t *v29;
  char *v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _OWORD *v37;
  char *v38;
  uint64_t v39;
  __int128 v40;
  mlir::GenericProgramPoint *v41;
  mlir::Operation *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  char *v46;
  llvm *v47[2];
  int v48;
  llvm *v49;
  uint64_t v50;
  int v51;
  llvm *v52;
  uint64_t v53;
  int v54;
  uint64_t *v55[2];
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  _QWORD *v59[2];

  if (!*(_BYTE *)(this + 40))
  {
    v2 = (_QWORD *)this;
    v3 = *(_QWORD *)(this + 24);
    v4 = *(unsigned int *)(v3 + 36);
    if ((_DWORD)v4)
    {
      v6 = 0;
      v7 = v3 - 16;
      while (1)
      {
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, v6);
        this = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v2[2] + 448) + 24))(*(_QWORD *)(v2[2] + 448), NextResultAtOffset);
        if ((this & 1) == 0)
        {
          this = isStaticMPSType((uint64_t **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
          if (!(_DWORD)this)
            break;
        }
        if (v4 == ++v6)
          return this;
      }
      v9 = (_QWORD *)v2[3];
      v56 = 0;
      v57 = 0;
      v55[0] = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)(v9 + 3));
      v55[1] = 0;
      v10 = v9[2];
      mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)v9);
      v56 = v10;
      v57 = v11;
      v47[0] = 0;
      v47[1] = 0;
      v48 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v53 = 0;
      v54 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v12 = v2[3];
      if ((*(_BYTE *)(v12 + 46) & 0x80) == 0)
      {
LABEL_47:
        v41 = mlir::OpBuilder::clone(v55, (mlir::Operation *)v12, (mlir::IRMapping *)v47);
        if (mlir::mps::inferTypes(v41, v42))
          mlir::verify(v41, (mlir::Operation *)1);
        __assert_rtn("_inferJITOutputTypes", "GPUBaseOps.mm", 339, "0 && \"failed to infer output types\"");
      }
      v13 = 0;
      v14 = 0;
      while (1)
      {
        if (v14 >= *(unsigned int *)(v12 + 68))
          goto LABEL_47;
        v16 = *(_QWORD *)(*(_QWORD *)(v12 + 72) + 32 * v14 + 24);
        v58 = v16;
        v59[0] = 0;
        if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v47, &v58, v59) & 1) == 0)
        {
          v17 = (*(uint64_t (**)(_QWORD *, GPU::EncodeDescriptor *, uint64_t **, unint64_t))(*v2 + 48))(v2, a2, v55, v14);
          v43 = v17;
          v58 = v16;
          v59[0] = 0;
          v18 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)v47, &v58, v59);
          v19 = v59[0];
          if ((v18 & 1) == 0)
          {
            v19 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v47, (uint64_t)&v58, &v58, v59[0]);
            *v19 = v58;
            v19[1] = 0;
          }
          v19[1] = v17;
          if (v16 != v43)
          {
            if (mlir::Value::getDefiningOp((mlir::Value *)&v43))
              break;
          }
        }
LABEL_12:
        ++v14;
        v12 = v2[3];
        if ((*(_BYTE *)(v12 + 46) & 0x80) == 0)
          goto LABEL_47;
      }
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v43);
      v21 = DefiningOp;
      if (v13 < v46)
      {
        *(_QWORD *)v13 = DefiningOp;
        v15 = (uint64_t)(v13 + 8);
        goto LABEL_11;
      }
      v22 = (char *)v44;
      v23 = (char *)(v13 - (char *)v44);
      v24 = (v13 - (char *)v44) >> 3;
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      v26 = v46 - (char *)v44;
      if ((v46 - (char *)v44) >> 2 > v25)
        v25 = v26 >> 2;
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
        v27 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v27 = v25;
      if (v27)
      {
        if (v27 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v28 = operator new(8 * v27);
        v29 = (uint64_t *)&v28[8 * v24];
        *v29 = v21;
        v15 = (uint64_t)(v29 + 1);
        v30 = (char *)(v13 - v22);
        if (v13 == v22)
        {
LABEL_29:
          v44 = v29;
          v45 = v15;
          v46 = &v28[8 * v27];
          if (!v13)
            goto LABEL_11;
          goto LABEL_36;
        }
      }
      else
      {
        v28 = 0;
        v29 = (uint64_t *)(8 * v24);
        *(_QWORD *)(8 * v24) = v21;
        v15 = 8 * v24 + 8;
        v30 = (char *)(v13 - v22);
        if (v13 == v22)
          goto LABEL_29;
      }
      v31 = (unint64_t)(v30 - 8);
      if (v31 >= 0x168)
      {
        v34 = (v13 - 8 - v22) & 0xFFFFFFFFFFFFFFF8;
        if (&v23[(_QWORD)v28 - 8 - v34] > &v23[(_QWORD)v28 - 8])
        {
          v32 = v13;
        }
        else if (&v13[-v34 - 8] > v13 - 8)
        {
          v32 = v13;
        }
        else if ((unint64_t)(v13 - v28 - (_QWORD)v23) >= 0x20)
        {
          v35 = (v31 >> 3) + 1;
          v36 = 8 * (v35 & 0x3FFFFFFFFFFFFFFCLL);
          v32 = &v13[-v36];
          v29 = (uint64_t *)((char *)v29 - v36);
          v37 = &v28[8 * v24 - 16];
          v38 = v13 - 16;
          v39 = v35 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v40 = *(_OWORD *)v38;
            *(v37 - 1) = *((_OWORD *)v38 - 1);
            *v37 = v40;
            v37 -= 2;
            v38 -= 32;
            v39 -= 4;
          }
          while (v39);
          if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_35:
            v13 = (char *)v44;
            v44 = v29;
            v45 = v15;
            v46 = &v28[8 * v27];
            if (v13)
LABEL_36:
              operator delete(v13);
LABEL_11:
            v45 = v15;
            v13 = (char *)v15;
            goto LABEL_12;
          }
        }
        else
        {
          v32 = v13;
        }
      }
      else
      {
        v32 = v13;
      }
      do
      {
        v33 = *((_QWORD *)v32 - 1);
        v32 -= 8;
        *--v29 = v33;
      }
      while (v32 != v22);
      goto LABEL_35;
    }
  }
  return this;
}

void sub_180E14DFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, llvm *a13)
{
  if (__p)
    operator delete(__p);
  mlir::IRMapping::~IRMapping(&a13);
}

void sub_180E14E50()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void GPU::BaseOpHandler::encodeConstantOp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t *v8;
  MPSGraphTensorData *v9;
  _QWORD *Type;
  uint64_t MPSDataType;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  id v15;
  id v16;
  void *v17;
  _BOOL4 v18;
  void *v19;
  uint64_t **v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  int v25;
  uint64_t NumElements;
  uint64_t ElementDataSize;
  void *v28;
  void *v29;
  unint64_t v30;
  void *v31;
  uint64_t v32;
  int v33;
  id v34;
  BOOL v35;
  int v36;
  int64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  unint64_t v41;
  unint64_t v42;
  size_t v43;
  int v44;
  _WORD *v45;
  char *v46;
  char *v47;
  int v48;
  uint64_t v49;
  char v50;
  void *v51;
  void *v52;
  size_t v53;
  void *v54;
  char v55;
  char v56;
  void *v57;
  void *v58;
  id v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  uint64_t *v70;
  void *v71;
  void *v72;
  void **v73;
  id v74;
  id v75;
  void *v76;
  uint64_t v77;
  void *v78;
  id *v79;
  id v80;
  _QWORD *v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  void *v87;
  void *v88;
  void *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  size_t v97;
  _QWORD *v98;
  id v99;
  void *v100;
  void *v101;
  _BOOL4 v102;
  id v103;
  void *v104;
  void *v105;
  void *v106;
  uint64_t v107;
  void *v108;
  MPSGraphTensorData *v109;
  unsigned int v110;
  size_t __n;
  void *__na;
  id v113;
  MPSGraphTensorData *v114;
  uint64_t *v115;
  void *v117;
  _QWORD v119[4];
  char v120;
  void *v121[5];
  void *__src;
  unsigned __int8 v123;
  unsigned __int8 v124;
  _QWORD v125[2];
  uint64_t v126;
  uint64_t v127;
  void *v128;
  _QWORD v129[3];
  _QWORD *v130;
  void *v131;
  _QWORD __pattern4[4];
  _BYTE v133[24];
  _BYTE *v134;
  uint64_t v135;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  v125[0] = a3;
  v125[1] = a4;
  v5 = *(_QWORD *)(a1 + 24);
  if (!*(_DWORD *)(v5 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v8 = (uint64_t *)(v5 - 16);
  v9 = (MPSGraphTensorData *)*(id *)(a1 + 48);
  if (!v9)
  {
    v115 = v8;
    if (!a3 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    mlir::mps::CPUNDArray::CPUNDArray(v121, v125[0]);
    Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v125);
    MPSDataType = getMPSDataType(Type);
    v12 = *(_QWORD *)(a1 + 16);
    __pattern4[0] = v8;
    v127 = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)__pattern4) + 2);
    v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v12 + 88), &v127);
    if (v13
      && (v126 = __pattern4[0],
          (v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v13 + 3, &v126)) != 0))
    {
      v15 = (id)v14[3];
    }
    else
    {
      v15 = 0;
    }
    objc_msgSend(v15, "mpsndarray");
    v16 = (id)objc_claimAutoreleasedReturnValue();
    v114 = (MPSGraphTensorData *)v15;
    if (v16
      && (objc_msgSend(v16, "buffer"),
          v17 = (void *)objc_claimAutoreleasedReturnValue(),
          v18 = objc_msgSend(v17, "storageMode") == 2,
          v17,
          !v18))
    {
      v33 = 1;
      v32 = (uint64_t)v16;
      v9 = v114;
      v117 = v16;
      if (*(_QWORD *)(a1 + 96))
        goto LABEL_19;
    }
    else
    {
      v19 = (void *)MEMORY[0x1E0CC6FE0];
      v20 = (uint64_t **)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v125);
      getMPSShapeFromMLIR(v20);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      adaptForMPS(v21);
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v19, "descriptorWithDataType:shape:", MPSDataType, v22);
      v23 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v23, "setPreferPackedRows:", 1);
      if (v124 | v123
        || mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v121) < 1
        || (objc_msgSend(*(id *)(a2 + 8), "device"),
            v24 = (void *)objc_claimAutoreleasedReturnValue(),
            v25 = objc_msgSend(v24, "hasUnifiedMemory"),
            v24,
            !v25))
      {
        v34 = objc_alloc(MEMORY[0x1E0CC6F50]);
        objc_msgSend(*(id *)(a2 + 8), "device");
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        v32 = objc_msgSend(v34, "initWithDevice:descriptor:", v31, v23);
        v33 = 1;
      }
      else
      {
        NumElements = mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v121);
        ElementDataSize = mlir::mps::CPUNDArray::getElementDataSize((mlir::mps::CPUNDArray *)v121);
        objc_msgSend(*(id *)(a2 + 8), "device");
        v28 = (void *)objc_claimAutoreleasedReturnValue();
        v29 = v28;
        if ((unsigned __int16)MPSDataType == 4)
          v30 = (unint64_t)(ElementDataSize * NumElements + 1) >> 1;
        else
          v30 = ElementDataSize * NumElements;
        v31 = (void *)objc_msgSend(v28, "newBufferWithBytesNoCopy:length:options:deallocator:", __src, v30, 0x100000, 0);

        v32 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6F50]), "initWithBuffer:descriptor:", v31, v23);
        v33 = 0;
      }

      v9 = -[MPSGraphTensorData initWithMPSNDArray:device:]([MPSGraphTensorData alloc], "initWithMPSNDArray:device:", v32, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48));
      v117 = (void *)v32;
      if (*(_QWORD *)(a1 + 96))
      {
LABEL_19:
        if (**(_BYTE **)(a1 + 88))
          v35 = v16 == (id)v32;
        else
          v35 = 0;
        v36 = v35;
        if (!mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v121) || !(v33 | v36))
          goto LABEL_84;
        v37 = mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v121);
        v113 = v16;
        v38 = mlir::mps::CPUNDArray::getElementDataSize((mlir::mps::CPUNDArray *)v121);
        v39 = v38;
        v40 = (unsigned __int16)MPSDataType;
        v41 = v38 * v37 + 1;
        v42 = v41 >> 1;
        if ((unsigned __int16)MPSDataType == 4)
          v43 = v41 >> 1;
        else
          v43 = v38 * v37;
        v44 = v124;
        v110 = MPSDataType;
        __n = v43;
        if (v124)
        {
          v45 = __src;
          v46 = (char *)malloc_type_malloc(v43, 0xA892026AuLL);
          v47 = v46;
          if (v40 != 4)
          {
            v50 = 1;
            v69 = v39 - 1;
            v51 = v117;
            v52 = v46;
            switch(v69)
            {
              case 0:
                memset(v46, *(unsigned __int8 *)v45, v37);
                v50 = 1;
                v16 = v113;
                if (!v36)
                  goto LABEL_82;
                goto LABEL_47;
              case 1:
                LOWORD(__pattern4[0]) = *v45;
                WORD1(__pattern4[0]) = __pattern4[0];
                v97 = 2 * v37;
                v98 = __pattern4;
                goto LABEL_80;
              case 2:
              case 4:
              case 5:
              case 6:
                goto LABEL_81;
              case 3:
                v97 = 4 * v37;
                v98 = v45;
LABEL_80:
                memset_pattern4(v46, v98, v97);
                v50 = 1;
LABEL_81:
                v16 = v113;
                if (!v36)
                  goto LABEL_82;
                goto LABEL_47;
              case 7:
                memset_pattern8(v46, v45, 8 * v37);
                v50 = 1;
                v16 = v113;
                if (!v36)
                  goto LABEL_82;
                goto LABEL_47;
              default:
                goto LABEL_39;
            }
          }
          v48 = *(_BYTE *)v45 & 0xF;
          if ((unint64_t)(v37 + 1) >= 3)
          {
            if (v37 >= 0)
              v49 = v37;
            else
              v49 = v37 + 1;
            memset(v46, v48 | (16 * v48), v49 >> 1);
          }
          if ((v37 & 1) == 0)
          {
            v50 = 1;
LABEL_39:
            v51 = v117;
            v52 = v47;
            v16 = v113;
            if (!v36)
              goto LABEL_82;
            goto LABEL_47;
          }
          v47[v42 - 1] = v48;
          v52 = v47;
          v50 = 1;
          v51 = v117;
          v16 = v113;
          if (v36)
            goto LABEL_47;
        }
        else
        {
          if (v36)
          {
            if (v123
              || (v53 = v43,
                  objc_msgSend(*(id *)(a2 + 8), "device"),
                  v54 = (void *)objc_claimAutoreleasedReturnValue(),
                  v55 = objc_msgSend(v54, "hasUnifiedMemory"),
                  v54,
                  v43 = v53,
                  (v55 & 1) == 0))
            {
              v52 = malloc_type_malloc(v43, 0xA046D8EBuLL);
              memcpy(v52, __src, __n);
              v51 = v117;
              v16 = v113;
              v56 = 1;
              if ((unsigned __int16)MPSDataType >= 8u)
                goto LABEL_48;
              goto LABEL_55;
            }
          }
          v50 = 0;
          v52 = __src;
          v51 = v117;
          v16 = v113;
          if (v36)
          {
LABEL_47:
            v56 = v50;
            if (v40 >= 8)
            {
LABEL_48:
              objc_msgSend(*(id *)(a2 + 8), "device");
              v57 = (void *)objc_claimAutoreleasedReturnValue();
              v119[0] = MEMORY[0x1E0C809B0];
              v119[1] = 3221225472;
              v119[2] = ___ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorEN4mlir12ElementsAttrEb_block_invoke;
              v119[3] = &__block_descriptor_33_e12_v24__0_v8Q16l;
              v120 = v56;
              v58 = (void *)objc_msgSend(v57, "newBufferWithBytesNoCopy:length:options:deallocator:", v52, __n, 0x100000, v119);

              v59 = objc_alloc(MEMORY[0x1E0CC7030]);
              objc_msgSend(*(id *)(a2 + 8), "device");
              v60 = (void *)objc_claimAutoreleasedReturnValue();
              __na = (void *)objc_msgSend(v59, "initWithDevice:", v60);

              v61 = (void *)MEMORY[0x1E0CC6FE0];
              objc_msgSend(v117, "descriptor");
              v62 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v62, "getShape");
              v63 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v61, "descriptorWithDataType:shape:", v110, v63);
              v64 = (void *)objc_claimAutoreleasedReturnValue();

              objc_msgSend(v64, "setPreferPackedRows:", 1);
              v65 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6F50]), "initWithBuffer:offset:descriptor:", v58, 0, v64);
              GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
              v66 = (void *)objc_claimAutoreleasedReturnValue();
              v67 = *(_QWORD *)(a2 + 8);
              v131 = v65;
              objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v131, 1);
              v68 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(__na, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v66, v67, v68, v117);

              goto LABEL_84;
            }
LABEL_55:
            v70 = *(uint64_t **)(a1 + 80);
            if (!v70)
            {
              objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice");
              v71 = (void *)objc_claimAutoreleasedReturnValue();
              v72 = v52;
              v73 = (void **)operator new();
              v74 = v71;
              *v73 = 0;
              v73[1] = 0;
              v75 = objc_alloc_init(MEMORY[0x1E0CC6B88]);
              v76 = *v73;
              *v73 = v75;

              v77 = objc_msgSend(v74, "newSharedEvent");
              v78 = v73[1];
              v73[1] = (void *)v77;

              v73[2] = 0;
              v79 = *(id **)(a1 + 80);
              *(_QWORD *)(a1 + 80) = v73;
              if (v79)
              {

                MEMORY[0x186DA1680](v79, 0x1080C40CC6EE3FDLL);
              }

              v70 = *(uint64_t **)(a1 + 80);
              v51 = v117;
              v52 = v72;
            }
            v80 = v51;
            v130 = 0;
            v81 = operator new(0x20uLL);
            *v81 = &off_1E0E05588;
            v81[1] = v80;
            v81[2] = v52;
            *((_BYTE *)v81 + 24) = v56;
            v130 = v81;
            v82 = v70[2];
            if ((unint64_t)(v82 + 3) <= 1)
            {
              objc_msgSend(*(id *)(a2 + 8), "device");
              v83 = (void *)objc_claimAutoreleasedReturnValue();
              v84 = objc_msgSend(v83, "newSharedEvent");
              v85 = (void *)v70[1];
              v70[1] = v84;

              v82 = 0;
              v70[2] = 0;
            }
            v86 = v82 + 2;
            v70[2] = v82 + 2;
            v87 = *(void **)(a2 + 72);
            if (v87)
            {
              objc_msgSend(v87, "endEncoding");
              v88 = *(void **)(a2 + 72);
              *(_QWORD *)(a2 + 72) = 0;

            }
            v90 = *v70;
            v89 = (void *)v70[1];
            __pattern4[0] = MEMORY[0x1E0C809B0];
            __pattern4[1] = 3321888768;
            __pattern4[2] = ___ZN3GPU19EncodeCPUWorkHelper6encodeEPNS_16EncodeDescriptorENSt3__18functionIFvvEEE_block_invoke;
            __pattern4[3] = &__block_descriptor_72_ea8_32c27_ZTSNSt3__18functionIFvvEEE_e29_v24__0___MTLSharedEvent__8Q16l;
            v91 = v133;
            v92 = (uint64_t)v130;
            if (v130)
            {
              if (v130 == v129)
              {
                v134 = v133;
                (*(void (**)(_QWORD *, _BYTE *))(v129[0] + 24))(v129, v133);
LABEL_68:
                v93 = v82 + 1;
                v135 = v86;
                objc_msgSend(v89, "notifyListener:atValue:block:", v90, v93, __pattern4);
                objc_msgSend(*(id *)(a2 + 8), "encodeSignalEvent:value:", v70[1], v93);
                objc_msgSend(*(id *)(a2 + 8), "encodeWaitForEvent:value:", v70[1], v86);
                if (v134 == v133)
                {
                  v94 = 4;
                }
                else
                {
                  if (!v134)
                  {
LABEL_73:
                    v95 = v130;
                    if (v130 == v129)
                    {
                      v96 = 4;
                      v95 = v129;
                    }
                    else
                    {
                      if (!v130)
                        goto LABEL_84;
                      v96 = 5;
                    }
                    (*(void (**)(void))(*v95 + 8 * v96))();
LABEL_84:
                    v99 = *(id *)(a2 + 88);
                    if (v99)
                    {
                      objc_msgSend(v117, "buffer");
                      v100 = (void *)objc_claimAutoreleasedReturnValue();
                      objc_msgSend(v99, "setConstantBuffer:", v100);

                    }
                    if (v16)
                    {
                      objc_msgSend(v16, "buffer");
                      v101 = (void *)objc_claimAutoreleasedReturnValue();
                      v102 = objc_msgSend(v101, "storageMode") == 2;

                      if (v102)
                      {
                        v103 = objc_alloc(MEMORY[0x1E0CC7030]);
                        objc_msgSend(*(id *)(a2 + 8), "device");
                        v104 = (void *)objc_claimAutoreleasedReturnValue();
                        v105 = (void *)objc_msgSend(v103, "initWithDevice:", v104);

                        objc_msgSend(v105, "setLabel:", &stru_1E0E7A578);
                        GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
                        v106 = (void *)objc_claimAutoreleasedReturnValue();
                        v107 = *(_QWORD *)(a2 + 8);
                        v128 = v117;
                        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v128, 1);
                        v108 = (void *)objc_claimAutoreleasedReturnValue();
                        objc_msgSend(v105, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v106, v107, v108, v16);

LABEL_91:
                      }
                    }
                    else if (a5)
                    {
                      v109 = v9;
                      v105 = *(void **)(a1 + 48);
                      *(_QWORD *)(a1 + 48) = v109;
                      goto LABEL_91;
                    }

                    mlir::mps::CPUNDArray::~CPUNDArray(v121);
                    v8 = v115;
                    goto LABEL_93;
                  }
                  v94 = 5;
                  v91 = v134;
                }
                (*(void (**)(_QWORD *))(*v91 + 8 * v94))(v91);
                goto LABEL_73;
              }
              v92 = (*(uint64_t (**)(void))(*v130 + 16))();
            }
            v134 = (_BYTE *)v92;
            goto LABEL_68;
          }
        }
LABEL_82:
        objc_msgSend(v51, "writeBytes:strideBytes:", v52, 0);
        if (v44)
          free(v52);
        goto LABEL_84;
      }
    }
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  }
LABEL_93:
  BaseRuntime::setTensorDataToDataMap(*(_QWORD *)(a1 + 16), v8, v9);

}

void sub_180E1597C(_Unwind_Exception *a1)
{

  _Unwind_Resume(a1);
}

void ___ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorEN4mlir12ElementsAttrEb_block_invoke(uint64_t a1, void *a2)
{
  if (*(_BYTE *)(a1 + 32))
    free(a2);
}

uint64_t GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v7;
  mlir::MLIRContext *v8;
  uint64_t UnknownLoc;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  unint64_t StaticType;

  v4 = *((_QWORD *)this + 3);
  if ((*(_BYTE *)(v4 + 46) & 0x80) == 0)
    __assert_rtn("getOperandStorage", "Operation.h", 960, "hasOperandStorage && \"expected operation to have operand storage\"");
  if (*(_DWORD *)(v4 + 68) <= a4)
    __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
  v7 = *(_QWORD *)(*(_QWORD *)(v4 + 72) + 32 * a4 + 24);
  if ((isStaticMPSType((uint64_t **)(*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8)) & 1) == 0)
  {
    StaticType = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), v7);
    UnknownLoc = mlir::Builder::getUnknownLoc(a3, v8);
    v10 = mlir::OpBuilder::create<mlir::mps::PlaceholderOp,mlir::Type &>((mlir::OpBuilder *)a3, UnknownLoc, (uint64_t *)&StaticType);
    if (!*(_DWORD *)(v10 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v11 = *(_QWORD *)(*(_QWORD *)(v10 - 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v11)
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    v12 = *(void **)(v11 + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v12 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
    }
    return v10 - 16;
  }
  return v7;
}

unint64_t GPU::BaseOpHandler::_getJITStaticOperandReprConstant(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t DefiningOp;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t **StaticType;
  uint64_t RHS;
  void *v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  mlir::MLIRContext *v19;
  int8x8_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint64_t **v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  unint64_t v34;
  llvm::APInt *v35;
  uint64_t v36;
  unsigned int Width;
  int Signedness;
  int v39;
  llvm::APInt *v40;
  llvm::APInt *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  llvm::APInt *v48;
  unint64_t v49;
  uint64_t v50;
  llvm::APInt *v51;
  const void **v52;
  unsigned int v53;
  llvm::APInt *v54;
  llvm::APInt *v55;
  char *v56;
  uint64_t **v57;
  uint64_t InterfaceFor;
  const char *v59;
  int v60;
  const char *v61;
  const char *v62;
  uint64_t *v63;
  mlir::MLIRContext *v64;
  uint64_t UnknownLoc;
  mlir::GenericProgramPoint *v66;
  llvm::APInt *v67;
  llvm::APInt *v68;
  void *v69;
  uint64_t v70;
  uint64_t v72;
  mlir::GenericProgramPoint *v73;
  uint64_t v74;
  mlir::UnknownLoc **v75;
  uint64_t *v76;
  uint64_t *v77;
  void *__p;
  llvm::APInt *v79;
  llvm::APInt *v80;
  void *v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t **v84;
  unint64_t v85;
  __int128 v86;
  char *v87;
  llvm::APInt *v88;
  llvm::APInt **v89;

  v4 = *((_QWORD *)this + 3);
  if ((*(_BYTE *)(v4 + 46) & 0x80) == 0)
    __assert_rtn("getOperandStorage", "Operation.h", 960, "hasOperandStorage && \"expected operation to have operand storage\"");
  if (*(_DWORD *)(v4 + 68) <= a4)
    __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
  v85 = *(_QWORD *)(*(_QWORD *)(v4 + 72) + 32 * a4 + 24);
  *(_QWORD *)&v86 = v85;
  if (!v85)
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v86);
  if (DefiningOp)
  {
    v9 = DefiningOp;
    v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 48) + 32))(*(_QWORD *)(v9 + 48), v10))
      return v85;
  }
  StaticType = (uint64_t **)GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), v85);
  if (!*StaticType)
    goto LABEL_99;
  if ((_UNKNOWN *)(*StaticType)[17] != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  v84 = StaticType;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v84);
  if (!RHS)
    __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  if (!*(_QWORD *)RHS)
LABEL_99:
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  v14 = *(void **)(*(_QWORD *)RHS + 136);
  v15 = v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id;
  if (v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    v16 = RHS;
  else
    v16 = 0;
  v83 = v16;
  if (!v15)
  {
    v11 = 0;
    if (MTLReportFailureTypeEnabled())
    {
      MTLReportFailure();
      return 0;
    }
    return (unint64_t)v11;
  }
  v17 = *((_QWORD *)this + 2) + 344;
  v81 = (void *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v85) + 2);
  *(_QWORD *)&v86 = &v81;
  v18 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>>>::__emplace_unique_key_args<mlir::Operation *,std::piecewise_construct_t const&,std::tuple<mlir::Operation * const&>,std::tuple<>>(v17, (uint64_t *)&v81, (uint64_t)&std::piecewise_construct, (_QWORD **)&v86);
  v20 = *(int8x8_t *)(v18 + 32);
  if (!*(_QWORD *)&v20)
    goto LABEL_37;
  v21 = 0x9DDFEA08EB382D69 * (((8 * v85) + 8) ^ HIDWORD(v85));
  v22 = 0x9DDFEA08EB382D69 * (HIDWORD(v85) ^ (v21 >> 47) ^ v21);
  v23 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
  v24 = (uint8x8_t)vcnt_s8(v20);
  v24.i16[0] = vaddlv_u8(v24);
  if (v24.u32[0] > 1uLL)
  {
    v25 = v23;
    if (v23 >= *(_QWORD *)&v20)
      v25 = v23 % *(_QWORD *)&v20;
  }
  else
  {
    v25 = v23 & (*(_QWORD *)&v20 - 1);
  }
  v26 = *(uint64_t ***)(*((_QWORD *)v18 + 3) + 8 * v25);
  if (!v26 || (v27 = *v26) == 0)
  {
LABEL_37:
    v74 = (uint64_t)(v18 + 24);
    v75 = a3;
    GPURegionRuntime::waitAndReadIntTensorData(*((_QWORD *)this + 2), (uint64_t)a2, (void *)v85, (uint64_t)&v81);
    __p = 0;
    v79 = 0;
    v80 = 0;
    v31 = (uint64_t *)v81;
    v32 = v82;
    v33 = (char *)v82 - (_BYTE *)v81;
    if (v82 != v81)
    {
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF9)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      __p = operator new(2 * v33);
      v79 = (llvm::APInt *)__p;
      v80 = (llvm::APInt *)((char *)__p + 16 * (v33 >> 3));
      if (v32 != v31)
      {
        v76 = v32;
        do
        {
          v36 = *v31;
          Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&v83);
          Signedness = mlir::IntegerType::getSignedness((mlir::IntegerType *)&v83);
          v39 = Signedness;
          v40 = v79;
          if (v79 < v80)
          {
            *((_DWORD *)v79 + 2) = Width;
            if (Width <= 0x40)
            {
              v34 = 0xFFFFFFFFFFFFFFFFLL >> -(char)Width;
              if (!Width)
                v34 = 0;
              *(_QWORD *)v40 = v34 & v36;
            }
            else
            {
              llvm::APInt::initSlowCase(v40, v36, Signedness == 1);
            }
            v35 = (llvm::APInt *)((char *)v40 + 16);
            goto LABEL_45;
          }
          v41 = (llvm::APInt *)__p;
          v42 = (v79 - (llvm::APInt *)__p) >> 4;
          v43 = v42 + 1;
          if ((unint64_t)(v42 + 1) >> 60)
            std::vector<int>::__throw_length_error[abi:ne180100]();
          v44 = v80 - (llvm::APInt *)__p;
          if ((v80 - (llvm::APInt *)__p) >> 3 > v43)
            v43 = v44 >> 3;
          if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0)
            v45 = 0xFFFFFFFFFFFFFFFLL;
          else
            v45 = v43;
          v89 = &v80;
          if (v45 >> 60)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v46 = (char *)operator new(16 * v45);
          v47 = &v46[16 * v42];
          *(_QWORD *)&v86 = v46;
          *((_QWORD *)&v86 + 1) = v47;
          v48 = (llvm::APInt *)&v46[16 * v45];
          v87 = v47;
          v88 = v48;
          *((_DWORD *)v47 + 2) = Width;
          if (Width > 0x40)
          {
            llvm::APInt::initSlowCase((llvm::APInt *)&v46[16 * v42], v36, v39 == 1);
            v41 = (llvm::APInt *)__p;
            v40 = v79;
            v35 = (llvm::APInt *)(v47 + 16);
            v87 = v47 + 16;
            if (v79 == __p)
              goto LABEL_67;
          }
          else
          {
            v49 = 0xFFFFFFFFFFFFFFFFLL >> -(char)Width;
            if (!Width)
              v49 = 0;
            *(_QWORD *)v47 = v49 & v36;
            v35 = (llvm::APInt *)(v47 + 16);
            v87 = v47 + 16;
            if (v40 == v41)
            {
LABEL_67:
              v54 = v41;
              goto LABEL_68;
            }
          }
          v50 = 0;
          do
          {
            v51 = (llvm::APInt *)&v47[v50 - 16];
            v52 = (const void **)((char *)v40 + v50 - 16);
            v53 = *(_DWORD *)((char *)v40 + v50 - 8);
            *(_DWORD *)&v47[v50 - 8] = v53;
            if (v53 <= 0x40)
              *(_QWORD *)v51 = *v52;
            else
              llvm::APInt::initSlowCase(v51, v52);
            v50 -= 16;
          }
          while ((llvm::APInt *)((char *)v40 + v50) != v41);
          v54 = (llvm::APInt *)__p;
          v41 = v79;
          v47 += v50;
          v35 = (llvm::APInt *)v87;
          v48 = v88;
LABEL_68:
          __p = v47;
          v79 = v35;
          v55 = v80;
          v80 = v48;
          v88 = v55;
          *(_QWORD *)&v86 = v54;
          *((_QWORD *)&v86 + 1) = v54;
          if (v41 != v54)
          {
            v56 = (char *)v41 - 16;
            v32 = v76;
            do
            {
              v87 = v56;
              if (*((_DWORD *)v56 + 2) >= 0x41u && *(_QWORD *)v56)
                MEMORY[0x186DA165C](*(_QWORD *)v56, 0x1000C8000313F17);
              v56 -= 16;
            }
            while (v56 + 16 != (char *)v54);
            v41 = v54;
            if (!v54)
              goto LABEL_45;
LABEL_77:
            operator delete(v41);
            goto LABEL_45;
          }
          v32 = v76;
          if (v41)
            goto LABEL_77;
LABEL_45:
          v79 = v35;
          ++v31;
        }
        while (v31 != v32);
      }
    }
    if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v84))
    {
      v57 = v84;
      if (v84)
      {
        InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v84);
        if (!InterfaceFor)
        {
          v59 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          v60 = 98;
          v61 = "InterfaceSupport.h";
          v62 = "Interface";
          goto LABEL_106;
        }
      }
      else
      {
        InterfaceFor = 0;
      }
      v63 = (uint64_t *)mlir::DenseElementsAttr::get((uint64_t)v57, InterfaceFor, (llvm::APInt *)__p, (v79 - (llvm::APInt *)__p) >> 4);
      if ((mlir::DenseIntElementsAttr::classof((uint64_t)v63) & 1) != 0)
      {
        v77 = v63;
        *(_QWORD *)&v86 = mlir::Attribute::cast<mlir::ElementsAttr>(&v77);
        *((_QWORD *)&v86 + 1) = v64;
        UnknownLoc = mlir::Builder::getUnknownLoc(v75, v64);
        v66 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)v75, UnknownLoc, (uint64_t)&v86);
        if (!*((_DWORD *)v66 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v77 = (uint64_t *)v85;
        std::__hash_table<std::__hash_value_type<void *,mlir::ElementsAttr>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,mlir::ElementsAttr>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,mlir::ElementsAttr>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,mlir::ElementsAttr>>>::__emplace_unique_key_args<void *,void *,mlir::ElementsAttr&>(v74, (uint64_t *)&v77, &v77, &v86);
        v67 = (llvm::APInt *)__p;
        if (__p)
        {
          v68 = v79;
          v69 = __p;
          if (v79 != __p)
          {
            do
            {
              if (*((_DWORD *)v68 - 2) >= 0x41u)
              {
                v70 = *((_QWORD *)v68 - 2);
                if (v70)
                  MEMORY[0x186DA165C](v70, 0x1000C8000313F17);
              }
              v68 = (llvm::APInt *)((char *)v68 - 16);
            }
            while (v68 != v67);
            v69 = __p;
          }
          v79 = v67;
          operator delete(v69);
        }
        v11 = (char *)v66 - 16;
        if (v81)
        {
          v82 = (uint64_t *)v81;
          operator delete(v81);
        }
        return (unint64_t)v11;
      }
    }
    v59 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v60 = 566;
    v61 = "Casting.h";
    v62 = "cast";
LABEL_106:
    __assert_rtn(v62, v61, v60, v59);
  }
  if (v24.u32[0] < 2uLL)
  {
    v28 = *(_QWORD *)&v20 - 1;
    while (1)
    {
      v30 = v27[1];
      if (v30 == v23)
      {
        if (v27[2] == v85)
          goto LABEL_97;
      }
      else if ((v30 & v28) != v25)
      {
        goto LABEL_37;
      }
      v27 = (uint64_t *)*v27;
      if (!v27)
        goto LABEL_37;
    }
  }
  while (1)
  {
    v29 = v27[1];
    if (v29 == v23)
      break;
    if (v29 >= *(_QWORD *)&v20)
      v29 %= *(_QWORD *)&v20;
    if (v29 != v25)
      goto LABEL_37;
LABEL_27:
    v27 = (uint64_t *)*v27;
    if (!v27)
      goto LABEL_37;
  }
  if (v27[2] != v85)
    goto LABEL_27;
LABEL_97:
  v86 = *(_OWORD *)(v27 + 3);
  v72 = mlir::Builder::getUnknownLoc(a3, v19);
  v73 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)a3, v72, (uint64_t)&v86);
  if (!*((_DWORD *)v73 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return (unint64_t)v73 - 16;
}

void sub_180E165BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  std::vector<llvm::APInt>::~vector[abi:ne180100](&a14);
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void **std::vector<llvm::APInt>::~vector[abi:ne180100](void **a1)
{
  char *v2;
  char *v3;
  void *v4;
  uint64_t v5;

  v2 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((_DWORD *)v3 - 2) >= 0x41u)
        {
          v5 = *((_QWORD *)v3 - 2);
          if (v5)
            MEMORY[0x186DA165C](v5, 0x1000C8000313F17);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t GPU::BaseOpHandler::kernelDAGOp()
{
  if (MTLReportFailureTypeEnabled())
    MTLReportFailure();
  return 0;
}

void GPU::BaseOpHandler::~BaseOpHandler(GPU::BaseOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

{
  char *v2;
  id *v3;

  *(_QWORD *)this = &off_1E0E1AF78;
  v2 = (char *)*((_QWORD *)this + 11);
  if (v2 != (char *)this + 112)
    free(v2);
  v3 = (id *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = 0;
  if (v3)
  {

    MEMORY[0x186DA1680](v3, 0x1080C40CC6EE3FDLL);
  }

}

uint64_t GPU::BaseOpHandler::setResultIsGraphOutput(uint64_t this, unsigned int a2)
{
  if (*(_QWORD *)(this + 96) <= (unint64_t)a2)
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  *(_BYTE *)(*(_QWORD *)(this + 88) + a2) = 1;
  return this;
}

uint64_t std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::~__func(uint64_t a1)
{

  return a1;
}

void std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::~__func(uint64_t a1)
{

  JUMPOUT(0x186DA1680);
}

_QWORD *std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  id v3;
  uint64_t v4;

  v2 = operator new(0x20uLL);
  *v2 = &off_1E0E05588;
  v3 = *(id *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  v2[1] = v3;
  v2[2] = v4;
  *((_BYTE *)v2 + 24) = *(_BYTE *)(a1 + 24);
  return v2;
}

id std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  id result;
  char v5;

  *(_QWORD *)a2 = &off_1E0E05588;
  result = *(id *)(a1 + 8);
  *(_QWORD *)(a2 + 8) = result;
  v5 = *(_BYTE *)(a1 + 24);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16);
  *(_BYTE *)(a2 + 24) = v5;
  return result;
}

void std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::destroy(uint64_t a1)
{

}

void std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::destroy_deallocate(id *a1)
{

  operator delete(a1);
}

void std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  objc_msgSend(*(id *)(a1 + 8), "writeBytes:strideBytes:", *(_QWORD *)(a1 + 16), 0);
  if (*(_BYTE *)(a1 + 24))
    free(*(void **)(a1 + 16));
}

uint64_t std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorEN4mlir12ElementsAttrEbE3$_1")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorEN4mlir12ElementsAttrEbE3$_1" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorEN4mlir12ElementsAttrEbE3$_1"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3GPU13BaseOpHandler16encodeConstantOpEPNS_16EncodeDescriptorEN4mlir12ElementsAttrEbE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1,std::allocator<GPU::BaseOpHandler::encodeConstantOp(GPU::EncodeDescriptor *,mlir::ElementsAttr,BOOL)::$_1>,void ()(void)>::target_type()
{
}

uint64_t std::__split_buffer<llvm::APInt>::~__split_buffer(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  unsigned int v4;

  v3 = *(_QWORD **)(a1 + 8);
  v2 = *(_QWORD **)(a1 + 16);
  while (v2 != v3)
  {
    v4 = *((_DWORD *)v2 - 2);
    v2 -= 2;
    *(_QWORD *)(a1 + 16) = v2;
    if (v4 >= 0x41)
    {
      if (*v2)
      {
        MEMORY[0x186DA165C](*v2, 0x1000C8000313F17);
        v2 = *(_QWORD **)(a1 + 16);
      }
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void GPU::DepthwiseConv2DOpHandler::encodeNDArrayOp(GPU::DepthwiseConv2DOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v5;
  void *v6;
  char *Input;
  char *Filter;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  id v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  id v16;
  char *StaticType;
  uint64_t Value;
  unint64_t v19;
  uint64_t *v20;
  char *v21;
  _QWORD *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  void *v26;
  int StorageType;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t NumElements;
  unsigned int v33;
  unint64_t v34;
  unint64_t v35;
  BOOL v36;
  int v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  BOOL v46;
  int v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int j;
  BOOL v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  BOOL v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int i;
  BOOL v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  int PaddingStyle;
  uint64_t *v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  void *v100;
  int *v101;
  int v102;
  char *v103;
  id v104;
  int v105;
  char *v106;
  void *v107;
  uint64_t v108;
  void *v109;
  const char *v110;
  int v111;
  const char *v112;
  const char *v113;
  const char *v114;
  int v115;
  const char *v116;
  const char *v117;
  const char *v118;
  int v119;
  const char *v120;
  const char *v121;
  _QWORD *AttrData;
  uint64_t v123;
  BOOL v124;
  unint64_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  void *v130;
  GPU::EncodeDescriptor *v131;
  id v132;
  NSArray *v133;
  void *v134;
  void *v135;
  void *v136;
  uint64_t v137;
  const char *v138;
  uint64_t v139;
  uint64_t v140;
  __int16 v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  uint64_t v145;
  __int16 v146;
  char *v147;
  id v148;
  uint64_t v149;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  uint64_t Strides;
  uint64_t v153;
  _QWORD v154[4];

  v154[2] = *MEMORY[0x1E0C80C00];
  v133 = a3;
  v5 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v147 = *(char **)(v5 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v147);
    if (v123 == 21)
    {
      v124 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v124 && *(_QWORD *)((char *)AttrData + 13) == 0x64325F766E6F635FLL)
      {
        v146 = 1283;
        v142 = "classof on '";
        v144 = (uint64_t)"mps.depthwise_conv_2d";
        v145 = 21;
        v138 = "' failed due to the operation not being registered";
        v141 = 259;
        llvm::operator+((uint64_t *)&v142, (uint64_t *)&v138, (uint64_t)&v147);
        llvm::report_fatal_error((llvm::Twine *)&v147, 1);
      }
    }
LABEL_239:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id)
    goto LABEL_239;
  v137 = *((_QWORD *)this + 3);
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v137);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v137);
  v9 = *((_QWORD *)this + 2);
  v147 = Input;
  v142 = (const char *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v147) + 2);
  v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v9 + 88), (uint64_t *)&v142);
  if (v10
    && (v138 = v147,
        (v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&v138)) != 0))
  {
    v12 = (id)v11[3];
  }
  else
  {
    v12 = 0;
  }
  objc_msgSend(v12, "mpsndarray");
  v135 = (void *)objc_claimAutoreleasedReturnValue();

  v13 = *((_QWORD *)this + 2);
  v147 = Filter;
  v142 = (const char *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v147) + 2);
  v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v13 + 88), (uint64_t *)&v142);
  if (v14
    && (v138 = v147,
        (v15 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v14 + 3, (uint64_t *)&v138)) != 0))
  {
    v16 = (id)v15[3];
  }
  else
  {
    v16 = 0;
  }
  objc_msgSend(v16, "mpsndarray");
  v134 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSArray objectAtIndexedSubscript:](v133, "objectAtIndexedSubscript:", 0);
  v130 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v130, "mpsndarray");
  v136 = (void *)objc_claimAutoreleasedReturnValue();
  if ((!v135 || !v134 || !v136) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (*((_QWORD *)this + 4) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  StaticType = (char *)GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), (uint64_t)Filter);
  if (!*(_QWORD *)StaticType)
  {
    v114 = "abstractType && \"Malformed type storage object.\"";
    v115 = 160;
    v116 = "TypeSupport.h";
    v117 = "getAbstractType";
    goto LABEL_219;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v114 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v115 = 566;
    v116 = "Casting.h";
    v117 = "cast";
LABEL_219:
    __assert_rtn(v117, v116, v115, v114);
  }
  v147 = StaticType;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v147);
  v129 = v19;
  v20 = (uint64_t *)Value;
  v21 = (char *)GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), (uint64_t)Input);
  if (!*(_QWORD *)v21)
  {
    v118 = "abstractType && \"Malformed type storage object.\"";
    v119 = 160;
    v120 = "TypeSupport.h";
    v121 = "getAbstractType";
    goto LABEL_222;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v21 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v118 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v119 = 566;
    v120 = "Casting.h";
    v121 = "cast";
LABEL_222:
    __assert_rtn(v121, v120, v119, v118);
  }
  v147 = v21;
  v22 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v147);
  v24 = v23;
  v131 = a2;
  v25 = v137;
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v153 = v25;
  v132 = v26;
  Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v153);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v153);
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v153);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v153);
  if (StorageType)
  {
    if (StorageType == 1)
    {
      if (v24 >= 4)
      {
        v29 = v22[1];
        v28 = v22[2];
        v30 = v22[3];
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v147, Strides, 0);
        v127 = v28;
        v128 = v30;
        v126 = v29;
        v31 = Strides;
        NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v142, v31, NumElements);
        v33 = 0;
        v34 = 1;
        v35 = 1;
        while (1)
        {
          v36 = v147 == v142 && v148 == v143;
          if (v36 && v149 == v144)
            break;
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v138);
          v37 = v139;
          if (v139 < 0x41)
          {
            v38 = (uint64_t)v138;
LABEL_32:
            v39 = v38;
            switch(v33)
            {
              case 0u:
                if (v38 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
                  goto LABEL_41;
                goto LABEL_44;
              case 1u:
                goto LABEL_45;
              case 2u:
                v39 = v34;
                v35 = v38;
                break;
              case 3u:
                if (v38 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
                  goto LABEL_41;
                goto LABEL_44;
              default:
                goto LABEL_40;
            }
            goto LABEL_45;
          }
          if (v37 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v138) <= 0x40)
          {
            v38 = *(_QWORD *)v138;
            if (v33 <= 3)
              goto LABEL_32;
          }
          else
          {
            v38 = -1;
            if (v33 <= 3)
              goto LABEL_32;
          }
LABEL_40:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_41:
            MTLReportFailure();
            v39 = v34;
          }
          else
          {
LABEL_44:
            v39 = v34;
          }
LABEL_45:
          if (v139 >= 0x41)
          {
            if (v138)
              MEMORY[0x186DA165C](v138, 0x1000C8000313F17);
          }
          ++v149;
          ++v33;
          v34 = v39;
        }
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v147, InputAttributeNames, 0);
        v68 = InputAttributeNames;
        v69 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v142, v68, v69);
        v70 = 0;
        v53 = 1;
        v54 = 1;
        while (1)
        {
          v71 = v147 == v142 && v148 == v143;
          if (v71 && v149 == v144)
          {
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v147, Rewriter, 0);
            v75 = Rewriter;
            v76 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v142, v75, v76);
            v61 = 0;
            v62 = 0;
            for (i = 0; ; ++i)
            {
              v78 = v147 == v142 && v148 == v143;
              if (v78 && v149 == v144)
                break;
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v138);
              v79 = v139;
              if (v139 >= 0x41)
              {
                if (v79 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v138) <= 0x40)
                  v80 = *(_QWORD *)v138;
                else
                  v80 = -1;
              }
              else
              {
                v80 = (uint64_t)v138;
              }
              if (i == 2)
                v81 = v80;
              else
                v81 = v62;
              if (i == 4)
                v61 = v80;
              else
                v62 = v81;
              if (v79 >= 0x41 && v138)
                MEMORY[0x186DA165C](v138, 0x1000C8000313F17);
              ++v149;
            }
            goto LABEL_181;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v138);
          v72 = v139;
          if (v139 < 0x41)
            break;
          if (v72 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v138) <= 0x40)
          {
            v73 = *(_QWORD *)v138;
            if (v70 <= 3)
              goto LABEL_141;
          }
          else
          {
            v73 = -1;
            if (v70 <= 3)
              goto LABEL_141;
          }
LABEL_149:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_150:
            MTLReportFailure();
            v74 = v53;
          }
          else
          {
LABEL_153:
            v74 = v53;
          }
LABEL_154:
          if (v139 >= 0x41 && v138)
            MEMORY[0x186DA165C](v138, 0x1000C8000313F17);
          ++v149;
          ++v70;
          v53 = v74;
        }
        v73 = (uint64_t)v138;
LABEL_141:
        v74 = v73;
        switch(v70)
        {
          case 0u:
            if (v73 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_150;
            goto LABEL_153;
          case 1u:
            goto LABEL_154;
          case 2u:
            v74 = v53;
            v54 = v73;
            break;
          case 3u:
            if (v73 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_150;
            goto LABEL_153;
          default:
            goto LABEL_149;
        }
        goto LABEL_154;
      }
      goto LABEL_211;
    }
    v110 = "0 && \"Unsupported dataLayout\"";
    v111 = 200;
LABEL_237:
    v112 = "GPUDepthwiseConvOps.mm";
    v113 = "createDepthwiseConv2D";
LABEL_212:
    __assert_rtn(v113, v112, v111, v110);
  }
  if (v24 < 4)
    goto LABEL_211;
  v41 = v22[2];
  v40 = v22[3];
  v42 = v22[1];
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v147, Strides, 0);
  v127 = v40;
  v128 = v42;
  v126 = v41;
  v43 = Strides;
  v44 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v142, v43, v44);
  v45 = 0;
  v34 = 1;
  v35 = 1;
  while (1)
  {
    v46 = v147 == v142 && v148 == v143;
    if (v46 && v149 == v144)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v138);
    v47 = v139;
    if (v139 < 0x41)
    {
      v48 = (uint64_t)v138;
LABEL_61:
      v49 = v48;
      switch(v45)
      {
        case 0u:
          if (v48 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_70;
          goto LABEL_72;
        case 1u:
          if (v48 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_70;
          goto LABEL_72;
        case 2u:
          goto LABEL_73;
        case 3u:
          v49 = v34;
          v35 = v48;
          if (v139 >= 0x41)
            goto LABEL_74;
          break;
        default:
          goto LABEL_69;
      }
      goto LABEL_52;
    }
    if (v47 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v138) <= 0x40)
    {
      v48 = *(_QWORD *)v138;
      if (v45 <= 3)
        goto LABEL_61;
    }
    else
    {
      v48 = -1;
      if (v45 <= 3)
        goto LABEL_61;
    }
LABEL_69:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_70:
      MTLReportFailure();
      v49 = v34;
    }
    else
    {
LABEL_72:
      v49 = v34;
    }
LABEL_73:
    if (v139 >= 0x41)
    {
LABEL_74:
      if (v138)
        MEMORY[0x186DA165C](v138, 0x1000C8000313F17);
    }
LABEL_52:
    ++v149;
    ++v45;
    v34 = v49;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v147, InputAttributeNames, 0);
  v50 = InputAttributeNames;
  v51 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v142, v50, v51);
  v52 = 0;
  v53 = 1;
  v54 = 1;
  while (1)
  {
    v55 = v147 == v142 && v148 == v143;
    if (v55 && v149 == v144)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v138);
    v56 = v139;
    if (v139 < 0x41)
    {
      v57 = (uint64_t)v138;
LABEL_90:
      v58 = v57;
      switch(v52)
      {
        case 0u:
          if (v57 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_99;
          goto LABEL_101;
        case 1u:
          if (v57 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_99;
          goto LABEL_101;
        case 2u:
          goto LABEL_102;
        case 3u:
          v58 = v53;
          v54 = v57;
          if (v139 >= 0x41)
            goto LABEL_103;
          break;
        default:
          goto LABEL_98;
      }
      goto LABEL_81;
    }
    if (v56 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v138) <= 0x40)
    {
      v57 = *(_QWORD *)v138;
      if (v52 <= 3)
        goto LABEL_90;
    }
    else
    {
      v57 = -1;
      if (v52 <= 3)
        goto LABEL_90;
    }
LABEL_98:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_99:
      MTLReportFailure();
      v58 = v53;
    }
    else
    {
LABEL_101:
      v58 = v53;
    }
LABEL_102:
    if (v139 >= 0x41)
    {
LABEL_103:
      if (v138)
        MEMORY[0x186DA165C](v138, 0x1000C8000313F17);
    }
LABEL_81:
    ++v149;
    ++v52;
    v53 = v58;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v147, Rewriter, 0);
  v59 = Rewriter;
  v60 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v142, v59, v60);
  v61 = 0;
  v62 = 0;
  for (j = 0; ; ++j)
  {
    v64 = v147 == v142 && v148 == v143;
    if (v64 && v149 == v144)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v138);
    v65 = v139;
    if (v139 >= 0x41)
    {
      if (v65 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v138) <= 0x40)
        v66 = *(_QWORD *)v138;
      else
        v66 = -1;
    }
    else
    {
      v66 = (uint64_t)v138;
    }
    if (j == 4)
      v67 = v66;
    else
      v67 = v62;
    if (j == 6)
      v61 = v66;
    else
      v62 = v67;
    if (v65 >= 0x41 && v138)
      MEMORY[0x186DA165C](v138, 0x1000C8000313F17);
    ++v149;
  }
LABEL_181:
  PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v153);
  if (PaddingStyle == 2)
  {
    if (v129 > 3)
    {
      v83 = v20 + 3;
      v84 = v20 + 1;
      v20 += 2;
      goto LABEL_187;
    }
    goto LABEL_211;
  }
  if (PaddingStyle != 3)
  {
    v110 = "0 && \"Unsupported weightsFormat\"";
    v111 = 219;
    goto LABEL_237;
  }
  if (v129 <= 3)
  {
LABEL_211:
    v110 = "Index < Length && \"Invalid index!\"";
    v111 = 257;
    v112 = "ArrayRef.h";
    v113 = "operator[]";
    goto LABEL_212;
  }
  v83 = v20 + 1;
  v84 = v20 + 2;
LABEL_187:
  v85 = *v83;
  v86 = *v20;
  if (v128 != *v84 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v87 = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v153);
  v88 = (v85 - 1) * v54 + 1;
  v89 = (v86 - 1) * v53 + 1;
  switch(v87)
  {
    case 0:
      break;
    case 1:
      v61 = 0;
      v62 = 0;
      break;
    case 2:
    case 4:
      v90 = v126 % v34;
      if (!(v126 % v34))
        v90 = v34;
      v91 = (v89 - v90) & ~((uint64_t)(v89 - v90) >> 63);
      v92 = v127 % v35;
      if (!(v127 % v35))
        v92 = v35;
      v93 = (v88 - v92) & ~((uint64_t)(v88 - v92) >> 63);
      v94 = v91 >> 1;
      v95 = v91 - (v91 >> 1);
      v96 = v93 >> 1;
      v97 = v93 - (v93 >> 1);
      if (v87 == 4)
        v61 = v97;
      else
        v61 = v96;
      if (v87 == 4)
        v62 = v95;
      else
        v62 = v94;
      break;
    default:
      __assert_rtn("createDepthwiseConv2D", "GPUDepthwiseConvOps.mm", 261, "0 && \"Unsupported paddingStyle\"");
  }
  if (v88 >= 0)
    v98 = (v85 - 1) * v54 + 1;
  else
    v98 = (v85 - 1) * v54 + 2;
  if (v89 >= 0)
    v99 = (v86 - 1) * v53 + 1;
  else
    v99 = (v86 - 1) * v53 + 2;
  v100 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6FD8]), "initWithDevice:", v132);
  v147 = (char *)((v98 >> 1) - v61);
  v148 = (id)((v99 >> 1) - v62);
  v149 = 0;
  objc_msgSend(v100, "setWindowOffsets:", &v147);
  v142 = (const char *)v35;
  v143 = v34;
  v144 = 1;
  objc_msgSend(v100, "setConvStrides:", &v142);
  v138 = (const char *)v54;
  v139 = v53;
  v140 = 1;
  objc_msgSend(v100, "setConvDilationRates:", &v138);
  objc_msgSend(v100, "setOptions:", objc_msgSend(v100, "options") | 1);

  v101 = (int *)MEMORY[0x1E0CC7278];
  if (*((_BYTE *)v136 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v136, "setReadCount:", objc_msgSend(v136, "readCount") + 1);
  v102 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v137);
  v103 = v147;
  v104 = v148;
  v105 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v137);
  v106 = (char *)v142;
  GPU::EncodeDescriptor::getcomputeEncoder(v131);
  v107 = (void *)objc_claimAutoreleasedReturnValue();
  v108 = *((_QWORD *)v131 + 1);
  v154[0] = v103;
  v154[1] = v106;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v154, 2);
  v109 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v100, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v107, v108, v109, v104);

  if (*((_BYTE *)v104 + *v101))
    objc_msgSend(v104, "setReadCount:", objc_msgSend(v104, "readCount") - 1);

}

void sub_180E17B68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{

  _Unwind_Resume(a1);
}

uint64_t mlir::Type::cast<mlir::RankedTensorType>(uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  if (!*(_QWORD *)result)
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  if (*(_UNKNOWN **)(*(_QWORD *)result + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  return result;
}

void GPU::`anonymous namespace'::permuteImage(uint64_t *a1, GPU::EncodeDescriptor *a2, void *a3, void *a4, int a5)
{
  id v9;
  id v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  _OWORD v19[8];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v9 = a3;
  v10 = a4;
  objc_msgSend(v9, "descriptor");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "descriptor");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "numberOfDimensions");
  if ((unint64_t)objc_msgSend(v11, "numberOfDimensions") <= 3 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (a5 == 1)
  {
    v19[4] = xmmword_1812871B0;
    v19[5] = unk_1812871C0;
    v19[6] = xmmword_1812871D0;
    v19[7] = unk_1812871E0;
    v19[0] = xmmword_181287170;
    v19[1] = unk_181287180;
    v19[2] = xmmword_181287190;
    v19[3] = unk_1812871A0;
    objc_msgSend(v11, "permuteWithDimensionOrder:", v19);
    objc_msgSend(v12, "permuteWithDimensionOrder:", v19);
  }
  else if (a5)
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
  }
  else
  {
    objc_msgSend(v11, "transposeDimension:withDimension:", 2, 3);
    objc_msgSend(v12, "transposeDimension:withDimension:", 2, 3);
  }
  v13 = *((_QWORD *)a2 + 1);
  GPU::EncodeDescriptor::getcomputeEncoder(a2);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v13, v14, v11, 0);
  v15 = objc_claimAutoreleasedReturnValue();

  if (!v15)
    __assert_rtn("permuteImage", "GPUDepthwiseConvOps.mm", 347, "transSource");
  v16 = *((_QWORD *)a2 + 1);
  GPU::EncodeDescriptor::getcomputeEncoder(a2);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v16, v17, v12, 1);
  v18 = objc_claimAutoreleasedReturnValue();

  if (!v18)
    __assert_rtn("permuteImage", "GPUDepthwiseConvOps.mm", 354, "transDest");
  *a1 = v15;
  a1[1] = v18;

}

void sub_180E17FD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void GPU::`anonymous namespace'::permuteWeights(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3, int a4, uint64_t a5)
{
  void *v7;
  void *v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  unint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  unint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  id v33;
  void *v34;
  void *v35;
  void *v36;
  id v38;
  void *v40;
  _QWORD v41[4];
  _QWORD v42[4];
  _OWORD v43[8];
  _QWORD v44[4];
  _QWORD v45[6];

  v45[4] = *MEMORY[0x1E0C80C00];
  v38 = a3;
  objc_msgSend(v38, "descriptor");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  if (a4 == 2)
  {
    objc_msgSend(v40, "getShape");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "objectAtIndexedSubscript:", 0);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v21 = objc_msgSend(v20, "unsignedIntegerValue");

    objc_msgSend(v7, "objectAtIndexedSubscript:", 1);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = objc_msgSend(v22, "unsignedIntegerValue") * v21;

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", v23);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    v42[0] = v24;
    v42[1] = &unk_1E0E98740;
    objc_msgSend(v7, "objectAtIndexedSubscript:", 2);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v42[2] = v25;
    objc_msgSend(v7, "objectAtIndexedSubscript:", 3);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    v42[3] = v26;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v42, 4);
    v36 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", v23);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v41[0] = v27;
    v41[1] = &unk_1E0E98740;
    objc_msgSend(v7, "objectAtIndexedSubscript:", 2);
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v41[2] = v28;
    objc_msgSend(v7, "objectAtIndexedSubscript:", 3);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v41[3] = v29;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v41, 4);
    v19 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v40, "transposeDimension:withDimension:", 2, 3);
    if (v21 >= 2)
      objc_msgSend(v40, "reshapeWithShape:", v36);
    goto LABEL_8;
  }
  if (a4 == 3)
  {
    objc_msgSend(v40, "getShape");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "objectAtIndexedSubscript:", 3);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = objc_msgSend(v8, "unsignedIntegerValue");

    objc_msgSend(v7, "objectAtIndexedSubscript:", 2);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = objc_msgSend(v10, "unsignedIntegerValue");

    objc_msgSend(v7, "objectAtIndexedSubscript:", 0);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v45[0] = v12;
    objc_msgSend(v7, "objectAtIndexedSubscript:", 1);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = v11 * v9;
    v45[1] = v13;
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", v14);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v45[2] = v15;
    v45[3] = &unk_1E0E98740;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v45, 4);
    v36 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", v14);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v44[0] = v16;
    v44[1] = &unk_1E0E98740;
    objc_msgSend(v7, "objectAtIndexedSubscript:", 0);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    v44[2] = v17;
    objc_msgSend(v7, "objectAtIndexedSubscript:", 1);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v44[3] = v18;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v44, 4);
    v19 = (void *)objc_claimAutoreleasedReturnValue();

    if (v9 >= 2)
      objc_msgSend(v40, "reshapeWithShape:", v36);
    v43[4] = xmmword_181287230;
    v43[5] = unk_181287240;
    v43[6] = xmmword_181287250;
    v43[7] = unk_181287260;
    v43[0] = xmmword_1812871F0;
    v43[1] = unk_181287200;
    v43[2] = xmmword_181287210;
    v43[3] = unk_181287220;
    objc_msgSend(v40, "permuteWithDimensionOrder:", v43);
LABEL_8:

    goto LABEL_13;
  }
  if (MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v19 = 0;
LABEL_13:
  v30 = *((_QWORD *)a2 + 1);
  GPU::EncodeDescriptor::getcomputeEncoder(a2);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v38, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v30, v31, v40, a5);
  v32 = (void *)objc_claimAutoreleasedReturnValue();

  if (a5 != 1 && !v32)
    __assert_rtn("permuteWeights", "GPUDepthwiseConvOps.mm", 412, "transWeights || aliasing==MPSAliasingStrategyShallAlias");
  if (v32)
  {
    v33 = v32;
    *(_QWORD *)a1 = v33;
    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CC6FE0], "descriptorWithDataType:shape:", objc_msgSend(v40, "dataType"), v19);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v34, "setPreferPackedRows:", 1);
    objc_msgSend(MEMORY[0x1E0CC7240], "temporaryNDArrayWithCommandBuffer:descriptor:", *((_QWORD *)a2 + 1), v34);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v35)
      __assert_rtn("permuteWeights", "GPUDepthwiseConvOps.mm", 423, "transWeights");
    v33 = v35;
    *(_QWORD *)a1 = v33;
    *(_BYTE *)(a1 + 8) = 1;

  }
}

void sub_180E18538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void GPU::DepthwiseConv2DDataGradientOpHandler::encodeNDArrayOp(GPU::DepthwiseConv2DDataGradientOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v5;
  void *v6;
  char *Input;
  char *Filter;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  id v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  id v16;
  uint64_t v17;
  char *StaticType;
  uint64_t Value;
  unint64_t v20;
  uint64_t *v21;
  uint64_t Result;
  char *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  void *v28;
  int StorageType;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t NumElements;
  unsigned int v35;
  unint64_t v36;
  unint64_t v37;
  BOOL v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  BOOL v48;
  int v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int j;
  BOOL v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int v72;
  BOOL v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int i;
  BOOL v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  int PaddingStyle;
  uint64_t *v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  int v103;
  char *v104;
  id v105;
  int v106;
  char *v107;
  void *v108;
  void *v109;
  void *v110;
  uint64_t v111;
  void *v112;
  void *v113;
  void *v114;
  const char *v115;
  int v116;
  const char *v117;
  const char *v118;
  const char *v119;
  int v120;
  const char *v121;
  const char *v122;
  const char *v123;
  int v124;
  const char *v125;
  const char *v126;
  _QWORD *AttrData;
  uint64_t v128;
  BOOL v129;
  BOOL v130;
  BOOL v131;
  unint64_t v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  void *v137;
  GPU::EncodeDescriptor *v138;
  id v139;
  NSArray *v140;
  void *v141;
  void *v142;
  void *v143;
  uint64_t v144;
  const char *v145;
  uint64_t v146;
  uint64_t v147;
  __int16 v148;
  const char *v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t v152;
  __int16 v153;
  char *v154;
  id v155;
  uint64_t v156;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  uint64_t Strides;
  uint64_t v160;
  _QWORD v161[2];
  _QWORD v162[2];
  _QWORD v163[4];

  v163[2] = *MEMORY[0x1E0C80C00];
  v140 = a3;
  v5 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v154 = *(char **)(v5 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v154);
    if (v128 == 35)
    {
      v129 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      v130 = v129 && AttrData[2] == 0x61645F64325F766ELL;
      v131 = v130 && AttrData[3] == 0x69646172675F6174;
      if (v131 && *(_QWORD *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        v153 = 1283;
        v149 = "classof on '";
        v151 = (uint64_t)"mps.depthwise_conv_2d_data_gradient";
        v152 = 35;
        v145 = "' failed due to the operation not being registered";
        v148 = 259;
        llvm::operator+((uint64_t *)&v149, (uint64_t *)&v145, (uint64_t)&v154);
        llvm::report_fatal_error((llvm::Twine *)&v154, 1);
      }
    }
LABEL_247:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id)
    goto LABEL_247;
  v144 = *((_QWORD *)this + 3);
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v144);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v144);
  v9 = *((_QWORD *)this + 2);
  v154 = Input;
  v149 = (const char *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v154) + 2);
  v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v9 + 88), (uint64_t *)&v149);
  if (v10
    && (v145 = v154,
        (v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&v145)) != 0))
  {
    v12 = (id)v11[3];
  }
  else
  {
    v12 = 0;
  }
  v138 = a2;
  objc_msgSend(v12, "mpsndarray");
  v142 = (void *)objc_claimAutoreleasedReturnValue();

  v13 = *((_QWORD *)this + 2);
  v154 = Filter;
  v149 = (const char *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v154) + 2);
  v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v13 + 88), (uint64_t *)&v149);
  if (v14
    && (v145 = v154,
        (v15 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v14 + 3, (uint64_t *)&v145)) != 0))
  {
    v16 = (id)v15[3];
  }
  else
  {
    v16 = 0;
  }
  objc_msgSend(v16, "mpsndarray");
  v141 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSArray objectAtIndexedSubscript:](v140, "objectAtIndexedSubscript:", 0);
  v137 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v137, "mpsndarray");
  v143 = (void *)objc_claimAutoreleasedReturnValue();
  if ((!v142 || !v141 || !v143) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (*((_QWORD *)this + 4) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v17 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v144);
  StaticType = (char *)GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), v17);
  if (!*(_QWORD *)StaticType)
  {
    v119 = "abstractType && \"Malformed type storage object.\"";
    v120 = 160;
    v121 = "TypeSupport.h";
    v122 = "getAbstractType";
    goto LABEL_221;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v119 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v120 = 566;
    v121 = "Casting.h";
    v122 = "cast";
LABEL_221:
    __assert_rtn(v122, v121, v120, v119);
  }
  v154 = StaticType;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v154);
  v136 = v20;
  v21 = (uint64_t *)Value;
  Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v144);
  v23 = (char *)GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Result);
  if (!*(_QWORD *)v23)
  {
    v123 = "abstractType && \"Malformed type storage object.\"";
    v124 = 160;
    v125 = "TypeSupport.h";
    v126 = "getAbstractType";
    goto LABEL_224;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v23 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v123 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v124 = 566;
    v125 = "Casting.h";
    v126 = "cast";
LABEL_224:
    __assert_rtn(v126, v125, v124, v123);
  }
  v154 = v23;
  v24 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v154);
  v26 = v25;
  v27 = v144;
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v160 = v27;
  v139 = v28;
  Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v160);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v160);
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v160);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v160);
  if (StorageType)
  {
    if (StorageType == 1)
    {
      if (v26 >= 4)
      {
        v31 = v24[1];
        v30 = v24[2];
        v32 = v24[3];
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v154, Strides, 0);
        v134 = v30;
        v135 = v32;
        v133 = v31;
        v33 = Strides;
        NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v149, v33, NumElements);
        v35 = 0;
        v36 = 1;
        v37 = 1;
        while (1)
        {
          v38 = v154 == v149 && v155 == v150;
          if (v38 && v156 == v151)
            break;
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v154, (llvm::APInt *)&v145);
          v39 = v146;
          if (v146 < 0x41)
          {
            v40 = (uint64_t)v145;
LABEL_32:
            v41 = v40;
            switch(v35)
            {
              case 0u:
                if (v40 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
                  goto LABEL_41;
                goto LABEL_44;
              case 1u:
                goto LABEL_45;
              case 2u:
                v41 = v36;
                v37 = v40;
                break;
              case 3u:
                if (v40 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
                  goto LABEL_41;
                goto LABEL_44;
              default:
                goto LABEL_40;
            }
            goto LABEL_45;
          }
          if (v39 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v145) <= 0x40)
          {
            v40 = *(_QWORD *)v145;
            if (v35 <= 3)
              goto LABEL_32;
          }
          else
          {
            v40 = -1;
            if (v35 <= 3)
              goto LABEL_32;
          }
LABEL_40:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_41:
            MTLReportFailure();
            v41 = v36;
          }
          else
          {
LABEL_44:
            v41 = v36;
          }
LABEL_45:
          if (v146 >= 0x41)
          {
            if (v145)
              MEMORY[0x186DA165C](v145, 0x1000C8000313F17);
          }
          ++v156;
          ++v35;
          v36 = v41;
        }
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v154, InputAttributeNames, 0);
        v70 = InputAttributeNames;
        v71 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v149, v70, v71);
        v72 = 0;
        v55 = 1;
        v56 = 1;
        while (1)
        {
          v73 = v154 == v149 && v155 == v150;
          if (v73 && v156 == v151)
          {
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v154, Rewriter, 0);
            v77 = Rewriter;
            v78 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v149, v77, v78);
            v63 = 0;
            v64 = 0;
            for (i = 0; ; ++i)
            {
              v80 = v154 == v149 && v155 == v150;
              if (v80 && v156 == v151)
                break;
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v154, (llvm::APInt *)&v145);
              v81 = v146;
              if (v146 >= 0x41)
              {
                if (v81 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v145) <= 0x40)
                  v82 = *(_QWORD *)v145;
                else
                  v82 = -1;
              }
              else
              {
                v82 = (uint64_t)v145;
              }
              if (i == 2)
                v83 = v82;
              else
                v83 = v64;
              if (i == 4)
                v63 = v82;
              else
                v64 = v83;
              if (v81 >= 0x41 && v145)
                MEMORY[0x186DA165C](v145, 0x1000C8000313F17);
              ++v156;
            }
            goto LABEL_181;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v154, (llvm::APInt *)&v145);
          v74 = v146;
          if (v146 < 0x41)
            break;
          if (v74 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v145) <= 0x40)
          {
            v75 = *(_QWORD *)v145;
            if (v72 <= 3)
              goto LABEL_141;
          }
          else
          {
            v75 = -1;
            if (v72 <= 3)
              goto LABEL_141;
          }
LABEL_149:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_150:
            MTLReportFailure();
            v76 = v55;
          }
          else
          {
LABEL_153:
            v76 = v55;
          }
LABEL_154:
          if (v146 >= 0x41 && v145)
            MEMORY[0x186DA165C](v145, 0x1000C8000313F17);
          ++v156;
          ++v72;
          v55 = v76;
        }
        v75 = (uint64_t)v145;
LABEL_141:
        v76 = v75;
        switch(v72)
        {
          case 0u:
            if (v75 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_150;
            goto LABEL_153;
          case 1u:
            goto LABEL_154;
          case 2u:
            v76 = v55;
            v56 = v75;
            break;
          case 3u:
            if (v75 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_150;
            goto LABEL_153;
          default:
            goto LABEL_149;
        }
        goto LABEL_154;
      }
      goto LABEL_213;
    }
    v115 = "0 && \"Unsupported dataLayout\"";
    v116 = 200;
LABEL_245:
    v117 = "GPUDepthwiseConvOps.mm";
    v118 = "createDepthwiseConv2D";
LABEL_214:
    __assert_rtn(v118, v117, v116, v115);
  }
  if (v26 < 4)
    goto LABEL_213;
  v43 = v24[2];
  v42 = v24[3];
  v44 = v24[1];
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v154, Strides, 0);
  v134 = v42;
  v135 = v44;
  v133 = v43;
  v45 = Strides;
  v46 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v149, v45, v46);
  v47 = 0;
  v36 = 1;
  v37 = 1;
  while (1)
  {
    v48 = v154 == v149 && v155 == v150;
    if (v48 && v156 == v151)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v154, (llvm::APInt *)&v145);
    v49 = v146;
    if (v146 < 0x41)
    {
      v50 = (uint64_t)v145;
LABEL_61:
      v51 = v50;
      switch(v47)
      {
        case 0u:
          if (v50 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_70;
          goto LABEL_72;
        case 1u:
          if (v50 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_70;
          goto LABEL_72;
        case 2u:
          goto LABEL_73;
        case 3u:
          v51 = v36;
          v37 = v50;
          if (v146 >= 0x41)
            goto LABEL_74;
          break;
        default:
          goto LABEL_69;
      }
      goto LABEL_52;
    }
    if (v49 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v145) <= 0x40)
    {
      v50 = *(_QWORD *)v145;
      if (v47 <= 3)
        goto LABEL_61;
    }
    else
    {
      v50 = -1;
      if (v47 <= 3)
        goto LABEL_61;
    }
LABEL_69:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_70:
      MTLReportFailure();
      v51 = v36;
    }
    else
    {
LABEL_72:
      v51 = v36;
    }
LABEL_73:
    if (v146 >= 0x41)
    {
LABEL_74:
      if (v145)
        MEMORY[0x186DA165C](v145, 0x1000C8000313F17);
    }
LABEL_52:
    ++v156;
    ++v47;
    v36 = v51;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v154, InputAttributeNames, 0);
  v52 = InputAttributeNames;
  v53 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v149, v52, v53);
  v54 = 0;
  v55 = 1;
  v56 = 1;
  while (1)
  {
    v57 = v154 == v149 && v155 == v150;
    if (v57 && v156 == v151)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v154, (llvm::APInt *)&v145);
    v58 = v146;
    if (v146 < 0x41)
    {
      v59 = (uint64_t)v145;
LABEL_90:
      v60 = v59;
      switch(v54)
      {
        case 0u:
          if (v59 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_99;
          goto LABEL_101;
        case 1u:
          if (v59 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_99;
          goto LABEL_101;
        case 2u:
          goto LABEL_102;
        case 3u:
          v60 = v55;
          v56 = v59;
          if (v146 >= 0x41)
            goto LABEL_103;
          break;
        default:
          goto LABEL_98;
      }
      goto LABEL_81;
    }
    if (v58 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v145) <= 0x40)
    {
      v59 = *(_QWORD *)v145;
      if (v54 <= 3)
        goto LABEL_90;
    }
    else
    {
      v59 = -1;
      if (v54 <= 3)
        goto LABEL_90;
    }
LABEL_98:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_99:
      MTLReportFailure();
      v60 = v55;
    }
    else
    {
LABEL_101:
      v60 = v55;
    }
LABEL_102:
    if (v146 >= 0x41)
    {
LABEL_103:
      if (v145)
        MEMORY[0x186DA165C](v145, 0x1000C8000313F17);
    }
LABEL_81:
    ++v156;
    ++v54;
    v55 = v60;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v154, Rewriter, 0);
  v61 = Rewriter;
  v62 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v149, v61, v62);
  v63 = 0;
  v64 = 0;
  for (j = 0; ; ++j)
  {
    v66 = v154 == v149 && v155 == v150;
    if (v66 && v156 == v151)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v154, (llvm::APInt *)&v145);
    v67 = v146;
    if (v146 >= 0x41)
    {
      if (v67 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v145) <= 0x40)
        v68 = *(_QWORD *)v145;
      else
        v68 = -1;
    }
    else
    {
      v68 = (uint64_t)v145;
    }
    if (j == 4)
      v69 = v68;
    else
      v69 = v64;
    if (j == 6)
      v63 = v68;
    else
      v64 = v69;
    if (v67 >= 0x41 && v145)
      MEMORY[0x186DA165C](v145, 0x1000C8000313F17);
    ++v156;
  }
LABEL_181:
  PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v160);
  if (PaddingStyle == 2)
  {
    if (v136 > 3)
    {
      v85 = v21 + 3;
      v86 = v21 + 1;
      v21 += 2;
      goto LABEL_187;
    }
    goto LABEL_213;
  }
  if (PaddingStyle != 3)
  {
    v115 = "0 && \"Unsupported weightsFormat\"";
    v116 = 219;
    goto LABEL_245;
  }
  if (v136 <= 3)
  {
LABEL_213:
    v115 = "Index < Length && \"Invalid index!\"";
    v116 = 257;
    v117 = "ArrayRef.h";
    v118 = "operator[]";
    goto LABEL_214;
  }
  v85 = v21 + 1;
  v86 = v21 + 2;
LABEL_187:
  v87 = *v85;
  v88 = *v21;
  if (v135 != *v86 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v89 = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v160);
  v90 = (v87 - 1) * v56 + 1;
  v91 = (v88 - 1) * v55 + 1;
  switch(v89)
  {
    case 0:
      break;
    case 1:
      v63 = 0;
      v64 = 0;
      break;
    case 2:
    case 4:
      v92 = v133 % v36;
      if (!(v133 % v36))
        v92 = v36;
      v93 = (v91 - v92) & ~((uint64_t)(v91 - v92) >> 63);
      v94 = v134 % v37;
      if (!(v134 % v37))
        v94 = v37;
      v95 = (v90 - v94) & ~((uint64_t)(v90 - v94) >> 63);
      v96 = v93 >> 1;
      v97 = v93 - (v93 >> 1);
      v98 = v95 >> 1;
      v99 = v95 - (v95 >> 1);
      if (v89 == 4)
        v63 = v99;
      else
        v63 = v98;
      if (v89 == 4)
        v64 = v97;
      else
        v64 = v96;
      break;
    default:
      __assert_rtn("createDepthwiseConv2D", "GPUDepthwiseConvOps.mm", 261, "0 && \"Unsupported paddingStyle\"");
  }
  if (v90 >= 0)
    v100 = (v87 - 1) * v56 + 1;
  else
    v100 = (v87 - 1) * v56 + 2;
  if (v91 >= 0)
    v101 = (v88 - 1) * v55 + 1;
  else
    v101 = (v88 - 1) * v55 + 2;
  v102 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6FD8]), "initWithDevice:", v139);
  v154 = (char *)((v100 >> 1) - v63);
  v155 = (id)((v101 >> 1) - v64);
  v156 = 0;
  objc_msgSend(v102, "setWindowOffsets:", &v154);
  v149 = (const char *)v37;
  v150 = v36;
  v151 = 1;
  objc_msgSend(v102, "setConvStrides:", &v149);
  v145 = (const char *)v56;
  v146 = v55;
  v147 = 1;
  objc_msgSend(v102, "setConvDilationRates:", &v145);
  objc_msgSend(v102, "setOptions:", objc_msgSend(v102, "options") | 1);

  if (*((_BYTE *)v143 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v143, "setReadCount:", objc_msgSend(v143, "readCount") + 1);
  v103 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v144);
  v104 = v154;
  v105 = v155;
  v106 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v144);
  v107 = (char *)v149;
  if (*((_BYTE *)v105 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v105, "setReadCount:", objc_msgSend(v105, "readCount") + 1);
  v163[0] = v105;
  v163[1] = v107;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v163, 2);
  v108 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v102, "resultStateForSourceArrays:sourceStates:destinationArray:", v108, 0, v105);
  v109 = (void *)objc_claimAutoreleasedReturnValue();

  GPU::EncodeDescriptor::getcomputeEncoder(v138);
  v110 = (void *)objc_claimAutoreleasedReturnValue();
  v111 = *((_QWORD *)v138 + 1);
  v162[0] = v105;
  v162[1] = v107;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v162, 2);
  v112 = (void *)objc_claimAutoreleasedReturnValue();
  v161[0] = v105;
  objc_msgSend(MEMORY[0x1E0C99E38], "null");
  v113 = (void *)objc_claimAutoreleasedReturnValue();
  v161[1] = v113;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v161, 2);
  v114 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v102, "encodeGradientsToCommandEncoder:commandBuffer:sourceArrays:sourceGradient:gradientState:destinationGradients:kernelDAGObject:", v110, v111, v112, v104, v109, v114, 0);

  if (*((_BYTE *)v105 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v105, "setReadCount:", objc_msgSend(v105, "readCount") - 1);

}

void sub_180E198B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{

  _Unwind_Resume(a1);
}

unint64_t GPU::DepthwiseConv2DDataGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 2)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 2u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::DepthwiseConv2DWeightsGradientOpHandler::encodeNDArrayOp(GPU::DepthwiseConv2DWeightsGradientOpHandler *this, id *a2, NSArray *a3)
{
  uint64_t v4;
  void *v5;
  uint64_t Input;
  uint64_t Filter;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  id v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  id v15;
  uint64_t Result;
  unint64_t StaticType;
  uint64_t *Value;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  int StorageType;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t NumElements;
  unsigned int v32;
  unint64_t v33;
  unint64_t v34;
  BOOL v35;
  int v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  BOOL v45;
  int v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int j;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  BOOL v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int i;
  BOOL v77;
  unsigned int v78;
  uint64_t v79;
  uint64_t v80;
  int PaddingStyle;
  uint64_t *v82;
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  int v100;
  int *v101;
  int v102;
  id v103;
  void *v104;
  int v105;
  void *v106;
  void *v107;
  id v108;
  void *v109;
  void *v110;
  void *v111;
  int v112;
  id v113;
  void *v114;
  void *v115;
  char *v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  void *v123;
  void *v124;
  id v125;
  void *v126;
  void *v127;
  void *v128;
  id v129;
  void *v130;
  uint64_t v131;
  void *v132;
  void *v133;
  id v134;
  void *v135;
  const char *v136;
  int v137;
  const char *v138;
  const char *v139;
  const char *v140;
  int v141;
  const char *v142;
  const char *v143;
  const char *v144;
  int v145;
  const char *v146;
  const char *v147;
  _QWORD *AttrData;
  uint64_t v149;
  BOOL v150;
  BOOL v151;
  BOOL v152;
  void *v154;
  id v155;
  unint64_t v156;
  void *v157;
  void *v158;
  unint64_t v159;
  void *v160;
  uint64_t v161;
  void *v162;
  NSArray *v163;
  unint64_t v164;
  id v165;
  void *v166;
  void *v167;
  id v168;
  char *v169;
  void *v170;
  GPU::DepthwiseConv2DWeightsGradientOpHandler *v172;
  id v173;
  unsigned __int8 v174;
  void *v175;
  char *v176;
  id v177;
  uint64_t v178;
  __int16 v179;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  _QWORD v182[2];
  _QWORD v183[2];
  _QWORD v184[2];
  const char *v185;
  unint64_t v186;
  uint64_t v187;
  uint64_t v188;
  __int16 v189;
  uint64_t Strides;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  uint64_t v199;

  v199 = *MEMORY[0x1E0C80C00];
  v163 = a3;
  v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(_QWORD *)&v191 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v191);
    if (v149 == 38)
    {
      v150 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      v151 = v150 && AttrData[2] == 0x65775F64325F766ELL;
      v152 = v151 && AttrData[3] == 0x72675F7374686769;
      if (v152 && *(_QWORD *)((char *)AttrData + 30) == 0x746E656964617267)
      {
        v189 = 1283;
        v185 = "classof on '";
        v187 = (uint64_t)"mps.depthwise_conv_2d_weights_gradient";
        v188 = 38;
        v176 = "' failed due to the operation not being registered";
        v179 = 259;
        llvm::operator+((uint64_t *)&v185, (uint64_t *)&v176, (uint64_t)&v191);
        llvm::report_fatal_error((llvm::Twine *)&v191, 1);
      }
    }
LABEL_260:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DWeightsGradientOp,void>::id)
    goto LABEL_260;
  v175 = (void *)*((_QWORD *)this + 3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v175);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v175);
  v8 = *((_QWORD *)this + 2);
  *(_QWORD *)&v191 = Input;
  v185 = (const char *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v191) + 2);
  v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v8 + 88), (uint64_t *)&v185);
  if (v9
    && (v176 = (char *)v191,
        (v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, (uint64_t *)&v176)) != 0))
  {
    v11 = (id)v10[3];
  }
  else
  {
    v11 = 0;
  }
  v172 = this;
  objc_msgSend(v11, "mpsndarray");
  v167 = (void *)objc_claimAutoreleasedReturnValue();

  v12 = *((_QWORD *)this + 2);
  *(_QWORD *)&v191 = Filter;
  v185 = (const char *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v191) + 2);
  v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v12 + 88), (uint64_t *)&v185);
  if (v13
    && (v176 = (char *)v191,
        (v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v13 + 3, (uint64_t *)&v176)) != 0))
  {
    v15 = (id)v14[3];
  }
  else
  {
    v15 = 0;
  }
  objc_msgSend(v15, "mpsndarray");
  v166 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSArray objectAtIndexedSubscript:](v163, "objectAtIndexedSubscript:", 0);
  v158 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v158, "mpsndarray");
  v170 = (void *)objc_claimAutoreleasedReturnValue();
  if ((!v167 || !v166 || !v170) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (*((_QWORD *)this + 4) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v175);
  StaticType = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Result);
  if (!*(_QWORD *)StaticType)
  {
    v140 = "abstractType && \"Malformed type storage object.\"";
    v141 = 160;
    v142 = "TypeSupport.h";
    v143 = "getAbstractType";
    goto LABEL_233;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v140 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v141 = 566;
    v142 = "Casting.h";
    v143 = "cast";
LABEL_233:
    __assert_rtn(v143, v142, v141, v140);
  }
  *(_QWORD *)&v191 = StaticType;
  Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v191);
  v20 = v19;
  v21 = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Filter);
  if (!*(_QWORD *)v21)
  {
    v144 = "abstractType && \"Malformed type storage object.\"";
    v145 = 160;
    v146 = "TypeSupport.h";
    v147 = "getAbstractType";
    goto LABEL_236;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v21 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v144 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v145 = 566;
    v146 = "Casting.h";
    v147 = "cast";
LABEL_236:
    __assert_rtn(v147, v146, v145, v144);
  }
  *(_QWORD *)&v191 = v21;
  v22 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v191);
  v24 = v23;
  v164 = v20;
  v25 = v175;
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v173 = v25;
  v168 = (id)objc_claimAutoreleasedReturnValue();
  Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v173);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v173);
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v173);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v173);
  if (StorageType)
  {
    if (StorageType == 1)
    {
      if (v24 >= 4)
      {
        v28 = v22[1];
        v27 = v22[2];
        v29 = v22[3];
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, Strides, 0);
        v159 = v27;
        v161 = v29;
        v156 = v28;
        v30 = Strides;
        NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v30, NumElements);
        v32 = 0;
        v33 = 1;
        v34 = 1;
        while (1)
        {
          v35 = (const char *)v191 == v185 && BYTE8(v191) == v186;
          if (v35 && (_QWORD)v192 == v187)
            break;
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
          v36 = (int)v177;
          if (v177 < 0x41)
          {
            v37 = (uint64_t)v176;
LABEL_32:
            v38 = v37;
            switch(v32)
            {
              case 0u:
                if (v37 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
                  goto LABEL_41;
                goto LABEL_44;
              case 1u:
                goto LABEL_45;
              case 2u:
                v38 = v33;
                v34 = v37;
                break;
              case 3u:
                if (v37 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
                  goto LABEL_41;
                goto LABEL_44;
              default:
                goto LABEL_40;
            }
            goto LABEL_45;
          }
          if (v36 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
          {
            v37 = *(_QWORD *)v176;
            if (v32 <= 3)
              goto LABEL_32;
          }
          else
          {
            v37 = -1;
            if (v32 <= 3)
              goto LABEL_32;
          }
LABEL_40:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_41:
            MTLReportFailure();
            v38 = v33;
          }
          else
          {
LABEL_44:
            v38 = v33;
          }
LABEL_45:
          if (v177 >= 0x41)
          {
            if (v176)
              MEMORY[0x186DA165C](v176, 0x1000C8000313F17);
          }
          *(_QWORD *)&v192 = v192 + 1;
          ++v32;
          v33 = v38;
        }
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, InputAttributeNames, 0);
        v67 = InputAttributeNames;
        v68 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
        mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v67, v68);
        v69 = 0;
        v52 = 1;
        v53 = 1;
        while (1)
        {
          v70 = (const char *)v191 == v185 && BYTE8(v191) == v186;
          if (v70 && (_QWORD)v192 == v187)
          {
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, Rewriter, 0);
            v74 = Rewriter;
            v75 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
            mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v74, v75);
            v60 = 0;
            v61 = 0;
            for (i = 0; ; ++i)
            {
              v77 = (const char *)v191 == v185 && BYTE8(v191) == v186;
              if (v77 && (_QWORD)v192 == v187)
                break;
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
              v78 = v177;
              if (v177 >= 0x41)
              {
                if (v78 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
                  v79 = *(_QWORD *)v176;
                else
                  v79 = -1;
              }
              else
              {
                v79 = (uint64_t)v176;
              }
              if (i == 2)
                v80 = v79;
              else
                v80 = v61;
              if (i == 4)
                v60 = v79;
              else
                v61 = v80;
              if (v78 >= 0x41 && v176)
                MEMORY[0x186DA165C](v176, 0x1000C8000313F17);
              *(_QWORD *)&v192 = v192 + 1;
            }
            goto LABEL_181;
          }
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
          v71 = (int)v177;
          if (v177 < 0x41)
            break;
          if (v71 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
          {
            v72 = *(_QWORD *)v176;
            if (v69 <= 3)
              goto LABEL_141;
          }
          else
          {
            v72 = -1;
            if (v69 <= 3)
              goto LABEL_141;
          }
LABEL_149:
          if (MTLReportFailureTypeEnabled())
          {
LABEL_150:
            MTLReportFailure();
            v73 = v52;
          }
          else
          {
LABEL_153:
            v73 = v52;
          }
LABEL_154:
          if (v177 >= 0x41 && v176)
            MEMORY[0x186DA165C](v176, 0x1000C8000313F17);
          *(_QWORD *)&v192 = v192 + 1;
          ++v69;
          v52 = v73;
        }
        v72 = (uint64_t)v176;
LABEL_141:
        v73 = v72;
        switch(v69)
        {
          case 0u:
            if (v72 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_150;
            goto LABEL_153;
          case 1u:
            goto LABEL_154;
          case 2u:
            v73 = v52;
            v53 = v72;
            break;
          case 3u:
            if (v72 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_150;
            goto LABEL_153;
          default:
            goto LABEL_149;
        }
        goto LABEL_154;
      }
      goto LABEL_225;
    }
    v136 = "0 && \"Unsupported dataLayout\"";
    v137 = 200;
LABEL_258:
    v138 = "GPUDepthwiseConvOps.mm";
    v139 = "createDepthwiseConv2D";
LABEL_226:
    __assert_rtn(v139, v138, v137, v136);
  }
  if (v24 < 4)
    goto LABEL_225;
  v40 = v22[2];
  v39 = v22[3];
  v41 = v22[1];
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, Strides, 0);
  v159 = v39;
  v161 = v41;
  v156 = v40;
  v42 = Strides;
  v43 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v42, v43);
  v44 = 0;
  v33 = 1;
  v34 = 1;
  while (1)
  {
    v45 = (const char *)v191 == v185 && BYTE8(v191) == v186;
    if (v45 && (_QWORD)v192 == v187)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
    v46 = (int)v177;
    if (v177 < 0x41)
    {
      v47 = (uint64_t)v176;
LABEL_61:
      v48 = v47;
      switch(v44)
      {
        case 0u:
          if (v47 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_70;
          goto LABEL_72;
        case 1u:
          if (v47 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_70;
          goto LABEL_72;
        case 2u:
          goto LABEL_73;
        case 3u:
          v48 = v33;
          v34 = v47;
          if (v177 >= 0x41)
            goto LABEL_74;
          break;
        default:
          goto LABEL_69;
      }
      goto LABEL_52;
    }
    if (v46 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
    {
      v47 = *(_QWORD *)v176;
      if (v44 <= 3)
        goto LABEL_61;
    }
    else
    {
      v47 = -1;
      if (v44 <= 3)
        goto LABEL_61;
    }
LABEL_69:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_70:
      MTLReportFailure();
      v48 = v33;
    }
    else
    {
LABEL_72:
      v48 = v33;
    }
LABEL_73:
    if (v177 >= 0x41)
    {
LABEL_74:
      if (v176)
        MEMORY[0x186DA165C](v176, 0x1000C8000313F17);
    }
LABEL_52:
    *(_QWORD *)&v192 = v192 + 1;
    ++v44;
    v33 = v48;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, InputAttributeNames, 0);
  v49 = InputAttributeNames;
  v50 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v49, v50);
  v51 = 0;
  v52 = 1;
  v53 = 1;
  while (1)
  {
    v54 = (const char *)v191 == v185 && BYTE8(v191) == v186;
    if (v54 && (_QWORD)v192 == v187)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
    v55 = (int)v177;
    if (v177 < 0x41)
    {
      v56 = (uint64_t)v176;
LABEL_90:
      v57 = v56;
      switch(v51)
      {
        case 0u:
          if (v56 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_99;
          goto LABEL_101;
        case 1u:
          if (v56 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_99;
          goto LABEL_101;
        case 2u:
          goto LABEL_102;
        case 3u:
          v57 = v52;
          v53 = v56;
          if (v177 >= 0x41)
            goto LABEL_103;
          break;
        default:
          goto LABEL_98;
      }
      goto LABEL_81;
    }
    if (v55 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
    {
      v56 = *(_QWORD *)v176;
      if (v51 <= 3)
        goto LABEL_90;
    }
    else
    {
      v56 = -1;
      if (v51 <= 3)
        goto LABEL_90;
    }
LABEL_98:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_99:
      MTLReportFailure();
      v57 = v52;
    }
    else
    {
LABEL_101:
      v57 = v52;
    }
LABEL_102:
    if (v177 >= 0x41)
    {
LABEL_103:
      if (v176)
        MEMORY[0x186DA165C](v176, 0x1000C8000313F17);
    }
LABEL_81:
    *(_QWORD *)&v192 = v192 + 1;
    ++v51;
    v52 = v57;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v191, Rewriter, 0);
  v58 = Rewriter;
  v59 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v185, v58, v59);
  v60 = 0;
  v61 = 0;
  for (j = 0; ; ++j)
  {
    v63 = (const char *)v191 == v185 && BYTE8(v191) == v186;
    if (v63 && (_QWORD)v192 == v187)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v191, (llvm::APInt *)&v176);
    v64 = v177;
    if (v177 >= 0x41)
    {
      if (v64 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v176) <= 0x40)
        v65 = *(_QWORD *)v176;
      else
        v65 = -1;
    }
    else
    {
      v65 = (uint64_t)v176;
    }
    if (j == 4)
      v66 = v65;
    else
      v66 = v61;
    if (j == 6)
      v60 = v65;
    else
      v61 = v66;
    if (v64 >= 0x41 && v176)
      MEMORY[0x186DA165C](v176, 0x1000C8000313F17);
    *(_QWORD *)&v192 = v192 + 1;
  }
LABEL_181:
  PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v173);
  if (PaddingStyle == 2)
  {
    if (v164 > 3)
    {
      v82 = Value + 3;
      v83 = Value + 1;
      Value += 2;
      goto LABEL_187;
    }
    goto LABEL_225;
  }
  if (PaddingStyle != 3)
  {
    v136 = "0 && \"Unsupported weightsFormat\"";
    v137 = 219;
    goto LABEL_258;
  }
  if (v164 <= 3)
  {
LABEL_225:
    v136 = "Index < Length && \"Invalid index!\"";
    v137 = 257;
    v138 = "ArrayRef.h";
    v139 = "operator[]";
    goto LABEL_226;
  }
  v82 = Value + 1;
  v83 = Value + 2;
LABEL_187:
  v84 = *v82;
  v85 = *Value;
  if (v161 != *v83 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v86 = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v173);
  v87 = (v84 - 1) * v53 + 1;
  v88 = (v85 - 1) * v52 + 1;
  switch(v86)
  {
    case 0:
      break;
    case 1:
      v60 = 0;
      v61 = 0;
      break;
    case 2:
    case 4:
      v89 = v156 % v33;
      if (!(v156 % v33))
        v89 = v33;
      v90 = (v88 - v89) & ~((uint64_t)(v88 - v89) >> 63);
      v91 = v159 % v34;
      if (!(v159 % v34))
        v91 = v34;
      v92 = (v87 - v91) & ~((uint64_t)(v87 - v91) >> 63);
      v93 = v90 >> 1;
      v94 = v90 - (v90 >> 1);
      v95 = v92 >> 1;
      v96 = v92 - (v92 >> 1);
      if (v86 == 4)
        v60 = v96;
      else
        v60 = v95;
      if (v86 == 4)
        v61 = v94;
      else
        v61 = v93;
      break;
    default:
      __assert_rtn("createDepthwiseConv2D", "GPUDepthwiseConvOps.mm", 261, "0 && \"Unsupported paddingStyle\"");
  }
  if (v87 >= 0)
    v97 = (v84 - 1) * v53 + 1;
  else
    v97 = (v84 - 1) * v53 + 2;
  if (v88 >= 0)
    v98 = v88;
  else
    v98 = v88 + 1;
  v99 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6FD8]), "initWithDevice:", v168);
  *(_QWORD *)&v191 = (v97 >> 1) - v60;
  *((_QWORD *)&v191 + 1) = (v98 >> 1) - v61;
  *(_QWORD *)&v192 = 0;
  objc_msgSend(v99, "setWindowOffsets:", &v191);
  v185 = (const char *)v34;
  v186 = v33;
  v187 = 1;
  objc_msgSend(v99, "setConvStrides:", &v185);
  v176 = (char *)v53;
  v177 = (id)v52;
  v178 = 1;
  objc_msgSend(v99, "setConvDilationRates:", &v176);
  objc_msgSend(v99, "setOptions:", objc_msgSend(v99, "options") | 1);

  v100 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v175);
  v169 = v176;
  v165 = v177;
  v101 = (int *)MEMORY[0x1E0CC7278];
  if (*((_BYTE *)v170 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v170, "setReadCount:", objc_msgSend(v170, "readCount") + 1);
  v102 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v175);
  v103 = v173;
  v104 = v103;
  v105 = v174;
  if (*((_BYTE *)v103 + *v101))
    objc_msgSend(v103, "setReadCount:", objc_msgSend(v103, "readCount") + 1);
  v184[0] = v169;
  v184[1] = v104;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v184, 2);
  v106 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v99, "resultStateForSourceArrays:sourceStates:destinationArray:", v106, 0, v104);
  v162 = (void *)objc_claimAutoreleasedReturnValue();

  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v107 = (void *)objc_claimAutoreleasedReturnValue();
  v108 = a2[1];
  v183[0] = v169;
  v183[1] = v104;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v183, 2);
  v109 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99E38], "null");
  v110 = (void *)objc_claimAutoreleasedReturnValue();
  v182[0] = v110;
  v182[1] = v104;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v182, 2);
  v111 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v99, "encodeGradientsToCommandEncoder:commandBuffer:sourceArrays:sourceGradient:gradientState:destinationGradients:kernelDAGObject:", v107, v108, v109, v165, v162, v111, 0);

  if (v105)
  {
    v112 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v175);
    v113 = v104;
    v155 = v170;
    v157 = v113;
    objc_msgSend(v113, "descriptor");
    v160 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v155, "descriptor");
    v154 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v154, "getShape");
    v114 = (void *)objc_claimAutoreleasedReturnValue();
    v115 = v114;
    if (v112 == 2)
    {
      objc_msgSend(v114, "objectAtIndexedSubscript:", 1);
      v121 = (void *)objc_claimAutoreleasedReturnValue();
      *(_QWORD *)&v191 = v121;
      objc_msgSend(v115, "objectAtIndexedSubscript:", 0);
      v122 = (void *)objc_claimAutoreleasedReturnValue();
      *((_QWORD *)&v191 + 1) = v122;
      objc_msgSend(v115, "objectAtIndexedSubscript:", 2);
      v123 = (void *)objc_claimAutoreleasedReturnValue();
      *(_QWORD *)&v192 = v123;
      objc_msgSend(v115, "objectAtIndexedSubscript:", 3);
      v124 = (void *)objc_claimAutoreleasedReturnValue();
      *((_QWORD *)&v192 + 1) = v124;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v191, 4);
      v120 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(v160, "reshapeWithShape:", v120);
      objc_msgSend(v160, "transposeDimension:withDimension:", 2, 3);
LABEL_217:

    }
    else
    {
      if (v112 == 3)
      {
        objc_msgSend(v114, "objectAtIndexedSubscript:", 2);
        v116 = (char *)objc_claimAutoreleasedReturnValue();
        v185 = v116;
        objc_msgSend(v115, "objectAtIndexedSubscript:", 3);
        v117 = (void *)objc_claimAutoreleasedReturnValue();
        v186 = (unint64_t)v117;
        objc_msgSend(v115, "objectAtIndexedSubscript:", 0);
        v118 = (void *)objc_claimAutoreleasedReturnValue();
        v187 = (uint64_t)v118;
        objc_msgSend(v115, "objectAtIndexedSubscript:", 1);
        v119 = (void *)objc_claimAutoreleasedReturnValue();
        v188 = (uint64_t)v119;
        objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v185, 4);
        v120 = (void *)objc_claimAutoreleasedReturnValue();

        v195 = xmmword_181287230;
        v196 = unk_181287240;
        v197 = xmmword_181287250;
        v198 = unk_181287260;
        v191 = xmmword_1812871F0;
        v192 = unk_181287200;
        v193 = xmmword_181287210;
        v194 = unk_181287220;
        objc_msgSend(v160, "reshapeWithShape:", v120);
        objc_msgSend(v160, "permuteWithDimensionOrder:", &v191);
        goto LABEL_217;
      }
      if (MTLReportFailureTypeEnabled())
        MTLReportFailure();
    }
    v125 = a2[1];
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v126 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v157, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v125, v126, v160, 1);
    v127 = (void *)objc_claimAutoreleasedReturnValue();

    if (!v127)
      __assert_rtn("permuteWeightsBack", "GPUDepthwiseConvOps.mm", 462, "tmp");
    v128 = (void *)*((_QWORD *)v172 + 1);
    if (!v128)
    {
      v129 = objc_alloc(MEMORY[0x1E0CC7030]);
      objc_msgSend(a2[1], "device");
      v130 = (void *)objc_claimAutoreleasedReturnValue();
      v131 = objc_msgSend(v129, "initWithDevice:", v130);
      v132 = (void *)*((_QWORD *)v172 + 1);
      *((_QWORD *)v172 + 1) = v131;

      objc_msgSend(*((id *)v172 + 1), "setOptions:", objc_msgSend(*((id *)v172 + 1), "options") | 1);
      v128 = (void *)*((_QWORD *)v172 + 1);
    }
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v133 = (void *)objc_claimAutoreleasedReturnValue();
    v134 = a2[1];
    Strides = (uint64_t)v127;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &Strides, 1);
    v135 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v128, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v133, v134, v135, v155);

  }
  else if (*((_BYTE *)v104 + *v101))
  {
    objc_msgSend(v104, "setReadCount:", objc_msgSend(v104, "readCount") - 1);
  }

}

void sub_180E1B014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, void *a20,uint64_t a21,void *a22)
{

  _Unwind_Resume(a1);
}

unint64_t GPU::DepthwiseConv2DWeightsGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 2)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 2u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::DepthwiseConv3DOpHandler::_createKernel(GPU::DepthwiseConv3DOpHandler *this)
{
  uint64_t v1;
  void *v2;
  uint64_t Filter;
  unint64_t StaticType;
  uint64_t Value;
  uint64_t v7;
  uint64_t v8;
  uint64_t Input;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void *v15;
  id v16;
  int ChannelAxis;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t NumElements;
  int v29;
  BOOL v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  BOOL v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  BOOL v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  uint64_t v52;
  uint64_t v53;
  _BOOL4 v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int PaddingStyle;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  const char *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  void *v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  void *v79;
  void *v80;
  _QWORD *AttrData;
  uint64_t v82;
  BOOL v83;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  id v89;
  uint64_t v90;
  __int128 v91;
  const char *v92;
  __int16 v93;
  const char *v94;
  uint64_t v95;
  const char *v96;
  uint64_t v97;
  __int16 v98;
  __int128 v99;
  uint64_t v100;
  __int128 v101;
  uint64_t v102;
  __int128 v103;
  unint64_t v104;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  uint64_t Strides;
  uint64_t v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(_QWORD *)&v109 = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v109);
    if (v82 == 21)
    {
      v83 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v83 && *(_QWORD *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        v98 = 1283;
        v94 = "classof on '";
        v96 = "mps.depthwise_conv_3d";
        v97 = 21;
        *(_QWORD *)&v91 = "' failed due to the operation not being registered";
        v93 = 259;
        llvm::operator+((uint64_t *)&v94, (uint64_t *)&v91, (uint64_t)&v109);
        llvm::report_fatal_error((llvm::Twine *)&v109, 1);
      }
    }
LABEL_134:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
    goto LABEL_134;
  v90 = *((_QWORD *)this + 3);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v90);
  StaticType = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Filter);
  if (!*(_QWORD *)StaticType)
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  if (*(_UNKNOWN **)(*(_QWORD *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  *(_QWORD *)&v109 = StaticType;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v109);
  v8 = v7;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v90);
  v10 = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Input);
  if (!*(_QWORD *)v10)
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  if (*(_UNKNOWN **)(*(_QWORD *)v10 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  *(_QWORD *)&v109 = v10;
  v11 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v109);
  v13 = v12;
  v14 = v90;
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v108 = v14;
  v16 = v15;
  Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v108);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v108);
  v110 = 0u;
  v111 = 0u;
  v109 = 0u;
  v88 = v8;
  v89 = v16;
  v85 = Value;
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v108);
  ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v108);
  if (ChannelAxis >= 0)
    v18 = v13;
  else
    v18 = 0;
  v86 = v18;
  v87 = ChannelAxis;
  if (ChannelAxis >= 0)
    v19 = 0;
  else
    v19 = v13;
  v103 = xmmword_181287390;
  v20 = 1;
  v104 = 1;
  v21 = v19 + ChannelAxis;
  v101 = xmmword_181287390;
  v102 = 1;
  v22 = 1;
  v23 = 1;
  if (v13 >= 3)
  {
    v24 = (int)(v13 - 1 - (v21 >= (int)v13 - 1));
    if (v13 <= v24
      || (v25 = (int)(v13 - 2 - (v21 >= (int)v13 - 2)), v13 <= v25)
      || (v26 = (int)(v13 - 3 - (v21 >= (int)v13 - 3)), v13 <= v26))
    {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    v23 = *(_QWORD *)(v11 + 8 * v24);
    v22 = *(_QWORD *)(v11 + 8 * v25);
    v20 = *(_QWORD *)(v11 + 8 * v26);
  }
  if (Strides && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, Strides, 0);
    v27 = Strides;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v91, v27, NumElements);
    v29 = 2;
    while (1)
    {
      v30 = v94 == (const char *)v91 && v95 == BYTE8(v91);
      if (v30 && v96 == v92)
        goto LABEL_35;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v94, (llvm::APInt *)&v99);
      v31 = DWORD2(v99);
      if (DWORD2(v99) < 0x41)
      {
        *((_QWORD *)&v103 + v29--) = v99;
        goto LABEL_22;
      }
      v32 = v31 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v99);
      v33 = v99;
      if (v32 <= 0x40)
        break;
      *((_QWORD *)&v103 + v29--) = -1;
      if (v33)
        goto LABEL_34;
LABEL_22:
      ++v96;
    }
    *((_QWORD *)&v103 + v29--) = *(_QWORD *)v99;
LABEL_34:
    MEMORY[0x186DA165C]();
    goto LABEL_22;
  }
LABEL_35:
  if (InputAttributeNames
    && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, InputAttributeNames, 0);
    v34 = InputAttributeNames;
    v35 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v91, v34, v35);
    v36 = 2;
    while (1)
    {
      v37 = v94 == (const char *)v91 && v95 == BYTE8(v91);
      if (v37 && v96 == v92)
        goto LABEL_52;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v94, (llvm::APInt *)&v99);
      v38 = DWORD2(v99);
      if (DWORD2(v99) < 0x41)
      {
        *((_QWORD *)&v101 + v36--) = v99;
        goto LABEL_39;
      }
      v39 = v38 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v99);
      v40 = v99;
      if (v39 <= 0x40)
        break;
      *((_QWORD *)&v101 + v36--) = -1;
      if (v40)
        goto LABEL_51;
LABEL_39:
      ++v96;
    }
    *((_QWORD *)&v101 + v36--) = *(_QWORD *)v99;
LABEL_51:
    MEMORY[0x186DA165C]();
    goto LABEL_39;
  }
LABEL_52:
  if (Rewriter && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter) == 6)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v94, Rewriter, 0);
    v41 = Rewriter;
    v42 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v91, v41, v42);
    v43 = 5;
    while (1)
    {
      v44 = v94 == (const char *)v91 && v95 == BYTE8(v91);
      if (v44 && v96 == v92)
        goto LABEL_69;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v94, (llvm::APInt *)&v99);
      v45 = DWORD2(v99);
      if (DWORD2(v99) < 0x41)
      {
        *((_QWORD *)&v109 + v43--) = v99;
        goto LABEL_56;
      }
      v46 = v45 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v99);
      v47 = v99;
      if (v46 <= 0x40)
        break;
      *((_QWORD *)&v109 + v43--) = -1;
      if (v47)
        goto LABEL_68;
LABEL_56:
      ++v96;
    }
    *((_QWORD *)&v109 + v43--) = *(_QWORD *)v99;
LABEL_68:
    MEMORY[0x186DA165C]();
    goto LABEL_56;
  }
LABEL_69:
  if (v88 == 4)
  {
    v48 = v21 - v13 + 4;
    v49 = 24;
    if (v48 > 2)
      v49 = 16;
    v50 = *(_QWORD *)(v85 + v49);
    v51 = __OFSUB__(v48, 1);
    v30 = v48 == 1;
    v52 = 8;
    if (((uint64_t)(v21 - v13 + 3) < 0) ^ v51 | v30)
      v52 = 16;
    v53 = *(_QWORD *)(v85 + v52);
    v54 = (uint64_t)(v21 - v13 + 3) < 0 != v51;
    v55 = v50 - 1;
    v56 = v53 - 1;
    v57 = *(_QWORD *)(v85 + 8 * v54) - 1;
  }
  else
  {
    v55 = 0;
    v56 = 0;
    v57 = 0;
  }
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v108);
  if (PaddingStyle >= 3 && PaddingStyle != 4)
    __assert_rtn("createDepthwiseConv3D", "GPUDepthwiseConvOps.mm", 791, "0 && \"Unknown paddingStyle\"");
  v59 = v101 * v55 + 1;
  if (PaddingStyle)
  {
    if (PaddingStyle == 2 || PaddingStyle == 4)
    {
      v60 = v103;
      if (v23 % (unint64_t)v103)
        v60 = v23 % (unint64_t)v103;
      v61 = (v59 - v60) & ~((uint64_t)(v59 - v60) >> 63);
      v62 = v61 >> 1;
      v63 = v61 - (v61 >> 1);
      if (PaddingStyle != 4)
        v63 = v62;
    }
    else
    {
      v63 = 0;
    }
    if (v59 < 0)
      v59 = v101 * v55 + 2;
    v64 = (const char *)((v59 >> 1) - v63);
    v65 = *((_QWORD *)&v101 + 1) * v56 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      v66 = *((_QWORD *)&v103 + 1);
      if (v22 % *((_QWORD *)&v103 + 1))
        v66 = v22 % *((_QWORD *)&v103 + 1);
      v67 = (v65 - v66) & ~((uint64_t)(v65 - v66) >> 63);
      v68 = v67 >> 1;
      v69 = v67 - (v67 >> 1);
      if (PaddingStyle != 4)
        v69 = v68;
    }
    else
    {
      v69 = 0;
    }
    v72 = v89;
    if (v65 < 0)
      v65 = *((_QWORD *)&v101 + 1) * v56 + 2;
    v70 = (v65 >> 1) - v69;
    v71 = v102 * v57 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      v73 = v104;
      if (v20 % v104)
        v73 = v20 % v104;
      v74 = (v71 - v73) & ~((uint64_t)(v71 - v73) >> 63);
      v75 = v74 >> 1;
      v76 = v74 - (v74 >> 1);
      if (PaddingStyle == 4)
        v77 = v76;
      else
        v77 = v75;
    }
    else
    {
      v77 = 0;
    }
  }
  else
  {
    if (v59 < 0)
      v59 = v101 * v55 + 2;
    v64 = (const char *)((v59 >> 1) - *((_QWORD *)&v109 + 1));
    v70 = (*((_QWORD *)&v101 + 1) * v56 + 1) / 2 - *((_QWORD *)&v110 + 1);
    v71 = v102 * v57 + 1;
    v72 = v89;
    v77 = *((_QWORD *)&v111 + 1);
  }
  if (v71 >= 0)
    v78 = v71;
  else
    v78 = v71 + 1;
  v79 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6FD8]), "initWithDevice:", v72);
  v94 = v64;
  v95 = v70;
  v96 = (const char *)((v78 >> 1) - v77);
  objc_msgSend(v79, "setWindowOffsets:", &v94);
  v91 = v103;
  v92 = (const char *)v104;
  objc_msgSend(v79, "setConvStrides:", &v91);
  v99 = v101;
  v100 = v102;
  objc_msgSend(v79, "setConvDilationRates:", &v99);
  objc_msgSend(v79, "setChannelAxis:", v86 + ~v87);
  objc_msgSend(v79, "setOptions:", objc_msgSend(v79, "options") | 1);

  v80 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = v79;

}

void sub_180E1BC8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

GPU::DepthwiseConv3DOpHandler **GPU::DepthwiseConv3DOpHandler::postInitializeHook(GPU::DepthwiseConv3DOpHandler **this)
{
  GPU::DepthwiseConv3DOpHandler *v1;
  uint64_t v2;
  _BYTE v3[8];

  if (*((_BYTE *)this + 40))
  {
    v1 = (GPU::DepthwiseConv3DOpHandler *)this;
    if (!this[4])
    {
      this = (GPU::DepthwiseConv3DOpHandler **)GPU::DepthwiseConv3DOpHandler::getQuantizationParameters(this[3], (mlir::Value *)v3, (mlir::Value *)&v2);
      if ((_DWORD)this)
        return (GPU::DepthwiseConv3DOpHandler **)GPU::DepthwiseConv3DOpHandler::_getQuantKernelDAGObject(v1);
    }
  }
  return this;
}

uint64_t GPU::DepthwiseConv3DOpHandler::getQuantizationParameters(GPU::DepthwiseConv3DOpHandler *this, mlir::Value *a2, mlir::Value *a3)
{
  uint64_t v3;
  void *v4;
  uint64_t DefiningOp;
  uint64_t v8;
  mlir::Operation *v9;
  mlir::Operation *v10;
  uint64_t Filter;
  mlir::Operation *v12;
  mlir::Operation *v13;
  int v14;
  unsigned int v15;
  BOOL v16;
  uint64_t v18;
  mlir::Operation *v19;
  mlir::Operation *v20;
  uint64_t v21;
  mlir::Operation *v22;
  mlir::Operation *v23;
  int v24;
  unsigned int v25;
  BOOL v26;
  _QWORD *AttrData;
  uint64_t v28;
  BOOL v29;
  BOOL (*v31)(llvm::APFloatBase *);
  uint64_t v32;
  uint64_t v33;
  GPU::DepthwiseConv3DOpHandler *v34;
  uint64_t v35[4];
  __int16 v36;
  uint64_t v37[4];
  __int16 v38;
  _QWORD *Input;
  unsigned int v40;

  v3 = *((_QWORD *)this + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    Input = *(_QWORD **)(v3 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&Input);
    if (v28 == 21)
    {
      v29 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v29 && *(_QWORD *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        v38 = 1283;
        v37[0] = (uint64_t)"classof on '";
        v37[2] = (uint64_t)"mps.depthwise_conv_3d";
        v37[3] = 21;
        v35[0] = (uint64_t)"' failed due to the operation not being registered";
        v36 = 259;
        llvm::operator+(v37, v35, (uint64_t)&Input);
        llvm::report_fatal_error((llvm::Twine *)&Input, 1);
      }
    }
LABEL_83:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
    goto LABEL_83;
  v34 = this;
  Input = (_QWORD *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (DefiningOp)
    DefiningOp = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible(DefiningOp);
  v33 = DefiningOp;
  Input = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v34);
  v8 = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (v8)
  {
    v32 = llvm::DefaultDoCastIfPossible<mlir::mps::DequantizeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DequantizeOp,mlir::Operation *,void>>::doCastIfPossible(v8);
    if ((v32 == 0) == (v33 == 0))
    {
      if (v33)
        goto LABEL_8;
      return 0;
    }
  }
  else
  {
    v32 = 0;
    if (!v33)
      return 0;
  }
  if (MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (v33)
  {
LABEL_8:
    *(_QWORD *)a2 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v33);
    *(_QWORD *)a3 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32);
    v31 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
    Input = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v33);
    if (!Input)
      goto LABEL_68;
    v9 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (v9
      && mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v31, v9))
    {
      v35[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v33);
      if (!v35[0])
        goto LABEL_68;
      v10 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v35);
      if (v10)
      {
        v40 = 1;
        Input = 0;
        v37[0] = (uint64_t)&Input;
        mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v10);
        if (v40 >= 0x41)
        {
          if (Input)
            MEMORY[0x186DA165C](Input, 0x1000C8000313F17);
        }
      }
    }
    Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v33);
    v31 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
    Input = (_QWORD *)Filter;
    if (!Filter)
      goto LABEL_68;
    v12 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (!v12
      || !mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v31, v12))
    {
      goto LABEL_36;
    }
    v35[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v33);
    if (!v35[0])
      goto LABEL_68;
    v13 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v35);
    if (!v13)
      goto LABEL_36;
    v40 = 1;
    Input = 0;
    v37[0] = (uint64_t)&Input;
    v14 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v13);
    v15 = v40;
    if (v14)
    {
      if (v40 < 0x41)
      {
        v16 = Input == 0;
        goto LABEL_32;
      }
      if (v15 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&Input) > 0x40)
      {
        if (Input)
          MEMORY[0x186DA165C](Input, 0x1000C8000313F17);
        goto LABEL_36;
      }
      v16 = *Input == 0;
    }
    else
    {
      v16 = 0;
      if (v40 < 0x41)
        goto LABEL_32;
    }
    if (Input)
      MEMORY[0x186DA165C](Input, 0x1000C8000313F17);
LABEL_32:
    if (v16)
    {
LABEL_38:
      v18 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v32);
      v31 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
      Input = (_QWORD *)v18;
      if (!v18)
        goto LABEL_68;
      v19 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Input);
      if (v19
        && mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v31, v19))
      {
        v35[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v32);
        if (!v35[0])
          goto LABEL_68;
        v20 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v35);
        if (v20)
        {
          v40 = 1;
          Input = 0;
          v37[0] = (uint64_t)&Input;
          mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v20);
          if (v40 >= 0x41)
          {
            if (Input)
              MEMORY[0x186DA165C](Input, 0x1000C8000313F17);
          }
        }
      }
      v21 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v32);
      v31 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
      Input = (_QWORD *)v21;
      if (v21)
      {
        v22 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Input);
        if (!v22
          || !mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v31, v22))
        {
          goto LABEL_65;
        }
        v35[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v32);
        if (v35[0])
        {
          v23 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v35);
          if (!v23)
            goto LABEL_65;
          v40 = 1;
          Input = 0;
          v37[0] = (uint64_t)&Input;
          v24 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v37, v23);
          v25 = v40;
          if (!v24)
          {
            v26 = 0;
            if (v40 < 0x41)
              goto LABEL_61;
            goto LABEL_58;
          }
          if (v40 < 0x41)
          {
            v26 = Input == 0;
            goto LABEL_61;
          }
          if (v25 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&Input) <= 0x40)
          {
            v26 = *Input == 0;
LABEL_58:
            if (Input)
            {
              MEMORY[0x186DA165C](Input, 0x1000C8000313F17);
              if (!v26)
                goto LABEL_65;
              return 1;
            }
LABEL_61:
            if (!v26)
              goto LABEL_65;
            return 1;
          }
          if (Input)
            MEMORY[0x186DA165C](Input, 0x1000C8000313F17);
LABEL_65:
          if (MTLReportFailureTypeEnabled())
          {
            MTLReportFailure();
            return 1;
          }
          return 1;
        }
      }
LABEL_68:
      __assert_rtn("matchPattern", "Matchers.h", 402, "value");
    }
LABEL_36:
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    goto LABEL_38;
  }
  return 0;
}

void sub_180E1C374(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  if (*(_DWORD *)(v1 - 64) >= 0x41u)
  {
    v3 = *(_QWORD *)(v1 - 72);
    if (v3)
      MEMORY[0x186DA165C](v3, 0x1000C8000313F17);
  }
  _Unwind_Resume(exception_object);
}

id GPU::DepthwiseConv3DOpHandler::_getQuantKernelDAGObject(GPU::DepthwiseConv3DOpHandler *this)
{
  uint64_t v2;
  id v3;
  GPU::MPSGraphKernelDAG *v4;
  uint64_t v5;
  uint64_t DAGOp;

  v2 = *((_QWORD *)this + 15);
  if (v2 && *((_BYTE *)this + 40))
  {
    if (*(_QWORD *)(v2 + 120) || !MTLReportFailureTypeEnabled())
    {
      v3 = *(id *)(*((_QWORD *)this + 15) + 120);
    }
    else
    {
      MTLReportFailure();
      v3 = *(id *)(*((_QWORD *)this + 15) + 120);
    }
  }
  else
  {
    v4 = (GPU::MPSGraphKernelDAG *)operator new();
    GPU::MPSGraphKernelDAG::MPSGraphKernelDAG(v4, *((GPURegionRuntime **)this + 2), 0);
    v5 = *((_QWORD *)this + 15);
    *((_QWORD *)this + 15) = v4;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      v4 = (GPU::MPSGraphKernelDAG *)*((_QWORD *)this + 15);
    }
    DAGOp = GPU::MPSGraphKernelDAG::createDAGOp(v4, this);
    if (!DAGOp && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    *(_QWORD *)(*((_QWORD *)this + 15) + 96) = DAGOp;
    GPU::MPSGraphKernelDAG::getKernelDAGObject(*((GPU::MPSGraphKernelDAG **)this + 15));
    v3 = (id)objc_claimAutoreleasedReturnValue();
  }
  return v3;
}

void sub_180E1C4D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DA1680](v1, 0x10A1C40A031F3DELL);
  _Unwind_Resume(a1);
}

id GPU::MPSGraphKernelDAG::getKernelDAGObject(GPU::MPSGraphKernelDAG *this)
{
  void *v1;
  id v2;
  uint64_t v4;
  void *v5;

  v1 = (void *)*((_QWORD *)this + 15);
  if (v1)
  {
    v2 = v1;
  }
  else
  {
    if (!*((_QWORD *)this + 12) && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v4 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6EC8]), "initWithKernelDAG:finalOp:", (char *)this + 80, *(_QWORD *)(*((_QWORD *)this + 12) + 32));
    v5 = (void *)*((_QWORD *)this + 15);
    *((_QWORD *)this + 15) = v4;

    v2 = *((id *)this + 15);
  }
  return v2;
}

void GPU::DepthwiseConv3DOpHandler::encodeNDArrayOp(GPU::DepthwiseConv3DOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  NSArray *v5;
  id v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  id v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t *v30;
  void *v31;
  id v32;
  GPU::MPSGraphKernelDAG *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t Input;
  uint64_t Filter;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  id v49;
  void *v50;
  uint64_t v51;
  void *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  _QWORD *AttrData;
  uint64_t v57;
  BOOL v58;
  id v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64[4];
  __int16 v65;
  uint64_t v66[2];
  const char *v67;
  uint64_t v68;
  __int16 v69;
  _QWORD v70[4];
  __int16 v71;
  _QWORD v72[4];

  v72[2] = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (!*((_BYTE *)this + 40))
    GPU::DepthwiseConv3DOpHandler::_createKernel(this);
  v62 = 0;
  v63 = 0;
  if (GPU::DepthwiseConv3DOpHandler::getQuantizationParameters(*((GPU::DepthwiseConv3DOpHandler **)this + 3), (mlir::Value *)&v63, (mlir::Value *)&v62))v6 = GPU::DepthwiseConv3DOpHandler::_getQuantKernelDAGObject(this);
  v7 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v8 = *(void **)(v7 + 16);
  if (v8 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v70[0] = *(_QWORD *)(v7 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v70);
    if (v57 == 21)
    {
      v58 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v58 && *(_QWORD *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        v69 = 1283;
        v66[0] = (uint64_t)"classof on '";
        v67 = "mps.depthwise_conv_3d";
        v68 = 21;
        v64[0] = (uint64_t)"' failed due to the operation not being registered";
        v65 = 259;
        llvm::operator+(v66, v64, (uint64_t)v70);
        llvm::report_fatal_error((llvm::Twine *)v70, 1);
      }
    }
LABEL_64:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v8 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
    goto LABEL_64;
  v61 = *((_QWORD *)this + 3);
  -[NSArray objectAtIndexedSubscript:](v5, "objectAtIndexedSubscript:", 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "mpsndarray");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = *((id *)this + 1);
  if (*((_QWORD *)this + 4))
  {
    v12 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*((_QWORD *)this + 3) + 16)) + 48);
    if (*(_UNKNOWN **)(v12 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v70[0] = *(_QWORD *)(v12 + 8);
      v13 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v70);
      if (v14 == 13 && *v13 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v13 + 5) == 0x6465686374697473)
      {
        v69 = 1283;
        v66[0] = (uint64_t)"classof on '";
        v67 = "mpsx.stitched";
        v68 = 13;
        v64[0] = (uint64_t)"' failed due to the operation not being registered";
        v65 = 259;
        llvm::operator+(v66, v64, (uint64_t)v70);
        llvm::report_fatal_error((llvm::Twine *)v70, 1);
      }
    }
    v16 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*((_QWORD *)this + 3) + 16)) + 48);
    v17 = *(void **)(v16 + 16);
    if (v17 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v70[0] = *(_QWORD *)(v16 + 8);
      v38 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v70);
      if (v39 == 13 && *v38 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v38 + 5) == 0x6465686374697473)
      {
        v69 = 1283;
        v66[0] = (uint64_t)"classof on '";
        v67 = "mpsx.stitched";
        v68 = 13;
        v70[0] = v66;
        v70[2] = "' failed due to the operation not being registered";
        v71 = 770;
        llvm::report_fatal_error((llvm::Twine *)v70, 1);
      }
    }
    else if (v17 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
LABEL_16:
      GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*((GPU::MPSGraphKernelDAG **)this + 4), *((GPURegionRuntime **)this + 2));
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      v19 = (void *)*((_QWORD *)a2 + 9);
      if (!v19)
      {
        v20 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
        v21 = (void *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = v20;

        v22 = (void *)*((_QWORD *)a2 + 11);
        v19 = (void *)*((_QWORD *)a2 + 9);
        if (v22)
        {
          objc_msgSend(v22, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
          v23 = objc_claimAutoreleasedReturnValue();
          v24 = (void *)*((_QWORD *)a2 + 9);
          *((_QWORD *)a2 + 9) = v23;

          v19 = (void *)*((_QWORD *)a2 + 9);
        }
      }
      if (*((_QWORD *)a2 + 10))
      {
        objc_msgSend(v19, "setLabel:");
        v19 = (void *)*((_QWORD *)a2 + 9);
      }
      v25 = v19;
      v26 = *((_QWORD *)a2 + 1);
      v27 = *((_QWORD *)this + 4);
      v28 = *(void **)(v27 + 120);
      if (!v28)
      {
        if (!*(_QWORD *)(v27 + 96) && MTLReportFailureTypeEnabled())
          MTLReportFailure();
        v29 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6EC8]), "initWithKernelDAG:finalOp:", v27 + 80, *(_QWORD *)(*(_QWORD *)(v27 + 96) + 32));
        v31 = *(void **)(v27 + 120);
        v30 = (uint64_t *)(v27 + 120);
        *v30 = v29;

        v28 = (void *)*v30;
      }
      v32 = v28;
      objc_msgSend(v11, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v25, v26, v18, 0, v10, v32);

      goto LABEL_46;
    }
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    goto LABEL_16;
  }
  v33 = (GPU::MPSGraphKernelDAG *)*((_QWORD *)this + 15);
  if (v33)
  {
    GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(v33, *((GPURegionRuntime **)this + 2));
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    v36 = *((_QWORD *)a2 + 1);
    GPU::MPSGraphKernelDAG::getKernelDAGObject(*((GPU::MPSGraphKernelDAG **)this + 15));
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v35, v36, v34, 0, v10, v37);

  }
  else
  {
    Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v61);
    Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v61);
    v43 = *((_QWORD *)this + 2);
    v70[0] = Input;
    v66[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)v70) + 2);
    v44 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v43 + 88), v66);
    if (v44
      && (v64[0] = v70[0],
          (v45 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v44 + 3, v64)) != 0))
    {
      v60 = (id)v45[3];
    }
    else
    {
      v60 = 0;
    }
    v46 = *((_QWORD *)this + 2);
    v70[0] = Filter;
    v66[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)v70) + 2);
    v47 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v46 + 88), v66);
    if (v47
      && (v64[0] = v70[0],
          (v48 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v47 + 3, v64)) != 0))
    {
      v49 = (id)v48[3];
    }
    else
    {
      v49 = 0;
    }
    objc_msgSend(v60, "mpsndarray");
    v50 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v49, "mpsndarray");
    v51 = objc_claimAutoreleasedReturnValue();
    v52 = (void *)v51;
    if ((!v10 || !v50 || !v51) && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    v54 = *((_QWORD *)a2 + 1);
    v72[0] = v50;
    v72[1] = v52;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v72, 2);
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v53, v54, v55, v10);

  }
LABEL_46:

}

void sub_180E1CC68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void GPU::DepthwiseConv3DDataGradientOpHandler::encodeNDArrayOp(GPU::DepthwiseConv3DDataGradientOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v5;
  void *v6;
  uint64_t Input;
  uint64_t Filter;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t DefiningOp;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  mlir::Operation *v25;
  mlir::Operation *v26;
  uint64_t v27;
  mlir::Operation *v28;
  uint64_t v29;
  unsigned __int8 v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  void *v34;
  BOOL v35;
  _QWORD *v36;
  uint64_t v37;
  BOOL v38;
  int8x8_t *v39;
  mlir::Block *ParentRegion;
  int8x8_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint8x8_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int8x8_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint8x8_t v57;
  unint64_t v58;
  int v59;
  unsigned int v60;
  const char **v61;
  uint64_t ***v62;
  uint64_t **v63;
  uint64_t v64;
  uint64_t *v65;
  unint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  int8x8_t *v69;
  mlir::Block *v70;
  int8x8_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  uint8x8_t v76;
  unint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int8x8_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint8x8_t v87;
  unint64_t v88;
  uint64_t ***v89;
  uint64_t **v90;
  uint64_t v91;
  uint64_t *v92;
  unint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  void *v96;
  unint64_t StaticType;
  uint64_t Value;
  uint64_t v99;
  uint64_t v100;
  uint64_t Result;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  void *v107;
  id v108;
  int ChannelAxis;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  int64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  BOOL (*v119)(llvm::APFloatBase *);
  uint64_t NumElements;
  int v121;
  BOOL v122;
  int v123;
  unsigned int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  int v128;
  BOOL v129;
  int v130;
  unsigned int v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  BOOL v136;
  int v137;
  unsigned int v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  BOOL v143;
  uint64_t v144;
  uint64_t v145;
  _BOOL4 v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  unsigned int PaddingStyle;
  uint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t v169;
  void *v170;
  void *v171;
  void *v172;
  void *v173;
  uint64_t v174;
  void *v175;
  void *v176;
  uint64_t v177;
  void *v178;
  id v179;
  uint64_t v180;
  void *v181;
  void *v182;
  void *v183;
  uint64_t v184;
  mlir::Operation *v185;
  mlir::Operation *v186;
  uint64_t v187;
  mlir::Operation *v188;
  uint64_t v189;
  unsigned __int8 v190;
  uint64_t v191;
  unint64_t v192;
  uint64_t v193;
  void *v194;
  BOOL v195;
  int v196;
  unsigned int v197;
  const char **v198;
  const char *v199;
  int v200;
  const char *v201;
  const char *v202;
  const char *v203;
  int v204;
  const char *v205;
  const char *v206;
  const char *v207;
  int v208;
  const char *v209;
  const char *v210;
  const char *v211;
  int v212;
  const char *v213;
  const char *v214;
  const char *v215;
  int v216;
  const char *v217;
  const char *v218;
  const char *v219;
  int v220;
  const char *v221;
  const char *v222;
  const char *v223;
  int v224;
  const char *v225;
  const char *v226;
  _QWORD *AttrData;
  uint64_t v228;
  BOOL v229;
  BOOL v230;
  BOOL v231;
  _QWORD *v233;
  uint64_t v234;
  BOOL v235;
  BOOL v236;
  BOOL v237;
  unint64_t v239;
  __int128 v240;
  unint64_t v241;
  unint64_t v242;
  uint64_t v243;
  uint64_t v244;
  unint64_t v245;
  __int128 v246;
  unint64_t v247;
  unint64_t v248;
  uint64_t v249;
  uint64_t v250;
  const char *v251;
  int v252;
  const char *v253;
  const char *v254;
  const char *v255;
  int v256;
  const char *v257;
  const char *v258;
  uint64_t v259;
  unint64_t v260;
  uint64_t v261;
  uint64_t v262;
  void *v263;
  GPU::EncodeDescriptor *v264;
  void *v265;
  NSArray *v266;
  void *v267;
  uint64_t v268;
  __int128 v269;
  uint64_t v270;
  __int128 v271;
  uint64_t v272;
  __int128 v273;
  unint64_t v274;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  BOOL (*Strides)(llvm::APFloatBase *);
  uint64_t v278;
  __int128 v279;
  const char *v280;
  __int16 v281;
  const char *v282;
  uint64_t v283;
  const char *v284;
  uint64_t v285;
  __int16 v286;
  _QWORD v287[2];
  _QWORD v288[2];
  _QWORD v289[2];
  __int128 v290;
  __int128 v291;
  __int128 v292;
  uint64_t v293;

  v293 = *MEMORY[0x1E0C80C00];
  v266 = a3;
  v5 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(_QWORD *)&v290 = *(_QWORD *)(v5 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v290);
    if (v228 == 35)
    {
      v229 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      v230 = v229 && AttrData[2] == 0x61645F64335F766ELL;
      v231 = v230 && AttrData[3] == 0x69646172675F6174;
      if (v231 && *(_QWORD *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        v286 = 1283;
        v282 = "classof on '";
        v284 = "mps.depthwise_conv_3d_data_gradient";
        v285 = 35;
        *(_QWORD *)&v279 = "' failed due to the operation not being registered";
        v281 = 259;
        llvm::operator+((uint64_t *)&v282, (uint64_t *)&v279, (uint64_t)&v290);
        llvm::report_fatal_error((llvm::Twine *)&v290, 1);
      }
    }
LABEL_424:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id)
    goto LABEL_424;
  v268 = *((_QWORD *)this + 3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v268);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v268);
  v9 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v10 = *(void **)(v9 + 16);
  if (v10 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(_QWORD *)&v290 = *(_QWORD *)(v9 + 8);
    v233 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v290);
    if (v234 == 35)
    {
      v235 = *v233 == 0x747065642E73706DLL && v233[1] == 0x6F635F6573697768;
      v236 = v235 && v233[2] == 0x61645F64335F766ELL;
      v237 = v236 && v233[3] == 0x69646172675F6174;
      if (v237 && *(_QWORD *)((char *)v233 + 27) == 0x746E656964617267)
      {
        v286 = 1283;
        v282 = "classof on '";
        v284 = "mps.depthwise_conv_3d_data_gradient";
        v285 = 35;
        *(_QWORD *)&v279 = "' failed due to the operation not being registered";
        v281 = 259;
        llvm::operator+((uint64_t *)&v282, (uint64_t *)&v279, (uint64_t)&v290);
        goto LABEL_396;
      }
    }
LABEL_425:
    v199 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v200 = 578;
    v201 = "Casting.h";
    v202 = "cast";
LABEL_334:
    __assert_rtn(v202, v201, v200, v199);
  }
  if (v10 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id)
    goto LABEL_425;
  v11 = Filter;
  *(_QWORD *)&v271 = *((_QWORD *)this + 3);
  *(_QWORD *)&v273 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v271);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v273);
  if (!DefiningOp)
  {
LABEL_15:
    v15 = 0;
    goto LABEL_16;
  }
  v13 = *(_QWORD *)(DefiningOp + 48);
  v14 = *(void **)(v13 + 16);
  if (v14 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(_QWORD *)&v290 = *(_QWORD *)(v13 + 8);
    v16 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v290);
    if (v17 == 14)
    {
      v18 = *v16 == 0x757165642E73706DLL && *(_QWORD *)((char *)v16 + 6) == 0x657A69746E617571;
      if (v18)
      {
LABEL_422:
        v286 = 1283;
        v282 = "classof on '";
        v284 = "mps.dequantize";
        v285 = 14;
        *(_QWORD *)&v279 = "' failed due to the operation not being registered";
        v281 = 259;
        llvm::operator+((uint64_t *)&v282, (uint64_t *)&v279, (uint64_t)&v290);
LABEL_396:
        llvm::report_fatal_error((llvm::Twine *)&v290, 1);
      }
    }
    goto LABEL_15;
  }
  if (v14 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
    v15 = DefiningOp;
  else
    v15 = 0;
LABEL_16:
  *(_QWORD *)&v269 = v15;
  *(_QWORD *)&v273 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v271);
  v19 = mlir::Value::getDefiningOp((mlir::Value *)&v273);
  if (!v19)
    goto LABEL_57;
  v20 = *(_QWORD *)(v19 + 48);
  v21 = *(void **)(v20 + 16);
  if (v21 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(_QWORD *)&v290 = *(_QWORD *)(v20 + 8);
    v36 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v290);
    if (v37 != 14
      || (*v36 == 0x757165642E73706DLL ? (v38 = *(_QWORD *)((char *)v36 + 6) == 0x657A69746E617571) : (v38 = 0), !v38))
    {
LABEL_57:
      v278 = 0;
      if (!(_QWORD)v269)
        goto LABEL_58;
      goto LABEL_336;
    }
    goto LABEL_422;
  }
  v18 = v21 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
  v22 = v21 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
  if (v18)
    v23 = v19;
  else
    v23 = 0;
  v278 = v23;
  if (v22 != ((_QWORD)v269 == 0))
  {
LABEL_336:
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    if (!(_QWORD)v269)
      goto LABEL_58;
    goto LABEL_23;
  }
  if (!(_QWORD)v269)
    goto LABEL_58;
LABEL_23:
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v269);
  v11 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v278);
  v24 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v269);
  *(_QWORD *)&v273 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  *(_QWORD *)&v290 = v24;
  if (!v24)
    goto LABEL_333;
  v25 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v290);
  if (v25
    && mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v273, v25))
  {
    *(_QWORD *)&v279 = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v269);
    if (!(_QWORD)v279)
      goto LABEL_333;
    v26 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v279);
    if (v26)
    {
      DWORD2(v290) = 1;
      *(_QWORD *)&v290 = 0;
      v282 = (const char *)&v290;
      mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&v282, v26);
      if (DWORD2(v290) >= 0x41)
      {
        if ((_QWORD)v290)
          MEMORY[0x186DA165C](v290, 0x1000C8000313F17);
      }
    }
  }
  v27 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v269);
  Strides = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  *(_QWORD *)&v290 = v27;
  if (!v27)
    goto LABEL_333;
  v28 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v290);
  if (!v28
    || !mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&Strides, v28))
  {
    goto LABEL_282;
  }
  *(_QWORD *)&v273 = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v269);
  if (!(_QWORD)v273)
    goto LABEL_333;
  v29 = mlir::Value::getDefiningOp((mlir::Value *)&v273);
  if (!v29)
    goto LABEL_282;
  LODWORD(v283) = 1;
  v282 = 0;
  *(_QWORD *)&v279 = &v282;
  if ((v30 & 1) == 0
  {
    *(_QWORD *)&v290 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
    *((_QWORD *)&v290 + 1) = 84;
    v239 = llvm::StringRef::find((uint64_t *)&v290, "DesiredTypeName = ", 0x12uLL, 0);
    v240 = v290;
    if (*((_QWORD *)&v290 + 1) >= v239)
      v241 = v239;
    else
      v241 = *((_QWORD *)&v290 + 1);
    v242 = *((_QWORD *)&v290 + 1) - v241;
    v243 = v290 + v241;
    *(_QWORD *)&v290 = v290 + v241;
    *((_QWORD *)&v290 + 1) -= v241;
    if (*((_QWORD *)&v240 + 1) <= v239)
    {
      v251 = "!Name.empty() && \"Unable to find the template parameter!\"";
      v252 = 33;
    }
    else
    {
      if (v242 < 0x12)
      {
        v251 = "size() >= N && \"Dropping more elements than exist\"";
        v252 = 614;
        v253 = "StringRef.h";
        v254 = "drop_front";
        goto LABEL_430;
      }
      *(_QWORD *)&v290 = v243 + 18;
      *((_QWORD *)&v290 + 1) = v242 - 18;
      if (v242 != 18 && *(_BYTE *)(v240 + *((_QWORD *)&v240 + 1) - 1) == 93)
      {
        if (v242 - 18 >= v242 - 19)
          v244 = v242 - 19;
        else
          v244 = v242 - 18;
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v243 + 18, v244);
        goto LABEL_37;
      }
      v251 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
      v252 = 36;
    }
    v253 = "TypeName.h";
    v254 = "getTypeName";
LABEL_430:
    __assert_rtn(v254, v253, v252, v251);
  }
LABEL_37:
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v29 + 48) + 32))(*(_QWORD *)(v29 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))goto LABEL_50;
  *(_QWORD *)&v290 = &v291;
  *((_QWORD *)&v290 + 1) = 0x100000000;
  if (!mlir::Operation::fold(v29, 0, 0, (uint64_t)&v290))
    __assert_rtn("match", "Matchers.h", 92, "succeeded(result) && \"expected ConstantLike op to be foldable\"");
  if (!DWORD2(v290))
  {
    v211 = "!empty()";
    v212 = 303;
    v213 = "SmallVector.h";
    v214 = "front";
    goto LABEL_352;
  }
  v31 = *(_QWORD *)v290;
  if ((*(_QWORD *)v290 & 4) != 0)
  {
    v211 = "isa<T>(*this) && \"Invalid accessor called\"";
    v212 = 156;
    v213 = "PointerUnion.h";
    v214 = "get";
    goto LABEL_352;
  }
  v32 = v31 & 0xFFFFFFFFFFFFFFF8;
  if ((v31 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    v211 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v212 = 650;
    v213 = "Casting.h";
    v214 = "dyn_cast";
LABEL_352:
    __assert_rtn(v214, v213, v212, v211);
  }
  if ((__int128 *)v290 != &v291)
    free((void *)v290);
  if (!*(_DWORD *)(v29 + 36))
  {
    v215 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v216 = 984;
    v217 = "Operation.h";
    v218 = "getOpResultImpl";
    goto LABEL_355;
  }
  v33 = *(_QWORD *)(*(_QWORD *)(v29 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v33)
  {
    v215 = "abstractType && \"Malformed type storage object.\"";
    v216 = 160;
    v217 = "TypeSupport.h";
    v218 = "getAbstractType";
LABEL_355:
    __assert_rtn(v218, v217, v216, v215);
  }
  v34 = *(void **)(v33 + 136);
  if (v34 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    && v34 != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id
    && v34 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
    && v34 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_50:
    v35 = 0;
    if (v283 < 0x41)
      goto LABEL_278;
    goto LABEL_276;
  }
  v59 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v279, v32);
  v60 = v283;
  if (!v59)
  {
    v35 = 0;
    if (v283 < 0x41)
      goto LABEL_278;
    goto LABEL_276;
  }
  if (v283 < 0x41)
  {
    v61 = &v282;
    goto LABEL_275;
  }
  if (v60 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v282) <= 0x40)
  {
    v61 = (const char **)v282;
LABEL_275:
    v35 = *v61 == 0;
    if (v60 < 0x41)
      goto LABEL_278;
LABEL_276:
    if (v282)
      MEMORY[0x186DA165C](v282, 0x1000C8000313F17);
LABEL_278:
    if (v35)
      goto LABEL_284;
    goto LABEL_282;
  }
  if (v282)
    MEMORY[0x186DA165C](v282, 0x1000C8000313F17);
LABEL_282:
  if (MTLReportFailureTypeEnabled())
    MTLReportFailure();
LABEL_284:
  v184 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v278);
  *(_QWORD *)&v273 = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  *(_QWORD *)&v290 = v184;
  if (!v184)
    goto LABEL_333;
  v185 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v290);
  if (v185
    && mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&v273, v185))
  {
    *(_QWORD *)&v279 = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v278);
    if ((_QWORD)v279)
    {
      v186 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v279);
      if (v186)
      {
        DWORD2(v290) = 1;
        *(_QWORD *)&v290 = 0;
        v282 = (const char *)&v290;
        mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&v282, v186);
        if (DWORD2(v290) >= 0x41)
        {
          if ((_QWORD)v290)
            MEMORY[0x186DA165C](v290, 0x1000C8000313F17);
        }
      }
      goto LABEL_292;
    }
LABEL_333:
    v199 = "value";
    v200 = 402;
    v201 = "Matchers.h";
    v202 = "matchPattern";
    goto LABEL_334;
  }
LABEL_292:
  v187 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v278);
  Strides = mlir::m_OneFloat(void)::{lambda(llvm::APFloat const&)#1}::__invoke;
  *(_QWORD *)&v290 = v187;
  if (!v187)
    goto LABEL_333;
  v188 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v290);
  if (!v188
    || !mlir::detail::constant_float_predicate_matcher::match((mlir::detail::constant_float_predicate_matcher *)&Strides, v188))
  {
LABEL_327:
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    goto LABEL_58;
  }
  *(_QWORD *)&v273 = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v278);
  if (!(_QWORD)v273)
    goto LABEL_333;
  v189 = mlir::Value::getDefiningOp((mlir::Value *)&v273);
  if (!v189)
    goto LABEL_327;
  LODWORD(v283) = 1;
  v282 = 0;
  *(_QWORD *)&v279 = &v282;
  if ((v190 & 1) == 0
  {
    *(_QWORD *)&v290 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
    *((_QWORD *)&v290 + 1) = 84;
    v245 = llvm::StringRef::find((uint64_t *)&v290, "DesiredTypeName = ", 0x12uLL, 0);
    v246 = v290;
    if (*((_QWORD *)&v290 + 1) >= v245)
      v247 = v245;
    else
      v247 = *((_QWORD *)&v290 + 1);
    v248 = *((_QWORD *)&v290 + 1) - v247;
    v249 = v290 + v247;
    *(_QWORD *)&v290 = v290 + v247;
    *((_QWORD *)&v290 + 1) -= v247;
    if (*((_QWORD *)&v246 + 1) <= v245)
    {
      v255 = "!Name.empty() && \"Unable to find the template parameter!\"";
      v256 = 33;
    }
    else
    {
      if (v248 < 0x12)
      {
        v255 = "size() >= N && \"Dropping more elements than exist\"";
        v256 = 614;
        v257 = "StringRef.h";
        v258 = "drop_front";
        goto LABEL_435;
      }
      *(_QWORD *)&v290 = v249 + 18;
      *((_QWORD *)&v290 + 1) = v248 - 18;
      if (v248 != 18 && *(_BYTE *)(v246 + *((_QWORD *)&v246 + 1) - 1) == 93)
      {
        if (v248 - 18 >= v248 - 19)
          v250 = v248 - 19;
        else
          v250 = v248 - 18;
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v249 + 18, v250);
        goto LABEL_298;
      }
      v255 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
      v256 = 36;
    }
    v257 = "TypeName.h";
    v258 = "getTypeName";
LABEL_435:
    __assert_rtn(v258, v257, v256, v255);
  }
LABEL_298:
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v189 + 48) + 32))(*(_QWORD *)(v189 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id))goto LABEL_311;
  *(_QWORD *)&v290 = &v291;
  *((_QWORD *)&v290 + 1) = 0x100000000;
  if (!mlir::Operation::fold(v189, 0, 0, (uint64_t)&v290))
    __assert_rtn("match", "Matchers.h", 92, "succeeded(result) && \"expected ConstantLike op to be foldable\"");
  if (!DWORD2(v290))
  {
    v219 = "!empty()";
    v220 = 303;
    v221 = "SmallVector.h";
    v222 = "front";
    goto LABEL_360;
  }
  v191 = *(_QWORD *)v290;
  if ((*(_QWORD *)v290 & 4) != 0)
  {
    v219 = "isa<T>(*this) && \"Invalid accessor called\"";
    v220 = 156;
    v221 = "PointerUnion.h";
    v222 = "get";
    goto LABEL_360;
  }
  v192 = v191 & 0xFFFFFFFFFFFFFFF8;
  if ((v191 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    v219 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v220 = 650;
    v221 = "Casting.h";
    v222 = "dyn_cast";
LABEL_360:
    __assert_rtn(v222, v221, v220, v219);
  }
  if ((__int128 *)v290 != &v291)
    free((void *)v290);
  if (!*(_DWORD *)(v189 + 36))
  {
    v223 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v224 = 984;
    v225 = "Operation.h";
    v226 = "getOpResultImpl";
    goto LABEL_363;
  }
  v193 = *(_QWORD *)(*(_QWORD *)(v189 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v193)
  {
    v223 = "abstractType && \"Malformed type storage object.\"";
    v224 = 160;
    v225 = "TypeSupport.h";
    v226 = "getAbstractType";
LABEL_363:
    __assert_rtn(v226, v225, v224, v223);
  }
  v194 = *(void **)(v193 + 136);
  if (v194 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    && v194 != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id
    && v194 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
    && v194 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_311:
    v195 = 0;
    if (v283 < 0x41)
      goto LABEL_323;
    goto LABEL_321;
  }
  v196 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v279, v192);
  v197 = v283;
  if (!v196)
  {
    v195 = 0;
    if (v283 < 0x41)
      goto LABEL_323;
    goto LABEL_321;
  }
  if (v283 >= 0x41)
  {
    if (v197 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v282) > 0x40)
    {
      if (v282)
        MEMORY[0x186DA165C](v282, 0x1000C8000313F17);
      goto LABEL_327;
    }
    v198 = (const char **)v282;
  }
  else
  {
    v198 = &v282;
  }
  v195 = *v198 == 0;
  if (v197 >= 0x41)
  {
LABEL_321:
    if (v282)
      MEMORY[0x186DA165C](v282, 0x1000C8000313F17);
  }
LABEL_323:
  if (!v195)
    goto LABEL_327;
LABEL_58:
  v39 = (int8x8_t *)*((_QWORD *)this + 2);
  *(_QWORD *)&v290 = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)&v290);
  v41 = v39[12];
  if (!*(_QWORD *)&v41)
    goto LABEL_104;
  v42 = *((_QWORD *)ParentRegion + 2);
  v43 = 0x9DDFEA08EB382D69 * (((8 * v42) + 8) ^ HIDWORD(v42));
  v44 = 0x9DDFEA08EB382D69 * (HIDWORD(v42) ^ (v43 >> 47) ^ v43);
  v45 = 0x9DDFEA08EB382D69 * (v44 ^ (v44 >> 47));
  v46 = (uint8x8_t)vcnt_s8(v41);
  v46.i16[0] = vaddlv_u8(v46);
  if (v46.u32[0] > 1uLL)
  {
    v47 = 0x9DDFEA08EB382D69 * (v44 ^ (v44 >> 47));
    if (v45 >= *(_QWORD *)&v41)
      v47 = v45 % *(_QWORD *)&v41;
  }
  else
  {
    v47 = v45 & (*(_QWORD *)&v41 - 1);
  }
  v48 = *(_QWORD **)(*(_QWORD *)&v39[11] + 8 * v47);
  if (!v48)
    goto LABEL_104;
  v49 = (_QWORD *)*v48;
  if (!v49)
    goto LABEL_104;
  if (v46.u32[0] < 2uLL)
  {
    v50 = *(_QWORD *)&v41 - 1;
    while (1)
    {
      v52 = v49[1];
      if (v52 == v45)
      {
        if (v49[2] == v42)
          goto LABEL_79;
      }
      else if ((v52 & v50) != v47)
      {
        goto LABEL_104;
      }
      v49 = (_QWORD *)*v49;
      if (!v49)
        goto LABEL_104;
    }
  }
  while (1)
  {
    v51 = v49[1];
    if (v51 == v45)
      break;
    if (v51 >= *(_QWORD *)&v41)
      v51 %= *(_QWORD *)&v41;
    if (v51 != v47)
      goto LABEL_104;
LABEL_68:
    v49 = (_QWORD *)*v49;
    if (!v49)
      goto LABEL_104;
  }
  if (v49[2] != v42)
    goto LABEL_68;
LABEL_79:
  v53 = (int8x8_t)v49[4];
  if (v53)
  {
    v54 = 0x9DDFEA08EB382D69 * (((8 * v290) + 8) ^ DWORD1(v290));
    v55 = 0x9DDFEA08EB382D69 * (DWORD1(v290) ^ (v54 >> 47) ^ v54);
    v56 = 0x9DDFEA08EB382D69 * (v55 ^ (v55 >> 47));
    v57 = (uint8x8_t)vcnt_s8(v53);
    v57.i16[0] = vaddlv_u8(v57);
    if (v57.u32[0] > 1uLL)
    {
      v58 = v56;
      if (v56 >= *(_QWORD *)&v53)
        v58 = v56 % *(_QWORD *)&v53;
    }
    else
    {
      v58 = v56 & (*(_QWORD *)&v53 - 1);
    }
    v62 = *(uint64_t ****)(v49[3] + 8 * v58);
    if (v62)
    {
      v63 = *v62;
      if (v63)
      {
        if (v57.u32[0] < 2uLL)
        {
          v64 = *(_QWORD *)&v53 - 1;
          while (1)
          {
            v67 = v63[1];
            if (v67 == (uint64_t *)v56)
            {
              if (v63[2] == (uint64_t *)v290)
                goto LABEL_329;
            }
            else if (((unint64_t)v67 & v64) != v58)
            {
              goto LABEL_104;
            }
            v65 = 0;
            v63 = (uint64_t **)*v63;
            if (!v63)
              goto LABEL_105;
          }
        }
        while (1)
        {
          v66 = (unint64_t)v63[1];
          if (v66 == v56)
          {
            if (v63[2] == (uint64_t *)v290)
            {
LABEL_329:
              v65 = v63[3];
              goto LABEL_105;
            }
          }
          else
          {
            if (v66 >= *(_QWORD *)&v53)
              v66 %= *(_QWORD *)&v53;
            if (v66 != v58)
              break;
          }
          v65 = 0;
          v63 = (uint64_t **)*v63;
          if (!v63)
            goto LABEL_105;
        }
      }
    }
  }
LABEL_104:
  v65 = 0;
LABEL_105:
  objc_msgSend(v65, "mpsndarray");
  v68 = objc_claimAutoreleasedReturnValue();

  v69 = (int8x8_t *)*((_QWORD *)this + 2);
  *(_QWORD *)&v290 = v11;
  v70 = mlir::Value::getParentRegion((mlir::Value *)&v290);
  v71 = v69[12];
  if (!*(_QWORD *)&v71)
    goto LABEL_146;
  v72 = *((_QWORD *)v70 + 2);
  v73 = 0x9DDFEA08EB382D69 * (((8 * v72) + 8) ^ HIDWORD(v72));
  v74 = 0x9DDFEA08EB382D69 * (HIDWORD(v72) ^ (v73 >> 47) ^ v73);
  v75 = 0x9DDFEA08EB382D69 * (v74 ^ (v74 >> 47));
  v76 = (uint8x8_t)vcnt_s8(v71);
  v76.i16[0] = vaddlv_u8(v76);
  if (v76.u32[0] > 1uLL)
  {
    v77 = 0x9DDFEA08EB382D69 * (v74 ^ (v74 >> 47));
    if (v75 >= *(_QWORD *)&v71)
      v77 = v75 % *(_QWORD *)&v71;
  }
  else
  {
    v77 = v75 & (*(_QWORD *)&v71 - 1);
  }
  v78 = *(_QWORD **)(*(_QWORD *)&v69[11] + 8 * v77);
  if (!v78)
    goto LABEL_146;
  v79 = (_QWORD *)*v78;
  if (!v79)
    goto LABEL_146;
  if (v76.u32[0] < 2uLL)
  {
    v80 = *(_QWORD *)&v71 - 1;
    while (1)
    {
      v82 = v79[1];
      if (v82 == v75)
      {
        if (v79[2] == v72)
          goto LABEL_126;
      }
      else if ((v82 & v80) != v77)
      {
        goto LABEL_146;
      }
      v79 = (_QWORD *)*v79;
      if (!v79)
        goto LABEL_146;
    }
  }
  while (1)
  {
    v81 = v79[1];
    if (v81 == v75)
      break;
    if (v81 >= *(_QWORD *)&v71)
      v81 %= *(_QWORD *)&v71;
    if (v81 != v77)
      goto LABEL_146;
LABEL_115:
    v79 = (_QWORD *)*v79;
    if (!v79)
      goto LABEL_146;
  }
  if (v79[2] != v72)
    goto LABEL_115;
LABEL_126:
  v83 = (int8x8_t)v79[4];
  if (!*(_QWORD *)&v83)
    goto LABEL_146;
  v84 = 0x9DDFEA08EB382D69 * (((8 * v290) + 8) ^ DWORD1(v290));
  v85 = 0x9DDFEA08EB382D69 * (DWORD1(v290) ^ (v84 >> 47) ^ v84);
  v86 = 0x9DDFEA08EB382D69 * (v85 ^ (v85 >> 47));
  v87 = (uint8x8_t)vcnt_s8(v83);
  v87.i16[0] = vaddlv_u8(v87);
  if (v87.u32[0] > 1uLL)
  {
    v88 = v86;
    if (v86 >= *(_QWORD *)&v83)
      v88 = v86 % *(_QWORD *)&v83;
  }
  else
  {
    v88 = v86 & (*(_QWORD *)&v83 - 1);
  }
  v89 = *(uint64_t ****)(v79[3] + 8 * v88);
  if (!v89 || (v90 = *v89) == 0)
  {
LABEL_146:
    v92 = 0;
    goto LABEL_147;
  }
  if (v87.u32[0] < 2uLL)
  {
    v91 = *(_QWORD *)&v83 - 1;
    while (1)
    {
      v94 = v90[1];
      if (v94 == (uint64_t *)v86)
      {
        if (v90[2] == (uint64_t *)v290)
          goto LABEL_330;
      }
      else if (((unint64_t)v94 & v91) != v88)
      {
        goto LABEL_146;
      }
      v92 = 0;
      v90 = (uint64_t **)*v90;
      if (!v90)
        goto LABEL_147;
    }
  }
  while (1)
  {
    v93 = (unint64_t)v90[1];
    if (v93 == v86)
      break;
    if (v93 >= *(_QWORD *)&v83)
      v93 %= *(_QWORD *)&v83;
    if (v93 != v88)
      goto LABEL_146;
LABEL_136:
    v92 = 0;
    v90 = (uint64_t **)*v90;
    if (!v90)
      goto LABEL_147;
  }
  if (v90[2] != (uint64_t *)v290)
    goto LABEL_136;
LABEL_330:
  v92 = v90[3];
LABEL_147:
  objc_msgSend(v92, "mpsndarray");
  v267 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSArray objectAtIndexedSubscript:](v266, "objectAtIndexedSubscript:", 0);
  v265 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v265, "mpsndarray");
  v95 = objc_claimAutoreleasedReturnValue();
  v96 = (void *)v95;
  if ((!v68 || !v267 || !v95) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (*((_QWORD *)this + 4) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  StaticType = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), v11);
  if (!*(_QWORD *)StaticType)
  {
    v203 = "abstractType && \"Malformed type storage object.\"";
    v204 = 160;
    v205 = "TypeSupport.h";
    v206 = "getAbstractType";
    goto LABEL_344;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v203 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v204 = 566;
    v205 = "Casting.h";
    v206 = "cast";
LABEL_344:
    __assert_rtn(v206, v205, v204, v203);
  }
  *(_QWORD *)&v290 = StaticType;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v290);
  v100 = v99;
  v264 = a2;
  Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v268);
  v102 = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Result);
  if (!*(_QWORD *)v102)
  {
    v207 = "abstractType && \"Malformed type storage object.\"";
    v208 = 160;
    v209 = "TypeSupport.h";
    v210 = "getAbstractType";
    goto LABEL_347;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v102 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v207 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v208 = 566;
    v209 = "Casting.h";
    v210 = "cast";
LABEL_347:
    __assert_rtn(v210, v209, v208, v207);
  }
  *(_QWORD *)&v290 = v102;
  v103 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v290);
  v105 = v104;
  v106 = v268;
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v107 = (void *)objc_claimAutoreleasedReturnValue();
  v278 = v106;
  v108 = v107;
  Strides = (BOOL (*)(llvm::APFloatBase *))mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v278);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v278);
  v291 = 0u;
  v292 = 0u;
  v290 = 0u;
  v262 = v100;
  v259 = Value;
  v263 = (void *)v68;
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v278);
  ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v278);
  if (ChannelAxis >= 0)
    v110 = v105;
  else
    v110 = 0;
  v260 = v110;
  v261 = ChannelAxis;
  if (ChannelAxis >= 0)
    v111 = 0;
  else
    v111 = v105;
  v273 = xmmword_181287390;
  v112 = 1;
  v274 = 1;
  v113 = v111 + ChannelAxis;
  v271 = xmmword_181287390;
  v272 = 1;
  v114 = 1;
  v115 = 1;
  if (v105 >= 3)
  {
    v116 = (int)(v105 - 1 - (v113 >= (int)v105 - 1));
    if (v105 <= v116
      || (v117 = (int)(v105 - 2 - (v113 >= (int)v105 - 2)), v105 <= v117)
      || (v118 = (int)(v105 - 3 - (v113 >= (int)v105 - 3)), v105 <= v118))
    {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    v115 = *(_QWORD *)(v103 + 8 * v116);
    v114 = *(_QWORD *)(v103 + 8 * v117);
    v112 = *(_QWORD *)(v103 + 8 * v118);
  }
  if (Strides && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v282, (uint64_t)Strides, 0);
    v119 = Strides;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v279, (uint64_t)v119, NumElements);
    v121 = 2;
    while (1)
    {
      v122 = v282 == (const char *)v279 && v283 == BYTE8(v279);
      if (v122 && v284 == v280)
        goto LABEL_183;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v282, (llvm::APInt *)&v269);
      v123 = DWORD2(v269);
      if (DWORD2(v269) < 0x41)
      {
        *((_QWORD *)&v273 + v121--) = v269;
        goto LABEL_170;
      }
      v124 = v123 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v269);
      v125 = v269;
      if (v124 <= 0x40)
        break;
      *((_QWORD *)&v273 + v121--) = -1;
      if (v125)
        goto LABEL_182;
LABEL_170:
      ++v284;
    }
    *((_QWORD *)&v273 + v121--) = *(_QWORD *)v269;
LABEL_182:
    MEMORY[0x186DA165C]();
    goto LABEL_170;
  }
LABEL_183:
  if (InputAttributeNames
    && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v282, InputAttributeNames, 0);
    v126 = InputAttributeNames;
    v127 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v279, v126, v127);
    v128 = 2;
    while (1)
    {
      v129 = v282 == (const char *)v279 && v283 == BYTE8(v279);
      if (v129 && v284 == v280)
        goto LABEL_200;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v282, (llvm::APInt *)&v269);
      v130 = DWORD2(v269);
      if (DWORD2(v269) < 0x41)
      {
        *((_QWORD *)&v271 + v128--) = v269;
        goto LABEL_187;
      }
      v131 = v130 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v269);
      v132 = v269;
      if (v131 <= 0x40)
        break;
      *((_QWORD *)&v271 + v128--) = -1;
      if (v132)
        goto LABEL_199;
LABEL_187:
      ++v284;
    }
    *((_QWORD *)&v271 + v128--) = *(_QWORD *)v269;
LABEL_199:
    MEMORY[0x186DA165C]();
    goto LABEL_187;
  }
LABEL_200:
  if (Rewriter && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter) == 6)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v282, Rewriter, 0);
    v133 = Rewriter;
    v134 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v279, v133, v134);
    v135 = 5;
    while (1)
    {
      v136 = v282 == (const char *)v279 && v283 == BYTE8(v279);
      if (v136 && v284 == v280)
        goto LABEL_217;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v282, (llvm::APInt *)&v269);
      v137 = DWORD2(v269);
      if (DWORD2(v269) < 0x41)
      {
        *((_QWORD *)&v290 + v135--) = v269;
        goto LABEL_204;
      }
      v138 = v137 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v269);
      v139 = v269;
      if (v138 <= 0x40)
        break;
      *((_QWORD *)&v290 + v135--) = -1;
      if (v139)
        goto LABEL_216;
LABEL_204:
      ++v284;
    }
    *((_QWORD *)&v290 + v135--) = *(_QWORD *)v269;
LABEL_216:
    MEMORY[0x186DA165C]();
    goto LABEL_204;
  }
LABEL_217:
  if (v262 == 4)
  {
    v140 = v113 - v105 + 4;
    v141 = 24;
    if (v140 > 2)
      v141 = 16;
    v142 = *(_QWORD *)(Value + v141);
    v143 = __OFSUB__(v140, 1);
    v18 = v140 == 1;
    v144 = 8;
    if (((uint64_t)(v113 - v105 + 3) < 0) ^ v143 | v18)
      v144 = 16;
    v145 = *(_QWORD *)(Value + v144);
    v146 = (uint64_t)(v113 - v105 + 3) < 0 != v143;
    v147 = v142 - 1;
    v148 = v145 - 1;
    v149 = *(_QWORD *)(v259 + 8 * v146) - 1;
  }
  else
  {
    v147 = 0;
    v148 = 0;
    v149 = 0;
  }
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v278);
  if (PaddingStyle >= 3 && PaddingStyle != 4)
    __assert_rtn("createDepthwiseConv3D", "GPUDepthwiseConvOps.mm", 791, "0 && \"Unknown paddingStyle\"");
  v151 = v271 * v147 + 1;
  if (PaddingStyle)
  {
    if (PaddingStyle == 2 || PaddingStyle == 4)
    {
      v152 = v273;
      if (v115 % (unint64_t)v273)
        v152 = v115 % (unint64_t)v273;
      v153 = (v151 - v152) & ~((uint64_t)(v151 - v152) >> 63);
      v154 = v153 >> 1;
      v155 = v153 - (v153 >> 1);
      if (PaddingStyle != 4)
        v155 = v154;
    }
    else
    {
      v155 = 0;
    }
    if (v151 < 0)
      v151 = v271 * v147 + 2;
    v156 = (v151 >> 1) - v155;
    v157 = *((_QWORD *)&v271 + 1) * v148 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      v158 = *((_QWORD *)&v273 + 1);
      if (v114 % *((_QWORD *)&v273 + 1))
        v158 = v114 % *((_QWORD *)&v273 + 1);
      v159 = (v157 - v158) & ~((uint64_t)(v157 - v158) >> 63);
      v160 = v159 >> 1;
      v161 = v159 - (v159 >> 1);
      if (PaddingStyle != 4)
        v161 = v160;
    }
    else
    {
      v161 = 0;
    }
    if (v157 < 0)
      v157 = *((_QWORD *)&v271 + 1) * v148 + 2;
    v162 = (v157 >> 1) - v161;
    v163 = v272 * v149 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      v164 = v274;
      if (v112 % v274)
        v164 = v112 % v274;
      v165 = (v163 - v164) & ~((uint64_t)(v163 - v164) >> 63);
      v166 = v165 >> 1;
      v167 = v165 - (v165 >> 1);
      if (PaddingStyle == 4)
        v168 = v167;
      else
        v168 = v166;
    }
    else
    {
      v168 = 0;
    }
  }
  else
  {
    if (v151 < 0)
      v151 = v271 * v147 + 2;
    v156 = (v151 >> 1) - *((_QWORD *)&v290 + 1);
    v162 = (*((_QWORD *)&v271 + 1) * v148 + 1) / 2 - *((_QWORD *)&v291 + 1);
    v163 = v272 * v149 + 1;
    v168 = *((_QWORD *)&v292 + 1);
  }
  if (v163 >= 0)
    v169 = v163;
  else
    v169 = v163 + 1;
  v170 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6FD8]), "initWithDevice:", v108);
  v282 = (const char *)v156;
  v283 = v162;
  v284 = (const char *)((v169 >> 1) - v168);
  objc_msgSend(v170, "setWindowOffsets:", &v282);
  v279 = v273;
  v280 = (const char *)v274;
  objc_msgSend(v170, "setConvStrides:", &v279);
  v269 = v271;
  v270 = v272;
  objc_msgSend(v170, "setConvDilationRates:", &v269);
  objc_msgSend(v170, "setChannelAxis:", v260 + ~v261);
  objc_msgSend(v170, "setOptions:", objc_msgSend(v170, "options") | 1);

  if (*((_BYTE *)v96 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v96, "setReadCount:", objc_msgSend(v96, "readCount") + 1);
  v289[0] = v96;
  v289[1] = v267;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v289, 2);
  v171 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v170, "resultStateForSourceArrays:sourceStates:destinationArray:", v171, 0, v96);
  v172 = (void *)objc_claimAutoreleasedReturnValue();

  v173 = (void *)*((_QWORD *)v264 + 9);
  if (!v173)
  {
    v174 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)v264 + 1), 0);
    v175 = (void *)*((_QWORD *)v264 + 9);
    *((_QWORD *)v264 + 9) = v174;

    v176 = (void *)*((_QWORD *)v264 + 11);
    v173 = (void *)*((_QWORD *)v264 + 9);
    if (v176)
    {
      objc_msgSend(v176, "wrapComputeEncoder:", *((_QWORD *)v264 + 9));
      v177 = objc_claimAutoreleasedReturnValue();
      v178 = (void *)*((_QWORD *)v264 + 9);
      *((_QWORD *)v264 + 9) = v177;

      v173 = (void *)*((_QWORD *)v264 + 9);
    }
  }
  if (*((_QWORD *)v264 + 10))
  {
    objc_msgSend(v173, "setLabel:");
    v173 = (void *)*((_QWORD *)v264 + 9);
  }
  v179 = v173;
  v180 = *((_QWORD *)v264 + 1);
  v288[0] = v96;
  v288[1] = v267;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v288, 2);
  v181 = (void *)objc_claimAutoreleasedReturnValue();
  v287[0] = v96;
  objc_msgSend(MEMORY[0x1E0C99E38], "null");
  v182 = (void *)objc_claimAutoreleasedReturnValue();
  v287[1] = v182;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v287, 2);
  v183 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v170, "encodeGradientsToCommandEncoder:commandBuffer:sourceArrays:sourceGradient:gradientState:destinationGradients:kernelDAGObject:", v179, v180, v181, v263, v172, v183, 0);

}

void sub_180E1EA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  uint64_t v18;
  uint64_t v20;

  if (*(_DWORD *)(v18 - 240) >= 0x41u)
  {
    v20 = *(_QWORD *)(v18 - 248);
    if (v20)
      MEMORY[0x186DA165C](v20, 0x1000C8000313F17);
  }

  _Unwind_Resume(a1);
}

unint64_t GPU::DepthwiseConv3DDataGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 2)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 2u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::DepthwiseConv3DWeightsGradientOpHandler::encodeNDArrayOp(GPU::DepthwiseConv3DWeightsGradientOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  NSArray *v5;
  uint64_t v6;
  void *v7;
  uint64_t Input;
  uint64_t Filter;
  int8x8_t *v10;
  mlir::Block *ParentRegion;
  int8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int8x8_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  uint64_t ***v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  uint64_t *v35;
  int8x8_t *v36;
  mlir::Block *v37;
  int8x8_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint8x8_t v43;
  unint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  int8x8_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint8x8_t v54;
  unint64_t v55;
  uint64_t ***v56;
  uint64_t **v57;
  uint64_t v58;
  uint64_t *v59;
  unint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  void *v63;
  uint64_t Result;
  unint64_t StaticType;
  uint64_t Value;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  void *v74;
  id v75;
  int ChannelAxis;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  int64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t NumElements;
  int v88;
  BOOL v89;
  int v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  BOOL v96;
  int v97;
  unsigned int v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  BOOL v103;
  int v104;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  BOOL v110;
  uint64_t v111;
  uint64_t v112;
  _BOOL4 v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int PaddingStyle;
  uint64_t v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  uint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  unint64_t v134;
  GPU::EncodeDescriptor *v135;
  unint64_t v136;
  uint64_t v137;
  void *v138;
  void *v139;
  void *v140;
  void *v141;
  uint64_t v142;
  void *v143;
  void *v144;
  uint64_t v145;
  void *v146;
  id v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  const char *v152;
  int v153;
  const char *v154;
  const char *v155;
  const char *v156;
  int v157;
  const char *v158;
  const char *v159;
  _QWORD *AttrData;
  uint64_t v161;
  BOOL v162;
  BOOL v163;
  BOOL v164;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  GPU::EncodeDescriptor *v169;
  uint64_t v170;
  NSArray *v171;
  void *v172;
  void *v173;
  void *v174;
  uint64_t v175;
  __int128 v176;
  const char *v177;
  __int16 v178;
  const char *v179;
  uint64_t v180;
  const char *v181;
  uint64_t v182;
  __int16 v183;
  __int128 v184;
  uint64_t v185;
  __int128 v186;
  uint64_t v187;
  __int128 v188;
  unint64_t v189;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  uint64_t Strides;
  uint64_t v193;
  _QWORD v194[2];
  _QWORD v195[2];
  _QWORD v196[2];
  __int128 v197;
  __int128 v198;
  __int128 v199;
  uint64_t v200;

  v200 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(_QWORD *)&v197 = *(_QWORD *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v197);
    if (v161 == 38)
    {
      v162 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      v163 = v162 && AttrData[2] == 0x65775F64335F766ELL;
      v164 = v163 && AttrData[3] == 0x72675F7374686769;
      if (v164 && *(_QWORD *)((char *)AttrData + 30) == 0x746E656964617267)
      {
        v183 = 1283;
        v179 = "classof on '";
        v181 = "mps.depthwise_conv_3d_weights_gradient";
        v182 = 38;
        *(_QWORD *)&v176 = "' failed due to the operation not being registered";
        v178 = 259;
        llvm::operator+((uint64_t *)&v179, (uint64_t *)&v176, (uint64_t)&v197);
        llvm::report_fatal_error((llvm::Twine *)&v197, 1);
      }
    }
LABEL_243:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DWeightsGradientOp,void>::id)
    goto LABEL_243;
  v175 = *((_QWORD *)this + 3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v175);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v175);
  v10 = (int8x8_t *)*((_QWORD *)this + 2);
  *(_QWORD *)&v197 = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)&v197);
  v12 = v10[12];
  if (!*(_QWORD *)&v12)
    goto LABEL_44;
  v13 = *((_QWORD *)ParentRegion + 2);
  v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(_QWORD *)&v12)
      v18 = v16 % *(_QWORD *)&v12;
  }
  else
  {
    v18 = v16 & (*(_QWORD *)&v12 - 1);
  }
  v19 = *(_QWORD **)(*(_QWORD *)&v10[11] + 8 * v18);
  if (!v19)
    goto LABEL_44;
  v20 = (_QWORD *)*v19;
  if (!v20)
    goto LABEL_44;
  if (v17.u32[0] < 2uLL)
  {
    v21 = *(_QWORD *)&v12 - 1;
    while (1)
    {
      v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13)
          goto LABEL_24;
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      v20 = (_QWORD *)*v20;
      if (!v20)
        goto LABEL_44;
    }
  }
  while (1)
  {
    v22 = v20[1];
    if (v22 == v16)
      break;
    if (v22 >= *(_QWORD *)&v12)
      v22 %= *(_QWORD *)&v12;
    if (v22 != v18)
      goto LABEL_44;
LABEL_13:
    v20 = (_QWORD *)*v20;
    if (!v20)
      goto LABEL_44;
  }
  if (v20[2] != v13)
    goto LABEL_13;
LABEL_24:
  v24 = (int8x8_t)v20[4];
  if (v24)
  {
    v25 = 0x9DDFEA08EB382D69 * (((8 * v197) + 8) ^ DWORD1(v197));
    v26 = 0x9DDFEA08EB382D69 * (DWORD1(v197) ^ (v25 >> 47) ^ v25);
    v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    v28 = (uint8x8_t)vcnt_s8(v24);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      v29 = v27;
      if (v27 >= *(_QWORD *)&v24)
        v29 = v27 % *(_QWORD *)&v24;
    }
    else
    {
      v29 = v27 & (*(_QWORD *)&v24 - 1);
    }
    v30 = *(uint64_t ****)(v20[3] + 8 * v29);
    if (v30)
    {
      v31 = *v30;
      if (v31)
      {
        if (v28.u32[0] < 2uLL)
        {
          v32 = *(_QWORD *)&v24 - 1;
          while (1)
          {
            v35 = v31[1];
            if (v35 == (uint64_t *)v27)
            {
              if (v31[2] == (uint64_t *)v197)
                goto LABEL_213;
            }
            else if (((unint64_t)v35 & v32) != v29)
            {
              goto LABEL_44;
            }
            v33 = 0;
            v31 = (uint64_t **)*v31;
            if (!v31)
              goto LABEL_45;
          }
        }
        while (1)
        {
          v34 = (unint64_t)v31[1];
          if (v34 == v27)
          {
            if (v31[2] == (uint64_t *)v197)
            {
LABEL_213:
              v33 = v31[3];
              goto LABEL_45;
            }
          }
          else
          {
            if (v34 >= *(_QWORD *)&v24)
              v34 %= *(_QWORD *)&v24;
            if (v34 != v29)
              break;
          }
          v33 = 0;
          v31 = (uint64_t **)*v31;
          if (!v31)
            goto LABEL_45;
        }
      }
    }
  }
LABEL_44:
  v33 = 0;
LABEL_45:
  objc_msgSend(v33, "mpsndarray");
  v173 = (void *)objc_claimAutoreleasedReturnValue();

  v36 = (int8x8_t *)*((_QWORD *)this + 2);
  *(_QWORD *)&v197 = Filter;
  v37 = mlir::Value::getParentRegion((mlir::Value *)&v197);
  v38 = v36[12];
  if (!*(_QWORD *)&v38)
    goto LABEL_86;
  v39 = *((_QWORD *)v37 + 2);
  v40 = 0x9DDFEA08EB382D69 * (((8 * v39) + 8) ^ HIDWORD(v39));
  v41 = 0x9DDFEA08EB382D69 * (HIDWORD(v39) ^ (v40 >> 47) ^ v40);
  v42 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
  v43 = (uint8x8_t)vcnt_s8(v38);
  v43.i16[0] = vaddlv_u8(v43);
  if (v43.u32[0] > 1uLL)
  {
    v44 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
    if (v42 >= *(_QWORD *)&v38)
      v44 = v42 % *(_QWORD *)&v38;
  }
  else
  {
    v44 = v42 & (*(_QWORD *)&v38 - 1);
  }
  v45 = *(_QWORD **)(*(_QWORD *)&v36[11] + 8 * v44);
  if (!v45)
    goto LABEL_86;
  v46 = (_QWORD *)*v45;
  if (!v46)
    goto LABEL_86;
  if (v43.u32[0] < 2uLL)
  {
    v47 = *(_QWORD *)&v38 - 1;
    while (1)
    {
      v49 = v46[1];
      if (v49 == v42)
      {
        if (v46[2] == v39)
          goto LABEL_66;
      }
      else if ((v49 & v47) != v44)
      {
        goto LABEL_86;
      }
      v46 = (_QWORD *)*v46;
      if (!v46)
        goto LABEL_86;
    }
  }
  while (1)
  {
    v48 = v46[1];
    if (v48 == v42)
      break;
    if (v48 >= *(_QWORD *)&v38)
      v48 %= *(_QWORD *)&v38;
    if (v48 != v44)
      goto LABEL_86;
LABEL_55:
    v46 = (_QWORD *)*v46;
    if (!v46)
      goto LABEL_86;
  }
  if (v46[2] != v39)
    goto LABEL_55;
LABEL_66:
  v50 = (int8x8_t)v46[4];
  if (!*(_QWORD *)&v50)
    goto LABEL_86;
  v51 = 0x9DDFEA08EB382D69 * (((8 * v197) + 8) ^ DWORD1(v197));
  v52 = 0x9DDFEA08EB382D69 * (DWORD1(v197) ^ (v51 >> 47) ^ v51);
  v53 = 0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47));
  v54 = (uint8x8_t)vcnt_s8(v50);
  v54.i16[0] = vaddlv_u8(v54);
  if (v54.u32[0] > 1uLL)
  {
    v55 = v53;
    if (v53 >= *(_QWORD *)&v50)
      v55 = v53 % *(_QWORD *)&v50;
  }
  else
  {
    v55 = v53 & (*(_QWORD *)&v50 - 1);
  }
  v56 = *(uint64_t ****)(v46[3] + 8 * v55);
  if (!v56 || (v57 = *v56) == 0)
  {
LABEL_86:
    v59 = 0;
    goto LABEL_87;
  }
  if (v54.u32[0] < 2uLL)
  {
    v58 = *(_QWORD *)&v50 - 1;
    while (1)
    {
      v61 = v57[1];
      if (v61 == (uint64_t *)v53)
      {
        if (v57[2] == (uint64_t *)v197)
          goto LABEL_214;
      }
      else if (((unint64_t)v61 & v58) != v55)
      {
        goto LABEL_86;
      }
      v59 = 0;
      v57 = (uint64_t **)*v57;
      if (!v57)
        goto LABEL_87;
    }
  }
  while (1)
  {
    v60 = (unint64_t)v57[1];
    if (v60 == v53)
      break;
    if (v60 >= *(_QWORD *)&v50)
      v60 %= *(_QWORD *)&v50;
    if (v60 != v55)
      goto LABEL_86;
LABEL_76:
    v59 = 0;
    v57 = (uint64_t **)*v57;
    if (!v57)
      goto LABEL_87;
  }
  if (v57[2] != (uint64_t *)v197)
    goto LABEL_76;
LABEL_214:
  v59 = v57[3];
LABEL_87:
  objc_msgSend(v59, "mpsndarray");
  v174 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSArray objectAtIndexedSubscript:](v5, "objectAtIndexedSubscript:", 0);
  v172 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v172, "mpsndarray");
  v62 = objc_claimAutoreleasedReturnValue();
  v63 = (void *)v62;
  if ((!v173 || !v174 || !v62) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (*((_QWORD *)this + 4) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v175);
  StaticType = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Result);
  if (!*(_QWORD *)StaticType)
  {
    v152 = "abstractType && \"Malformed type storage object.\"";
    v153 = 160;
    v154 = "TypeSupport.h";
    v155 = "getAbstractType";
    goto LABEL_222;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v152 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v153 = 566;
    v154 = "Casting.h";
    v155 = "cast";
LABEL_222:
    __assert_rtn(v155, v154, v153, v152);
  }
  *(_QWORD *)&v197 = StaticType;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v197);
  v68 = v67;
  v69 = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Filter);
  if (!*(_QWORD *)v69)
  {
    v156 = "abstractType && \"Malformed type storage object.\"";
    v157 = 160;
    v158 = "TypeSupport.h";
    v159 = "getAbstractType";
    goto LABEL_225;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v69 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v156 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v157 = 566;
    v158 = "Casting.h";
    v159 = "cast";
LABEL_225:
    __assert_rtn(v159, v158, v157, v156);
  }
  *(_QWORD *)&v197 = v69;
  v70 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v197);
  v72 = v71;
  v73 = v175;
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  v193 = v73;
  v75 = v74;
  Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v193);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v193);
  v198 = 0u;
  v199 = 0u;
  v197 = 0u;
  v170 = v68;
  v166 = Value;
  v169 = a2;
  v171 = v5;
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v193);
  ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v193);
  if (ChannelAxis >= 0)
    v77 = v72;
  else
    v77 = 0;
  v167 = v77;
  v168 = ChannelAxis;
  if (ChannelAxis >= 0)
    v78 = 0;
  else
    v78 = v72;
  v188 = xmmword_181287390;
  v79 = 1;
  v189 = 1;
  v80 = v78 + ChannelAxis;
  v186 = xmmword_181287390;
  v187 = 1;
  v81 = 1;
  v82 = 1;
  if (v72 >= 3)
  {
    v83 = (int)(v72 - 1 - (v80 >= (int)v72 - 1));
    if (v72 <= v83
      || (v84 = (int)(v72 - 2 - (v80 >= (int)v72 - 2)), v72 <= v84)
      || (v85 = (int)(v72 - 3 - (v80 >= (int)v72 - 3)), v72 <= v85))
    {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    v82 = *(_QWORD *)(v70 + 8 * v83);
    v81 = *(_QWORD *)(v70 + 8 * v84);
    v79 = *(_QWORD *)(v70 + 8 * v85);
  }
  if (Strides && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v179, Strides, 0);
    v86 = Strides;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v176, v86, NumElements);
    v88 = 2;
    while (1)
    {
      v89 = v179 == (const char *)v176 && v180 == BYTE8(v176);
      if (v89 && v181 == v177)
        goto LABEL_123;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v179, (llvm::APInt *)&v184);
      v90 = DWORD2(v184);
      if (DWORD2(v184) < 0x41)
      {
        *((_QWORD *)&v188 + v88--) = v184;
        goto LABEL_110;
      }
      v91 = v90 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v184);
      v92 = v184;
      if (v91 <= 0x40)
        break;
      *((_QWORD *)&v188 + v88--) = -1;
      if (v92)
        goto LABEL_122;
LABEL_110:
      ++v181;
    }
    *((_QWORD *)&v188 + v88--) = *(_QWORD *)v184;
LABEL_122:
    MEMORY[0x186DA165C]();
    goto LABEL_110;
  }
LABEL_123:
  if (InputAttributeNames
    && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames) == 3)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v179, InputAttributeNames, 0);
    v93 = InputAttributeNames;
    v94 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v176, v93, v94);
    v95 = 2;
    while (1)
    {
      v96 = v179 == (const char *)v176 && v180 == BYTE8(v176);
      if (v96 && v181 == v177)
        goto LABEL_140;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v179, (llvm::APInt *)&v184);
      v97 = DWORD2(v184);
      if (DWORD2(v184) < 0x41)
      {
        *((_QWORD *)&v186 + v95--) = v184;
        goto LABEL_127;
      }
      v98 = v97 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v184);
      v99 = v184;
      if (v98 <= 0x40)
        break;
      *((_QWORD *)&v186 + v95--) = -1;
      if (v99)
        goto LABEL_139;
LABEL_127:
      ++v181;
    }
    *((_QWORD *)&v186 + v95--) = *(_QWORD *)v184;
LABEL_139:
    MEMORY[0x186DA165C]();
    goto LABEL_127;
  }
LABEL_140:
  if (Rewriter && mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter) == 6)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v179, Rewriter, 0);
    v100 = Rewriter;
    v101 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v176, v100, v101);
    v102 = 5;
    while (1)
    {
      v103 = v179 == (const char *)v176 && v180 == BYTE8(v176);
      if (v103 && v181 == v177)
        goto LABEL_157;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v179, (llvm::APInt *)&v184);
      v104 = DWORD2(v184);
      if (DWORD2(v184) < 0x41)
      {
        *((_QWORD *)&v197 + v102--) = v184;
        goto LABEL_144;
      }
      v105 = v104 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v184);
      v106 = v184;
      if (v105 <= 0x40)
        break;
      *((_QWORD *)&v197 + v102--) = -1;
      if (v106)
        goto LABEL_156;
LABEL_144:
      ++v181;
    }
    *((_QWORD *)&v197 + v102--) = *(_QWORD *)v184;
LABEL_156:
    MEMORY[0x186DA165C]();
    goto LABEL_144;
  }
LABEL_157:
  if (v170 == 4)
  {
    v107 = v80 - v72 + 4;
    v108 = 24;
    if (v107 > 2)
      v108 = 16;
    v109 = *(_QWORD *)(v166 + v108);
    v110 = __OFSUB__(v107, 1);
    v89 = v107 == 1;
    v111 = 8;
    if (((uint64_t)(v80 - v72 + 3) < 0) ^ v110 | v89)
      v111 = 16;
    v112 = *(_QWORD *)(v166 + v111);
    v113 = (uint64_t)(v80 - v72 + 3) < 0 != v110;
    v114 = v109 - 1;
    v115 = v112 - 1;
    v116 = *(_QWORD *)(v166 + 8 * v113) - 1;
  }
  else
  {
    v114 = 0;
    v115 = 0;
    v116 = 0;
  }
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v193);
  if (PaddingStyle >= 3 && PaddingStyle != 4)
    __assert_rtn("createDepthwiseConv3D", "GPUDepthwiseConvOps.mm", 791, "0 && \"Unknown paddingStyle\"");
  v118 = v186 * v114 + 1;
  if (PaddingStyle)
  {
    if (PaddingStyle == 2 || PaddingStyle == 4)
    {
      v119 = v188;
      if (v82 % (unint64_t)v188)
        v119 = v82 % (unint64_t)v188;
      v120 = (v118 - v119) & ~((uint64_t)(v118 - v119) >> 63);
      v121 = v120 >> 1;
      v122 = v120 - (v120 >> 1);
      if (PaddingStyle != 4)
        v122 = v121;
    }
    else
    {
      v122 = 0;
    }
    if (v118 < 0)
      v118 = v186 * v114 + 2;
    v123 = (const char *)((v118 >> 1) - v122);
    v124 = *((_QWORD *)&v186 + 1) * v115 + 1;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      v125 = *((_QWORD *)&v188 + 1);
      if (v81 % *((_QWORD *)&v188 + 1))
        v125 = v81 % *((_QWORD *)&v188 + 1);
      v126 = (v124 - v125) & ~((uint64_t)(v124 - v125) >> 63);
      v127 = v126 >> 1;
      v128 = v126 - (v126 >> 1);
      if (PaddingStyle != 4)
        v128 = v127;
    }
    else
    {
      v128 = 0;
    }
    if (v124 < 0)
      v124 = *((_QWORD *)&v186 + 1) * v115 + 2;
    v129 = (v124 >> 1) - v128;
    v130 = v187 * v116 + 1;
    v135 = v169;
    if (PaddingStyle == 4 || PaddingStyle == 2)
    {
      v131 = v189;
      if (v79 % v189)
        v131 = v79 % v189;
      v132 = (v130 - v131) & ~((uint64_t)(v130 - v131) >> 63);
      v133 = v132 >> 1;
      v134 = v132 - (v132 >> 1);
      if (PaddingStyle == 4)
        v136 = v134;
      else
        v136 = v133;
    }
    else
    {
      v136 = 0;
    }
  }
  else
  {
    if (v118 < 0)
      v118 = v186 * v114 + 2;
    v123 = (const char *)((v118 >> 1) - *((_QWORD *)&v197 + 1));
    v129 = (*((_QWORD *)&v186 + 1) * v115 + 1) / 2 - *((_QWORD *)&v198 + 1);
    v130 = v187 * v116 + 1;
    v135 = v169;
    v136 = *((_QWORD *)&v199 + 1);
  }
  if (v130 >= 0)
    v137 = v130;
  else
    v137 = v130 + 1;
  v138 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6FD8]), "initWithDevice:", v75);
  v179 = v123;
  v180 = v129;
  v181 = (const char *)((v137 >> 1) - v136);
  objc_msgSend(v138, "setWindowOffsets:", &v179);
  v176 = v188;
  v177 = (const char *)v189;
  objc_msgSend(v138, "setConvStrides:", &v176);
  v184 = v186;
  v185 = v187;
  objc_msgSend(v138, "setConvDilationRates:", &v184);
  objc_msgSend(v138, "setChannelAxis:", v167 + ~v168);
  objc_msgSend(v138, "setOptions:", objc_msgSend(v138, "options") | 1);

  if (*((_BYTE *)v63 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v63, "setReadCount:", objc_msgSend(v63, "readCount") + 1);
  v196[0] = v174;
  v196[1] = v63;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v196, 2);
  v139 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v138, "resultStateForSourceArrays:sourceStates:destinationArray:", v139, 0, v63);
  v140 = (void *)objc_claimAutoreleasedReturnValue();

  v141 = (void *)*((_QWORD *)v135 + 9);
  if (!v141)
  {
    v142 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)v135 + 1), 0);
    v143 = (void *)*((_QWORD *)v135 + 9);
    *((_QWORD *)v135 + 9) = v142;

    v144 = (void *)*((_QWORD *)v135 + 11);
    v141 = (void *)*((_QWORD *)v135 + 9);
    if (v144)
    {
      objc_msgSend(v144, "wrapComputeEncoder:", *((_QWORD *)v135 + 9));
      v145 = objc_claimAutoreleasedReturnValue();
      v146 = (void *)*((_QWORD *)v135 + 9);
      *((_QWORD *)v135 + 9) = v145;

      v141 = (void *)*((_QWORD *)v135 + 9);
    }
  }
  if (*((_QWORD *)v135 + 10))
  {
    objc_msgSend(v141, "setLabel:");
    v141 = (void *)*((_QWORD *)v135 + 9);
  }
  v147 = v141;
  v148 = *((_QWORD *)v135 + 1);
  v195[0] = v174;
  v195[1] = v63;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v195, 2);
  v149 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99E38], "null");
  v150 = (void *)objc_claimAutoreleasedReturnValue();
  v194[0] = v150;
  v194[1] = v63;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v194, 2);
  v151 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v138, "encodeGradientsToCommandEncoder:commandBuffer:sourceArrays:sourceGradient:gradientState:destinationGradients:kernelDAGObject:", v147, v148, v149, v173, v140, v151, 0);

}

void sub_180E1FC74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

unint64_t GPU::DepthwiseConv3DWeightsGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 2)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 2u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::DepthwiseConv2DOpHandler::~DepthwiseConv2DOpHandler(GPU::DepthwiseConv2DOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::DepthwiseConv2DDataGradientOpHandler::~DepthwiseConv2DDataGradientOpHandler(GPU::DepthwiseConv2DDataGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::DepthwiseConv2DWeightsGradientOpHandler::~DepthwiseConv2DWeightsGradientOpHandler(GPU::DepthwiseConv2DWeightsGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

uint64_t GPU::DepthwiseConv3DOpHandler::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  GPU::DepthwiseConv3DOpHandler *v3;
  uint64_t v4;
  void *v5;
  uint64_t result;
  unint64_t Input;
  unint64_t Filter;
  _QWORD *AttrData;
  uint64_t v11;
  BOOL v12;
  uint64_t v14[4];
  __int16 v15;
  uint64_t v16[4];
  __int16 v17;
  _QWORD v18[5];

  v3 = *(GPU::DepthwiseConv3DOpHandler **)(a1 + 24);
  v4 = *((_QWORD *)v3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v18[0] = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v18);
    if (v11 == 21)
    {
      v12 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v12 && *(_QWORD *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        v17 = 1283;
        v16[0] = (uint64_t)"classof on '";
        v16[2] = (uint64_t)"mps.depthwise_conv_3d";
        v16[3] = 21;
        v14[0] = (uint64_t)"' failed due to the operation not being registered";
        v15 = 259;
        llvm::operator+(v16, v14, (uint64_t)v18);
        llvm::report_fatal_error((llvm::Twine *)v18, 1);
      }
    }
LABEL_17:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
    goto LABEL_17;
  v18[0] = v3;
  v16[0] = 0;
  v14[0] = 0;
  if (GPU::DepthwiseConv3DOpHandler::getQuantizationParameters(v3, (mlir::Value *)v16, (mlir::Value *)v14))
  {
    GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, v16[0], 0);
    GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, v14[0], 0);
    MPSKernelDAG::binaryCoreOp();
    result = MPSKernelDAG::castOp();
  }
  else
  {
    Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v18);
    GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
    Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v18);
    GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Filter, 0);
    result = MPSKernelDAG::binaryCoreOp();
  }
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 24);
  return result;
}

void GPU::DepthwiseConv3DOpHandler::~DepthwiseConv3DOpHandler(GPU::DepthwiseConv3DOpHandler *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E0E1EA20;
  v2 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  GPU::BaseOpHandler::~BaseOpHandler(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E0E1EA20;
  v2 = *((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::DepthwiseConv3DDataGradientOpHandler::~DepthwiseConv3DDataGradientOpHandler(GPU::DepthwiseConv3DDataGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::DepthwiseConv3DWeightsGradientOpHandler::~DepthwiseConv3DWeightsGradientOpHandler(GPU::DepthwiseConv3DWeightsGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

GPU::MPSGraphKernelDAG *GPU::MPSGraphKernelDAG::MPSGraphKernelDAG(GPU::MPSGraphKernelDAG *this, GPURegionRuntime *a2, mlir::Operation *a3)
{
  uint64_t v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;

  *(_QWORD *)this = &unk_1E0E1C650;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 12) = 1065353216;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 14) = a3;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = a2;
  *((_QWORD *)this + 17) = 0;
  v4 = operator new();
  MPSKernelDAG::MPSKernelDAG();
  v5 = (_QWORD *)operator new();
  *v5 = &unk_1E0E52158;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
  *((_QWORD *)this + 10) = v4;
  *((_QWORD *)this + 11) = v5;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  v9 = (void *)*((_QWORD *)this + 15);
  *((_QWORD *)this + 15) = 0;

  v10 = operator new();
  v11 = *((_QWORD *)this + 17);
  v12 = *((_QWORD *)this + 16) != 0;
  *(_QWORD *)v10 = &unk_1E0E4B878;
  *(_BYTE *)(v10 + 16) = v12;
  *((_QWORD *)this + 17) = v10;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
  return this;
}

void sub_180E202E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v11;
  void *v12;
  uint64_t v14;

  v14 = *(_QWORD *)(v11 + 136);
  *(_QWORD *)(v11 + 136) = 0;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);

    mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)(v11 + 80));
    v12 = *(void **)(v11 + 56);
    if (v12)
    {
LABEL_6:
      *(_QWORD *)(v11 + 64) = v12;
      operator delete(v12);
      std::unordered_set<mlir::Operation *>::~unordered_set[abi:ne180100](v11 + 16);
      _Unwind_Resume(a1);
    }
  }
  else
  {

    mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)(v11 + 80));
    v12 = *(void **)(v11 + 56);
    if (v12)
      goto LABEL_6;
  }
  std::unordered_set<mlir::Operation *>::~unordered_set[abi:ne180100](v11 + 16);
  _Unwind_Resume(a1);
}

void GPU::MPSGraphKernelDAG::~MPSGraphKernelDAG(GPU::MPSGraphKernelDAG *this)
{
  GPU::MPSGraphKernelDAG::~MPSGraphKernelDAG(this);
  JUMPOUT(0x186DA1680);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;

  *(_QWORD *)this = &unk_1E0E1C650;
  v2 = *((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);

  v3 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
  if (!v3)
    goto LABEL_7;
  p_shared_owners = (unint64_t *)&v3->__shared_owners_;
  do
    v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (v5)
  {
LABEL_7:
    v6 = (void *)*((_QWORD *)this + 7);
    if (!v6)
      goto LABEL_9;
    goto LABEL_8;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  v6 = (void *)*((_QWORD *)this + 7);
  if (v6)
  {
LABEL_8:
    *((_QWORD *)this + 8) = v6;
    operator delete(v6);
  }
LABEL_9:
  v7 = (_QWORD *)*((_QWORD *)this + 4);
  if (v7)
  {
    do
    {
      v8 = (_QWORD *)*v7;
      operator delete(v7);
      v7 = v8;
    }
    while (v8);
  }
  v9 = (void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = 0;
  if (v9)
    operator delete(v9);
}

void std::__shared_ptr_pointer<MPSKernelDAG *,std::shared_ptr<MPSKernelDAG>::__shared_ptr_default_delete<MPSKernelDAG,MPSKernelDAG>,std::allocator<MPSKernelDAG>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x186DA1680);
}

uint64_t std::__shared_ptr_pointer<MPSKernelDAG *,std::shared_ptr<MPSKernelDAG>::__shared_ptr_default_delete<MPSKernelDAG,MPSKernelDAG>,std::allocator<MPSKernelDAG>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<MPSKernelDAG *,std::shared_ptr<MPSKernelDAG>::__shared_ptr_default_delete<MPSKernelDAG,MPSKernelDAG>,std::allocator<MPSKernelDAG>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x8000000181287307)
    return a1 + 24;
  if (((v3 & 0x8000000181287307 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x8000000181287307))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x8000000181287307 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 24;
  return 0;
}

uint64_t mlir::mps::MPSFusableCoreOps::isCoreOperandStitchable(mlir::mps::MPSFusableCoreOps *this, mlir::Operation *a2, int a3)
{
  uint64_t v6;
  void *v7;
  uint64_t AttrData;
  uint64_t v9;
  BOOL v10;
  uint64_t v12;
  void *v13;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  void *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v30;
  void *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  _QWORD *v36;
  uint64_t v37;
  BOOL v38;
  uint64_t v40;
  void *v41;
  _QWORD *v42;
  uint64_t v43;
  BOOL v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  BOOL v49;
  uint64_t v50;
  void *v51;
  _QWORD *v52;
  uint64_t v53;
  BOOL v54;
  const char *v56;
  uint64_t v57;
  const char *v58;
  const char *v59;
  const char *v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  const char *v64;
  uint64_t v65;
  __int16 v66;
  _QWORD v67[5];

  v6 = *((_QWORD *)a2 + 6);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v67[0] = *(_QWORD *)(v6 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
    if (v9 == 17)
    {
      v10 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x75735F6E6F697463;
      if (v10 && *(_BYTE *)(AttrData + 16) == 109)
      {
        v66 = 1283;
        v56 = "mps.reduction_sum";
        goto LABEL_90;
      }
    }
  }
  else if (v7 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id)
  {
    return a3 < 1;
  }
  v12 = *((_QWORD *)a2 + 6);
  v13 = *(void **)(v12 + 16);
  if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v67[0] = *(_QWORD *)(v12 + 8);
    v15 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
    if (v16 != 17)
      goto LABEL_23;
    v17 = *(_QWORD *)v15 == 0x756465722E73706DLL && *(_QWORD *)(v15 + 8) == 0x616D5F6E6F697463;
    if (!v17 || *(_BYTE *)(v15 + 16) != 120)
      goto LABEL_23;
    v66 = 1283;
    v56 = "mps.reduction_max";
LABEL_90:
    v63 = "classof on '";
    v64 = v56;
    v57 = 17;
    goto LABEL_101;
  }
  if (v13 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id)
    return a3 < 1;
LABEL_23:
  v19 = *((_QWORD *)a2 + 6);
  v20 = *(void **)(v19 + 16);
  if (v20 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v67[0] = *(_QWORD *)(v19 + 8);
    v22 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
    if (v23 == 10 && *(_QWORD *)v22 == 0x6D74616D2E73706DLL && *(_WORD *)(v22 + 8) == 27765)
    {
      v66 = 1283;
      v58 = "mps.matmul";
      goto LABEL_98;
    }
LABEL_31:
    v25 = *((_QWORD *)a2 + 6);
    v26 = *(void **)(v25 + 16);
    if (v26 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v67[0] = *(_QWORD *)(v25 + 8);
      v27 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
      if (v28 == 11 && *v27 == 0x766E6F632E73706DLL && *(_QWORD *)((char *)v27 + 3) == 0x64325F766E6F632ELL)
      {
        v66 = 1283;
        v59 = "mps.conv_2d";
        goto LABEL_96;
      }
    }
    else if (v26 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    {
      v21 = (void *)MEMORY[0x1E0CC6F88];
      return objc_msgSend(v21, "supportsPrefixForDevice:", *((_QWORD *)this + 1));
    }
    v30 = *((_QWORD *)a2 + 6);
    v31 = *(void **)(v30 + 16);
    if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v67[0] = *(_QWORD *)(v30 + 8);
      v32 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
      if (v33 == 8 && *v32 == 0x656C69742E73706DLL)
      {
        v66 = 1283;
        v63 = "classof on '";
        v64 = "mps.tile";
        v57 = 8;
        goto LABEL_101;
      }
    }
    else if (v31 == &mlir::detail::TypeIDResolver<mlir::mps::TileOp,void>::id)
    {
      if (*((_BYTE *)this + 16))
        return 0;
      v21 = (void *)MEMORY[0x1E0CC7198];
      return objc_msgSend(v21, "supportsPrefixForDevice:", *((_QWORD *)this + 1));
    }
    v34 = *((_QWORD *)a2 + 6);
    v35 = *(void **)(v34 + 16);
    if (v35 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v67[0] = *(_QWORD *)(v34 + 8);
      v36 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
      if (v37 == 21)
      {
        v38 = *v36 == 0x747065642E73706DLL && v36[1] == 0x6F635F6573697768;
        if (v38 && *(_QWORD *)((char *)v36 + 13) == 0x64335F766E6F635FLL)
        {
          v66 = 1283;
          v60 = "mps.depthwise_conv_3d";
LABEL_100:
          v63 = "classof on '";
          v64 = v60;
          v57 = 21;
LABEL_101:
          v65 = v57;
          v61 = "' failed due to the operation not being registered";
          v62 = 259;
          llvm::operator+((uint64_t *)&v63, (uint64_t *)&v61, (uint64_t)v67);
          llvm::report_fatal_error((llvm::Twine *)v67, 1);
        }
      }
    }
    else if (v35 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
    {
      v21 = (void *)MEMORY[0x1E0CC6FD8];
      return objc_msgSend(v21, "supportsPrefixForDevice:", *((_QWORD *)this + 1));
    }
    v40 = *((_QWORD *)a2 + 6);
    v41 = *(void **)(v40 + 16);
    if (v41 != &mlir::detail::TypeIDResolver<void,void>::id)
    {
      if (v41 == &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
      {
        if (*((_BYTE *)this + 16))
          return 0;
        v21 = (void *)MEMORY[0x1E0CC7170];
        return objc_msgSend(v21, "supportsPrefixForDevice:", *((_QWORD *)this + 1));
      }
      goto LABEL_65;
    }
    v67[0] = *(_QWORD *)(v40 + 8);
    v42 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
    if (v43 != 11
      || (*v42 == 0x6E6574732E73706DLL ? (v44 = *(_QWORD *)((char *)v42 + 3) == 0x6C69636E6574732ELL) : (v44 = 0), !v44))
    {
LABEL_65:
      v45 = *((_QWORD *)a2 + 6);
      v46 = *(void **)(v45 + 16);
      if (v46 != &mlir::detail::TypeIDResolver<void,void>::id)
      {
        if (v46 == &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id)
          return 0;
        goto LABEL_73;
      }
      v67[0] = *(_QWORD *)(v45 + 8);
      v47 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
      if (v48 != 10
        || (*(_QWORD *)v47 == 0x697365722E73706DLL ? (v49 = *(unsigned __int16 *)(v47 + 8) == 25978) : (v49 = 0), !v49))
      {
LABEL_73:
        v50 = *((_QWORD *)a2 + 6);
        v51 = *(void **)(v50 + 16);
        if (v51 != &mlir::detail::TypeIDResolver<void,void>::id)
        {
          if (v51 == &mlir::detail::TypeIDResolver<mlir::mpsx::QuantizedMatMulOp,void>::id)
          {
            v21 = (void *)MEMORY[0x1E0CC70F8];
            return objc_msgSend(v21, "supportsPrefixForDevice:", *((_QWORD *)this + 1));
          }
          return 1;
        }
        v67[0] = *(_QWORD *)(v50 + 8);
        v52 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
        if (v53 != 21)
          return 1;
        v54 = *v52 == 0x6175712E7873706DLL && v52[1] == 0x6D5F64657A69746ELL;
        if (!v54 || *(_QWORD *)((char *)v52 + 13) != 0x6C756D74616D5F64)
          return 1;
        v66 = 1283;
        v60 = "mpsx.quantized_matmul";
        goto LABEL_100;
      }
      v66 = 1283;
      v58 = "mps.resize";
LABEL_98:
      v63 = "classof on '";
      v64 = v58;
      v57 = 10;
      goto LABEL_101;
    }
    v66 = 1283;
    v59 = "mps.stencil";
LABEL_96:
    v63 = "classof on '";
    v64 = v59;
    v57 = 11;
    goto LABEL_101;
  }
  if (v20 != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
    goto LABEL_31;
  v21 = (void *)MEMORY[0x1E0CC7078];
  return objc_msgSend(v21, "supportsPrefixForDevice:", *((_QWORD *)this + 1));
}

uint64_t mlir::mps::MPSFusableCoreOps::isCorePostfixStitchable(mlir::mps::MPSFusableCoreOps *this, mlir::Operation *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t AttrData;
  uint64_t v8;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t Input;
  uint64_t Filter;
  uint64_t v16;
  uint64_t v17;
  uint64_t **v18;
  uint64_t v19;
  uint64_t InterfaceFor;
  uint64_t **v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v25;
  void *v26;
  void *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  BOOL v51;
  uint64_t v53;
  uint64_t **v54;
  uint64_t v55;
  _QWORD *ArgAttrsAttr;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  id v65;
  uint64_t Value;
  unint64_t v67;
  _QWORD *v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t *v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int i;
  BOOL v77;
  int v78;
  uint64_t v79;
  int j;
  BOOL v82;
  int v83;
  uint64_t v84;
  int k;
  BOOL v86;
  int v87;
  uint64_t v88;
  int m;
  BOOL v90;
  int v91;
  uint64_t v92;
  const char *v93;
  uint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  const char *v98;
  const char *v99;
  uint64_t v100;
  const char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  const char *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  const char *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  const char *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t InputAttributeNames;
  uint64_t Strides;
  uint64_t **v130;
  uint64_t v131;
  uint64_t **v132;
  uint64_t **v133;
  uint64_t v134;
  uint64_t **v135;
  uint64_t **v136;
  uint64_t v137;
  unint64_t v138;
  _QWORD v139[2];

  v4 = *((_QWORD *)a2 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v122 = *(const char **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v122);
    if (v8 == 10 && *(_QWORD *)AttrData == 0x6D74616D2E73706DLL && *(_WORD *)(AttrData + 8) == 27765)
    {
      LOWORD(v120) = 1283;
      v93 = "mps.matmul";
      goto LABEL_208;
    }
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
  {
    return objc_msgSend(MEMORY[0x1E0CC7078], "supportsPostfixForDevice:", *((_QWORD *)this + 1));
  }
  v10 = *((_QWORD *)a2 + 6);
  v11 = *(void **)(v10 + 16);
  if (v11 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v122 = *(const char **)(v10 + 8);
    v22 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v122);
    if (v23 == 11 && *v22 == 0x766E6F632E73706DLL && *(_QWORD *)((char *)v22 + 3) == 0x64325F766E6F632ELL)
    {
LABEL_205:
      LOWORD(v120) = 1283;
      v98 = "mps.conv_2d";
LABEL_206:
      v116 = "classof on '";
      v118 = (uint64_t)v98;
      v94 = 11;
      goto LABEL_213;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v12 = *((_QWORD *)a2 + 6);
      v13 = *(void **)(v12 + 16);
      if (v13 != &mlir::detail::TypeIDResolver<void,void>::id)
      {
        if (v13 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
        {
          v139[0] = a2;
          Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v139);
          Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v139);
          v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v139);
          v17 = *(_QWORD *)(Input + 8);
          v18 = (uint64_t **)(v17 & 0xFFFFFFFFFFFFFFF8);
          v138 = v17 & 0xFFFFFFFFFFFFFFF8;
          if ((v17 & 0xFFFFFFFFFFFFFFF8) == 0)
            goto LABEL_81;
          v19 = v16;
          if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v17 & 0xFFFFFFFFFFFFFFF8)))
          {
            InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v18);
            if (!InterfaceFor)
              goto LABEL_195;
            v136 = v18;
            v137 = InterfaceFor;
            v21 = (uint64_t **)(*(_QWORD *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8);
            v135 = v21;
            if (!v21)
LABEL_81:
              __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
          }
          else
          {
            v136 = 0;
            v137 = 0;
            v21 = (uint64_t **)(*(_QWORD *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8);
            v135 = v21;
            if (!v21)
              goto LABEL_81;
          }
          if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v21))
          {
            v53 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v21);
            if (!v53)
              goto LABEL_195;
            v133 = v21;
            v134 = v53;
            v54 = (uint64_t **)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8);
            v132 = v54;
            if (!v54)
              goto LABEL_81;
          }
          else
          {
            v133 = 0;
            v134 = 0;
            v54 = (uint64_t **)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8);
            v132 = v54;
            if (!v54)
              goto LABEL_81;
          }
          if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54))
          {
            v130 = 0;
            v131 = 0;
            if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v136))
              return objc_msgSend(MEMORY[0x1E0CC6F88], "supportsPostfixForDevice:convolutionDescriptor:sourceTensorDescriptor:destinationTensorDescriptor:weightsTensorDescriptor:", *((_QWORD *)this + 1), 0, 0, 0, 0);
            goto LABEL_83;
          }
          v55 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54);
          if (v55)
          {
            v130 = v54;
            v131 = v55;
            if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v136))
              return objc_msgSend(MEMORY[0x1E0CC6F88], "supportsPostfixForDevice:convolutionDescriptor:sourceTensorDescriptor:destinationTensorDescriptor:weightsTensorDescriptor:", *((_QWORD *)this + 1), 0, 0, 0, 0);
LABEL_83:
            ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v136);
            if (v57)
            {
              v58 = 8 * v57;
              while (*ArgAttrsAttr != 0x8000000000000000)
              {
                ++ArgAttrsAttr;
                v58 -= 8;
                if (!v58)
                  goto LABEL_87;
              }
              return objc_msgSend(MEMORY[0x1E0CC6F88], "supportsPostfixForDevice:convolutionDescriptor:sourceTensorDescriptor:destinationTensorDescriptor:weightsTensorDescriptor:", *((_QWORD *)this + 1), 0, 0, 0, 0);
            }
LABEL_87:
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v133))
            {
              v59 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v133);
              if (v60)
              {
                v61 = 8 * v60;
                while (*v59 != 0x8000000000000000)
                {
                  ++v59;
                  v61 -= 8;
                  if (!v61)
                    goto LABEL_92;
                }
                return objc_msgSend(MEMORY[0x1E0CC6F88], "supportsPostfixForDevice:convolutionDescriptor:sourceTensorDescriptor:destinationTensorDescriptor:weightsTensorDescriptor:", *((_QWORD *)this + 1), 0, 0, 0, 0);
              }
LABEL_92:
              if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v130))
              {
                v62 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v130);
                if (v63)
                {
                  v64 = 8 * v63;
                  while (*v62 != 0x8000000000000000)
                  {
                    ++v62;
                    v64 -= 8;
                    if (!v64)
                      goto LABEL_97;
                  }
                  return objc_msgSend(MEMORY[0x1E0CC6F88], "supportsPostfixForDevice:convolutionDescriptor:sourceTensorDescriptor:destinationTensorDescriptor:weightsTensorDescriptor:", *((_QWORD *)this + 1), 0, 0, 0, 0);
                }
LABEL_97:
                v65 = objc_alloc_init(MEMORY[0x1E0CC6F90]);
                objc_msgSend(v65, "setGroups:", mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)v139));
                v122 = (const char *)mlir::Type::cast<mlir::RankedTensorType>((uint64_t *)&v135);
                Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v122);
                v108 = v67;
                v109 = (_QWORD *)Value;
                v122 = (const char *)mlir::Type::cast<mlir::RankedTensorType>((uint64_t *)&v138);
                v68 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v122);
                v70 = v69;
                v122 = (const char *)mlir::Type::cast<mlir::RankedTensorType>((uint64_t *)&v132);
                v71 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v122);
                v73 = v72;
                Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)v139);
                InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)v139);
                if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)v139))
                {
                  objc_msgSend(v65, "setDataFormat:", 1);
                  if (v70 >= 4 && v73 >= 4)
                  {
                    v74 = v68[2];
                    v106 = v68[1];
                    v107 = v68[3];
                    v100 = v71[2];
                    v75 = *v71;
                    v102 = v71[1];
                    v104 = v71[3];
                    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v122, Strides, 0);
                    mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&Strides, &v116);
                    for (i = 0; ; ++i)
                    {
                      v77 = v122 == v116 && v123 == v117;
                      if (v77 && v124 == v118)
                        break;
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v122, (llvm::APInt *)&v110);
                      v78 = v111;
                      if (v111 >= 0x41)
                      {
                        if (v78 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v110) <= 0x40)
                        {
                          v79 = *(_QWORD *)v110;
                          if (i == 1)
                          {
LABEL_116:
                            objc_msgSend(v65, "setStrideInPixelsY:", v79, v100, v102, v104);
                            goto LABEL_117;
                          }
                        }
                        else
                        {
                          v79 = -1;
                          if (i == 1)
                            goto LABEL_116;
                        }
                      }
                      else
                      {
                        v79 = (uint64_t)v110;
                        if (i == 1)
                          goto LABEL_116;
                      }
                      if (i == 2)
                        objc_msgSend(v65, "setStrideInPixelsX:", v79);
LABEL_117:
                      if (v111 >= 0x41)
                      {
                        if (v110)
                          MEMORY[0x186DA165C](v110, 0x1000C8000313F17);
                      }
                      ++v124;
                    }
                    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v122, InputAttributeNames, 0);
                    mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&InputAttributeNames, &v116);
                    for (j = 0; ; ++j)
                    {
                      v82 = v122 == v116 && v123 == v117;
                      if (v82 && v124 == v118)
                        goto LABEL_187;
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v122, (llvm::APInt *)&v110);
                      v83 = v111;
                      if (v111 >= 0x41)
                      {
                        if (v83 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v110) <= 0x40)
                        {
                          v84 = *(_QWORD *)v110;
                          if (j == 1)
                          {
LABEL_141:
                            objc_msgSend(v65, "setDilationRateInY:", v84, v100, v102, v104);
                            goto LABEL_142;
                          }
                        }
                        else
                        {
                          v84 = -1;
                          if (j == 1)
                            goto LABEL_141;
                        }
                      }
                      else
                      {
                        v84 = (uint64_t)v110;
                        if (j == 1)
                          goto LABEL_141;
                      }
                      if (j == 2)
                        objc_msgSend(v65, "setDilationRateInX:", v84);
LABEL_142:
                      if (v111 >= 0x41 && v110)
                        MEMORY[0x186DA165C](v110, 0x1000C8000313F17);
                      ++v124;
                    }
                  }
                }
                else
                {
                  objc_msgSend(v65, "setDataFormat:", 0);
                  if (v70 >= 4 && v73 >= 4)
                  {
                    v74 = v68[3];
                    v106 = v68[2];
                    v107 = v68[1];
                    v100 = v71[3];
                    v102 = v71[2];
                    v75 = *v71;
                    v104 = v71[1];
                    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v122, Strides, 0);
                    mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&Strides, &v116);
                    for (k = 0; ; ++k)
                    {
                      v86 = v122 == v116 && v123 == v117;
                      if (v86 && v124 == v118)
                        break;
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v122, (llvm::APInt *)&v110);
                      v87 = v111;
                      if (v111 >= 0x41)
                      {
                        if (v87 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v110) <= 0x40)
                          v88 = *(_QWORD *)v110;
                        else
                          v88 = -1;
                      }
                      else
                      {
                        v88 = (uint64_t)v110;
                      }
                      if (k == 2)
                      {
                        objc_msgSend(v65, "setStrideInPixelsY:", v88);
                      }
                      else if (k == 3)
                      {
                        objc_msgSend(v65, "setStrideInPixelsX:", v88);
                      }
                      if (v111 >= 0x41 && v110)
                        MEMORY[0x186DA165C](v110, 0x1000C8000313F17);
                      ++v124;
                    }
                    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v122, InputAttributeNames, 0);
                    mlir::DenseIntElementsAttr::end((mlir::DenseIntElementsAttr *)&InputAttributeNames, &v116);
                    for (m = 0; ; ++m)
                    {
                      v90 = v122 == v116 && v123 == v117;
                      if (v90 && v124 == v118)
                        break;
                      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v122, (llvm::APInt *)&v110);
                      v91 = v111;
                      if (v111 >= 0x41)
                      {
                        if (v91 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v110) <= 0x40)
                          v92 = *(_QWORD *)v110;
                        else
                          v92 = -1;
                      }
                      else
                      {
                        v92 = (uint64_t)v110;
                      }
                      if (m == 2)
                      {
                        objc_msgSend(v65, "setDilationRateInY:", v92);
                      }
                      else if (m == 3)
                      {
                        objc_msgSend(v65, "setDilationRateInX:", v92);
                      }
                      if (v111 >= 0x41 && v110)
                        MEMORY[0x186DA165C](v110, 0x1000C8000313F17);
                      ++v124;
                    }
LABEL_187:
                    if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)v139) == 2)
                    {
                      objc_msgSend(v65, "setWeightsFormat:", 1);
                      if (v108 < 4)
                        goto LABEL_196;
                      objc_msgSend(v65, "setKernelWidth:", v109[3]);
                      objc_msgSend(v65, "setKernelHeight:", v109[2]);
                      objc_msgSend(v65, "setInputFeatureChannels:", v109[1]);
                    }
                    else
                    {
                      objc_msgSend(v65, "setWeightsFormat:", 0);
                      if (v108 < 2)
                        goto LABEL_196;
                      objc_msgSend(v65, "setKernelWidth:", v109[1]);
                      objc_msgSend(v65, "setKernelHeight:", *v109);
                      if (v108 < 3)
                        goto LABEL_196;
                      objc_msgSend(v65, "setInputFeatureChannels:", v109[2]);
                      if (v108 <= 3)
                        goto LABEL_196;
                      v109 += 3;
                    }
                    objc_msgSend(v65, "setOutputFeatureChannels:", *v109, v100, v102, v104);
                    v122 = (const char *)v74;
                    v123 = v106;
                    v124 = 1;
                    v125 = v107;
                    v126 = v75;
                    v127 = 0;
                    LODWORD(v127) = getMPSDataType((_QWORD *)(*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8));
                    v116 = v101;
                    v117 = v103;
                    v118 = 1;
                    v119 = v105;
                    v120 = v75;
                    v121 = 0;
                    LODWORD(v121) = getMPSDataType((_QWORD *)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
                    v115 = 0;
                    v110 = (const char *)objc_msgSend(v65, "kernelWidth");
                    v111 = objc_msgSend(v65, "kernelHeight");
                    v112 = 1;
                    v113 = objc_msgSend(v65, "inputFeatureChannels");
                    v114 = objc_msgSend(v65, "outputFeatureChannels");
                    LODWORD(v115) = getMPSDataType((_QWORD *)(*(_QWORD *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8));
                    v43 = objc_msgSend(MEMORY[0x1E0CC6F88], "supportsPostfixForDevice:convolutionDescriptor:sourceTensorDescriptor:destinationTensorDescriptor:weightsTensorDescriptor:", *((_QWORD *)this + 1), v65, &v122, &v116, &v110);

                    return v43;
                  }
                }
LABEL_196:
                __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
              }
            }
            return objc_msgSend(MEMORY[0x1E0CC6F88], "supportsPostfixForDevice:convolutionDescriptor:sourceTensorDescriptor:destinationTensorDescriptor:weightsTensorDescriptor:", *((_QWORD *)this + 1), 0, 0, 0, 0);
          }
LABEL_195:
          __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
        }
LABEL_214:
        __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
      }
      v122 = *(const char **)(v12 + 8);
      v95 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v122);
      if (v96 != 11)
        goto LABEL_214;
      if (*v95 != 0x766E6F632E73706DLL || *(_QWORD *)((char *)v95 + 3) != 0x64325F766E6F632ELL)
        goto LABEL_214;
      goto LABEL_205;
    }
    v27 = (void *)MEMORY[0x1E0CC6F88];
    return objc_msgSend(v27, "supportsPostfixForDevice:", *((_QWORD *)this + 1));
  }
  v25 = *((_QWORD *)a2 + 6);
  v26 = *(void **)(v25 + 16);
  if (v26 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v122 = *(const char **)(v25 + 8);
    v28 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v122);
    if (v29 == 8 && *v28 == 0x656C69742E73706DLL)
    {
      LOWORD(v120) = 1283;
      v116 = "classof on '";
      v118 = (uint64_t)"mps.tile";
      v94 = 8;
      goto LABEL_213;
    }
  }
  else if (v26 == &mlir::detail::TypeIDResolver<mlir::mps::TileOp,void>::id)
  {
    if (!*((_BYTE *)this + 16))
    {
      v27 = (void *)MEMORY[0x1E0CC7198];
      return objc_msgSend(v27, "supportsPostfixForDevice:", *((_QWORD *)this + 1));
    }
    return 0;
  }
  v30 = *((_QWORD *)a2 + 6);
  v31 = *(void **)(v30 + 16);
  if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v122 = *(const char **)(v30 + 8);
    v32 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v122);
    if (v33 != 10)
      goto LABEL_39;
    if (*(_QWORD *)v32 != 0x697365722E73706DLL || *(_WORD *)(v32 + 8) != 25978)
      goto LABEL_39;
    LOWORD(v120) = 1283;
    v93 = "mps.resize";
LABEL_208:
    v116 = "classof on '";
    v118 = (uint64_t)v93;
    v94 = 10;
    goto LABEL_213;
  }
  if (v31 == &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id)
  {
    if (!*((_BYTE *)this + 16))
    {
      v27 = (void *)MEMORY[0x1E0CC7138];
      return objc_msgSend(v27, "supportsPostfixForDevice:", *((_QWORD *)this + 1));
    }
    return 0;
  }
LABEL_39:
  v35 = *((_QWORD *)a2 + 6);
  v36 = *(void **)(v35 + 16);
  if (v36 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v122 = *(const char **)(v35 + 8);
    v37 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v122);
    if (v38 == 21)
    {
      v39 = *v37 == 0x747065642E73706DLL && v37[1] == 0x6F635F6573697768;
      if (v39 && *(_QWORD *)((char *)v37 + 13) == 0x64335F766E6F635FLL)
      {
        LOWORD(v120) = 1283;
        v99 = "mps.depthwise_conv_3d";
LABEL_212:
        v116 = "classof on '";
        v118 = (uint64_t)v99;
        v94 = 21;
LABEL_213:
        v119 = v94;
        v110 = "' failed due to the operation not being registered";
        LOWORD(v114) = 259;
        llvm::operator+((uint64_t *)&v116, (uint64_t *)&v110, (uint64_t)&v122);
        llvm::report_fatal_error((llvm::Twine *)&v122, 1);
      }
    }
  }
  else if (v36 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
  {
    v27 = (void *)MEMORY[0x1E0CC6FD8];
    return objc_msgSend(v27, "supportsPostfixForDevice:", *((_QWORD *)this + 1));
  }
  v41 = *((_QWORD *)a2 + 6);
  v42 = *(void **)(v41 + 16);
  if (v42 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v122 = *(const char **)(v41 + 8);
    v44 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v122);
    if (v45 == 11 && *v44 == 0x6E6574732E73706DLL && *(_QWORD *)((char *)v44 + 3) == 0x6C69636E6574732ELL)
    {
      LOWORD(v120) = 1283;
      v98 = "mps.stencil";
      goto LABEL_206;
    }
    goto LABEL_59;
  }
  if (v42 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
  {
LABEL_59:
    v47 = *((_QWORD *)a2 + 6);
    v48 = *(void **)(v47 + 16);
    if (v48 != &mlir::detail::TypeIDResolver<void,void>::id)
    {
      if (v48 == &mlir::detail::TypeIDResolver<mlir::mpsx::QuantizedMatMulOp,void>::id)
      {
        v27 = (void *)MEMORY[0x1E0CC70F8];
        return objc_msgSend(v27, "supportsPostfixForDevice:", *((_QWORD *)this + 1));
      }
      return 1;
    }
    v122 = *(const char **)(v47 + 8);
    v49 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v122);
    if (v50 != 21)
      return 1;
    v51 = *v49 == 0x6175712E7873706DLL && v49[1] == 0x6D5F64657A69746ELL;
    if (!v51 || *(_QWORD *)((char *)v49 + 13) != 0x6C756D74616D5F64)
      return 1;
    LOWORD(v120) = 1283;
    v99 = "mpsx.quantized_matmul";
    goto LABEL_212;
  }
  if (!*((_BYTE *)this + 16))
  {
    v27 = (void *)MEMORY[0x1E0CC7170];
    return objc_msgSend(v27, "supportsPostfixForDevice:", *((_QWORD *)this + 1));
  }
  return 0;
}

void sub_180E21980(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void mlir::mps::MPSFusableCoreOps::~MPSFusableCoreOps(mlir::mps::MPSFusableCoreOps *this)
{
  JUMPOUT(0x186DA1680);
}

uint64_t mlir::detail::constant_float_predicate_matcher::match(mlir::detail::constant_float_predicate_matcher *this, mlir::Operation *a2)
{
  llvm::APFloatBase *v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  void *v7;
  BOOL v20;
  uint64_t v21;
  const char *v23;
  int v24;
  const char *v25;
  const char *v26;
  char *v27;
  unint64_t *v28;
  uint64_t v29;
  char v30[8];
  llvm::APFloatBase *v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v4 = (llvm::APFloatBase *)llvm::APFloatBase::Bogus(this);
  v5 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v4);
  if (v5 == v4)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(&v31, (uint64_t)v4);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)&v31, (uint64_t)v4);
  v27 = v30;
  v28 = (unint64_t *)&v29;
  v29 = 0;
  if (!mlir::detail::constant_op_binder<mlir::Attribute>::match(&v28, (uint64_t)a2))
    goto LABEL_51;
  if (!*((_DWORD *)a2 + 9))
  {
    v23 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v24 = 984;
    v25 = "Operation.h";
    v26 = "getOpResultImpl";
    goto LABEL_56;
  }
  v6 = *(_QWORD *)(*((_QWORD *)a2 - 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
  {
    v23 = "abstractType && \"Malformed type storage object.\"";
    v24 = 160;
    v25 = "TypeSupport.h";
    v26 = "getAbstractType";
LABEL_56:
    __assert_rtn(v26, v25, v24, v23);
  }
  v7 = *(void **)(v6 + 136);
  v20 = v7 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
     || v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
  if (!v20 || !mlir::detail::constant_float_value_binder::match((uint64_t *)&v27, v29))
  {
LABEL_51:
    v21 = 0;
    if (v5 == v31)
      goto LABEL_50;
LABEL_52:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v31);
    return v21;
  }
  v21 = (*(uint64_t (**)(char *))this)(v30);
  if (v5 != v31)
    goto LABEL_52;
LABEL_50:
  std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v32);
  return v21;
}

void sub_180E21D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  llvm::APFloat::~APFloat((llvm::APFloat *)va);
  _Unwind_Resume(a1);
}

GPU::ANERegionCallOpHandler *GPU::ANERegionCallOpHandler::ANERegionCallOpHandler(GPU::ANERegionCallOpHandler *this, GPU::BaseOpHandler *a2)
{
  uint64_t v3;
  mlir::Operation *v4;
  void **v5;
  dispatch_queue_t *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  _QWORD *WeakRetained;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  unint64_t v24;
  const void *Callee;
  size_t v26;
  void **v27;
  void **p_dst;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  void *v33;
  uint64_t v34;
  unint64_t v35;
  const void *v36;
  size_t v37;
  void **v38;
  void **v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  mlir::Operation *v44;
  uint64_t InherentAttr;
  char v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  dispatch_queue_t v50;
  dispatch_queue_t v51;
  uint64_t v52;
  void *v53;
  id v54;
  void *v55;
  uint64_t v56;
  void *v57;
  _BYTE *v58;
  int v59;
  void *v60;
  int v61;
  _BYTE *v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  char v66;
  char *v67;
  unint64_t UInt;
  const __CFString *v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  char v77;
  char *v78;
  const char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  void *v85;
  void *v86;
  char *v87;
  std::string::size_type v88;
  const char **v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  void *v94;
  uint64_t v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  void *v103;
  int v104;
  mlir::Operation *v105;
  void *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  mlir::Operation *v111;
  void *v112;
  void *v113;
  char v114;
  void *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  mlir::Operation *v121;
  uint64_t v122;
  int v123;
  void *v124;
  id v125;
  BOOL v126;
  void *v127;
  uint64_t v128;
  unint64_t v129;
  const char ***v130;
  unsigned int v131;
  unint64_t v132;
  uint64_t v133;
  const double *v134;
  unsigned __int128 *v135;
  unint64_t v136;
  const double *v137;
  unsigned __int128 v138;
  unsigned __int128 v139;
  unint64_t v140;
  const char ***v141;
  const char **v142;
  unsigned int v143;
  unint64_t v144;
  const char *v145;
  int8x16_t *v146;
  std::string::size_type size;
  mlir::Operation *v148;
  unint64_t v149;
  void *v150;
  char *v151;
  unsigned int v152;
  uint64_t v153;
  char *v154;
  int v155;
  mlir::detail::OpResultImpl *v156;
  uint64_t v157;
  char *NextResultAtOffset;
  _QWORD *v159;
  mlir::Operation *v160;
  mlir::Operation *v161;
  uint64_t v162;
  void *v163;
  uint64_t v164;
  uint64_t v165;
  BOOL v166;
  BOOL v167;
  unint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  char **v173;
  char *v174;
  char *v175;
  __int128 v176;
  uint64_t v177;
  unsigned int v178;
  uint64_t v179;
  int8x16_t *v180;
  std::string::size_type v181;
  unint64_t v182;
  BOOL v183;
  char *v184;
  unsigned int v185;
  uint64_t v186;
  char *v187;
  int v188;
  unsigned int v189;
  char *v190;
  void *v191;
  _QWORD *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  void *v197;
  unint64_t v198;
  unint64_t i;
  void *v200;
  id v201;
  const char *v202;
  int8x16_t *v203;
  const unsigned __int8 *v204;
  int Key;
  uint64_t v206;
  unint64_t v207;
  unsigned int v208;
  void *v209;
  int v210;
  const char *v211;
  const char *v212;
  const char *v213;
  unint64_t v214;
  void *v215;
  unint64_t v216;
  uint64_t v217;
  unint64_t v218;
  void *v219;
  id v220;
  const char *v221;
  int8x16_t *v222;
  const unsigned __int8 *v223;
  int v224;
  uint64_t v225;
  unint64_t v226;
  unsigned int v227;
  void *v228;
  void *v229;
  int v230;
  const char *v231;
  const char *v232;
  const char *v233;
  uint64_t v234;
  unint64_t v235;
  _QWORD *v236;
  _QWORD *v237;
  uint64_t v238;
  char **v239;
  uint64_t DefiningOp;
  void *v241;
  int v242;
  uint64_t v243;
  unint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  unint64_t v248;
  unint64_t v249;
  uint8x8_t v250;
  char **v251;
  char *v252;
  unint64_t v253;
  uint64_t v254;
  char **v255;
  float v256;
  float v257;
  unint64_t v258;
  _BOOL8 v259;
  unint64_t v260;
  unint64_t v261;
  size_t prime;
  unint64_t v263;
  uint8x8_t v264;
  uint64_t v265;
  unint64_t v266;
  uint64_t v267;
  llvm *v268;
  uint64_t v270;
  llvm *v271;
  int v274;
  const char *v275;
  const char *v276;
  const char *v277;
  const char *v278;
  int v279;
  _QWORD *AttrData;
  uint64_t v281;
  BOOL v282;
  void *v284;
  void *v285;
  void *v286;
  void *v287;
  char *v288;
  char *v289;
  char *v290;
  char **v291;
  char *v292;
  id *location;
  char *v294;
  uint64_t *v295;
  void *v296;
  _QWORD *v297;
  void *v298;
  id v299;
  id v300;
  void *v301;
  char *obj;
  id obja;
  uint64_t v304;
  int data;
  void *v306;
  uint64_t v307;
  void *v308;
  void *v309;
  void *v310;
  mlir::detail::OpResultImpl *v311;
  mlir::detail::OpResultImpl *v312;
  uint64_t v313;
  mlir::Operation *v314;
  id v315;
  mlir::Operation *v316;
  char *__dst;
  uint64_t v318;
  const char **MemRefRowBytes;
  uint64_t ElementTypeOrSelf;
  void *v321[2];
  void *v322;
  void *v323;
  uint64_t v324;
  uint64_t v325;
  const char *v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  __int16 v330;
  std::string v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  __CFString *v336;
  const __CFString *v337;
  const __CFString *v338;
  const __CFString *v339;
  _QWORD v340[3];

  v340[1] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a2 + 2);
  *((_QWORD *)this + 2) = v3;
  v4 = (mlir::Operation *)*((_QWORD *)a2 + 3);
  *((_QWORD *)this + 3) = v4;
  *(_QWORD *)this = &off_1E0E1D700;
  *((_OWORD *)this + 2) = 0u;
  v5 = (void **)((char *)this + 32);
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 16) = (char *)this + 144;
  v289 = (char *)this + 128;
  v290 = (char *)this + 144;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 17) = 0x400000000;
  v288 = (char *)this + 192;
  *((_QWORD *)this + 22) = (char *)this + 192;
  v294 = (char *)this + 176;
  *(_OWORD *)((char *)this + 232) = 0u;
  v6 = (dispatch_queue_t *)((char *)this + 232);
  *((_QWORD *)this + 23) = 0x400000000;
  v297 = (_QWORD *)((char *)this + 272);
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_QWORD *)this + 34) = (char *)this + 288;
  *((_QWORD *)this + 35) = 0x400000000;
  v291 = (char **)((char *)this + 320);
  v292 = (char *)this + 336;
  *((_QWORD *)this + 40) = (char *)this + 336;
  *((_QWORD *)this + 41) = 0x400000000;
  *((_QWORD *)this + 86) = 0;
  *((_QWORD *)this + 88) = 0;
  *((_QWORD *)this + 87) = 0;
  v7 = *((_QWORD *)v4 + 6);
  v8 = *(void **)(v7 + 16);
  if (v8 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst = *(char **)(v7 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__dst);
    if (v281 == 21)
    {
      v282 = *AttrData == 0x6E656D6563616C70 && AttrData[1] == 0x6E6F696765722E74;
      if (v282 && *(_QWORD *)((char *)AttrData + 13) == 0x6C6C61635F6E6F69)
      {
        LOWORD(v333) = 1283;
        v331.__r_.__value_.__r.__words[0] = (std::string::size_type)"classof on '";
        v331.__r_.__value_.__r.__words[2] = (std::string::size_type)"placement.region_call";
        v332 = 21;
        v326 = "' failed due to the operation not being registered";
        v330 = 259;
        llvm::operator+((uint64_t *)&v331, (uint64_t *)&v326, (uint64_t)&__dst);
        llvm::report_fatal_error((llvm::Twine *)&__dst, 1);
      }
    }
LABEL_426:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v8 != &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
    goto LABEL_426;
  v314 = v4;
  v9 = (void *)MEMORY[0x1E0CB3940];
  WeakRetained = objc_loadWeakRetained((id *)(v3 + 72));
  objc_msgSend(v9, "stringWithFormat:", CFSTR("%@/"), WeakRetained[72]);
  v11 = objc_claimAutoreleasedReturnValue();
  v12 = (void *)*((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = v11;

  objc_msgSend(MEMORY[0x1E0CFDF48], "aneSubType");
  v13 = objc_claimAutoreleasedReturnValue();
  v14 = *v5;
  *v5 = (void *)v13;

  v15 = *v5;
  objc_msgSend(MEMORY[0x1E0CFDF48], "aneSubTypeVariant");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v15, "stringByAppendingString:", v16);
  v17 = objc_claimAutoreleasedReturnValue();
  v18 = *v5;
  *v5 = (void *)v17;

  v19 = *v5;
  objc_msgSend(MEMORY[0x1E0CFDF48], "aneSubTypeProductVariant");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v19, "stringByAppendingString:", v20);
  v21 = objc_claimAutoreleasedReturnValue();
  v22 = *v5;
  *v5 = (void *)v21;

  v23 = (void *)MEMORY[0x1E0CB3940];
  Callee = (const void *)mlir::placement::RegionCall::getCallee(&v314);
  if (!Callee)
  {
    __dst = 0;
    v318 = 0;
    p_dst = (void **)&__dst;
    MemRefRowBytes = 0;
    goto LABEL_15;
  }
  v26 = v24;
  if (v24 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v24 >= 0x17)
  {
    v29 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v24 | 7) != 0x17)
      v29 = v24 | 7;
    v30 = v29 + 1;
    v27 = (void **)operator new(v29 + 1);
    v318 = v26;
    MemRefRowBytes = (const char **)(v30 | 0x8000000000000000);
    __dst = (char *)v27;
    goto LABEL_12;
  }
  HIBYTE(MemRefRowBytes) = v24;
  v27 = (void **)&__dst;
  if (v24)
LABEL_12:
    memmove(v27, Callee, v26);
  *((_BYTE *)v27 + v26) = 0;
  p_dst = (void **)&__dst;
  if (SHIBYTE(MemRefRowBytes) < 0)
    p_dst = (void **)__dst;
LABEL_15:
  objc_msgSend(v23, "stringWithFormat:", CFSTR("%s"), p_dst);
  v31 = objc_claimAutoreleasedReturnValue();
  v32 = (void *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = v31;

  if (SHIBYTE(MemRefRowBytes) < 0)
    operator delete(__dst);
  v33 = (void *)MEMORY[0x1E0CB3940];
  v34 = *((_QWORD *)this + 5);
  v36 = (const void *)mlir::placement::RegionCall::getCallee(&v314);
  if (!v36)
  {
    __dst = 0;
    v318 = 0;
    v39 = (void **)&__dst;
    MemRefRowBytes = 0;
    goto LABEL_29;
  }
  v37 = v35;
  if (v35 > 0x7FFFFFFFFFFFFFF7)
    std::string::__throw_length_error[abi:ne180100]();
  if (v35 >= 0x17)
  {
    v40 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v35 | 7) != 0x17)
      v40 = v35 | 7;
    v41 = v40 + 1;
    v38 = (void **)operator new(v40 + 1);
    v318 = v37;
    MemRefRowBytes = (const char **)(v41 | 0x8000000000000000);
    __dst = (char *)v38;
    goto LABEL_26;
  }
  HIBYTE(MemRefRowBytes) = v35;
  v38 = (void **)&__dst;
  if (v35)
LABEL_26:
    memmove(v38, v36, v37);
  *((_BYTE *)v38 + v37) = 0;
  v39 = (void **)&__dst;
  if (SHIBYTE(MemRefRowBytes) < 0)
    v39 = (void **)__dst;
LABEL_29:
  objc_msgSend(v33, "stringWithFormat:", CFSTR("%@%s.plist"), v34, v39);
  v42 = objc_claimAutoreleasedReturnValue();
  v43 = (void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = v42;

  if ((SHIBYTE(MemRefRowBytes) & 0x80000000) == 0)
  {
    v44 = v314;
    if (!*((_BYTE *)v314 + 47))
      goto LABEL_34;
LABEL_33:
    InherentAttr = mlir::Operation::getInherentAttr((uint64_t)v44, (uint64_t)"regionSHA", 9);
    if (v46)
      goto LABEL_35;
    goto LABEL_34;
  }
  operator delete(__dst);
  v44 = v314;
  if (*((_BYTE *)v314 + 47))
    goto LABEL_33;
LABEL_34:
  InherentAttr = mlir::DictionaryAttr::get((uint64_t)v44 + 56, "regionSHA", 9uLL);
LABEL_35:
  if (InherentAttr)
  {
    if (!*(_QWORD *)InherentAttr)
      __assert_rtn("getAbstractAttribute", "AttributeSupport.h", 165, "abstractAttribute && \"Malformed attribute storage object.\"");
    if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      v47 = InherentAttr;
    else
      v47 = 0;
  }
  else
  {
    v47 = 0;
  }
  v313 = v47;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s"), mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v313));
  v48 = objc_claimAutoreleasedReturnValue();
  v49 = (void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = v48;

  *((_BYTE *)this + 224) = 0;
  if (qword_1ECD35620 != -1)
    dispatch_once(&qword_1ECD35620, &__block_literal_global_0);
  v50 = dispatch_queue_create("com.apple.MPSANEQueue", 0);
  v51 = *v6;
  *v6 = v50;

  v52 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6B88]), "initWithDispatchQueue:", *v6);
  v53 = (void *)*((_QWORD *)this + 30);
  *((_QWORD *)this + 30) = v52;

  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v296 = (void *)objc_claimAutoreleasedReturnValue();
  v54 = objc_alloc_init(MEMORY[0x1E0CBBEB8]);
  v55 = (void *)*((_QWORD *)this + 31);
  *((_QWORD *)this + 31) = v54;

  v56 = objc_msgSend(v296, "newSharedEventWithMachPort:", objc_msgSend(*((id *)this + 31), "eventPort"));
  v57 = (void *)*((_QWORD *)this + 32);
  *((_QWORD *)this + 32) = v56;

  *((_QWORD *)this + 33) = 0;
  *((_BYTE *)this + 114) = byte_1ECD35601;
  *((_BYTE *)this + 115) = byte_1ECD35602;
  *((_BYTE *)this + 117) = byte_1ECD35603;
  if (byte_1ECD35604 == 1)
  {
    *((_BYTE *)this + 118) = byte_1ECD35604;
  }
  else
  {
    v58 = objc_loadWeakRetained((id *)(*((_QWORD *)this + 2) + 72));
    *((_BYTE *)this + 118) = v58[615];

  }
  *((_BYTE *)this + 113) = byte_1ECD35605;
  v59 = byte_1ECD35606;
  *((_BYTE *)this + 119) = byte_1ECD35606;
  *((_BYTE *)this + 120) = byte_1ECD35607;
  *((_BYTE *)this + 121) = byte_1ECD35608;
  if (byte_1ECD3560A != 1)
  {
    v62 = objc_loadWeakRetained((id *)(*((_QWORD *)this + 2) + 72));
    *((_BYTE *)this + 122) = v62[616];

    v60 = (void *)MEMORY[0x1E0CFDF88];
    if (*((_BYTE *)this + 119))
      goto LABEL_48;
LABEL_50:
    v61 = objc_msgSend(v60, "aneUserInteractiveTaskQoS");
    goto LABEL_51;
  }
  *((_BYTE *)this + 122) = byte_1ECD3560A;
  v60 = (void *)MEMORY[0x1E0CFDF88];
  if (!v59)
    goto LABEL_50;
LABEL_48:
  v61 = objc_msgSend(v60, "aneRealTimeTaskQoS");
LABEL_51:
  *((_DWORD *)this + 24) = v61;
  v63 = (void *)*((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = 0;

  v64 = *(_QWORD *)(*((_QWORD *)this + 2) + 64);
  if (!*(_BYTE *)(v64 + 47)
    || (v65 = mlir::Operation::getInherentAttr(*(_QWORD *)(*((_QWORD *)this + 2) + 64), (uint64_t)"mps.aneCompilerSpatialSplitting", 31), !v66))
  {
    v65 = mlir::DictionaryAttr::get(v64 + 56, "mps.aneCompilerSpatialSplitting", 0x1FuLL);
  }
  if (v65)
  {
    if (!*(_QWORD *)v65)
      __assert_rtn("getAbstractAttribute", "AttributeSupport.h", 165, "abstractAttribute && \"Malformed attribute storage object.\"");
    if (*(_UNKNOWN **)(*(_QWORD *)v65 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v67 = (char *)v65;
    else
      v67 = 0;
  }
  else
  {
    v67 = 0;
  }
  __dst = v67;
  UInt = (unint64_t)mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&__dst);
  if (UInt >= 4)
    v69 = CFSTR("Auto");
  else
    v69 = (const __CFString *)qword_1E0E769E0[UInt];
  v70 = (void *)*((_QWORD *)this + 13);
  *((_QWORD *)this + 13) = v69;

  *((_BYTE *)this + 112) = 0;
  v71 = *(_QWORD *)(*((_QWORD *)this + 2) + 64);
  if (!*(_BYTE *)(v71 + 47)
    || (v72 = mlir::Operation::getInherentAttr(*(_QWORD *)(*((_QWORD *)this + 2) + 64), (uint64_t)"mps.enableANEFWToFWSignal", 25), !v73))
  {
    v72 = mlir::DictionaryAttr::get(v71 + 56, "mps.enableANEFWToFWSignal", 0x19uLL);
  }
  if (v72)
  {
    if (!*(_QWORD *)v72)
      __assert_rtn("getAbstractAttribute", "AttributeSupport.h", 165, "abstractAttribute && \"Malformed attribute storage object.\"");
    if (*(_UNKNOWN **)(*(_QWORD *)v72 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v74 = (char *)v72;
    else
      v74 = 0;
  }
  else
  {
    v74 = 0;
  }
  __dst = v74;
  *((_BYTE *)this + 112) = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&__dst) != 0;
  *((_BYTE *)this + 116) = 0;
  v75 = *(_QWORD *)(*((_QWORD *)this + 2) + 64);
  if (!*(_BYTE *)(v75 + 47)
    || (v76 = mlir::Operation::getInherentAttr(*(_QWORD *)(*((_QWORD *)this + 2) + 64), (uint64_t)"mps.enableANELateLatch", 22), !v77))
  {
    v76 = mlir::DictionaryAttr::get(v75 + 56, "mps.enableANELateLatch", 0x16uLL);
  }
  if (v76)
  {
    if (!*(_QWORD *)v76)
      __assert_rtn("getAbstractAttribute", "AttributeSupport.h", 165, "abstractAttribute && \"Malformed attribute storage object.\"");
    if (*(_UNKNOWN **)(*(_QWORD *)v76 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v78 = (char *)v76;
    else
      v78 = 0;
  }
  else
  {
    v78 = 0;
  }
  __dst = v78;
  *((_BYTE *)this + 116) = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&__dst) != 0;
  v79 = (const char *)*((_QWORD *)this + 13);
  v80 = *((_QWORD *)this + 4);
  if (v79)
  {
    v336 = CFSTR("SpatialSplitMode");
    v337 = CFSTR("NetworkPlistPath");
    v81 = *((_QWORD *)this + 6);
    v82 = *((_QWORD *)this + 7);
    v326 = v79;
    v327 = v81;
    v339 = CFSTR("TargetArchitecture");
    v340[0] = v80;
    v338 = CFSTR("NetworkPlistName");
    v328 = v82;
    v329 = v80;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v326, &v336, 4);
  }
  else
  {
    v340[0] = *((_QWORD *)this + 4);
    v336 = CFSTR("NetworkPlistPath");
    v337 = CFSTR("NetworkPlistName");
    v84 = *((_QWORD *)this + 7);
    v326 = (const char *)*((_QWORD *)this + 6);
    v327 = v84;
    v338 = CFSTR("TargetArchitecture");
    v328 = v80;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v326, &v336, 3);
  }
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  v323 = v83;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v323, v340, 1);
  v85 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(*((id *)this + 5), "stringByAppendingPathComponent:", CFSTR("MPSGraph_ANE_compilerOptions.plist"));
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v87 = (char *)*MEMORY[0x1E0CFE000];
  v88 = *MEMORY[0x1E0CFDFD0];
  v331.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0CFE090];
  v331.__r_.__value_.__l.__size_ = v88;
  __dst = v87;
  v318 = (uint64_t)CFSTR("MPSGraph_ANE_compilerOptions.plist");
  v331.__r_.__value_.__r.__words[2] = *MEMORY[0x1E0CFDFE8];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *((unsigned __int8 *)this + 116));
  v89 = (const char **)objc_claimAutoreleasedReturnValue();
  MemRefRowBytes = v89;
  v332 = *MEMORY[0x1E0CFE018];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *((_BYTE *)this + 118) == 0);
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  ElementTypeOrSelf = (uint64_t)v90;
  v333 = *MEMORY[0x1E0CFDFE0];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *((unsigned __int8 *)this + 112));
  v91 = (void *)objc_claimAutoreleasedReturnValue();
  v321[0] = v91;
  v334 = *MEMORY[0x1E0CFE0A8];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", *((_BYTE *)this + 118) == 0);
  v92 = (void *)objc_claimAutoreleasedReturnValue();
  v321[1] = v92;
  v335 = *MEMORY[0x1E0CFE098];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.plist"), *((_QWORD *)this + 7));
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  v322 = v93;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &__dst, &v331, 7);
  v94 = (void *)objc_claimAutoreleasedReturnValue();
  v95 = objc_msgSend(v94, "mutableCopy");
  v96 = (void *)*((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = v95;

  std::mutex::lock(&GPU::ANERegionCallOpHandler::_intermediateBufferHandleMutex);
  if (_MergedGlobals_70 == 1 && !*((_BYTE *)this + 117))
  {
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", qword_1ECD35610);
    v97 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*((id *)this + 11), "setObject:forKeyedSubscript:", v97, *MEMORY[0x1E0CFDFF0]);

    if (!*((_BYTE *)this + 224))
    {
      ++qword_1ECD35618;
      *((_BYTE *)this + 224) = 1;
    }
  }
  if ((objc_msgSend(v85, "writeToFile:atomically:", v86, 1) & 1) == 0 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v98 = (void *)MEMORY[0x1E0CFDF68];
  objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", *((_QWORD *)this + 5));
  v99 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v98, "modelAtURLWithCacheURLIdentifier:key:cacheURLIdentifier:", v99, *((_QWORD *)this + 7), *((_QWORD *)this + 8));
  v100 = objc_claimAutoreleasedReturnValue();
  v101 = (void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = v100;

  if (*((_BYTE *)this + 119))
    objc_msgSend(MEMORY[0x1E0CFDF38], "sharedPrivateConnection");
  else
    objc_msgSend(MEMORY[0x1E0CFDF38], "sharedConnection");
  v102 = objc_claimAutoreleasedReturnValue();
  v103 = (void *)*((_QWORD *)this + 10);
  *((_QWORD *)this + 10) = v102;

  v104 = *(_DWORD *)(*((_QWORD *)this + 2) + 220);
  if (!objc_msgSend(*((id *)this + 10), "compiledModelExistsFor:", *((_QWORD *)this + 9))
    || (v104 & 8) != 0)
  {
    v107 = *((_QWORD *)this + 9);
    v106 = (void *)*((_QWORD *)this + 10);
    v108 = *((_QWORD *)this + 11);
    v109 = *((unsigned int *)this + 24);
    v316 = 0;
    v110 = objc_msgSend(v106, "compileModel:options:qos:error:", v107, v108, v109, &v316);
    v111 = v316;
    v105 = v111;
    if (!v110 || (v104 & 8) != 0)
    {
      if (v111)
      {
        v125 = objc_loadWeakRetained((id *)(*((_QWORD *)this + 2) + 72));
        v126 = (objc_msgSend(v125, "options") & 2) == 0;

        if (!v126)
          printf("ANE plist filePath:\n%s\n", (const char *)objc_msgSend(*((id *)this + 6), "UTF8String"));
        -[mlir::Operation debugDescription](v105, "debugDescription");
        v127 = (void *)objc_claimAutoreleasedReturnValue();
        NSLog(CFSTR("\nError:\n\n %@"), v127);

      }
      NSLog(CFSTR("ANE compilation failed!"));
      goto LABEL_120;
    }
    objc_msgSend(*((id *)this + 9), "getCacheURLIdentifier");
    v112 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v112, "isEqualToString:", *((_QWORD *)this + 8));

    objc_msgSend(*((id *)this + 9), "getCacheURLIdentifier");
    v113 = (void *)objc_claimAutoreleasedReturnValue();
    v114 = objc_msgSend(v113, "isEqualToString:", *((_QWORD *)this + 8));

    if ((v114 & 1) == 0 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    objc_msgSend(*((id *)this + 10), "compiledModelExistsFor:", *((_QWORD *)this + 9));
    if ((objc_msgSend(*((id *)this + 10), "compiledModelExistsFor:", *((_QWORD *)this + 9)) & 1) == 0
      && MTLReportFailureTypeEnabled())
    {
      MTLReportFailure();
    }
  }
  else
  {
    v105 = 0;
  }

  v116 = *((_QWORD *)this + 9);
  v115 = (void *)*((_QWORD *)this + 10);
  v117 = *((_QWORD *)this + 11);
  v118 = *((unsigned int *)this + 24);
  if (*((_BYTE *)this + 119))
  {
    v315 = 0;
    v119 = objc_msgSend(v115, "loadRealTimeModel:options:qos:error:", v116, v117, v118, &v315);
  }
  else
  {
    v315 = 0;
    v119 = objc_msgSend(v115, "loadModel:options:qos:error:", v116, v117, v118, &v315);
  }
  v120 = v119;
  v121 = (mlir::Operation *)v315;
  v105 = v121;
  if (!v120 || (v104 & 0x10) != 0)
  {
    if (v121)
    {
      -[mlir::Operation debugDescription](v121, "debugDescription");
      v124 = (void *)objc_claimAutoreleasedReturnValue();
      NSLog(CFSTR("Error = %@"), v124);

    }
    NSLog(CFSTR("ANE load failed!"));
LABEL_120:
    v123 = 0;
    goto LABEL_121;
  }
  if ((_MergedGlobals_70 & 1) == 0 && !*((_BYTE *)this + 117))
  {
    if (*((_BYTE *)this + 224) && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    if (qword_1ECD35618 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    _MergedGlobals_70 = 1;
    qword_1ECD35610 = objc_msgSend(*((id *)this + 9), "intermediateBufferHandle");
    if (!*((_BYTE *)this + 224))
    {
      ++qword_1ECD35618;
      *((_BYTE *)this + 224) = 1;
    }
  }
  objc_msgSend(*((id *)this + 9), "intermediateBufferHandle");
  v122 = qword_1ECD35610;
  if (v122 == objc_msgSend(*((id *)this + 9), "intermediateBufferHandle"))
  {
    v123 = 1;
  }
  else
  {
    v123 = 1;
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
  }
LABEL_121:
  std::mutex::unlock(&GPU::ANERegionCallOpHandler::_intermediateBufferHandleMutex);

  if (!v123 || byte_1ECD35609 == 1)
  {
    *(_BYTE *)(*((_QWORD *)this + 2) + 216) = 0;
    if (*((_BYTE *)this + 122) && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    goto LABEL_372;
  }
  if ((*((_BYTE *)v314 + 46) & 0x80) == 0)
  {
    v129 = 0;
    v131 = 0;
    __dst = (char *)&MemRefRowBytes;
    v318 = 0x400000000;
    v143 = 4;
    goto LABEL_142;
  }
  v128 = *((_QWORD *)v314 + 9);
  v129 = *((unsigned int *)v314 + 17);
  __dst = (char *)&MemRefRowBytes;
  v318 = 0x400000000;
  if (v129 <= 4)
  {
    v131 = 0;
    if (!(_DWORD)v129)
    {
      v129 = 0;
      v143 = 4;
      goto LABEL_142;
    }
    v130 = &MemRefRowBytes;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &MemRefRowBytes, v129, 8);
    v130 = (const char ***)&__dst[8 * v318];
    if (v129 >= 0xD
      && ((unint64_t)v130 >= v128 + 32 * v129
       || v128 + 24 >= (unint64_t)&__dst[8 * v129 + 8 * v318]))
    {
      v133 = v129 & 3;
      if ((v129 & 3) == 0)
        v133 = 4;
      v132 = v129 - v133;
      v130 += v132;
      v134 = (const double *)(v128 + 88);
      v135 = (unsigned __int128 *)&__dst[8 * v318 + 16];
      v136 = v132;
      do
      {
        v137 = v134 - 8;
        v138 = (unsigned __int128)vld4q_f64(v137);
        v139 = (unsigned __int128)vld4q_f64(v134);
        *(v135 - 1) = v138;
        *v135 = v139;
        v134 += 16;
        v135 += 2;
        v136 -= 4;
      }
      while (v136);
      goto LABEL_139;
    }
  }
  v132 = 0;
LABEL_139:
  v140 = v129 - v132;
  v141 = (const char ***)(v128 + 32 * v132 + 24);
  do
  {
    v142 = *v141;
    v141 += 4;
    *v130++ = v142;
    --v140;
  }
  while (v140);
  v131 = v318;
  v143 = HIDWORD(v318);
LABEL_142:
  v144 = v129 + v131;
  if (v144 > v143)
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  LODWORD(v318) = v144;
  llvm::SmallVectorImpl<mlir::Value>::operator=((uint64_t)v297, (uint64_t)&__dst);
  if (__dst != (char *)&MemRefRowBytes)
    free(__dst);
  v336 = 0;
  v337 = 0;
  v338 = (const __CFString *)0x1000000000;
  v326 = 0;
  if (*((_DWORD *)this + 70))
  {
    v145 = 0;
    do
    {
      __dst = "__arg";
      MemRefRowBytes = &v326;
      LOWORD(v321[0]) = 3331;
      llvm::Twine::str((llvm::Twine *)&__dst, &v331);
      if ((v331.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v146 = (int8x16_t *)&v331;
      else
        v146 = (int8x16_t *)v331.__r_.__value_.__r.__words[0];
      if ((v331.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v331.__r_.__value_.__r.__words[2]);
      else
        size = v331.__r_.__value_.__l.__size_;
      *(_QWORD *)(*llvm::StringMap<unsigned long long,llvm::MallocAllocator>::try_emplace<>((uint64_t)&v336, v146, (const unsigned __int8 *)size)+ 8) = v145;
      if (SHIBYTE(v331.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v331.__r_.__value_.__l.__data_);
      v145 = v326 + 1;
      v326 = v145;
    }
    while (v145 != (const char *)*((unsigned int *)this + 70));
  }
  v323 = 0;
  v324 = 0;
  v325 = 0x1000000000;
  v148 = v314;
  v149 = *((unsigned int *)v314 + 9);
  if (*((_DWORD *)this + 83) < v149)
  {
    __dst = 0;
    v150 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)v291, v292, v149, 88, (unint64_t *)&__dst);
    std::__uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,std::__always_false,GPU::ANERegionCallOpHandler::ResultInfo* std::uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*>(GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*)::{lambda(GPU::ANERegionCallOpHandler::ResultInfo*&&)#1}>(*((_QWORD *)this + 40), *((_QWORD *)this + 40) + 88 * *((unsigned int *)this + 82), (uint64_t)v150);
    v151 = (char *)*((_QWORD *)this + 40);
    v152 = *((_DWORD *)this + 82);
    if (v152)
    {
      v153 = 88 * v152;
      do
      {
        v154 = *(char **)&v151[v153 - 56];
        if (&v151[v153 - 40] != v154)
          free(v154);
        v153 -= 88;
      }
      while (v153);
      v151 = *v291;
    }
    v155 = (int)__dst;
    if (v151 != v292)
      free(v151);
    *((_QWORD *)this + 40) = v150;
    *((_DWORD *)this + 83) = v155;
    v148 = v314;
    LODWORD(v149) = *((_DWORD *)v314 + 9);
  }
  v156 = (mlir::Operation *)((char *)v148 - 16);
  if (!(_DWORD)v149)
    v156 = 0;
  v311 = v156;
  if ((_DWORD)v149)
  {
    v157 = 0;
    v307 = v149;
    do
    {
      NextResultAtOffset = (char *)mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v311, v157);
      v340[0] = v157;
      v316 = 0;
      v159 = *(_QWORD **)NextResultAtOffset;
      if (!*(_QWORD *)NextResultAtOffset)
LABEL_404:
        __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 187, "memrefToTensorOp");
      v160 = 0;
      do
      {
        v161 = (mlir::Operation *)v159[2];
        if (v160 && MTLReportFailureTypeEnabled())
          MTLReportFailure();
        if (!v161)
          __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
        v162 = *((_QWORD *)v161 + 6);
        v163 = *(void **)(v162 + 16);
        if (v163 == &mlir::detail::TypeIDResolver<void,void>::id)
        {
          __dst = *(char **)(v162 + 8);
          v164 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__dst);
          if (v165 == 26)
          {
            v166 = *(_QWORD *)v164 == 0x6E656D6563616C70 && *(_QWORD *)(v164 + 8) == 0x6665726D656D2E74;
            v167 = v166 && *(_QWORD *)(v164 + 16) == 0x736E65745F6F745FLL;
            if (v167 && *(_WORD *)(v164 + 24) == 29295)
            {
              LOWORD(v333) = 1283;
              v331.__r_.__value_.__r.__words[0] = (std::string::size_type)"classof on '";
              v331.__r_.__value_.__r.__words[2] = (std::string::size_type)"placement.memref_to_tensor";
              v332 = 26;
              v326 = "' failed due to the operation not being registered";
              v330 = 259;
              llvm::operator+((uint64_t *)&v331, (uint64_t *)&v326, (uint64_t)&__dst);
              llvm::report_fatal_error((llvm::Twine *)&__dst, 1);
            }
          }
        }
        else if (v163 == &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
        {
          v316 = v161;
          goto LABEL_173;
        }
        v316 = 0;
        if (MTLReportFailureTypeEnabled())
          MTLReportFailure();
LABEL_173:
        v159 = (_QWORD *)*v159;
        v160 = v316;
      }
      while (v159);
      if (!v316)
        goto LABEL_404;
      __dst = NextResultAtOffset;
      v318 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v316);
      v169 = *((_QWORD *)NextResultAtOffset + 1) & 0xFFFFFFFFFFFFFFF8;
      if (!*(_QWORD *)v169)
      {
        v274 = 160;
        v275 = "abstractType && \"Malformed type storage object.\"";
        v276 = "TypeSupport.h";
        v277 = "getAbstractType";
        goto LABEL_377;
      }
      if (*(_UNKNOWN **)(*(_QWORD *)v169 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      {
        v274 = 566;
        v277 = "cast";
        v276 = "Casting.h";
        v275 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
LABEL_377:
        __assert_rtn(v277, v276, v274, v275);
      }
      MemRefRowBytes = (const char **)getMemRefRowBytes(v169);
      v170 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v316);
      ElementTypeOrSelf = mlir::getElementTypeOrSelf(v170);
      mlir::placement::MemrefToTensor::getInputShapeAfterInterleave(&v316, v321);
      v171 = *((unsigned int *)this + 82);
      v172 = *((_QWORD *)this + 40);
      if (v171 >= *((_DWORD *)this + 83))
      {
        v182 = v171 + 1;
        v183 = v172 + 88 * v171 > (unint64_t)&__dst;
        if (v172 <= (unint64_t)&__dst && v183)
        {
          v331.__r_.__value_.__r.__words[0] = 0;
          v174 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)v291, v292, v182, 88, (unint64_t *)&v331);
          std::__uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,std::__always_false,GPU::ANERegionCallOpHandler::ResultInfo* std::uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*>(GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*)::{lambda(GPU::ANERegionCallOpHandler::ResultInfo*&&)#1}>(*((_QWORD *)this + 40), *((_QWORD *)this + 40) + 88 * *((unsigned int *)this + 82), (uint64_t)v174);
          obj = (char *)*((_QWORD *)this + 40);
          v189 = *((_DWORD *)this + 82);
          if (v189)
          {
            v304 = 88 * v189;
            do
            {
              v190 = *(char **)&obj[v304 - 56];
              if (&obj[v304 - 40] != v190)
                free(v190);
              v304 -= 88;
            }
            while (v304);
            obj = *v291;
          }
          data = (int)v331.__r_.__value_.__l.__data_;
          if (obj != v292)
            free(obj);
          *((_QWORD *)this + 40) = v174;
          *((_DWORD *)this + 83) = data;
          v173 = (char **)&v174[8 * ((uint64_t)((uint64_t)&__dst - v172) >> 3)];
        }
        else
        {
          v331.__r_.__value_.__r.__words[0] = 0;
          v174 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)v291, v292, v182, 88, (unint64_t *)&v331);
          std::__uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,std::__always_false,GPU::ANERegionCallOpHandler::ResultInfo* std::uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*>(GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*)::{lambda(GPU::ANERegionCallOpHandler::ResultInfo*&&)#1}>(*((_QWORD *)this + 40), *((_QWORD *)this + 40) + 88 * *((unsigned int *)this + 82), (uint64_t)v174);
          v184 = (char *)*((_QWORD *)this + 40);
          v185 = *((_DWORD *)this + 82);
          if (v185)
          {
            v186 = 88 * v185;
            do
            {
              v187 = *(char **)&v184[v186 - 56];
              if (&v184[v186 - 40] != v187)
                free(v187);
              v186 -= 88;
            }
            while (v186);
            v184 = *v291;
          }
          v188 = (int)v331.__r_.__value_.__l.__data_;
          if (v184 != v292)
            free(v184);
          *((_QWORD *)this + 40) = v174;
          *((_DWORD *)this + 83) = v188;
          v173 = &__dst;
        }
      }
      else
      {
        v173 = &__dst;
        v174 = (char *)*((_QWORD *)this + 40);
      }
      v175 = &v174[88 * *((unsigned int *)this + 82)];
      v176 = *((_OWORD *)v173 + 1);
      *(_OWORD *)v175 = *(_OWORD *)v173;
      *((_OWORD *)v175 + 1) = v176;
      *((_QWORD *)v175 + 5) = 0x500000000;
      *((_QWORD *)v175 + 4) = v175 + 48;
      v177 = (uint64_t)(v175 + 32);
      if (*((_DWORD *)v173 + 10))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v177, (uint64_t)(v173 + 4));
      v178 = *((_DWORD *)this + 82);
      if (v178 >= *((_DWORD *)this + 83))
        __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
      *((_DWORD *)this + 82) = v178 + 1;
      if (v321[0] != &v322)
        free(v321[0]);
      v179 = v340[0];
      __dst = "__out:";
      MemRefRowBytes = (const char **)v340;
      LOWORD(v321[0]) = 2819;
      llvm::Twine::str((llvm::Twine *)&__dst, &v331);
      if ((v331.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v180 = (int8x16_t *)&v331;
      else
        v180 = (int8x16_t *)v331.__r_.__value_.__r.__words[0];
      if ((v331.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v181 = HIBYTE(v331.__r_.__value_.__r.__words[2]);
      else
        v181 = v331.__r_.__value_.__l.__size_;
      *(_QWORD *)(*llvm::StringMap<unsigned long long,llvm::MallocAllocator>::try_emplace<>((uint64_t)&v323, v180, (const unsigned __int8 *)v181)+ 8) = v179;
      if (SHIBYTE(v331.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v331.__r_.__value_.__l.__data_);
      ++v157;
    }
    while (v157 != v307);
  }
  objc_msgSend(*((id *)this + 9), "modelAttributes");
  v191 = (void *)objc_claimAutoreleasedReturnValue();
  v310 = v191;
  objc_msgSend(v191, "objectForKeyedSubscript:", CFSTR("NetworkStatusList"));
  v286 = (void *)objc_claimAutoreleasedReturnValue();
  v192 = (_QWORD *)MEMORY[0x1E0CFE010];
  objc_msgSend(v191, "objectForKeyedSubscript:", *MEMORY[0x1E0CFE010]);
  v193 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v193, "objectForKeyedSubscript:", *MEMORY[0x1E0CFE088]);
  v287 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v287 || !objc_msgSend(v287, "count"))
  {
    v278 = "0";
    v279 = 203;
    goto LABEL_396;
  }
  if (!v286 || !objc_msgSend(v286, "count"))
  {
    v278 = "0";
    v279 = 206;
LABEL_396:
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", v279, v278);
  }
  if (objc_msgSend(v287, "count") != 1)
  {
    v278 = "ANEFModelProcedures.count==1";
    v279 = 210;
    goto LABEL_396;
  }
  objc_msgSend(v287, "objectAtIndexedSubscript:", 0);
  v284 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v284, "objectForKeyedSubscript:", *MEMORY[0x1E0CFE030]);
  v306 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v306 || !objc_msgSend(v306, "count"))
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 215, "0");
  objc_msgSend(v284, "objectForKeyedSubscript:", *MEMORY[0x1E0CFE058]);
  v301 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v301 || !objc_msgSend(v301, "count"))
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 219, "0");
  objc_msgSend(v286, "objectAtIndexedSubscript:", 0);
  v194 = (void *)objc_claimAutoreleasedReturnValue();
  v285 = v194;
  if (!v194 || !objc_msgSend(v194, "count"))
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 224, "0");
  objc_msgSend(v285, "objectForKeyedSubscript:", CFSTR("LiveInputList"));
  v312 = (mlir::detail::OpResultImpl *)objc_claimAutoreleasedReturnValue();
  if (!v312 || !-[mlir::detail::OpResultImpl count](v312, "count"))
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 228, "0");
  objc_msgSend(v285, "objectForKeyedSubscript:", CFSTR("LiveOutputList"));
  v195 = (void *)objc_claimAutoreleasedReturnValue();
  v308 = v195;
  if (!v195 || !objc_msgSend(v195, "count"))
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 232, "0");
  objc_msgSend(v191, "objectForKeyedSubscript:", *v192);
  v196 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v196, "objectForKeyedSubscript:", *MEMORY[0x1E0CFE028]);
  v298 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v298)
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 238, "0");
  objc_msgSend(v191, "objectForKeyedSubscript:", *v192);
  v197 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v197, "objectForKeyedSubscript:", *MEMORY[0x1E0CFE050]);
  v309 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v309)
    __assert_rtn("ANERegionCallOpHandler", "ANERegion.mm", 242, "0");
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", -[mlir::detail::OpResultImpl count](v312, "count"));
  obja = (id)objc_claimAutoreleasedReturnValue();
  v198 = -[mlir::detail::OpResultImpl count](v312, "count");
  if (v198 > *((unsigned int *)this + 35))
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v289, v290, v198, 8);
  for (i = 0; i < -[mlir::detail::OpResultImpl count](v312, "count", v198); ++i)
  {
    -[mlir::detail::OpResultImpl objectAtIndexedSubscript:](v312, "objectAtIndexedSubscript:", i);
    v200 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v200, "objectForKeyedSubscript:", CFSTR("Name"));
    v201 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v202 = (const char *)objc_msgSend(v201, "UTF8String");
    v203 = (int8x16_t *)v202;
    if (v202)
      v204 = (const unsigned __int8 *)strlen(v202);
    else
      v204 = 0;
    Key = llvm::StringMapImpl::FindKey((uint64_t *)&v336, v203, v204);
    if (Key == -1 || Key == (unint64_t)v337)
    {
      v210 = 245;
      v213 = "Iter != this->end() && \"StringMap::at failed due to a missing key\"";
      v212 = "StringMap.h";
      v211 = "at";
LABEL_263:
      __assert_rtn(v211, v212, v210, v213);
    }
    v206 = *(_QWORD *)(*((_QWORD *)&v336->isa + Key) + 8);
    v207 = *((unsigned int *)this + 34);
    if (v207 >= *((unsigned int *)this + 35))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v289, v290, v207 + 1, 8);
      *(_QWORD *)(*((_QWORD *)this + 16) + 8 * *((unsigned int *)this + 34)) = v206;
      v208 = *((_DWORD *)this + 34);
      if (v208 >= *((_DWORD *)this + 35))
      {
LABEL_262:
        v210 = 102;
        v211 = "set_size";
        v212 = "SmallVector.h";
        v213 = "N <= capacity()";
        goto LABEL_263;
      }
    }
    else
    {
      *(_QWORD *)(*((_QWORD *)this + 16) + 8 * v207) = v206;
      v208 = *((_DWORD *)this + 34);
      if (v208 >= *((_DWORD *)this + 35))
        goto LABEL_262;
    }
    *((_DWORD *)this + 34) = v208 + 1;
    objc_msgSend(v306, "objectAtIndexedSubscript:", i);
    v209 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(obja, "addObject:", v209);

    v191 = v310;
  }
  objc_storeStrong((id *)this + 86, obja);
  v214 = objc_msgSend(v308, "count");
  if (v214 > *((unsigned int *)this + 47))
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v294, v288, v214, 8);
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", -[mlir::detail::OpResultImpl count](v312, "count", v214));
  v299 = (id)objc_claimAutoreleasedReturnValue();
  v215 = v308;
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", objc_msgSend(v308, "count"));
  v300 = (id)objc_claimAutoreleasedReturnValue();
  v216 = 0;
  v217 = MEMORY[0x1E0C9AAA0];
  v218 = (unint64_t)"set_size";
  while (v216 < objc_msgSend(v215, "count"))
  {
    objc_msgSend(v215, "objectAtIndexedSubscript:", v216);
    v219 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v219, "objectForKeyedSubscript:", CFSTR("Name"));
    v220 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v221 = (const char *)objc_msgSend(v220, "UTF8String");
    v222 = (int8x16_t *)v221;
    if (v221)
      v223 = (const unsigned __int8 *)strlen(v221);
    else
      v223 = 0;
    v224 = llvm::StringMapImpl::FindKey((uint64_t *)&v323, v222, v223);
    if (v224 == -1 || v224 == (unint64_t)v324)
    {
      v230 = 245;
      v233 = "Iter != this->end() && \"StringMap::at failed due to a missing key\"";
      v232 = "StringMap.h";
      v231 = "at";
LABEL_281:
      __assert_rtn(v231, v232, v230, v233);
    }
    v225 = *(_QWORD *)(*((_QWORD *)v323 + v224) + 8);
    v226 = *((unsigned int *)this + 46);
    if (v226 >= *((unsigned int *)this + 47))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v294, v288, v226 + 1, 8);
      *(_QWORD *)(*((_QWORD *)this + 22) + 8 * *((unsigned int *)this + 46)) = v225;
      v227 = *((_DWORD *)this + 46);
      if (v227 >= *((_DWORD *)this + 47))
      {
LABEL_280:
        v230 = 102;
        v231 = "set_size";
        v232 = "SmallVector.h";
        v233 = "N <= capacity()";
        goto LABEL_281;
      }
    }
    else
    {
      *(_QWORD *)(*((_QWORD *)this + 22) + 8 * v226) = v225;
      v227 = *((_DWORD *)this + 46);
      if (v227 >= *((_DWORD *)this + 47))
        goto LABEL_280;
    }
    *((_DWORD *)this + 46) = v227 + 1;
    objc_msgSend(v301, "objectAtIndexedSubscript:", v216);
    v228 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v300, "addObject:", v228);

    if (v216 >= objc_msgSend(v309, "count"))
    {
      objc_msgSend(v299, "addObject:", v217);
    }
    else
    {
      objc_msgSend(v309, "objectAtIndexedSubscript:", v216);
      v229 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v299, "addObject:", v229);

    }
    v191 = v310;

    ++v216;
    v215 = v308;
  }
  objc_storeStrong((id *)this + 87, v300);
  objc_storeStrong((id *)this + 88, v299);
  v234 = *((unsigned int *)this + 34);
  if ((_DWORD)v234)
  {
    v235 = 0;
    v236 = (_QWORD *)*((_QWORD *)this + 16);
    location = (id *)&v236[v234];
    while (1)
    {
      if (v235 >= objc_msgSend(v298, "count"))
        goto LABEL_353;
      if (*v236 >= (unint64_t)*((unsigned int *)this + 70))
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      v331.__r_.__value_.__r.__words[0] = *(_QWORD *)(*v297 + 8 * *v236);
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v331);
      if (!DefiningOp)
        __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
      if (!llvm::DefaultDoCastIfPossible<mlir::placement::TensorToMemref,mlir::Operation *,llvm::CastInfo<mlir::placement::TensorToMemref,mlir::Operation *,void>>::doCastIfPossible(DefiningOp)
        && MTLReportFailureTypeEnabled())
      {
        MTLReportFailure();
      }
      objc_msgSend(v298, "objectAtIndexedSubscript:", v235);
      v241 = (void *)objc_claimAutoreleasedReturnValue();
      v242 = objc_msgSend(v241, "isEqual:", MEMORY[0x1E0C9AAB0]);

      if (v242)
        break;
LABEL_289:
      ++v235;
      if (++v236 == location)
        goto LABEL_353;
    }
    v243 = *((_QWORD *)this + 2);
    v244 = mlir::Value::getDefiningOp((mlir::Value *)&v331);
    v245 = v244;
    v295 = (uint64_t *)(v243 + 264);
    v246 = 0x9DDFEA08EB382D69 * (((8 * v244) + 8) ^ HIDWORD(v244));
    v247 = 0x9DDFEA08EB382D69 * (HIDWORD(v244) ^ (v246 >> 47) ^ v246);
    v248 = 0x9DDFEA08EB382D69 * (v247 ^ (v247 >> 47));
    v249 = *(_QWORD *)(v243 + 272);
    if (v249)
    {
      v250 = (uint8x8_t)vcnt_s8((int8x8_t)v249);
      v250.i16[0] = vaddlv_u8(v250);
      if (v250.u32[0] > 1uLL)
      {
        v218 = 0x9DDFEA08EB382D69 * (v247 ^ (v247 >> 47));
        if (v248 >= v249)
          v218 = v248 % v249;
      }
      else
      {
        v218 = (v249 - 1) & v248;
      }
      v251 = *(char ***)(*v295 + 8 * v218);
      if (v251)
      {
        v252 = *v251;
        if (*v251)
        {
          if (v250.u32[0] < 2uLL)
          {
            while (1)
            {
              v254 = *((_QWORD *)v252 + 1);
              if (v254 == v248)
              {
                if (*((_QWORD *)v252 + 2) == v244)
                  goto LABEL_288;
              }
              else if ((v254 & (v249 - 1)) != v218)
              {
                goto LABEL_315;
              }
              v252 = *(char **)v252;
              if (!v252)
                goto LABEL_315;
            }
          }
          do
          {
            v253 = *((_QWORD *)v252 + 1);
            if (v253 == v248)
            {
              if (*((_QWORD *)v252 + 2) == v244)
                goto LABEL_288;
            }
            else
            {
              if (v253 >= v249)
                v253 %= v249;
              if (v253 != v218)
                break;
            }
            v252 = *(char **)v252;
          }
          while (v252);
        }
      }
    }
LABEL_315:
    v252 = (char *)operator new(0x20uLL);
    v255 = (char **)(v243 + 280);
    __dst = v252;
    v318 = v243 + 280;
    *(_QWORD *)v252 = 0;
    *((_QWORD *)v252 + 1) = v248;
    *((_QWORD *)v252 + 2) = v245;
    *((_QWORD *)v252 + 3) = 0;
    LOBYTE(MemRefRowBytes) = 1;
    v256 = (float)(unint64_t)(*(_QWORD *)(v243 + 288) + 1);
    v257 = *(float *)(v243 + 296);
    if (v249 && (float)(v257 * (float)v249) >= v256)
    {
      v237 = (_QWORD *)(v243 + 264);
      v238 = *v295;
      v239 = *(char ***)(*v295 + 8 * v218);
      if (!v239)
        goto LABEL_318;
    }
    else
    {
      v259 = (v249 & (v249 - 1)) != 0;
      if (v249 < 3)
        v259 = 1;
      v260 = v259 | (2 * v249);
      v261 = vcvtps_u32_f32(v256 / v257);
      if (v260 <= v261)
        prime = v261;
      else
        prime = v260;
      if (prime == 1)
      {
        prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        prime = std::__next_prime(prime);
        v249 = *(_QWORD *)(v243 + 272);
      }
      if (prime > v249)
        goto LABEL_331;
      if (prime < v249)
      {
        v263 = vcvtps_u32_f32((float)*(unint64_t *)(v243 + 288) / *(float *)(v243 + 296));
        if (v249 < 3 || (v264 = (uint8x8_t)vcnt_s8((int8x8_t)v249), v264.i16[0] = vaddlv_u8(v264), v264.u32[0] > 1uLL))
        {
          v263 = std::__next_prime(v263);
        }
        else
        {
          v265 = 1 << -(char)__clz(v263 - 1);
          if (v263 >= 2)
            v263 = v265;
        }
        if (prime <= v263)
          prime = v263;
        if (prime < v249)
LABEL_331:
          std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>((uint64_t)v295, prime);
      }
      v249 = *(_QWORD *)(v243 + 272);
      v266 = v249 - 1;
      if ((v249 & (v249 - 1)) != 0)
      {
        v237 = (_QWORD *)(v243 + 264);
        if (v248 >= v249)
        {
          v218 = v248 % v249;
          v238 = *v295;
          v239 = *(char ***)(*v295 + 8 * (v248 % v249));
          if (!v239)
            goto LABEL_318;
        }
        else
        {
          v218 = v248;
          v238 = *v295;
          v239 = *(char ***)(*v295 + 8 * v248);
          if (!v239)
            goto LABEL_318;
        }
      }
      else
      {
        v218 = v266 & v248;
        v237 = (_QWORD *)(v243 + 264);
        v238 = *v295;
        v239 = *(char ***)(*v295 + 8 * (v266 & v248));
        if (!v239)
        {
LABEL_318:
          *(_QWORD *)v252 = *v255;
          *v255 = v252;
          *(_QWORD *)(v238 + 8 * v218) = v255;
          v191 = v310;
          if (!*(_QWORD *)v252)
          {
LABEL_287:
            ++*(_QWORD *)(v243 + 288);
LABEL_288:
            GPU::TensorToMemrefOpHandler::setAlignBytes(*((_QWORD *)v252 + 3), 0x4000);
            goto LABEL_289;
          }
          v258 = *(_QWORD *)(*(_QWORD *)v252 + 8);
          if ((v249 & (v249 - 1)) != 0)
          {
            if (v258 >= v249)
              v258 %= v249;
          }
          else
          {
            v258 &= v249 - 1;
          }
          v239 = (char **)(*v237 + 8 * v258);
LABEL_286:
          *v239 = v252;
          goto LABEL_287;
        }
      }
    }
    *(_QWORD *)v252 = *v239;
    v191 = v310;
    goto LABEL_286;
  }
LABEL_353:

  if (HIDWORD(v324) && (_DWORD)v324)
  {
    v267 = 0;
    do
    {
      v268 = *(llvm **)((char *)v323 + v267);
      if (v268 != (llvm *)-8 && v268 != 0)
        llvm::deallocate_buffer(v268, (void *)(*(_QWORD *)v268 + 17));
      v267 += 8;
    }
    while (8 * v324 != v267);
  }
  free(v323);
  if (HIDWORD(v337) && (_DWORD)v337)
  {
    v270 = 0;
    do
    {
      v271 = *(llvm **)((char *)&v336->isa + v270);
      if (v271 != (llvm *)-8 && v271 != 0)
        llvm::deallocate_buffer(v271, (void *)(*(_QWORD *)v271 + 17));
      v270 += 8;
    }
    while (8 * v337 != v270);
  }
  free(v336);
LABEL_372:

  return this;
}

void sub_180E24298(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void **a18, void *a19, void **a20,char *a21,uint64_t a22,uint64_t a23,void *a24,void **a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char *a54,unsigned int a55,int a56)
{
  uint64_t v56;
  uint64_t v57;
  uint64_t v59;
  char *v60;
  unsigned int v61;
  void *v62;
  void *v63;
  uint64_t v64;
  llvm *v65;
  uint64_t v67;
  llvm *v68;
  uint64_t v70;
  char *v71;

  if (a47 != a33)
    free(a47);
  if (a56 && a55)
  {
    v64 = 0;
    do
    {
      v65 = *(llvm **)&a54[v64];
      if (v65 != (llvm *)-8 && v65 != 0)
        llvm::deallocate_buffer(v65, (void *)(*(_QWORD *)v65 + 17));
      v64 += 8;
    }
    while (8 * a55 != v64);
  }
  free(a54);
  if (*(_DWORD *)(v57 - 140))
  {
    v59 = *(unsigned int *)(v57 - 144);
    if ((_DWORD)v59)
    {
      v67 = 0;
      do
      {
        v68 = *(llvm **)(*(_QWORD *)(v57 - 152) + v67);
        if (v68 != (llvm *)-8 && v68 != 0)
          llvm::deallocate_buffer(v68, (void *)(*(_QWORD *)v68 + 17));
        v67 += 8;
      }
      while (8 * v59 != v67);
    }
  }
  free(*(void **)(v57 - 152));

  v60 = *(char **)(v56 + 320);
  v61 = *(_DWORD *)(v56 + 328);
  if (v61)
  {
    v70 = 88 * v61;
    do
    {
      v71 = *(char **)&v60[v70 - 56];
      if (&v60[v70 - 40] != v71)
        free(v71);
      v70 -= 88;
    }
    while (v70);
    v60 = (char *)*a20;
    if (*a20 == a21)
    {
LABEL_9:
      v62 = *a25;
      if (*a25 == a16)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  else if (v60 == a21)
  {
    goto LABEL_9;
  }
  free(v60);
  v62 = *a25;
  if (*a25 == a16)
  {
LABEL_11:

    v63 = *(void **)(v56 + 176);
    if (v63 != a17)
      free(v63);
    if (*a18 != a19)
      free(*a18);

    _Unwind_Resume(a1);
  }
LABEL_10:
  free(v62);
  goto LABEL_11;
}

void ___ZN3GPU22ANERegionCallOpHandlerC2EPNS_13BaseOpHandlerE_block_invoke()
{
  if (getenv("MPSGRAPH_DISABLE_ANE_SHARED_EVENTS"))
  {
    NSLog(CFSTR("MPSGRAPH_DISABLE_ANE_SHARED_EVENTS EV is on"));
    byte_1ECD35601 = 1;
  }
  if (getenv("MPSGRAPH_ENABLE_ANE_SHARED_EVENTS"))
  {
    NSLog(CFSTR("MPSGRAPH_ENABLE_ANE_SHARED_EVENTS EV is on"));
    byte_1ECD35602 = 1;
  }
  if (getenv("MPSGRAPH_DISABLE_ANE_INTERMEDIATE_BUFFER"))
  {
    NSLog(CFSTR("MPSGRAPH_DISABLE_ANE_INTERMEDIATE_BUFFER EV is set"));
    byte_1ECD35603 = 1;
  }
  if (getenv("MPSGRAPH_DISABLE_ANE_CACHING"))
  {
    NSLog(CFSTR("MPSGRAPH_DISABLE_ANE_CACHING EV is set"));
    byte_1ECD35604 = 1;
  }
  if (getenv("MPSGRAPH_ENABLE_ANE_SYNC_RUN"))
  {
    NSLog(CFSTR("MPSGRAPH_ENABLE_ANE_SYNC_RUN EV is set"));
    byte_1ECD35605 = 1;
  }
  if (getenv("MPSGRAPH_ENABLE_ANE_REAL_TIME_QOS"))
  {
    NSLog(CFSTR("MPSGRAPH_ENABLE_ANE_REAL_TIME_QOS EV is set"));
    byte_1ECD35606 = 1;
  }
  if (getenv("MPS_GRAPH_ENABLE_ANE_ERRORS_AS_FAILURES"))
  {
    NSLog(CFSTR("MPS_GRAPH_ENABLE_ANE_ERRORS_AS_FAILURES EV is set"));
    byte_1ECD35607 = 1;
  }
  if (getenv("MPS_GRAPH_ENABLE_ANE_OVERFLOW_AS_FAILURES"))
  {
    NSLog(CFSTR("MPS_GRAPH_ENABLE_ANE_OVERFLOW_AS_FAILURES EV is set"));
    byte_1ECD35608 = 1;
  }
  if (getenv("MPS_GRAPH_FORCE_ANE_FALLBACK"))
  {
    NSLog(CFSTR("MPS_GRAPH_FORCE_ANE_FALLBACK EV is set"));
    byte_1ECD35609 = 1;
  }
  if (getenv("MPS_GRAPH_DISABLE_ANE_FALLBACK"))
  {
    NSLog(CFSTR("MPS_GRAPH_DISABLE_ANE_FALLBACK EV is set"));
    byte_1ECD3560A = 1;
  }
  std::mutex::lock(&GPU::ANERegionCallOpHandler::_intermediateBufferHandleMutex);
  _MergedGlobals_70 = 0;
  qword_1ECD35610 = -1;
  qword_1ECD35618 = 0;
  std::mutex::unlock(&GPU::ANERegionCallOpHandler::_intermediateBufferHandleMutex);
}

void GPU::ANERegionCallOpHandler::~ANERegionCallOpHandler(GPU::ANERegionCallOpHandler *this)
{
  void *v2;
  char v3;
  id v4;
  char v5;
  char *v6;
  unsigned int v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  void *v13;

  *(_QWORD *)this = &off_1E0E1D700;
  std::mutex::lock(&GPU::ANERegionCallOpHandler::_intermediateBufferHandleMutex);
  if (_MergedGlobals_70 == 1 && !*((_BYTE *)this + 117) && *((_BYTE *)this + 224))
  {
    if (!--qword_1ECD35618)
    {
      _MergedGlobals_70 = 0;
      qword_1ECD35610 = -1;
    }
    *((_BYTE *)this + 224) = 0;
  }
  std::mutex::unlock(&GPU::ANERegionCallOpHandler::_intermediateBufferHandleMutex);
  if (*((_QWORD *)this + 9))
  {
    v2 = (void *)*((_QWORD *)this + 10);
    if (*((_BYTE *)this + 119))
    {
      v3 = objc_msgSend(v2, "unloadRealTimeModel:options:qos:error:");
      v4 = 0;
      if ((v3 & 1) == 0)
      {
LABEL_28:
        if (v4)
        {
          objc_msgSend(v4, "debugDescription");
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          NSLog(CFSTR("Error = %@"), v13);

        }
        __assert_rtn("~ANERegionCallOpHandler", "ANERegion.mm", 321, "0");
      }
    }
    else
    {
      v5 = objc_msgSend(v2, "unloadModel:options:qos:error:");
      v4 = 0;
      if ((v5 & 1) == 0)
        goto LABEL_28;
    }
  }
  else
  {
    v4 = 0;
  }

  v6 = (char *)*((_QWORD *)this + 40);
  v7 = *((_DWORD *)this + 82);
  if (v7)
  {
    v8 = 88 * v7;
    do
    {
      v9 = *(char **)&v6[v8 - 56];
      if (&v6[v8 - 40] != v9)
        free(v9);
      v8 -= 88;
    }
    while (v8);
    v6 = (char *)*((_QWORD *)this + 40);
  }
  if (v6 != (char *)this + 336)
    free(v6);
  v10 = (char *)*((_QWORD *)this + 34);
  if (v10 != (char *)this + 288)
    free(v10);

  v11 = (char *)*((_QWORD *)this + 22);
  if (v11 != (char *)this + 192)
    free(v11);
  v12 = (char *)*((_QWORD *)this + 16);
  if (v12 != (char *)this + 144)
    free(v12);

}

{
  GPU::ANERegionCallOpHandler::~ANERegionCallOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::ANERegionCallOpHandler::checkAndResetSharedEvents(GPU::ANERegionCallOpHandler *this)
{
  id v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id v6;

  if ((unint64_t)(*((_QWORD *)this + 33) + 3) <= 1)
  {
    objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
    v6 = (id)objc_claimAutoreleasedReturnValue();
    v2 = objc_alloc_init(MEMORY[0x1E0CBBEB8]);
    v3 = (void *)*((_QWORD *)this + 31);
    *((_QWORD *)this + 31) = v2;

    v4 = objc_msgSend(v6, "newSharedEventWithMachPort:", objc_msgSend(*((id *)this + 31), "eventPort"));
    v5 = (void *)*((_QWORD *)this + 32);
    *((_QWORD *)this + 32) = v4;

    *((_QWORD *)this + 33) = 0;
  }
}

void sub_180E24DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void GPU::ANERegionCallOpHandler::encodeSynchronous(uint64_t a1, uint64_t a2, void *a3, void *a4, char a5)
{
  id v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;

  v13 = a3;
  v9 = a4;
  if ((a5 & 1) == 0)
  {
    objc_msgSend(*(id *)(a2 + 8), "rootCommandBuffer");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    (**(void (***)(uint64_t))a2)(a2);
    objc_msgSend(v10, "waitUntilCompleted");

  }
  objc_msgSend(MEMORY[0x1E0CFDF90], "requestWithInputs:inputIndices:outputs:outputIndices:weightsBuffer:perfStats:procedureIndex:sharedEvents:", v13, *(_QWORD *)(a1 + 688), v9, *(_QWORD *)(a1 + 696), 0, 0, &unk_1E0E98758, 0);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = (void *)objc_msgSend(*(id *)(a1 + 88), "mutableCopy");
  objc_msgSend(v12, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAA0], *MEMORY[0x1E0CFDFD8]);

  objc_msgSend(*(id *)(a1 + 72), "programHandle");
  kdebug_trace();

}

void sub_180E24F54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_180E24F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_180E24F88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_180E24FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_180E24FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void GPU::`anonymous namespace'::evaluateModel(void *a1, void *a2, void *a3, void *a4, uint64_t a5, int a6, NSError *a7, int a8)
{
  id v15;
  id v16;
  id v17;
  id v18;
  id *v19;
  uint64_t v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v15 = a1;
  v16 = a2;
  v17 = a3;
  v18 = a4;
  if (v15)
  {
    if (a6)
    {
      v24 = 0;
      v19 = (id *)&v24;
      v20 = objc_msgSend(v16, "evaluateRealTimeWithModel:options:request:error:", v15, v17, v18, &v24);
    }
    else
    {
      v23 = 0;
      v19 = (id *)&v23;
      v20 = objc_msgSend(v16, "evaluateWithModel:options:request:qos:error:", v15, v17, v18, a5, &v23);
    }
    v22 = v20;
    v21 = *v19;
  }
  else
  {
    v21 = 0;
    v22 = 1;
  }

}

void sub_180E250F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void GPU::ANERegionCallOpHandler::encodeAsynchronousWithIOFences(uint64_t a1, uint64_t a2, void *a3, void *a4, int a5)
{
  id v9;
  id v10;
  uint64_t v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  id WeakRetained;
  id v18;
  uint64_t v19;
  id v20;
  void *v21;
  NSObject *v22;
  id *v23;
  id *v24;
  void *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  _QWORD v29[4];
  id v30;
  _QWORD v31[2];
  _QWORD block[4];
  id v33;
  _QWORD v34[2];
  _QWORD v35[4];
  id v36;
  uint64_t v37;
  uint64_t v38;
  id v39;

  v9 = a3;
  v10 = a4;
  v27 = v10;
  v28 = v9;
  GPU::ANERegionCallOpHandler::checkAndResetSharedEvents((GPU::ANERegionCallOpHandler *)a1);
  v11 = *(_QWORD *)(a1 + 264);
  v12 = *(id *)(a2 + 8);
  v13 = v12;
  if ((a5 & 1) == 0)
  {
    ++v11;
    v14 = *(_QWORD *)(a1 + 256);
    ++*(_QWORD *)(a1 + 264);
    objc_msgSend(v12, "encodeSignalEvent:value:", v14, v11);
  }
  v15 = *(_QWORD *)(a1 + 264) + 1;
  *(_QWORD *)(a1 + 264) = v15;
  objc_msgSend(MEMORY[0x1E0CFDF90], "requestWithInputs:inputIndices:outputs:outputIndices:weightsBuffer:perfStats:procedureIndex:sharedEvents:", v9, *(_QWORD *)(a1 + 688), v10, *(_QWORD *)(a1 + 696), 0, 0, &unk_1E0E98758, 0);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 16) + 56));

  v18 = *(id *)(a1 + 256);
  v19 = MEMORY[0x1E0C809B0];
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 3221225472;
  v35[2] = ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke;
  v35[3] = &unk_1E0E76910;
  v37 = a1;
  v20 = v18;
  v36 = v20;
  v38 = v15;
  v39 = WeakRetained;
  objc_msgSend(v16, "setCompletionHandler:", v35);
  v21 = (void *)objc_msgSend(*(id *)(a1 + 88), "mutableCopy");
  objc_msgSend(v21, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAA0], *MEMORY[0x1E0CFDFD8]);
  if (a5)
  {
    v22 = *(NSObject **)(a1 + 232);
    block[0] = v19;
    block[1] = 3221225472;
    block[2] = ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke_2;
    block[3] = &unk_1E0E76938;
    v34[1] = a1;
    v23 = &v33;
    v33 = v21;
    v24 = (id *)v34;
    v34[0] = v16;
    dispatch_async(v22, block);
  }
  else
  {
    v25 = *(void **)(a1 + 256);
    v26 = *(_QWORD *)(a1 + 240);
    v29[0] = v19;
    v29[1] = 3221225472;
    v29[2] = ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke_3;
    v29[3] = &unk_1E0E76960;
    v31[1] = a1;
    v30 = v21;
    v31[0] = v16;
    objc_msgSend(v25, "notifyListener:atValue:block:", v26, v11, v29);
    v23 = &v30;
    v24 = (id *)v31;
  }

  objc_msgSend(v13, "encodeWaitForEvent:value:", *(_QWORD *)(a1 + 256), v15);
}

void sub_180E25380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  void *v32;
  void *v33;
  void *v34;
  void *v35;

  _Unwind_Resume(a1);
}

void ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke(uint64_t a1, GPU::_anonymous_namespace_ *a2, void *a3)
{
  uint64_t v5;
  id v6;

  v6 = a3;
  v5 = *(_QWORD *)(a1 + 40);
  objc_msgSend(*(id *)(a1 + 32), "setSignaledValue:", *(_QWORD *)(a1 + 48));
  objc_msgSend(*(id *)(v5 + 72), "programHandle");
  kdebug_trace();

}

void sub_180E2548C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void GPU::`anonymous namespace'::checkANEEvaluationStatus(GPU::_anonymous_namespace_ *this, void *a2, NSError *a3, int a4)
{
  int v5;
  char v6;
  id v7;
  void *v8;
  int v9;
  void *v10;
  int v11;
  void *v12;

  v5 = (int)a3;
  v6 = (char)this;
  v7 = a2;
  v8 = v7;
  if ((v6 & 1) == 0)
  {
    v12 = v7;
    if (objc_msgSend(v7, "code") == 5)
    {
      if (!v5)
      {
        objc_msgSend(v12, "debugDescription");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        NSLog(CFSTR("ANE Overflow Error = %@"), v10);
        goto LABEL_11;
      }
      v9 = MTLReportFailureTypeEnabled();
      v8 = v12;
      if (v9)
      {
LABEL_5:
        objc_msgSend(v12, "debugDescription");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        MTLReportFailure();
LABEL_11:

        v8 = v12;
      }
    }
    else
    {
      if (!a4)
      {
        objc_msgSend(v12, "debugDescription");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        NSLog(CFSTR("ANE Evaluation Error = %@"), v10);
        goto LABEL_11;
      }
      v11 = MTLReportFailureTypeEnabled();
      v8 = v12;
      if (v11)
        goto LABEL_5;
    }
  }

}

void sub_180E255D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_180E255F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke_2(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 48);
}

void ___ZN3GPU22ANERegionCallOpHandler30encodeAsynchronousWithIOFencesEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7_b_block_invoke_3(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 48);
}

void GPU::ANERegionCallOpHandler::encodeAsynchronousWithSharedEvents(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  unint64_t v4;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint8x8_t v16;
  void **v17;
  void *v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  float v22;
  float v23;
  uint64_t v24;
  _QWORD *v25;
  _BOOL8 v26;
  unint64_t v27;
  unint64_t v28;
  size_t prime;
  unint64_t v30;
  uint8x8_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  GraphANESharedEventHandler *v35;
  unint64_t v36;
  uint8x8_t v37;
  _QWORD *v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  float v44;
  float v45;
  uint64_t v46;
  _QWORD *v47;
  _BOOL8 v48;
  unint64_t v49;
  unint64_t v50;
  size_t v51;
  int8x8_t v52;
  unint64_t v53;
  uint8x8_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  void *v59;
  uint64_t v60;
  IOSurfaceSharedEvent *v61;
  void *v62;
  IOSurfaceSharedEvent *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  void *v70;
  id WeakRetained;
  void *v72;
  uint64_t v73;
  void *v74;
  void *v75;
  id v76;
  id v77;
  id v78;
  uint64_t v79;
  void *v80;
  _QWORD v81[6];
  _QWORD *v82;
  uint64_t v83;
  char v84;
  _QWORD v85[3];

  v85[1] = *MEMORY[0x1E0C80C00];
  v77 = a3;
  v78 = a4;
  GPU::ANERegionCallOpHandler::checkAndResetSharedEvents((GPU::ANERegionCallOpHandler *)a1);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice");
  v75 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = *(_QWORD *)(a1 + 264) + 1;
  *(_QWORD *)(a1 + 264) = v8;
  v76 = *(id *)(a2 + 8);
  objc_msgSend(v76, "encodeSignalEvent:value:", *(_QWORD *)(a1 + 256), v8);
  v79 = *(_QWORD *)(a1 + 264) + 1;
  *(_QWORD *)(a1 + 264) = v79;
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", 3);
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*(id *)(a2 + 8), "rootCommandBuffer");
  v9 = objc_claimAutoreleasedReturnValue();
  v10 = (void *)v9;
  v11 = (uint64_t *)(a2 + 32);
  v12 = 0x9DDFEA08EB382D69 * (((8 * v9) + 8) ^ HIDWORD(v9));
  v13 = 0x9DDFEA08EB382D69 * (HIDWORD(v9) ^ (v12 >> 47) ^ v12);
  v14 = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
  v15 = *(_QWORD *)(a2 + 40);
  v73 = v8;
  if (v15)
  {
    v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
    v16.i16[0] = vaddlv_u8(v16);
    if (v16.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
      if (v14 >= v15)
        v4 = v14 % v15;
    }
    else
    {
      v4 = (v15 - 1) & v14;
    }
    v17 = *(void ***)(*v11 + 8 * v4);
    if (v17)
    {
      v18 = *v17;
      if (*v17)
      {
        if (v16.u32[0] < 2uLL)
        {
          while (1)
          {
            v20 = *((_QWORD *)v18 + 1);
            if (v20 == v14)
            {
              if (*((_QWORD *)v18 + 2) == v9)
                goto LABEL_62;
            }
            else if ((v20 & (v15 - 1)) != v4)
            {
              goto LABEL_22;
            }
            v18 = *(void **)v18;
            if (!v18)
              goto LABEL_22;
          }
        }
        do
        {
          v19 = *((_QWORD *)v18 + 1);
          if (v19 == v14)
          {
            if (*((_QWORD *)v18 + 2) == v9)
              goto LABEL_62;
          }
          else
          {
            if (v19 >= v15)
              v19 %= v15;
            if (v19 != v4)
              break;
          }
          v18 = *(void **)v18;
        }
        while (v18);
      }
    }
  }
LABEL_22:
  v18 = operator new(0x20uLL);
  v21 = (_QWORD *)(a2 + 48);
  v82 = v18;
  v83 = a2 + 48;
  *(_QWORD *)v18 = 0;
  *((_QWORD *)v18 + 1) = v14;
  *((_QWORD *)v18 + 2) = v10;
  *((_QWORD *)v18 + 3) = 0;
  v84 = 1;
  v22 = (float)(unint64_t)(*(_QWORD *)(a2 + 56) + 1);
  v23 = *(float *)(a2 + 64);
  if (v15 && (float)(v23 * (float)v15) >= v22)
  {
    v24 = *v11;
    v25 = *(_QWORD **)(*v11 + 8 * v4);
    if (v25)
    {
LABEL_25:
      *(_QWORD *)v18 = *v25;
LABEL_60:
      *v25 = v18;
      goto LABEL_61;
    }
  }
  else
  {
    v26 = 1;
    if (v15 >= 3)
      v26 = (v15 & (v15 - 1)) != 0;
    v27 = v26 | (2 * v15);
    v28 = vcvtps_u32_f32(v22 / v23);
    if (v27 <= v28)
      prime = v28;
    else
      prime = v27;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v15 = *(_QWORD *)(a2 + 40);
    }
    if (prime > v15)
      goto LABEL_36;
    if (prime < v15)
    {
      v30 = vcvtps_u32_f32((float)*(unint64_t *)(a2 + 56) / *(float *)(a2 + 64));
      if (v15 < 3 || (v31 = (uint8x8_t)vcnt_s8((int8x8_t)v15), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        v30 = std::__next_prime(v30);
      }
      else
      {
        v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2)
          v30 = v32;
      }
      if (prime <= v30)
        prime = v30;
      if (prime < v15)
LABEL_36:
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a2 + 32, prime);
    }
    v15 = *(_QWORD *)(a2 + 40);
    v33 = v15 - 1;
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v14 >= v15)
      {
        v4 = v14 % v15;
        v24 = *v11;
        v25 = *(_QWORD **)(*v11 + 8 * (v14 % v15));
        if (v25)
          goto LABEL_25;
      }
      else
      {
        v4 = v14;
        v24 = *v11;
        v25 = *(_QWORD **)(*v11 + 8 * v14);
        if (v25)
          goto LABEL_25;
      }
    }
    else
    {
      v4 = v33 & v14;
      v24 = *v11;
      v25 = *(_QWORD **)(*v11 + 8 * (v33 & v14));
      if (v25)
        goto LABEL_25;
    }
  }
  *(_QWORD *)v18 = *v21;
  *v21 = v18;
  *(_QWORD *)(v24 + 8 * v4) = v21;
  if (*(_QWORD *)v18)
  {
    v34 = *(_QWORD *)(*(_QWORD *)v18 + 8);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v34 >= v15)
        v34 %= v15;
    }
    else
    {
      v34 &= v15 - 1;
    }
    v25 = (_QWORD *)(*v11 + 8 * v34);
    goto LABEL_60;
  }
LABEL_61:
  ++*(_QWORD *)(a2 + 56);
LABEL_62:
  v35 = (GraphANESharedEventHandler *)*((id *)v18 + 3);
  if (!v35)
  {
    v35 = -[GraphANESharedEventHandler initWithDevice:]([GraphANESharedEventHandler alloc], "initWithDevice:", v75);
    v36 = *(_QWORD *)(a2 + 40);
    if (v36)
    {
      v37 = (uint8x8_t)vcnt_s8((int8x8_t)v36);
      v37.i16[0] = vaddlv_u8(v37);
      if (v37.u32[0] > 1uLL)
      {
        v4 = v14;
        if (v14 >= v36)
          v4 = v14 % v36;
      }
      else
      {
        v4 = (v36 - 1) & v14;
      }
      v38 = *(_QWORD **)(*v11 + 8 * v4);
      if (v38)
      {
        v39 = (_QWORD *)*v38;
        if (v39)
        {
          if (v37.u32[0] < 2uLL)
          {
            while (1)
            {
              v41 = v39[1];
              if (v41 == v14)
              {
                if ((void *)v39[2] == v10)
                  goto LABEL_124;
              }
              else if ((v41 & (v36 - 1)) != v4)
              {
                goto LABEL_84;
              }
              v39 = (_QWORD *)*v39;
              if (!v39)
                goto LABEL_84;
            }
          }
          do
          {
            v40 = v39[1];
            if (v40 == v14)
            {
              if ((void *)v39[2] == v10)
                goto LABEL_124;
            }
            else
            {
              if (v40 >= v36)
                v40 %= v36;
              if (v40 != v4)
                break;
            }
            v39 = (_QWORD *)*v39;
          }
          while (v39);
        }
      }
    }
LABEL_84:
    v42 = operator new(0x20uLL);
    v43 = (_QWORD *)(a2 + 48);
    v82 = v42;
    v83 = a2 + 48;
    *v42 = 0;
    v42[1] = v14;
    v42[2] = v10;
    v42[3] = v35;
    v84 = 1;
    v44 = (float)(unint64_t)(*(_QWORD *)(a2 + 56) + 1);
    v45 = *(float *)(a2 + 64);
    if (v36 && (float)(v45 * (float)v36) >= v44)
    {
      v46 = *v11;
      v47 = *(_QWORD **)(*v11 + 8 * v4);
      if (v47)
      {
LABEL_87:
        *v42 = *v47;
        goto LABEL_122;
      }
    }
    else
    {
      v48 = 1;
      if (v36 >= 3)
        v48 = (v36 & (v36 - 1)) != 0;
      v49 = v48 | (2 * v36);
      v50 = vcvtps_u32_f32(v44 / v45);
      if (v49 <= v50)
        v51 = v50;
      else
        v51 = v49;
      if (v51 == 1)
      {
        v51 = 2;
      }
      else if ((v51 & (v51 - 1)) != 0)
      {
        v51 = std::__next_prime(v51);
      }
      v52 = *(int8x8_t *)(a2 + 40);
      if (v51 > *(_QWORD *)&v52)
        goto LABEL_98;
      if (v51 < *(_QWORD *)&v52)
      {
        v53 = vcvtps_u32_f32((float)*(unint64_t *)(a2 + 56) / *(float *)(a2 + 64));
        if (*(_QWORD *)&v52 < 3uLL || (v54 = (uint8x8_t)vcnt_s8(v52), v54.i16[0] = vaddlv_u8(v54), v54.u32[0] > 1uLL))
        {
          v53 = std::__next_prime(v53);
        }
        else
        {
          v55 = 1 << -(char)__clz(v53 - 1);
          if (v53 >= 2)
            v53 = v55;
        }
        if (v51 <= v53)
          v51 = v53;
        if (v51 < *(_QWORD *)&v52)
LABEL_98:
          std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a2 + 32, v51);
      }
      v36 = *(_QWORD *)(a2 + 40);
      v56 = v36 - 1;
      if ((v36 & (v36 - 1)) != 0)
      {
        if (v14 >= v36)
        {
          v4 = v14 % v36;
          v46 = *v11;
          v47 = *(_QWORD **)(*v11 + 8 * (v14 % v36));
          if (v47)
            goto LABEL_87;
        }
        else
        {
          v4 = v14;
          v46 = *v11;
          v47 = *(_QWORD **)(*v11 + 8 * v14);
          if (v47)
            goto LABEL_87;
        }
      }
      else
      {
        v4 = v56 & v14;
        v46 = *v11;
        v47 = *(_QWORD **)(*v11 + 8 * (v56 & v14));
        if (v47)
          goto LABEL_87;
      }
    }
    *v42 = *v43;
    *v43 = v42;
    *(_QWORD *)(v46 + 8 * v4) = v43;
    if (!*v42)
      goto LABEL_123;
    v57 = *(_QWORD *)(*v42 + 8);
    if ((v36 & (v36 - 1)) != 0)
    {
      if (v57 >= v36)
        v57 %= v36;
    }
    else
    {
      v57 &= v36 - 1;
    }
    v47 = (_QWORD *)(*v11 + 8 * v57);
LABEL_122:
    *v47 = v42;
LABEL_123:
    ++*(_QWORD *)(a2 + 56);
LABEL_124:
    objc_msgSend(v10, "encodeSignalEventScheduled:value:", v35->_sharedEvent, 1);

  }
  objc_msgSend(MEMORY[0x1E0CFDFA8], "waitEventWithValue:sharedEvent:eventType:", v73, *(_QWORD *)(a1 + 248), 0);
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v80, "addObject:");
  if (objc_msgSend(*(id *)(*(_QWORD *)(a2 + 16) + 24), "count"))
  {
    objc_msgSend(*(id *)(*(_QWORD *)(a2 + 16) + 24), "objectAtIndexedSubscript:", 0);
    v58 = objc_claimAutoreleasedReturnValue();
    v59 = (void *)objc_msgSend(*(id *)(v58 + 8), "newSharedEventHandle");
    v60 = objc_msgSend(v59, "eventPort");
    v61 = (IOSurfaceSharedEvent *)objc_msgSend(objc_alloc(MEMORY[0x1E0CBBEB8]), "initWithMachPort:", v60);
    objc_msgSend(MEMORY[0x1E0CFDFA8], "waitEventWithValue:sharedEvent:eventType:", *(_QWORD *)(v58 + 16), v61, 1);
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v80, "addObject:", v62);

  }
  else
  {
    v61 = v35->_ioSurfaceStartSharedEvent;
    objc_msgSend(MEMORY[0x1E0CFDFA8], "waitEventWithValue:sharedEvent:eventType:", 1, v61, 1);
    v58 = objc_claimAutoreleasedReturnValue();
    objc_msgSend(v80, "addObject:", v58);
  }

  v63 = v35->_ioSurfaceStartSharedEvent;
  objc_msgSend(MEMORY[0x1E0CFDFA8], "waitEventWithValue:sharedEvent:eventType:", 1, v63, 2);
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v80, "addObject:", v64);
  objc_msgSend(MEMORY[0x1E0CFDFA0], "signalEventWithValue:symbolIndex:eventType:sharedEvent:", v79, 0, 0, *(_QWORD *)(a1 + 248));
  v65 = (void *)objc_claimAutoreleasedReturnValue();
  v66 = v65;
  if (*(_BYTE *)(a1 + 112))
    objc_msgSend(v65, "setAgentMask:", 6);
  v67 = (void *)MEMORY[0x1E0CFDF98];
  v85[0] = v66;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v85, 1);
  v68 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v67, "sharedEventsWithSignalEvents:waitEvents:", v68, v80);
  v69 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0CFDF90], "requestWithInputs:inputIndices:outputs:outputIndices:weightsBuffer:perfStats:procedureIndex:sharedEvents:", v77, *(_QWORD *)(a1 + 688), v78, *(_QWORD *)(a1 + 696), 0, 0, &unk_1E0E98758, v69);
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 16) + 56));

  v81[0] = MEMORY[0x1E0C809B0];
  v81[1] = 3221225472;
  v81[2] = ___ZN3GPU22ANERegionCallOpHandler34encodeAsynchronousWithSharedEventsEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7__block_invoke;
  v81[3] = &__block_descriptor_48_e20_v20__0B8__NSError_12l;
  v81[4] = a1;
  v81[5] = WeakRetained;
  objc_msgSend(v70, "setCompletionHandler:", v81);
  objc_msgSend(v76, "encodeWaitForEvent:value:", *(_QWORD *)(a1 + 256), v79);
  v72 = (void *)objc_msgSend(*(id *)(a1 + 88), "mutableCopy");
  objc_msgSend(v72, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], *MEMORY[0x1E0CFDFD8]);

}

void sub_180E26044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  void *v17;
  void *v18;
  va_list va;

  va_start(va, a17);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,MPSGraphTensorData * {__strong}>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void ___ZN3GPU22ANERegionCallOpHandler34encodeAsynchronousWithSharedEventsEPNS_16EncodeDescriptorEP7NSArrayIP19_ANEIOSurfaceObjectES7__block_invoke(uint64_t a1, GPU::_anonymous_namespace_ *a2, void *a3)
{
  id v5;
  uint64_t v6;
  id v7;

  v5 = a3;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = v5;
  objc_msgSend(*(id *)(v6 + 72), "programHandle");
  kdebug_trace();

}

void sub_180E2624C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void GPU::ANERegionCallOpHandler::encodeOpWithInputsAndOutputs(uint64_t a1, uint64_t a2, void *a3, void *a4, int a5, int a6)
{
  id v11;
  id v12;

  v12 = a3;
  v11 = a4;
  if (a5 == 2)
  {
    GPU::ANERegionCallOpHandler::encodeAsynchronousWithSharedEvents(a1, a2, v12, v11);
  }
  else if (a5 == 1)
  {
    GPU::ANERegionCallOpHandler::encodeAsynchronousWithIOFences(a1, a2, v12, v11, a6);
  }
  else
  {
    if (a5)
      llvm::llvm_unreachable_internal((llvm *)"Unknown encodeMode", "/Library/Caches/com.apple.xbs/Sources/MetalPerformanceShadersGraph/mpsgraph/MetalPerformanceShadersGraph/Runtimes/MPSRuntime/Operations/RegionOps/ANERegion.mm", (const char *)0x27A);
    GPU::ANERegionCallOpHandler::encodeSynchronous(a1, a2, v12, v11, a6);
  }

}

void sub_180E26338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void GPU::ANERegionCallOpHandler::encodeOp(GPU::ANERegionCallOpHandler *this, GPU::EncodeDescriptor *a2)
{
  id WeakRetained;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  id v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  unint64_t v19;
  uint64_t v20;
  void *v21;
  int v22;
  id *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  int v27;
  void *v28;
  uint64_t v29;
  void *v30;
  void *v31;
  uint64_t MPSDataType;
  void *v33;
  GPU *v34;
  MPSNDArrayDescriptor *v35;
  size_t v36;
  BOOL v37;
  void *v38;
  void *v39;
  uint64_t v40;
  id v41;
  void *v42;
  MPSGraphTensorData *v43;
  int v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  void *v48;
  GPU::EncodeDescriptor *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  void *memptr;

  WeakRetained = objc_loadWeakRetained((id *)(*((_QWORD *)this + 2) + 56));
  v5 = (void *)*((_QWORD *)this + 9);
  if (v5)
    objc_msgSend(v5, "programHandle");
  kdebug_trace();

  v6 = (void *)*((_QWORD *)a2 + 9);
  if (v6)
  {
    objc_msgSend(v6, "endEncoding");
    v7 = (void *)*((_QWORD *)a2 + 9);
    *((_QWORD *)a2 + 9) = 0;

  }
  v49 = a2;
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", objc_msgSend(*((id *)this + 86), "count"));
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = *((unsigned int *)this + 34);
  if ((_DWORD)v8)
  {
    v9 = (_QWORD *)*((_QWORD *)this + 16);
    v10 = 8 * v8;
    do
    {
      if (*v9 >= (unint64_t)*((unsigned int *)this + 70))
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      v11 = *((_QWORD *)this + 2);
      memptr = *(void **)(*((_QWORD *)this + 34) + 8 * *v9);
      v52 = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&memptr) + 2);
      v12 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v11 + 88), &v52);
      if (v12
        && (v51 = memptr,
            (v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v12 + 3, (uint64_t *)&v51)) != 0))
      {
        v14 = (id)v13[3];
      }
      else
      {
        v14 = 0;
      }
      objc_msgSend(MEMORY[0x1E0CFDF50], "objectWithIOSurface:", objc_msgSend(v14, "iosurface"));
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v15 && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      objc_msgSend(v50, "addObject:", v15);

      ++v9;
      v10 -= 8;
    }
    while (v10);
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", objc_msgSend(*((id *)this + 87), "count"));
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = *((unsigned int *)this + 46);
  if ((_DWORD)v16)
  {
    v17 = 0;
    v47 = *((_QWORD *)this + 22);
    for (i = 8 * v16; i; i -= 8)
    {
      v19 = *(_QWORD *)(v47 + 8 * v17);
      if (v19 >= *((unsigned int *)this + 82))
        __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
      v20 = *((_QWORD *)this + 40);
      objc_msgSend(*((id *)this + 88), "objectAtIndexedSubscript:", v17);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v22 = objc_msgSend(v21, "isEqual:", MEMORY[0x1E0C9AAB0]);

      (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t, _QWORD, uint64_t))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2), *(_QWORD *)(v20 + 88 * v19 + 8), *((_QWORD *)v49 + 1), 1, 0, 64);
      v23 = (id *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v23, "mpsndarray");
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      v25 = v24;
      v26 = *(_QWORD *)((_BYTE *)v24 + (int)*MEMORY[0x1E0CC7288]) & 0x3FLL;
      if (v26)
        v27 = 0;
      else
        v27 = v22;
      if (v27 == 1)
      {
        objc_msgSend(v23[13], "buffer");
        v28 = (void *)objc_claimAutoreleasedReturnValue();
        v29 = objc_msgSend(v28, "gpuAddress") & 0x3FFF;

        if (v29)
          goto LABEL_27;
      }
      else
      {

        if (v26)
        {
LABEL_27:
          v31 = (void *)MEMORY[0x1E0CC6FE0];
          MPSDataType = getMPSDataType(*(_QWORD **)(v20 + 88 * v19 + 24));
          getMPSShapeFromMLIR(*(uint64_t **)(v20 + 88 * v19 + 32), *(unsigned int *)(v20 + 88 * v19 + 40));
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v31, "descriptorWithDataType:shape:", MPSDataType, v33);
          v34 = (GPU *)objc_claimAutoreleasedReturnValue();

          *(_QWORD *)((char *)v34 + (int)*MEMORY[0x1E0CC72C8]) = *(_QWORD *)(v20 + 88 * v19 + 16);
          if (v22)
          {
            memptr = 0;
            v36 = GPU::calculateNDArrayAllocationSize(v34, v35);
            if (malloc_type_posix_memalign(&memptr, 0x4000uLL, v36, 0x2C806A27uLL))
              v37 = 1;
            else
              v37 = memptr == 0;
            if (v37 && MTLReportFailureTypeEnabled())
              MTLReportFailure();
            objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
            v38 = (void *)objc_claimAutoreleasedReturnValue();
            v39 = (void *)objc_msgSend(v38, "newBufferWithBytesNoCopy:length:options:deallocator:", memptr, v36, 0, &__block_literal_global_144);

            v40 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6F50]), "initWithBuffer:descriptor:", v39, v34);
          }
          else
          {
            v41 = objc_alloc(MEMORY[0x1E0CC6F50]);
            objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
            v39 = (void *)objc_claimAutoreleasedReturnValue();
            v40 = objc_msgSend(v41, "initWithDevice:descriptor:", v39, v34);
          }
          v42 = (void *)v40;

          v43 = -[MPSGraphTensorData initWithMPSNDArray:device:]([MPSGraphTensorData alloc], "initWithMPSNDArray:device:", v42, *(_QWORD *)(*((_QWORD *)this + 2) + 48));
          BaseRuntime::setTensorDataToDataMap(*((_QWORD *)this + 2), *(uint64_t **)(v20 + 88 * v19), v43);
          objc_msgSend(MEMORY[0x1E0CFDF50], "objectWithIOSurface:", -[MPSGraphTensorData iosurface](v43, "iosurface"));
          v30 = (void *)objc_claimAutoreleasedReturnValue();

          goto LABEL_35;
        }
      }
      objc_msgSend(MEMORY[0x1E0CFDF50], "objectWithIOSurface:", objc_msgSend(v23, "iosurface"));
      v30 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_35:
      if (!v30 && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      objc_msgSend(v48, "addObject:", v30);

      ++v17;
    }
  }
  if (*((_BYTE *)this + 115))
  {
    v44 = 2;
    v45 = (uint64_t)v49;
    v46 = v50;
  }
  else
  {
    v45 = (uint64_t)v49;
    v46 = v50;
    if (*((_BYTE *)this + 113))
    {
      v44 = 0;
    }
    else if (*((_BYTE *)this + 114))
    {
      v44 = 1;
    }
    else
    {
      v44 = 2;
    }
  }
  GPU::ANERegionCallOpHandler::encodeOpWithInputsAndOutputs((uint64_t)this, v45, v46, v48, v44, 0);

}

void sub_180E26928(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_180E2693C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E2694C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void sub_180E26960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_180E26A94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void ___ZN3GPU22ANERegionCallOpHandler8encodeOpEPNS_16EncodeDescriptorE_block_invoke(int a1, void *a2)
{
  free(a2);
}

uint64_t *llvm::StringMap<unsigned long long,llvm::MallocAllocator>::try_emplace<>(uint64_t a1, int8x16_t *a2, const unsigned __int8 *a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  _QWORD *buffer;
  void *v10;
  unsigned int v11;
  int v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;

  v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  v7 = (uint64_t *)(*(_QWORD *)a1 + 8 * v6);
  v8 = *v7;
  if (*v7 == -8)
  {
    --*(_DWORD *)(a1 + 16);
    buffer = llvm::allocate_buffer((size_t)(a3 + 17), (std::align_val_t)8uLL);
    v10 = buffer + 2;
    if (!a3)
      goto LABEL_5;
    goto LABEL_4;
  }
  if (v8)
  {
    while (!v8 || v8 == -8)
    {
      v17 = v7[1];
      ++v7;
      v8 = v17;
    }
    return v7;
  }
  buffer = llvm::allocate_buffer((size_t)(a3 + 17), (std::align_val_t)8uLL);
  v10 = buffer + 2;
  if (a3)
LABEL_4:
    memcpy(v10, a2, (size_t)a3);
LABEL_5:
  a3[(_QWORD)v10] = 0;
  *buffer = a3;
  buffer[1] = 0;
  *v7 = (uint64_t)buffer;
  v11 = *(_DWORD *)(a1 + 8);
  v12 = *(_DWORD *)(a1 + 12) + 1;
  *(_DWORD *)(a1 + 12) = v12;
  if (*(_DWORD *)(a1 + 16) + v12 > v11)
    __assert_rtn("try_emplace", "StringMap.h", 353, "NumItems + NumTombstones <= NumBuckets");
  v7 = (uint64_t *)(*(_QWORD *)a1 + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
  if (*v7)
    v13 = *v7 == -8;
  else
    v13 = 1;
  if (v13)
  {
    do
    {
      v15 = v7[1];
      ++v7;
      v14 = v15;
      if (v15)
        v16 = v14 == -8;
      else
        v16 = 1;
    }
    while (v16);
  }
  return v7;
}

uint64_t std::__uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,std::__always_false,GPU::ANERegionCallOpHandler::ResultInfo* std::uninitialized_move[abi:ne180100]<GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*>(GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*,GPU::ANERegionCallOpHandler::ResultInfo*)::{lambda(GPU::ANERegionCallOpHandler::ResultInfo*&&)#1}>(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;

  if (result != a2)
  {
    v5 = result;
    v6 = 0;
    do
    {
      v7 = v5 + v6;
      v8 = a3 + v6;
      v9 = *(_OWORD *)(v5 + v6 + 16);
      *(_OWORD *)v8 = *(_OWORD *)(v5 + v6);
      *(_OWORD *)(v8 + 16) = v9;
      *(_QWORD *)(v8 + 40) = 0x500000000;
      *(_QWORD *)(v8 + 32) = a3 + v6 + 48;
      result = a3 + v6 + 32;
      if (*(_DWORD *)(v5 + v6 + 40))
        result = llvm::SmallVectorImpl<llvm::SMLoc>::operator=(result, v7 + 32);
      v6 += 88;
    }
    while (v7 + 88 != a2);
  }
  return result;
}

void sub_180E26C88(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v4;
  _QWORD *v5;
  _QWORD *v6;

  v4 = *(void **)(v1 + v2 + 32);
  if ((void *)(v1 + v2 + 48) != v4)
    free(v4);
  __cxa_begin_catch(a1);
  if (v2)
  {
    v5 = (_QWORD *)(v1 + 48);
    do
    {
      v6 = (_QWORD *)*(v5 - 2);
      if (v5 != v6)
        free(v6);
      v5 += 11;
      v2 -= 88;
    }
    while (v2);
  }
  __cxa_rethrow();
}

void sub_180E26CE0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void _GLOBAL__sub_I_ANERegion_mm()
{
  void *v0;

  v0 = (void *)MEMORY[0x186DA1C20]();
  __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE4AB8], &GPU::ANERegionCallOpHandler::_intermediateBufferHandleMutex, &dword_18013D000);
  objc_autoreleasePoolPop(v0);
}

void sub_180E26DB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E26EE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E26F9C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E27AF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,uint64_t a26,char a27)
{
  void *v27;
  void *v28;
  void *v29;

  if (__p)
    operator delete(__p);

  ScopedMPSSignpost::~ScopedMPSSignpost((ScopedMPSSignpost *)&a27);
  _Unwind_Resume(a1);
}

void ScopedMPSSignpost::~ScopedMPSSignpost(ScopedMPSSignpost *this)
{
  kdebug_trace();
}

void sub_180E27D90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E27F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

BOOL validateLayout(MPSGraphTensor *a1, MPSGraphTensorNamedDataLayout a2, MPSGraphTensorNamedDataLayout *a3, int a4)
{
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  int v13;

  -[MPSGraphTensor shape](a1, "shape");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = objc_msgSend(v7, "count");

  if (a4 < 1)
    return 0;
  v9 = a4;
  while (1)
  {
    v10 = *a3++;
    if (v10 == a2)
      break;
    if (!--v9)
      return 0;
  }
  if (!v8)
    return 1;
  if (a2 >= MPSGraphTensorNamedDataLayoutNCDHW)
  {
    v13 = MTLReportFailureTypeEnabled();
    v12 = 0;
    if (v13)
    {
      MTLReportFailure();
      v12 = 0;
    }
  }
  else
  {
    v12 = qword_1812873F0[a2];
  }
  return v8 == v12;
}

void sub_180E28350(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *EmitterObjC::QuantizationGenericOpHandler<mlir::mps::QuantizeOp,true>::QuantizationGenericOpHandler(_QWORD *a1, id *a2, uint64_t a3)
{
  uint64_t v3;
  void *v4;
  uint64_t Input;
  uint64_t v8;
  uint64_t Filter;
  uint64_t Bias;
  _QWORD *FunctionType;
  char *MPSDataType;
  uint64_t Axis;
  uint64_t v14;
  void *v15;
  void **v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  void **v24;
  int v25;
  void **v26;
  void **v27;
  std::string *p_p;
  void *v29;
  uint64_t v30;
  id v31;
  uint64_t AttrData;
  uint64_t v34;
  _QWORD *v36;
  void *v37;
  char v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  std::string __p;
  __int16 v44;
  void *v45[2];
  const char *v46;
  uint64_t v47;
  __int16 v48;
  void *v49[2];
  char v50;

  a1[1] = a2;
  a1[2] = a3;
  *a1 = &off_1E0E14F30;
  v3 = *(_QWORD *)(a3 + 48);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v49[0] = *(void **)(v3 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
    if (v34 == 12 && *(_QWORD *)AttrData == 0x6E6175712E73706DLL && *(_DWORD *)(AttrData + 8) == 1702521204)
    {
      v48 = 1283;
      v45[0] = "classof on '";
      v46 = "mps.quantize";
      v47 = 12;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+((uint64_t *)v45, (uint64_t *)&__p, (uint64_t)v49);
      llvm::report_fatal_error((llvm::Twine *)v49, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  v8 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  FunctionType = (_QWORD *)mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v42);
  MPSDataType = (char *)getMPSDataType(FunctionType);
  EmitterObjC::emitMPSDataType(MPSDataType, (uint64_t)v49);
  Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v42);
  if ((Axis & 0xFF00000000) != 0)
    v14 = Axis;
  else
    v14 = 0;
  v15 = (void *)MEMORY[0x1E0CB3940];
  v16 = v45;
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(v45, a2, v8);
  if (SHIBYTE(v46) < 0)
    v16 = (void **)v45[0];
  v41 = Input;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v41;
  v17 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v41, (uint64_t)&std::piecewise_construct, &__p);
  v18 = v17 + 3;
  if (*((char *)v17 + 47) < 0)
    v18 = (_QWORD *)*v18;
  v40 = Filter;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v40;
  v19 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v40, (uint64_t)&std::piecewise_construct, &__p);
  v20 = v19 + 3;
  if (*((char *)v19 + 47) < 0)
    v20 = (_QWORD *)*v20;
  v36 = v18;
  v39 = Bias;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v39;
  v21 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v39, (uint64_t)&std::piecewise_construct, &__p);
  v22 = a1;
  v23 = v21 + 3;
  v24 = v16;
  if (*((char *)v21 + 47) < 0)
    v23 = (_QWORD *)*v23;
  v25 = v50;
  v26 = (void **)v49[0];
  v38 = 0;
  LOBYTE(v37) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v8, (uint64_t)&v37, &__p);
  v27 = v49;
  if (v25 < 0)
    v27 = v26;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v15, "stringWithFormat:", CFSTR("\n        MPSGraphTensor *%s = \n        [graph               %s:%s\n                    scaleTensor:%s\n                zeroPointTensor:%s\n                    dataType:%s\n                        axis:%d\n                        name:%s];\n        "),
    v24,
    "quantizeTensor",
    v36,
    v20,
    v23,
    v27,
    v14,
    p_p);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v38 & 0x80000000) == 0)
      goto LABEL_21;
LABEL_26:
    operator delete(v37);
    if ((SHIBYTE(v46) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_27;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v38 < 0)
    goto LABEL_26;
LABEL_21:
  if ((SHIBYTE(v46) & 0x80000000) == 0)
    goto LABEL_22;
LABEL_27:
  operator delete(v45[0]);
LABEL_22:
  objc_msgSend(a2[27], "stringByAppendingString:", v29);
  v30 = objc_claimAutoreleasedReturnValue();
  v31 = a2[27];
  a2[27] = (id)v30;

  if (v50 < 0)
    operator delete(v49[0]);
  return v22;
}

void sub_180E286D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  void *v42;
  uint64_t v43;

  if ((*(char *)(v43 - 113) & 0x80000000) == 0)
    _Unwind_Resume(a1);
  operator delete(*(void **)(v43 - 136));
  _Unwind_Resume(a1);
}

_QWORD *EmitterObjC::QuantizationGenericOpHandler<mlir::mps::DequantizeOp,false>::QuantizationGenericOpHandler(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  void *v4;
  uint64_t Input;
  uint64_t v8;
  uint64_t Filter;
  void *v10;
  uint64_t Bias;
  _QWORD *FunctionType;
  char *MPSDataType;
  int v14;
  uint64_t Axis;
  uint64_t v16;
  uint64_t SparseShape;
  void *v18;
  void **v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  int v28;
  void **v29;
  void **v30;
  std::string *v31;
  void *v32;
  void *v33;
  void *v34;
  void **v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  int v42;
  void **v43;
  void **v44;
  std::string *p_p;
  void *v46;
  uint64_t v47;
  void *v48;
  _QWORD *AttrData;
  uint64_t v51;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  void *v56;
  char v57;
  void *v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  std::string __p;
  __int16 v66;
  void *v67[2];
  const char *v68;
  uint64_t v69;
  __int16 v70;
  void *v71[2];
  char v72;

  a1[1] = a2;
  a1[2] = a3;
  *a1 = &off_1E0E14F48;
  v3 = *(_QWORD *)(a3 + 48);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v71[0] = *(void **)(v3 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v71);
    if (v51 == 14 && *AttrData == 0x757165642E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x657A69746E617571)
    {
      v70 = 1283;
      v67[0] = "classof on '";
      v68 = "mps.dequantize";
      v69 = 14;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"' failed due to the operation not being registered";
      v66 = 259;
      llvm::operator+((uint64_t *)v67, (uint64_t *)&__p, (uint64_t)v71);
      llvm::report_fatal_error((llvm::Twine *)v71, 1);
    }
LABEL_59:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
    goto LABEL_59;
  v64 = a3;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v64);
  v8 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v64);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v64);
  getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8));
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v55 = v10;
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v64);
  mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v64);
  FunctionType = (_QWORD *)mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v64);
  MPSDataType = (char *)getMPSDataType(FunctionType);
  v14 = (int)MPSDataType;
  EmitterObjC::emitMPSDataType(MPSDataType, (uint64_t)v71);
  Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v64);
  if ((Axis & 0xFF00000000) != 0)
    v16 = Axis;
  else
    v16 = 0;
  if ((v14 & 0xDFFFFFFF) == 4)
    **(_BYTE **)(a2 + 312) = 1;
  if ((unint64_t)objc_msgSend(v10, "count") < 2)
  {
    v54 = v16;
    v34 = (void *)MEMORY[0x1E0CB3940];
    v35 = v67;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(v67, a2, v8);
    if (SHIBYTE(v68) < 0)
      v35 = (void **)v67[0];
    v63 = Input;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v63;
    v36 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v63, (uint64_t)&std::piecewise_construct, &__p);
    v37 = v36 + 3;
    if (*((char *)v36 + 47) < 0)
      v37 = (_QWORD *)*v37;
    v62 = Filter;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v62;
    v38 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v62, (uint64_t)&std::piecewise_construct, &__p);
    v39 = v38 + 3;
    if (*((char *)v38 + 47) < 0)
      v39 = (_QWORD *)*v39;
    v61 = Bias;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v61;
    v40 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v61, (uint64_t)&std::piecewise_construct, &__p);
    v41 = v40 + 3;
    if (*((char *)v40 + 47) < 0)
      v41 = (_QWORD *)*v41;
    v42 = v72;
    v43 = (void **)v71[0];
    v57 = 0;
    LOBYTE(v56) = 0;
    EmitObjC::emitTensorName(a2, v8, (uint64_t)&v56, &__p);
    v44 = v71;
    if (v42 < 0)
      v44 = v43;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    objc_msgSend(v34, "stringWithFormat:", CFSTR("\n            MPSGraphTensor *%s = \n            [graph               %s:%s\n                        scaleTensor:%s\n                    zeroPointTensor:%s\n                        dataType:%s\n                            axis:%d\n                            name:%s];\n            "),
      v35,
      "dequantizeTensor",
      v37,
      v39,
      v41,
      v44,
      v54,
      p_p);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v33 = v55;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v57 & 0x80000000) == 0)
        goto LABEL_47;
    }
    else if ((v57 & 0x80000000) == 0)
    {
      goto LABEL_47;
    }
    v46 = v56;
  }
  else
  {
    v53 = v8;
    SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v64);
    v18 = (void *)MEMORY[0x1E0CB3940];
    v19 = v67;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(v67, a2, v53);
    if (SHIBYTE(v68) < 0)
      v19 = (void **)v67[0];
    v63 = Input;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v63;
    v20 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v63, (uint64_t)&std::piecewise_construct, &__p);
    v21 = v20 + 3;
    if (*((char *)v20 + 47) < 0)
      v21 = (_QWORD *)*v21;
    v62 = Filter;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v62;
    v22 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v62, (uint64_t)&std::piecewise_construct, &__p);
    v23 = v22 + 3;
    if (*((char *)v22 + 47) < 0)
      v23 = (_QWORD *)*v23;
    v61 = Bias;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v61;
    v24 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v61, (uint64_t)&std::piecewise_construct, &__p);
    v25 = v24 + 3;
    if (*((char *)v24 + 47) < 0)
      v25 = (_QWORD *)*v25;
    v60 = SparseShape;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v60;
    v26 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a2 + 256, &v60, (uint64_t)&std::piecewise_construct, &__p);
    v27 = v26 + 3;
    if (*((char *)v26 + 47) < 0)
      v27 = (_QWORD *)*v27;
    v28 = v72;
    v29 = (void **)v71[0];
    v59 = 0;
    LOBYTE(v58) = 0;
    EmitObjC::emitTensorName(a2, v53, (uint64_t)&v58, &__p);
    v30 = v71;
    if (v28 < 0)
      v30 = v29;
    v31 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v31 = (std::string *)__p.__r_.__value_.__r.__words[0];
    objc_msgSend(v18, "stringWithFormat:", CFSTR("\n            MPSGraphTensor *%s = \n            [graph               %s:%s\n                        scaleTensor:%s\n                    zeroPointTensor:%s\n                        minTensor:%s\n                        dataType:%s\n                            name:%s];\n            "),
      v19,
      "dequantizeTensor",
      v21,
      v23,
      v25,
      v27,
      v30,
      v31);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v33 = v55;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v59 & 0x80000000) == 0)
        goto LABEL_47;
    }
    else if ((v59 & 0x80000000) == 0)
    {
      goto LABEL_47;
    }
    v46 = v58;
  }
  operator delete(v46);
LABEL_47:
  if (SHIBYTE(v68) < 0)
    operator delete(v67[0]);
  objc_msgSend(*(id *)(a2 + 216), "stringByAppendingString:", v32);
  v47 = objc_claimAutoreleasedReturnValue();
  v48 = *(void **)(a2 + 216);
  *(_QWORD *)(a2 + 216) = v47;

  if (v72 < 0)
    operator delete(v71[0]);

  return a1;
}

void sub_180E28D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  uint64_t v41;

  if (a41 < 0)
    operator delete(__p);
  if (a24 < 0)
    operator delete(a19);
  if (*(char *)(v41 - 153) < 0)
  {
    operator delete(*(void **)(v41 - 176));
    if ((*(char *)(v41 - 113) & 0x80000000) == 0)
      goto LABEL_7;
  }
  else if ((*(char *)(v41 - 113) & 0x80000000) == 0)
  {
LABEL_7:

    _Unwind_Resume(a1);
  }
  operator delete(*(void **)(v41 - 136));

  _Unwind_Resume(a1);
}

void sub_180E28E14()
{
  uint64_t v0;

  if (*(char *)(v0 - 113) < 0)
    JUMPOUT(0x180E28DF4);
  JUMPOUT(0x180E28DDCLL);
}

void sub_180E28E24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{

  _Unwind_Resume(a1);
}

void sub_180E28E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{

  _Unwind_Resume(a1);
}

void sub_180E28E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{

  _Unwind_Resume(a1);
}

void sub_180E28E60()
{
  void *v0;
  uint64_t v1;

  if (*(char *)(v1 - 113) < 0)
    JUMPOUT(0x180E28DF4);
  JUMPOUT(0x180E28DDCLL);
}

void sub_180E28E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{

  _Unwind_Resume(a1);
}

void EmitObjC::emitTensorName(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  _QWORD *v6;
  const std::string::value_type *v7;
  const std::string::value_type *v8;
  const std::string::value_type *v9;
  int v10;
  const std::string::value_type *v11;
  std::string::size_type v12;
  std::string *v13;
  __int128 v14;
  int v15;
  const std::string::value_type *v16;
  std::string::size_type v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  std::string::value_type __s[8];
  char v22;
  uint64_t v23;
  std::string v24;
  std::string v25;
  std::string v26;

  *((_BYTE *)&v24.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&v24, "@\"");
  v23 = a2;
  *(_QWORD *)__s = &v23;
  v6 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(a1 + 256, &v23, (uint64_t)&std::piecewise_construct, (_QWORD **)__s);
  v9 = (const std::string::value_type *)v6[3];
  v7 = (const std::string::value_type *)(v6 + 3);
  v8 = v9;
  v10 = v7[23];
  if (v10 >= 0)
    v11 = v7;
  else
    v11 = v8;
  if (v10 >= 0)
    v12 = *((unsigned __int8 *)v7 + 23);
  else
    v12 = *((_QWORD *)v7 + 1);
  v13 = std::string::append(&v24, v11, v12);
  v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = *(char *)(a3 + 23);
  if (v15 >= 0)
    v16 = (const std::string::value_type *)a3;
  else
    v16 = *(const std::string::value_type **)a3;
  if (v15 >= 0)
    v17 = *(unsigned __int8 *)(a3 + 23);
  else
    v17 = *(_QWORD *)(a3 + 8);
  v18 = std::string::append(&v25, v16, v17);
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  v22 = 1;
  strcpy(__s, "\"");
  v20 = std::string::append(&v26, __s, 1uLL);
  *a4 = *v20;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (v22 < 0)
  {
    operator delete(*(void **)__s);
    if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_15:
      if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_16;
      goto LABEL_20;
    }
  }
  else if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_15;
  }
  operator delete(v26.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_16:
    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
LABEL_21:
    operator delete(v24.__r_.__value_.__l.__data_);
    return;
  }
LABEL_20:
  operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_21;
}

void sub_180E29004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((*(char *)(v28 - 25) & 0x80000000) == 0)
    {
LABEL_3:
      if ((a28 & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  else if ((*(char *)(v28 - 25) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v28 - 48));
  if ((a28 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a22 & 0x80000000) == 0)
      goto LABEL_5;
    goto LABEL_9;
  }
LABEL_8:
  operator delete(a23);
  if ((a22 & 0x80000000) == 0)
LABEL_5:
    _Unwind_Resume(exception_object);
LABEL_9:
  operator delete(a17);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  _QWORD **v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  float v18;
  float v19;
  uint64_t v20;
  _QWORD *v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  size_t prime;
  unint64_t v26;
  uint8x8_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;

  v7 = *a2;
  v8 = HIDWORD(*a2);
  v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11)
        v4 = v10 % v11;
    }
    else
    {
      v4 = v10 & (v11 - 1);
    }
    v13 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      v14 = *v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7)
                return v14;
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            v14 = (_QWORD *)*v14;
            if (!v14)
              goto LABEL_23;
          }
        }
        do
        {
          v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7)
              return v14;
          }
          else
          {
            if (v15 >= v11)
              v15 %= v11;
            if (v15 != v4)
              break;
          }
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  v17 = (_QWORD *)(a1 + 16);
  v14 = operator new(0x30uLL);
  *v14 = 0;
  v14[1] = v10;
  v14[2] = **a4;
  v14[3] = 0;
  v14[4] = 0;
  v14[5] = 0;
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (v11 && (float)(v19 * (float)v11) >= v18)
  {
    v20 = *(_QWORD *)a1;
    v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v21)
    {
LABEL_26:
      *v14 = *v21;
LABEL_61:
      *v21 = v14;
      goto LABEL_62;
    }
  }
  else
  {
    v22 = 1;
    if (v11 >= 3)
      v22 = (v11 & (v11 - 1)) != 0;
    v23 = v22 | (2 * v11);
    v24 = vcvtps_u32_f32(v18 / v19);
    if (v23 <= v24)
      prime = v24;
    else
      prime = v23;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v11 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v11)
      goto LABEL_37;
    if (prime < v11)
    {
      v26 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (v27 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        v26 = std::__next_prime(v26);
      }
      else
      {
        v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2)
          v26 = v28;
      }
      if (prime <= v26)
        prime = v26;
      if (prime < v11)
LABEL_37:
        std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>(a1, prime);
    }
    v11 = *(_QWORD *)(a1 + 8);
    v29 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        v4 = v10 % v11;
        v20 = *(_QWORD *)a1;
        v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v10 % v11));
        if (v21)
          goto LABEL_26;
      }
      else
      {
        v4 = v10;
        v20 = *(_QWORD *)a1;
        v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v10);
        if (v21)
          goto LABEL_26;
      }
    }
    else
    {
      v4 = v29 & v10;
      v20 = *(_QWORD *)a1;
      v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * (v29 & v10));
      if (v21)
        goto LABEL_26;
    }
  }
  *v14 = *v17;
  *v17 = v14;
  *(_QWORD *)(v20 + 8 * v4) = v17;
  if (*v14)
  {
    v30 = *(_QWORD *)(*v14 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v30 >= v11)
        v30 %= v11;
    }
    else
    {
      v30 &= v11 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v30);
    goto LABEL_61;
  }
LABEL_62:
  ++*(_QWORD *)(a1 + 24);
  return v14;
}

void sub_180E293E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,std::string>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__hash_node<std::__hash_value_type<void *,std::string>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,std::string>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((_BYTE *)a1 + 16) && *(char *)(v2 + 47) < 0)
      operator delete(*(void **)(v2 + 24));
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t MILToMLIR::PoolingPattern::matchAndRewrite(MILToMLIR::PoolingPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  MILToMLIRRewriter *v3;
  const MIL::IROperation *v4;
  uint64_t LocationForOp;
  const void ***v6;
  const void ***v7;
  const void **v8;
  uint64_t *v9;
  const void **v10;
  char *v11;
  uint64_t *v12;
  __int128 v13;
  char *v14;
  char *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  _BYTE *v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  const void ***v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 *v39;
  uint64_t *v40;
  __int128 *v41;
  const void *v42;
  const void *v43;
  uint64_t v44;
  int v45;
  const void *v46;
  _BOOL4 v47;
  int v48;
  uint64_t *v49;
  const void *v50;
  __int128 *v51;
  unint64_t v52;
  unint64_t v53;
  const void *v54;
  unint64_t v55;
  const void *v56;
  int v57;
  _BOOL4 v58;
  uint64_t v59;
  uint64_t *v60;
  __int128 *v62;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v64;
  uint64_t v65;
  int v66;
  int v67;
  char *v68;
  uint64_t v69;
  __int128 *v70;
  uint64_t *v71;
  __int128 *v72;
  const void *v73;
  const void *v74;
  unint64_t v75;
  int v76;
  const void *v77;
  size_t v78;
  _BOOL4 v79;
  int v80;
  uint64_t *v81;
  const void *v82;
  __int128 *v83;
  unint64_t v84;
  int v85;
  unint64_t v86;
  const void *v87;
  const void *v88;
  size_t v89;
  _BOOL4 v90;
  int v91;
  _BOOL4 v92;
  uint64_t v93;
  uint64_t v94;
  void *v95;
  __int128 *v96;
  uint64_t ParameterValue;
  uint64_t Data;
  unint64_t v99;
  unint64_t v100;
  int v101;
  unint64_t v102;
  int *v103;
  uint64_t v104;
  uint64_t v105;
  __int128 *v106;
  uint64_t v107;
  uint64_t *v108;
  __int128 *v109;
  const void *v110;
  const void *v111;
  unint64_t v112;
  int v113;
  const void *v114;
  size_t v115;
  _BOOL4 v116;
  int v117;
  uint64_t *v118;
  const void *v119;
  __int128 *v120;
  unint64_t v121;
  int v122;
  unint64_t v123;
  const void *v124;
  const void *v125;
  size_t v126;
  _BOOL4 v127;
  int v128;
  _BOOL4 v129;
  int v130;
  uint64_t v131;
  unint64_t v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  char *v138;
  __int128 *v139;
  __int128 *v140;
  __int128 *v141;
  __int128 *v142;
  const void *v143;
  unint64_t v144;
  int v145;
  const void *v146;
  size_t v147;
  _BOOL4 v148;
  int v149;
  uint64_t *v150;
  const void *v151;
  __int128 *v152;
  unint64_t v153;
  int v154;
  unint64_t v155;
  const void *v156;
  const void *v157;
  size_t v158;
  _BOOL4 v159;
  int v160;
  _BOOL4 v161;
  __int128 *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  unint64_t v166;
  _OWORD *v167;
  int v168;
  unint64_t v169;
  int *v170;
  uint64_t v171;
  _BYTE *v172;
  int v173;
  int v174;
  unsigned int v175;
  BOOL v176;
  int v178;
  int v179;
  _OWORD *v183;
  uint64_t v184;
  __int128 *v185;
  uint64_t *v186;
  __int128 *v187;
  const void *v188;
  const void *v189;
  unint64_t v190;
  int v191;
  const void *v192;
  size_t v193;
  _BOOL4 v194;
  int v195;
  uint64_t *v196;
  const void *v197;
  __int128 *v198;
  unint64_t v199;
  int v200;
  unint64_t v201;
  const void *v202;
  const void *v203;
  size_t v204;
  _BOOL4 v205;
  int v206;
  _BOOL4 v207;
  uint64_t v208;
  void *v209;
  __int128 *v210;
  uint64_t v211;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  int v216;
  int *v217;
  uint64_t v218;
  _OWORD *v219;
  uint64_t v220;
  __int128 v221;
  uint64_t v222;
  __int128 *v223;
  __int128 *v224;
  __int128 *v225;
  const void *v226;
  const void *v227;
  unint64_t v228;
  int v229;
  const void *v230;
  size_t v231;
  _BOOL4 v232;
  int v233;
  __int128 *v234;
  const void *v235;
  __int128 *v236;
  unint64_t v237;
  int v238;
  unint64_t v239;
  const void *v240;
  const void *v241;
  size_t v242;
  _BOOL4 v243;
  int v244;
  _BOOL4 v245;
  __int128 *v246;
  uint64_t v247;
  _BYTE *v248;
  uint64_t v249;
  int64_t size;
  std::string *v251;
  char *v252;
  uint64_t v253;
  std::string *v254;
  _QWORD *v255;
  char *v256;
  int64_t v257;
  std::string *v258;
  char *v259;
  char *v260;
  uint64_t v261;
  __int128 *v262;
  uint64_t *v263;
  __int128 *v264;
  const void *v265;
  const void *v266;
  unint64_t v267;
  int v268;
  const void *v269;
  size_t v270;
  _BOOL4 v271;
  int v272;
  uint64_t *v273;
  const void *v274;
  __int128 *v275;
  unint64_t v276;
  int v277;
  unint64_t v278;
  const void *v279;
  const void *v280;
  size_t v281;
  _BOOL4 v282;
  int v283;
  _BOOL4 v284;
  BOOL v285;
  uint64_t v286;
  void **v287;
  void **v288;
  void *v289;
  uint64_t v290;
  void **v291;
  std::string *v292;
  char *v293;
  uint64_t v295;
  void **v296;
  int v297;
  uint64_t v298;
  unint64_t v299;
  __int128 v300;
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  _OWORD *v305;
  int v306;
  uint64_t v307;
  unint64_t v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  __int128 v313;
  _OWORD *v314;
  __int128 *v315;
  _OWORD *v316;
  uint64_t v317;
  _BYTE *v318;
  uint64_t v319;
  std::runtime_error *exception;
  std::runtime_error *v321;
  _OWORD *v322;
  unint64_t v323;
  int v324;
  _OWORD v325[2];
  mlir::Builder *v326;
  uint64_t v327;
  MILToMLIRRewriter *v328;
  const MIL::IROperation *v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  void *v333[3];
  __int16 v334;
  std::string v335;
  void *__p;
  __int128 v337;
  _QWORD v338[3];
  unsigned int v339;
  _BYTE v340[24];
  _BYTE __s1[24];
  char *__s2;
  __int128 v343;
  char *v344;
  __int128 v345;
  uint64_t v346[3];

  v3 = (MILToMLIRRewriter *)a3;
  v4 = a2;
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v346[0] = MILToMLIRRewriter::getArgValue((int8x8_t *)v3, v4, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)v4 + 192))(v4) != 1)
  {
    v344 = (char *)operator new(0x40uLL);
    v345 = xmmword_18125E6C0;
    strcpy(v344, "The number of outputs does not match the number of results.");
    v37 = MILToMLIRRewriter::notifyFailure((uint64_t)v3, (uint64_t)v4, (const std::string::value_type *)&v344);
    if (SHIBYTE(v345) < 0)
      operator delete(v344);
    return v37;
  }
  v327 = LocationForOp;
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)v4 + 160))(v4);
  v345 = 0uLL;
  v344 = (char *)&v345;
  v7 = v6 + 1;
  v8 = *v6;
  if (*v6 == (const void **)(v6 + 1))
    goto LABEL_87;
  v328 = v3;
  v329 = v4;
  v326 = (MILToMLIRRewriter *)((char *)v3 + 104);
  while (2)
  {
    v9 = std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__find_equal<std::string>((uint64_t **)&v344, (uint64_t *)&v345, (uint64_t **)&__s2, (uint64_t **)__s1, v8 + 4);
    if (*v9)
    {
      v10 = (const void **)v8[1];
      if (!v10)
        goto LABEL_45;
      goto LABEL_39;
    }
    v11 = (char *)operator new(0x50uLL);
    v12 = (uint64_t *)v11;
    if (*((char *)v8 + 55) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v11 + 32), (const std::string::value_type *)v8[4], (std::string::size_type)v8[5]);
    }
    else
    {
      v13 = *((_OWORD *)v8 + 2);
      *((_QWORD *)v11 + 6) = v8[6];
      *((_OWORD *)v11 + 2) = v13;
    }
    v12[7] = 0;
    v12[8] = 0;
    v12[9] = 0;
    v14 = (char *)v8[7];
    v15 = (char *)v8[8];
    v16 = v15 - v14;
    if (v15 != v14)
    {
      if (v16 < 0)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      v17 = operator new(v15 - v14);
      v12[7] = (uint64_t)v17;
      v12[8] = (uint64_t)v17;
      v12[9] = (uint64_t)&v17[2 * (v16 >> 4)];
      do
      {
        *v17 = *(_QWORD *)v14;
        v18 = *((_QWORD *)v14 + 1);
        v17[1] = v18;
        if (v18)
        {
          v19 = (unint64_t *)(v18 + 8);
          do
            v20 = __ldxr(v19);
          while (__stxr(v20 + 1, v19));
        }
        v14 += 16;
        v17 += 2;
      }
      while (v14 != v15);
      v12[8] = (uint64_t)v17;
    }
    v21 = __s2;
    *v12 = 0;
    v12[1] = 0;
    v12[2] = (uint64_t)v21;
    *v9 = (uint64_t)v12;
    if (*(_QWORD *)v344)
    {
      v344 = *(char **)v344;
      v12 = (uint64_t *)*v9;
    }
    v22 = (uint64_t *)v345;
    *((_BYTE *)v12 + 24) = v12 == (uint64_t *)v345;
    if (v12 == v22)
    {
LABEL_38:
      ++*((_QWORD *)&v345 + 1);
      v10 = (const void **)v8[1];
      if (!v10)
        goto LABEL_45;
      goto LABEL_39;
    }
    while (1)
    {
      v23 = v12[2];
      if (*(_BYTE *)(v23 + 24))
        goto LABEL_38;
      v24 = *(uint64_t **)(v23 + 16);
      v25 = *v24;
      if (*v24 != v23)
        break;
      v28 = v24[1];
      if (!v28 || (v29 = *(unsigned __int8 *)(v28 + 24), v26 = (_BYTE *)(v28 + 24), v29))
      {
        if (*(uint64_t **)v23 == v12)
        {
          *(_BYTE *)(v23 + 24) = 1;
          *((_BYTE *)v24 + 24) = 0;
          v32 = *(_QWORD *)(v23 + 8);
          *v24 = v32;
          if (v32)
            goto LABEL_36;
        }
        else
        {
          v30 = *(uint64_t **)(v23 + 8);
          v31 = *v30;
          *(_QWORD *)(v23 + 8) = *v30;
          if (v31)
          {
            *(_QWORD *)(v31 + 16) = v23;
            v24 = *(uint64_t **)(v23 + 16);
          }
          v30[2] = (uint64_t)v24;
          *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v30;
          *v30 = v23;
          *(_QWORD *)(v23 + 16) = v30;
          v24 = (uint64_t *)v30[2];
          v23 = *v24;
          *((_BYTE *)v30 + 24) = 1;
          *((_BYTE *)v24 + 24) = 0;
          v32 = *(_QWORD *)(v23 + 8);
          *v24 = v32;
          if (v32)
LABEL_36:
            *(_QWORD *)(v32 + 16) = v24;
        }
        *(_QWORD *)(v23 + 16) = v24[2];
        *(_QWORD *)(v24[2] + 8 * (*(_QWORD *)v24[2] != (_QWORD)v24)) = v23;
        *(_QWORD *)(v23 + 8) = v24;
        v24[2] = v23;
        goto LABEL_38;
      }
LABEL_24:
      *(_BYTE *)(v23 + 24) = 1;
      v12 = v24;
      *((_BYTE *)v24 + 24) = v24 == v22;
      *v26 = 1;
      if (v24 == v22)
        goto LABEL_38;
    }
    if (v25)
    {
      v27 = *(unsigned __int8 *)(v25 + 24);
      v26 = (_BYTE *)(v25 + 24);
      if (!v27)
        goto LABEL_24;
    }
    if (*(uint64_t **)v23 == v12)
    {
      v36 = v12[1];
      *(_QWORD *)v23 = v36;
      if (v36)
      {
        *(_QWORD *)(v36 + 16) = v23;
        v24 = *(uint64_t **)(v23 + 16);
      }
      v12[2] = (uint64_t)v24;
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v12;
      v12[1] = v23;
      *(_QWORD *)(v23 + 16) = v12;
      v24 = (uint64_t *)v12[2];
      *((_BYTE *)v12 + 24) = 1;
      *((_BYTE *)v24 + 24) = 0;
      v34 = (uint64_t *)v24[1];
      v35 = *v34;
      v24[1] = *v34;
      if (v35)
LABEL_43:
        *(_QWORD *)(v35 + 16) = v24;
    }
    else
    {
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v24 + 24) = 0;
      v34 = (uint64_t *)v24[1];
      v35 = *v34;
      v24[1] = *v34;
      if (v35)
        goto LABEL_43;
    }
    v34[2] = v24[2];
    *(_QWORD *)(v24[2] + 8 * (*(_QWORD *)v24[2] != (_QWORD)v24)) = v34;
    *v34 = (uint64_t)v24;
    v24[2] = (uint64_t)v34;
    ++*((_QWORD *)&v345 + 1);
    v10 = (const void **)v8[1];
    if (!v10)
    {
      do
      {
LABEL_45:
        v33 = (const void ***)v8[2];
        v176 = *v33 == v8;
        v8 = (const void **)v33;
      }
      while (!v176);
      goto LABEL_4;
    }
    do
    {
LABEL_39:
      v33 = (const void ***)v10;
      v10 = (const void **)*v10;
    }
    while (v10);
LABEL_4:
    v8 = (const void **)v33;
    if (v33 != v7)
      continue;
    break;
  }
  v38 = v345;
  HIBYTE(v343) = 1;
  LOWORD(__s2) = 120;
  v3 = v328;
  v4 = v329;
  if (!(_QWORD)v345)
    goto LABEL_87;
  v39 = &v345;
  do
  {
    v40 = (uint64_t *)v38;
    v41 = v39;
    v43 = (const void *)(v38 + 32);
    v42 = *(const void **)(v38 + 32);
    v44 = *(unsigned __int8 *)(v38 + 55);
    v45 = (char)v44;
    if ((v44 & 0x80u) != 0)
      v44 = v40[5];
    if (v45 >= 0)
      v46 = v43;
    else
      v46 = v42;
    v47 = v44 == 0;
    v48 = memcmp(v46, &__s2, v44 != 0);
    if (v48)
      v47 = v48 < 0;
    if (v47)
      v49 = v40 + 1;
    else
      v49 = v40;
    if (v47)
      v39 = v41;
    else
      v39 = (__int128 *)v40;
    v38 = *v49;
  }
  while (v38);
  if (v39 == &v345)
    goto LABEL_87;
  v50 = v41 + 2;
  if (v47)
    v51 = v41;
  else
    v51 = (__int128 *)v40;
  if (!v47)
    v50 = v43;
  v52 = *((unsigned __int8 *)v39 + 55);
  v54 = (const void *)*((_QWORD *)v51 + 4);
  v53 = *((_QWORD *)v51 + 5);
  if ((v52 & 0x80u) == 0)
    v55 = v52;
  else
    v55 = v53;
  if ((v52 & 0x80u) == 0)
    v56 = v50;
  else
    v56 = v54;
  v57 = memcmp(&__s2, v56, v55 != 0);
  v58 = v55 > 1;
  if (v57)
    v58 = v57 < 0;
  if (v58)
  {
LABEL_87:
    __s2 = (char *)operator new(0x28uLL);
    v343 = xmmword_181261450;
    strcpy(__s2, "Could not find parameter with name 'x'.");
    v59 = MILToMLIRRewriter::notifyFailure((uint64_t)v3, (uint64_t)v4, (const std::string::value_type *)&__s2);
    goto LABEL_88;
  }
  if (v47)
    v62 = v41;
  else
    v62 = (__int128 *)v40;
  if (*((_QWORD *)v62 + 8) - *((_QWORD *)v62 + 7) == 16)
  {
    HIBYTE(v343) = 1;
    LOWORD(__s2) = 120;
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
    if (SHIBYTE(v343) < 0)
      operator delete(__s2);
    v64 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
    v65 = MIL::IRTensorValueType::Rank(v64);
    v66 = v65;
    if (v65 <= 2)
    {
      __s2 = (char *)operator new(0x20uLL);
      v343 = xmmword_181261470;
      strcpy(__s2, "Unexpectedly small rank for 'x'");
      v59 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, (const std::string::value_type *)&__s2);
      goto LABEL_88;
    }
    v67 = v65 - 3;
    if ((unint64_t)(v65 - 3) < 3)
    {
      v68 = (char *)operator new(0x20uLL);
      *(_QWORD *)&v343 = v68 + 32;
      *((_QWORD *)&v343 + 1) = v68 + 32;
      v325[0] = unk_1812875C0;
      v325[1] = xmmword_1812875B0;
      *(_OWORD *)v68 = xmmword_1812875B0;
      *((_OWORD *)v68 + 1) = unk_1812875C0;
      __s2 = v68;
      __s1[23] = 12;
      strcpy(__s1, "kernel_sizes");
      v69 = v345;
      if (!(_QWORD)v345)
        goto LABEL_139;
      v324 = v67 + 1;
      v70 = &v345;
      do
      {
        v71 = (uint64_t *)v69;
        v72 = v70;
        v74 = (const void *)(v69 + 32);
        v73 = *(const void **)(v69 + 32);
        v75 = *(unsigned __int8 *)(v69 + 55);
        v76 = (char)v75;
        if ((v75 & 0x80u) != 0)
          v75 = v71[5];
        if (v76 >= 0)
          v77 = v74;
        else
          v77 = v73;
        if (v75 >= 0xC)
          v78 = 12;
        else
          v78 = v75;
        v79 = v75 < 0xC;
        v80 = memcmp(v77, __s1, v78);
        if (v80)
          v79 = v80 < 0;
        if (v79)
          v81 = v71 + 1;
        else
          v81 = v71;
        if (v79)
          v70 = v72;
        else
          v70 = (__int128 *)v71;
        v69 = *v81;
      }
      while (v69);
      if (v70 == &v345)
        goto LABEL_139;
      v82 = v72 + 2;
      if (v79)
        v83 = v72;
      else
        v83 = (__int128 *)v71;
      if (!v79)
        v82 = v74;
      v84 = *((unsigned __int8 *)v70 + 55);
      v85 = (char)v84;
      v87 = (const void *)*((_QWORD *)v83 + 4);
      v86 = *((_QWORD *)v83 + 5);
      if ((v84 & 0x80u) != 0)
        v84 = v86;
      if (v85 >= 0)
        v88 = v82;
      else
        v88 = v87;
      if (v84 >= 0xC)
        v89 = 12;
      else
        v89 = v84;
      v90 = v84 > 0xC;
      v91 = memcmp(__s1, v88, v89);
      v92 = v91 < 0;
      if (!v91)
        v92 = v90;
      if (v92)
      {
LABEL_139:
        v93 = (uint64_t)v328;
        goto LABEL_140;
      }
      if (v79)
        v96 = v72;
      else
        v96 = (__int128 *)v71;
      v93 = (uint64_t)v328;
      if (*((_QWORD *)v96 + 8) - *((_QWORD *)v96 + 7) != 16)
      {
LABEL_140:
        *(_QWORD *)__s1 = operator new(0x40uLL);
        *(_OWORD *)&__s1[8] = xmmword_181287560;
        strcpy(*(char **)__s1, "required parameter \"kernel_sizes\" not found for pooling layer.");
        v94 = MILToMLIRRewriter::notifyFailure(v93, (uint64_t)v329, __s1);
        goto LABEL_141;
      }
      __s1[23] = 12;
      strcpy(__s1, "kernel_sizes");
      ParameterValue = MIL::IROperation::GetParameterValue();
      if ((__s1[23] & 0x80000000) != 0)
        operator delete(*(void **)__s1);
      (*(void (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
      Data = MIL::IRTensorValue::GetDataView<int>();
      if (v99 == v324)
      {
        if (v99 < 8)
        {
          v100 = 0;
          goto LABEL_155;
        }
        v100 = 0;
        v130 = 3 - v67;
        if (3 - v67 + (int)v99 - 1 < 3 - v67)
          goto LABEL_155;
        if ((v99 - 1) >> 32)
          goto LABEL_155;
        v100 = v99 & 0xFFFFFFFFFFFFFFF8;
        v131 = Data + 16;
        v132 = v99 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          v133 = *(_OWORD *)(v131 - 16);
          *(_QWORD *)&v134 = (int)v133;
          *((_QWORD *)&v134 + 1) = SDWORD1(v133);
          v135 = v134;
          *(_QWORD *)&v134 = SDWORD2(v133);
          *((_QWORD *)&v134 + 1) = SHIDWORD(v133);
          v136 = v134;
          *(_QWORD *)&v134 = (int)*(_OWORD *)v131;
          *((_QWORD *)&v134 + 1) = (int)HIDWORD(*(_QWORD *)v131);
          v137 = v134;
          *(_QWORD *)&v134 = (int)*(_QWORD *)(v131 + 8);
          *((_QWORD *)&v134 + 1) = (int)HIDWORD(*(_OWORD *)v131);
          v138 = &v68[8 * v130];
          *(_OWORD *)v138 = v135;
          *((_OWORD *)v138 + 1) = v136;
          *((_OWORD *)v138 + 2) = v137;
          *((_OWORD *)v138 + 3) = v134;
          v131 += 32;
          v130 += 8;
          v132 -= 8;
        }
        while (v132);
        if (v99 != v100)
        {
LABEL_155:
          v101 = v100 - v66 + 6;
          v102 = v99 - v100;
          v103 = (int *)(Data + 4 * v100);
          do
          {
            v104 = *v103++;
            *(_QWORD *)&v68[8 * v101++] = v104;
            --v102;
          }
          while (v102);
        }
        v323 = v99;
        __s1[23] = 8;
        strcpy(__s1, "pad_type");
        v105 = v345;
        if (!(_QWORD)v345)
          goto LABEL_193;
        v106 = &v345;
        v107 = v345;
        do
        {
          v108 = (uint64_t *)v107;
          v109 = v106;
          v111 = (const void *)(v107 + 32);
          v110 = *(const void **)(v107 + 32);
          v112 = *(unsigned __int8 *)(v107 + 55);
          v113 = (char)v112;
          if ((v112 & 0x80u) != 0)
            v112 = v108[5];
          if (v113 >= 0)
            v114 = v111;
          else
            v114 = v110;
          if (v112 >= 8)
            v115 = 8;
          else
            v115 = v112;
          v116 = v112 < 8;
          v117 = memcmp(v114, __s1, v115);
          if (v117)
            v116 = v117 < 0;
          if (v116)
            v118 = v108 + 1;
          else
            v118 = v108;
          if (v116)
            v106 = v109;
          else
            v106 = (__int128 *)v108;
          v107 = *v118;
        }
        while (v107);
        if (v106 == &v345)
          goto LABEL_193;
        v119 = v109 + 2;
        if (v116)
          v120 = v109;
        else
          v120 = (__int128 *)v108;
        if (!v116)
          v119 = v111;
        v121 = *((unsigned __int8 *)v106 + 55);
        v122 = (char)v121;
        v124 = (const void *)*((_QWORD *)v120 + 4);
        v123 = *((_QWORD *)v120 + 5);
        if ((v121 & 0x80u) != 0)
          v121 = v123;
        if (v122 >= 0)
          v125 = v119;
        else
          v125 = v124;
        if (v121 >= 8)
          v126 = 8;
        else
          v126 = v121;
        v127 = v121 > 8;
        v128 = memcmp(__s1, v125, v126);
        v129 = v128 < 0;
        if (!v128)
          v129 = v127;
        if (v129)
        {
LABEL_193:
          *(_QWORD *)__s1 = operator new(0x30uLL);
          *(_OWORD *)&__s1[8] = xmmword_181267470;
          strcpy(*(char **)__s1, "Could not find parameter with name 'pad_type'.");
          v94 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, __s1);
          goto LABEL_141;
        }
        if (v116)
          v139 = v109;
        else
          v139 = (__int128 *)v108;
        if (*((_QWORD *)v139 + 8) - *((_QWORD *)v139 + 7) == 16)
        {
          v322 = operator new(0x20uLL);
          *(_QWORD *)&__s1[8] = v322 + 2;
          *(_QWORD *)&__s1[16] = v322 + 2;
          *v322 = v325[1];
          v322[1] = v325[0];
          *(_QWORD *)__s1 = v322;
          v340[23] = 7;
          strcpy(v340, "strides");
          v140 = &v345;
          do
          {
            v141 = (__int128 *)v105;
            v142 = v140;
            v143 = (const void *)(v105 + 32);
            v144 = *(unsigned __int8 *)(v105 + 55);
            v145 = (char)v144;
            if ((v144 & 0x80u) != 0)
              v144 = *(_QWORD *)(v105 + 40);
            if (v145 >= 0)
              v146 = (const void *)(v105 + 32);
            else
              v146 = *(const void **)(v105 + 32);
            if (v144 >= 7)
              v147 = 7;
            else
              v147 = v144;
            v148 = v144 < 7;
            v149 = memcmp(v146, v340, v147);
            if (v149)
              v148 = v149 < 0;
            if (v148)
              v150 = (uint64_t *)(v105 + 8);
            else
              v150 = (uint64_t *)v105;
            if (v148)
              v140 = v142;
            else
              v140 = (__int128 *)v105;
            v105 = *v150;
          }
          while (*v150);
          if (v140 != &v345)
          {
            v151 = v142 + 2;
            if (v148)
              v152 = v142;
            else
              v152 = v141;
            if (!v148)
              v151 = v143;
            v153 = *((unsigned __int8 *)v140 + 55);
            v154 = (char)v153;
            v156 = (const void *)*((_QWORD *)v152 + 4);
            v155 = *((_QWORD *)v152 + 5);
            if ((v153 & 0x80u) != 0)
              v153 = v155;
            if (v154 >= 0)
              v157 = v151;
            else
              v157 = v156;
            if (v153 >= 7)
              v158 = 7;
            else
              v158 = v153;
            v159 = v153 > 7;
            v160 = memcmp(v340, v157, v158);
            v161 = v160 < 0;
            if (!v160)
              v161 = v159;
            if (!v161)
            {
              v162 = v148 ? v142 : v141;
              if (*((_QWORD *)v162 + 8) - *((_QWORD *)v162 + 7) == 16)
              {
                v340[23] = 7;
                strcpy(v340, "strides");
                v163 = MIL::IROperation::TryGetParameterValue();
                if ((v340[23] & 0x80000000) != 0)
                  operator delete(*(void **)v340);
                (*(void (**)(uint64_t))(*(_QWORD *)v163 + 40))(v163);
                v164 = MIL::IRTensorValue::GetDataView<int>();
                if (v165 == v323)
                {
                  if (v323 < 8)
                  {
                    v166 = 0;
                    goto LABEL_249;
                  }
                  v166 = 0;
                  v297 = 3 - v67;
                  if (3 - v67 + (int)v323 - 1 < 3 - v67)
                  {
LABEL_249:
                    v167 = v322;
                  }
                  else
                  {
                    v167 = v322;
                    if (!((v323 - 1) >> 32))
                    {
                      v166 = v323 & 0xFFFFFFFFFFFFFFF8;
                      v298 = v164 + 16;
                      v299 = v323 & 0xFFFFFFFFFFFFFFF8;
                      do
                      {
                        v300 = *(_OWORD *)(v298 - 16);
                        *(_QWORD *)&v301 = (int)v300;
                        *((_QWORD *)&v301 + 1) = SDWORD1(v300);
                        v302 = v301;
                        *(_QWORD *)&v301 = SDWORD2(v300);
                        *((_QWORD *)&v301 + 1) = SHIDWORD(v300);
                        v303 = v301;
                        *(_QWORD *)&v301 = (int)*(_OWORD *)v298;
                        *((_QWORD *)&v301 + 1) = (int)HIDWORD(*(_QWORD *)v298);
                        v304 = v301;
                        *(_QWORD *)&v301 = (int)*(_QWORD *)(v298 + 8);
                        *((_QWORD *)&v301 + 1) = (int)HIDWORD(*(_OWORD *)v298);
                        v305 = (_OWORD *)((char *)v322 + 8 * v297);
                        *v305 = v302;
                        v305[1] = v303;
                        v305[2] = v304;
                        v305[3] = v301;
                        v298 += 32;
                        v297 += 8;
                        v299 -= 8;
                      }
                      while (v299);
                      v167 = v322;
                      if (v323 == v166)
                        goto LABEL_252;
                    }
                  }
                  v168 = v166 - v66 + 6;
                  v169 = v323 - v166;
                  v170 = (int *)(v164 + 4 * v166);
                  do
                  {
                    v171 = *v170++;
                    *((_QWORD *)v167 + v168++) = v171;
                    --v169;
                  }
                  while (v169);
                  goto LABEL_252;
                }
                *(_QWORD *)v340 = operator new(0x40uLL);
                *(_OWORD *)&v340[8] = xmmword_181287550;
                strcpy(*(char **)v340, "Strides parameter size must equal the dimension of the input.");
                v37 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, v340);
LABEL_493:
                if ((v340[23] & 0x80000000) != 0)
                  operator delete(*(void **)v340);
                v95 = v322;
LABEL_143:
                operator delete(v95);
                goto LABEL_144;
              }
            }
          }
LABEL_252:
          v340[23] = 8;
          strcpy(v340, "pad_type");
          MIL::IROperation::TryGetParameterValue();
          if ((v340[23] & 0x80000000) != 0)
            operator delete(*(void **)v340);
          MIL::IRValue::GetScalar<std::string>();
          if ((v340[23] & 0x80000000) == 0)
          {
            v172 = v340;
            switch(v340[23])
            {
              case 4:
                v173 = *(_DWORD *)v340;
                goto LABEL_260;
              case 5:
                v176 = *(_DWORD *)v340 == 1768710518 && v340[4] == 100;
                if (!v176)
                  goto LABEL_519;
                goto LABEL_290;
              case 6:
                goto LABEL_273;
              case 0xA:
                if (*(_QWORD *)v340 != 0x776F6C5F656D6173 || *(unsigned __int16 *)&v340[8] != 29285)
                  goto LABEL_519;
                goto LABEL_284;
              default:
                goto LABEL_519;
            }
          }
          switch(*(_QWORD *)&v340[8])
          {
            case 4:
              v173 = **(_DWORD **)v340;
LABEL_260:
              if (v173 != 1701667187)
                goto LABEL_519;
              v174 = 0;
              v175 = 2;
              goto LABEL_291;
            case 5:
              if (**(_DWORD **)v340 != 1768710518 || *(_BYTE *)(*(_QWORD *)v340 + 4) != 100)
                goto LABEL_519;
LABEL_290:
              v174 = 0;
              v175 = 1;
              goto LABEL_291;
            case 6:
              v172 = *(_BYTE **)v340;
LABEL_273:
              v178 = *(_DWORD *)v172;
              v179 = *((unsigned __int16 *)v172 + 2);
              if (v178 != 1953723747 || v179 != 28015)
                goto LABEL_519;
              v339 = 0;
              v174 = 1;
              goto LABEL_292;
            case 0xALL:
              if (**(_QWORD **)v340 != 0x776F6C5F656D6173 || *(_WORD *)(*(_QWORD *)v340 + 8) != 29285)
                goto LABEL_519;
LABEL_284:
              v174 = 0;
              v175 = 4;
LABEL_291:
              v339 = v175;
LABEL_292:
              v183 = operator new(0x40uLL);
              v338[1] = v183 + 4;
              v338[2] = v183 + 4;
              *v183 = 0u;
              v183[1] = 0u;
              v183[2] = 0u;
              v183[3] = 0u;
              v338[0] = v183;
              if (!v174)
                goto LABEL_343;
              HIBYTE(v337) = 3;
              LODWORD(__p) = 6578544;
              v184 = v345;
              if (!(_QWORD)v345)
                goto LABEL_329;
              v185 = &v345;
              do
              {
                v186 = (uint64_t *)v184;
                v187 = v185;
                v189 = (const void *)(v184 + 32);
                v188 = *(const void **)(v184 + 32);
                v190 = *(unsigned __int8 *)(v184 + 55);
                v191 = (char)v190;
                if ((v190 & 0x80u) != 0)
                  v190 = v186[5];
                if (v191 >= 0)
                  v192 = v189;
                else
                  v192 = v188;
                if (v190 >= 3)
                  v193 = 3;
                else
                  v193 = v190;
                v194 = v190 < 3;
                v195 = memcmp(v192, &__p, v193);
                if (v195)
                  v194 = v195 < 0;
                if (v194)
                  v196 = v186 + 1;
                else
                  v196 = v186;
                if (v194)
                  v185 = v187;
                else
                  v185 = (__int128 *)v186;
                v184 = *v196;
              }
              while (v184);
              if (v185 == &v345)
                goto LABEL_329;
              v197 = v187 + 2;
              if (v194)
                v198 = v187;
              else
                v198 = (__int128 *)v186;
              if (!v194)
                v197 = v189;
              v199 = *((unsigned __int8 *)v185 + 55);
              v200 = (char)v199;
              v202 = (const void *)*((_QWORD *)v198 + 4);
              v201 = *((_QWORD *)v198 + 5);
              if ((v199 & 0x80u) != 0)
                v199 = v201;
              if (v200 >= 0)
                v203 = v197;
              else
                v203 = v202;
              if (v199 >= 3)
                v204 = 3;
              else
                v204 = v199;
              v205 = v199 > 3;
              v206 = memcmp(&__p, v203, v204);
              v207 = v206 < 0;
              if (!v206)
                v207 = v205;
              if (v207)
              {
LABEL_329:
                __p = operator new(0x30uLL);
                v337 = xmmword_1812674D0;
                strcpy((char *)__p, "Could not find parameter with name 'pad'.");
                v208 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, (const std::string::value_type *)&__p);
                goto LABEL_330;
              }
              if (v194)
                v210 = v187;
              else
                v210 = (__int128 *)v186;
              if (*((_QWORD *)v210 + 8) - *((_QWORD *)v210 + 7) != 16)
              {
                __p = operator new(0x28uLL);
                v337 = xmmword_181286A40;
                strcpy((char *)__p, "Unexpected argument size for 'pad'");
                v208 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, (const std::string::value_type *)&__p);
LABEL_330:
                v37 = v208;
                if ((SHIBYTE(v337) & 0x80000000) == 0)
                  goto LABEL_492;
                v209 = __p;
LABEL_491:
                operator delete(v209);
LABEL_492:
                operator delete(v183);
                goto LABEL_493;
              }
              HIBYTE(v337) = 3;
              LODWORD(__p) = 6578544;
              v211 = MIL::IROperation::TryGetParameterValue();
              if (SHIBYTE(v337) < 0)
                operator delete(__p);
              (*(void (**)(uint64_t))(*(_QWORD *)v211 + 40))(v211);
              v212 = MIL::IRTensorValue::GetDataView<int>();
              if (!v213)
                goto LABEL_343;
              if (v213 >= 8)
              {
                v214 = 0;
                v306 = 8 - 2 * v324;
                if (v306 + (int)v213 - 1 >= v306 && !((v213 - 1) >> 32))
                {
                  v214 = v213 & 0xFFFFFFFFFFFFFFF8;
                  v307 = v212 + 16;
                  v308 = v213 & 0xFFFFFFFFFFFFFFF8;
                  do
                  {
                    v309 = *(_OWORD *)(v307 - 16);
                    *(_QWORD *)&v310 = (int)v309;
                    *((_QWORD *)&v310 + 1) = SDWORD1(v309);
                    v311 = v310;
                    *(_QWORD *)&v310 = SDWORD2(v309);
                    *((_QWORD *)&v310 + 1) = SHIDWORD(v309);
                    v312 = v310;
                    *(_QWORD *)&v310 = (int)*(_OWORD *)v307;
                    *((_QWORD *)&v310 + 1) = (int)HIDWORD(*(_QWORD *)v307);
                    v313 = v310;
                    *(_QWORD *)&v310 = (int)*(_QWORD *)(v307 + 8);
                    *((_QWORD *)&v310 + 1) = (int)HIDWORD(*(_OWORD *)v307);
                    v314 = (_OWORD *)((char *)v183 + 8 * v306);
                    *v314 = v311;
                    v314[1] = v312;
                    v314[2] = v313;
                    v314[3] = v310;
                    v307 += 32;
                    v306 += 8;
                    v308 -= 8;
                  }
                  while (v308);
                  if (v213 == v214)
                  {
LABEL_343:
                    v219 = operator new(0x20uLL);
                    *(_QWORD *)&v337 = v219 + 2;
                    *((_QWORD *)&v337 + 1) = v219 + 2;
                    *v219 = v325[1];
                    v219[1] = v325[0];
                    __p = v219;
                    v220 = (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)v329 + 56))(v329);
                    if (*(char *)(v220 + 23) < 0)
                    {
                      std::string::__init_copy_ctor_external(&v335, *(const std::string::value_type **)v220, *(_QWORD *)(v220 + 8));
                    }
                    else
                    {
                      v221 = *(_OWORD *)v220;
                      v335.__r_.__value_.__r.__words[2] = *(_QWORD *)(v220 + 16);
                      *(_OWORD *)&v335.__r_.__value_.__l.__data_ = v221;
                    }
                    v334 = 0;
                    HIBYTE(v333[2]) = 9;
                    strcpy((char *)v333, "ceil_mode");
                    v222 = v345;
                    if ((_QWORD)v345)
                    {
                      v223 = &v345;
                      do
                      {
                        v224 = (__int128 *)v222;
                        v225 = v223;
                        v227 = (const void *)(v222 + 32);
                        v226 = *(const void **)(v222 + 32);
                        v228 = *(unsigned __int8 *)(v222 + 55);
                        v229 = (char)v228;
                        if ((v228 & 0x80u) != 0)
                          v228 = *((_QWORD *)v224 + 5);
                        if (v229 >= 0)
                          v230 = v227;
                        else
                          v230 = v226;
                        if (v228 >= 9)
                          v231 = 9;
                        else
                          v231 = v228;
                        v232 = v228 < 9;
                        v233 = memcmp(v230, v333, v231);
                        if (v233)
                          v232 = v233 < 0;
                        if (v232)
                          v234 = (__int128 *)((char *)v224 + 8);
                        else
                          v234 = v224;
                        if (v232)
                          v223 = v225;
                        else
                          v223 = v224;
                        v222 = *(_QWORD *)v234;
                      }
                      while (v222);
                      if (v223 != &v345)
                      {
                        v235 = v225 + 2;
                        if (v232)
                          v236 = v225;
                        else
                          v236 = v224;
                        if (!v232)
                          v235 = v227;
                        v237 = *((unsigned __int8 *)v223 + 55);
                        v238 = (char)v237;
                        v240 = (const void *)*((_QWORD *)v236 + 4);
                        v239 = *((_QWORD *)v236 + 5);
                        if ((v237 & 0x80u) != 0)
                          v237 = v239;
                        if (v238 >= 0)
                          v241 = v235;
                        else
                          v241 = v240;
                        if (v237 >= 9)
                          v242 = 9;
                        else
                          v242 = v237;
                        v243 = v237 > 9;
                        v244 = memcmp(v333, v241, v242);
                        v245 = v244 < 0;
                        if (!v244)
                          v245 = v243;
                        if (!v245)
                        {
                          v246 = v232 ? v225 : v224;
                          if (*((_QWORD *)v246 + 8) - *((_QWORD *)v246 + 7) == 16)
                          {
                            HIBYTE(v333[2]) = 9;
                            strcpy((char *)v333, "ceil_mode");
                            v247 = MIL::IROperation::TryGetParameterValue();
                            if (SHIBYTE(v333[2]) < 0)
                              operator delete(v333[0]);
                            (*(void (**)(uint64_t))(*(_QWORD *)v247 + 40))(v247);
                            v248 = (_BYTE *)MIL::IRTensorValue::GetDataView<BOOL>();
                            if (!v249)
                            {
                              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                              std::runtime_error::runtime_error(exception, "index out of bounds");
                              exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
                              __cxa_throw(exception, (struct type_info *)off_1E0DF5DB8, MEMORY[0x1E0DE42B0]);
                            }
                            LOBYTE(v334) = *v248;
                          }
                        }
                      }
                    }
                    if ((v335.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      size = HIBYTE(v335.__r_.__value_.__r.__words[2]);
                    else
                      size = v335.__r_.__value_.__l.__size_;
                    if ((v335.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v251 = &v335;
                    else
                      v251 = (std::string *)v335.__r_.__value_.__r.__words[0];
                    v252 = (char *)v251 + size;
                    if (size <= 7)
                      goto LABEL_463;
                    v253 = size;
                    v254 = v251;
                    while (1)
                    {
                      v255 = memchr(v254, 97, v253 - 7);
                      if (!v255)
                      {
LABEL_401:
                        v257 = size;
                        v258 = v251;
                        goto LABEL_402;
                      }
                      v256 = (char *)v255;
                      if (*v255 == 0x6C6F6F705F677661)
                        break;
                      v254 = (std::string *)((char *)v255 + 1);
                      v253 = v252 - (v256 + 1);
                      if (v253 < 8)
                        goto LABEL_401;
                    }
                    v257 = size;
                    v258 = v251;
                    if (v256 != v252)
                    {
                      v257 = size;
                      v258 = v251;
                      if (v256 - (char *)v251 != -1)
                      {
                        v260 = (char *)operator new(0x20uLL);
                        strcpy(v260, "exclude_padding_from_average");
                        qmemcpy(v325, "ing_from_averageexclude_padding_", sizeof(v325));
                        v261 = v345;
                        if (!(_QWORD)v345)
                          goto LABEL_444;
                        v262 = &v345;
                        do
                        {
                          v263 = (uint64_t *)v261;
                          v264 = v262;
                          v266 = (const void *)(v261 + 32);
                          v265 = *(const void **)(v261 + 32);
                          v267 = *(unsigned __int8 *)(v261 + 55);
                          v268 = (char)v267;
                          if ((v267 & 0x80u) != 0)
                            v267 = v263[5];
                          if (v268 >= 0)
                            v269 = v266;
                          else
                            v269 = v265;
                          if (v267 >= 0x1C)
                            v270 = 28;
                          else
                            v270 = v267;
                          v271 = v267 < 0x1C;
                          v272 = memcmp(v269, v260, v270);
                          if (v272)
                            v271 = v272 < 0;
                          if (v271)
                            v273 = v263 + 1;
                          else
                            v273 = v263;
                          if (v271)
                            v262 = v264;
                          else
                            v262 = (__int128 *)v263;
                          v261 = *v273;
                        }
                        while (v261);
                        if (v262 == &v345)
                          goto LABEL_444;
                        v274 = v264 + 2;
                        if (v271)
                          v275 = v264;
                        else
                          v275 = (__int128 *)v263;
                        if (!v271)
                          v274 = v266;
                        v276 = *((unsigned __int8 *)v262 + 55);
                        v277 = (char)v276;
                        v279 = (const void *)*((_QWORD *)v275 + 4);
                        v278 = *((_QWORD *)v275 + 5);
                        if ((v276 & 0x80u) != 0)
                          v276 = v278;
                        if (v277 >= 0)
                          v280 = v274;
                        else
                          v280 = v279;
                        if (v276 >= 0x1C)
                          v281 = 28;
                        else
                          v281 = v276;
                        v282 = v276 > 0x1C;
                        v283 = memcmp(v260, v280, v281);
                        v284 = v283 < 0;
                        if (!v283)
                          v284 = v282;
                        if (v284)
                        {
LABEL_444:
                          operator delete(v260);
                        }
                        else
                        {
                          operator delete(v260);
                          if (v271)
                            v315 = v264;
                          else
                            v315 = (__int128 *)v263;
                          if (*((_QWORD *)v315 + 8) - *((_QWORD *)v315 + 7) == 16)
                          {
                            v316 = operator new(0x20uLL);
                            v333[0] = v316;
                            *(_OWORD *)&v333[1] = xmmword_181268750;
                            *v316 = v325[1];
                            *(_OWORD *)((char *)v316 + 12) = v325[0];
                            *((_BYTE *)v316 + 28) = 0;
                            v317 = MIL::IROperation::TryGetParameterValue();
                            if (SHIBYTE(v333[2]) < 0)
                              operator delete(v333[0]);
                            (*(void (**)(uint64_t))(*(_QWORD *)v317 + 40))(v317);
                            v318 = (_BYTE *)MIL::IRTensorValue::GetDataView<BOOL>();
                            if (!v319)
                            {
                              v321 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                              std::runtime_error::runtime_error(v321, "index out of bounds");
                              v321->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
                              __cxa_throw(v321, (struct type_info *)off_1E0DF5DB8, MEMORY[0x1E0DE42B0]);
                            }
                            v285 = *v318 != 0;
                            goto LABEL_446;
                          }
                        }
                        v285 = 0;
LABEL_446:
                        HIBYTE(v334) = !v285;
                        v333[0] = (void *)MILToMLIR::vecToAttr(v326, &__s2);
                        v332 = MILToMLIR::vecToAttr(v326, __s1);
                        v331 = MILToMLIR::vecToAttr(v326, &__p);
                        v330 = MILToMLIR::vecToAttr(v326, v338);
                        v286 = mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>((mlir::UnitAttr **)v326, v327, v346, (uint64_t *)v333, &v332, &v331, &v339, &v330, (char *)&v334, (char *)&v334 + 1);
                        (*(void (**)(void **__return_ptr))(*(_QWORD *)v329 + 200))(v333);
                        if (!*(_DWORD *)(v286 + 36))
                          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                        MILToMLIRRewriter::setValue((uint64_t)v328, (__int128 *)v333[0], v286 - 16);
                        v287 = (void **)v333[0];
                        if (!v333[0])
                          goto LABEL_487;
                        v288 = (void **)v333[1];
                        v289 = v333[0];
                        if (v333[1] == v333[0])
                          goto LABEL_486;
                        do
                        {
                          if (*((char *)v288 - 1) < 0)
                            operator delete(*(v288 - 3));
                          v288 -= 3;
                        }
                        while (v288 != v287);
                        goto LABEL_485;
                      }
                    }
                    while (1)
                    {
LABEL_402:
                      v259 = (char *)memchr(v258, 109, v257 - 7);
                      if (!v259)
                        goto LABEL_463;
                      if (*(_QWORD *)v259 == 0x6C6F6F705F78616DLL)
                        break;
                      v258 = (std::string *)(v259 + 1);
                      v257 = v252 - (char *)v258;
                      if (v252 - (char *)v258 <= 7)
                        goto LABEL_463;
                    }
                    if (v259 == v252 || v259 - (char *)v251 == -1)
                    {
LABEL_463:
                      if (size < 7)
                        goto LABEL_481;
                      v292 = v251;
                      while (1)
                      {
                        v293 = (char *)memchr(v292, 108, size - 6);
                        if (!v293)
                          goto LABEL_481;
                        if (*(_DWORD *)v293 == 1885287020 && *(_DWORD *)(v293 + 3) == 1819242352)
                          break;
                        v292 = (std::string *)(v293 + 1);
                        size = v252 - (char *)v292;
                        if (v252 - (char *)v292 < 7)
                          goto LABEL_481;
                      }
                      if (v293 == v252 || v293 - (char *)v251 == -1)
                      {
LABEL_481:
                        v333[0] = operator new(0x20uLL);
                        *(_OWORD *)&v333[1] = xmmword_18125D370;
                        strcpy((char *)v333[0], "Unknown pooling type op.");
                        v37 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, (const std::string::value_type *)v333);
                        if (SHIBYTE(v333[2]) < 0)
                          operator delete(v333[0]);
                        goto LABEL_488;
                      }
                      v333[0] = (void *)MILToMLIR::vecToAttr(v326, &__s2);
                      v332 = MILToMLIR::vecToAttr(v326, __s1);
                      v331 = MILToMLIR::vecToAttr(v326, &__p);
                      v330 = MILToMLIR::vecToAttr(v326, v338);
                      v295 = mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>((mlir::UnitAttr **)v326, v327, v346, (uint64_t *)v333, &v332, &v331, &v339, &v330, (char *)&v334, (char *)&v334 + 1);
                      (*(void (**)(void **__return_ptr))(*(_QWORD *)v329 + 200))(v333);
                      if (!*(_DWORD *)(v295 + 36))
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      MILToMLIRRewriter::setValue((uint64_t)v328, (__int128 *)v333[0], v295 - 16);
                      v287 = (void **)v333[0];
                      if (!v333[0])
                      {
LABEL_487:
                        v37 = 1;
LABEL_488:
                        if (SHIBYTE(v335.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(v335.__r_.__value_.__l.__data_);
                        v209 = v219;
                        goto LABEL_491;
                      }
                      v296 = (void **)v333[1];
                      v289 = v333[0];
                      if (v333[1] == v333[0])
                      {
LABEL_486:
                        v333[1] = v287;
                        operator delete(v289);
                        goto LABEL_487;
                      }
                      do
                      {
                        if (*((char *)v296 - 1) < 0)
                          operator delete(*(v296 - 3));
                        v296 -= 3;
                      }
                      while (v296 != v287);
                    }
                    else
                    {
                      v333[0] = (void *)MILToMLIR::vecToAttr(v326, &__s2);
                      v332 = MILToMLIR::vecToAttr(v326, __s1);
                      v331 = MILToMLIR::vecToAttr(v326, &__p);
                      v330 = MILToMLIR::vecToAttr(v326, v338);
                      v290 = mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>((uint64_t *)v326, v327, v346, (uint64_t *)v333, &v332, &v331, &v339, &v330, (char *)&v334, (char *)&v334 + 1);
                      (*(void (**)(void **__return_ptr))(*(_QWORD *)v329 + 200))(v333);
                      if (!*(_DWORD *)(v290 + 36))
                        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                      MILToMLIRRewriter::setValue((uint64_t)v328, (__int128 *)v333[0], v290 - 16);
                      v287 = (void **)v333[0];
                      if (!v333[0])
                        goto LABEL_487;
                      v291 = (void **)v333[1];
                      v289 = v333[0];
                      if (v333[1] == v333[0])
                        goto LABEL_486;
                      do
                      {
                        if (*((char *)v291 - 1) < 0)
                          operator delete(*(v291 - 3));
                        v291 -= 3;
                      }
                      while (v291 != v287);
                    }
LABEL_485:
                    v289 = v333[0];
                    goto LABEL_486;
                  }
                }
              }
              else
              {
                v214 = 0;
              }
              v215 = v213 - v214;
              v216 = v214 - 2 * v66 + 12;
              v217 = (int *)(v212 + 4 * v214);
              do
              {
                v218 = *v217++;
                *((_QWORD *)v183 + v216++) = v218;
                --v215;
              }
              while (v215);
              goto LABEL_343;
            default:
LABEL_519:
              __assert_rtn("matchAndRewriteGenericPool", "MILToMLIRRewritePool.mm", 122, "0 && \"Unknown padding style\"");
          }
        }
        *(_QWORD *)__s1 = operator new(0x28uLL);
        *(_OWORD *)&__s1[8] = xmmword_181261450;
        strcpy(*(char **)__s1, "Unexpected argument size for 'pad_type'");
        v94 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, __s1);
      }
      else
      {
        *(_QWORD *)__s1 = operator new(0x48uLL);
        *(_OWORD *)&__s1[8] = xmmword_181287540;
        strcpy(*(char **)__s1, "kernel_sizes parameter size must equal the dimension of the input.");
        v94 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, __s1);
      }
LABEL_141:
      v37 = v94;
      if ((__s1[23] & 0x80000000) != 0)
      {
        v95 = *(void **)__s1;
        goto LABEL_143;
      }
LABEL_144:
      v60 = (uint64_t *)v68;
LABEL_90:
      operator delete(v60);
      goto LABEL_91;
    }
    __s2 = (char *)operator new(0x38uLL);
    v343 = xmmword_181287530;
    strcpy(__s2, "Pooling is only supported for inputs of rank 3, 4, or 5");
    v59 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, (const std::string::value_type *)&__s2);
  }
  else
  {
    __s2 = (char *)operator new(0x28uLL);
    v343 = xmmword_181261460;
    strcpy(__s2, "Unexpected argument size for 'x'");
    v59 = MILToMLIRRewriter::notifyFailure((uint64_t)v328, (uint64_t)v329, (const std::string::value_type *)&__s2);
  }
LABEL_88:
  v37 = v59;
  if (SHIBYTE(v343) < 0)
  {
    v60 = (uint64_t *)__s2;
    goto LABEL_90;
  }
LABEL_91:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v344, (char *)v345);
  return v37;
}

void sub_180E2AFD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  void *v46;
  void *v47;
  void *v48;
  uint64_t v49;
  void *v51;
  void *v52;

  __cxa_free_exception(v46);
  if (a39 < 0)
    operator delete(__p);
  operator delete(v48);
  operator delete(v47);
  if (*(char *)(v49 - 177) < 0)
  {
    operator delete(*(void **)(v49 - 200));
    v52 = *(void **)(v49 - 176);
    if (v52)
      goto LABEL_5;
  }
  else
  {
    v52 = *(void **)(v49 - 176);
    if (v52)
    {
LABEL_5:
      operator delete(v52);
      v51 = *(void **)(v49 - 152);
      if (!v51)
      {
LABEL_10:
        std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(v49 - 128, *(char **)(v49 - 120));
        _Unwind_Resume(a1);
      }
LABEL_9:
      operator delete(v51);
      goto LABEL_10;
    }
  }
  v51 = *(void **)(v49 - 152);
  if (!v51)
    goto LABEL_10;
  goto LABEL_9;
}

void MILToMLIR::PoolingPattern::~PoolingPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  uint64_t v22;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  _BYTE v33[40];
  _QWORD v34[39];

  v34[38] = *MEMORY[0x1E0C80C00];
  v28 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    v32 = 1283;
    v31[2] = (uint64_t)"mps.pooling_average";
    v31[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  mlir::mps::PoolAvgOp::build(a1, (uint64_t)v34, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v34);
  if (!v21)
  {
    v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v25 = 662;
    v26 = "Casting.h";
    v27 = "dyn_cast";
    goto LABEL_8;
  }
  v22 = llvm::DefaultDoCastIfPossible<mlir::mps::PoolAvgOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolAvgOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    v24 = "result && \"builder didn't return the right type\"";
    v25 = 497;
    v26 = "Builders.h";
    v27 = "create";
LABEL_8:
    __assert_rtn(v27, v26, v25, v24);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v22;
}

void sub_180E2B600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E2B618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::vecToAttr(mlir::Builder *a1, _QWORD *a2)
{
  uint64_t IntegerType;
  uint64_t v4;
  _QWORD *v5;
  uint64_t **v6;
  uint64_t InterfaceFor;
  const char *v8;
  int v9;
  const char *v10;
  const char *v11;
  uint64_t v12;

  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v4 = (uint64_t)(a2[1] - *a2) >> 3;
  v5 = operator new(8uLL);
  *v5 = v4;
  v6 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v5, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v6))
    goto LABEL_8;
  if (v6)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v6);
    if (!InterfaceFor)
    {
      v8 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v9 = 98;
      v10 = "InterfaceSupport.h";
      v11 = "Interface";
      goto LABEL_9;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v12 = mlir::DenseElementsAttr::getFromRawBuffer(v6, InterfaceFor, *a2, a2[1] - *a2, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v12) & 1) == 0)
  {
LABEL_8:
    v8 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v9 = 566;
    v10 = "Casting.h";
    v11 = "cast";
LABEL_9:
    __assert_rtn(v11, v10, v9, v8);
  }
  operator delete(v5);
  return v12;
}

void sub_180E2B728(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E2B73C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  uint64_t v22;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  _BYTE v33[40];
  _QWORD v34[39];

  v34[38] = *MEMORY[0x1E0C80C00];
  v28 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max", (const unsigned __int8 *)0xF, Context);
  if (!v20)
  {
    v32 = 1283;
    v31[2] = (uint64_t)"mps.pooling_max";
    v31[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  mlir::mps::PoolMaxOp::build(a1, (uint64_t)v34, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v34);
  if (!v21)
  {
    v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v25 = 662;
    v26 = "Casting.h";
    v27 = "dyn_cast";
    goto LABEL_8;
  }
  v22 = llvm::DefaultDoCastIfPossible<mlir::mps::PoolMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolMaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    v24 = "result && \"builder didn't return the right type\"";
    v25 = 497;
    v26 = "Builders.h";
    v27 = "create";
LABEL_8:
    __assert_rtn(v27, v26, v25, v24);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v22;
}

void sub_180E2B90C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E2B924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle &,mlir::DenseIntElementsAttr,BOOL &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  uint64_t v22;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  _BYTE v33[40];
  _QWORD v34[39];

  v34[38] = *MEMORY[0x1E0C80C00];
  v28 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    v32 = 1283;
    v31[2] = (uint64_t)"mps.pooling_l2_norm";
    v31[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v34, a2, v19);
  mlir::mps::PoolL2NormOp::build(a1, (uint64_t)v34, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v34);
  if (!v21)
  {
    v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v25 = 662;
    v26 = "Casting.h";
    v27 = "dyn_cast";
    goto LABEL_8;
  }
  v22 = llvm::DefaultDoCastIfPossible<mlir::mps::PoolL2NormOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolL2NormOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    v24 = "result && \"builder didn't return the right type\"";
    v25 = 497;
    v26 = "Builders.h";
    v27 = "create";
LABEL_8:
    __assert_rtn(v27, v26, v25, v24);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v34);
  return v22;
}

void sub_180E2BAF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E2BB0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PoolAvgOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolAvgOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 19
      && *AttrData == 0x6C6F6F702E73706DLL
      && AttrData[1] == 0x726576615F676E69
      && *(_QWORD *)((char *)AttrData + 11) == 0x656761726576615FLL)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.pooling_average";
      v9[3] = 19;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PoolMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolMaxOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x6C6F6F702E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x78616D5F676E696CLL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.pooling_max";
      v8[3] = 15;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PoolMaxOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PoolL2NormOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PoolL2NormOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 19
      && *AttrData == 0x6C6F6F702E73706DLL
      && AttrData[1] == 0x6E5F326C5F676E69
      && *(_QWORD *)((char *)AttrData + 11) == 0x6D726F6E5F326C5FLL)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.pooling_l2_norm";
      v9[3] = 19;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id)
  {
    return 0;
  }
  return result;
}

void GPU::StencilOpHandler::_createNDArrayMultiaryKernel(GPU::StencilOpHandler *this)
{
  uint64_t v1;
  void *v2;
  uint64_t Input;
  unint64_t StaticType;
  unint64_t v5;
  unint64_t v6;
  uint64_t Filter;
  unint64_t v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t NumElements;
  int v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  unsigned int v25;
  unsigned int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  id v47;
  void *v48;
  void *v49;
  unsigned int WeightsLayout;
  unsigned int PaddingStyle;
  double ValueAsDouble;
  uint64_t v53;
  uint64_t v54;
  int v55;
  BOOL v56;
  unsigned int v57;
  unsigned int v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t i;
  BOOL v63;
  _QWORD *AttrData;
  uint64_t v65;
  const char *v67;
  int v68;
  const char *v69;
  uint64_t v70;
  uint64_t Value;
  _OWORD v73[2];
  _OWORD v74[2];
  _OWORD v75[2];
  _QWORD *v76;
  unsigned int v77;
  _QWORD *v78;
  unsigned int v79;
  uint64_t v80;
  _QWORD *KernelSizes;
  unsigned __int8 v82;
  uint64_t v83;
  __int128 v84;
  __int128 v85;
  uint64_t ExplicitPadding;
  uint64_t v87;
  uint64_t FastmathAttr;
  uint64_t Strides;
  uint64_t Offsets;
  uint64_t v91;
  uint64_t v92;
  __int128 v93;
  __int128 v94;
  __int16 v95;
  __int128 v96;
  __int128 v97;
  __int16 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(_QWORD *)&v99 = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v99);
    if (v65 == 11 && *AttrData == 0x6E6574732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      v98 = 1283;
      *(_QWORD *)&v96 = "classof on '";
      *(_QWORD *)&v97 = "mps.stencil";
      *((_QWORD *)&v97 + 1) = 11;
      *(_QWORD *)&v93 = "' failed due to the operation not being registered";
      v95 = 259;
      llvm::operator+((uint64_t *)&v96, (uint64_t *)&v93, (uint64_t)&v99);
      llvm::report_fatal_error((llvm::Twine *)&v99, 1);
    }
LABEL_130:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
    goto LABEL_130;
  v92 = *((_QWORD *)this + 3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v92);
  StaticType = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Input);
  if (!*(_QWORD *)StaticType)
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  if (*(_UNKNOWN **)(*(_QWORD *)StaticType + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  *(_QWORD *)&v99 = StaticType;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v99);
  v6 = v5;
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v92);
  v8 = GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), Filter);
  if (!*(_QWORD *)v8)
    __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  *(_QWORD *)&v99 = v8;
  v9 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v99);
  v11 = v10;
  Offsets = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v92);
  v91 = v12;
  Strides = mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v92);
  FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v92);
  ExplicitPadding = mlir::mps::StencilOp::getExplicitPadding((mlir::mps::StencilOp *)&v92);
  v87 = v13;
  v96 = 0u;
  v97 = 0u;
  v93 = xmmword_1812875E0;
  v94 = unk_1812875F0;
  v84 = xmmword_1812875E0;
  v85 = unk_1812875F0;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, Strides, 0);
  v14 = Strides;
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&KernelSizes, v14, NumElements);
  v16 = 0;
  while (1)
  {
    v17 = (_QWORD *)v99 == KernelSizes && BYTE8(v99) == v82;
    if (v17 && (_QWORD)v100 == v83)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v99, (llvm::APInt *)&v78);
    if (v16 == 4)
    {
      if (MTLReportFailureTypeEnabled())
        MTLReportFailure();
    }
    v18 = v79;
    if (v79 < 0x41)
    {
      *((_QWORD *)&v93 + 3 - v16++) = v78;
      goto LABEL_9;
    }
    v19 = v18 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v78);
    v20 = v78;
    if (v19 <= 0x40)
    {
      *((_QWORD *)&v93 + 3 - v16++) = *v78;
LABEL_24:
      MEMORY[0x186DA165C]();
      goto LABEL_9;
    }
    *((_QWORD *)&v93 + 3 - v16++) = -1;
    if (v20)
      goto LABEL_24;
LABEL_9:
    *(_QWORD *)&v100 = v100 + 1;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v99, FastmathAttr, 0);
  v21 = FastmathAttr;
  v22 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&FastmathAttr);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&KernelSizes, v21, v22);
  v23 = 0;
  while (1)
  {
    v24 = (_QWORD *)v99 == KernelSizes && BYTE8(v99) == v82;
    if (v24 && (_QWORD)v100 == v83)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v99, (llvm::APInt *)&v78);
    if (v23 == 4 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v25 = v79;
    if (v79 < 0x41)
    {
      *((_QWORD *)&v84 + 3 - v23++) = v78;
      goto LABEL_27;
    }
    v26 = v25 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v78);
    v27 = v78;
    if (v26 <= 0x40)
    {
      *((_QWORD *)&v84 + 3 - v23++) = *v78;
LABEL_42:
      MEMORY[0x186DA165C]();
      goto LABEL_27;
    }
    *((_QWORD *)&v84 + 3 - v23++) = -1;
    if (v27)
      goto LABEL_42;
LABEL_27:
    *(_QWORD *)&v100 = v100 + 1;
  }
  if (v11 < 4)
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  v29 = *v9;
  v28 = v9[1];
  v31 = v9[2];
  v30 = v9[3];
  v101 = 0u;
  v102 = 0u;
  v99 = 0u;
  v100 = 0u;
  v32 = (v29 - 1) * *((_QWORD *)&v85 + 1) + 1;
  v33 = (v28 - 1) * v85 + 1;
  v34 = (v31 - 1) * *((_QWORD *)&v84 + 1) + 1;
  v70 = (v30 - 1) * v84 + 1;
  switch(mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92))
  {
    case 0u:
      goto LABEL_97;
    case 2u:
    case 4u:
      if (v6 <= 3)
        __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
      v35 = *(_QWORD *)(Value + 8 * (v6 - 4)) % *((_QWORD *)&v94 + 1);
      if (!v35)
        v35 = *((_QWORD *)&v94 + 1);
      v36 = (v32 - v35) & ~((v32 - v35) >> 63);
      *(_QWORD *)&v99 = v36 >> 1;
      if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) == 4)
        *(_QWORD *)&v99 = v36 - (v36 >> 1);
      v37 = *(_QWORD *)(Value + 8 * v6 - 24) % (unint64_t)v94;
      if (!v37)
        v37 = v94;
      v38 = (v33 - v37) & ~((uint64_t)(v33 - v37) >> 63);
      *(_QWORD *)&v100 = v38 >> 1;
      if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) == 4)
        *(_QWORD *)&v100 = v38 - (v38 >> 1);
      v39 = *(_QWORD *)(Value + 8 * v6 - 16) % *((_QWORD *)&v93 + 1);
      if (!v39)
        v39 = *((_QWORD *)&v93 + 1);
      v40 = (v34 - v39) & ~((v34 - v39) >> 63);
      *(_QWORD *)&v101 = v40 >> 1;
      if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) == 4)
        *(_QWORD *)&v101 = v40 - (v40 >> 1);
      v41 = *(_QWORD *)(Value + 8 * v6 - 8) % (unint64_t)v93;
      if (!v41)
        v41 = v93;
      v42 = (v70 - v41) & ~((uint64_t)(v70 - v41) >> 63);
      *(_QWORD *)&v102 = v42 >> 1;
      if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) == 4)
        *(_QWORD *)&v102 = v42 - (v42 >> 1);
      goto LABEL_62;
    case 3u:
      if (!(_BYTE)v91 && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&KernelSizes, Offsets, 0);
      v53 = Offsets;
      v54 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Offsets);
      mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v78, v53, v54);
      v55 = 0;
      break;
    default:
      goto LABEL_62;
  }
  while (2)
  {
    v56 = KernelSizes == v78 && v82 == v79;
    if (!v56 || v83 != v80)
    {
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&KernelSizes, (llvm::APInt *)&v76);
      if (v55 == 4 && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      v57 = v77;
      if (v77 < 0x41)
      {
        *((_QWORD *)&v96 + 3 - v55++) = v76;
      }
      else
      {
        v58 = v57 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v76);
        v59 = v76;
        if (v58 <= 0x40)
        {
          *((_QWORD *)&v96 + 3 - v55++) = *v76;
        }
        else
        {
          *((_QWORD *)&v96 + 3 - v55++) = -1;
          if (!v59)
            goto LABEL_81;
        }
        MEMORY[0x186DA165C]();
      }
LABEL_81:
      ++v83;
      continue;
    }
    break;
  }
LABEL_97:
  if (!(_BYTE)v87 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&KernelSizes, ExplicitPadding, 0);
  v60 = ExplicitPadding;
  v61 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&ExplicitPadding);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v78, v60, v61);
  for (i = 0; ; ++i)
  {
    v63 = KernelSizes == v78 && v82 == v79;
    if (v63 && v83 == v80)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&KernelSizes, (llvm::APInt *)&v76);
    if (i == 8 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    *((_QWORD *)&v99 + i) = llvm::APInt::getSExtValue((llvm::APInt *)&v76);
    if (v77 >= 0x41 && v76)
      MEMORY[0x186DA165C](v76, 0x1000C8000313F17);
    ++v83;
  }
LABEL_62:
  if (mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v92) != 3)
  {
    if (v32 >= 0)
      v43 = v32;
    else
      v43 = v32 + 1;
    v44 = (v43 >> 1) - v99;
    if (v33 >= 0)
      v45 = v33;
    else
      v45 = v33 + 1;
    *(_QWORD *)&v97 = (v45 >> 1) - v100;
    *((_QWORD *)&v97 + 1) = v44;
    if (v34 >= 0)
      v46 = v34;
    else
      v46 = v34 + 1;
    *(_QWORD *)&v96 = v70 / 2 - v102;
    *((_QWORD *)&v96 + 1) = (v46 >> 1) - v101;
  }
  v47 = objc_alloc(MEMORY[0x1E0CC7170]);
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  v49 = (void *)objc_msgSend(v47, "initWithDevice:", v48);

  v75[0] = v96;
  v75[1] = v97;
  objc_msgSend(v49, "setStencilOffsets:", v75);
  v74[0] = v93;
  v74[1] = v94;
  objc_msgSend(v49, "setStencilStrides:", v74);
  v73[0] = v84;
  v73[1] = v85;
  objc_msgSend(v49, "setStencilDilationRates:", v73);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v92);
  if (WeightsLayout > 5)
  {
    v67 = "0 && \"Unsupported reductionMode\"";
    v68 = 33;
    v69 = "mlirToMpsReductionMode";
    goto LABEL_129;
  }
  objc_msgSend(v49, "setReductionMode:", dword_181287684[WeightsLayout]);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v92);
  if (PaddingStyle >= 7)
  {
    v67 = "0 && \"Unsupported paddingMode\"";
    v68 = 56;
    v69 = "mlirToMpsStencilPadMode";
LABEL_129:
    __assert_rtn(v69, "GPUStencilOps.mm", v68, v67);
  }
  objc_msgSend(v49, "setPaddingMode:", dword_18128769C[PaddingStyle]);
  KernelSizes = (_QWORD *)mlir::mps::ColToImOp::getKernelSizes((mlir::mps::ColToImOp *)&v92);
  ValueAsDouble = mlir::FloatAttr::getValueAsDouble((mlir::FloatAttr *)&KernelSizes);
  *(float *)&ValueAsDouble = ValueAsDouble;
  objc_msgSend(v49, "setPaddingConstant:", ValueAsDouble);
  objc_storeStrong((id *)this + 1, v49);
  objc_msgSend(*((id *)this + 1), "setOptions:", objc_msgSend(*((id *)this + 1), "options") | 1);

}

void sub_180E2C978(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t llvm::APInt::getSExtValue(llvm::APInt *this)
{
  unsigned int v1;
  uint64_t v3;

  v1 = *((_DWORD *)this + 2);
  if (v1 > 0x40)
  {
    v3 = *(_QWORD *)this;
    if (((*(_QWORD *)(*(_QWORD *)this + 8 * ((v1 - 1) >> 6)) >> (v1 - 1)) & 1) != 0)
    {
      if (v1 - llvm::APInt::countLeadingOnesSlowCase(this) + 1 < 0x41)
        return *(_QWORD *)v3;
    }
    else if (v1 - llvm::APInt::countLeadingZerosSlowCase(this) + 1 < 0x41)
    {
      return *(_QWORD *)v3;
    }
    __assert_rtn("getSExtValue", "APInt.h", 1510, "getSignificantBits() <= 64 && \"Too many bits for int64_t\"");
  }
  if (!v1)
    __assert_rtn("SignExtend64", "MathExtras.h", 461, "B > 0 && \"Bit width can't be 0.\"");
  return (uint64_t)(*(_QWORD *)this << -(char)v1) >> -(char)v1;
}

void GPU::MultiaryKernelOpHandler<GPU::StencilOpHandler,mlir::mps::StencilOp,MPSNDArrayStencilKernel,2ul>::encodeNDArrayOp(uint64_t a1, _QWORD *a2, void *a3)
{
  void *v5;
  void *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  void *v21;
  id v22;
  id v23;
  void *v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  id v28;
  _QWORD *v29;
  uint64_t v30;
  void *v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  id v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  id v43;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  _QWORD *AttrData;
  uint64_t v49;
  id v51;
  id v52;
  uint64_t v53[4];
  __int16 v54;
  uint64_t v55[2];
  const char *v56;
  uint64_t v57;
  __int16 v58;
  _QWORD v59[4];
  __int16 v60;

  v51 = a3;
  if (!*(_BYTE *)(a1 + 40))
    GPU::StencilOpHandler::_createNDArrayMultiaryKernel((GPU::StencilOpHandler *)a1);
  objc_msgSend(v51, "objectAtIndexedSubscript:", 0, v51);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "mpsndarray");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v6 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v7 = v6;
  v8 = *(_QWORD *)(a1 + 24);
  v9 = *(_QWORD *)(v8 + 48);
  v10 = *(void **)(v9 + 16);
  if (v10 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v59[0] = *(_QWORD *)(v9 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v59);
    if (v49 == 11 && *AttrData == 0x6E6574732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      v58 = 1283;
      v55[0] = (uint64_t)"classof on '";
      v56 = "mps.stencil";
      v57 = 11;
      v53[0] = (uint64_t)"' failed due to the operation not being registered";
      v54 = 259;
      llvm::operator+(v55, v53, (uint64_t)v59);
      llvm::report_fatal_error((llvm::Twine *)v59, 1);
    }
LABEL_68:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v10 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
    goto LABEL_68;
  if (!*(_QWORD *)(a1 + 32))
  {
    objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", 2);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    if ((*(_BYTE *)(v8 + 46) & 0x80) != 0)
    {
      if (!*(_DWORD *)(v8 + 68))
      {
LABEL_50:
        v44 = "Index < this->size() && \"Invalid index!\"";
        v45 = 443;
        v46 = "ArrayRef.h";
        v47 = "operator[]";
LABEL_51:
        __assert_rtn(v47, v46, v45, v44);
      }
      v25 = *(_QWORD *)(a1 + 16);
      v59[0] = *(_QWORD *)(*(_QWORD *)(v8 + 72) + 24);
      v55[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)v59) + 2);
      v26 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v25 + 88), v55);
      if (v26
        && (v53[0] = v59[0],
            (v27 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v26 + 3, v53)) != 0))
      {
        v28 = (id)v27[3];
      }
      else
      {
        v28 = 0;
      }
      objc_msgSend(v28, "mpsndarray");
      v32 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v32 && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      objc_msgSend(v17, "addObject:", v32);

      if ((*(_BYTE *)(v8 + 46) & 0x80) != 0)
      {
        if (*(_DWORD *)(v8 + 68) >= 2u)
        {
          v33 = *(_QWORD *)(a1 + 16);
          v59[0] = *(_QWORD *)(*(_QWORD *)(v8 + 72) + 56);
          v55[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)v59) + 2);
          v34 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v33 + 88), v55);
          if (v34
            && (v53[0] = v59[0],
                (v35 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v34 + 3, v53)) != 0))
          {
            v36 = (id)v35[3];
          }
          else
          {
            v36 = 0;
          }
          objc_msgSend(v36, "mpsndarray");
          v37 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v37 && MTLReportFailureTypeEnabled())
            MTLReportFailure();
          objc_msgSend(v17, "addObject:", v37);

          v22 = 0;
          v23 = *(id *)(a1 + 8);
          v24 = (void *)a2[9];
          if (!v24)
            goto LABEL_42;
          goto LABEL_44;
        }
        goto LABEL_50;
      }
    }
    v44 = "hasOperandStorage && \"expected operation to have operand storage\"";
    v45 = 960;
    v46 = "Operation.h";
    v47 = "getOperandStorage";
    goto LABEL_51;
  }
  v11 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(v8 + 16)) + 48);
  if (*(_UNKNOWN **)(v11 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v59[0] = *(_QWORD *)(v11 + 8);
    v12 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v59);
    if (v13 == 13 && *v12 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v12 + 5) == 0x6465686374697473)
    {
      v58 = 1283;
      v55[0] = (uint64_t)"classof on '";
      v56 = "mpsx.stitched";
      v57 = 13;
      v53[0] = (uint64_t)"' failed due to the operation not being registered";
      v54 = 259;
      llvm::operator+(v55, v53, (uint64_t)v59);
      llvm::report_fatal_error((llvm::Twine *)v59, 1);
    }
  }
  v15 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
  v16 = *(void **)(v15 + 16);
  if (v16 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v59[0] = *(_QWORD *)(v15 + 8);
    v29 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v59);
    if (v30 == 13 && *v29 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v29 + 5) == 0x6465686374697473)
    {
      v58 = 1283;
      v55[0] = (uint64_t)"classof on '";
      v56 = "mpsx.stitched";
      v57 = 13;
      v59[0] = v55;
      v59[2] = "' failed due to the operation not being registered";
      v60 = 770;
      llvm::report_fatal_error((llvm::Twine *)v59, 1);
    }
  }
  else if (v16 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
  {
    goto LABEL_15;
  }
  if (MTLReportFailureTypeEnabled())
    MTLReportFailure();
LABEL_15:
  GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = *(_QWORD *)(a1 + 32);
  v19 = *(void **)(v18 + 120);
  if (!v19)
  {
    if (!*(_QWORD *)(v18 + 96) && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v20 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6EC8]), "initWithKernelDAG:finalOp:", v18 + 80, *(_QWORD *)(*(_QWORD *)(v18 + 96) + 32));
    v21 = *(void **)(v18 + 120);
    *(_QWORD *)(v18 + 120) = v20;

    v19 = *(void **)(v18 + 120);
  }
  v22 = v19;
  v23 = *(id *)(a1 + 8);
  v24 = (void *)a2[9];
  if (!v24)
  {
LABEL_42:
    v38 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", a2[1], 0);
    v39 = (void *)a2[9];
    a2[9] = v38;

    v40 = (void *)a2[11];
    v24 = (void *)a2[9];
    if (v40)
    {
      objc_msgSend(v40, "wrapComputeEncoder:", a2[9]);
      v41 = objc_claimAutoreleasedReturnValue();
      v42 = (void *)a2[9];
      a2[9] = v41;

      v24 = (void *)a2[9];
    }
  }
LABEL_44:
  if (a2[10])
  {
    objc_msgSend(v24, "setLabel:");
    v24 = (void *)a2[9];
  }
  v43 = v24;
  objc_msgSend(v23, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v43, a2[1], v17, 0, v7, v22);

}

void sub_180E2D180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

void sub_180E2D198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  void *v9;
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t GPU::StencilOpHandler::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  unint64_t Input;
  unint64_t Filter;
  uint64_t result;
  _QWORD *AttrData;
  uint64_t v10;
  const char *v12;
  __int16 v13;
  uint64_t v14[4];
  __int16 v15;
  _QWORD v16[5];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(_QWORD *)(v2 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v10 == 11 && *AttrData == 0x6E6574732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.stencil";
      v14[3] = 11;
      v12 = "' failed due to the operation not being registered";
      v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_11:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
    goto LABEL_11;
  v16[0] = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Filter, 0);
  result = MPSKernelDAG::binaryCoreOp();
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 24);
  return result;
}

void GPU::StencilOpHandler::~StencilOpHandler(GPU::StencilOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::MultiaryKernelOpHandler<GPU::StencilOpHandler,mlir::mps::StencilOp,MPSNDArrayStencilKernel,2ul>::~MultiaryKernelOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);
  JUMPOUT(0x186DA1680);
}

void sub_180E2D678(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_180E2D70C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_180E2D9CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{

  _Unwind_Resume(a1);
}

uint64_t MPSSymbolTable::getLocationByInsertingOp<mlir::mps::SampleGridOp>(uint64_t a1, mlir::StringAttr **a2, uint64_t a3, unsigned int a4, void *a5)
{
  id v9;
  uint64_t StringAttr;
  uint64_t v11;
  const char *v12;
  size_t v13;
  size_t v14;
  int8x16_t *p_dst;
  __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  std::string *p_p;
  char v20;
  uint64_t v21;
  uint64_t v22;
  std::string __p;
  int8x16_t __dst;
  unint64_t v26;
  _QWORD v27[4];
  __int16 v28;

  v9 = a5;
  v28 = 260;
  v27[0] = a3;
  StringAttr = mlir::Builder::getStringAttr(a2, (mlir::MLIRContext *)v27);
  v11 = mlir::FileLineColLoc::get(StringAttr, a4, 0);
  if (!v11)
    __assert_rtn("Location", "Location.h", 66, "loc && \"location should never be null.\"");
  if (!v9)
  {
    HIBYTE(v26) = 15;
    qmemcpy(&__dst, "mps.sample_grid", 15);
    v16 = &__dst.i8[15];
    goto LABEL_13;
  }
  v12 = (const char *)objc_msgSend(objc_retainAutorelease(v9), "UTF8String");
  v13 = strlen(v12);
  if (v13 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v14 = v13;
  if (v13 >= 0x17)
  {
    v17 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17)
      v17 = v13 | 7;
    v18 = v17 + 1;
    p_dst = (int8x16_t *)operator new(v17 + 1);
    __dst.i64[1] = v14;
    v26 = v18 | 0x8000000000000000;
    __dst.i64[0] = (uint64_t)p_dst;
  }
  else
  {
    HIBYTE(v26) = v13;
    p_dst = &__dst;
    if (!v13)
      goto LABEL_12;
  }
  memmove(p_dst, v12, v14);
LABEL_12:
  v16 = &p_dst->i8[v14];
LABEL_13:
  *v16 = 0;
  MPSSymbolTable::insertOpInSymbolTable(a1, &__dst, &__p);
  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  v20 = 1;
  HIBYTE(v28) = 1;
  if (p_p->__r_.__value_.__s.__data_[0])
  {
    v27[0] = p_p;
    v20 = 3;
  }
  LOBYTE(v28) = v20;
  v21 = mlir::Builder::getStringAttr(a2, (mlir::MLIRContext *)v27);
  v22 = mlir::NameLoc::get(v21, v11);
  if (!v22)
    __assert_rtn("Location", "Location.h", 66, "loc && \"location should never be null.\"");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v26) & 0x80000000) == 0)
      goto LABEL_20;
LABEL_22:
    operator delete((void *)__dst.i64[0]);
    goto LABEL_20;
  }
  if (SHIBYTE(v26) < 0)
    goto LABEL_22;
LABEL_20:

  return v22;
}

void sub_180E2DC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;

  if ((a21 & 0x80000000) == 0)
  {

    _Unwind_Resume(a1);
  }
  operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E2DC98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E2E02C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  void *v34;

  _Unwind_Resume(a1);
}

void sub_180E2E220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_180E2E474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_180E2E64C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

EmitterObjC::Conv2DOpHandler *EmitterObjC::Conv2DOpHandler::Conv2DOpHandler(EmitterObjC::Conv2DOpHandler *this, id *a2, mlir::Operation *a3)
{
  uint64_t Input;
  uint64_t Filter;
  uint64_t v7;
  void *Groups;
  int StorageType;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  std::string::size_type v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t NumElements;
  unsigned int v21;
  uint64_t v22;
  BOOL v23;
  int v24;
  std::string::size_type v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  BOOL v37;
  int v38;
  std::string::size_type v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  BOOL v44;
  int v45;
  std::string::size_type v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  BOOL v51;
  unsigned int v52;
  std::string::size_type v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  BOOL v58;
  unsigned int v59;
  std::string::size_type v60;
  int v61;
  void *v62;
  _QWORD **v63;
  unsigned int PaddingStyle;
  char *v65;
  int WeightsLayout;
  const char *v67;
  void *v68;
  uint64_t v69;
  id v70;
  void *v71;
  _QWORD **v72;
  _QWORD *v73;
  _QWORD *v74;
  _QWORD *v75;
  _QWORD *v76;
  int v77;
  uint64_t *v78;
  uint64_t **v79;
  std::string *p_p;
  void *v81;
  uint64_t v82;
  id v83;
  const char *v85;
  uint64_t v86;
  EmitterObjC::Conv2DOpHandler *v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  id *v92;
  void *v93;
  char v94;
  std::string __p;
  uint64_t v96;
  uint64_t v97;
  uint64_t *v98;
  char v99;
  uint64_t v100;
  uint64_t *v101;
  char v102;
  uint64_t v103;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  uint64_t Strides;
  _QWORD v107[2];

  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *(_QWORD *)this = &off_1E0E14918;
  if (!a3)
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  v107[0] = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v107);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v107);
  v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v107);
  Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)v107);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)v107);
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)v107);
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)v107);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)v107);
  v91 = v7;
  v92 = a2;
  v87 = this;
  v88 = Filter;
  v89 = Input;
  v90 = Groups;
  if (StorageType == 1)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v101, Strides, 0);
    v19 = Strides;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v98, v19, NumElements);
    v21 = 0;
    v13 = -1;
    v22 = -1;
    while (1)
    {
      v23 = v101 == v98 && v102 == v99;
      if (v23 && v103 == v100)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v101, (llvm::APInt *)&__p);
      v24 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
      {
        v25 = __p.__r_.__value_.__r.__words[0];
LABEL_43:
        v26 = v25;
        switch(v21)
        {
          case 0u:
            if (v25 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_52;
            goto LABEL_55;
          case 1u:
            goto LABEL_56;
          case 2u:
            v26 = v13;
            v22 = v25;
            break;
          case 3u:
            if (v25 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_52;
            goto LABEL_55;
          default:
            goto LABEL_51;
        }
        goto LABEL_56;
      }
      if (v24 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        v25 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
        if (v21 <= 3)
          goto LABEL_43;
      }
      else
      {
        v25 = -1;
        if (v21 <= 3)
          goto LABEL_43;
      }
LABEL_51:
      if (MTLReportFailureTypeEnabled())
      {
LABEL_52:
        MTLReportFailure();
        v26 = v13;
      }
      else
      {
LABEL_55:
        v26 = v13;
      }
LABEL_56:
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41 && __p.__r_.__value_.__r.__words[0])
        MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      ++v103;
      ++v21;
      v13 = v26;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v101, InputAttributeNames, 0);
    v86 = v22;
    v41 = InputAttributeNames;
    v42 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v98, v41, v42);
    v43 = 0;
    v27 = -1;
    v28 = -1;
    while (1)
    {
      v44 = v101 == v98 && v102 == v99;
      if (v44 && v103 == v100)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v101, (llvm::APInt *)&__p);
      v45 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
      {
        v46 = __p.__r_.__value_.__r.__words[0];
LABEL_104:
        v47 = v46;
        switch(v43)
        {
          case 0u:
            if (v46 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_113;
            goto LABEL_116;
          case 1u:
            goto LABEL_117;
          case 2u:
            v47 = v27;
            v28 = v46;
            break;
          case 3u:
            if (v46 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_113;
            goto LABEL_116;
          default:
            goto LABEL_112;
        }
        goto LABEL_117;
      }
      if (v45 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        v46 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
        if (v43 <= 3)
          goto LABEL_104;
      }
      else
      {
        v46 = -1;
        if (v43 <= 3)
          goto LABEL_104;
      }
LABEL_112:
      if (MTLReportFailureTypeEnabled())
      {
LABEL_113:
        MTLReportFailure();
        v47 = v27;
      }
      else
      {
LABEL_116:
        v47 = v27;
      }
LABEL_117:
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41 && __p.__r_.__value_.__r.__words[0])
        MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      ++v103;
      ++v43;
      v27 = v47;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v101, Rewriter, 0);
    v55 = Rewriter;
    v56 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v98, v55, v56);
    v57 = 0;
    v29 = -1;
    v30 = -1;
    v31 = -1;
    v32 = -1;
    while (1)
    {
      v58 = v101 == v98 && v102 == v99;
      if (v58 && v103 == v100)
        goto LABEL_64;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v101, (llvm::APInt *)&__p);
      v59 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
      {
        if (v59 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
        {
          v60 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
          v61 = v57 - 2;
        }
        else
        {
          v60 = -1;
          v61 = v57 - 2;
          if ((v57 - 2) > 3)
          {
LABEL_169:
            if (v59 >= 0x41)
            {
LABEL_170:
              if (__p.__r_.__value_.__r.__words[0])
                MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
            }
            goto LABEL_149;
          }
        }
      }
      else
      {
        v60 = __p.__r_.__value_.__r.__words[0];
        v61 = v57 - 2;
        if ((v57 - 2) > 3)
          goto LABEL_169;
      }
      switch(v61)
      {
        case 0:
          v30 = v60;
          if (v59 >= 0x41)
            goto LABEL_170;
          break;
        case 1:
          v29 = v60;
          if (v59 >= 0x41)
            goto LABEL_170;
          break;
        case 2:
          v32 = v60;
          goto LABEL_169;
        case 3:
          v31 = v60;
          if (v59 >= 0x41)
            goto LABEL_170;
          break;
        default:
          goto LABEL_169;
      }
LABEL_149:
      ++v103;
      ++v57;
    }
  }
  if (StorageType)
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v13 = -1;
    v86 = -1;
    v27 = -1;
    v28 = -1;
    v29 = -1;
    v30 = -1;
    v31 = -1;
    v32 = -1;
LABEL_64:
    v33 = "MPSGraphTensorNamedDataLayoutNHWC";
    goto LABEL_175;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v101, Strides, 0);
  v10 = Strides;
  v11 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v98, v10, v11);
  v12 = 0;
  v13 = -1;
  v14 = -1;
  while (1)
  {
    v15 = v101 == v98 && v102 == v99;
    if (v15 && v103 == v100)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v101, (llvm::APInt *)&__p);
    v16 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
    {
      v17 = __p.__r_.__value_.__r.__words[0];
LABEL_14:
      v18 = v17;
      switch(v12)
      {
        case 0u:
          if (v17 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_23;
          goto LABEL_25;
        case 1u:
          if (v17 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_23;
          goto LABEL_25;
        case 2u:
          goto LABEL_26;
        case 3u:
          v18 = v13;
          v14 = v17;
          if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
            goto LABEL_27;
          break;
        default:
          goto LABEL_22;
      }
      goto LABEL_5;
    }
    if (v16 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      v17 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
      if (v12 <= 3)
        goto LABEL_14;
    }
    else
    {
      v17 = -1;
      if (v12 <= 3)
        goto LABEL_14;
    }
LABEL_22:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_23:
      MTLReportFailure();
      v18 = v13;
    }
    else
    {
LABEL_25:
      v18 = v13;
    }
LABEL_26:
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
LABEL_27:
      if (__p.__r_.__value_.__r.__words[0])
        MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
    }
LABEL_5:
    ++v103;
    ++v12;
    v13 = v18;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v101, InputAttributeNames, 0);
  v86 = v14;
  v34 = InputAttributeNames;
  v35 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v98, v34, v35);
  v36 = 0;
  v27 = -1;
  v28 = -1;
  while (1)
  {
    v37 = v101 == v98 && v102 == v99;
    if (v37 && v103 == v100)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v101, (llvm::APInt *)&__p);
    v38 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
    {
      v39 = __p.__r_.__value_.__r.__words[0];
LABEL_75:
      v40 = v39;
      switch(v36)
      {
        case 0u:
          if (v39 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_84;
          goto LABEL_86;
        case 1u:
          if (v39 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_84;
          goto LABEL_86;
        case 2u:
          goto LABEL_87;
        case 3u:
          v40 = v27;
          v28 = v39;
          if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
            goto LABEL_88;
          break;
        default:
          goto LABEL_83;
      }
      goto LABEL_66;
    }
    if (v38 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      v39 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
      if (v36 <= 3)
        goto LABEL_75;
    }
    else
    {
      v39 = -1;
      if (v36 <= 3)
        goto LABEL_75;
    }
LABEL_83:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_84:
      MTLReportFailure();
      v40 = v27;
    }
    else
    {
LABEL_86:
      v40 = v27;
    }
LABEL_87:
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
LABEL_88:
      if (__p.__r_.__value_.__r.__words[0])
        MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
    }
LABEL_66:
    ++v103;
    ++v36;
    v27 = v40;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v101, Rewriter, 0);
  v48 = Rewriter;
  v49 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v98, v48, v49);
  v50 = 0;
  v29 = -1;
  v30 = -1;
  v31 = -1;
  v32 = -1;
  while (1)
  {
    v51 = v101 == v98 && v102 == v99;
    if (v51 && v103 == v100)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v101, (llvm::APInt *)&__p);
    v52 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
      if (v52 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        v53 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
        v54 = v50 - 4;
      }
      else
      {
        v53 = -1;
        v54 = v50 - 4;
        if ((v50 - 4) > 3)
        {
LABEL_143:
          if (v52 >= 0x41)
          {
LABEL_144:
            if (__p.__r_.__value_.__r.__words[0])
              MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
          }
          goto LABEL_123;
        }
      }
    }
    else
    {
      v53 = __p.__r_.__value_.__r.__words[0];
      v54 = v50 - 4;
      if ((v50 - 4) > 3)
        goto LABEL_143;
    }
    switch(v54)
    {
      case 0:
        v30 = v53;
        if (v52 >= 0x41)
          goto LABEL_144;
        break;
      case 1:
        v29 = v53;
        if (v52 >= 0x41)
          goto LABEL_144;
        break;
      case 2:
        v32 = v53;
        goto LABEL_143;
      case 3:
        v31 = v53;
        if (v52 >= 0x41)
          goto LABEL_144;
        break;
      default:
        goto LABEL_143;
    }
LABEL_123:
    ++v103;
    ++v50;
  }
  v33 = "MPSGraphTensorNamedDataLayoutNCHW";
LABEL_175:
  v85 = v33;
  v62 = (void *)MEMORY[0x1E0CB3940];
  v63 = &v101;
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*v92 + 4))(&v101, v92, v91);
  if (v103 < 0)
    v63 = (_QWORD **)v101;
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)v107);
  if (PaddingStyle >= 5)
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v65 = 0;
  }
  else
  {
    v65 = off_1E0E76A00[PaddingStyle];
  }
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)v107);
  if (WeightsLayout == 2)
  {
    v67 = "MPSGraphTensorNamedDataLayoutOIHW";
  }
  else if (WeightsLayout == 3)
  {
    v67 = "MPSGraphTensorNamedDataLayoutHWIO";
  }
  else
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v67 = 0;
  }
  objc_msgSend(v62, "stringWithFormat:", CFSTR("\n    MPSGraphConvolution2DOpDescriptor *%sConvDescriptor = \n    [MPSGraphConvolution2DOpDescriptor descriptorWithStrideInX:%ld\n                                                     strideInY:%ld\n                                               dilationRateInX:%ld\n                                               dilationRateInY:%ld\n                                                        groups:%ld\n                                                   paddingLeft:%ld\n                                                  paddingRight:%ld\n                                                    paddingTop:%ld\n                                                 paddingBottom:%ld\n                                                  paddingStyle:%s\n                                                    dataLayout:%s\n                                                 weightsLayout:%s];\n    "),
    v63,
    v86,
    v13,
    v28,
    v27,
    v90,
    v32,
    v31,
    v30,
    v29,
    v65,
    v85,
    v67);
  v68 = (void *)objc_claimAutoreleasedReturnValue();
  if (SHIBYTE(v103) < 0)
    operator delete(v101);
  objc_msgSend(v92[27], "stringByAppendingString:", v68);
  v69 = objc_claimAutoreleasedReturnValue();
  v70 = v92[27];
  v92[27] = (id)v69;

  v71 = (void *)MEMORY[0x1E0CB3940];
  v72 = &v101;
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*v92 + 4))(&v101, v92, v91);
  if (v103 < 0)
    v72 = (_QWORD **)v101;
  v97 = v89;
  v98 = &v97;
  v73 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(v92 + 32), &v97, (uint64_t)&std::piecewise_construct, &v98);
  v74 = v73 + 3;
  if (*((char *)v73 + 47) < 0)
    v74 = (_QWORD *)*v74;
  v96 = v88;
  v98 = &v96;
  v75 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(v92 + 32), &v96, (uint64_t)&std::piecewise_construct, &v98);
  v76 = v75 + 3;
  if (*((char *)v75 + 47) < 0)
    v76 = (_QWORD *)*v76;
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*v92 + 4))(&v98, v92, v91);
  v77 = SHIBYTE(v100);
  v78 = v98;
  v94 = 0;
  LOBYTE(v93) = 0;
  EmitObjC::emitTensorName((uint64_t)v92, v91, (uint64_t)&v93, &__p);
  v79 = &v98;
  if (v77 < 0)
    v79 = (uint64_t **)v78;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v71, "stringWithFormat:", CFSTR("\n    MPSGraphTensor *%s = \n    [graph convolution2DWithSourceTensor:%s\n                           weightsTensor:%s\n                              descriptor:%sConvDescriptor\n                                    name:%s];\n    "),
    v72,
    v74,
    v76,
    v79,
    p_p);
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v94 & 0x80000000) == 0)
      goto LABEL_206;
LABEL_210:
    operator delete(v93);
    if (SHIBYTE(v100) < 0)
      goto LABEL_211;
LABEL_207:
    if ((SHIBYTE(v103) & 0x80000000) == 0)
      goto LABEL_208;
LABEL_212:
    operator delete(v101);
    goto LABEL_208;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v94 < 0)
    goto LABEL_210;
LABEL_206:
  if ((SHIBYTE(v100) & 0x80000000) == 0)
    goto LABEL_207;
LABEL_211:
  operator delete(v98);
  if (SHIBYTE(v103) < 0)
    goto LABEL_212;
LABEL_208:
  objc_msgSend(v92[27], "stringByAppendingString:", v81);
  v82 = objc_claimAutoreleasedReturnValue();
  v83 = v92[27];
  v92[27] = (id)v82;

  return v87;
}

void sub_180E2F4F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_180E2F508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  void *v41;
  uint64_t v42;

  if (a41 < 0)
  {
    operator delete(__p);
    if (a35 < 0)
    {
LABEL_5:
      operator delete(a30);
      if ((*(char *)(v42 - 161) & 0x80000000) == 0)
        goto LABEL_6;
      goto LABEL_9;
    }
  }
  else if (a35 < 0)
  {
    goto LABEL_5;
  }
  if ((*(char *)(v42 - 161) & 0x80000000) == 0)
  {
LABEL_6:
    if (*(char *)(v42 - 129) < 0)
      goto LABEL_7;
    goto LABEL_10;
  }
LABEL_9:
  operator delete(*(void **)(v42 - 184));
  if (*(char *)(v42 - 129) < 0)
  {
LABEL_7:
    operator delete(*(void **)(v42 - 152));

    _Unwind_Resume(a1);
  }
LABEL_10:

  _Unwind_Resume(a1);
}

void sub_180E2F5CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34)
{
  uint64_t v34;

  if (*(char *)(v34 - 129) < 0)
  {
    operator delete(*(void **)(v34 - 152));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

EmitterObjC::Conv2DDataGradientOpHandler *EmitterObjC::Conv2DDataGradientOpHandler::Conv2DDataGradientOpHandler(EmitterObjC::Conv2DDataGradientOpHandler *this, id *a2, mlir::Operation *a3)
{
  uint64_t SplitSizes;
  uint64_t v5;
  void *Groups;
  int StorageType;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  std::string::size_type v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t NumElements;
  unsigned int v18;
  BOOL v19;
  int v20;
  std::string::size_type v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  BOOL v33;
  int v34;
  std::string::size_type v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  BOOL v40;
  int v41;
  std::string::size_type v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  BOOL v47;
  unsigned int v48;
  std::string::size_type v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  BOOL v54;
  unsigned int v55;
  std::string::size_type v56;
  int v57;
  void *v58;
  _QWORD **v59;
  unsigned int PaddingStyle;
  char *v61;
  int WeightsLayout;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  id v66;
  void *v67;
  _QWORD **v68;
  char *v69;
  _QWORD *v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  _QWORD *v75;
  int v76;
  uint64_t *v77;
  uint64_t **v78;
  std::string *p_p;
  void *v80;
  uint64_t v81;
  id v82;
  const char *v84;
  EmitterObjC::Conv2DDataGradientOpHandler *v85;
  uint64_t v86;
  uint64_t Filter;
  uint64_t Input;
  void *v89;
  uint64_t v90;
  uint64_t v92;
  void *v93;
  void *v94;
  char v95;
  std::string __p;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t *v100;
  char v101;
  uint64_t v102;
  uint64_t *v103;
  char v104;
  uint64_t v105;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  uint64_t Strides;
  _QWORD v109[2];

  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *(_QWORD *)this = &off_1E0E14F18;
  if (!a3)
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  v109[0] = llvm::DefaultDoCastIfPossible<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,llvm::CastInfo<mlir::mps::Conv2DDataGradientOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v109);
  SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)v109);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)v109);
  v5 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v109);
  Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)v109);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)v109);
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)v109);
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)v109);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)v109);
  v85 = this;
  v86 = SplitSizes;
  v89 = Groups;
  v90 = v5;
  if (StorageType == 1)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v103, Strides, 0);
    v16 = Strides;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v100, v16, NumElements);
    v18 = 0;
    v11 = -1;
    v92 = -1;
    while (1)
    {
      v19 = v103 == v100 && v104 == v101;
      if (v19 && v105 == v102)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v103, (llvm::APInt *)&__p);
      v20 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
      {
        v21 = __p.__r_.__value_.__r.__words[0];
LABEL_43:
        v22 = v21;
        switch(v18)
        {
          case 0u:
            if (v21 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_52;
            goto LABEL_55;
          case 1u:
            goto LABEL_56;
          case 2u:
            v22 = v11;
            v92 = v21;
            break;
          case 3u:
            if (v21 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_52;
            goto LABEL_55;
          default:
            goto LABEL_51;
        }
        goto LABEL_56;
      }
      if (v20 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        v21 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
        if (v18 <= 3)
          goto LABEL_43;
      }
      else
      {
        v21 = -1;
        if (v18 <= 3)
          goto LABEL_43;
      }
LABEL_51:
      if (MTLReportFailureTypeEnabled())
      {
LABEL_52:
        MTLReportFailure();
        v22 = v11;
      }
      else
      {
LABEL_55:
        v22 = v11;
      }
LABEL_56:
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41 && __p.__r_.__value_.__r.__words[0])
        MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      ++v105;
      ++v18;
      v11 = v22;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v103, InputAttributeNames, 0);
    v37 = InputAttributeNames;
    v38 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v100, v37, v38);
    v39 = 0;
    v23 = -1;
    v24 = -1;
    while (1)
    {
      v40 = v103 == v100 && v104 == v101;
      if (v40 && v105 == v102)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v103, (llvm::APInt *)&__p);
      v41 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
      {
        v42 = __p.__r_.__value_.__r.__words[0];
LABEL_104:
        v43 = v42;
        switch(v39)
        {
          case 0u:
            if (v42 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_113;
            goto LABEL_116;
          case 1u:
            goto LABEL_117;
          case 2u:
            v43 = v23;
            v24 = v42;
            break;
          case 3u:
            if (v42 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
              goto LABEL_113;
            goto LABEL_116;
          default:
            goto LABEL_112;
        }
        goto LABEL_117;
      }
      if (v41 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        v42 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
        if (v39 <= 3)
          goto LABEL_104;
      }
      else
      {
        v42 = -1;
        if (v39 <= 3)
          goto LABEL_104;
      }
LABEL_112:
      if (MTLReportFailureTypeEnabled())
      {
LABEL_113:
        MTLReportFailure();
        v43 = v23;
      }
      else
      {
LABEL_116:
        v43 = v23;
      }
LABEL_117:
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41 && __p.__r_.__value_.__r.__words[0])
        MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
      ++v105;
      ++v39;
      v23 = v43;
    }
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v103, Rewriter, 0);
    v51 = Rewriter;
    v52 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v100, v51, v52);
    v53 = 0;
    v25 = -1;
    v26 = -1;
    v27 = -1;
    v28 = -1;
    while (1)
    {
      v54 = v103 == v100 && v104 == v101;
      if (v54 && v105 == v102)
        goto LABEL_64;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v103, (llvm::APInt *)&__p);
      v55 = __p.__r_.__value_.__r.__words[1];
      if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
      {
        if (v55 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
        {
          v56 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
          v57 = v53 - 2;
        }
        else
        {
          v56 = -1;
          v57 = v53 - 2;
          if ((v53 - 2) > 3)
          {
LABEL_169:
            if (v55 >= 0x41)
            {
LABEL_170:
              if (__p.__r_.__value_.__r.__words[0])
                MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
            }
            goto LABEL_149;
          }
        }
      }
      else
      {
        v56 = __p.__r_.__value_.__r.__words[0];
        v57 = v53 - 2;
        if ((v53 - 2) > 3)
          goto LABEL_169;
      }
      switch(v57)
      {
        case 0:
          v26 = v56;
          if (v55 >= 0x41)
            goto LABEL_170;
          break;
        case 1:
          v25 = v56;
          if (v55 >= 0x41)
            goto LABEL_170;
          break;
        case 2:
          v28 = v56;
          goto LABEL_169;
        case 3:
          v27 = v56;
          if (v55 >= 0x41)
            goto LABEL_170;
          break;
        default:
          goto LABEL_169;
      }
LABEL_149:
      ++v105;
      ++v53;
    }
  }
  if (StorageType)
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v11 = -1;
    v92 = -1;
    v23 = -1;
    v24 = -1;
    v25 = -1;
    v26 = -1;
    v27 = -1;
    v28 = -1;
LABEL_64:
    v29 = "MPSGraphTensorNamedDataLayoutNHWC";
    goto LABEL_175;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v103, Strides, 0);
  v8 = Strides;
  v9 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Strides);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v100, v8, v9);
  v10 = 0;
  v11 = -1;
  v92 = -1;
  while (1)
  {
    v12 = v103 == v100 && v104 == v101;
    if (v12 && v105 == v102)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v103, (llvm::APInt *)&__p);
    v13 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
    {
      v14 = __p.__r_.__value_.__r.__words[0];
LABEL_14:
      v15 = v14;
      switch(v10)
      {
        case 0u:
          if (v14 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_23;
          goto LABEL_25;
        case 1u:
          if (v14 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_23;
          goto LABEL_25;
        case 2u:
          goto LABEL_26;
        case 3u:
          v15 = v11;
          v92 = v14;
          if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
            goto LABEL_27;
          break;
        default:
          goto LABEL_22;
      }
      goto LABEL_5;
    }
    if (v13 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      v14 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
      if (v10 <= 3)
        goto LABEL_14;
    }
    else
    {
      v14 = -1;
      if (v10 <= 3)
        goto LABEL_14;
    }
LABEL_22:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_23:
      MTLReportFailure();
      v15 = v11;
    }
    else
    {
LABEL_25:
      v15 = v11;
    }
LABEL_26:
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
LABEL_27:
      if (__p.__r_.__value_.__r.__words[0])
        MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
    }
LABEL_5:
    ++v105;
    ++v10;
    v11 = v15;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v103, InputAttributeNames, 0);
  v30 = InputAttributeNames;
  v31 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&InputAttributeNames);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v100, v30, v31);
  v32 = 0;
  v23 = -1;
  v24 = -1;
  while (1)
  {
    v33 = v103 == v100 && v104 == v101;
    if (v33 && v105 == v102)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v103, (llvm::APInt *)&__p);
    v34 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) < 0x41)
    {
      v35 = __p.__r_.__value_.__r.__words[0];
LABEL_75:
      v36 = v35;
      switch(v32)
      {
        case 0u:
          if (v35 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_84;
          goto LABEL_86;
        case 1u:
          if (v35 != 1 && (MTLReportFailureTypeEnabled() & 1) != 0)
            goto LABEL_84;
          goto LABEL_86;
        case 2u:
          goto LABEL_87;
        case 3u:
          v36 = v23;
          v24 = v35;
          if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
            goto LABEL_88;
          break;
        default:
          goto LABEL_83;
      }
      goto LABEL_66;
    }
    if (v34 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      v35 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
      if (v32 <= 3)
        goto LABEL_75;
    }
    else
    {
      v35 = -1;
      if (v32 <= 3)
        goto LABEL_75;
    }
LABEL_83:
    if (MTLReportFailureTypeEnabled())
    {
LABEL_84:
      MTLReportFailure();
      v36 = v23;
    }
    else
    {
LABEL_86:
      v36 = v23;
    }
LABEL_87:
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
LABEL_88:
      if (__p.__r_.__value_.__r.__words[0])
        MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
    }
LABEL_66:
    ++v105;
    ++v32;
    v23 = v36;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v103, Rewriter, 0);
  v44 = Rewriter;
  v45 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&Rewriter);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v100, v44, v45);
  v46 = 0;
  v25 = -1;
  v26 = -1;
  v27 = -1;
  v28 = -1;
  while (1)
  {
    v47 = v103 == v100 && v104 == v101;
    if (v47 && v105 == v102)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v103, (llvm::APInt *)&__p);
    v48 = __p.__r_.__value_.__r.__words[1];
    if (LODWORD(__p.__r_.__value_.__r.__words[1]) >= 0x41)
    {
      if (v48 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
      {
        v49 = *(_QWORD *)__p.__r_.__value_.__l.__data_;
        v50 = v46 - 4;
      }
      else
      {
        v49 = -1;
        v50 = v46 - 4;
        if ((v46 - 4) > 3)
        {
LABEL_143:
          if (v48 >= 0x41)
          {
LABEL_144:
            if (__p.__r_.__value_.__r.__words[0])
              MEMORY[0x186DA165C](__p.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
          }
          goto LABEL_123;
        }
      }
    }
    else
    {
      v49 = __p.__r_.__value_.__r.__words[0];
      v50 = v46 - 4;
      if ((v46 - 4) > 3)
        goto LABEL_143;
    }
    switch(v50)
    {
      case 0:
        v26 = v49;
        if (v48 >= 0x41)
          goto LABEL_144;
        break;
      case 1:
        v25 = v49;
        if (v48 >= 0x41)
          goto LABEL_144;
        break;
      case 2:
        v28 = v49;
        goto LABEL_143;
      case 3:
        v27 = v49;
        if (v48 >= 0x41)
          goto LABEL_144;
        break;
      default:
        goto LABEL_143;
    }
LABEL_123:
    ++v105;
    ++v46;
  }
  v29 = "MPSGraphTensorNamedDataLayoutNCHW";
LABEL_175:
  v84 = v29;
  v58 = (void *)MEMORY[0x1E0CB3940];
  v59 = &v103;
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*a2 + 4))(&v103, a2, v90);
  if (v105 < 0)
    v59 = (_QWORD **)v103;
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)v109);
  if (PaddingStyle >= 5)
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v61 = 0;
  }
  else
  {
    v61 = off_1E0E76A00[PaddingStyle];
  }
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)v109);
  if (WeightsLayout == 2)
  {
    v63 = "MPSGraphTensorNamedDataLayoutOIHW";
  }
  else if (WeightsLayout == 3)
  {
    v63 = "MPSGraphTensorNamedDataLayoutHWIO";
  }
  else
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v63 = 0;
  }
  objc_msgSend(v58, "stringWithFormat:", CFSTR("\n    MPSGraphConvolution2DOpDescriptor *%sConvDescriptor = \n    [MPSGraphConvolution2DOpDescriptor descriptorWithStrideInX:%ld\n                                                     strideInY:%ld\n                                               dilationRateInX:%ld\n                                               dilationRateInY:%ld\n                                                        groups:%ld\n                                                   paddingLeft:%ld\n                                                  paddingRight:%ld\n                                                    paddingTop:%ld\n                                                 paddingBottom:%ld\n                                                  paddingStyle:%s\n                                                    dataLayout:%s\n                                                 weightsLayout:%s];\n    "),
    v59,
    v92,
    v11,
    v24,
    v23,
    v89,
    v28,
    v27,
    v26,
    v25,
    v61,
    v84,
    v63);
  v64 = objc_claimAutoreleasedReturnValue();
  if (SHIBYTE(v105) < 0)
    operator delete(v103);
  v93 = (void *)v64;
  objc_msgSend(a2[27], "stringByAppendingString:", v64);
  v65 = objc_claimAutoreleasedReturnValue();
  v66 = a2[27];
  a2[27] = (id)v65;

  v67 = (void *)MEMORY[0x1E0CB3940];
  v68 = &v103;
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*a2 + 4))(&v103, a2, v90);
  if (v105 < 0)
    v68 = (_QWORD **)v103;
  v69 = (char *)(a2 + 32);
  v99 = Input;
  v100 = &v99;
  v70 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v99, (uint64_t)&std::piecewise_construct, &v100);
  v71 = v70 + 3;
  if (*((char *)v70 + 47) < 0)
    v71 = (_QWORD *)*v71;
  v98 = Filter;
  v100 = &v98;
  v72 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)v69, &v98, (uint64_t)&std::piecewise_construct, &v100);
  v73 = v72 + 3;
  if (*((char *)v72 + 47) < 0)
    v73 = (_QWORD *)*v73;
  v97 = v86;
  v100 = &v97;
  v74 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)v69, &v97, (uint64_t)&std::piecewise_construct, &v100);
  v75 = v74 + 3;
  if (*((char *)v74 + 47) < 0)
    v75 = (_QWORD *)*v75;
  (*((void (**)(uint64_t **__return_ptr, id *, uint64_t))*a2 + 4))(&v100, a2, v90);
  v76 = SHIBYTE(v102);
  v77 = v100;
  v95 = 0;
  LOBYTE(v94) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v90, (uint64_t)&v94, &__p);
  v78 = &v100;
  if (v76 < 0)
    v78 = (uint64_t **)v77;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v67, "stringWithFormat:", CFSTR("\n    MPSGraphTensor *%s = \n    [graph convolutionTranspose2DWithSourceTensor:%s\n                                    weightsTensor:%s\n                                outputShapeTensor:%s\n                                       descriptor:%sConvDescriptor\n                                             name:%s];\n    "),
    v68,
    v71,
    v73,
    v75,
    v78,
    p_p);
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v95 & 0x80000000) == 0)
      goto LABEL_208;
LABEL_212:
    operator delete(v94);
    if (SHIBYTE(v102) < 0)
      goto LABEL_213;
LABEL_209:
    if ((SHIBYTE(v105) & 0x80000000) == 0)
      goto LABEL_210;
LABEL_214:
    operator delete(v103);
    goto LABEL_210;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v95 < 0)
    goto LABEL_212;
LABEL_208:
  if ((SHIBYTE(v102) & 0x80000000) == 0)
    goto LABEL_209;
LABEL_213:
  operator delete(v100);
  if (SHIBYTE(v105) < 0)
    goto LABEL_214;
LABEL_210:
  objc_msgSend(a2[27], "stringByAppendingString:", v80);
  v81 = objc_claimAutoreleasedReturnValue();
  v82 = a2[27];
  a2[27] = (id)v81;

  return v85;
}

void sub_180E304EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{
  void *v30;

  _Unwind_Resume(a1);
}

void sub_180E30504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  uint64_t v42;

  if (a42 < 0)
  {
    operator delete(__p);
    if (a36 < 0)
    {
LABEL_5:
      operator delete(a31);
      if ((*(char *)(v42 - 161) & 0x80000000) == 0)
        goto LABEL_6;
      goto LABEL_9;
    }
  }
  else if (a36 < 0)
  {
    goto LABEL_5;
  }
  if ((*(char *)(v42 - 161) & 0x80000000) == 0)
  {
LABEL_6:
    if (*(char *)(v42 - 129) < 0)
      goto LABEL_7;
    goto LABEL_10;
  }
LABEL_9:
  operator delete(*(void **)(v42 - 184));
  if (*(char *)(v42 - 129) < 0)
  {
LABEL_7:
    operator delete(*(void **)(v42 - 152));

    _Unwind_Resume(a1);
  }
LABEL_10:

  _Unwind_Resume(a1);
}

void sub_180E305E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,int a35)
{
  uint64_t v35;

  if (*(char *)(v35 - 129) < 0)
  {
    operator delete(*(void **)(v35 - 152));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

EmitterObjC::DepthwiseConv3DOpHandler *EmitterObjC::DepthwiseConv3DOpHandler::DepthwiseConv3DOpHandler(EmitterObjC::DepthwiseConv3DOpHandler *this, id *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  uint64_t v6;
  uint64_t ChannelAxis;
  void *v8;
  void **v9;
  uint64_t *v10;
  uint64_t v11;
  void *v12;
  uint64_t *v13;
  uint64_t v14;
  void *v15;
  uint64_t *v16;
  uint64_t v17;
  void *v18;
  unsigned int PaddingStyle;
  char *v20;
  _QWORD **v21;
  void *v22;
  uint64_t v23;
  id v24;
  void *v25;
  void **v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  int v31;
  _QWORD *v32;
  _QWORD **v33;
  std::string *p_p;
  void *v35;
  uint64_t v36;
  id v37;
  _QWORD *AttrData;
  uint64_t v40;
  BOOL v41;
  uint64_t Filter;
  uint64_t Input;
  void *v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *Rewriter;
  uint64_t *InputAttributeNames;
  uint64_t *Strides;
  mlir::Operation *v53;
  std::string __p;
  __int16 v55;
  _QWORD *v56[2];
  const char *v57;
  uint64_t v58;
  __int16 v59;
  void *v60[2];
  char v61;

  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *(_QWORD *)this = &off_1E0E14E70;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v60[0] = *(void **)(v3 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
    if (v40 == 21)
    {
      v41 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v41 && *(_QWORD *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        v59 = 1283;
        v56[0] = "classof on '";
        v57 = "mps.depthwise_conv_3d";
        v58 = 21;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"' failed due to the operation not being registered";
        v55 = 259;
        llvm::operator+((uint64_t *)v56, (uint64_t *)&__p, (uint64_t)v60);
        llvm::report_fatal_error((llvm::Twine *)v60, 1);
      }
    }
LABEL_50:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
    goto LABEL_50;
  v53 = a3;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  v6 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v53);
  Strides = (uint64_t *)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v53);
  InputAttributeNames = (uint64_t *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v53);
  Rewriter = (uint64_t *)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v53);
  ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v53);
  v8 = (void *)MEMORY[0x1E0CB3940];
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(v60, a2, v6);
  if (v61 >= 0)
    v9 = v60;
  else
    v9 = (void **)v60[0];
  v10 = mlir::Attribute::cast<mlir::ElementsAttr>(&Strides);
  EmitterObjC::elementsAttrToObjcArray((uint64_t)v10, v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = mlir::Attribute::cast<mlir::ElementsAttr>(&InputAttributeNames);
  EmitterObjC::elementsAttrToObjcArray((uint64_t)v13, v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = mlir::Attribute::cast<mlir::ElementsAttr>(&Rewriter);
  EmitterObjC::elementsAttrToObjcArray((uint64_t)v16, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v53);
  if (PaddingStyle >= 5)
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v20 = 0;
  }
  else
  {
    v20 = off_1E0E76A00[PaddingStyle];
  }
  (*((void (**)(_QWORD **__return_ptr, id *, uint64_t))*a2 + 4))(v56, a2, v6);
  if (SHIBYTE(v57) >= 0)
    v21 = v56;
  else
    v21 = (_QWORD **)v56[0];
  objc_msgSend(v8, "stringWithFormat:", CFSTR("\n    MPSGraphDepthwiseConvolution3DOpDescriptor *%sDWConvDescriptor = \n    [MPSGraphDepthwiseConvolution3DOpDescriptor descriptorWithStrides:%@\n                                                        dilationRates:%@\n                                                        paddingValues:%@\n                                                         paddingStyle:%s];\n    %sDWConvDescriptor.channelDimensionIndex = %d;\n    "),
    v9,
    v12,
    v15,
    v18,
    v20,
    v21,
    ChannelAxis);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (SHIBYTE(v57) < 0)
  {
    operator delete(v56[0]);

    if ((v61 & 0x80000000) == 0)
      goto LABEL_17;
  }
  else
  {

    if ((v61 & 0x80000000) == 0)
      goto LABEL_17;
  }
  operator delete(v60[0]);
LABEL_17:
  objc_msgSend(a2[27], "stringByAppendingString:", v22);
  v23 = objc_claimAutoreleasedReturnValue();
  v24 = a2[27];
  a2[27] = (id)v23;

  v25 = (void *)MEMORY[0x1E0CB3940];
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(v60, a2, v6);
  if (v61 >= 0)
    v26 = v60;
  else
    v26 = (void **)v60[0];
  v49 = Input;
  v56[0] = &v49;
  v27 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v49, (uint64_t)&std::piecewise_construct, v56);
  v28 = v27 + 3;
  if (*((char *)v27 + 47) < 0)
    v28 = (_QWORD *)*v28;
  v48 = Filter;
  v56[0] = &v48;
  v29 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), &v48, (uint64_t)&std::piecewise_construct, v56);
  v30 = v29 + 3;
  if (*((char *)v29 + 47) < 0)
    v30 = (_QWORD *)*v30;
  (*((void (**)(_QWORD **__return_ptr, id *, uint64_t))*a2 + 4))(v56, a2, v6);
  v31 = SHIBYTE(v57);
  v32 = v56[0];
  v47 = 0;
  LOBYTE(v46) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v6, (uint64_t)&v46, &__p);
  v33 = v56;
  if (v31 < 0)
    v33 = (_QWORD **)v32;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v25, "stringWithFormat:", CFSTR("\n    MPSGraphTensor *%s = \n    [graph depthwiseConvolution3DWithSourceTensor:%s\n                                    weightsTensor:%s\n                                       descriptor:%sDWConvDescriptor\n                                             name:%s];\n    "),
    v26,
    v28,
    v30,
    v33,
    p_p);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v47 & 0x80000000) == 0)
    {
LABEL_31:
      if ((SHIBYTE(v57) & 0x80000000) == 0)
        goto LABEL_32;
LABEL_38:
      operator delete(v56[0]);
      if ((v61 & 0x80000000) == 0)
        goto LABEL_33;
LABEL_39:
      operator delete(v60[0]);
      goto LABEL_33;
    }
  }
  else if ((v47 & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v46);
  if (SHIBYTE(v57) < 0)
    goto LABEL_38;
LABEL_32:
  if (v61 < 0)
    goto LABEL_39;
LABEL_33:
  objc_msgSend(a2[27], "stringByAppendingString:", v35);
  v36 = objc_claimAutoreleasedReturnValue();
  v37 = a2[27];
  a2[27] = (id)v36;

  return this;
}

void sub_180E30B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  void *v37;
  void *v38;

  _Unwind_Resume(a1);
}

void sub_180E30BFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;

  if (*(char *)(v4 - 145) < 0)
    operator delete(*(void **)(v4 - 168));

  if (*(char *)(v4 - 105) < 0)
    operator delete(*(void **)(v4 - 128));
  _Unwind_Resume(a1);
}

id EmitterObjC::elementsAttrToObjcArray(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  void *v5;
  __CFString *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v13;
  uint64_t v14;
  _QWORD v15[5];

  v15[4] = *MEMORY[0x1E0C80C00];
  v13 = v15;
  v14 = 0x400000000;
  mlir::getIntValues<long long>(a1, a2, (uint64_t)&v13, 1);
  v2 = v14;
  if ((_DWORD)v14)
  {
    v3 = (char *)v13;
    objc_msgSend(CFSTR("@["), "stringByAppendingFormat:", CFSTR("@%ld"), *(_QWORD *)v13);
    v4 = objc_claimAutoreleasedReturnValue();
    v5 = (void *)v4;
    if ((_DWORD)v2 == 1)
    {
      v6 = (__CFString *)v4;
    }
    else
    {
      v7 = (uint64_t *)(v3 + 8);
      v8 = 8 * v2 - 8;
      do
      {
        v9 = *v7;
        objc_msgSend(v5, "stringByAppendingString:", CFSTR(", "));
        v10 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(v10, "stringByAppendingFormat:", CFSTR("@%ld"), v9);
        v6 = (__CFString *)objc_claimAutoreleasedReturnValue();

        ++v7;
        v5 = v6;
        v8 -= 8;
      }
      while (v8);
    }
  }
  else
  {
    v6 = CFSTR("@[");
  }
  -[__CFString stringByAppendingString:](v6, "stringByAppendingString:", CFSTR("]"));
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  if (v13 != v15)
    free(v13);
  return v11;
}

{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  void *v5;
  __CFString *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v13;
  uint64_t v14;
  _QWORD v15[5];

  v15[4] = *MEMORY[0x1E0C80C00];
  v13 = v15;
  v14 = 0x400000000;
  mlir::getIntValues<long long>(a1, a2, (uint64_t)&v13, 1);
  v2 = v14;
  if ((_DWORD)v14)
  {
    v3 = (char *)v13;
    objc_msgSend(CFSTR("@["), "stringByAppendingFormat:", CFSTR("@%ld"), *(_QWORD *)v13);
    v4 = objc_claimAutoreleasedReturnValue();
    v5 = (void *)v4;
    if ((_DWORD)v2 == 1)
    {
      v6 = (__CFString *)v4;
    }
    else
    {
      v7 = (uint64_t *)(v3 + 8);
      v8 = 8 * v2 - 8;
      do
      {
        v9 = *v7;
        objc_msgSend(v5, "stringByAppendingString:", CFSTR(", "));
        v10 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(v10, "stringByAppendingFormat:", CFSTR("@%ld"), v9);
        v6 = (__CFString *)objc_claimAutoreleasedReturnValue();

        ++v7;
        v5 = v6;
        v8 -= 8;
      }
      while (v8);
    }
  }
  else
  {
    v6 = CFSTR("@[");
  }
  -[__CFString stringByAppendingString:](v6, "stringByAppendingString:", CFSTR("]"));
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  if (v13 != v15)
    free(v13);
  return v11;
}

void sub_180E30DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  void *v10;

  if (a10 != v10)
  {
    free(a10);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t static_init(uint64_t result)
{
  int *v1;
  unint64_t v2;
  int64_t v3;
  unsigned int v4;

  v1 = &dword_1810DA234;
  v2 = ((char *)&OBJC_CLASS_METHODS_MPSANEWeightFileManager - (char *)&dword_1810DA234) >> 2;
  if (v2)
  {
    if (v2 <= 1)
      v3 = 1;
    else
      v3 = ((char *)&OBJC_CLASS_METHODS_MPSANEWeightFileManager - (char *)&dword_1810DA234) >> 2;
    do
    {
      v4 = *v1++;
      result = ((uint64_t (*)(uint64_t))((char *)&dword_18013D000 + v4))(result);
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t MILToMLIR::SingleGateRNNPattern::matchAndRewrite(MILToMLIR::SingleGateRNNPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t v7;
  const void ***v8;
  const void ***v9;
  const void **v10;
  char v11;
  _DWORD *v12;
  uint64_t IntegerType;
  uint64_t **v14;
  uint64_t InterfaceFor;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  const void **v20;
  const void ***v21;
  void *v22;
  mlir::GenericProgramPoint *v23;
  void *v24;
  uint64_t Value;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t ElementTypeOrSelf;
  uint64_t v31;
  mlir::GenericProgramPoint *v32;
  uint64_t v33;
  mlir::GenericProgramPoint *v34;
  unsigned int v35;
  int v36;
  void **v37;
  int v38;
  int v39;
  BOOL v40;
  _DWORD *v41;
  uint64_t v42;
  uint64_t **v43;
  uint64_t v44;
  const char *v45;
  int v46;
  const char *v47;
  const char *v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t *Context;
  uint64_t v52;
  char v53;
  mlir::GenericProgramPoint *v54;
  uint64_t v55;
  mlir::GenericProgramPoint *v56;
  _DWORD *v57;
  uint64_t v58;
  uint64_t **v59;
  uint64_t v60;
  const char *v61;
  int v62;
  const char *v63;
  const char *v64;
  void *v65;
  mlir::GenericProgramPoint *v66;
  uint64_t *v67;
  uint64_t v68;
  char *v69;
  char *v70;
  uint64_t *v71;
  void **v72;
  void **v73;
  void *v74;
  char *v75;
  char *v76;
  uint64_t *v77;
  void **v78;
  void **v79;
  void *v80;
  const char *v82;
  int v83;
  const char *v84;
  const char *v85;
  const char *v86;
  int v87;
  const char *v88;
  const char *v89;
  std::string v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  std::string v94;
  void *v95[2];
  char v96;
  char **v97;
  char *v98[2];
  uint64_t v99;
  uint64_t OptionalArgValue;
  uint64_t ArgValue;
  mlir::GenericProgramPoint *v102;
  uint64_t v103[4];
  __int16 v104;
  uint64_t v105[4];
  __int16 v106;
  uint64_t *v107[5];
  void *__p[2];
  char v109;
  uint64_t v110;

  v110 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "initial_h");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  v99 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh");
  v8 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v98[0] = 0;
  v98[1] = 0;
  v97 = v98;
  v9 = v8 + 1;
  v10 = *v8;
  if (*v8 != (const void **)(v8 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v97, (uint64_t *)v98, v10 + 4, (uint64_t)(v10 + 4));
      v20 = (const void **)v10[1];
      if (v20)
      {
        do
        {
          v21 = (const void ***)v20;
          v20 = (const void **)*v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          v21 = (const void ***)v10[2];
          v40 = *v21 == v10;
          v10 = (const void **)v21;
        }
        while (!v40);
      }
      v10 = (const void **)v21;
    }
    while (v21 != v9);
  }
  v109 = 9;
  strcpy((char *)__p, "direction");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (v109 < 0)
    operator delete(__p[0]);
  v109 = 10;
  strcpy((char *)__p, "activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (v109 < 0)
    operator delete(__p[0]);
  v109 = 15;
  strcpy((char *)__p, "output_sequence");
  MIL::IROperation::TryGetParameterValue();
  v11 = MIL::IRValue::GetScalar<BOOL>();
  if (v109 < 0)
    operator delete(__p[0]);
  v93 = 0;
  v12 = operator new(4uLL);
  *v12 = 1;
  __p[0] = (void *)1;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v14 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v14))
    goto LABEL_100;
  if (v14)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v14);
    if (!InterfaceFor)
    {
      v16 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v17 = 98;
      v18 = "InterfaceSupport.h";
      v19 = "Interface";
      goto LABEL_104;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v22 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v14, InterfaceFor, v12, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v22))
  {
LABEL_100:
    v16 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v17 = 566;
    v18 = "Casting.h";
    v19 = "cast";
    goto LABEL_104;
  }
  __p[0] = v22;
  v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)__p);
  if (!*((_DWORD *)v23 + 9))
  {
    v16 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v17 = 984;
    v18 = "Operation.h";
    v19 = "getOpResultImpl";
LABEL_104:
    __assert_rtn(v19, v18, v17, v16);
  }
  v93 = (uint64_t)v23 - 16;
  operator delete(v12);
  v24 = (void *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24)
  {
    v82 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v83 = 650;
    v84 = "Casting.h";
    v85 = "dyn_cast";
    goto LABEL_107;
  }
  if (!*(_QWORD *)v24)
  {
    v82 = "abstractType && \"Malformed type storage object.\"";
    v83 = 160;
    v84 = "TypeSupport.h";
    v85 = "getAbstractType";
LABEL_107:
    __assert_rtn(v85, v84, v83, v82);
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v24 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v24 = 0;
  __p[0] = v24;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)__p);
  if (v26 <= 1)
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  v27 = *(_QWORD *)(Value + 8);
  if (v27 == 1)
  {
    v28 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v93);
    if (!*(_DWORD *)(v28 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    ArgValue = v28 - 16;
  }
  LOBYTE(__p[0]) = 0;
  LOBYTE(v107[0]) = 1;
  v29 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 13, LocationForOp, &ArgValue, &v99, (unsigned __int8 *)__p, (unsigned __int8 *)v107);
  v92 = v29;
  if (!*(_DWORD *)(v29 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v91 = v29 - 16;
  if (OptionalArgValue)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(OptionalArgValue);
    if (!*(_DWORD *)(v92 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    if (ElementTypeOrSelf != mlir::getElementTypeOrSelf(v92 - 16))
    {
      if (!*(_DWORD *)(v92 + 36)
        || (v31 = mlir::getElementTypeOrSelf(v92 - 16),
            __p[0] = (void *)mlir::TypeAttr::get(v31),
            v32 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &OptionalArgValue, (uint64_t *)__p), !*((_DWORD *)v32 + 9)))
      {
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      }
      OptionalArgValue = (uint64_t)v32 - 16;
    }
    v33 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MatMulOp &,mlir::Value &>(a3 + 13, LocationForOp, (uint64_t)&v92, &OptionalArgValue);
    if (!*(_DWORD *)(v33 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v91 = v33 - 16;
  }
  if (v27 == 1)
  {
    v34 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v91, &v93);
    if (!*((_DWORD *)v34 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v91 = (uint64_t)v34 - 16;
  }
  if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v90, v94.__r_.__value_.__l.__data_, v94.__r_.__value_.__l.__size_);
  else
    v90 = v94;
  v35 = MILToMLIR::activationStringToAttr((uint64_t)&v90, 1u);
  if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v90.__r_.__value_.__l.__data_);
    v36 = v96;
    if ((v96 & 0x80000000) == 0)
      goto LABEL_47;
LABEL_50:
    if (v95[1] != (void *)7)
      goto LABEL_65;
    v37 = (void **)v95[0];
    goto LABEL_52;
  }
  v36 = v96;
  if (v96 < 0)
    goto LABEL_50;
LABEL_47:
  if (v36 != 7)
    goto LABEL_65;
  v37 = v95;
LABEL_52:
  v38 = *(_DWORD *)v37;
  v39 = *(_DWORD *)((char *)v37 + 3);
  v40 = v38 == 1702258034 && v39 == 1702064741;
  if (!v40)
    goto LABEL_65;
  v41 = operator new(4uLL);
  *v41 = 0;
  __p[0] = (void *)1;
  v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v43 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v42, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v43))
    goto LABEL_122;
  if (v43)
  {
    v44 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v43);
    if (!v44)
    {
      v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v46 = 98;
      v47 = "InterfaceSupport.h";
      v48 = "Interface";
      goto LABEL_123;
    }
  }
  else
  {
    v44 = 0;
  }
  v49 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v43, v44, v41, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v49) & 1) == 0)
  {
LABEL_122:
    v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v46 = 566;
    v47 = "Casting.h";
    v48 = "cast";
LABEL_123:
    __assert_rtn(v48, v47, v46, v45);
  }
  v107[0] = v49;
  __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, v107);
  v50 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v91, (uint64_t)__p);
  if (!*(_DWORD *)(v50 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v91 = v50 - 16;
  operator delete(v41);
LABEL_65:
  v102 = (mlir::GenericProgramPoint *)LocationForOp;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v102);
  v52 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.singlegate_rnn", (const unsigned __int8 *)0x12, Context);
  if (!v53)
  {
    v106 = 1283;
    v105[2] = (uint64_t)"mps.singlegate_rnn";
    v105[3] = 18;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v104 = 259;
    llvm::operator+(v105, v103, (uint64_t)v107);
    llvm::report_fatal_error((llvm::Twine *)v107, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v52);
  mlir::mps::SingleGateRNNOp::build(a3 + 13, (uint64_t)__p, v91, v7, v35, 0, v6, 0);
  v54 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)__p);
  if (!v54)
  {
    v86 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v87 = 662;
    v88 = "Casting.h";
    v89 = "dyn_cast";
    goto LABEL_113;
  }
  v55 = llvm::DefaultDoCastIfPossible<mlir::mps::SingleGateRNNOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SingleGateRNNOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v54);
  if (!v55)
  {
    v86 = "result && \"builder didn't return the right type\"";
    v87 = 497;
    v88 = "Builders.h";
    v89 = "create";
LABEL_113:
    __assert_rtn(v89, v88, v87, v86);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (!*(_DWORD *)(v55 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v105[0] = v55 - 16;
  LODWORD(__p[0]) = 0;
  LODWORD(v107[0]) = -1;
  LODWORD(v102) = 1;
  v56 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, v105, (unsigned int *)__p, (unsigned int *)v107, (unsigned int *)&v102);
  if (!*((_DWORD *)v56 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v103[0] = (uint64_t)v56 - 16;
  v57 = operator new(4uLL);
  *v57 = 0;
  __p[0] = (void *)1;
  v58 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v59 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v58, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v59))
    goto LABEL_101;
  if (v59)
  {
    v60 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v59);
    if (!v60)
    {
      v61 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v62 = 98;
      v63 = "InterfaceSupport.h";
      v64 = "Interface";
      goto LABEL_102;
    }
  }
  else
  {
    v60 = 0;
  }
  v65 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v59, v60, v57, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v65) & 1) == 0)
  {
LABEL_101:
    v61 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v62 = 566;
    v63 = "Casting.h";
    v64 = "cast";
LABEL_102:
    __assert_rtn(v64, v63, v62, v61);
  }
  __p[0] = v65;
  v102 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)__p);
  v66 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, v103, &v102);
  if (!*((_DWORD *)v66 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  if ((v11 & 1) == 0)
    v105[0] = v103[0];
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
  v67 = (uint64_t *)__p[0];
  v68 = v105[0];
  v69 = (char *)operator new(8uLL);
  *(_QWORD *)v69 = v68;
  v70 = (char *)(a3 + 8);
  v107[0] = v67;
  v71 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v70, (uint64_t)v67, (uint64_t)&std::piecewise_construct, (__int128 **)v107);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v71 + 5, v69, v69 + 8, 1uLL);
  operator delete(v69);
  v72 = (void **)__p[0];
  if (__p[0])
  {
    v73 = (void **)__p[1];
    v74 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v73 - 1) < 0)
          operator delete(*(v73 - 3));
        v73 -= 3;
      }
      while (v73 != v72);
      v74 = __p[0];
    }
    __p[1] = v72;
    operator delete(v74);
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
  v75 = (char *)__p[0];
  v76 = (char *)operator new(8uLL);
  *(_QWORD *)v76 = (char *)v66 - 16;
  v107[0] = (uint64_t *)(v75 + 24);
  v77 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v70, (uint64_t)(v75 + 24), (uint64_t)&std::piecewise_construct, (__int128 **)v107);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v77 + 5, v76, v76 + 8, 1uLL);
  operator delete(v76);
  v78 = (void **)__p[0];
  if (__p[0])
  {
    v79 = (void **)__p[1];
    v80 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v79 - 1) < 0)
          operator delete(*(v79 - 3));
        v79 -= 3;
      }
      while (v79 != v78);
      v80 = __p[0];
    }
    __p[1] = v78;
    operator delete(v80);
  }
  operator delete(v57);
  if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v94.__r_.__value_.__l.__data_);
    if ((v96 & 0x80000000) == 0)
      goto LABEL_97;
LABEL_99:
    operator delete(v95[0]);
    goto LABEL_97;
  }
  if (v96 < 0)
    goto LABEL_99;
LABEL_97:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v97, v98[0]);
  return 1;
}

void sub_180E31AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28,char *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a28, a29);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.squeeze";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::SqueezeOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::SqueezeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SqueezeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E31DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E31E0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MatMulOp &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.add";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *(_QWORD *)a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E31FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E31FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::activationStringToAttr(uint64_t a1, unsigned __int8 a2)
{
  int *v2;
  int v3;
  uint64_t result;
  uint64_t v5;
  int *v6;
  int v7;
  int v8;
  uint64_t v10;
  int *v11;
  int v12;
  int v13;
  unint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;

  v2 = (int *)a1;
  v3 = *(char *)(a1 + 23);
  if (v3 < 0)
  {
    result = 0;
    v5 = *((_QWORD *)v2 + 1);
    switch(v5)
    {
      case 4:
        v6 = *(int **)v2;
        if (*v6 == 1970038130)
        {
LABEL_21:
          result = 1;
        }
        else
        {
          if (*v6 != 1752064372)
            goto LABEL_47;
          result = 2;
        }
        break;
      case 6:
        v11 = *(int **)v2;
        v12 = *v11;
        v13 = *((unsigned __int16 *)v11 + 2);
        if (v12 != 1701734764 || v13 != 29281)
          goto LABEL_47;
        result = 0;
        break;
      case 7:
        if (**(_DWORD **)v2 == 1835493747 && *(_DWORD *)(*(_QWORD *)v2 + 3) == 1684631405)
        {
LABEL_42:
          result = 3;
        }
        else
        {
          if (v5 == 12)
            goto LABEL_33;
LABEL_20:
          result = 0;
        }
        break;
      case 11:
        v19 = **(_QWORD **)v2 ^ 0x745F64656C616373 | *(_QWORD *)(*(_QWORD *)v2 + 3) ^ 0x686E61745F64656CLL;
        if (((v19 == 0) & a2) != 0)
          result = 2;
        else
          result = 5;
        if (v19)
LABEL_47:
          result = 0;
        break;
      case 12:
LABEL_33:
        v2 = *(int **)v2;
LABEL_34:
        v16 = 0x686172645F736967;
        v17 = bswap64(*(_QWORD *)v2);
        if (v17 == 0x686172645F736967 && (v16 = 1836018020, v17 = bswap32(v2[2]), (_DWORD)v17 == 1836018020))
        {
          v18 = 0;
        }
        else if (v17 < v16)
        {
          v18 = -1;
        }
        else
        {
          v18 = 1;
        }
        result = 4 * (v18 == 0);
        break;
      default:
        return result;
    }
  }
  else
  {
    result = 0;
    switch((char)v3)
    {
      case 4:
        if (*v2 == 1970038130)
          goto LABEL_21;
        if (*v2 != 1752064372)
          goto LABEL_20;
        result = 2;
        break;
      case 7:
        v7 = *v2;
        v8 = *(int *)((char *)v2 + 3);
        if (v7 != 1835493747 || v8 != 1684631405)
          goto LABEL_20;
        goto LABEL_42;
      case 11:
        v10 = *(_QWORD *)v2 ^ 0x745F64656C616373 | *(_QWORD *)((char *)v2 + 3) ^ 0x686E61745F64656CLL;
        if (((v10 == 0) & a2) != 0)
          result = 2;
        else
          result = 5;
        if (v10)
          goto LABEL_20;
        return result;
      case 12:
        goto LABEL_34;
      default:
        return result;
    }
  }
  return result;
}

uint64_t MILToMLIR::LSTMPattern::matchAndRewrite(MILToMLIR::LSTMPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void ***v7;
  const void **v8;
  uint64_t *v9;
  int v10;
  void **v11;
  const void **v12;
  const void ***v13;
  void *v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  uint64_t *v22;
  mlir::GenericProgramPoint *v23;
  _DWORD *v24;
  uint64_t IntegerType;
  uint64_t **v26;
  uint64_t InterfaceFor;
  const char *v28;
  int v29;
  const char *v30;
  const char *v31;
  uint64_t *v32;
  mlir::GenericProgramPoint *v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  uint64_t *v39;
  mlir::GenericProgramPoint *v40;
  uint64_t *v41;
  uint64_t Value;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  size_t v53;
  char v54;
  uint64_t *v55;
  int64_t v56;
  _BYTE *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  mlir::GenericProgramPoint *v65;
  mlir::GenericProgramPoint *v66;
  void **v67;
  int v68;
  int v69;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  mlir::Float32Type *Context;
  mlir::MLIRContext *v90;
  uint64_t v91;
  uint64_t *v92;
  mlir::GenericProgramPoint *v93;
  _DWORD *v94;
  uint64_t v95;
  uint64_t **v96;
  uint64_t v97;
  const char *v98;
  int v99;
  const char *v100;
  const char *v101;
  uint64_t *v102;
  mlir::GenericProgramPoint *v103;
  uint64_t *v104;
  uint64_t v105;
  char v106;
  mlir::GenericProgramPoint *v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  mlir::GenericProgramPoint *v114;
  mlir::GenericProgramPoint *v115;
  uint64_t v116;
  int v117;
  mlir::GenericProgramPoint *v118;
  mlir::GenericProgramPoint *v119;
  char *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t *v124;
  uint64_t v125;
  _QWORD *v126;
  uint64_t v127;
  _QWORD *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  _DWORD *v132;
  uint64_t v133;
  uint64_t **v134;
  uint64_t v135;
  const char *v136;
  int v137;
  const char *v138;
  const char *v139;
  uint64_t *v140;
  mlir::GenericProgramPoint *v141;
  mlir::GenericProgramPoint *v142;
  uint64_t *v143;
  uint64_t v144;
  char *v145;
  char *v146;
  uint64_t *v147;
  uint64_t *v148;
  uint64_t *v149;
  uint64_t *v150;
  uint64_t *v151;
  char *v152;
  uint64_t *v153;
  uint64_t *v154;
  uint64_t *v155;
  uint64_t *v156;
  uint64_t *v157;
  char *v158;
  uint64_t *v159;
  uint64_t *v160;
  uint64_t *v161;
  uint64_t *v162;
  uint64_t v164;
  const char *v165;
  int v166;
  const char *v167;
  const char *v168;
  const char *v169;
  int v170;
  const char *v171;
  const char *v172;
  const char *v173;
  int v174;
  const char *v175;
  const char *v176;
  const char *v177;
  int v178;
  const char *v179;
  const char *v180;
  uint64_t v181;
  char v182;
  int v183;
  unsigned __int8 v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  std::string v189;
  unsigned int v190;
  std::string v191;
  unsigned int v192;
  std::string v193;
  unsigned int v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  std::string v207;
  std::string v208;
  std::string v209;
  void **v210;
  uint64_t v211;
  char v212;
  char **v213;
  char *v214[2];
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t OptionalArgValue;
  uint64_t v220;
  uint64_t v221;
  uint64_t ArgValue;
  uint64_t v223;
  uint64_t v224[4];
  __int16 v225;
  mlir::GenericProgramPoint *v226;
  mlir::GenericProgramPoint *v227;
  const char *v228;
  uint64_t v229;
  __int16 v230;
  uint64_t *v231[38];
  _BYTE __src[24];
  uint64_t v233;

  v233 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v221 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "initial_h");
  v220 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "initial_c");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  v218 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih");
  v217 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh");
  v216 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "peephole");
  v215 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "clip");
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v214[0] = 0;
  v214[1] = 0;
  v213 = v214;
  v7 = v6 + 1;
  v8 = *v6;
  if (*v6 != (const void **)(v6 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v213, (uint64_t *)v214, v8 + 4, (uint64_t)(v8 + 4));
      v12 = (const void **)v8[1];
      if (v12)
      {
        do
        {
          v13 = (const void ***)v12;
          v12 = (const void **)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (const void ***)v8[2];
          v16 = *v13 == v8;
          v8 = (const void **)v13;
        }
        while (!v16);
      }
      v8 = (const void **)v13;
    }
    while (v13 != v7);
  }
  HIBYTE(v231[2]) = 9;
  strcpy((char *)v231, "direction");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (SHIBYTE(v231[2]) < 0)
    operator delete(v231[0]);
  HIBYTE(v231[2]) = 10;
  strcpy((char *)v231, "activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (SHIBYTE(v231[2]) < 0)
    operator delete(v231[0]);
  HIBYTE(v231[2]) = 20;
  strcpy((char *)v231, "recurrent_activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (SHIBYTE(v231[2]) < 0)
    operator delete(v231[0]);
  HIBYTE(v231[2]) = 15;
  strcpy((char *)v231, "cell_activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  if (SHIBYTE(v231[2]) < 0)
    operator delete(v231[0]);
  HIBYTE(v231[2]) = 15;
  strcpy((char *)v231, "output_sequence");
  MIL::IROperation::TryGetParameterValue();
  v182 = MIL::IRValue::GetScalar<BOOL>();
  if (SHIBYTE(v231[2]) < 0)
  {
    operator delete(v231[0]);
    v9 = (uint64_t *)(a3 + 13);
    v10 = v212;
    if ((v212 & 0x80000000) == 0)
    {
LABEL_12:
      if (v10 == 13)
      {
        v11 = (void **)&v210;
LABEL_24:
        v14 = *v11;
        v15 = *(uint64_t *)((char *)v11 + 5);
        v16 = v14 == (void *)0x7463657269646962 && v15 == 0x6C616E6F69746365;
        v17 = v16;
        v183 = v17;
        goto LABEL_32;
      }
      goto LABEL_31;
    }
  }
  else
  {
    v9 = (uint64_t *)(a3 + 13);
    v10 = v212;
    if ((v212 & 0x80000000) == 0)
      goto LABEL_12;
  }
  if (v211 == 13)
  {
    v11 = v210;
    goto LABEL_24;
  }
LABEL_31:
  v183 = 0;
LABEL_32:
  v205 = 0;
  v206 = 0;
  v203 = 0;
  v204 = 0;
  v202 = 0;
  v18 = mlir::IntegerType::get(*v9, 0x20u, 1u);
  v19 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v18, 0);
  v231[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v19, 0);
  v20 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v20 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v201 = (uint64_t)v20 - 16;
  v21 = mlir::IntegerType::get(*v9, 0x20u, 1u);
  v22 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v21, 0);
  v231[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v22, -1);
  v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v23 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v199 = 0;
  v200 = (uint64_t)v23 - 16;
  v198 = 0;
  v24 = operator new(4uLL);
  *v24 = 0;
  v231[0] = (uint64_t *)1;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v9, 0x20u, 1);
  v26 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v231, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26))
    goto LABEL_223;
  if (v26)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!InterfaceFor)
    {
      v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v29 = 98;
      v30 = "InterfaceSupport.h";
      v31 = "Interface";
      goto LABEL_230;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v32 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v26, InterfaceFor, v24, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v32))
  {
LABEL_223:
    v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v29 = 566;
    v30 = "Casting.h";
    v31 = "cast";
    goto LABEL_230;
  }
  v231[0] = v32;
  v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v33 + 9))
  {
    v28 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v29 = 984;
    v30 = "Operation.h";
    v31 = "getOpResultImpl";
LABEL_230:
    __assert_rtn(v31, v30, v29, v28);
  }
  v199 = (uint64_t)v33 - 16;
  *v24 = 1;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26))
    goto LABEL_224;
  if (v26)
  {
    v34 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!v34)
    {
      v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v36 = 98;
      v37 = "InterfaceSupport.h";
      v38 = "Interface";
      goto LABEL_232;
    }
  }
  else
  {
    v34 = 0;
  }
  v39 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v26, v34, v24, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v39))
  {
LABEL_224:
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
    goto LABEL_232;
  }
  v231[0] = v39;
  v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v40 + 9))
  {
    v35 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v36 = 984;
    v37 = "Operation.h";
    v38 = "getOpResultImpl";
LABEL_232:
    __assert_rtn(v38, v37, v36, v35);
  }
  v198 = (uint64_t)v40 - 16;
  operator delete(v24);
  v41 = (uint64_t *)(*(_QWORD *)(v217 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v41)
  {
    v165 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v166 = 650;
    v167 = "Casting.h";
    v168 = "dyn_cast";
    goto LABEL_235;
  }
  if (!*v41)
  {
    v165 = "abstractType && \"Malformed type storage object.\"";
    v166 = 160;
    v167 = "TypeSupport.h";
    v168 = "getAbstractType";
LABEL_235:
    __assert_rtn(v168, v167, v166, v165);
  }
  if (*(_UNKNOWN **)(*v41 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v41 = 0;
  v231[0] = v41;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v231);
  v181 = 0;
  v44 = 0;
  v197 = 0;
  if (!v183)
    goto LABEL_81;
  if (v43 <= 1)
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  v44 = *(_QWORD *)(Value + 8);
  v197 = v44;
  v45 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias_back");
  v46 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih_back");
  v205 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh_back");
  v181 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "peephole_back");
  v204 = v181;
  v47 = v218;
  v48 = (uint64_t *)operator new(0x10uLL);
  v231[1] = v48 + 2;
  v231[2] = v48 + 2;
  *v48 = v47;
  v48[1] = v46;
  v231[0] = v48;
  __src[0] = 0;
  v49 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v201, __src);
  if (!*(_DWORD *)(v49 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v218 = v49 - 16;
  if (!OptionalArgValue)
  {
LABEL_78:
    v54 = 1;
    v55 = v231[0];
    if (!v231[0])
      goto LABEL_80;
    goto LABEL_79;
  }
  if (v45)
  {
    *(_QWORD *)__src = OptionalArgValue;
    *(_QWORD *)&__src[8] = v45;
    v50 = (uint64_t)v231[2];
    v45 = (uint64_t)v231[0];
    if ((uint64_t *)((char *)v231[2] - (char *)v231[0]) >= (uint64_t *)0x10)
    {
      v56 = (char *)v231[1] - (char *)v231[0];
      if ((uint64_t *)((char *)v231[1] - (char *)v231[0]) > (uint64_t *)0xF)
      {
        *(_OWORD *)v231[0] = *(_OWORD *)__src;
        v53 = 16;
      }
      else
      {
        v57 = &__src[v56];
        if (v231[1] != v231[0])
        {
          memcpy(v231[0], __src, (char *)v231[1] - (char *)v231[0]);
          v45 = (uint64_t)v231[1];
        }
        v53 = 16 - v56;
        memcpy((void *)v45, v57, v53);
      }
    }
    else
    {
      if (v231[0])
      {
        v231[1] = v231[0];
        operator delete(v231[0]);
        v50 = 0;
        memset(v231, 0, 24);
      }
      v51 = v50 >> 2;
      if ((unint64_t)(v50 >> 2) <= 2)
        v51 = 2;
      if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8)
        v52 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v52 = v51;
      if (v52 >> 61)
        std::vector<long>::__throw_length_error[abi:ne180100]();
      v45 = (uint64_t)operator new(8 * v52);
      v231[0] = (uint64_t *)v45;
      v231[2] = (uint64_t *)(v45 + 8 * v52);
      *(_OWORD *)v45 = *(_OWORD *)__src;
      v53 = 16;
    }
    v231[1] = (uint64_t *)(v45 + v53);
    __src[0] = 0;
    v58 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v201, __src);
    if (!*(_DWORD *)(v58 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    OptionalArgValue = v58 - 16;
    goto LABEL_78;
  }
  *(_QWORD *)__src = operator new(0x50uLL);
  *(_OWORD *)&__src[8] = xmmword_1812877E0;
  v45 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __src);
  if ((__src[23] & 0x80000000) != 0)
    operator delete(*(void **)__src);
  v54 = 0;
  v55 = v231[0];
  if (v231[0])
  {
LABEL_79:
    v231[1] = v55;
    operator delete(v55);
  }
LABEL_80:
  if ((v54 & 1) == 0)
    goto LABEL_211;
LABEL_81:
  v59 = (uint64_t *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v59)
  {
    v169 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v170 = 650;
    v171 = "Casting.h";
    v172 = "dyn_cast";
    goto LABEL_240;
  }
  if (!*v59)
  {
    v169 = "abstractType && \"Malformed type storage object.\"";
    v170 = 160;
    v171 = "TypeSupport.h";
    v172 = "getAbstractType";
LABEL_240:
    __assert_rtn(v172, v171, v170, v169);
  }
  if (*(_UNKNOWN **)(*v59 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v59 = 0;
  v231[0] = v59;
  v60 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v231);
  if (v61 <= 1)
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  v62 = *(_QWORD *)(v60 + 8);
  if (v62 == 1)
  {
    v63 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &ArgValue, &v198);
    if (!*(_DWORD *)(v63 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    ArgValue = v63 - 16;
  }
  LOBYTE(v231[0]) = 0;
  __src[0] = 1;
  v64 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::BoolAttr **)v9, LocationForOp, &ArgValue, &v218, (unsigned __int8 *)v231, __src);
  if (!*(_DWORD *)(v64 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v195 = v64 - 16;
  v196 = v64 - 16;
  if (OptionalArgValue)
  {
    v65 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v9, LocationForOp, &v196, &OptionalArgValue);
    if (!*((_DWORD *)v65 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v195 = (uint64_t)v65 - 16;
  }
  if (v62 == 1)
  {
    v66 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &v195, &v198);
    if (!*((_DWORD *)v66 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v195 = (uint64_t)v66 - 16;
  }
  if (v212 < 0)
  {
    if (v211 != 7)
      goto LABEL_105;
    v67 = v210;
  }
  else
  {
    if (v212 != 7)
      goto LABEL_105;
    v67 = (void **)&v210;
  }
  v68 = *(_DWORD *)v67;
  v69 = *(_DWORD *)((char *)v67 + 3);
  if (v68 != 1702258034 || v69 != 1702064741)
  {
LABEL_105:
    if (!v183)
      goto LABEL_114;
    goto LABEL_106;
  }
  v164 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &v195, &v199);
  if (!*(_DWORD *)(v164 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v195 = v164 - 16;
  if (v183)
  {
LABEL_106:
    LODWORD(v226) = -1;
    v231[0] = (uint64_t *)(4 * v44);
    *(_QWORD *)__src = 4 * v44;
    v71 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long,long long>((mlir::mps::ConstantOp *)v9, LocationForOp, &v195, (unsigned int *)&v226, (unsigned int *)v231, (unsigned int *)__src);
    if (!*(_DWORD *)(v71 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v206 = v71 - 16;
    v72 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &v206, &v199);
    if (!*(_DWORD *)(v72 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v206 = v72 - 16;
    *(_DWORD *)__src = -1;
    LODWORD(v226) = 0;
    v231[0] = (uint64_t *)(4 * v44);
    v73 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long>((mlir::mps::ConstantOp *)v9, LocationForOp, &v195, (unsigned int *)__src, (unsigned int *)&v226, (unsigned int *)v231);
    if (!*(_DWORD *)(v73 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v195 = v73 - 16;
    LODWORD(v231[0]) = -1;
    v74 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long &,long long &>((mlir::mps::ConstantOp *)v9, LocationForOp, &v221, (unsigned int *)v231, (unsigned int *)&v197, (unsigned int *)&v197);
    if (!*(_DWORD *)(v74 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v203 = v74 - 16;
    LODWORD(v231[0]) = -1;
    v75 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long &,long long &>((mlir::mps::ConstantOp *)v9, LocationForOp, &v220, (unsigned int *)v231, (unsigned int *)&v197, (unsigned int *)&v197);
    if (!*(_DWORD *)(v75 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v202 = v75 - 16;
    LODWORD(v231[0]) = -1;
    *(_DWORD *)__src = 0;
    v76 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long &>((mlir::mps::ConstantOp *)v9, LocationForOp, &v221, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v197);
    if (!*(_DWORD *)(v76 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v221 = v76 - 16;
    LODWORD(v231[0]) = -1;
    *(_DWORD *)__src = 0;
    v77 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long &>((mlir::mps::ConstantOp *)v9, LocationForOp, &v220, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v197);
    if (!*(_DWORD *)(v77 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v220 = v77 - 16;
  }
LABEL_114:
  if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v193, v209.__r_.__value_.__l.__data_, v209.__r_.__value_.__l.__size_);
  else
    v193 = v209;
  v78 = MILToMLIR::activationStringToAttr((uint64_t)&v193, 1u);
  v79 = v78;
  if (SHIBYTE(v193.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v193.__r_.__value_.__l.__data_);
    v194 = v79;
    if ((SHIBYTE(v208.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_119;
  }
  else
  {
    v194 = v78;
    if ((SHIBYTE(v208.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_119:
      v191 = v208;
      goto LABEL_122;
    }
  }
  std::string::__init_copy_ctor_external(&v191, v208.__r_.__value_.__l.__data_, v208.__r_.__value_.__l.__size_);
LABEL_122:
  v80 = MILToMLIR::activationStringToAttr((uint64_t)&v191, 1u);
  v81 = v80;
  if (SHIBYTE(v191.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v191.__r_.__value_.__l.__data_);
    v192 = v81;
    if ((SHIBYTE(v207.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_124;
  }
  else
  {
    v192 = v80;
    if ((SHIBYTE(v207.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_124:
      v189 = v207;
      goto LABEL_127;
    }
  }
  std::string::__init_copy_ctor_external(&v189, v207.__r_.__value_.__l.__data_, v207.__r_.__value_.__l.__size_);
LABEL_127:
  v82 = MILToMLIR::activationStringToAttr((uint64_t)&v189, 1u);
  v83 = v82;
  if (SHIBYTE(v189.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v189.__r_.__value_.__l.__data_);
    v190 = v83;
    v84 = v216;
    if (!v216)
      goto LABEL_155;
  }
  else
  {
    v190 = v82;
    v84 = v216;
    if (!v216)
      goto LABEL_155;
  }
  v85 = (uint64_t *)(*(_QWORD *)(v84 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v85)
  {
    v173 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v174 = 650;
    v175 = "Casting.h";
    v176 = "dyn_cast";
    goto LABEL_254;
  }
  if (!*v85)
  {
    v173 = "abstractType && \"Malformed type storage object.\"";
    v174 = 160;
    v175 = "TypeSupport.h";
    v176 = "getAbstractType";
LABEL_254:
    __assert_rtn(v176, v175, v174, v173);
  }
  if (*(_UNKNOWN **)(*v85 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v85 = 0;
  v231[0] = v85;
  v86 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v231);
  if (!v87)
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  v88 = *v86;
  v231[0] = (uint64_t *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  Context = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)v231);
  v91 = mlir::Float32Type::get(Context, v90);
  v231[0] = (uint64_t *)1;
  v92 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v231, 1, v91, 0);
  v231[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v92, 0);
  v93 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  if (!*((_DWORD *)v93 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v94 = operator new(4uLL);
  *v94 = (int)v88 / 3;
  v231[0] = (uint64_t *)1;
  v95 = mlir::Builder::getIntegerType((mlir::Builder *)v9, 0x20u, 1);
  v96 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v231, 1, v95, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v96))
    goto LABEL_236;
  if (v96)
  {
    v97 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v96);
    if (!v97)
    {
      v98 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v99 = 98;
      v100 = "InterfaceSupport.h";
      v101 = "Interface";
      goto LABEL_237;
    }
  }
  else
  {
    v97 = 0;
  }
  v102 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v96, v97, v94, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v102) & 1) == 0)
  {
LABEL_236:
    v98 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v99 = 566;
    v100 = "Casting.h";
    v101 = "cast";
LABEL_237:
    __assert_rtn(v101, v100, v99, v98);
  }
  v231[0] = v102;
  v103 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  v223 = LocationForOp;
  v104 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v223);
  v105 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, v104);
  if (!v106)
  {
    v230 = 1283;
    v228 = "mps.broadcast_to";
    v229 = 16;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v225 = 259;
    llvm::operator+((uint64_t *)&v226, v224, (uint64_t)__src);
    llvm::report_fatal_error((llvm::Twine *)__src, 1);
  }
  mlir::OperationState::OperationState(v231, LocationForOp, v105);
  if (!*((_DWORD *)v103 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::BroadcastToOp::build((uint64_t)v9, (uint64_t)v231, (uint64_t)v93 - 16, (uint64_t)v103 - 16);
  v107 = mlir::OpBuilder::create((mlir::OpBuilder *)v9, (const mlir::OperationState *)v231);
  if (!v107)
  {
    v177 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v178 = 662;
    v179 = "Casting.h";
    v180 = "dyn_cast";
    goto LABEL_261;
  }
  v108 = llvm::DefaultDoCastIfPossible<mlir::mps::BroadcastToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BroadcastToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v107);
  if (!v108)
  {
    v177 = "result && \"builder didn't return the right type\"";
    v178 = 497;
    v179 = "Builders.h";
    v180 = "create";
LABEL_261:
    __assert_rtn(v180, v179, v178, v177);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v231);
  if (!*(_DWORD *)(v108 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v109 = (uint64_t *)operator new(0x10uLL);
  v231[1] = v109 + 2;
  v231[2] = v109 + 2;
  *v109 = v84;
  v109[1] = v108 - 16;
  v231[0] = v109;
  __src[0] = 0;
  v110 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v201, __src);
  if (!*(_DWORD *)(v110 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v216 = v110 - 16;
  if (v183)
  {
    *v231[0] = v181;
    __src[0] = 0;
    v111 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v201, __src);
    if (!*(_DWORD *)(v111 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v204 = v111 - 16;
  }
  if (v231[0])
  {
    v231[1] = v231[0];
    operator delete(v231[0]);
  }
  operator delete(v94);
LABEL_155:
  LODWORD(v231[0]) = 2;
  __src[0] = 0;
  v112 = mlir::OpBuilder::create<mlir::mps::LSTMOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::LSTMGateLayout,BOOL,mlir::Value &,mlir::Value &,decltype(nullptr),mlir::Value &,mlir::Value &>((mlir::UnitAttr **)v9, LocationForOp, &v195, &v217, &v192, &v192, &v190, &v192, &v194, (unsigned int *)v231, __src, &v221, &v220, &v216, (_BOOL8 *)&v215);
  v113 = *(_DWORD *)(v112 + 36);
  if (!v113)
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v224[0] = v112 - 16;
  if (v113 == 1)
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v223 = v112 - 32;
  LODWORD(v231[0]) = 0;
  *(_DWORD *)__src = -1;
  LODWORD(v226) = 1;
  v114 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v9, LocationForOp, v224, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v226);
  if (!*((_DWORD *)v114 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v188 = (uint64_t)v114 - 16;
  LODWORD(v231[0]) = 0;
  *(_DWORD *)__src = -1;
  LODWORD(v226) = 1;
  v115 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v9, LocationForOp, &v223, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v226);
  if (!*((_DWORD *)v115 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v187 = (uint64_t)v115 - 16;
  if ((v182 & 1) == 0)
    v224[0] = v188;
  if (v183)
  {
    LODWORD(v231[0]) = 2;
    __src[0] = 0;
    v116 = mlir::OpBuilder::create<mlir::mps::LSTMOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::LSTMGateLayout,BOOL,mlir::Value &,mlir::Value &,decltype(nullptr),mlir::Value &,mlir::Value &>((mlir::UnitAttr **)v9, LocationForOp, &v206, &v205, &v192, &v192, &v190, &v192, &v194, (unsigned int *)v231, __src, &v203, &v202, &v204, (_BOOL8 *)&v215);
    v117 = *(_DWORD *)(v116 + 36);
    if (!v117)
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v186 = v116 - 16;
    if (v117 == 1)
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v185 = v116 - 32;
    LODWORD(v231[0]) = 0;
    *(_DWORD *)__src = -1;
    LODWORD(v226) = 1;
    v118 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v9, LocationForOp, &v186, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v226);
    if (!*((_DWORD *)v118 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    LODWORD(v231[0]) = 0;
    *(_DWORD *)__src = -1;
    LODWORD(v226) = 1;
    v119 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v9, LocationForOp, &v185, (unsigned int *)v231, (unsigned int *)__src, (unsigned int *)&v226);
    if (!*((_DWORD *)v119 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v120 = (char *)v118 - 16;
    v121 = (uint64_t)v120;
    if ((v182 & 1) != 0)
    {
      v122 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v9, LocationForOp, &v186, &v199);
      if (!*(_DWORD *)(v122 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v121 = v122 - 16;
    }
    v186 = v121;
    v123 = v224[0];
    v124 = (uint64_t *)operator new(0x10uLL);
    v231[1] = v124 + 2;
    v231[2] = v124 + 2;
    *v124 = v123;
    v124[1] = v121;
    v231[0] = v124;
    v125 = v188;
    v126 = operator new(0x10uLL);
    *(_QWORD *)&__src[8] = v126 + 2;
    *(_QWORD *)&__src[16] = v126 + 2;
    *v126 = v125;
    v126[1] = v120;
    *(_QWORD *)__src = v126;
    v127 = v187;
    v128 = operator new(0x10uLL);
    v227 = (mlir::GenericProgramPoint *)(v128 + 2);
    v228 = (const char *)(v128 + 2);
    *v128 = v127;
    v128[1] = (char *)v119 - 16;
    v226 = (mlir::GenericProgramPoint *)v128;
    v184 = 0;
    v129 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)v231, &v200, &v184);
    if (!*(_DWORD *)(v129 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v224[0] = v129 - 16;
    v184 = 0;
    v130 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)__src, &v200, &v184);
    if (!*(_DWORD *)(v130 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v188 = v130 - 16;
    v184 = 0;
    v131 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v9, LocationForOp, (uint64_t *)&v226, &v200, &v184);
    if (!*(_DWORD *)(v131 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v187 = v131 - 16;
    if (v226)
    {
      v227 = v226;
      operator delete(v226);
    }
    if (*(_QWORD *)__src)
    {
      *(_QWORD *)&__src[8] = *(_QWORD *)__src;
      operator delete(*(void **)__src);
    }
    if (v231[0])
    {
      v231[1] = v231[0];
      operator delete(v231[0]);
    }
  }
  v132 = operator new(4uLL);
  *v132 = 0;
  v231[0] = (uint64_t *)1;
  v133 = mlir::Builder::getIntegerType((mlir::Builder *)v9, 0x20u, 1);
  v134 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v231, 1, v133, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v134))
    goto LABEL_225;
  if (v134)
  {
    v135 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v134);
    if (!v135)
    {
      v136 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v137 = 98;
      v138 = "InterfaceSupport.h";
      v139 = "Interface";
      goto LABEL_226;
    }
  }
  else
  {
    v135 = 0;
  }
  v140 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v134, v135, v132, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v140) & 1) == 0)
  {
LABEL_225:
    v136 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v137 = 566;
    v138 = "Casting.h";
    v139 = "cast";
LABEL_226:
    __assert_rtn(v139, v138, v137, v136);
  }
  v231[0] = v140;
  v226 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v9, LocationForOp, v231);
  v141 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)v9, LocationForOp, &v188, &v226);
  if (!*((_DWORD *)v141 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v142 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)v9, LocationForOp, &v187, &v226);
  if (!*((_DWORD *)v142 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v231, a2);
  v143 = v231[0];
  v144 = v224[0];
  v145 = (char *)operator new(8uLL);
  *(_QWORD *)v145 = v144;
  v146 = (char *)(a3 + 8);
  *(_QWORD *)__src = v143;
  v147 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v146, (uint64_t)v143, (uint64_t)&std::piecewise_construct, (__int128 **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v147 + 5, v145, v145 + 8, 1uLL);
  operator delete(v145);
  v148 = v231[0];
  if (v231[0])
  {
    v149 = v231[1];
    v150 = v231[0];
    if (v231[1] != v231[0])
    {
      do
      {
        if (*((char *)v149 - 1) < 0)
          operator delete((void *)*(v149 - 3));
        v149 -= 3;
      }
      while (v149 != v148);
      v150 = v231[0];
    }
    v231[1] = v148;
    operator delete(v150);
  }
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v231, a2);
  v151 = v231[0];
  v152 = (char *)operator new(8uLL);
  *(_QWORD *)v152 = (char *)v141 - 16;
  *(_QWORD *)__src = v151 + 3;
  v153 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v146, (uint64_t)(v151 + 3), (uint64_t)&std::piecewise_construct, (__int128 **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v153 + 5, v152, v152 + 8, 1uLL);
  operator delete(v152);
  v154 = v231[0];
  if (v231[0])
  {
    v155 = v231[1];
    v156 = v231[0];
    if (v231[1] != v231[0])
    {
      do
      {
        if (*((char *)v155 - 1) < 0)
          operator delete((void *)*(v155 - 3));
        v155 -= 3;
      }
      while (v155 != v154);
      v156 = v231[0];
    }
    v231[1] = v154;
    operator delete(v156);
  }
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v231, a2);
  v157 = v231[0];
  v158 = (char *)operator new(8uLL);
  *(_QWORD *)v158 = (char *)v142 - 16;
  *(_QWORD *)__src = v157 + 6;
  v159 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v146, (uint64_t)(v157 + 6), (uint64_t)&std::piecewise_construct, (__int128 **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v159 + 5, v158, v158 + 8, 1uLL);
  operator delete(v158);
  v160 = v231[0];
  if (v231[0])
  {
    v161 = v231[1];
    v162 = v231[0];
    if (v231[1] != v231[0])
    {
      do
      {
        if (*((char *)v161 - 1) < 0)
          operator delete((void *)*(v161 - 3));
        v161 -= 3;
      }
      while (v161 != v160);
      v162 = v231[0];
    }
    v231[1] = v160;
    operator delete(v162);
  }
  operator delete(v132);
  v45 = 1;
LABEL_211:
  if (SHIBYTE(v207.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v207.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v208.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_213:
      if ((SHIBYTE(v209.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_214;
LABEL_218:
      operator delete(v209.__r_.__value_.__l.__data_);
      if ((v212 & 0x80000000) == 0)
        goto LABEL_215;
LABEL_219:
      operator delete(v210);
      goto LABEL_215;
    }
  }
  else if ((SHIBYTE(v208.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_213;
  }
  operator delete(v208.__r_.__value_.__l.__data_);
  if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_218;
LABEL_214:
  if (v212 < 0)
    goto LABEL_219;
LABEL_215:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v213, v214[0]);
  return v45;
}

void sub_180E3412C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,int a55,__int16 a56,char a57,char a58,uint64_t a59,uint64_t a60,int a61,__int16 a62,char a63)
{
  char a64;
  void *a65;
  char a70;
  char a71;
  char *a72;
  void **v72;
  uint64_t v73;
  void *v75;

  if (*(char *)(v73 - 121) < 0)
    operator delete(*(void **)(v73 - 144));
  v75 = (void *)STACK[0x240];
  if (STACK[0x240])
  {
    STACK[0x248] = (unint64_t)v75;
    operator delete(v75);
  }
  if (a52 < 0)
    operator delete(v72[12]);
  if (a58 < 0)
    operator delete(v72[15]);
  if (a64 < 0)
    operator delete(v72[18]);
  if (a70 < 0)
  {
    operator delete(a65);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a71, a72);
    _Unwind_Resume(a1);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a71, a72);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long,long long>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  uint64_t v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180E345DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E345F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  uint64_t v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180E34798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E347B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long &,long long &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  uint64_t v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180E34954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E3496C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long &>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  uint64_t v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.slice";
    v25[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  mlir::mps::SliceOp::build(a1, v28, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_8;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::SliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_8:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180E34B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E34B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::LSTMOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::LSTMGateLayout,BOOL,mlir::Value &,mlir::Value &,decltype(nullptr),mlir::Value &,mlir::Value &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, unsigned int *a9, unsigned int *a10, char *a11, uint64_t *a12, uint64_t *a13, uint64_t *a14, _BOOL8 *a15)
{
  uint64_t *Context;
  uint64_t v24;
  char v25;
  mlir::GenericProgramPoint *v26;
  uint64_t v27;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  __int16 v35;
  uint64_t v36[4];
  __int16 v37;
  _BYTE v38[40];
  _QWORD v39[39];

  v39[38] = *MEMORY[0x1E0C80C00];
  v33 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v33);
  v24 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.lstm", (const unsigned __int8 *)8, Context);
  if (!v25)
  {
    v37 = 1283;
    v36[2] = (uint64_t)"mps.lstm";
    v36[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v35 = 259;
    llvm::operator+(v36, (uint64_t *)&v34, (uint64_t)v38);
    llvm::report_fatal_error((llvm::Twine *)v38, 1);
  }
  mlir::OperationState::OperationState(v39, a2, v24);
  mlir::mps::LSTMOp::build(a1, (uint64_t)v39, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, 0, *a14, *a15);
  v26 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v39);
  if (!v26)
  {
    v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v30 = 662;
    v31 = "Casting.h";
    v32 = "dyn_cast";
    goto LABEL_8;
  }
  v27 = llvm::DefaultDoCastIfPossible<mlir::mps::LSTMOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LSTMOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v26);
  if (!v27)
  {
    v29 = "result && \"builder didn't return the right type\"";
    v30 = 497;
    v31 = "Builders.h";
    v32 = "create";
LABEL_8:
    __assert_rtn(v32, v31, v30, v29);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v39);
  return v27;
}

void sub_180E34D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

void sub_180E34D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a32);
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::GRUPattern::matchAndRewrite(MILToMLIR::GRUPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void ***v7;
  const void **v8;
  char v9;
  uint64_t *v10;
  void **v11;
  const void **v12;
  const void ***v13;
  void *v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  uint64_t *v22;
  mlir::GenericProgramPoint *v23;
  _DWORD *v24;
  uint64_t IntegerType;
  uint64_t **v26;
  uint64_t InterfaceFor;
  const char *v28;
  int v29;
  const char *v30;
  const char *v31;
  uint64_t *v32;
  mlir::GenericProgramPoint *v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  uint64_t *v39;
  mlir::GenericProgramPoint *v40;
  uint64_t *v41;
  uint64_t Value;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char v54;
  uint64_t *v55;
  int64_t v56;
  _BYTE *v57;
  size_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  mlir::GenericProgramPoint *v66;
  mlir::GenericProgramPoint *v67;
  void **v68;
  int v69;
  int v70;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  uint64_t v81;
  mlir::GenericProgramPoint *v82;
  uint64_t v83;
  mlir::GenericProgramPoint *v84;
  char *v85;
  mlir::GenericProgramPoint *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  char *v96;
  char *v97;
  uint64_t *v98;
  uint64_t *v99;
  uint64_t *v100;
  uint64_t *v101;
  _DWORD *v102;
  uint64_t v103;
  uint64_t **v104;
  uint64_t v105;
  const char *v106;
  int v107;
  const char *v108;
  const char *v109;
  uint64_t *v110;
  mlir::GenericProgramPoint *v111;
  uint64_t *v112;
  char *v113;
  uint64_t *v114;
  uint64_t *v115;
  uint64_t *v116;
  uint64_t *v117;
  uint64_t v119;
  const char *v120;
  int v121;
  const char *v122;
  const char *v123;
  const char *v124;
  int v125;
  const char *v126;
  const char *v127;
  int v128;
  unsigned int v129;
  mlir::GenericProgramPoint *v130;
  uint64_t v131;
  uint64_t v132;
  std::string v133;
  unsigned int v134;
  std::string v135;
  unsigned int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t *v147[3];
  __int128 v148;
  _BYTE v149[32];
  void **v150;
  uint64_t v151;
  char v152;
  char **v153;
  char *v154[2];
  uint64_t v155;
  uint64_t v156;
  uint64_t OptionalArgValue;
  uint64_t v158;
  uint64_t ArgValue;
  _BYTE __src[24];
  uint64_t v161;

  v161 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v158 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "initial_h");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  v156 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih");
  v155 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh");
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v154[0] = 0;
  v154[1] = 0;
  v153 = v154;
  v7 = v6 + 1;
  v8 = *v6;
  if (*v6 != (const void **)(v6 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v153, (uint64_t *)v154, v8 + 4, (uint64_t)(v8 + 4));
      v12 = (const void **)v8[1];
      if (v12)
      {
        do
        {
          v13 = (const void ***)v12;
          v12 = (const void **)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (const void ***)v8[2];
          v16 = *v13 == v8;
          v8 = (const void **)v13;
        }
        while (!v16);
      }
      v8 = (const void **)v13;
    }
    while (v13 != v7);
  }
  v149[31] = 9;
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  strcpy(&v149[7], "\ndirection");
  strcpy((char *)&v148, "activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  strcpy((char *)v147, "recurrent_activation");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  HIBYTE(v147[2]) = 15;
  strcpy((char *)v147, "output_sequence");
  MIL::IROperation::TryGetParameterValue();
  v9 = MIL::IRValue::GetScalar<BOOL>();
  v10 = (uint64_t *)(a3 + 13);
  if (v152 < 0)
  {
    if (v151 == 13)
    {
      v11 = v150;
      goto LABEL_14;
    }
  }
  else if (v152 == 13)
  {
    v11 = (void **)&v150;
LABEL_14:
    v14 = *v11;
    v15 = *(uint64_t *)((char *)v11 + 5);
    v16 = v14 == (void *)0x7463657269646962 && v15 == 0x6C616E6F69746365;
    v17 = v16;
    v128 = v17;
    goto LABEL_22;
  }
  v128 = 0;
LABEL_22:
  v145 = 0;
  v146 = 0;
  v144 = 0;
  v18 = mlir::IntegerType::get(*v10, 0x20u, 1u);
  v19 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v18, 0);
  v147[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v19, 0);
  v20 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v147);
  if (!*((_DWORD *)v20 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v143 = (uint64_t)v20 - 16;
  v21 = mlir::IntegerType::get(*v10, 0x20u, 1u);
  v22 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v21, 0);
  v147[0] = (uint64_t *)mlir::mps::getConstantAttr<int>(v22, -1);
  v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v147);
  if (!*((_DWORD *)v23 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v142 = (uint64_t)v23 - 16;
  v140 = 0;
  v141 = 0;
  v24 = operator new(4uLL);
  *v24 = 0;
  v147[0] = (uint64_t *)1;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v10, 0x20u, 1);
  v26 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v147, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26))
    goto LABEL_162;
  if (v26)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!InterfaceFor)
    {
      v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v29 = 98;
      v30 = "InterfaceSupport.h";
      v31 = "Interface";
      goto LABEL_169;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v32 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v26, InterfaceFor, v24, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v32))
  {
LABEL_162:
    v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v29 = 566;
    v30 = "Casting.h";
    v31 = "cast";
    goto LABEL_169;
  }
  v147[0] = v32;
  v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v147);
  if (!*((_DWORD *)v33 + 9))
  {
    v28 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v29 = 984;
    v30 = "Operation.h";
    v31 = "getOpResultImpl";
LABEL_169:
    __assert_rtn(v31, v30, v29, v28);
  }
  v141 = (uint64_t)v33 - 16;
  *v24 = 1;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26))
    goto LABEL_163;
  if (v26)
  {
    v34 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!v34)
    {
      v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v36 = 98;
      v37 = "InterfaceSupport.h";
      v38 = "Interface";
      goto LABEL_171;
    }
  }
  else
  {
    v34 = 0;
  }
  v39 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v26, v34, v24, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v39))
  {
LABEL_163:
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
    goto LABEL_171;
  }
  v147[0] = v39;
  v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v147);
  if (!*((_DWORD *)v40 + 9))
  {
    v35 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v36 = 984;
    v37 = "Operation.h";
    v38 = "getOpResultImpl";
LABEL_171:
    __assert_rtn(v38, v37, v36, v35);
  }
  v140 = (uint64_t)v40 - 16;
  operator delete(v24);
  v41 = (uint64_t *)(*(_QWORD *)(v155 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v41)
  {
    v120 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v121 = 650;
    v122 = "Casting.h";
    v123 = "dyn_cast";
    goto LABEL_174;
  }
  if (!*v41)
  {
    v120 = "abstractType && \"Malformed type storage object.\"";
    v121 = 160;
    v122 = "TypeSupport.h";
    v123 = "getAbstractType";
LABEL_174:
    __assert_rtn(v123, v122, v121, v120);
  }
  if (*(_UNKNOWN **)(*v41 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v41 = 0;
  v147[0] = v41;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v147);
  v44 = 0;
  v139 = 0;
  if (!v128)
    goto LABEL_71;
  if (v43 <= 1)
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  v44 = *(_QWORD *)(Value + 8);
  v139 = v44;
  v45 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias_back");
  v46 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_ih_back");
  v47 = v9;
  v145 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight_hh_back");
  v48 = v156;
  v49 = (uint64_t *)operator new(0x10uLL);
  v147[1] = v49 + 2;
  v147[2] = v49 + 2;
  *v49 = v48;
  v49[1] = v46;
  v147[0] = v49;
  __src[0] = 0;
  v50 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v10, LocationForOp, (uint64_t *)v147, &v143, __src);
  if (!*(_DWORD *)(v50 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v9 = v47;
  v156 = v50 - 16;
  if (!OptionalArgValue)
  {
LABEL_68:
    v54 = 1;
    v55 = v147[0];
    if (!v147[0])
      goto LABEL_70;
    goto LABEL_69;
  }
  if (v45)
  {
    *(_QWORD *)__src = OptionalArgValue;
    *(_QWORD *)&__src[8] = v45;
    v51 = (uint64_t)v147[2];
    v45 = (uint64_t)v147[0];
    if ((uint64_t *)((char *)v147[2] - (char *)v147[0]) >= (uint64_t *)0x10)
    {
      v56 = (char *)v147[1] - (char *)v147[0];
      if ((uint64_t *)((char *)v147[1] - (char *)v147[0]) <= (uint64_t *)0xF)
      {
        v57 = &__src[v56];
        if (v147[1] != v147[0])
        {
          memcpy(v147[0], __src, (char *)v147[1] - (char *)v147[0]);
          v45 = (uint64_t)v147[1];
        }
        v58 = 16 - v56;
        memcpy((void *)v45, v57, v58);
        goto LABEL_66;
      }
    }
    else
    {
      if (v147[0])
      {
        v147[1] = v147[0];
        operator delete(v147[0]);
        v51 = 0;
        memset(v147, 0, sizeof(v147));
      }
      v52 = v51 >> 2;
      if ((unint64_t)(v51 >> 2) <= 2)
        v52 = 2;
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
        v53 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v53 = v52;
      if (v53 >> 61)
        std::vector<long>::__throw_length_error[abi:ne180100]();
      v45 = (uint64_t)operator new(8 * v53);
      v147[0] = (uint64_t *)v45;
      v147[2] = (uint64_t *)(v45 + 8 * v53);
    }
    *(_OWORD *)v45 = *(_OWORD *)__src;
    v58 = 16;
LABEL_66:
    v147[1] = (uint64_t *)(v45 + v58);
    __src[0] = 0;
    v59 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v10, LocationForOp, (uint64_t *)v147, &v143, __src);
    if (!*(_DWORD *)(v59 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    OptionalArgValue = v59 - 16;
    goto LABEL_68;
  }
  *(_QWORD *)__src = operator new(0x50uLL);
  *(_OWORD *)&__src[8] = xmmword_1812877E0;
  v45 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __src);
  if ((__src[23] & 0x80000000) != 0)
    operator delete(*(void **)__src);
  v54 = 0;
  v55 = v147[0];
  if (v147[0])
  {
LABEL_69:
    v147[1] = v55;
    operator delete(v55);
  }
LABEL_70:
  if ((v54 & 1) == 0)
    goto LABEL_152;
LABEL_71:
  v60 = (uint64_t *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v60)
  {
    v124 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v125 = 650;
    v126 = "Casting.h";
    v127 = "dyn_cast";
    goto LABEL_177;
  }
  if (!*v60)
  {
    v124 = "abstractType && \"Malformed type storage object.\"";
    v125 = 160;
    v126 = "TypeSupport.h";
    v127 = "getAbstractType";
LABEL_177:
    __assert_rtn(v127, v126, v125, v124);
  }
  if (*(_UNKNOWN **)(*v60 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v60 = 0;
  v147[0] = v60;
  v61 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v147);
  if (v62 <= 1)
    __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
  v63 = *(_QWORD *)(v61 + 8);
  if (v63 == 1)
  {
    v64 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, &ArgValue, &v140);
    if (!*(_DWORD *)(v64 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    ArgValue = v64 - 16;
  }
  LOBYTE(v147[0]) = 0;
  __src[0] = 1;
  v65 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::BoolAttr **)v10, LocationForOp, &ArgValue, &v156, (unsigned __int8 *)v147, __src);
  if (!*(_DWORD *)(v65 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v137 = v65 - 16;
  v138 = v65 - 16;
  if (OptionalArgValue)
  {
    v66 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)v10, LocationForOp, &v138, &OptionalArgValue);
    if (!*((_DWORD *)v66 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v137 = (uint64_t)v66 - 16;
  }
  if (v63 == 1)
  {
    v67 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, &v137, &v140);
    if (!*((_DWORD *)v67 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v137 = (uint64_t)v67 - 16;
  }
  if (v152 < 0)
  {
    if (v151 != 7)
      goto LABEL_95;
    v68 = v150;
  }
  else
  {
    if (v152 != 7)
      goto LABEL_95;
    v68 = (void **)&v150;
  }
  v69 = *(_DWORD *)v68;
  v70 = *(_DWORD *)((char *)v68 + 3);
  if (v69 != 1702258034 || v70 != 1702064741)
  {
LABEL_95:
    if (!v128)
      goto LABEL_102;
    goto LABEL_96;
  }
  v119 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, &v137, &v141);
  if (!*(_DWORD *)(v119 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v137 = v119 - 16;
  if (v128)
  {
LABEL_96:
    LODWORD(v132) = -1;
    v72 = (uint64_t *)(4 * v44);
    v147[0] = v72;
    *(_QWORD *)__src = v72;
    v73 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long,long long>((mlir::mps::ConstantOp *)v10, LocationForOp, &v137, (unsigned int *)&v132, (unsigned int *)v147, (unsigned int *)__src);
    if (!*(_DWORD *)(v73 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v146 = v73 - 16;
    v74 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, &v146, &v141);
    if (!*(_DWORD *)(v74 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    *(_DWORD *)__src = -1;
    LODWORD(v132) = 0;
    v146 = v74 - 16;
    v147[0] = v72;
    v75 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long>((mlir::mps::ConstantOp *)v10, LocationForOp, &v137, (unsigned int *)__src, (unsigned int *)&v132, (unsigned int *)v147);
    if (!*(_DWORD *)(v75 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v137 = v75 - 16;
    LODWORD(v147[0]) = -1;
    v76 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,long long &,long long &>((mlir::mps::ConstantOp *)v10, LocationForOp, &v158, (unsigned int *)v147, (unsigned int *)&v139, (unsigned int *)&v139);
    if (!*(_DWORD *)(v76 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v144 = v76 - 16;
    LODWORD(v147[0]) = -1;
    *(_DWORD *)__src = 0;
    v77 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,long long &>((mlir::mps::ConstantOp *)v10, LocationForOp, &v158, (unsigned int *)v147, (unsigned int *)__src, (unsigned int *)&v139);
    if (!*(_DWORD *)(v77 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v158 = v77 - 16;
  }
LABEL_102:
  if ((v149[31] & 0x80000000) != 0)
    std::string::__init_copy_ctor_external(&v135, *(const std::string::value_type **)&v149[8], *(std::string::size_type *)&v149[16]);
  else
    v135 = *(std::string *)&v149[8];
  v78 = MILToMLIR::activationStringToAttr((uint64_t)&v135, 0);
  v79 = v78;
  if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v135.__r_.__value_.__l.__data_);
    v136 = v79;
    if ((v149[7] & 0x80000000) == 0)
      goto LABEL_107;
  }
  else
  {
    v136 = v78;
    if ((v149[7] & 0x80000000) == 0)
    {
LABEL_107:
      *(_OWORD *)&v133.__r_.__value_.__l.__data_ = v148;
      v133.__r_.__value_.__r.__words[2] = *(_QWORD *)v149;
      goto LABEL_110;
    }
  }
  std::string::__init_copy_ctor_external(&v133, (const std::string::value_type *)v148, *((std::string::size_type *)&v148 + 1));
LABEL_110:
  v80 = MILToMLIR::activationStringToAttr((uint64_t)&v133, 0);
  if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v133.__r_.__value_.__l.__data_);
  v134 = v80;
  LODWORD(v147[0]) = 2;
  __src[0] = 0;
  LOBYTE(v132) = 0;
  LOBYTE(v131) = 0;
  v81 = mlir::OpBuilder::create<mlir::mps::GRUOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::GRUGateLayout,BOOL,BOOL,BOOL,mlir::Value &,decltype(nullptr),decltype(nullptr)>((mlir::UnitAttr **)v10, LocationForOp, &v137, &v155, &v134, &v134, &v136, (unsigned int *)v147, __src, (char *)&v132, (unsigned __int8 *)&v131, &v158);
  if (!*(_DWORD *)(v81 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v132 = v81 - 16;
  LODWORD(v147[0]) = 0;
  *(_DWORD *)__src = -1;
  LODWORD(v130) = 1;
  v82 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v10, LocationForOp, &v132, (unsigned int *)v147, (unsigned int *)__src, (unsigned int *)&v130);
  if (!*((_DWORD *)v82 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v131 = (uint64_t)v82 - 16;
  if ((v9 & 1) == 0)
    v132 = (uint64_t)v82 - 16;
  if (v128)
  {
    LODWORD(v147[0]) = 2;
    __src[0] = 0;
    LOBYTE(v130) = 0;
    LOBYTE(v129) = 1;
    v83 = mlir::OpBuilder::create<mlir::mps::GRUOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::GRUGateLayout,BOOL,BOOL,BOOL,mlir::Value &,decltype(nullptr),decltype(nullptr)>((mlir::UnitAttr **)v10, LocationForOp, &v146, &v145, &v134, &v134, &v136, (unsigned int *)v147, __src, (char *)&v130, (unsigned __int8 *)&v129, &v144);
    if (!*(_DWORD *)(v83 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v130 = (mlir::GenericProgramPoint *)(v83 - 16);
    LODWORD(v147[0]) = 0;
    *(_DWORD *)__src = -1;
    v129 = 1;
    v84 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::Value &,int,int,int>((mlir::mps::ConstantOp *)v10, LocationForOp, (uint64_t *)&v130, (unsigned int *)v147, (unsigned int *)__src, &v129);
    if (!*((_DWORD *)v84 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v85 = (char *)v84 - 16;
    v86 = (mlir::GenericProgramPoint *)((char *)v84 - 16);
    if ((v9 & 1) != 0)
    {
      v87 = mlir::OpBuilder::create<mlir::mps::ReverseOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)v10, LocationForOp, (uint64_t *)&v130, &v141);
      if (!*(_DWORD *)(v87 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v86 = (mlir::GenericProgramPoint *)(v87 - 16);
    }
    v130 = v86;
    v88 = v132;
    v89 = (uint64_t *)operator new(0x10uLL);
    v147[1] = v89 + 2;
    v147[2] = v89 + 2;
    *v89 = v88;
    v89[1] = (uint64_t)v86;
    v147[0] = v89;
    v90 = v131;
    v91 = operator new(0x10uLL);
    *(_QWORD *)&__src[8] = v91 + 2;
    *(_QWORD *)&__src[16] = v91 + 2;
    *v91 = v90;
    v91[1] = v85;
    *(_QWORD *)__src = v91;
    LOBYTE(v129) = 0;
    v92 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v10, LocationForOp, (uint64_t *)v147, &v142, (unsigned __int8 *)&v129);
    if (!*(_DWORD *)(v92 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v132 = v92 - 16;
    LOBYTE(v129) = 0;
    v93 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL>((mlir::UnitAttr **)v10, LocationForOp, (uint64_t *)__src, &v142, (unsigned __int8 *)&v129);
    if (!*(_DWORD *)(v93 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v131 = v93 - 16;
    if (*(_QWORD *)__src)
    {
      *(_QWORD *)&__src[8] = *(_QWORD *)__src;
      operator delete(*(void **)__src);
    }
    if (v147[0])
    {
      v147[1] = v147[0];
      operator delete(v147[0]);
    }
  }
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v147, a2);
  v94 = v147[0];
  v95 = v132;
  v96 = (char *)operator new(8uLL);
  *(_QWORD *)v96 = v95;
  v97 = (char *)(a3 + 8);
  *(_QWORD *)__src = v94;
  v98 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v94, (uint64_t)&std::piecewise_construct, (__int128 **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v98 + 5, v96, v96 + 8, 1uLL);
  operator delete(v96);
  v99 = v147[0];
  if (v147[0])
  {
    v100 = v147[1];
    v101 = v147[0];
    if (v147[1] != v147[0])
    {
      do
      {
        if (*((char *)v100 - 1) < 0)
          operator delete((void *)*(v100 - 3));
        v100 -= 3;
      }
      while (v100 != v99);
      v101 = v147[0];
    }
    v147[1] = v99;
    operator delete(v101);
  }
  v102 = operator new(4uLL);
  *v102 = 0;
  v147[0] = (uint64_t *)1;
  v103 = mlir::Builder::getIntegerType((mlir::Builder *)v10, 0x20u, 1);
  v104 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v147, 1, v103, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v104))
    goto LABEL_164;
  if (v104)
  {
    v105 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v104);
    if (!v105)
    {
      v106 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v107 = 98;
      v108 = "InterfaceSupport.h";
      v109 = "Interface";
      goto LABEL_165;
    }
  }
  else
  {
    v105 = 0;
  }
  v110 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v104, v105, v102, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v110) & 1) == 0)
  {
LABEL_164:
    v106 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v107 = 566;
    v108 = "Casting.h";
    v109 = "cast";
LABEL_165:
    __assert_rtn(v109, v108, v107, v106);
  }
  v147[0] = v110;
  v130 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v10, LocationForOp, v147);
  v111 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)v10, LocationForOp, &v131, &v130);
  if (!*((_DWORD *)v111 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  (*(void (**)(uint64_t **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v147, a2);
  v112 = v147[0];
  v113 = (char *)operator new(8uLL);
  *(_QWORD *)v113 = (char *)v111 - 16;
  *(_QWORD *)__src = v112 + 3;
  v114 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)v97, (uint64_t)(v112 + 3), (uint64_t)&std::piecewise_construct, (__int128 **)__src);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v114 + 5, v113, v113 + 8, 1uLL);
  operator delete(v113);
  v115 = v147[0];
  if (v147[0])
  {
    v116 = v147[1];
    v117 = v147[0];
    if (v147[1] != v147[0])
    {
      do
      {
        if (*((char *)v116 - 1) < 0)
          operator delete((void *)*(v116 - 3));
        v116 -= 3;
      }
      while (v116 != v115);
      v117 = v147[0];
    }
    v147[1] = v115;
    operator delete(v117);
  }
  operator delete(v102);
  v45 = 1;
LABEL_152:
  if ((v149[7] & 0x80000000) == 0)
  {
    if ((v149[31] & 0x80000000) == 0)
      goto LABEL_154;
LABEL_157:
    operator delete(*(void **)&v149[8]);
    if ((v152 & 0x80000000) == 0)
      goto LABEL_155;
LABEL_158:
    operator delete(v150);
    goto LABEL_155;
  }
  operator delete((void *)v148);
  if ((v149[31] & 0x80000000) != 0)
    goto LABEL_157;
LABEL_154:
  if (v152 < 0)
    goto LABEL_158;
LABEL_155:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v153, v154[0]);
  return v45;
}

void sub_180E361B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  uint64_t v43;
  uint64_t v44;
  void *v46;

  if (*(char *)(v44 - 105) < 0)
    operator delete(*(void **)(v43 + 200));
  v46 = *(void **)(v43 + 40);
  if (v46)
  {
    *(_QWORD *)(v43 + 48) = v46;
    operator delete(v46);
  }
  if (a43 < 0)
    operator delete(*(void **)(v43 + 64));
  if (*(char *)(v44 - 217) < 0)
    operator delete(*(void **)(v43 + 88));
  if (*(char *)(v44 - 193) < 0)
    operator delete(*(void **)(v43 + 112));
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy(v44 - 192, *(char **)(v43 + 144));
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::GRUOp,mlir::Value &,mlir::Value &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::RNNActivation &,mlir::mps::GRUGateLayout,BOOL,BOOL,BOOL,mlir::Value &,decltype(nullptr),decltype(nullptr)>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, char *a9, char *a10, unsigned __int8 *a11, uint64_t *a12)
{
  uint64_t *Context;
  uint64_t v21;
  char v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v24;
  const char *v26;
  int v27;
  const char *v28;
  const char *v29;
  uint64_t v30;
  const char *v31;
  __int16 v32;
  uint64_t v33[4];
  __int16 v34;
  _BYTE v35[40];
  _QWORD v36[39];

  v36[38] = *MEMORY[0x1E0C80C00];
  v30 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
  v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gru", (const unsigned __int8 *)7, Context);
  if (!v22)
  {
    v34 = 1283;
    v33[2] = (uint64_t)"mps.gru";
    v33[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v32 = 259;
    llvm::operator+(v33, (uint64_t *)&v31, (uint64_t)v35);
    llvm::report_fatal_error((llvm::Twine *)v35, 1);
  }
  mlir::OperationState::OperationState(v36, a2, v21);
  mlir::mps::GRUOp::build(a1, (uint64_t)v36, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, 0, 0);
  v23 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v36);
  if (!v23)
  {
    v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v27 = 662;
    v28 = "Casting.h";
    v29 = "dyn_cast";
    goto LABEL_8;
  }
  v24 = llvm::DefaultDoCastIfPossible<mlir::mps::GRUOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GRUOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v23);
  if (!v24)
  {
    v26 = "result && \"builder didn't return the right type\"";
    v27 = 497;
    v28 = "Builders.h";
    v29 = "create";
LABEL_8:
    __assert_rtn(v29, v28, v27, v26);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v36);
  return v24;
}

void sub_180E36584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

void sub_180E3659C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

void MILToMLIR::SingleGateRNNPattern::~SingleGateRNNPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::LSTMPattern::~LSTMPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

void MILToMLIR::GRUPattern::~GRUPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SingleGateRNNOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SingleGateRNNOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x676E69732E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x725F65746167656CLL
      && *(_WORD *)(AttrData + 16) == 28270)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.singlegate_rnn";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SingleGateRNNOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::BroadcastToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BroadcastToOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 16 && *AttrData == 0x616F72622E73706DLL && AttrData[1] == 0x6F745F7473616364)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.broadcast_to";
      v8[3] = 16;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LSTMOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LSTMOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6D74736C2E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.lstm";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GRUOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GRUOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970431790)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.gru";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GRUOp,void>::id)
  {
    return 0;
  }
  return result;
}

void sub_180E36C30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E36DC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E36FF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_180E375DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,char a48)
{
  void *v48;
  void *v49;
  void *v50;

  operator delete(v50);
  operator delete(v49);
  operator delete(v48);
  operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E377CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_180E37DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,uint64_t a47,char a48)
{
  void *v48;
  void *v49;
  void *v50;

  operator delete(v50);
  operator delete(v49);
  operator delete(v48);
  operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E37FFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_180E38244(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

uint64_t GPU::ScatterGenericOpHandler<mlir::mps::ScatterOp>::ScatterGenericOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  GPU::BaseOpHandler *v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  void *v15;
  _QWORD *AttrData;
  uint64_t v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[5];

  v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4);
  *(_QWORD *)v5 = &off_1E0E1E840;
  *((_QWORD *)v5 + 15) = 0;
  v6 = *(_QWORD *)(*((_QWORD *)v5 + 3) + 48);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v25[0] = *(_QWORD *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v25);
    if (v18 == 11 && *AttrData == 0x746163732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x726574746163732ELL)
    {
      v24 = 1283;
      v23[0] = (uint64_t)"classof on '";
      v23[2] = (uint64_t)"mps.scatter";
      v23[3] = 11;
      v21 = "' failed due to the operation not being registered";
      v22 = 259;
      llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
      llvm::report_fatal_error((llvm::Twine *)v25, 1);
    }
LABEL_11:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id)
    goto LABEL_11;
  v20 = *((_QWORD *)v5 + 3);
  v8 = objc_alloc(MEMORY[0x1E0CC7158]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice", v20);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v25[0] = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v20);
  v10 = objc_msgSend(v8, "initWithDevice:operation:", v9, mlir::AffineExpr::getKind((mlir::AffineExpr *)v25));
  v11 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v10;

  v12 = objc_alloc(MEMORY[0x1E0CC7030]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = objc_msgSend(v12, "initWithDevice:", v13);
  v15 = *(void **)(a1 + 120);
  *(_QWORD *)(a1 + 120) = v14;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  objc_msgSend(*(id *)(a1 + 120), "setOptions:", objc_msgSend(*(id *)(a1 + 120), "options") | 1);
  return a1;
}

void sub_180E384B8(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void sub_180E384DC(_Unwind_Exception *a1)
{
  id *v1;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void GPU::ScatterOpHandler::encodeNDArrayOp(GPU::ScatterOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v5;
  void *v6;
  uint64_t Input;
  uint64_t Filter;
  uint64_t Bias;
  int8x8_t *v10;
  mlir::Block *ParentRegion;
  int8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int8x8_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  uint64_t ***v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  uint64_t *v35;
  int8x8_t *v36;
  mlir::Block *v37;
  int8x8_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint8x8_t v43;
  unint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  int8x8_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint8x8_t v54;
  unint64_t v55;
  uint64_t ***v56;
  uint64_t **v57;
  uint64_t v58;
  uint64_t *v59;
  unint64_t v60;
  uint64_t *v61;
  int8x8_t *v62;
  mlir::Block *v63;
  int8x8_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint8x8_t v69;
  unint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int8x8_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint8x8_t v80;
  unint64_t v81;
  uint64_t ***v82;
  uint64_t **v83;
  uint64_t v84;
  uint64_t *v85;
  unint64_t v86;
  uint64_t *v87;
  void *v88;
  uint64_t v89;
  uint64_t SparseShape;
  uint64_t Axis;
  void *v92;
  void *v93;
  id v94;
  void *v95;
  uint64_t v96;
  void *v97;
  void *v98;
  uint64_t v99;
  void *v100;
  id v101;
  void *v102;
  void *v103;
  void *v104;
  id v105;
  id v106;
  void *v107;
  uint64_t v108;
  void *v109;
  void *v110;
  uint64_t v111;
  void *v112;
  id v113;
  uint64_t v114;
  void *v115;
  _QWORD *AttrData;
  uint64_t v117;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  void *v123;
  NSArray *v124;
  void *v125;
  void *v126;
  uint64_t v127;
  const char *v128;
  __int16 v129;
  uint64_t v130[4];
  __int16 v131;
  _QWORD v132[5];
  _QWORD v133[5];

  v133[3] = *MEMORY[0x1E0C80C00];
  v124 = a3;
  v5 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v132[0] = *(_QWORD *)(v5 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v132);
    if (v117 == 11 && *AttrData == 0x746163732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x726574746163732ELL)
    {
      v131 = 1283;
      v130[0] = (uint64_t)"classof on '";
      v130[2] = (uint64_t)"mps.scatter";
      v130[3] = 11;
      v128 = "' failed due to the operation not being registered";
      v129 = 259;
      llvm::operator+(v130, (uint64_t *)&v128, (uint64_t)v132);
      llvm::report_fatal_error((llvm::Twine *)v132, 1);
    }
LABEL_158:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id)
    goto LABEL_158;
  v127 = *((_QWORD *)this + 3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v127);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v127);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v127);
  v10 = (int8x8_t *)*((_QWORD *)this + 2);
  v132[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v132);
  v12 = v10[12];
  if (!*(_QWORD *)&v12)
    goto LABEL_44;
  v13 = *((_QWORD *)ParentRegion + 2);
  v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(_QWORD *)&v12)
      v18 = v16 % *(_QWORD *)&v12;
  }
  else
  {
    v18 = v16 & (*(_QWORD *)&v12 - 1);
  }
  v19 = *(_QWORD **)(*(_QWORD *)&v10[11] + 8 * v18);
  if (!v19)
    goto LABEL_44;
  v20 = (_QWORD *)*v19;
  if (!v20)
    goto LABEL_44;
  if (v17.u32[0] < 2uLL)
  {
    v21 = *(_QWORD *)&v12 - 1;
    while (1)
    {
      v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13)
          goto LABEL_24;
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      v20 = (_QWORD *)*v20;
      if (!v20)
        goto LABEL_44;
    }
  }
  while (1)
  {
    v22 = v20[1];
    if (v22 == v16)
      break;
    if (v22 >= *(_QWORD *)&v12)
      v22 %= *(_QWORD *)&v12;
    if (v22 != v18)
      goto LABEL_44;
LABEL_13:
    v20 = (_QWORD *)*v20;
    if (!v20)
      goto LABEL_44;
  }
  if (v20[2] != v13)
    goto LABEL_13;
LABEL_24:
  v24 = (int8x8_t)v20[4];
  if (v24)
  {
    v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v132[0])) + 8) ^ HIDWORD(v132[0]));
    v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v132[0]) ^ (v25 >> 47) ^ v25);
    v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    v28 = (uint8x8_t)vcnt_s8(v24);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      v29 = v27;
      if (v27 >= *(_QWORD *)&v24)
        v29 = v27 % *(_QWORD *)&v24;
    }
    else
    {
      v29 = v27 & (*(_QWORD *)&v24 - 1);
    }
    v30 = *(uint64_t ****)(v20[3] + 8 * v29);
    if (v30)
    {
      v31 = *v30;
      if (v31)
      {
        if (v28.u32[0] < 2uLL)
        {
          v32 = *(_QWORD *)&v24 - 1;
          while (1)
          {
            v35 = v31[1];
            if (v35 == (uint64_t *)v27)
            {
              if (v31[2] == (uint64_t *)v132[0])
                goto LABEL_146;
            }
            else if (((unint64_t)v35 & v32) != v29)
            {
              goto LABEL_44;
            }
            v33 = 0;
            v31 = (uint64_t **)*v31;
            if (!v31)
              goto LABEL_45;
          }
        }
        while (1)
        {
          v34 = (unint64_t)v31[1];
          if (v34 == v27)
          {
            if (v31[2] == (uint64_t *)v132[0])
            {
LABEL_146:
              v33 = v31[3];
              goto LABEL_45;
            }
          }
          else
          {
            if (v34 >= *(_QWORD *)&v24)
              v34 %= *(_QWORD *)&v24;
            if (v34 != v29)
              break;
          }
          v33 = 0;
          v31 = (uint64_t **)*v31;
          if (!v31)
            goto LABEL_45;
        }
      }
    }
  }
LABEL_44:
  v33 = 0;
LABEL_45:
  objc_msgSend(v33, "mpsndarray");
  v125 = (void *)objc_claimAutoreleasedReturnValue();

  v36 = (int8x8_t *)*((_QWORD *)this + 2);
  v132[0] = Filter;
  v37 = mlir::Value::getParentRegion((mlir::Value *)v132);
  v38 = v36[12];
  if (!*(_QWORD *)&v38)
    goto LABEL_86;
  v39 = *((_QWORD *)v37 + 2);
  v40 = 0x9DDFEA08EB382D69 * (((8 * v39) + 8) ^ HIDWORD(v39));
  v41 = 0x9DDFEA08EB382D69 * (HIDWORD(v39) ^ (v40 >> 47) ^ v40);
  v42 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
  v43 = (uint8x8_t)vcnt_s8(v38);
  v43.i16[0] = vaddlv_u8(v43);
  if (v43.u32[0] > 1uLL)
  {
    v44 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
    if (v42 >= *(_QWORD *)&v38)
      v44 = v42 % *(_QWORD *)&v38;
  }
  else
  {
    v44 = v42 & (*(_QWORD *)&v38 - 1);
  }
  v45 = *(_QWORD **)(*(_QWORD *)&v36[11] + 8 * v44);
  if (!v45)
    goto LABEL_86;
  v46 = (_QWORD *)*v45;
  if (!v46)
    goto LABEL_86;
  if (v43.u32[0] < 2uLL)
  {
    v47 = *(_QWORD *)&v38 - 1;
    while (1)
    {
      v49 = v46[1];
      if (v49 == v42)
      {
        if (v46[2] == v39)
          goto LABEL_66;
      }
      else if ((v49 & v47) != v44)
      {
        goto LABEL_86;
      }
      v46 = (_QWORD *)*v46;
      if (!v46)
        goto LABEL_86;
    }
  }
  while (2)
  {
    v48 = v46[1];
    if (v48 != v42)
    {
      if (v48 >= *(_QWORD *)&v38)
        v48 %= *(_QWORD *)&v38;
      if (v48 != v44)
        goto LABEL_86;
      goto LABEL_55;
    }
    if (v46[2] != v39)
    {
LABEL_55:
      v46 = (_QWORD *)*v46;
      if (!v46)
        goto LABEL_86;
      continue;
    }
    break;
  }
LABEL_66:
  v50 = (int8x8_t)v46[4];
  if (v50)
  {
    v51 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v132[0])) + 8) ^ HIDWORD(v132[0]));
    v52 = 0x9DDFEA08EB382D69 * (HIDWORD(v132[0]) ^ (v51 >> 47) ^ v51);
    v53 = 0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47));
    v54 = (uint8x8_t)vcnt_s8(v50);
    v54.i16[0] = vaddlv_u8(v54);
    if (v54.u32[0] > 1uLL)
    {
      v55 = v53;
      if (v53 >= *(_QWORD *)&v50)
        v55 = v53 % *(_QWORD *)&v50;
    }
    else
    {
      v55 = v53 & (*(_QWORD *)&v50 - 1);
    }
    v56 = *(uint64_t ****)(v46[3] + 8 * v55);
    if (v56)
    {
      v57 = *v56;
      if (v57)
      {
        if (v54.u32[0] < 2uLL)
        {
          v58 = *(_QWORD *)&v50 - 1;
          while (1)
          {
            v61 = v57[1];
            if (v61 == (uint64_t *)v53)
            {
              if (v57[2] == (uint64_t *)v132[0])
                goto LABEL_147;
            }
            else if (((unint64_t)v61 & v58) != v55)
            {
              goto LABEL_86;
            }
            v59 = 0;
            v57 = (uint64_t **)*v57;
            if (!v57)
              goto LABEL_87;
          }
        }
        while (1)
        {
          v60 = (unint64_t)v57[1];
          if (v60 == v53)
          {
            if (v57[2] == (uint64_t *)v132[0])
            {
LABEL_147:
              v59 = v57[3];
              goto LABEL_87;
            }
          }
          else
          {
            if (v60 >= *(_QWORD *)&v50)
              v60 %= *(_QWORD *)&v50;
            if (v60 != v55)
              break;
          }
          v59 = 0;
          v57 = (uint64_t **)*v57;
          if (!v57)
            goto LABEL_87;
        }
      }
    }
  }
LABEL_86:
  v59 = 0;
LABEL_87:
  objc_msgSend(v59, "mpsndarray");
  v126 = (void *)objc_claimAutoreleasedReturnValue();

  v62 = (int8x8_t *)*((_QWORD *)this + 2);
  v132[0] = Bias;
  v63 = mlir::Value::getParentRegion((mlir::Value *)v132);
  v64 = v62[12];
  if (!*(_QWORD *)&v64)
    goto LABEL_128;
  v65 = *((_QWORD *)v63 + 2);
  v66 = 0x9DDFEA08EB382D69 * (((8 * v65) + 8) ^ HIDWORD(v65));
  v67 = 0x9DDFEA08EB382D69 * (HIDWORD(v65) ^ (v66 >> 47) ^ v66);
  v68 = 0x9DDFEA08EB382D69 * (v67 ^ (v67 >> 47));
  v69 = (uint8x8_t)vcnt_s8(v64);
  v69.i16[0] = vaddlv_u8(v69);
  if (v69.u32[0] > 1uLL)
  {
    v70 = 0x9DDFEA08EB382D69 * (v67 ^ (v67 >> 47));
    if (v68 >= *(_QWORD *)&v64)
      v70 = v68 % *(_QWORD *)&v64;
  }
  else
  {
    v70 = v68 & (*(_QWORD *)&v64 - 1);
  }
  v71 = *(_QWORD **)(*(_QWORD *)&v62[11] + 8 * v70);
  if (!v71)
    goto LABEL_128;
  v72 = (_QWORD *)*v71;
  if (!v72)
    goto LABEL_128;
  if (v69.u32[0] < 2uLL)
  {
    v73 = *(_QWORD *)&v64 - 1;
    while (1)
    {
      v75 = v72[1];
      if (v75 == v68)
      {
        if (v72[2] == v65)
          goto LABEL_108;
      }
      else if ((v75 & v73) != v70)
      {
        goto LABEL_128;
      }
      v72 = (_QWORD *)*v72;
      if (!v72)
        goto LABEL_128;
    }
  }
  while (1)
  {
    v74 = v72[1];
    if (v74 == v68)
      break;
    if (v74 >= *(_QWORD *)&v64)
      v74 %= *(_QWORD *)&v64;
    if (v74 != v70)
      goto LABEL_128;
LABEL_97:
    v72 = (_QWORD *)*v72;
    if (!v72)
      goto LABEL_128;
  }
  if (v72[2] != v65)
    goto LABEL_97;
LABEL_108:
  v76 = (int8x8_t)v72[4];
  if (!*(_QWORD *)&v76)
    goto LABEL_128;
  v77 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v132[0])) + 8) ^ HIDWORD(v132[0]));
  v78 = 0x9DDFEA08EB382D69 * (HIDWORD(v132[0]) ^ (v77 >> 47) ^ v77);
  v79 = 0x9DDFEA08EB382D69 * (v78 ^ (v78 >> 47));
  v80 = (uint8x8_t)vcnt_s8(v76);
  v80.i16[0] = vaddlv_u8(v80);
  if (v80.u32[0] > 1uLL)
  {
    v81 = v79;
    if (v79 >= *(_QWORD *)&v76)
      v81 = v79 % *(_QWORD *)&v76;
  }
  else
  {
    v81 = v79 & (*(_QWORD *)&v76 - 1);
  }
  v82 = *(uint64_t ****)(v72[3] + 8 * v81);
  if (!v82 || (v83 = *v82) == 0)
  {
LABEL_128:
    v85 = 0;
    goto LABEL_129;
  }
  if (v80.u32[0] < 2uLL)
  {
    v84 = *(_QWORD *)&v76 - 1;
    while (1)
    {
      v87 = v83[1];
      if (v87 == (uint64_t *)v79)
      {
        if (v83[2] == (uint64_t *)v132[0])
          goto LABEL_148;
      }
      else if (((unint64_t)v87 & v84) != v81)
      {
        goto LABEL_128;
      }
      v85 = 0;
      v83 = (uint64_t **)*v83;
      if (!v83)
        goto LABEL_129;
    }
  }
  while (1)
  {
    v86 = (unint64_t)v83[1];
    if (v86 == v79)
      break;
    if (v86 >= *(_QWORD *)&v76)
      v86 %= *(_QWORD *)&v76;
    if (v86 != v81)
      goto LABEL_128;
LABEL_118:
    v85 = 0;
    v83 = (uint64_t **)*v83;
    if (!v83)
      goto LABEL_129;
  }
  if (v83[2] != (uint64_t *)v132[0])
    goto LABEL_118;
LABEL_148:
  v85 = v83[3];
LABEL_129:
  objc_msgSend(v85, "mpsndarray");
  v88 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSArray objectAtIndexedSubscript:](v124, "objectAtIndexedSubscript:", 0);
  v120 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v120, "mpsndarray");
  v122 = (void *)objc_claimAutoreleasedReturnValue();
  if ((!v122 || !v125 || !v126 || !v88) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  objc_msgSend(v88, "descriptor");
  v123 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v126, "descriptor");
  v121 = (void *)objc_claimAutoreleasedReturnValue();
  v89 = objc_msgSend(v121, "numberOfDimensions");
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v127);
  Axis = RuntimeUtils::getAxis(SparseShape, v89);
  objc_msgSend(v123, "getShape");
  v119 = (void *)objc_claimAutoreleasedReturnValue();
  RuntimeUtils::expandShape(v119, 1, 1);
  v92 = (void *)objc_claimAutoreleasedReturnValue();
  RuntimeUtils::expandShape(v92, 0, Axis);
  v93 = (void *)objc_claimAutoreleasedReturnValue();

  v94 = *((id *)this + 15);
  v95 = (void *)*((_QWORD *)a2 + 9);
  if (!v95)
  {
    v96 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
    v97 = (void *)*((_QWORD *)a2 + 9);
    *((_QWORD *)a2 + 9) = v96;

    v98 = (void *)*((_QWORD *)a2 + 11);
    v95 = (void *)*((_QWORD *)a2 + 9);
    if (v98)
    {
      objc_msgSend(v98, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
      v99 = objc_claimAutoreleasedReturnValue();
      v100 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v99;

      v95 = (void *)*((_QWORD *)a2 + 9);
    }
  }
  if (*((_QWORD *)a2 + 10))
  {
    objc_msgSend(v95, "setLabel:");
    v95 = (void *)*((_QWORD *)a2 + 9);
  }
  v101 = v95;
  objc_msgSend(v94, "reshapeWithCommandEncoder:commandBuffer:sourceArray:shape:destinationArray:", v101, *((_QWORD *)a2 + 1), v88, v93, 0);
  v102 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v102)
  {
    objc_msgSend(MEMORY[0x1E0CC6FE0], "descriptorWithDataType:shape:", objc_msgSend(v88, "dataType"), v93);
    v103 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v103, "setPreferPackedRows:", 1);
    objc_msgSend(MEMORY[0x1E0CC7240], "temporaryNDArrayWithCommandBuffer:descriptor:", *((_QWORD *)a2 + 1), v103);
    v102 = (void *)objc_claimAutoreleasedReturnValue();
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v104 = (void *)objc_claimAutoreleasedReturnValue();
    v105 = (id)objc_msgSend(v94, "reshapeWithCommandEncoder:commandBuffer:sourceArray:shape:destinationArray:", v104, *((_QWORD *)a2 + 1), v88, v93, v102);

  }
  v106 = *((id *)this + 1);
  objc_msgSend(v106, "setBatchDimensions:", Axis);
  v107 = (void *)*((_QWORD *)a2 + 9);
  if (!v107)
  {
    v108 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
    v109 = (void *)*((_QWORD *)a2 + 9);
    *((_QWORD *)a2 + 9) = v108;

    v110 = (void *)*((_QWORD *)a2 + 11);
    v107 = (void *)*((_QWORD *)a2 + 9);
    if (v110)
    {
      objc_msgSend(v110, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
      v111 = objc_claimAutoreleasedReturnValue();
      v112 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v111;

      v107 = (void *)*((_QWORD *)a2 + 9);
    }
  }
  if (*((_QWORD *)a2 + 10))
  {
    objc_msgSend(v107, "setLabel:");
    v107 = (void *)*((_QWORD *)a2 + 9);
  }
  v113 = v107;
  v114 = *((_QWORD *)a2 + 1);
  v133[0] = v125;
  v133[1] = v126;
  v133[2] = v102;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v133, 3);
  v115 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v106, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v113, v114, v115, v122);

}

void sub_180E39088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  void *v17;

  _Unwind_Resume(a1);
}

uint64_t GPU::ScatterGenericOpHandler<mlir::mps::ScatterAlongAxisOp>::ScatterGenericOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  GPU::BaseOpHandler *v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  void *v15;
  _QWORD *AttrData;
  uint64_t v18;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  _QWORD v26[5];

  v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4);
  *(_QWORD *)v5 = &off_1E0E1E7F0;
  *((_QWORD *)v5 + 15) = 0;
  v6 = *(_QWORD *)(*((_QWORD *)v5 + 3) + 48);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v26[0] = *(_QWORD *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v26);
    if (v18 == 22
      && *AttrData == 0x746163732E73706DLL
      && AttrData[1] == 0x6E6F6C615F726574
      && *(_QWORD *)((char *)AttrData + 14) == 0x736978615F676E6FLL)
    {
      v25 = 1283;
      v24[0] = (uint64_t)"classof on '";
      v24[2] = (uint64_t)"mps.scatter_along_axis";
      v24[3] = 22;
      v22 = "' failed due to the operation not being registered";
      v23 = 259;
      llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
      llvm::report_fatal_error((llvm::Twine *)v26, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id)
    goto LABEL_14;
  v21 = *((_QWORD *)v5 + 3);
  v8 = objc_alloc(MEMORY[0x1E0CC7158]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice", v21);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v26[0] = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v21);
  v10 = objc_msgSend(v8, "initWithDevice:operation:", v9, mlir::AffineExpr::getKind((mlir::AffineExpr *)v26));
  v11 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v10;

  v12 = objc_alloc(MEMORY[0x1E0CC7030]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = objc_msgSend(v12, "initWithDevice:", v13);
  v15 = *(void **)(a1 + 120);
  *(_QWORD *)(a1 + 120) = v14;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  objc_msgSend(*(id *)(a1 + 120), "setOptions:", objc_msgSend(*(id *)(a1 + 120), "options") | 1);
  return a1;
}

void sub_180E3940C(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void sub_180E39430(_Unwind_Exception *a1)
{
  id *v1;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void GPU::ScatterAlongAxisOpHandler::encodeNDArrayOp(GPU::ScatterAlongAxisOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v5;
  void *v6;
  uint64_t Input;
  uint64_t Filter;
  uint64_t Bias;
  int8x8_t *v10;
  mlir::Block *ParentRegion;
  int8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int8x8_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  uint64_t ***v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  uint64_t *v35;
  void *v36;
  int8x8_t *v37;
  mlir::Block *v38;
  int8x8_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint8x8_t v44;
  unint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int8x8_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  uint8x8_t v55;
  unint64_t v56;
  uint64_t ***v57;
  uint64_t **v58;
  uint64_t v59;
  uint64_t *v60;
  unint64_t v61;
  uint64_t *v62;
  void *v63;
  int8x8_t *v64;
  mlir::Block *v65;
  int8x8_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint8x8_t v71;
  unint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  int8x8_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint8x8_t v82;
  unint64_t v83;
  uint64_t ***v84;
  uint64_t **v85;
  uint64_t v86;
  uint64_t *v87;
  unint64_t v88;
  uint64_t *v89;
  void *v90;
  uint64_t v91;
  uint64_t SparseShape;
  uint64_t v93;
  uint64_t v94;
  void *v95;
  uint64_t v96;
  void *v97;
  void *v98;
  uint64_t v99;
  void *v100;
  id v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  void *v105;
  void *v106;
  uint64_t v107;
  void *v108;
  id v109;
  uint64_t v110;
  void *v111;
  uint64_t v112;
  void *v113;
  void *v114;
  uint64_t v115;
  void *v116;
  id v117;
  uint64_t v118;
  void *v119;
  void *v120;
  uint64_t v121;
  void *v122;
  uint64_t v123;
  void *v124;
  void *v125;
  uint64_t v126;
  void *v127;
  id v128;
  void *v129;
  id v130;
  void *v131;
  uint64_t v132;
  void *v133;
  void *v134;
  uint64_t v135;
  void *v136;
  id v137;
  void *v138;
  void *v139;
  void *v140;
  id v141;
  id v142;
  void *v143;
  uint64_t v144;
  void *v145;
  void *v146;
  uint64_t v147;
  void *v148;
  id v149;
  uint64_t v150;
  void *v151;
  _QWORD *AttrData;
  uint64_t v153;
  BOOL v154;
  void *v156;
  uint64_t v157;
  NSArray *v158;
  void *v159;
  void *v160;
  void *v161;
  void *v162;
  void *v163;
  void *v164;
  void *v165;
  GPU::ScatterAlongAxisOpHandler *v166;
  uint64_t v167;
  const char *v168;
  __int16 v169;
  uint64_t v170[4];
  __int16 v171;
  _QWORD v172[5];
  _QWORD v173[5];

  v173[3] = *MEMORY[0x1E0C80C00];
  v158 = a3;
  v166 = this;
  v5 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v172[0] = *(_QWORD *)(v5 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v172);
    if (v153 == 22)
    {
      v154 = *AttrData == 0x746163732E73706DLL && AttrData[1] == 0x6E6F6C615F726574;
      if (v154 && *(_QWORD *)((char *)AttrData + 14) == 0x736978615F676E6FLL)
      {
        v171 = 1283;
        v170[0] = (uint64_t)"classof on '";
        v170[2] = (uint64_t)"mps.scatter_along_axis";
        v170[3] = 22;
        v168 = "' failed due to the operation not being registered";
        v169 = 259;
        llvm::operator+(v170, (uint64_t *)&v168, (uint64_t)v172);
        llvm::report_fatal_error((llvm::Twine *)v172, 1);
      }
    }
LABEL_186:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id)
    goto LABEL_186;
  v167 = *((_QWORD *)this + 3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v167);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v167);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v167);
  v10 = (int8x8_t *)*((_QWORD *)v166 + 2);
  v172[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v172);
  v12 = v10[12];
  if (!*(_QWORD *)&v12)
    goto LABEL_44;
  v13 = *((_QWORD *)ParentRegion + 2);
  v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(_QWORD *)&v12)
      v18 = v16 % *(_QWORD *)&v12;
  }
  else
  {
    v18 = v16 & (*(_QWORD *)&v12 - 1);
  }
  v19 = *(_QWORD **)(*(_QWORD *)&v10[11] + 8 * v18);
  if (!v19)
    goto LABEL_44;
  v20 = (_QWORD *)*v19;
  if (!v20)
    goto LABEL_44;
  if (v17.u32[0] < 2uLL)
  {
    v21 = *(_QWORD *)&v12 - 1;
    while (1)
    {
      v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13)
          goto LABEL_24;
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      v20 = (_QWORD *)*v20;
      if (!v20)
        goto LABEL_44;
    }
  }
  while (1)
  {
    v22 = v20[1];
    if (v22 == v16)
      break;
    if (v22 >= *(_QWORD *)&v12)
      v22 %= *(_QWORD *)&v12;
    if (v22 != v18)
      goto LABEL_44;
LABEL_13:
    v20 = (_QWORD *)*v20;
    if (!v20)
      goto LABEL_44;
  }
  if (v20[2] != v13)
    goto LABEL_13;
LABEL_24:
  v24 = (int8x8_t)v20[4];
  if (v24)
  {
    v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v172[0])) + 8) ^ HIDWORD(v172[0]));
    v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v172[0]) ^ (v25 >> 47) ^ v25);
    v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    v28 = (uint8x8_t)vcnt_s8(v24);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      v29 = v27;
      if (v27 >= *(_QWORD *)&v24)
        v29 = v27 % *(_QWORD *)&v24;
    }
    else
    {
      v29 = v27 & (*(_QWORD *)&v24 - 1);
    }
    v30 = *(uint64_t ****)(v20[3] + 8 * v29);
    if (v30)
    {
      v31 = *v30;
      if (v31)
      {
        if (v28.u32[0] < 2uLL)
        {
          v32 = *(_QWORD *)&v24 - 1;
          while (1)
          {
            v35 = v31[1];
            if (v35 == (uint64_t *)v27)
            {
              if (v31[2] == (uint64_t *)v172[0])
                goto LABEL_171;
            }
            else if (((unint64_t)v35 & v32) != v29)
            {
              goto LABEL_44;
            }
            v33 = 0;
            v31 = (uint64_t **)*v31;
            if (!v31)
              goto LABEL_45;
          }
        }
        while (1)
        {
          v34 = (unint64_t)v31[1];
          if (v34 == v27)
          {
            if (v31[2] == (uint64_t *)v172[0])
            {
LABEL_171:
              v33 = v31[3];
              goto LABEL_45;
            }
          }
          else
          {
            if (v34 >= *(_QWORD *)&v24)
              v34 %= *(_QWORD *)&v24;
            if (v34 != v29)
              break;
          }
          v33 = 0;
          v31 = (uint64_t **)*v31;
          if (!v31)
            goto LABEL_45;
        }
      }
    }
  }
LABEL_44:
  v33 = 0;
LABEL_45:
  objc_msgSend(v33, "mpsndarray");
  v36 = (void *)objc_claimAutoreleasedReturnValue();

  v37 = (int8x8_t *)*((_QWORD *)v166 + 2);
  v172[0] = Filter;
  v38 = mlir::Value::getParentRegion((mlir::Value *)v172);
  v39 = v37[12];
  if (!*(_QWORD *)&v39)
    goto LABEL_86;
  v40 = *((_QWORD *)v38 + 2);
  v41 = 0x9DDFEA08EB382D69 * (((8 * v40) + 8) ^ HIDWORD(v40));
  v42 = 0x9DDFEA08EB382D69 * (HIDWORD(v40) ^ (v41 >> 47) ^ v41);
  v43 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
  v44 = (uint8x8_t)vcnt_s8(v39);
  v44.i16[0] = vaddlv_u8(v44);
  if (v44.u32[0] > 1uLL)
  {
    v45 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
    if (v43 >= *(_QWORD *)&v39)
      v45 = v43 % *(_QWORD *)&v39;
  }
  else
  {
    v45 = v43 & (*(_QWORD *)&v39 - 1);
  }
  v46 = *(_QWORD **)(*(_QWORD *)&v37[11] + 8 * v45);
  if (!v46)
    goto LABEL_86;
  v47 = (_QWORD *)*v46;
  if (!v47)
    goto LABEL_86;
  if (v44.u32[0] < 2uLL)
  {
    v48 = *(_QWORD *)&v39 - 1;
    while (1)
    {
      v50 = v47[1];
      if (v50 == v43)
      {
        if (v47[2] == v40)
          goto LABEL_66;
      }
      else if ((v50 & v48) != v45)
      {
        goto LABEL_86;
      }
      v47 = (_QWORD *)*v47;
      if (!v47)
        goto LABEL_86;
    }
  }
  while (2)
  {
    v49 = v47[1];
    if (v49 != v43)
    {
      if (v49 >= *(_QWORD *)&v39)
        v49 %= *(_QWORD *)&v39;
      if (v49 != v45)
        goto LABEL_86;
      goto LABEL_55;
    }
    if (v47[2] != v40)
    {
LABEL_55:
      v47 = (_QWORD *)*v47;
      if (!v47)
        goto LABEL_86;
      continue;
    }
    break;
  }
LABEL_66:
  v51 = (int8x8_t)v47[4];
  if (v51)
  {
    v52 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v172[0])) + 8) ^ HIDWORD(v172[0]));
    v53 = 0x9DDFEA08EB382D69 * (HIDWORD(v172[0]) ^ (v52 >> 47) ^ v52);
    v54 = 0x9DDFEA08EB382D69 * (v53 ^ (v53 >> 47));
    v55 = (uint8x8_t)vcnt_s8(v51);
    v55.i16[0] = vaddlv_u8(v55);
    if (v55.u32[0] > 1uLL)
    {
      v56 = v54;
      if (v54 >= *(_QWORD *)&v51)
        v56 = v54 % *(_QWORD *)&v51;
    }
    else
    {
      v56 = v54 & (*(_QWORD *)&v51 - 1);
    }
    v57 = *(uint64_t ****)(v47[3] + 8 * v56);
    if (v57)
    {
      v58 = *v57;
      if (v58)
      {
        if (v55.u32[0] < 2uLL)
        {
          v59 = *(_QWORD *)&v51 - 1;
          while (1)
          {
            v62 = v58[1];
            if (v62 == (uint64_t *)v54)
            {
              if (v58[2] == (uint64_t *)v172[0])
                goto LABEL_172;
            }
            else if (((unint64_t)v62 & v59) != v56)
            {
              goto LABEL_86;
            }
            v60 = 0;
            v58 = (uint64_t **)*v58;
            if (!v58)
              goto LABEL_87;
          }
        }
        while (1)
        {
          v61 = (unint64_t)v58[1];
          if (v61 == v54)
          {
            if (v58[2] == (uint64_t *)v172[0])
            {
LABEL_172:
              v60 = v58[3];
              goto LABEL_87;
            }
          }
          else
          {
            if (v61 >= *(_QWORD *)&v51)
              v61 %= *(_QWORD *)&v51;
            if (v61 != v56)
              break;
          }
          v60 = 0;
          v58 = (uint64_t **)*v58;
          if (!v58)
            goto LABEL_87;
        }
      }
    }
  }
LABEL_86:
  v60 = 0;
LABEL_87:
  objc_msgSend(v60, "mpsndarray");
  v63 = (void *)objc_claimAutoreleasedReturnValue();

  v64 = (int8x8_t *)*((_QWORD *)v166 + 2);
  v172[0] = Bias;
  v65 = mlir::Value::getParentRegion((mlir::Value *)v172);
  v66 = v64[12];
  if (!*(_QWORD *)&v66)
    goto LABEL_128;
  v67 = *((_QWORD *)v65 + 2);
  v68 = 0x9DDFEA08EB382D69 * (((8 * v67) + 8) ^ HIDWORD(v67));
  v69 = 0x9DDFEA08EB382D69 * (HIDWORD(v67) ^ (v68 >> 47) ^ v68);
  v70 = 0x9DDFEA08EB382D69 * (v69 ^ (v69 >> 47));
  v71 = (uint8x8_t)vcnt_s8(v66);
  v71.i16[0] = vaddlv_u8(v71);
  if (v71.u32[0] > 1uLL)
  {
    v72 = 0x9DDFEA08EB382D69 * (v69 ^ (v69 >> 47));
    if (v70 >= *(_QWORD *)&v66)
      v72 = v70 % *(_QWORD *)&v66;
  }
  else
  {
    v72 = v70 & (*(_QWORD *)&v66 - 1);
  }
  v73 = *(_QWORD **)(*(_QWORD *)&v64[11] + 8 * v72);
  if (!v73)
    goto LABEL_128;
  v74 = (_QWORD *)*v73;
  if (!v74)
    goto LABEL_128;
  if (v71.u32[0] < 2uLL)
  {
    v75 = *(_QWORD *)&v66 - 1;
    while (1)
    {
      v77 = v74[1];
      if (v77 == v70)
      {
        if (v74[2] == v67)
          goto LABEL_108;
      }
      else if ((v77 & v75) != v72)
      {
        goto LABEL_128;
      }
      v74 = (_QWORD *)*v74;
      if (!v74)
        goto LABEL_128;
    }
  }
  while (1)
  {
    v76 = v74[1];
    if (v76 == v70)
      break;
    if (v76 >= *(_QWORD *)&v66)
      v76 %= *(_QWORD *)&v66;
    if (v76 != v72)
      goto LABEL_128;
LABEL_97:
    v74 = (_QWORD *)*v74;
    if (!v74)
      goto LABEL_128;
  }
  if (v74[2] != v67)
    goto LABEL_97;
LABEL_108:
  v78 = (int8x8_t)v74[4];
  if (!*(_QWORD *)&v78)
    goto LABEL_128;
  v79 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v172[0])) + 8) ^ HIDWORD(v172[0]));
  v80 = 0x9DDFEA08EB382D69 * (HIDWORD(v172[0]) ^ (v79 >> 47) ^ v79);
  v81 = 0x9DDFEA08EB382D69 * (v80 ^ (v80 >> 47));
  v82 = (uint8x8_t)vcnt_s8(v78);
  v82.i16[0] = vaddlv_u8(v82);
  if (v82.u32[0] > 1uLL)
  {
    v83 = v81;
    if (v81 >= *(_QWORD *)&v78)
      v83 = v81 % *(_QWORD *)&v78;
  }
  else
  {
    v83 = v81 & (*(_QWORD *)&v78 - 1);
  }
  v84 = *(uint64_t ****)(v74[3] + 8 * v83);
  if (!v84 || (v85 = *v84) == 0)
  {
LABEL_128:
    v87 = 0;
    goto LABEL_129;
  }
  if (v82.u32[0] < 2uLL)
  {
    v86 = *(_QWORD *)&v78 - 1;
    while (1)
    {
      v89 = v85[1];
      if (v89 == (uint64_t *)v81)
      {
        if (v85[2] == (uint64_t *)v172[0])
          goto LABEL_173;
      }
      else if (((unint64_t)v89 & v86) != v83)
      {
        goto LABEL_128;
      }
      v87 = 0;
      v85 = (uint64_t **)*v85;
      if (!v85)
        goto LABEL_129;
    }
  }
  while (1)
  {
    v88 = (unint64_t)v85[1];
    if (v88 == v81)
      break;
    if (v88 >= *(_QWORD *)&v78)
      v88 %= *(_QWORD *)&v78;
    if (v88 != v83)
      goto LABEL_128;
LABEL_118:
    v87 = 0;
    v85 = (uint64_t **)*v85;
    if (!v85)
      goto LABEL_129;
  }
  if (v85[2] != (uint64_t *)v172[0])
    goto LABEL_118;
LABEL_173:
  v87 = v85[3];
LABEL_129:
  objc_msgSend(v87, "mpsndarray");
  v164 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSArray objectAtIndexedSubscript:](v158, "objectAtIndexedSubscript:", 0);
  v156 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v156, "mpsndarray");
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  if ((!v90 || !v36 || !v63 || !v164) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  objc_msgSend(v36, "descriptor");
  v159 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v63, "descriptor");
  v161 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v164, "descriptor");
  v162 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v90, "descriptor");
  v160 = (void *)objc_claimAutoreleasedReturnValue();
  v157 = objc_msgSend(v160, "numberOfDimensions");
  v91 = objc_msgSend(v161, "numberOfDimensions");
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v167);
  v93 = v91 + ~RuntimeUtils::getAxis(SparseShape, v91);
  if (v93)
  {
    objc_msgSend(v159, "transposeDimension:withDimension:", 0, v93);
    objc_msgSend(v161, "transposeDimension:withDimension:", 0, v93);
    objc_msgSend(v162, "transposeDimension:withDimension:", 0, v93);
    objc_msgSend(v160, "transposeDimension:withDimension:", 0, v93);
    v94 = *((_QWORD *)a2 + 1);
    v95 = (void *)*((_QWORD *)a2 + 9);
    if (!v95)
    {
      v96 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
      v97 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v96;

      v98 = (void *)*((_QWORD *)a2 + 11);
      v95 = (void *)*((_QWORD *)a2 + 9);
      if (v98)
      {
        objc_msgSend(v98, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
        v99 = objc_claimAutoreleasedReturnValue();
        v100 = (void *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = v99;

        v95 = (void *)*((_QWORD *)a2 + 9);
      }
    }
    if (*((_QWORD *)a2 + 10))
    {
      objc_msgSend(v95, "setLabel:");
      v95 = (void *)*((_QWORD *)a2 + 9);
    }
    v101 = v95;
    objc_msgSend(v36, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v94, v101, v159, 1);
    v165 = (void *)objc_claimAutoreleasedReturnValue();

    v102 = *((_QWORD *)a2 + 1);
    v103 = (void *)*((_QWORD *)a2 + 9);
    if (!v103)
    {
      v104 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
      v105 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v104;

      v106 = (void *)*((_QWORD *)a2 + 11);
      v103 = (void *)*((_QWORD *)a2 + 9);
      if (v106)
      {
        objc_msgSend(v106, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
        v107 = objc_claimAutoreleasedReturnValue();
        v108 = (void *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = v107;

        v103 = (void *)*((_QWORD *)a2 + 9);
      }
    }
    if (*((_QWORD *)a2 + 10))
    {
      objc_msgSend(v103, "setLabel:");
      v103 = (void *)*((_QWORD *)a2 + 9);
    }
    v109 = v103;
    objc_msgSend(v63, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v102, v109, v161, 1);
    v163 = (void *)objc_claimAutoreleasedReturnValue();

    if (*((_BYTE *)v90 + (int)*MEMORY[0x1E0CC7278]))
      objc_msgSend(v90, "setReadCount:", objc_msgSend(v90, "readCount") + 1);
    v110 = *((_QWORD *)a2 + 1);
    v111 = (void *)*((_QWORD *)a2 + 9);
    if (!v111)
    {
      v112 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
      v113 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v112;

      v114 = (void *)*((_QWORD *)a2 + 11);
      v111 = (void *)*((_QWORD *)a2 + 9);
      if (v114)
      {
        objc_msgSend(v114, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
        v115 = objc_claimAutoreleasedReturnValue();
        v116 = (void *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = v115;

        v111 = (void *)*((_QWORD *)a2 + 9);
      }
    }
    if (*((_QWORD *)a2 + 10))
    {
      objc_msgSend(v111, "setLabel:");
      v111 = (void *)*((_QWORD *)a2 + 9);
    }
    v117 = v111;
    objc_msgSend(v90, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v110, v117, v160, 1);
    v118 = objc_claimAutoreleasedReturnValue();

    v90 = (void *)v118;
  }
  else
  {
    v163 = v63;
    v165 = v36;
  }
  objc_msgSend(v162, "getShape");
  v119 = (void *)objc_claimAutoreleasedReturnValue();
  RuntimeUtils::expandShape(v119, objc_msgSend(v119, "count"), 1);
  v120 = (void *)objc_claimAutoreleasedReturnValue();
  v121 = *((_QWORD *)a2 + 1);
  v122 = (void *)*((_QWORD *)a2 + 9);
  if (!v122)
  {
    v123 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
    v124 = (void *)*((_QWORD *)a2 + 9);
    *((_QWORD *)a2 + 9) = v123;

    v125 = (void *)*((_QWORD *)a2 + 11);
    v122 = (void *)*((_QWORD *)a2 + 9);
    if (v125)
    {
      objc_msgSend(v125, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
      v126 = objc_claimAutoreleasedReturnValue();
      v127 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v126;

      v122 = (void *)*((_QWORD *)a2 + 9);
    }
  }
  if (*((_QWORD *)a2 + 10))
  {
    objc_msgSend(v122, "setLabel:");
    v122 = (void *)*((_QWORD *)a2 + 9);
  }
  v128 = v122;
  objc_msgSend(v164, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v121, v128, v162, 1);
  v129 = (void *)objc_claimAutoreleasedReturnValue();

  v130 = *((id *)v166 + 15);
  v131 = (void *)*((_QWORD *)a2 + 9);
  if (!v131)
  {
    v132 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
    v133 = (void *)*((_QWORD *)a2 + 9);
    *((_QWORD *)a2 + 9) = v132;

    v134 = (void *)*((_QWORD *)a2 + 11);
    v131 = (void *)*((_QWORD *)a2 + 9);
    if (v134)
    {
      objc_msgSend(v134, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
      v135 = objc_claimAutoreleasedReturnValue();
      v136 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v135;

      v131 = (void *)*((_QWORD *)a2 + 9);
    }
  }
  if (*((_QWORD *)a2 + 10))
  {
    objc_msgSend(v131, "setLabel:");
    v131 = (void *)*((_QWORD *)a2 + 9);
  }
  v137 = v131;
  objc_msgSend(v130, "reshapeWithCommandEncoder:commandBuffer:sourceArray:shape:destinationArray:", v137, *((_QWORD *)a2 + 1), v129, v120, 0);
  v138 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v138)
  {
    objc_msgSend(MEMORY[0x1E0CC6FE0], "descriptorWithDataType:shape:", objc_msgSend(v164, "dataType"), v120);
    v139 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v139, "setPreferPackedRows:", 1);
    objc_msgSend(MEMORY[0x1E0CC7240], "temporaryNDArrayWithCommandBuffer:descriptor:", *((_QWORD *)a2 + 1), v139);
    v138 = (void *)objc_claimAutoreleasedReturnValue();
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v140 = (void *)objc_claimAutoreleasedReturnValue();
    v141 = (id)objc_msgSend(v130, "reshapeWithCommandEncoder:commandBuffer:sourceArray:shape:destinationArray:", v140, *((_QWORD *)a2 + 1), v164, v120, v138);

  }
  v142 = *((id *)v166 + 1);
  objc_msgSend(v142, "setBatchDimensions:", v157 - 1);
  v143 = (void *)*((_QWORD *)a2 + 9);
  if (!v143)
  {
    v144 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
    v145 = (void *)*((_QWORD *)a2 + 9);
    *((_QWORD *)a2 + 9) = v144;

    v146 = (void *)*((_QWORD *)a2 + 11);
    v143 = (void *)*((_QWORD *)a2 + 9);
    if (v146)
    {
      objc_msgSend(v146, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
      v147 = objc_claimAutoreleasedReturnValue();
      v148 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v147;

      v143 = (void *)*((_QWORD *)a2 + 9);
    }
  }
  if (*((_QWORD *)a2 + 10))
  {
    objc_msgSend(v143, "setLabel:");
    v143 = (void *)*((_QWORD *)a2 + 9);
  }
  v149 = v143;
  v150 = *((_QWORD *)a2 + 1);
  v173[0] = v165;
  v173[1] = v163;
  v173[2] = v138;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v173, 3);
  v151 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v142, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v149, v150, v151, v90);

}

void sub_180E3A388(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, _Unwind_Exception *exception_object)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

uint64_t GPU::ScatterGenericOpHandler<mlir::mps::ScatterNDOp>::ScatterGenericOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  GPU::BaseOpHandler *v5;
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  void *v15;
  _QWORD *AttrData;
  uint64_t v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[5];

  v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4);
  *(_QWORD *)v5 = &off_1E0E1E7A0;
  *((_QWORD *)v5 + 15) = 0;
  v6 = *(_QWORD *)(*((_QWORD *)v5 + 3) + 48);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v25[0] = *(_QWORD *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v25);
    if (v18 == 14 && *AttrData == 0x746163732E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x646E5F7265747461)
    {
      v24 = 1283;
      v23[0] = (uint64_t)"classof on '";
      v23[2] = (uint64_t)"mps.scatter_nd";
      v23[3] = 14;
      v21 = "' failed due to the operation not being registered";
      v22 = 259;
      llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
      llvm::report_fatal_error((llvm::Twine *)v25, 1);
    }
LABEL_11:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id)
    goto LABEL_11;
  v20 = *((_QWORD *)v5 + 3);
  v8 = objc_alloc(MEMORY[0x1E0CC7158]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice", v20);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v25[0] = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v20);
  v10 = objc_msgSend(v8, "initWithDevice:operation:", v9, mlir::AffineExpr::getKind((mlir::AffineExpr *)v25));
  v11 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v10;

  v12 = objc_alloc(MEMORY[0x1E0CC7030]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = objc_msgSend(v12, "initWithDevice:", v13);
  v15 = *(void **)(a1 + 120);
  *(_QWORD *)(a1 + 120) = v14;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  objc_msgSend(*(id *)(a1 + 120), "setOptions:", objc_msgSend(*(id *)(a1 + 120), "options") | 1);
  return a1;
}

void sub_180E3A740(_Unwind_Exception *a1)
{
  id *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void sub_180E3A764(_Unwind_Exception *a1)
{
  id *v1;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void GPU::ScatterNDOpHandler::encodeNDArrayOp(GPU::ScatterNDOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  NSArray *v5;
  uint64_t v6;
  void *v7;
  uint64_t Input;
  uint64_t Filter;
  uint64_t Bias;
  int8x8_t *v11;
  mlir::Block *ParentRegion;
  int8x8_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint8x8_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  int8x8_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint8x8_t v29;
  unint64_t v30;
  uint64_t ***v31;
  uint64_t **v32;
  uint64_t v33;
  uint64_t *v34;
  unint64_t v35;
  uint64_t *v36;
  void *v37;
  int8x8_t *v38;
  mlir::Block *v39;
  int8x8_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint8x8_t v45;
  unint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  int8x8_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint8x8_t v56;
  unint64_t v57;
  uint64_t ***v58;
  uint64_t **v59;
  uint64_t v60;
  uint64_t *v61;
  unint64_t v62;
  uint64_t *v63;
  void *v64;
  int8x8_t *v65;
  mlir::Block *v66;
  int8x8_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint8x8_t v72;
  unint64_t v73;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int8x8_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  uint8x8_t v83;
  unint64_t v84;
  uint64_t ***v85;
  uint64_t **v86;
  uint64_t v87;
  uint64_t *v88;
  unint64_t v89;
  uint64_t *v90;
  void *v91;
  void *v92;
  void *v93;
  id v94;
  void *v95;
  uint64_t v96;
  void *v97;
  void *v98;
  uint64_t v99;
  void *v100;
  id v101;
  uint64_t v102;
  void *v103;
  _QWORD *AttrData;
  uint64_t v105;
  uint64_t v107;
  const char *v108;
  __int16 v109;
  uint64_t v110[4];
  __int16 v111;
  _QWORD v112[5];
  _QWORD v113[5];

  v113[3] = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v112[0] = *(_QWORD *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v112);
    if (v105 == 14 && *AttrData == 0x746163732E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x646E5F7265747461)
    {
      v111 = 1283;
      v110[0] = (uint64_t)"classof on '";
      v110[2] = (uint64_t)"mps.scatter_nd";
      v110[3] = 14;
      v108 = "' failed due to the operation not being registered";
      v109 = 259;
      llvm::operator+(v110, (uint64_t *)&v108, (uint64_t)v112);
      llvm::report_fatal_error((llvm::Twine *)v112, 1);
    }
LABEL_151:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id)
    goto LABEL_151;
  v107 = *((_QWORD *)this + 3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v107);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v107);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v107);
  v11 = (int8x8_t *)*((_QWORD *)this + 2);
  v112[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v112);
  v13 = v11[12];
  if (!*(_QWORD *)&v13)
    goto LABEL_44;
  v14 = *((_QWORD *)ParentRegion + 2);
  v15 = 0x9DDFEA08EB382D69 * (((8 * v14) + 8) ^ HIDWORD(v14));
  v16 = 0x9DDFEA08EB382D69 * (HIDWORD(v14) ^ (v15 >> 47) ^ v15);
  v17 = 0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47));
  v18 = (uint8x8_t)vcnt_s8(v13);
  v18.i16[0] = vaddlv_u8(v18);
  if (v18.u32[0] > 1uLL)
  {
    v19 = 0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47));
    if (v17 >= *(_QWORD *)&v13)
      v19 = v17 % *(_QWORD *)&v13;
  }
  else
  {
    v19 = v17 & (*(_QWORD *)&v13 - 1);
  }
  v20 = *(_QWORD **)(*(_QWORD *)&v11[11] + 8 * v19);
  if (!v20)
    goto LABEL_44;
  v21 = (_QWORD *)*v20;
  if (!v21)
    goto LABEL_44;
  if (v18.u32[0] < 2uLL)
  {
    v22 = *(_QWORD *)&v13 - 1;
    while (1)
    {
      v24 = v21[1];
      if (v24 == v17)
      {
        if (v21[2] == v14)
          goto LABEL_24;
      }
      else if ((v24 & v22) != v19)
      {
        goto LABEL_44;
      }
      v21 = (_QWORD *)*v21;
      if (!v21)
        goto LABEL_44;
    }
  }
  while (1)
  {
    v23 = v21[1];
    if (v23 == v17)
      break;
    if (v23 >= *(_QWORD *)&v13)
      v23 %= *(_QWORD *)&v13;
    if (v23 != v19)
      goto LABEL_44;
LABEL_13:
    v21 = (_QWORD *)*v21;
    if (!v21)
      goto LABEL_44;
  }
  if (v21[2] != v14)
    goto LABEL_13;
LABEL_24:
  v25 = (int8x8_t)v21[4];
  if (v25)
  {
    v26 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v112[0])) + 8) ^ HIDWORD(v112[0]));
    v27 = 0x9DDFEA08EB382D69 * (HIDWORD(v112[0]) ^ (v26 >> 47) ^ v26);
    v28 = 0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47));
    v29 = (uint8x8_t)vcnt_s8(v25);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      v30 = v28;
      if (v28 >= *(_QWORD *)&v25)
        v30 = v28 % *(_QWORD *)&v25;
    }
    else
    {
      v30 = v28 & (*(_QWORD *)&v25 - 1);
    }
    v31 = *(uint64_t ****)(v21[3] + 8 * v30);
    if (v31)
    {
      v32 = *v31;
      if (v32)
      {
        if (v29.u32[0] < 2uLL)
        {
          v33 = *(_QWORD *)&v25 - 1;
          while (1)
          {
            v36 = v32[1];
            if (v36 == (uint64_t *)v28)
            {
              if (v32[2] == (uint64_t *)v112[0])
                goto LABEL_139;
            }
            else if (((unint64_t)v36 & v33) != v30)
            {
              goto LABEL_44;
            }
            v34 = 0;
            v32 = (uint64_t **)*v32;
            if (!v32)
              goto LABEL_45;
          }
        }
        while (1)
        {
          v35 = (unint64_t)v32[1];
          if (v35 == v28)
          {
            if (v32[2] == (uint64_t *)v112[0])
            {
LABEL_139:
              v34 = v32[3];
              goto LABEL_45;
            }
          }
          else
          {
            if (v35 >= *(_QWORD *)&v25)
              v35 %= *(_QWORD *)&v25;
            if (v35 != v30)
              break;
          }
          v34 = 0;
          v32 = (uint64_t **)*v32;
          if (!v32)
            goto LABEL_45;
        }
      }
    }
  }
LABEL_44:
  v34 = 0;
LABEL_45:
  objc_msgSend(v34, "mpsndarray");
  v37 = (void *)objc_claimAutoreleasedReturnValue();

  v38 = (int8x8_t *)*((_QWORD *)this + 2);
  v112[0] = Filter;
  v39 = mlir::Value::getParentRegion((mlir::Value *)v112);
  v40 = v38[12];
  if (!*(_QWORD *)&v40)
    goto LABEL_86;
  v41 = *((_QWORD *)v39 + 2);
  v42 = 0x9DDFEA08EB382D69 * (((8 * v41) + 8) ^ HIDWORD(v41));
  v43 = 0x9DDFEA08EB382D69 * (HIDWORD(v41) ^ (v42 >> 47) ^ v42);
  v44 = 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47));
  v45 = (uint8x8_t)vcnt_s8(v40);
  v45.i16[0] = vaddlv_u8(v45);
  if (v45.u32[0] > 1uLL)
  {
    v46 = 0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47));
    if (v44 >= *(_QWORD *)&v40)
      v46 = v44 % *(_QWORD *)&v40;
  }
  else
  {
    v46 = v44 & (*(_QWORD *)&v40 - 1);
  }
  v47 = *(_QWORD **)(*(_QWORD *)&v38[11] + 8 * v46);
  if (!v47)
    goto LABEL_86;
  v48 = (_QWORD *)*v47;
  if (!v48)
    goto LABEL_86;
  if (v45.u32[0] < 2uLL)
  {
    v49 = *(_QWORD *)&v40 - 1;
    while (1)
    {
      v51 = v48[1];
      if (v51 == v44)
      {
        if (v48[2] == v41)
          goto LABEL_66;
      }
      else if ((v51 & v49) != v46)
      {
        goto LABEL_86;
      }
      v48 = (_QWORD *)*v48;
      if (!v48)
        goto LABEL_86;
    }
  }
  while (2)
  {
    v50 = v48[1];
    if (v50 != v44)
    {
      if (v50 >= *(_QWORD *)&v40)
        v50 %= *(_QWORD *)&v40;
      if (v50 != v46)
        goto LABEL_86;
      goto LABEL_55;
    }
    if (v48[2] != v41)
    {
LABEL_55:
      v48 = (_QWORD *)*v48;
      if (!v48)
        goto LABEL_86;
      continue;
    }
    break;
  }
LABEL_66:
  v52 = (int8x8_t)v48[4];
  if (v52)
  {
    v53 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v112[0])) + 8) ^ HIDWORD(v112[0]));
    v54 = 0x9DDFEA08EB382D69 * (HIDWORD(v112[0]) ^ (v53 >> 47) ^ v53);
    v55 = 0x9DDFEA08EB382D69 * (v54 ^ (v54 >> 47));
    v56 = (uint8x8_t)vcnt_s8(v52);
    v56.i16[0] = vaddlv_u8(v56);
    if (v56.u32[0] > 1uLL)
    {
      v57 = v55;
      if (v55 >= *(_QWORD *)&v52)
        v57 = v55 % *(_QWORD *)&v52;
    }
    else
    {
      v57 = v55 & (*(_QWORD *)&v52 - 1);
    }
    v58 = *(uint64_t ****)(v48[3] + 8 * v57);
    if (v58)
    {
      v59 = *v58;
      if (v59)
      {
        if (v56.u32[0] < 2uLL)
        {
          v60 = *(_QWORD *)&v52 - 1;
          while (1)
          {
            v63 = v59[1];
            if (v63 == (uint64_t *)v55)
            {
              if (v59[2] == (uint64_t *)v112[0])
                goto LABEL_140;
            }
            else if (((unint64_t)v63 & v60) != v57)
            {
              goto LABEL_86;
            }
            v61 = 0;
            v59 = (uint64_t **)*v59;
            if (!v59)
              goto LABEL_87;
          }
        }
        while (1)
        {
          v62 = (unint64_t)v59[1];
          if (v62 == v55)
          {
            if (v59[2] == (uint64_t *)v112[0])
            {
LABEL_140:
              v61 = v59[3];
              goto LABEL_87;
            }
          }
          else
          {
            if (v62 >= *(_QWORD *)&v52)
              v62 %= *(_QWORD *)&v52;
            if (v62 != v57)
              break;
          }
          v61 = 0;
          v59 = (uint64_t **)*v59;
          if (!v59)
            goto LABEL_87;
        }
      }
    }
  }
LABEL_86:
  v61 = 0;
LABEL_87:
  objc_msgSend(v61, "mpsndarray");
  v64 = (void *)objc_claimAutoreleasedReturnValue();

  v65 = (int8x8_t *)*((_QWORD *)this + 2);
  v112[0] = Bias;
  v66 = mlir::Value::getParentRegion((mlir::Value *)v112);
  v67 = v65[12];
  if (!*(_QWORD *)&v67)
    goto LABEL_128;
  v68 = *((_QWORD *)v66 + 2);
  v69 = 0x9DDFEA08EB382D69 * (((8 * v68) + 8) ^ HIDWORD(v68));
  v70 = 0x9DDFEA08EB382D69 * (HIDWORD(v68) ^ (v69 >> 47) ^ v69);
  v71 = 0x9DDFEA08EB382D69 * (v70 ^ (v70 >> 47));
  v72 = (uint8x8_t)vcnt_s8(v67);
  v72.i16[0] = vaddlv_u8(v72);
  if (v72.u32[0] > 1uLL)
  {
    v73 = 0x9DDFEA08EB382D69 * (v70 ^ (v70 >> 47));
    if (v71 >= *(_QWORD *)&v67)
      v73 = v71 % *(_QWORD *)&v67;
  }
  else
  {
    v73 = v71 & (*(_QWORD *)&v67 - 1);
  }
  v74 = *(_QWORD **)(*(_QWORD *)&v65[11] + 8 * v73);
  if (!v74)
    goto LABEL_128;
  v75 = (_QWORD *)*v74;
  if (!v75)
    goto LABEL_128;
  if (v72.u32[0] < 2uLL)
  {
    v76 = *(_QWORD *)&v67 - 1;
    while (1)
    {
      v78 = v75[1];
      if (v78 == v71)
      {
        if (v75[2] == v68)
          goto LABEL_108;
      }
      else if ((v78 & v76) != v73)
      {
        goto LABEL_128;
      }
      v75 = (_QWORD *)*v75;
      if (!v75)
        goto LABEL_128;
    }
  }
  while (1)
  {
    v77 = v75[1];
    if (v77 == v71)
      break;
    if (v77 >= *(_QWORD *)&v67)
      v77 %= *(_QWORD *)&v67;
    if (v77 != v73)
      goto LABEL_128;
LABEL_97:
    v75 = (_QWORD *)*v75;
    if (!v75)
      goto LABEL_128;
  }
  if (v75[2] != v68)
    goto LABEL_97;
LABEL_108:
  v79 = (int8x8_t)v75[4];
  if (!*(_QWORD *)&v79)
    goto LABEL_128;
  v80 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v112[0])) + 8) ^ HIDWORD(v112[0]));
  v81 = 0x9DDFEA08EB382D69 * (HIDWORD(v112[0]) ^ (v80 >> 47) ^ v80);
  v82 = 0x9DDFEA08EB382D69 * (v81 ^ (v81 >> 47));
  v83 = (uint8x8_t)vcnt_s8(v79);
  v83.i16[0] = vaddlv_u8(v83);
  if (v83.u32[0] > 1uLL)
  {
    v84 = v82;
    if (v82 >= *(_QWORD *)&v79)
      v84 = v82 % *(_QWORD *)&v79;
  }
  else
  {
    v84 = v82 & (*(_QWORD *)&v79 - 1);
  }
  v85 = *(uint64_t ****)(v75[3] + 8 * v84);
  if (!v85 || (v86 = *v85) == 0)
  {
LABEL_128:
    v88 = 0;
    goto LABEL_129;
  }
  if (v83.u32[0] < 2uLL)
  {
    v87 = *(_QWORD *)&v79 - 1;
    while (1)
    {
      v90 = v86[1];
      if (v90 == (uint64_t *)v82)
      {
        if (v86[2] == (uint64_t *)v112[0])
          goto LABEL_141;
      }
      else if (((unint64_t)v90 & v87) != v84)
      {
        goto LABEL_128;
      }
      v88 = 0;
      v86 = (uint64_t **)*v86;
      if (!v86)
        goto LABEL_129;
    }
  }
  while (1)
  {
    v89 = (unint64_t)v86[1];
    if (v89 == v82)
      break;
    if (v89 >= *(_QWORD *)&v79)
      v89 %= *(_QWORD *)&v79;
    if (v89 != v84)
      goto LABEL_128;
LABEL_118:
    v88 = 0;
    v86 = (uint64_t **)*v86;
    if (!v86)
      goto LABEL_129;
  }
  if (v86[2] != (uint64_t *)v112[0])
    goto LABEL_118;
LABEL_141:
  v88 = v86[3];
LABEL_129:
  objc_msgSend(v88, "mpsndarray");
  v91 = (void *)objc_claimAutoreleasedReturnValue();

  -[NSArray objectAtIndexedSubscript:](v5, "objectAtIndexedSubscript:", 0);
  v92 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v92, "mpsndarray");
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  if ((!v93 || !v37 || !v64 || !v91) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v94 = *((id *)this + 1);
  objc_msgSend(v94, "setBatchDimensions:", mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v107));
  v95 = (void *)*((_QWORD *)a2 + 9);
  if (!v95)
  {
    v96 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
    v97 = (void *)*((_QWORD *)a2 + 9);
    *((_QWORD *)a2 + 9) = v96;

    v98 = (void *)*((_QWORD *)a2 + 11);
    v95 = (void *)*((_QWORD *)a2 + 9);
    if (v98)
    {
      objc_msgSend(v98, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
      v99 = objc_claimAutoreleasedReturnValue();
      v100 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v99;

      v95 = (void *)*((_QWORD *)a2 + 9);
    }
  }
  if (*((_QWORD *)a2 + 10))
  {
    objc_msgSend(v95, "setLabel:");
    v95 = (void *)*((_QWORD *)a2 + 9);
  }
  v101 = v95;
  v102 = *((_QWORD *)a2 + 1);
  v113[0] = v37;
  v113[1] = v64;
  v113[2] = v91;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v113, 3);
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v94, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v101, v102, v103, v93);

}

void sub_180E3B11C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void GPU::ScatterOpHandler::~ScatterOpHandler(id *this)
{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
}

{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
  JUMPOUT(0x186DA1680);
}

void GPU::ScatterAlongAxisOpHandler::~ScatterAlongAxisOpHandler(id *this)
{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
}

{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
  JUMPOUT(0x186DA1680);
}

void GPU::ScatterNDOpHandler::~ScatterNDOpHandler(id *this)
{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
}

{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
  JUMPOUT(0x186DA1680);
}

void GPU::ScatterGenericOpHandler<mlir::mps::ScatterOp>::~ScatterGenericOpHandler(id *a1)
{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
}

{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
  JUMPOUT(0x186DA1680);
}

void GPU::ScatterGenericOpHandler<mlir::mps::ScatterAlongAxisOp>::~ScatterGenericOpHandler(id *a1)
{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
}

{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
  JUMPOUT(0x186DA1680);
}

void GPU::ScatterGenericOpHandler<mlir::mps::ScatterNDOp>::~ScatterGenericOpHandler(id *a1)
{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
}

{

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)a1);
  JUMPOUT(0x186DA1680);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::BaseCumulativeOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  _BOOL8 InferredResultTypes;
  uint64_t v11;
  void *v12;
  uint64_t AttrData;
  uint64_t v15;
  mlir::Operation *v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[5];

  *(_QWORD *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4) = &off_1E0E1DDA0;
  v6 = *((_QWORD *)a3 + 6);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v23[0] = *(_QWORD *)(v6 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
    if (v15 == 18
      && *(_QWORD *)AttrData == 0x756D75632E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x735F65766974616CLL
      && *(_WORD *)(AttrData + 16) == 28021)
    {
      v22 = 1283;
      v21[0] = (uint64_t)"classof on '";
      v21[2] = (uint64_t)"mps.cumulative_sum";
      v21[3] = 18;
      v19 = "' failed due to the operation not being registered";
      v20 = 259;
      llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
      llvm::report_fatal_error((llvm::Twine *)v23, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id)
    goto LABEL_14;
  v18 = a3;
  v8 = objc_alloc(MEMORY[0x1E0CC7150]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice", a3);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v18);
  v11 = objc_msgSend(v8, "initWithDevice:axis:operation:exclusive:reverse:", v9, 0, 0, InferredResultTypes, mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v18));
  v12 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v11;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  return a1;
}

void sub_180E3B5EC(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E3B604(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::BaseCumulativeOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  _BOOL8 InferredResultTypes;
  uint64_t v11;
  void *v12;
  _QWORD *AttrData;
  uint64_t v15;
  mlir::Operation *v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[5];

  *(_QWORD *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4) = &off_1E0E1DE90;
  v6 = *((_QWORD *)a3 + 6);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v23[0] = *(_QWORD *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
    if (v15 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x705F65766974616CLL
      && *(_QWORD *)((char *)AttrData + 14) == 0x746375646F72705FLL)
    {
      v22 = 1283;
      v21[0] = (uint64_t)"classof on '";
      v21[2] = (uint64_t)"mps.cumulative_product";
      v21[3] = 22;
      v19 = "' failed due to the operation not being registered";
      v20 = 259;
      llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
      llvm::report_fatal_error((llvm::Twine *)v23, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id)
    goto LABEL_14;
  v18 = a3;
  v8 = objc_alloc(MEMORY[0x1E0CC7150]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice", a3);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v18);
  v11 = objc_msgSend(v8, "initWithDevice:axis:operation:exclusive:reverse:", v9, 0, 1, InferredResultTypes, mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v18));
  v12 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v11;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  return a1;
}

void sub_180E3B7E0(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E3B7F8(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::BaseCumulativeOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  _BOOL8 InferredResultTypes;
  uint64_t v11;
  void *v12;
  _QWORD *AttrData;
  uint64_t v15;
  mlir::Operation *v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[5];

  *(_QWORD *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4) = &off_1E0E1DDF0;
  v6 = *((_QWORD *)a3 + 6);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v23[0] = *(_QWORD *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
    if (v15 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x6D5F65766974616CLL
      && *(_QWORD *)((char *)AttrData + 14) == 0x6D756D6978616D5FLL)
    {
      v22 = 1283;
      v21[0] = (uint64_t)"classof on '";
      v21[2] = (uint64_t)"mps.cumulative_maximum";
      v21[3] = 22;
      v19 = "' failed due to the operation not being registered";
      v20 = 259;
      llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
      llvm::report_fatal_error((llvm::Twine *)v23, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id)
    goto LABEL_14;
  v18 = a3;
  v8 = objc_alloc(MEMORY[0x1E0CC7150]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice", a3);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v18);
  v11 = objc_msgSend(v8, "initWithDevice:axis:operation:exclusive:reverse:", v9, 0, 2, InferredResultTypes, mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v18));
  v12 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v11;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  return a1;
}

void sub_180E3B9D4(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E3B9EC(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::BaseCumulativeOpHandler(uint64_t a1, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v6;
  void *v7;
  id v8;
  void *v9;
  _BOOL8 InferredResultTypes;
  uint64_t v11;
  void *v12;
  _QWORD *AttrData;
  uint64_t v15;
  mlir::Operation *v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[5];

  *(_QWORD *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)a1, a2, a3, a4) = &off_1E0E1DE40;
  v6 = *((_QWORD *)a3 + 6);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v23[0] = *(_QWORD *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v23);
    if (v15 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x6D5F65766974616CLL
      && *(_QWORD *)((char *)AttrData + 14) == 0x6D756D696E696D5FLL)
    {
      v22 = 1283;
      v21[0] = (uint64_t)"classof on '";
      v21[2] = (uint64_t)"mps.cumulative_minimum";
      v21[3] = 22;
      v19 = "' failed due to the operation not being registered";
      v20 = 259;
      llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
      llvm::report_fatal_error((llvm::Twine *)v23, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id)
    goto LABEL_14;
  v18 = a3;
  v8 = objc_alloc(MEMORY[0x1E0CC7150]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice", a3);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v18);
  v11 = objc_msgSend(v8, "initWithDevice:axis:operation:exclusive:reverse:", v9, 0, 3, InferredResultTypes, mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v18));
  v12 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v11;

  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);
  return a1;
}

void sub_180E3BBC8(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E3BBE0(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  uint64_t v5;
  void *v6;
  uint64_t Input;
  void *Filter;
  void *v9;
  int8x8_t *v10;
  mlir::Block *ParentRegion;
  int8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int8x8_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  uint64_t ***v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  uint64_t *v35;
  void *v36;
  void *v37;
  id v38;
  uint64_t Axis;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  void *v52;
  uint64_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t *v60;
  void *v61;
  id v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  uint64_t AttrData;
  uint64_t v68;
  BOOL v69;
  id v71;
  void *v72;
  uint64_t v73;
  uint64_t v74[4];
  __int16 v75;
  uint64_t v76[2];
  const char *v77;
  uint64_t v78;
  __int16 v79;
  _QWORD v80[4];
  __int16 v81;
  _QWORD v82[3];

  v82[1] = *MEMORY[0x1E0C80C00];
  v71 = a3;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v80[0] = *(_QWORD *)(v5 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
    if (v68 == 18)
    {
      v69 = *(_QWORD *)AttrData == 0x756D75632E73706DLL && *(_QWORD *)(AttrData + 8) == 0x735F65766974616CLL;
      if (v69 && *(_WORD *)(AttrData + 16) == 28021)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mps.cumulative_sum";
        v78 = 18;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id)
    goto LABEL_94;
  v73 = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  objc_msgSend(v71, "objectAtIndexedSubscript:", 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = *(int8x8_t **)(a1 + 16);
  v80[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v80);
  v12 = v10[12];
  if (!*(_QWORD *)&v12)
    goto LABEL_44;
  v13 = *((_QWORD *)ParentRegion + 2);
  v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(_QWORD *)&v12)
      v18 = v16 % *(_QWORD *)&v12;
  }
  else
  {
    v18 = v16 & (*(_QWORD *)&v12 - 1);
  }
  v19 = *(_QWORD **)(*(_QWORD *)&v10[11] + 8 * v18);
  if (!v19)
    goto LABEL_44;
  v20 = (_QWORD *)*v19;
  if (!v20)
    goto LABEL_44;
  if (v17.u32[0] < 2uLL)
  {
    v21 = *(_QWORD *)&v12 - 1;
    while (1)
    {
      v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13)
          goto LABEL_24;
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      v20 = (_QWORD *)*v20;
      if (!v20)
        goto LABEL_44;
    }
  }
  while (1)
  {
    v22 = v20[1];
    if (v22 == v16)
      break;
    if (v22 >= *(_QWORD *)&v12)
      v22 %= *(_QWORD *)&v12;
    if (v22 != v18)
      goto LABEL_44;
LABEL_13:
    v20 = (_QWORD *)*v20;
    if (!v20)
      goto LABEL_44;
  }
  if (v20[2] != v13)
    goto LABEL_13;
LABEL_24:
  v24 = (int8x8_t)v20[4];
  if (!*(_QWORD *)&v24)
    goto LABEL_44;
  v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v80[0])) + 8) ^ HIDWORD(v80[0]));
  v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v80[0]) ^ (v25 >> 47) ^ v25);
  v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  v28 = (uint8x8_t)vcnt_s8(v24);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(_QWORD *)&v24)
      v29 = v27 % *(_QWORD *)&v24;
  }
  else
  {
    v29 = v27 & (*(_QWORD *)&v24 - 1);
  }
  v30 = *(uint64_t ****)(v20[3] + 8 * v29);
  if (!v30 || (v31 = *v30) == 0)
  {
LABEL_44:
    v33 = 0;
    goto LABEL_45;
  }
  if (v28.u32[0] < 2uLL)
  {
    v32 = *(_QWORD *)&v24 - 1;
    while (1)
    {
      v35 = v31[1];
      if (v35 == (uint64_t *)v27)
      {
        if (v31[2] == (uint64_t *)v80[0])
          goto LABEL_76;
      }
      else if (((unint64_t)v35 & v32) != v29)
      {
        goto LABEL_44;
      }
      v33 = 0;
      v31 = (uint64_t **)*v31;
      if (!v31)
        goto LABEL_45;
    }
  }
  while (1)
  {
    v34 = (unint64_t)v31[1];
    if (v34 == v27)
      break;
    if (v34 >= *(_QWORD *)&v24)
      v34 %= *(_QWORD *)&v24;
    if (v34 != v29)
      goto LABEL_44;
LABEL_34:
    v33 = 0;
    v31 = (uint64_t **)*v31;
    if (!v31)
      goto LABEL_45;
  }
  if (v31[2] != (uint64_t *)v80[0])
    goto LABEL_34;
LABEL_76:
  v33 = v31[3];
LABEL_45:
  objc_msgSend(v33, "mpsndarray", v71);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "mpsndarray");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = *(id *)(a1 + 8);
  Axis = RuntimeUtils::getAxis(*(_QWORD *)(a1 + 16), (uint64_t)a2, Filter, objc_msgSend(v36, "numberOfDimensions"));
  v40 = objc_msgSend(v36, "numberOfDimensions");
  if (Axis >= 0)
    v41 = v40;
  else
    v41 = 0;
  objc_msgSend(v38, "setAxis:", v41 + ~Axis);
  objc_msgSend(v38, "setExclusive:", mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v73));
  objc_msgSend(v38, "setReverse:", mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v73));
  if (*(_QWORD *)(a1 + 32))
  {
    v42 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v42 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(_QWORD *)(v42 + 8);
      v43 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v44 == 13 && *v43 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v43 + 5) == 0x6465686374697473)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mpsx.stitched";
        v78 = 13;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    v46 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    v47 = *(void **)(v46 + 16);
    if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(_QWORD *)(v46 + 8);
      v64 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v65 == 13 && *v64 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v64 + 5) == 0x6465686374697473)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mpsx.stitched";
        v78 = 13;
        v80[0] = v76;
        v80[2] = "' failed due to the operation not being registered";
        v81 = 770;
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    else if (v47 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_57;
    }
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
LABEL_57:
    GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v49 = (void *)*((_QWORD *)a2 + 9);
    if (!v49)
    {
      v50 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
      v51 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v50;

      v52 = (void *)*((_QWORD *)a2 + 11);
      v49 = (void *)*((_QWORD *)a2 + 9);
      if (v52)
      {
        objc_msgSend(v52, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
        v53 = objc_claimAutoreleasedReturnValue();
        v54 = (void *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = v53;

        v49 = (void *)*((_QWORD *)a2 + 9);
      }
    }
    if (*((_QWORD *)a2 + 10))
    {
      objc_msgSend(v49, "setLabel:");
      v49 = (void *)*((_QWORD *)a2 + 9);
    }
    v55 = v49;
    v56 = *((_QWORD *)a2 + 1);
    v57 = *(_QWORD *)(a1 + 32);
    v58 = *(void **)(v57 + 120);
    if (!v58)
    {
      if (!*(_QWORD *)(v57 + 96) && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      v59 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6EC8]), "initWithKernelDAG:finalOp:", v57 + 80, *(_QWORD *)(*(_QWORD *)(v57 + 96) + 32));
      v61 = *(void **)(v57 + 120);
      v60 = (uint64_t *)(v57 + 120);
      *v60 = v59;

      v58 = (void *)*v60;
    }
    v62 = v58;
    objc_msgSend(v38, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v55, v56, v48, 0, v37, v62);

  }
  else
  {
    if (!v36 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v63 = *((_QWORD *)a2 + 1);
    v82[0] = v36;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v82, 1);
    v55 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v38, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v48, v63, v55, v37);
  }

}

void sub_180E3C3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  unint64_t Input;
  uint64_t result;
  uint64_t AttrData;
  uint64_t v9;
  const char *v12;
  __int16 v13;
  uint64_t v14[4];
  __int16 v15;
  _QWORD v16[5];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(_QWORD *)(v2 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v9 == 18
      && *(_QWORD *)AttrData == 0x756D75632E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x735F65766974616CLL
      && *(_WORD *)(AttrData + 16) == 28021)
    {
      v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.cumulative_sum";
      v14[3] = 18;
      v12 = "' failed due to the operation not being registered";
      v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id)
    goto LABEL_14;
  v16[0] = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  result = MPSKernelDAG::unaryCoreOp();
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 24);
  return result;
}

void GPU::CumulativeSumOpHandler::~CumulativeSumOpHandler(GPU::CumulativeSumOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

unint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  uint64_t v5;
  void *v6;
  uint64_t Input;
  void *Filter;
  void *v9;
  int8x8_t *v10;
  mlir::Block *ParentRegion;
  int8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int8x8_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  uint64_t ***v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  uint64_t *v35;
  void *v36;
  void *v37;
  id v38;
  uint64_t Axis;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  void *v52;
  uint64_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t *v60;
  void *v61;
  id v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  _QWORD *AttrData;
  uint64_t v68;
  BOOL v69;
  id v71;
  void *v72;
  uint64_t v73;
  uint64_t v74[4];
  __int16 v75;
  uint64_t v76[2];
  const char *v77;
  uint64_t v78;
  __int16 v79;
  _QWORD v80[4];
  __int16 v81;
  _QWORD v82[3];

  v82[1] = *MEMORY[0x1E0C80C00];
  v71 = a3;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v80[0] = *(_QWORD *)(v5 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
    if (v68 == 22)
    {
      v69 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x705F65766974616CLL;
      if (v69 && *(_QWORD *)((char *)AttrData + 14) == 0x746375646F72705FLL)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mps.cumulative_product";
        v78 = 22;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id)
    goto LABEL_94;
  v73 = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  objc_msgSend(v71, "objectAtIndexedSubscript:", 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = *(int8x8_t **)(a1 + 16);
  v80[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v80);
  v12 = v10[12];
  if (!*(_QWORD *)&v12)
    goto LABEL_44;
  v13 = *((_QWORD *)ParentRegion + 2);
  v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(_QWORD *)&v12)
      v18 = v16 % *(_QWORD *)&v12;
  }
  else
  {
    v18 = v16 & (*(_QWORD *)&v12 - 1);
  }
  v19 = *(_QWORD **)(*(_QWORD *)&v10[11] + 8 * v18);
  if (!v19)
    goto LABEL_44;
  v20 = (_QWORD *)*v19;
  if (!v20)
    goto LABEL_44;
  if (v17.u32[0] < 2uLL)
  {
    v21 = *(_QWORD *)&v12 - 1;
    while (1)
    {
      v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13)
          goto LABEL_24;
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      v20 = (_QWORD *)*v20;
      if (!v20)
        goto LABEL_44;
    }
  }
  while (1)
  {
    v22 = v20[1];
    if (v22 == v16)
      break;
    if (v22 >= *(_QWORD *)&v12)
      v22 %= *(_QWORD *)&v12;
    if (v22 != v18)
      goto LABEL_44;
LABEL_13:
    v20 = (_QWORD *)*v20;
    if (!v20)
      goto LABEL_44;
  }
  if (v20[2] != v13)
    goto LABEL_13;
LABEL_24:
  v24 = (int8x8_t)v20[4];
  if (!*(_QWORD *)&v24)
    goto LABEL_44;
  v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v80[0])) + 8) ^ HIDWORD(v80[0]));
  v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v80[0]) ^ (v25 >> 47) ^ v25);
  v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  v28 = (uint8x8_t)vcnt_s8(v24);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(_QWORD *)&v24)
      v29 = v27 % *(_QWORD *)&v24;
  }
  else
  {
    v29 = v27 & (*(_QWORD *)&v24 - 1);
  }
  v30 = *(uint64_t ****)(v20[3] + 8 * v29);
  if (!v30 || (v31 = *v30) == 0)
  {
LABEL_44:
    v33 = 0;
    goto LABEL_45;
  }
  if (v28.u32[0] < 2uLL)
  {
    v32 = *(_QWORD *)&v24 - 1;
    while (1)
    {
      v35 = v31[1];
      if (v35 == (uint64_t *)v27)
      {
        if (v31[2] == (uint64_t *)v80[0])
          goto LABEL_76;
      }
      else if (((unint64_t)v35 & v32) != v29)
      {
        goto LABEL_44;
      }
      v33 = 0;
      v31 = (uint64_t **)*v31;
      if (!v31)
        goto LABEL_45;
    }
  }
  while (1)
  {
    v34 = (unint64_t)v31[1];
    if (v34 == v27)
      break;
    if (v34 >= *(_QWORD *)&v24)
      v34 %= *(_QWORD *)&v24;
    if (v34 != v29)
      goto LABEL_44;
LABEL_34:
    v33 = 0;
    v31 = (uint64_t **)*v31;
    if (!v31)
      goto LABEL_45;
  }
  if (v31[2] != (uint64_t *)v80[0])
    goto LABEL_34;
LABEL_76:
  v33 = v31[3];
LABEL_45:
  objc_msgSend(v33, "mpsndarray", v71);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "mpsndarray");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = *(id *)(a1 + 8);
  Axis = RuntimeUtils::getAxis(*(_QWORD *)(a1 + 16), (uint64_t)a2, Filter, objc_msgSend(v36, "numberOfDimensions"));
  v40 = objc_msgSend(v36, "numberOfDimensions");
  if (Axis >= 0)
    v41 = v40;
  else
    v41 = 0;
  objc_msgSend(v38, "setAxis:", v41 + ~Axis);
  objc_msgSend(v38, "setExclusive:", mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v73));
  objc_msgSend(v38, "setReverse:", mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v73));
  if (*(_QWORD *)(a1 + 32))
  {
    v42 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v42 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(_QWORD *)(v42 + 8);
      v43 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v44 == 13 && *v43 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v43 + 5) == 0x6465686374697473)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mpsx.stitched";
        v78 = 13;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    v46 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    v47 = *(void **)(v46 + 16);
    if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(_QWORD *)(v46 + 8);
      v64 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v65 == 13 && *v64 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v64 + 5) == 0x6465686374697473)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mpsx.stitched";
        v78 = 13;
        v80[0] = v76;
        v80[2] = "' failed due to the operation not being registered";
        v81 = 770;
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    else if (v47 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_57;
    }
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
LABEL_57:
    GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v49 = (void *)*((_QWORD *)a2 + 9);
    if (!v49)
    {
      v50 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
      v51 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v50;

      v52 = (void *)*((_QWORD *)a2 + 11);
      v49 = (void *)*((_QWORD *)a2 + 9);
      if (v52)
      {
        objc_msgSend(v52, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
        v53 = objc_claimAutoreleasedReturnValue();
        v54 = (void *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = v53;

        v49 = (void *)*((_QWORD *)a2 + 9);
      }
    }
    if (*((_QWORD *)a2 + 10))
    {
      objc_msgSend(v49, "setLabel:");
      v49 = (void *)*((_QWORD *)a2 + 9);
    }
    v55 = v49;
    v56 = *((_QWORD *)a2 + 1);
    v57 = *(_QWORD *)(a1 + 32);
    v58 = *(void **)(v57 + 120);
    if (!v58)
    {
      if (!*(_QWORD *)(v57 + 96) && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      v59 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6EC8]), "initWithKernelDAG:finalOp:", v57 + 80, *(_QWORD *)(*(_QWORD *)(v57 + 96) + 32));
      v61 = *(void **)(v57 + 120);
      v60 = (uint64_t *)(v57 + 120);
      *v60 = v59;

      v58 = (void *)*v60;
    }
    v62 = v58;
    objc_msgSend(v38, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v55, v56, v48, 0, v37, v62);

  }
  else
  {
    if (!v36 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v63 = *((_QWORD *)a2 + 1);
    v82[0] = v36;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v82, 1);
    v55 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v38, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v48, v63, v55, v37);
  }

}

void sub_180E3CE4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  unint64_t Input;
  uint64_t result;
  _QWORD *AttrData;
  uint64_t v9;
  const char *v12;
  __int16 v13;
  uint64_t v14[4];
  __int16 v15;
  _QWORD v16[5];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(_QWORD *)(v2 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v9 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x705F65766974616CLL
      && *(_QWORD *)((char *)AttrData + 14) == 0x746375646F72705FLL)
    {
      v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.cumulative_product";
      v14[3] = 22;
      v12 = "' failed due to the operation not being registered";
      v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id)
    goto LABEL_14;
  v16[0] = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  result = MPSKernelDAG::unaryCoreOp();
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 24);
  return result;
}

void GPU::CumulativeProductOpHandler::~CumulativeProductOpHandler(GPU::CumulativeProductOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

unint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  uint64_t v5;
  void *v6;
  uint64_t Input;
  void *Filter;
  void *v9;
  int8x8_t *v10;
  mlir::Block *ParentRegion;
  int8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int8x8_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  uint64_t ***v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  uint64_t *v35;
  void *v36;
  void *v37;
  id v38;
  uint64_t Axis;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  void *v52;
  uint64_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t *v60;
  void *v61;
  id v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  _QWORD *AttrData;
  uint64_t v68;
  BOOL v69;
  id v71;
  void *v72;
  uint64_t v73;
  uint64_t v74[4];
  __int16 v75;
  uint64_t v76[2];
  const char *v77;
  uint64_t v78;
  __int16 v79;
  _QWORD v80[4];
  __int16 v81;
  _QWORD v82[3];

  v82[1] = *MEMORY[0x1E0C80C00];
  v71 = a3;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v80[0] = *(_QWORD *)(v5 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
    if (v68 == 22)
    {
      v69 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x6D5F65766974616CLL;
      if (v69 && *(_QWORD *)((char *)AttrData + 14) == 0x6D756D6978616D5FLL)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mps.cumulative_maximum";
        v78 = 22;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id)
    goto LABEL_94;
  v73 = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  objc_msgSend(v71, "objectAtIndexedSubscript:", 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = *(int8x8_t **)(a1 + 16);
  v80[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v80);
  v12 = v10[12];
  if (!*(_QWORD *)&v12)
    goto LABEL_44;
  v13 = *((_QWORD *)ParentRegion + 2);
  v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(_QWORD *)&v12)
      v18 = v16 % *(_QWORD *)&v12;
  }
  else
  {
    v18 = v16 & (*(_QWORD *)&v12 - 1);
  }
  v19 = *(_QWORD **)(*(_QWORD *)&v10[11] + 8 * v18);
  if (!v19)
    goto LABEL_44;
  v20 = (_QWORD *)*v19;
  if (!v20)
    goto LABEL_44;
  if (v17.u32[0] < 2uLL)
  {
    v21 = *(_QWORD *)&v12 - 1;
    while (1)
    {
      v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13)
          goto LABEL_24;
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      v20 = (_QWORD *)*v20;
      if (!v20)
        goto LABEL_44;
    }
  }
  while (1)
  {
    v22 = v20[1];
    if (v22 == v16)
      break;
    if (v22 >= *(_QWORD *)&v12)
      v22 %= *(_QWORD *)&v12;
    if (v22 != v18)
      goto LABEL_44;
LABEL_13:
    v20 = (_QWORD *)*v20;
    if (!v20)
      goto LABEL_44;
  }
  if (v20[2] != v13)
    goto LABEL_13;
LABEL_24:
  v24 = (int8x8_t)v20[4];
  if (!*(_QWORD *)&v24)
    goto LABEL_44;
  v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v80[0])) + 8) ^ HIDWORD(v80[0]));
  v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v80[0]) ^ (v25 >> 47) ^ v25);
  v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  v28 = (uint8x8_t)vcnt_s8(v24);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(_QWORD *)&v24)
      v29 = v27 % *(_QWORD *)&v24;
  }
  else
  {
    v29 = v27 & (*(_QWORD *)&v24 - 1);
  }
  v30 = *(uint64_t ****)(v20[3] + 8 * v29);
  if (!v30 || (v31 = *v30) == 0)
  {
LABEL_44:
    v33 = 0;
    goto LABEL_45;
  }
  if (v28.u32[0] < 2uLL)
  {
    v32 = *(_QWORD *)&v24 - 1;
    while (1)
    {
      v35 = v31[1];
      if (v35 == (uint64_t *)v27)
      {
        if (v31[2] == (uint64_t *)v80[0])
          goto LABEL_76;
      }
      else if (((unint64_t)v35 & v32) != v29)
      {
        goto LABEL_44;
      }
      v33 = 0;
      v31 = (uint64_t **)*v31;
      if (!v31)
        goto LABEL_45;
    }
  }
  while (1)
  {
    v34 = (unint64_t)v31[1];
    if (v34 == v27)
      break;
    if (v34 >= *(_QWORD *)&v24)
      v34 %= *(_QWORD *)&v24;
    if (v34 != v29)
      goto LABEL_44;
LABEL_34:
    v33 = 0;
    v31 = (uint64_t **)*v31;
    if (!v31)
      goto LABEL_45;
  }
  if (v31[2] != (uint64_t *)v80[0])
    goto LABEL_34;
LABEL_76:
  v33 = v31[3];
LABEL_45:
  objc_msgSend(v33, "mpsndarray", v71);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "mpsndarray");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = *(id *)(a1 + 8);
  Axis = RuntimeUtils::getAxis(*(_QWORD *)(a1 + 16), (uint64_t)a2, Filter, objc_msgSend(v36, "numberOfDimensions"));
  v40 = objc_msgSend(v36, "numberOfDimensions");
  if (Axis >= 0)
    v41 = v40;
  else
    v41 = 0;
  objc_msgSend(v38, "setAxis:", v41 + ~Axis);
  objc_msgSend(v38, "setExclusive:", mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v73));
  objc_msgSend(v38, "setReverse:", mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v73));
  if (*(_QWORD *)(a1 + 32))
  {
    v42 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v42 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(_QWORD *)(v42 + 8);
      v43 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v44 == 13 && *v43 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v43 + 5) == 0x6465686374697473)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mpsx.stitched";
        v78 = 13;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    v46 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    v47 = *(void **)(v46 + 16);
    if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(_QWORD *)(v46 + 8);
      v64 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v65 == 13 && *v64 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v64 + 5) == 0x6465686374697473)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mpsx.stitched";
        v78 = 13;
        v80[0] = v76;
        v80[2] = "' failed due to the operation not being registered";
        v81 = 770;
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    else if (v47 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_57;
    }
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
LABEL_57:
    GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v49 = (void *)*((_QWORD *)a2 + 9);
    if (!v49)
    {
      v50 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
      v51 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v50;

      v52 = (void *)*((_QWORD *)a2 + 11);
      v49 = (void *)*((_QWORD *)a2 + 9);
      if (v52)
      {
        objc_msgSend(v52, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
        v53 = objc_claimAutoreleasedReturnValue();
        v54 = (void *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = v53;

        v49 = (void *)*((_QWORD *)a2 + 9);
      }
    }
    if (*((_QWORD *)a2 + 10))
    {
      objc_msgSend(v49, "setLabel:");
      v49 = (void *)*((_QWORD *)a2 + 9);
    }
    v55 = v49;
    v56 = *((_QWORD *)a2 + 1);
    v57 = *(_QWORD *)(a1 + 32);
    v58 = *(void **)(v57 + 120);
    if (!v58)
    {
      if (!*(_QWORD *)(v57 + 96) && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      v59 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6EC8]), "initWithKernelDAG:finalOp:", v57 + 80, *(_QWORD *)(*(_QWORD *)(v57 + 96) + 32));
      v61 = *(void **)(v57 + 120);
      v60 = (uint64_t *)(v57 + 120);
      *v60 = v59;

      v58 = (void *)*v60;
    }
    v62 = v58;
    objc_msgSend(v38, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v55, v56, v48, 0, v37, v62);

  }
  else
  {
    if (!v36 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v63 = *((_QWORD *)a2 + 1);
    v82[0] = v36;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v82, 1);
    v55 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v38, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v48, v63, v55, v37);
  }

}

void sub_180E3D8B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  unint64_t Input;
  uint64_t result;
  _QWORD *AttrData;
  uint64_t v9;
  const char *v12;
  __int16 v13;
  uint64_t v14[4];
  __int16 v15;
  _QWORD v16[5];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(_QWORD *)(v2 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v9 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x6D5F65766974616CLL
      && *(_QWORD *)((char *)AttrData + 14) == 0x6D756D6978616D5FLL)
    {
      v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.cumulative_maximum";
      v14[3] = 22;
      v12 = "' failed due to the operation not being registered";
      v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id)
    goto LABEL_14;
  v16[0] = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  result = MPSKernelDAG::unaryCoreOp();
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 24);
  return result;
}

void GPU::CumulativeMaximumOpHandler::~CumulativeMaximumOpHandler(GPU::CumulativeMaximumOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

unint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  uint64_t v5;
  void *v6;
  uint64_t Input;
  void *Filter;
  void *v9;
  int8x8_t *v10;
  mlir::Block *ParentRegion;
  int8x8_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int8x8_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  uint64_t ***v30;
  uint64_t **v31;
  uint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  uint64_t *v35;
  void *v36;
  void *v37;
  id v38;
  uint64_t Axis;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  void *v52;
  uint64_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t *v60;
  void *v61;
  id v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  _QWORD *AttrData;
  uint64_t v68;
  BOOL v69;
  id v71;
  void *v72;
  uint64_t v73;
  uint64_t v74[4];
  __int16 v75;
  uint64_t v76[2];
  const char *v77;
  uint64_t v78;
  __int16 v79;
  _QWORD v80[4];
  __int16 v81;
  _QWORD v82[3];

  v82[1] = *MEMORY[0x1E0C80C00];
  v71 = a3;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v80[0] = *(_QWORD *)(v5 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
    if (v68 == 22)
    {
      v69 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x6D5F65766974616CLL;
      if (v69 && *(_QWORD *)((char *)AttrData + 14) == 0x6D756D696E696D5FLL)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mps.cumulative_minimum";
        v78 = 22;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id)
    goto LABEL_94;
  v73 = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  objc_msgSend(v71, "objectAtIndexedSubscript:", 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = *(int8x8_t **)(a1 + 16);
  v80[0] = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)v80);
  v12 = v10[12];
  if (!*(_QWORD *)&v12)
    goto LABEL_44;
  v13 = *((_QWORD *)ParentRegion + 2);
  v14 = 0x9DDFEA08EB382D69 * (((8 * v13) + 8) ^ HIDWORD(v13));
  v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v13) ^ (v14 >> 47) ^ v14);
  v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
  v17 = (uint8x8_t)vcnt_s8(v12);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    v18 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
    if (v16 >= *(_QWORD *)&v12)
      v18 = v16 % *(_QWORD *)&v12;
  }
  else
  {
    v18 = v16 & (*(_QWORD *)&v12 - 1);
  }
  v19 = *(_QWORD **)(*(_QWORD *)&v10[11] + 8 * v18);
  if (!v19)
    goto LABEL_44;
  v20 = (_QWORD *)*v19;
  if (!v20)
    goto LABEL_44;
  if (v17.u32[0] < 2uLL)
  {
    v21 = *(_QWORD *)&v12 - 1;
    while (1)
    {
      v23 = v20[1];
      if (v23 == v16)
      {
        if (v20[2] == v13)
          goto LABEL_24;
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_44;
      }
      v20 = (_QWORD *)*v20;
      if (!v20)
        goto LABEL_44;
    }
  }
  while (1)
  {
    v22 = v20[1];
    if (v22 == v16)
      break;
    if (v22 >= *(_QWORD *)&v12)
      v22 %= *(_QWORD *)&v12;
    if (v22 != v18)
      goto LABEL_44;
LABEL_13:
    v20 = (_QWORD *)*v20;
    if (!v20)
      goto LABEL_44;
  }
  if (v20[2] != v13)
    goto LABEL_13;
LABEL_24:
  v24 = (int8x8_t)v20[4];
  if (!*(_QWORD *)&v24)
    goto LABEL_44;
  v25 = 0x9DDFEA08EB382D69 * (((8 * LODWORD(v80[0])) + 8) ^ HIDWORD(v80[0]));
  v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v80[0]) ^ (v25 >> 47) ^ v25);
  v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  v28 = (uint8x8_t)vcnt_s8(v24);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(_QWORD *)&v24)
      v29 = v27 % *(_QWORD *)&v24;
  }
  else
  {
    v29 = v27 & (*(_QWORD *)&v24 - 1);
  }
  v30 = *(uint64_t ****)(v20[3] + 8 * v29);
  if (!v30 || (v31 = *v30) == 0)
  {
LABEL_44:
    v33 = 0;
    goto LABEL_45;
  }
  if (v28.u32[0] < 2uLL)
  {
    v32 = *(_QWORD *)&v24 - 1;
    while (1)
    {
      v35 = v31[1];
      if (v35 == (uint64_t *)v27)
      {
        if (v31[2] == (uint64_t *)v80[0])
          goto LABEL_76;
      }
      else if (((unint64_t)v35 & v32) != v29)
      {
        goto LABEL_44;
      }
      v33 = 0;
      v31 = (uint64_t **)*v31;
      if (!v31)
        goto LABEL_45;
    }
  }
  while (1)
  {
    v34 = (unint64_t)v31[1];
    if (v34 == v27)
      break;
    if (v34 >= *(_QWORD *)&v24)
      v34 %= *(_QWORD *)&v24;
    if (v34 != v29)
      goto LABEL_44;
LABEL_34:
    v33 = 0;
    v31 = (uint64_t **)*v31;
    if (!v31)
      goto LABEL_45;
  }
  if (v31[2] != (uint64_t *)v80[0])
    goto LABEL_34;
LABEL_76:
  v33 = v31[3];
LABEL_45:
  objc_msgSend(v33, "mpsndarray", v71);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "mpsndarray");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = *(id *)(a1 + 8);
  Axis = RuntimeUtils::getAxis(*(_QWORD *)(a1 + 16), (uint64_t)a2, Filter, objc_msgSend(v36, "numberOfDimensions"));
  v40 = objc_msgSend(v36, "numberOfDimensions");
  if (Axis >= 0)
    v41 = v40;
  else
    v41 = 0;
  objc_msgSend(v38, "setAxis:", v41 + ~Axis);
  objc_msgSend(v38, "setExclusive:", mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v73));
  objc_msgSend(v38, "setReverse:", mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v73));
  if (*(_QWORD *)(a1 + 32))
  {
    v42 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v42 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(_QWORD *)(v42 + 8);
      v43 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v44 == 13 && *v43 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v43 + 5) == 0x6465686374697473)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mpsx.stitched";
        v78 = 13;
        v74[0] = (uint64_t)"' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, v74, (uint64_t)v80);
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    v46 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    v47 = *(void **)(v46 + 16);
    if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v80[0] = *(_QWORD *)(v46 + 8);
      v64 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v80);
      if (v65 == 13 && *v64 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v64 + 5) == 0x6465686374697473)
      {
        v79 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v77 = "mpsx.stitched";
        v78 = 13;
        v80[0] = v76;
        v80[2] = "' failed due to the operation not being registered";
        v81 = 770;
        llvm::report_fatal_error((llvm::Twine *)v80, 1);
      }
    }
    else if (v47 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
      goto LABEL_57;
    }
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
LABEL_57:
    GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v49 = (void *)*((_QWORD *)a2 + 9);
    if (!v49)
    {
      v50 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6DE8]), "initWithCommandBuffer:withDispatchType:", *((_QWORD *)a2 + 1), 0);
      v51 = (void *)*((_QWORD *)a2 + 9);
      *((_QWORD *)a2 + 9) = v50;

      v52 = (void *)*((_QWORD *)a2 + 11);
      v49 = (void *)*((_QWORD *)a2 + 9);
      if (v52)
      {
        objc_msgSend(v52, "wrapComputeEncoder:", *((_QWORD *)a2 + 9));
        v53 = objc_claimAutoreleasedReturnValue();
        v54 = (void *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = v53;

        v49 = (void *)*((_QWORD *)a2 + 9);
      }
    }
    if (*((_QWORD *)a2 + 10))
    {
      objc_msgSend(v49, "setLabel:");
      v49 = (void *)*((_QWORD *)a2 + 9);
    }
    v55 = v49;
    v56 = *((_QWORD *)a2 + 1);
    v57 = *(_QWORD *)(a1 + 32);
    v58 = *(void **)(v57 + 120);
    if (!v58)
    {
      if (!*(_QWORD *)(v57 + 96) && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      v59 = objc_msgSend(objc_alloc(MEMORY[0x1E0CC6EC8]), "initWithKernelDAG:finalOp:", v57 + 80, *(_QWORD *)(*(_QWORD *)(v57 + 96) + 32));
      v61 = *(void **)(v57 + 120);
      v60 = (uint64_t *)(v57 + 120);
      *v60 = v59;

      v58 = (void *)*v60;
    }
    v62 = v58;
    objc_msgSend(v38, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v55, v56, v48, 0, v37, v62);

  }
  else
  {
    if (!v36 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    v63 = *((_QWORD *)a2 + 1);
    v82[0] = v36;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v82, 1);
    v55 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v38, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v48, v63, v55, v37);
  }

}

void sub_180E3E324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  unint64_t Input;
  uint64_t result;
  _QWORD *AttrData;
  uint64_t v9;
  const char *v12;
  __int16 v13;
  uint64_t v14[4];
  __int16 v15;
  _QWORD v16[5];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v16[0] = *(_QWORD *)(v2 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v16);
    if (v9 == 22
      && *AttrData == 0x756D75632E73706DLL
      && AttrData[1] == 0x6D5F65766974616CLL
      && *(_QWORD *)((char *)AttrData + 14) == 0x6D756D696E696D5FLL)
    {
      v15 = 1283;
      v14[0] = (uint64_t)"classof on '";
      v14[2] = (uint64_t)"mps.cumulative_minimum";
      v14[3] = 22;
      v12 = "' failed due to the operation not being registered";
      v13 = 259;
      llvm::operator+(v14, (uint64_t *)&v12, (uint64_t)v16);
      llvm::report_fatal_error((llvm::Twine *)v16, 1);
    }
LABEL_14:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id)
    goto LABEL_14;
  v16[0] = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v16);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  result = MPSKernelDAG::unaryCoreOp();
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 24);
  return result;
}

void GPU::CumulativeMinimumOpHandler::~CumulativeMinimumOpHandler(GPU::CumulativeMinimumOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

unint64_t GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeSumOp,(MPSNDArrayScanOperation)0>::~BaseCumulativeOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);
  JUMPOUT(0x186DA1680);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeProductOp,(MPSNDArrayScanOperation)1>::~BaseCumulativeOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);
  JUMPOUT(0x186DA1680);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMaximumOp,(MPSNDArrayScanOperation)2>::~BaseCumulativeOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);
  JUMPOUT(0x186DA1680);
}

void GPU::BaseCumulativeOpHandler<mlir::mps::CumulativeMinimumOp,(MPSNDArrayScanOperation)3>::~BaseCumulativeOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);
  JUMPOUT(0x186DA1680);
}

GPU::TensorToMemrefOpHandler *GPU::TensorToMemrefOpHandler::TensorToMemrefOpHandler(GPU::TensorToMemrefOpHandler *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  id v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  unint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t AttrData;
  uint64_t v19;
  mlir::Operation *v23;
  const char *v24;
  __int16 v25;
  uint64_t v26[4];
  __int16 v27;
  _QWORD v28[5];

  *(_QWORD *)GPU::BaseOpHandler::BaseOpHandler(this, a2, a3, a4) = &off_1E0E1E8E0;
  v6 = objc_alloc(MEMORY[0x1E0CC7030]);
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = objc_msgSend(v6, "initWithDevice:", v7);
  v9 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = v8;

  v10 = *((_QWORD *)a3 + 6);
  v11 = *(void **)(v10 + 16);
  if (v11 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v28[0] = *(_QWORD *)(v10 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v28);
    if (v19 == 26
      && *(_QWORD *)AttrData == 0x6E656D6563616C70
      && *(_QWORD *)(AttrData + 8) == 0x726F736E65742E74
      && *(_QWORD *)(AttrData + 16) == 0x726D656D5F6F745FLL
      && *(_WORD *)(AttrData + 24) == 26213)
    {
      v27 = 1283;
      v26[0] = (uint64_t)"classof on '";
      v26[2] = (uint64_t)"placement.tensor_to_memref";
      v26[3] = 26;
      v24 = "' failed due to the operation not being registered";
      v25 = 259;
      llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
      llvm::report_fatal_error((llvm::Twine *)v28, 1);
    }
    goto LABEL_23;
  }
  if (v11 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
  {
LABEL_23:
    v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v15 = 578;
    goto LABEL_8;
  }
  v23 = a3;
  v12 = *(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v23) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!*(_QWORD *)v12)
  {
    v14 = "abstractType && \"Malformed type storage object.\"";
    v15 = 160;
    v16 = "TypeSupport.h";
    v17 = "getAbstractType";
    goto LABEL_9;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v12 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v15 = 566;
LABEL_8:
    v16 = "Casting.h";
    v17 = "cast";
LABEL_9:
    __assert_rtn(v17, v16, v15, v14);
  }
  *((_QWORD *)this + 15) = getMemRefRowBytes(v12);
  *((_QWORD *)this + 16) = 0;
  return this;
}

void sub_180E3E828(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E3E840(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E3E854(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

BOOL GPU::TensorToMemrefOpHandler::inputRequiresCopy(GPU::TensorToMemrefOpHandler *this, MPSGraphTensorData *a2)
{
  MPSGraphTensorData *v3;
  char *v4;
  BOOL v5;
  char *v6;
  int32x4_t *v7;
  char *v8;
  char *v9;
  char *v10;
  char v11;
  _BOOL8 v12;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;

  v3 = a2;
  -[MPSGraphTensorData mpsndarray](v3, "mpsndarray");
  v4 = (char *)objc_claimAutoreleasedReturnValue();
  if ((vminvq_u8((uint8x16_t)vceqq_s8(*(int8x16_t *)&v4[*MEMORY[0x1E0CC7268]], (int8x16_t)xmmword_181287B00)) & 0x80) != 0)
  {
    -[MPSGraphTensorData mpsndarray](v3, "mpsndarray");
    v6 = (char *)objc_claimAutoreleasedReturnValue();
    v7 = (int32x4_t *)&v6[*MEMORY[0x1E0CC7260]];
    v16 = v7[1];
    v17 = v7[3];
    v14 = *v7;
    v15 = v7[2];
    -[MPSGraphTensorData mpsndarray](v3, "mpsndarray");
    v8 = (char *)objc_claimAutoreleasedReturnValue();
    if ((vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_s32(v14, *(int32x4_t *)&v8[*MEMORY[0x1E0CC7290]]), (int8x16_t)vceqq_s32(v15, *(int32x4_t *)&v8[*MEMORY[0x1E0CC7290] + 32])), vandq_s8((int8x16_t)vceqq_s32(v16, *(int32x4_t *)&v8[*MEMORY[0x1E0CC7290] + 16]), (int8x16_t)vceqq_s32(v17, *(int32x4_t *)&v8[*MEMORY[0x1E0CC7290] + 48])))) & 0x80000000) != 0)
    {
      -[MPSGraphTensorData mpsndarray](v3, "mpsndarray");
      v9 = (char *)objc_claimAutoreleasedReturnValue();
      v5 = (vminvq_u32((uint32x4_t)vceqzq_s32((int32x4_t)vorrq_s8(vorrq_s8(*(int8x16_t *)&v9[*MEMORY[0x1E0CC7298]], *(int8x16_t *)&v9[*MEMORY[0x1E0CC7298] + 32]), vorrq_s8(*(int8x16_t *)&v9[*MEMORY[0x1E0CC7298] + 16], *(int8x16_t *)&v9[*MEMORY[0x1E0CC7298] + 48])))) & 0x80000000) == 0;

    }
    else
    {
      v5 = 1;
    }

  }
  else
  {
    v5 = 1;
  }

  -[MPSGraphTensorData mpsndarray](v3, "mpsndarray");
  v10 = (char *)objc_claimAutoreleasedReturnValue();
  v11 = *(_QWORD *)&v10[*MEMORY[0x1E0CC7288]] != *((_QWORD *)this + 15) || v5;
  v12 = (v11 & 1) != 0 || *((_QWORD *)this + 16) == 0x4000;

  return v12;
}

void sub_180E3EA1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_180E3EA48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t GPU::TensorToMemrefOpHandler::setAlignBytes(uint64_t this, uint64_t a2)
{
  uint64_t v3;

  v3 = this;
  if ((a2 & 0xFFFFFFFFFFFFBFFFLL) != 0 && (this = MTLReportFailureTypeEnabled(), (_DWORD)this))
  {
    this = MTLReportFailure();
    *(_QWORD *)(v3 + 128) = a2;
  }
  else
  {
    *(_QWORD *)(v3 + 128) = a2;
  }
  return this;
}

void GPU::TensorToMemrefOpHandler::encodeOp(GPU::TensorToMemrefOpHandler *this, GPU::EncodeDescriptor *a2)
{
  uint64_t v2;
  void *v3;
  _QWORD *Input;
  _QWORD *Result;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  MPSGraphTensorData *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  BOOL v15;
  char v16;
  unsigned int Interleave;
  unint64_t ANENextSupportedInterleaveValue;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  void *v24;
  uint64_t v25;
  void *v26;
  GPU *v27;
  MPSNDArrayDescriptor *v28;
  size_t v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  char isKindOfClass;
  void *v35;
  void *v36;
  _QWORD *v37;
  int v38;
  uint64_t v39;
  id v40;
  void *v41;
  uint64_t **v42;
  void *InterfaceFor;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  const void *ArgAttrsAttr;
  uint64_t v49;
  void *v50;
  void *v51;
  uint64_t v52;
  void *v53;
  id v54;
  MPSGraphTensorData *v55;
  void *v56;
  uint64_t v57;
  uint64_t AttrData;
  uint64_t v59;
  BOOL v60;
  BOOL v61;
  id v63;
  mlir::Operation *v64;
  uint64_t v65[4];
  __int16 v66;
  void *memptr[4];
  __int16 v68;
  void *v69;
  void *__s2;
  unsigned int v71;
  _QWORD v72[7];

  v72[5] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __s2 = *(void **)(v2 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__s2);
    if (v59 == 26)
    {
      v60 = *(_QWORD *)AttrData == 0x6E656D6563616C70 && *(_QWORD *)(AttrData + 8) == 0x726F736E65742E74;
      v61 = v60 && *(_QWORD *)(AttrData + 16) == 0x726D656D5F6F745FLL;
      if (v61 && *(_WORD *)(AttrData + 24) == 26213)
      {
        v68 = 1283;
        memptr[0] = "classof on '";
        memptr[2] = "placement.tensor_to_memref";
        memptr[3] = (void *)26;
        v65[0] = (uint64_t)"' failed due to the operation not being registered";
        v66 = 259;
        llvm::operator+((uint64_t *)memptr, v65, (uint64_t)&__s2);
        llvm::report_fatal_error((llvm::Twine *)&__s2, 1);
      }
    }
LABEL_73:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
    goto LABEL_73;
  v64 = (mlir::Operation *)*((_QWORD *)this + 3);
  Input = (_QWORD *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v64);
  Result = (_QWORD *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v64);
  v8 = *((_QWORD *)this + 2);
  __s2 = Input;
  memptr[0] = *((void **)mlir::Value::getParentRegion((mlir::Value *)&__s2) + 2);
  v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v8 + 88), (uint64_t *)memptr);
  if (v9
    && (v65[0] = (uint64_t)__s2,
        (v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, v65)) != 0))
  {
    v11 = (MPSGraphTensorData *)(id)v10[3];
  }
  else
  {
    v11 = 0;
  }
  v12 = *((_QWORD *)this + 2);
  __s2 = Result;
  memptr[0] = *((void **)mlir::Value::getParentRegion((mlir::Value *)&__s2) + 2);
  v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v12 + 88), (uint64_t *)memptr);
  if (v13
    && (v65[0] = (uint64_t)__s2,
        (v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v13 + 3, v65)) != 0))
  {
    v63 = (id)v14[3];
  }
  else
  {
    v63 = 0;
  }
  v15 = GPU::TensorToMemrefOpHandler::inputRequiresCopy(this, v11);
  if (v63)
    v16 = 1;
  else
    v16 = v15;
  if ((v16 & 1) == 0)
  {
    -[MPSGraphTensorData mpsndarray](v11, "mpsndarray");
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();

    if ((isKindOfClass & 1) != 0)
    {
      -[MPSGraphTensorData mpsndarray](v11, "mpsndarray");
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      v36 = v35;
      v37 = (_QWORD *)*Result;
      if (*Result)
      {
        v38 = 0;
        do
        {
          ++v38;
          v37 = (_QWORD *)*v37;
        }
        while (v37);
        v39 = v38;
      }
      else
      {
        v39 = 0;
      }
      objc_msgSend(v35, "setReadCount:", objc_msgSend(v35, "readCount", v63) + v39);

    }
    BaseRuntime::setTensorDataToDataMap(*((_QWORD *)this + 2), Result, v11);
    goto LABEL_50;
  }
  if (mlir::placement::MemrefToTensor::getInterleaveAttr(&v64))
  {
    Interleave = mlir::placement::MemrefToTensor::getInterleave(&v64);
    ANENextSupportedInterleaveValue = mlir::getANENextSupportedInterleaveValue(Interleave);
    if (ANENextSupportedInterleaveValue != mlir::placement::MemrefToTensor::getInterleave(&v64))
    {
      if (MTLReportFailureTypeEnabled())
        MTLReportFailure();
    }
  }
  v19 = *(_QWORD *)(*((_QWORD *)this + 2) + 424);
  if (v19)
  {
    v20 = *((_QWORD *)this + 3);
    v21 = *(unsigned int *)(v19 + 136);
    if (v21 >= *(_DWORD *)(v19 + 140))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v19 + 128, (void *)(v19 + 144), v21 + 1, 8);
      *(_QWORD *)(*(_QWORD *)(v19 + 128) + 8 * *(unsigned int *)(v19 + 136)) = v20;
      v22 = *(_DWORD *)(v19 + 136);
      if (v22 < *(_DWORD *)(v19 + 140))
        goto LABEL_22;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(v19 + 128) + 8 * v21) = v20;
      v22 = *(_DWORD *)(v19 + 136);
      if (v22 < *(_DWORD *)(v19 + 140))
      {
LABEL_22:
        *(_DWORD *)(v19 + 136) = v22 + 1;
        goto LABEL_23;
      }
    }
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
LABEL_23:
  -[MPSGraphTensorData mpsndarray](v11, "mpsndarray", v63);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v23 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (*((_BYTE *)v23 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v23, "setReadCount:", objc_msgSend(v23, "readCount") + 1);
  mlir::placement::TensorToMemref::getOutputShapeBeforeInterleave(&v64, (uint64_t)&__s2);
  v24 = (void *)MEMORY[0x1E0CC6FE0];
  v25 = objc_msgSend(v23, "dataType");
  getMPSShapeFromMLIR((uint64_t *)__s2, v71);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v24, "descriptorWithDataType:shape:", v25, v26);
  v27 = (GPU *)objc_claimAutoreleasedReturnValue();

  *(_QWORD *)((char *)v27 + (int)*MEMORY[0x1E0CC72C8]) = *((_QWORD *)this + 15);
  if (*((_QWORD *)this + 16) == 0x4000)
  {
    memptr[0] = 0;
    v29 = GPU::calculateNDArrayAllocationSize(v27, v28);
    if ((malloc_type_posix_memalign(memptr, *((_QWORD *)this + 16), v29, 0x91C3134BuLL) || !memptr[0])
      && MTLReportFailureTypeEnabled())
    {
      MTLReportFailure();
    }
    objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v31 = (void *)objc_msgSend(v30, "newBufferWithBytesNoCopy:length:options:deallocator:", memptr[0], v29, 0, &__block_literal_global_1);

    v32 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CC6F50]), "initWithBuffer:descriptor:", v31, v27);
  }
  else
  {
    v40 = objc_alloc(MEMORY[0x1E0CC6F50]);
    objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    v32 = (void *)objc_msgSend(v40, "initWithDevice:descriptor:", v41, v27);

  }
  v42 = (uint64_t **)(Input[1] & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v42))
  {
    v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v45 = 566;
    v46 = "Casting.h";
    v47 = "cast";
LABEL_55:
    __assert_rtn(v47, v46, v45, v44);
  }
  if (v42)
  {
    InterfaceFor = (void *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v42);
    if (!InterfaceFor)
    {
      v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v45 = 98;
      v46 = "InterfaceSupport.h";
      v47 = "Interface";
      goto LABEL_55;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  memptr[0] = v42;
  memptr[1] = InterfaceFor;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)memptr);
  if (v49 == v71 && !memcmp(ArgAttrsAttr, __s2, 8 * v71))
  {
    v56 = (void *)*((_QWORD *)this + 1);
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    v57 = *((_QWORD *)a2 + 1);
    v69 = v23;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v69, 1);
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v56, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v51, v57, v53, v32);
  }
  else
  {
    v50 = (void *)*((_QWORD *)this + 1);
    GPU::EncodeDescriptor::getcomputeEncoder(a2);
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    v52 = *((_QWORD *)a2 + 1);
    getMPSShapeFromMLIR((uint64_t *)__s2, v71);
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    v54 = (id)objc_msgSend(v50, "reshapeWithCommandEncoder:commandBuffer:sourceArray:shape:destinationArray:", v51, v52, v23, v53, v32);
  }

  v55 = -[MPSGraphTensorData initWithMPSNDArray:device:]([MPSGraphTensorData alloc], "initWithMPSNDArray:device:", v32, *(_QWORD *)(*((_QWORD *)this + 2) + 48));
  BaseRuntime::setTensorDataToDataMap(*((_QWORD *)this + 2), Result, v55);

  if (__s2 != v72)
    free(__s2);

LABEL_50:
}

void sub_180E3F210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void ___ZN3GPU23TensorToMemrefOpHandler8encodeOpEPNS_16EncodeDescriptorE_block_invoke(int a1, void *a2)
{
  free(a2);
}

GPU::MemrefToTensorOpHandler *GPU::MemrefToTensorOpHandler::MemrefToTensorOpHandler(GPU::MemrefToTensorOpHandler *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  id v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  unint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t AttrData;
  uint64_t v19;
  mlir::Operation *v23;
  const char *v24;
  __int16 v25;
  uint64_t v26[4];
  __int16 v27;
  _QWORD v28[5];

  *(_QWORD *)GPU::BaseOpHandler::BaseOpHandler(this, a2, a3, a4) = &off_1E0E1E070;
  v6 = objc_alloc(MEMORY[0x1E0CC7030]);
  objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 48), "metalDevice");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = objc_msgSend(v6, "initWithDevice:", v7);
  v9 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = v8;

  v10 = *((_QWORD *)a3 + 6);
  v11 = *(void **)(v10 + 16);
  if (v11 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v28[0] = *(_QWORD *)(v10 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v28);
    if (v19 == 26
      && *(_QWORD *)AttrData == 0x6E656D6563616C70
      && *(_QWORD *)(AttrData + 8) == 0x6665726D656D2E74
      && *(_QWORD *)(AttrData + 16) == 0x736E65745F6F745FLL
      && *(_WORD *)(AttrData + 24) == 29295)
    {
      v27 = 1283;
      v26[0] = (uint64_t)"classof on '";
      v26[2] = (uint64_t)"placement.memref_to_tensor";
      v26[3] = 26;
      v24 = "' failed due to the operation not being registered";
      v25 = 259;
      llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
      llvm::report_fatal_error((llvm::Twine *)v28, 1);
    }
    goto LABEL_23;
  }
  if (v11 != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
  {
LABEL_23:
    v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v15 = 578;
    goto LABEL_8;
  }
  v23 = a3;
  v12 = *(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v23) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!*(_QWORD *)v12)
  {
    v14 = "abstractType && \"Malformed type storage object.\"";
    v15 = 160;
    v16 = "TypeSupport.h";
    v17 = "getAbstractType";
    goto LABEL_9;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v12 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v15 = 566;
LABEL_8:
    v16 = "Casting.h";
    v17 = "cast";
LABEL_9:
    __assert_rtn(v17, v16, v15, v14);
  }
  *((_QWORD *)this + 15) = getMemRefRowBytes(v12);
  return this;
}

void sub_180E3F558(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E3F570(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E3F584(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void GPU::MemrefToTensorOpHandler::encodeOp(GPU::MemrefToTensorOpHandler *this, void **a2)
{
  uint64_t v2;
  void *v3;
  void *Input;
  _QWORD *Result;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  id v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  _BOOL4 v16;
  void *v17;
  BOOL v18;
  unsigned int Interleave;
  unint64_t ANENextSupportedInterleaveValue;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  void *v25;
  uint64_t **v26;
  uint64_t InterfaceFor;
  const char *v28;
  int v29;
  const char *v30;
  const char *v31;
  const void *ArgAttrsAttr;
  uint64_t v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  id v40;
  _QWORD *v41;
  uint64_t AttrData;
  uint64_t v43;
  BOOL v44;
  BOOL v45;
  mlir::Operation *v47;
  uint64_t v48[4];
  __int16 v49;
  uint64_t v50[4];
  __int16 v51;
  void *__s2;
  unsigned int v53;
  _QWORD v54[6];

  v54[5] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __s2 = *(void **)(v2 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&__s2);
    if (v43 == 26)
    {
      v44 = *(_QWORD *)AttrData == 0x6E656D6563616C70 && *(_QWORD *)(AttrData + 8) == 0x6665726D656D2E74;
      v45 = v44 && *(_QWORD *)(AttrData + 16) == 0x736E65745F6F745FLL;
      if (v45 && *(_WORD *)(AttrData + 24) == 29295)
      {
        v51 = 1283;
        v50[0] = (uint64_t)"classof on '";
        v50[2] = (uint64_t)"placement.memref_to_tensor";
        v50[3] = 26;
        v48[0] = (uint64_t)"' failed due to the operation not being registered";
        v49 = 259;
        llvm::operator+(v50, v48, (uint64_t)&__s2);
        llvm::report_fatal_error((llvm::Twine *)&__s2, 1);
      }
    }
LABEL_61:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::placement::MemrefToTensor,void>::id)
    goto LABEL_61;
  v47 = (mlir::Operation *)*((_QWORD *)this + 3);
  Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  Result = (_QWORD *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  v8 = *((_QWORD *)this + 2);
  __s2 = Input;
  v50[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&__s2) + 2);
  v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v8 + 88), v50);
  if (v9
    && (v48[0] = (uint64_t)__s2,
        (v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, v48)) != 0))
  {
    v11 = (id)v10[3];
  }
  else
  {
    v11 = 0;
  }
  v12 = *((_QWORD *)this + 2);
  __s2 = Result;
  v50[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&__s2) + 2);
  v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v12 + 88), v50);
  if (v13)
  {
    v48[0] = (uint64_t)__s2;
    v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v13 + 3, v48);
    if (v13)
      v13 = (id)v13[3];
  }
  v14 = v13;
  if (objc_msgSend(v14, "iosurface"))
  {
    objc_msgSend(v14, "mpsndarray");
    v15 = (char *)objc_claimAutoreleasedReturnValue();
    v16 = *(_QWORD *)&v15[*MEMORY[0x1E0CC7288]] == *((_QWORD *)this + 15);

    if (v16)
    {
      objc_msgSend(v11, "mpsndarray");
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      v18 = v17 == 0;

      if (v18)
        goto LABEL_38;
    }
  }
  else
  {

  }
  if (mlir::placement::MemrefToTensor::getInterleaveAttr(&v47))
  {
    Interleave = mlir::placement::MemrefToTensor::getInterleave(&v47);
    ANENextSupportedInterleaveValue = mlir::getANENextSupportedInterleaveValue(Interleave);
    if (ANENextSupportedInterleaveValue != mlir::placement::MemrefToTensor::getInterleave(&v47))
    {
      if (MTLReportFailureTypeEnabled())
        MTLReportFailure();
    }
  }
  v21 = *(_QWORD *)(*((_QWORD *)this + 2) + 424);
  if (v21)
  {
    v22 = *((_QWORD *)this + 3);
    v23 = *(unsigned int *)(v21 + 136);
    if (v23 >= *(_DWORD *)(v21 + 140))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v21 + 128, (void *)(v21 + 144), v23 + 1, 8);
      *(_QWORD *)(*(_QWORD *)(v21 + 128) + 8 * *(unsigned int *)(v21 + 136)) = v22;
      v24 = *(_DWORD *)(v21 + 136);
      if (v24 < *(_DWORD *)(v21 + 140))
        goto LABEL_22;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(v21 + 128) + 8 * v23) = v22;
      v24 = *(_DWORD *)(v21 + 136);
      if (v24 < *(_DWORD *)(v21 + 140))
      {
LABEL_22:
        *(_DWORD *)(v21 + 136) = v24 + 1;
        goto LABEL_23;
      }
    }
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  }
LABEL_23:
  objc_msgSend(v11, "mpsndarray");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v25 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  mlir::placement::MemrefToTensor::getInputShapeAfterInterleave(&v47, &__s2);
  v26 = (uint64_t **)(Result[1] & 0xFFFFFFFFFFFFFFF8);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26))
  {
    v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v29 = 566;
    v30 = "Casting.h";
    v31 = "cast";
LABEL_43:
    __assert_rtn(v31, v30, v29, v28);
  }
  if (v26)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v26);
    if (!InterfaceFor)
    {
      v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v29 = 98;
      v30 = "InterfaceSupport.h";
      v31 = "Interface";
      goto LABEL_43;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v50[0] = (uint64_t)v26;
  v50[1] = InterfaceFor;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
  if (v33 == v53 && !memcmp(ArgAttrsAttr, __s2, 8 * v53))
  {
    v41 = (_QWORD *)*((_QWORD *)this + 2);
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    GPURegionRuntime::copyNDArrayToTarget(v41, v34, a2[1], (id *)this + 1, v25, v14, Result, 0);
  }
  else
  {
    objc_msgSend(v14, "mpsndarray");
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v34 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    if (*((_BYTE *)v25 + (int)*MEMORY[0x1E0CC7278]))
      objc_msgSend(v25, "setReadCount:", objc_msgSend(v25, "readCount") + 1);
    v35 = (void *)*((_QWORD *)this + 1);
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    v37 = a2[1];
    getMPSShapeFromMLIR((uint64_t **)(Result[1] & 0xFFFFFFFFFFFFFFF8));
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    adaptForMPS(v38);
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    v40 = (id)objc_msgSend(v35, "reshapeWithCommandEncoder:commandBuffer:sourceArray:shape:destinationArray:", v36, v37, v25, v39, v34);

  }
  if (__s2 != v54)
    free(__s2);

LABEL_38:
}

void sub_180E3FB34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void GPU::TensorToMemrefOpHandler::~TensorToMemrefOpHandler(GPU::TensorToMemrefOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::MemrefToTensorOpHandler::~MemrefToTensorOpHandler(GPU::MemrefToTensorOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void sub_180E3FC90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E3FFE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;

  _Unwind_Resume(a1);
}

void sub_180E40024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;
  void *v26;

  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:

      if ((SHIBYTE(a13) & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);

  if ((SHIBYTE(a13) & 0x80000000) == 0)
  {
LABEL_4:

    _Unwind_Resume(a1);
  }
LABEL_7:
  JUMPOUT(0x180E40088);
}

void sub_180E40078(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;

  if (a16 < 0)
    JUMPOUT(0x180E40088);
  JUMPOUT(0x180E40044);
}

void sub_180E405B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  void *v40;

  _Unwind_Resume(a1);
}

void sub_180E40B5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  void *v40;

  _Unwind_Resume(a1);
}

void sub_180E41104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  void *v40;

  _Unwind_Resume(a1);
}

void sub_180E412CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_180E4143C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_180E415B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_180E41728(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_180E418A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_180E41A14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_180E41B90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_180E41D00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CumulativeSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CumulativeSumOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x756D75632E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x735F65766974616CLL
      && *(_WORD *)(AttrData + 16) == 28021)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.cumulative_sum";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id)
  {
    return 0;
  }
  return result;
}

unint64_t GPU::ResizeOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

unint64_t GPU::ResizeGradientOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeOpHandler,mlir::mps::ResizeOp,MPSNDArrayResample,1ul>::encodeNDArrayOp(uint64_t a1, GPU::EncodeDescriptor *a2, void *a3)
{
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  int16x8_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  id v12;
  uint64_t v13;
  uint64_t Scale;
  double v15;
  mlir::Operation *v16;
  uint64_t v17;
  uint64_t Offset;
  double v19;
  id v20;
  void *v21;
  uint64_t v22;
  void *v23;
  mlir::mps *v24;
  uint64_t ResizeLayout;
  unsigned int v26;
  const char *v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;
  char *v31;
  unint64_t v32;
  uint64_t v33;
  char v34;
  _QWORD *v35;
  uint64_t DefiningOp;
  uint64_t v37;
  char *v38;
  int64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  _BYTE *v44;
  uint64_t *v45;
  int64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t *v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _OWORD *v54;
  char *v55;
  uint64_t v56;
  __int128 v57;
  mlir::GenericProgramPoint *v58;
  mlir::Operation *v59;
  uint64_t *v60;
  int64_t v61;
  _QWORD *v62;
  char *v63;
  int64_t v64;
  char *v65;
  char *v66;
  id v67;
  id v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  _BOOL4 IsSize;
  _BOOL4 InferredResultTypes;
  int v79;
  float v80;
  float v81;
  float v82;
  float v83;
  char *v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t NearestRoundingMode;
  uint64_t GateLayout;
  uint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v98;
  void *v99;
  void *v100;
  void *v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t AttrData;
  uint64_t v109;
  unsigned int v111;
  void *v112;
  void *v113;
  void *v114;
  id v115;
  id v116;
  char *v117;
  double v118;
  double __src;
  id v120;
  int16x8_t *v121;
  id v122;
  char *v124;
  char *v125;
  char *v126;
  _QWORD *v127;
  char *v128;
  char *v129;
  mlir::mps *v130;
  uint64_t v131;
  void *__p;
  char *v133;
  char *v134;
  __int16 v135;
  uint64_t *v136[2];
  const char *v137;
  uint64_t v138;
  __int16 v139;
  double v140;
  double v141;
  double v142;
  double v143;
  uint64_t v144;
  int v145;
  uint64_t v146;
  uint64_t v147;
  int v148;
  uint64_t v149;

  v149 = *MEMORY[0x1E0C80C00];
  v116 = a3;
  if (!*(_BYTE *)(a1 + 40))
    GPU::MultiaryKernelOpHandler<GPU::ResizeOpHandler,mlir::mps::ResizeOp,MPSNDArrayResample,1ul>::_createNDArrayMultiaryKernel(a1);
  objc_msgSend(v116, "objectAtIndexedSubscript:", 0);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "mpsndarray");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v5 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v122 = v5;
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v140 = *(double *)(v6 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v140);
    if (v109 == 10 && *(_QWORD *)AttrData == 0x697365722E73706DLL && *(_WORD *)(AttrData + 8) == 25978)
    {
      v139 = 1283;
      v136[0] = (uint64_t *)"classof on '";
      v137 = "mps.resize";
      v138 = 10;
      __p = "' failed due to the operation not being registered";
      v135 = 259;
      llvm::operator+((uint64_t *)v136, (uint64_t *)&__p, (uint64_t)&v140);
      llvm::report_fatal_error((llvm::Twine *)&v140, 1);
    }
LABEL_156:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id)
    goto LABEL_156;
  v130 = *(mlir::mps **)(a1 + 24);
  *(double *)&v8 = COERCE_DOUBLE(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v130));
  v9 = *(_QWORD *)(a1 + 16);
  v140 = *(double *)&v8;
  v136[0] = *((uint64_t **)mlir::Value::getParentRegion((mlir::Value *)&v140) + 2);
  v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v9 + 88), (uint64_t *)v136);
  if (v10
    && (__p = *(void **)&v140,
        (v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&__p)) != 0))
  {
    v12 = (id)v11[3];
  }
  else
  {
    v12 = 0;
  }
  objc_msgSend(v12, "mpsndarray");
  *(double *)&v121 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());

  if ((!v122 || *(double *)&v121 == 0.0) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v130))
  {
    v13 = *(_QWORD *)(a1 + 16);
    Scale = mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v130);
    GPURegionRuntime::waitAndReadFPTensorData(v13, (uint64_t)a2, Scale, (int16x8_t **)&v140);
    v15 = v141;
    __src = v140;
  }
  else
  {
    v15 = 0.0;
    __src = 0.0;
  }
  if (mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v130))
  {
    v17 = *(_QWORD *)(a1 + 16);
    Offset = mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v130);
    GPURegionRuntime::waitAndReadFPTensorData(v17, (uint64_t)a2, Offset, (int16x8_t **)&v140);
    v19 = v141;
    v118 = v140;
    if (*(_QWORD *)(a1 + 8))
      goto LABEL_20;
  }
  else
  {
    v19 = 0.0;
    v118 = 0.0;
    if (*(_QWORD *)(a1 + 8))
      goto LABEL_20;
  }
  v20 = objc_alloc(MEMORY[0x1E0CC7138]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = objc_msgSend(v20, "initWithDevice:", v21);
  v23 = *(void **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v22;

LABEL_20:
  v24 = v130;
  ResizeLayout = mlir::mps::getResizeLayout(v130, v16);
  v26 = ResizeLayout;
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    v136[0] = (uint64_t *)mlir::Attribute::getContext((mlir::mps *)((char *)v24 + 24));
    v136[1] = 0;
    v27 = (const char *)*((_QWORD *)v24 + 2);
    mlir::GenericProgramPoint::~GenericProgramPoint(v24);
    v137 = v27;
    v138 = v28;
    v140 = 0.0;
    v141 = 0.0;
    LODWORD(v142) = 0;
    v143 = 0.0;
    v144 = 0;
    v145 = 0;
    v146 = 0;
    v147 = 0;
    v148 = 0;
    __p = 0;
    v133 = 0;
    v134 = 0;
    if ((*((_BYTE *)v24 + 46) & 0x80) == 0)
    {
LABEL_64:
      v58 = mlir::OpBuilder::clone(v136, v24, (mlir::IRMapping *)&v140);
      if (mlir::mps::inferTypes(v58, v59))
        mlir::verify(v58, (mlir::Operation *)1);
      __assert_rtn("getLayoutHelper", "GPUResizeOps.mm", 81, "0 && \"failed to infer output types\"");
    }
    v29 = 0;
    v30 = 0;
    while (1)
    {
      if (v30 >= *((unsigned int *)v24 + 17))
        goto LABEL_64;
      v32 = *(_QWORD *)(*((_QWORD *)v24 + 9) + 32 * v30 + 24);
      v124 = (char *)v32;
      v127 = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v140, (unint64_t *)&v124, &v127) & 1) == 0)
      {
        v33 = (*(uint64_t (**)(uint64_t, GPU::EncodeDescriptor *, uint64_t **, unint64_t))(*(_QWORD *)a1 + 48))(a1, a2, v136, v30);
        v131 = v33;
        v124 = (char *)v32;
        v127 = 0;
        v34 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v140, (unint64_t *)&v124, &v127);
        v35 = v127;
        if ((v34 & 1) == 0)
        {
          v35 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)&v140, (uint64_t)&v124, (unint64_t *)&v124, v127);
          *v35 = v124;
          v35[1] = 0;
        }
        v35[1] = v33;
        if (v32 != v131)
        {
          if (mlir::Value::getDefiningOp((mlir::Value *)&v131))
            break;
        }
      }
LABEL_25:
      ++v30;
      if ((*((_BYTE *)v24 + 46) & 0x80) == 0)
        goto LABEL_64;
    }
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v131);
    v37 = DefiningOp;
    if (v29 < v134)
    {
      *(_QWORD *)v29 = DefiningOp;
      v31 = v29 + 8;
    }
    else
    {
      v38 = (char *)__p;
      v39 = v29 - (_BYTE *)__p;
      v40 = (v29 - (_BYTE *)__p) >> 3;
      v41 = v40 + 1;
      if ((unint64_t)(v40 + 1) >> 61)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      v42 = v134 - (_BYTE *)__p;
      if ((v134 - (_BYTE *)__p) >> 2 > v41)
        v41 = v42 >> 2;
      if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
        v43 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v43 = v41;
      if (v43)
      {
        if (v43 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v44 = operator new(8 * v43);
        v45 = (uint64_t *)&v44[8 * v40];
        *v45 = v37;
        v31 = (char *)(v45 + 1);
        v46 = v29 - v38;
        if (v29 != v38)
        {
LABEL_42:
          v47 = v46 - 8;
          if (v47 >= 0x168)
          {
            v51 = (v29 - 8 - v38) & 0xFFFFFFFFFFFFFFF8;
            if (&v44[v39 - 8 - v51] > &v44[v39 - 8])
            {
              v48 = v29;
            }
            else if (&v29[-v51 - 8] > v29 - 8)
            {
              v48 = v29;
            }
            else if ((unint64_t)(v29 - v44 - v39) >= 0x20)
            {
              v52 = (v47 >> 3) + 1;
              v53 = 8 * (v52 & 0x3FFFFFFFFFFFFFFCLL);
              v48 = &v29[-v53];
              v45 = (uint64_t *)((char *)v45 - v53);
              v54 = &v44[v39 - 16];
              v55 = v29 - 16;
              v56 = v52 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v57 = *(_OWORD *)v55;
                *(v54 - 1) = *((_OWORD *)v55 - 1);
                *v54 = v57;
                v54 -= 2;
                v55 -= 32;
                v56 -= 4;
              }
              while (v56);
              if (v52 == (v52 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_45:
                v29 = (char *)__p;
                __p = v45;
                v133 = v31;
                v134 = &v44[8 * v43];
                if (!v29)
                  goto LABEL_24;
                goto LABEL_49;
              }
            }
            else
            {
              v48 = v29;
            }
          }
          else
          {
            v48 = v29;
          }
          do
          {
            v49 = *((_QWORD *)v48 - 1);
            v48 -= 8;
            *--v45 = v49;
          }
          while (v48 != v38);
          goto LABEL_45;
        }
      }
      else
      {
        v44 = 0;
        v45 = (uint64_t *)(8 * v40);
        v50 = (uint64_t *)(8 * v40);
        *v50 = v37;
        v31 = (char *)(v50 + 1);
        v46 = v29 - v38;
        if (v29 != v38)
          goto LABEL_42;
      }
      __p = v45;
      v133 = v31;
      v134 = &v44[8 * v43];
      if (v29)
LABEL_49:
        operator delete(v29);
    }
LABEL_24:
    v133 = v31;
    v29 = v31;
    goto LABEL_25;
  }
  v115 = *(id *)(a1 + 8);
  v60 = (uint64_t *)v130;
  mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v130);
  -[int16x8_t descriptor](v121, "descriptor");
  v112 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v122, "descriptor");
  v113 = (void *)objc_claimAutoreleasedReturnValue();
  v127 = 0;
  v128 = 0;
  v129 = 0;
  v61 = *(_QWORD *)&v15 - *(_QWORD *)&__src;
  if (*(_QWORD *)&v15 != *(_QWORD *)&__src)
  {
    if (v61 < 0)
      std::vector<long>::__throw_length_error[abi:ne180100]();
    v62 = operator new(*(_QWORD *)&v15 - *(_QWORD *)&__src);
    v63 = (char *)v62 + 4 * (v61 >> 2);
    v127 = v62;
    v129 = v63;
    v117 = (char *)v62;
    memcpy(v62, *(const void **)&__src, v61);
    v128 = v63;
    v124 = 0;
    v125 = 0;
    v126 = 0;
    v64 = *(_QWORD *)&v19 - *(_QWORD *)&v118;
    if (*(_QWORD *)&v19 != *(_QWORD *)&v118)
      goto LABEL_69;
LABEL_72:
    v66 = 0;
    v65 = 0;
    goto LABEL_73;
  }
  v63 = 0;
  v117 = 0;
  v124 = 0;
  v125 = 0;
  v126 = 0;
  v64 = *(_QWORD *)&v19 - *(_QWORD *)&v118;
  if (*(_QWORD *)&v19 == *(_QWORD *)&v118)
    goto LABEL_72;
LABEL_69:
  if (v64 < 0)
    std::vector<long>::__throw_length_error[abi:ne180100]();
  v65 = (char *)operator new(v64);
  v66 = &v65[4 * (v64 >> 2)];
  v124 = v65;
  v126 = v66;
  memcpy(v65, *(const void **)&v118, v64);
  v125 = v66;
LABEL_73:
  v136[0] = v60;
  v67 = v115;
  v68 = v112;
  v120 = v113;
  v114 = v68;
  if (v26 <= 6 && ((1 << v26) & 0x51) != 0)
    goto LABEL_75;
  if ((v26 & 0xFFFFFFFB) != 1)
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
LABEL_75:
    objc_msgSend(v68, "sliceRangeForDimension:", 0);
    v70 = v69;
    objc_msgSend(v68, "sliceRangeForDimension:", 1);
    v72 = v71;
    objc_msgSend(v120, "sliceRangeForDimension:", 0);
    v74 = v73;
    objc_msgSend(v120, "sliceRangeForDimension:", 1);
    v76 = v75;
    v111 = 0;
    if (v117 != v63)
      goto LABEL_92;
    goto LABEL_76;
  }
  objc_msgSend(v68, "sliceRangeForDimension:", 1);
  v70 = v85;
  objc_msgSend(v68, "sliceRangeForDimension:", 2);
  v72 = v86;
  objc_msgSend(v120, "sliceRangeForDimension:", 1);
  v74 = v87;
  objc_msgSend(v120, "sliceRangeForDimension:", 2);
  v76 = v88;
  v111 = 1;
  if (v117 != v63)
    goto LABEL_92;
LABEL_76:
  if (v65 == v66)
  {
    IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)v136);
    InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)v136);
    v79 = !IsSize || InferredResultTypes;
    if (v79)
      v80 = 0.0;
    else
      v80 = (float)((float)((float)v76 / (float)v72) + -1.0) * 0.5;
    if (v79)
      v81 = 0.0;
    else
      v81 = (float)((float)((float)v74 / (float)v70) + -1.0) * 0.5;
    if (InferredResultTypes)
      v82 = (float)(v76 - 1) / (float)(v72 - 1);
    else
      v82 = (float)v76 / (float)v72;
    if (InferredResultTypes)
      v83 = (float)(v74 - 1) / (float)(v70 - 1);
    else
      v83 = (float)v74 / (float)v70;
    v84 = v117;
    goto LABEL_101;
  }
LABEL_92:
  if (v26 >= 7 || ((0x73u >> v26) & 1) == 0)
    llvm::llvm_unreachable_internal((llvm *)"unhandled TensorDataLayout enum.", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/Utils/MPSTypeUtils.h", (const char *)0x69);
  v89 = 8 * (int)v26;
  v90 = *(_QWORD *)((char *)&unk_181287C68 + v89);
  v91 = *(_QWORD *)((char *)&unk_181287CA0 + v89);
  v84 = v117;
  if (v117 != v63)
  {
    if (v90 >= (v63 - v117) >> 2 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v82 = *(float *)&v117[4 * v90];
    v83 = *(float *)&v117[4 * v91];
    if (v65 != v66)
      goto LABEL_97;
LABEL_100:
    v80 = 0.0;
    v81 = 0.0;
    goto LABEL_101;
  }
  v82 = 1.0;
  v83 = 1.0;
  if (v65 == v66)
    goto LABEL_100;
LABEL_97:
  if (v90 >= (v66 - v65) >> 2 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v80 = *(float *)&v65[4 * v90];
  v81 = *(float *)&v65[4 * v91];
LABEL_101:
  if ((mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)v136) & 0xFF00000000) != 0)
  {
    NearestRoundingMode = mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)v136);
    if (NearestRoundingMode >= 6)
      __assert_rtn("MPSGraphNearestRoundingModeToNDArrayNearestRoundingMode", "GPUResizeOps.mm", 50, "0 && \"Invalid nearest rounding mode\"");
  }
  else
  {
    NearestRoundingMode = 0;
  }
  v140 = v83;
  v141 = v82;
  v142 = v81;
  v143 = v80;
  objc_msgSend(v67, "setScaleTransform:", &v140);
  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)v136);
  if (GateLayout >= 2)
    __assert_rtn("MPSGraphResizeModeToNDArrayResampleMode", "GPUResizeOps.mm", 30, "0 && \"Invalid resize mode\"");
  objc_msgSend(v67, "setResampleMode:", GateLayout);
  objc_msgSend(v67, "setNearestMode:", NearestRoundingMode);
  objc_msgSend(v67, "setDataFormat:", v111);
  objc_msgSend(v67, "setOptions:", objc_msgSend(v67, "options") | 1);

  if (v65)
  {
    v125 = v65;
    operator delete(v65);
  }
  if (v84)
  {
    v128 = v84;
    operator delete(v84);
  }

  if (*(_QWORD *)(a1 + 32))
  {
    v94 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    if (*(_UNKNOWN **)(v94 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v140 = *(double *)(v94 + 8);
      v95 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v140);
      if (v96 == 13 && *v95 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v95 + 5) == 0x6465686374697473)
      {
        v139 = 1283;
        v136[0] = (uint64_t *)"classof on '";
        v137 = "mpsx.stitched";
        v138 = 13;
        __p = "' failed due to the operation not being registered";
        v135 = 259;
        llvm::operator+((uint64_t *)v136, (uint64_t *)&__p, (uint64_t)&v140);
        llvm::report_fatal_error((llvm::Twine *)&v140, 1);
      }
    }
    v98 = *(_QWORD *)(mlir::Block::getParentOp(*(mlir::Block **)(*(_QWORD *)(a1 + 24) + 16)) + 48);
    v99 = *(void **)(v98 + 16);
    if (v99 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v140 = *(double *)(v98 + 8);
      v105 = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v140);
      if (v106 == 13 && *v105 == 0x6974732E7873706DLL && *(_QWORD *)((char *)v105 + 5) == 0x6465686374697473)
      {
        v139 = 1283;
        v136[0] = (uint64_t *)"classof on '";
        v137 = "mpsx.stitched";
        v138 = 13;
        v140 = COERCE_DOUBLE(v136);
        v142 = COERCE_DOUBLE("' failed due to the operation not being registered");
        LOWORD(v144) = 770;
        llvm::report_fatal_error((llvm::Twine *)&v140, 1);
      }
    }
    else if (v99 == &mlir::detail::TypeIDResolver<mlir::mpsx::StitchedOp,void>::id)
    {
LABEL_119:
      GPU::MPSGraphKernelDAG::getNDArraysForPlaceholders(*(GPU::MPSGraphKernelDAG **)(a1 + 32), *(GPURegionRuntime **)(a1 + 16));
      v100 = (void *)objc_claimAutoreleasedReturnValue();
      GPU::EncodeDescriptor::getcomputeEncoder(a2);
      v101 = (void *)objc_claimAutoreleasedReturnValue();
      v102 = *((_QWORD *)a2 + 1);
      GPU::MPSGraphKernelDAG::getKernelDAGObject(*(GPU::MPSGraphKernelDAG **)(a1 + 32));
      v103 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v67, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v101, v102, v100, 0, v122, v103);

      goto LABEL_121;
    }
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
    goto LABEL_119;
  }
  GPU::EncodeDescriptor::getcomputeEncoder(a2);
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  v104 = *((_QWORD *)a2 + 1);
  v140 = *(double *)&v121;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v140, 1);
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v67, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v100, v104, v101, v122);
LABEL_121:

  if (v118 != 0.0)
    operator delete(*(void **)&v118);
  if (__src != 0.0)
    operator delete(*(void **)&__src);

}

void sub_180E42F48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id a15, void *__p, void *a17, void *a18, uint64_t a19, uint64_t a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33)
{
  void *v33;

  _Unwind_Resume(a1);
}

uint64_t GPU::ResizeOpHandler::kernelDAGOp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  unint64_t Input;
  uint64_t result;
  uint64_t AttrData;
  uint64_t v9;
  const char *v11;
  __int16 v12;
  uint64_t v13[4];
  __int16 v14;
  _QWORD v15[5];

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v15[0] = *(_QWORD *)(v2 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v15);
    if (v9 == 10 && *(_QWORD *)AttrData == 0x697365722E73706DLL && *(_WORD *)(AttrData + 8) == 25978)
    {
      v14 = 1283;
      v13[0] = (uint64_t)"classof on '";
      v13[2] = (uint64_t)"mps.resize";
      v13[3] = 10;
      v11 = "' failed due to the operation not being registered";
      v12 = 259;
      llvm::operator+(v13, (uint64_t *)&v11, (uint64_t)v15);
      llvm::report_fatal_error((llvm::Twine *)v15, 1);
    }
LABEL_11:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id)
    goto LABEL_11;
  v15[0] = *(_QWORD *)(a1 + 24);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v15);
  GPU::MPSGraphKernelDAG::getBaseTensorFromDataMap(a2, Input, 0);
  result = MPSKernelDAG::unaryCoreOp();
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(a1 + 24);
  return result;
}

void GPU::ResizeOpHandler::~ResizeOpHandler(GPU::ResizeOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeGradientOpHandler,mlir::mps::ResizeGradientOp,MPSNDArrayResampleGradient,1ul>::encodeNDArrayOp(uint64_t a1, void **a2, void *a3)
{
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  int16x8_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  id v12;
  uint64_t v13;
  uint64_t Scale;
  double v15;
  double v16;
  mlir::Operation *v17;
  uint64_t v18;
  uint64_t Offset;
  double v20;
  double v21;
  mlir::mps *v22;
  uint64_t ResizeLayout;
  const char *v24;
  uint64_t v25;
  char *v26;
  unint64_t v27;
  char *v28;
  unint64_t v29;
  uint64_t v30;
  char v31;
  _QWORD *v32;
  uint64_t DefiningOp;
  uint64_t v34;
  char *v35;
  int64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  _BYTE *v41;
  uint64_t *v42;
  int64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t v46;
  uint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _OWORD *v51;
  char *v52;
  uint64_t v53;
  __int128 v54;
  mlir::GenericProgramPoint *v55;
  mlir::Operation *v56;
  id v57;
  id v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  int16x8_t *v63;
  void *v64;
  mlir::mps *v65;
  int64_t v66;
  uint64_t *v67;
  const char *v68;
  int64_t v69;
  char *v70;
  char *v71;
  id v72;
  id v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  _BOOL4 IsSize;
  _BOOL4 InferredResultTypes;
  int v84;
  float v85;
  float v86;
  float v87;
  float v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t NearestRoundingMode;
  uint64_t GateLayout;
  void *v98;
  void *v99;
  void *v100;
  void *v101;
  id v102;
  _QWORD *AttrData;
  uint64_t v104;
  BOOL v105;
  void *v107;
  unsigned int v108;
  void *v109;
  void *v110;
  void *v111;
  id v112;
  void *v113;
  uint64_t v114;
  id v115;
  id v116;
  void *v117;
  double v118;
  double __src;
  id v120;
  unsigned int v121;
  int16x8_t *v122;
  void *v123;
  mlir::mps *v125;
  void *__p;
  char *v127;
  char *v128;
  __int16 v129;
  const char *Context;
  uint64_t *v131;
  const char *v132;
  uint64_t v133;
  __int16 v134;
  uint64_t v135;
  unint64_t v136;
  mlir::mps *v137;
  double v138;
  double v139;
  double v140;
  double v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  uint64_t v145;
  int v146;
  uint64_t v147;

  v147 = *MEMORY[0x1E0C80C00];
  v115 = a3;
  if (!*(_BYTE *)(a1 + 40))
    GPU::MultiaryKernelOpHandler<GPU::ResizeGradientOpHandler,mlir::mps::ResizeGradientOp,MPSNDArrayResampleGradient,1ul>::_createNDArrayMultiaryKernel(a1);
  objc_msgSend(v115, "objectAtIndexedSubscript:", 0);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "mpsndarray");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  v107 = v5;
  if (!v5 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v116 = v5;
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 48);
  v7 = *(void **)(v6 + 16);
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v138 = *(double *)(v6 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v138);
    if (v104 == 19)
    {
      v105 = *AttrData == 0x697365722E73706DLL && AttrData[1] == 0x69646172675F657ALL;
      if (v105 && *(_QWORD *)((char *)AttrData + 11) == 0x746E656964617267)
      {
        v134 = 1283;
        Context = "classof on '";
        v132 = "mps.resize_gradient";
        v133 = 19;
        __p = "' failed due to the operation not being registered";
        v129 = 259;
        llvm::operator+((uint64_t *)&Context, (uint64_t *)&__p, (uint64_t)&v138);
        llvm::report_fatal_error((llvm::Twine *)&v138, 1);
      }
    }
LABEL_147:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeGradientOp,void>::id)
    goto LABEL_147;
  v125 = *(mlir::mps **)(a1 + 24);
  *(double *)&v8 = COERCE_DOUBLE(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v125));
  mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v125);
  v9 = *(_QWORD *)(a1 + 16);
  v138 = *(double *)&v8;
  Context = (const char *)*((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v138) + 2);
  v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v9 + 88), (uint64_t *)&Context);
  if (v10
    && (__p = *(void **)&v138,
        (v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, (uint64_t *)&__p)) != 0))
  {
    v12 = (id)v11[3];
  }
  else
  {
    v12 = 0;
  }
  objc_msgSend(v12, "mpsndarray");
  v113 = (void *)objc_claimAutoreleasedReturnValue();

  if ((!v116 || !v113) && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  if (mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v125))
  {
    v13 = *(_QWORD *)(a1 + 16);
    Scale = mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v125);
    GPURegionRuntime::waitAndReadFPTensorData(v13, (uint64_t)a2, Scale, (int16x8_t **)&v138);
    v15 = v138;
    v16 = v139;
  }
  else
  {
    v16 = 0.0;
    v15 = 0.0;
  }
  __src = v15;
  if (mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v125))
  {
    v18 = *(_QWORD *)(a1 + 16);
    Offset = mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v125);
    GPURegionRuntime::waitAndReadFPTensorData(v18, (uint64_t)a2, Offset, (int16x8_t **)&v138);
    v20 = v138;
    v21 = v139;
  }
  else
  {
    v21 = 0.0;
    v20 = 0.0;
  }
  v118 = v20;
  v22 = v125;
  ResizeLayout = mlir::mps::getResizeLayout(v125, v17);
  if ((ResizeLayout & 0xFF00000000) == 0)
  {
    Context = (const char *)mlir::Attribute::getContext((mlir::mps *)((char *)v22 + 24));
    v131 = 0;
    v24 = (const char *)*((_QWORD *)v22 + 2);
    mlir::GenericProgramPoint::~GenericProgramPoint(v22);
    v132 = v24;
    v133 = v25;
    v138 = 0.0;
    v139 = 0.0;
    LODWORD(v140) = 0;
    v141 = 0.0;
    v142 = 0;
    v143 = 0;
    v144 = 0;
    v145 = 0;
    v146 = 0;
    __p = 0;
    v127 = 0;
    v128 = 0;
    if ((*((_BYTE *)v22 + 46) & 0x80) == 0)
    {
LABEL_62:
      v55 = mlir::OpBuilder::clone((uint64_t **)&Context, v22, (mlir::IRMapping *)&v138);
      if (mlir::mps::inferTypes(v55, v56))
        mlir::verify(v55, (mlir::Operation *)1);
      __assert_rtn("getLayoutHelper", "GPUResizeOps.mm", 81, "0 && \"failed to infer output types\"");
    }
    v26 = 0;
    v27 = 0;
    while (1)
    {
      if (v27 >= *((unsigned int *)v22 + 17))
        goto LABEL_62;
      v29 = *(_QWORD *)(*((_QWORD *)v22 + 9) + 32 * v27 + 24);
      v136 = v29;
      v137 = 0;
      if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v138, &v136, &v137) & 1) == 0)
      {
        v30 = (*(uint64_t (**)(uint64_t, void **, const char **, unint64_t))(*(_QWORD *)a1 + 48))(a1, a2, &Context, v27);
        v135 = v30;
        v136 = v29;
        v137 = 0;
        v31 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)&v138, &v136, &v137);
        v32 = v137;
        if ((v31 & 1) == 0)
        {
          v32 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)&v138, (uint64_t)&v136, &v136, v137);
          *v32 = v136;
          v32[1] = 0;
        }
        v32[1] = v30;
        if (v29 != v135)
        {
          if (mlir::Value::getDefiningOp((mlir::Value *)&v135))
            break;
        }
      }
LABEL_23:
      ++v27;
      if ((*((_BYTE *)v22 + 46) & 0x80) == 0)
        goto LABEL_62;
    }
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v135);
    v34 = DefiningOp;
    if (v26 < v128)
    {
      *(_QWORD *)v26 = DefiningOp;
      v28 = v26 + 8;
    }
    else
    {
      v35 = (char *)__p;
      v36 = v26 - (_BYTE *)__p;
      v37 = (v26 - (_BYTE *)__p) >> 3;
      v38 = v37 + 1;
      if ((unint64_t)(v37 + 1) >> 61)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      v39 = v128 - (_BYTE *)__p;
      if ((v128 - (_BYTE *)__p) >> 2 > v38)
        v38 = v39 >> 2;
      if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8)
        v40 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v40 = v38;
      if (v40)
      {
        if (v40 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v41 = operator new(8 * v40);
        v42 = (uint64_t *)&v41[8 * v37];
        *v42 = v34;
        v28 = (char *)(v42 + 1);
        v43 = v26 - v35;
        if (v26 != v35)
        {
LABEL_40:
          v44 = v43 - 8;
          if (v44 >= 0x168)
          {
            v48 = (v26 - 8 - v35) & 0xFFFFFFFFFFFFFFF8;
            if (&v41[v36 - 8 - v48] > &v41[v36 - 8])
            {
              v45 = v26;
            }
            else if (&v26[-v48 - 8] > v26 - 8)
            {
              v45 = v26;
            }
            else if ((unint64_t)(v26 - v41 - v36) >= 0x20)
            {
              v49 = (v44 >> 3) + 1;
              v50 = 8 * (v49 & 0x3FFFFFFFFFFFFFFCLL);
              v45 = &v26[-v50];
              v42 = (uint64_t *)((char *)v42 - v50);
              v51 = &v41[v36 - 16];
              v52 = v26 - 16;
              v53 = v49 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v54 = *(_OWORD *)v52;
                *(v51 - 1) = *((_OWORD *)v52 - 1);
                *v51 = v54;
                v51 -= 2;
                v52 -= 32;
                v53 -= 4;
              }
              while (v53);
              if (v49 == (v49 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_43:
                v26 = (char *)__p;
                __p = v42;
                v127 = v28;
                v128 = &v41[8 * v40];
                if (!v26)
                  goto LABEL_22;
                goto LABEL_47;
              }
            }
            else
            {
              v45 = v26;
            }
          }
          else
          {
            v45 = v26;
          }
          do
          {
            v46 = *((_QWORD *)v45 - 1);
            v45 -= 8;
            *--v42 = v46;
          }
          while (v45 != v35);
          goto LABEL_43;
        }
      }
      else
      {
        v41 = 0;
        v42 = (uint64_t *)(8 * v37);
        v47 = (uint64_t *)(8 * v37);
        *v47 = v34;
        v28 = (char *)(v47 + 1);
        v43 = v26 - v35;
        if (v26 != v35)
          goto LABEL_40;
      }
      __p = v42;
      v127 = v28;
      v128 = &v41[8 * v40];
      if (v26)
LABEL_47:
        operator delete(v26);
    }
LABEL_22:
    v127 = v28;
    v26 = v28;
    goto LABEL_23;
  }
  v121 = ResizeLayout;
  v57 = v113;
  v58 = v116;
  v59 = v58;
  v117 = v57;
  if (*((_BYTE *)v58 + (int)*MEMORY[0x1E0CC7278]))
    objc_msgSend(v58, "setReadCount:", objc_msgSend(v58, "readCount") + 1);
  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  RuntimeUtils::convertNDArrayLayout(ResizeLayout, 6u, v117, 0, 1, v60, a2[1]);
  v123 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v123)
  {
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    RuntimeUtils::convertNDArrayLayout(ResizeLayout, 6u, v117, 0, 4, v61, a2[1]);
    v123 = (void *)objc_claimAutoreleasedReturnValue();

  }
  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  RuntimeUtils::convertNDArrayLayout(ResizeLayout, 6u, v59, 0, 1, v62, a2[1]);
  v114 = objc_claimAutoreleasedReturnValue();

  v63 = (int16x8_t *)v114;
  if (!v114)
  {
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    RuntimeUtils::convertNDArrayLayout(v121, 6u, v59, 0, 4, v64, a2[1]);
    *(double *)&v63 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());

  }
  v112 = *(id *)(a1 + 8);
  v65 = v125;
  v122 = v63;
  -[int16x8_t descriptor](v63, "descriptor");
  v109 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v123, "descriptor");
  v110 = (void *)objc_claimAutoreleasedReturnValue();
  Context = 0;
  v131 = 0;
  v132 = 0;
  v66 = *(_QWORD *)&v16 - *(_QWORD *)&__src;
  if (*(_QWORD *)&v16 != *(_QWORD *)&__src)
  {
    if (v66 < 0)
      std::vector<long>::__throw_length_error[abi:ne180100]();
    v67 = (uint64_t *)operator new(*(_QWORD *)&v16 - *(_QWORD *)&__src);
    v68 = (char *)v67 + 4 * (v66 >> 2);
    Context = (const char *)v67;
    v132 = v68;
    memcpy(v67, *(const void **)&__src, v66);
    v131 = (uint64_t *)v68;
    __p = 0;
    v127 = 0;
    v128 = 0;
    v69 = *(_QWORD *)&v21 - *(_QWORD *)&v118;
    if (*(_QWORD *)&v21 != *(_QWORD *)&v118)
      goto LABEL_73;
LABEL_76:
    v71 = 0;
    v70 = 0;
    goto LABEL_77;
  }
  v68 = 0;
  v67 = 0;
  __p = 0;
  v127 = 0;
  v128 = 0;
  v69 = *(_QWORD *)&v21 - *(_QWORD *)&v118;
  if (*(_QWORD *)&v21 == *(_QWORD *)&v118)
    goto LABEL_76;
LABEL_73:
  if (v69 < 0)
    std::vector<long>::__throw_length_error[abi:ne180100]();
  v70 = (char *)operator new(v69);
  v71 = &v70[4 * (v69 >> 2)];
  __p = v70;
  v128 = v71;
  memcpy(v70, *(const void **)&v118, v69);
  v127 = v71;
LABEL_77:
  v137 = v65;
  v72 = v112;
  v120 = v109;
  v73 = v110;
  v111 = v73;
  if (v121 <= 6 && ((1 << v121) & 0x51) != 0)
    goto LABEL_79;
  if ((v121 & 0xFFFFFFFB) != 1)
  {
    if (MTLReportFailureTypeEnabled())
      MTLReportFailure();
LABEL_79:
    objc_msgSend(v120, "sliceRangeForDimension:", 0);
    v75 = v74;
    objc_msgSend(v120, "sliceRangeForDimension:", 1);
    v77 = v76;
    objc_msgSend(v73, "sliceRangeForDimension:", 0);
    v79 = v78;
    objc_msgSend(v73, "sliceRangeForDimension:", 1);
    v81 = v80;
    v108 = 0;
    if (v67 != (uint64_t *)v68)
      goto LABEL_95;
    goto LABEL_80;
  }
  objc_msgSend(v120, "sliceRangeForDimension:", 1);
  v75 = v89;
  objc_msgSend(v120, "sliceRangeForDimension:", 2);
  v77 = v90;
  objc_msgSend(v73, "sliceRangeForDimension:", 1);
  v79 = v91;
  objc_msgSend(v73, "sliceRangeForDimension:", 2);
  v81 = v92;
  v108 = 1;
  if (v67 != (uint64_t *)v68)
    goto LABEL_95;
LABEL_80:
  if (v70 == v71)
  {
    IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v137);
    InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v137);
    v84 = !IsSize || InferredResultTypes;
    if (v84)
      v85 = 0.0;
    else
      v85 = (float)((float)((float)v81 / (float)v77) + -1.0) * 0.5;
    if (v84)
      v86 = 0.0;
    else
      v86 = (float)((float)((float)v79 / (float)v75) + -1.0) * 0.5;
    if (InferredResultTypes)
      v87 = (float)(v81 - 1) / (float)(v77 - 1);
    else
      v87 = (float)v81 / (float)v77;
    if (InferredResultTypes)
      v88 = (float)(v79 - 1) / (float)(v75 - 1);
    else
      v88 = (float)v79 / (float)v75;
    goto LABEL_104;
  }
LABEL_95:
  if (v121 >= 7 || ((0x73u >> v121) & 1) == 0)
    llvm::llvm_unreachable_internal((llvm *)"unhandled TensorDataLayout enum.", "../mlir-mps/third_party/mlir-apple/include/Dialect/MPS/Utils/MPSTypeUtils.h", (const char *)0x69);
  v93 = 8 * (int)v121;
  v94 = *(_QWORD *)((char *)&unk_181287C68 + v93);
  v95 = *(_QWORD *)((char *)&unk_181287CA0 + v93);
  if (v67 != (uint64_t *)v68)
  {
    if (v94 >= (v68 - (const char *)v67) >> 2 && MTLReportFailureTypeEnabled())
      MTLReportFailure();
    v87 = *((float *)v67 + v94);
    v88 = *((float *)v67 + v95);
    if (v70 != v71)
      goto LABEL_100;
LABEL_103:
    v85 = 0.0;
    v86 = 0.0;
    goto LABEL_104;
  }
  v87 = 1.0;
  v88 = 1.0;
  if (v70 == v71)
    goto LABEL_103;
LABEL_100:
  if (v94 >= (v71 - v70) >> 2 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v85 = *(float *)&v70[4 * v94];
  v86 = *(float *)&v70[4 * v95];
LABEL_104:
  if ((mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)&v137) & 0xFF00000000) != 0)
  {
    NearestRoundingMode = mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)&v137);
    if (NearestRoundingMode >= 6)
      __assert_rtn("MPSGraphNearestRoundingModeToNDArrayNearestRoundingMode", "GPUResizeOps.mm", 50, "0 && \"Invalid nearest rounding mode\"");
  }
  else
  {
    NearestRoundingMode = 0;
  }
  v138 = v88;
  v139 = v87;
  v140 = v86;
  v141 = v85;
  objc_msgSend(v72, "setScaleTransform:", &v138);
  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v137);
  if (GateLayout >= 2)
    __assert_rtn("MPSGraphResizeModeToNDArrayResampleMode", "GPUResizeOps.mm", 30, "0 && \"Invalid resize mode\"");
  objc_msgSend(v72, "setResampleMode:", GateLayout);
  objc_msgSend(v72, "setNearestMode:", NearestRoundingMode);
  objc_msgSend(v72, "setDataFormat:", v108);
  objc_msgSend(v72, "setOptions:", objc_msgSend(v72, "options") | 1);

  if (v70)
  {
    v127 = v70;
    operator delete(v70);
  }
  if (v67)
  {
    v131 = v67;
    operator delete(v67);
  }

  if (v122->i8[*MEMORY[0x1E0CC7278]])
    -[int16x8_t setReadCount:](v122, "setReadCount:", -[int16x8_t readCount](v122, "readCount") + 1);
  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  v99 = a2[1];
  v138 = *(double *)&v122;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v138, 1);
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v72, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:sourceGradient:gradientState:destinationArray:kernelDAGObject:", v98, v99, v100, v123, 0, v122, 0, v107);

  if (v114)
  {
    if (v122->i8[*MEMORY[0x1E0CC7278]])
      MPSDecrementReadCount((MPSTemporaryNDArray *)v122);
  }
  else
  {
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v101 = (void *)objc_claimAutoreleasedReturnValue();
    v102 = RuntimeUtils::convertNDArrayLayout(6u, v121, v122, v59, 4, v101, a2[1]);

  }
  if (v118 != 0.0)
    operator delete(*(void **)&v118);
  if (__src != 0.0)
    operator delete(*(void **)&__src);

}

void sub_180E44248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, id a18, void *a19, uint64_t a20,void *__p,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{

  _Unwind_Resume(a1);
}

void GPU::ResizeGradientOpHandler::~ResizeGradientOpHandler(GPU::ResizeGradientOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeOpHandler,mlir::mps::ResizeOp,MPSNDArrayResample,1ul>::_createNDArrayMultiaryKernel(uint64_t a1)
{
  id v2;
  void *v3;
  id obj;

  v2 = objc_alloc(MEMORY[0x1E0CC7138]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  obj = (id)objc_msgSend(v2, "initWithDevice:", v3);

  objc_storeStrong((id *)(a1 + 8), obj);
  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);

}

void sub_180E445A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_180E445B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeOpHandler,mlir::mps::ResizeOp,MPSNDArrayResample,1ul>::~MultiaryKernelOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);
  JUMPOUT(0x186DA1680);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeGradientOpHandler,mlir::mps::ResizeGradientOp,MPSNDArrayResampleGradient,1ul>::_createNDArrayMultiaryKernel(uint64_t a1)
{
  id v2;
  void *v3;
  id obj;

  v2 = objc_alloc(MEMORY[0x1E0CC7140]);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 16) + 48), "metalDevice");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  obj = (id)objc_msgSend(v2, "initWithDevice:", v3);

  objc_storeStrong((id *)(a1 + 8), obj);
  objc_msgSend(*(id *)(a1 + 8), "setOptions:", objc_msgSend(*(id *)(a1 + 8), "options") | 1);

}

void sub_180E44680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_180E44698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void GPU::MultiaryKernelOpHandler<GPU::ResizeGradientOpHandler,mlir::mps::ResizeGradientOp,MPSNDArrayResampleGradient,1ul>::~MultiaryKernelOpHandler(GPU::BaseOpHandler *a1)
{
  GPU::BaseOpHandler::~BaseOpHandler(a1);
  JUMPOUT(0x186DA1680);
}

EmitterObjC::ReductionMeanOpHandler *EmitterObjC::ReductionMeanOpHandler::ReductionMeanOpHandler(EmitterObjC::ReductionMeanOpHandler *this, id *a2, mlir::Operation *a3)
{
  uint64_t Input;
  uint64_t Axes;
  uint64_t v7;
  std::string::size_type v8;
  std::string *v9;
  std::string::size_type size;
  std::string *v11;
  std::string *v12;
  size_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  void *p_dst;
  int v18;
  size_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  std::string *p_p;
  uint64_t v25;
  uint64_t v26;
  std::string *v27;
  std::string *v28;
  std::string::size_type v29;
  std::string *v30;
  int v31;
  size_t v32;
  unint64_t v33;
  char *v34;
  void *v35;
  std::string *v36;
  _QWORD *v37;
  _QWORD *v38;
  int v39;
  std::string::size_type v40;
  std::string *v41;
  std::string *v42;
  void *v43;
  uint64_t v44;
  id v45;
  uint64_t v47;
  uint64_t v48;
  std::string *v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  char v53;
  std::string v54;
  std::string __dst;
  std::string __p;
  uint64_t v57;
  _BYTE v58[15];
  uint64_t *v59;
  uint64_t v60;
  _QWORD v61[6];

  v61[4] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *(_QWORD *)this = &off_1E0E14DC8;
  if (!a3)
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  v57 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMeanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMeanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v57);
  v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&__p, "@[");
  v59 = v61;
  v60 = 0x400000000;
  v51 = v7;
  if (mlir::matchConstantWithIntVector<long long>(Axes, (uint64_t)&v59))
  {
    v8 = v60;
    if (!(_DWORD)v60)
    {
      v13 = 2;
      goto LABEL_61;
    }
    __dst.__r_.__value_.__r.__words[2] = 0x300000000000000;
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0x405B40uLL;
    std::to_string(&v54, *v59);
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v9 = &v54;
    else
      v9 = (std::string *)v54.__r_.__value_.__r.__words[0];
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v54.__r_.__value_.__r.__words[2]);
    else
      size = v54.__r_.__value_.__l.__size_;
    v11 = std::string::append(&__dst, (const std::string::value_type *)v9, size);
    v12 = (std::string *)v11->__r_.__value_.__r.__words[0];
    *(_QWORD *)v58 = v11->__r_.__value_.__l.__size_;
    *(_QWORD *)&v58[7] = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
    v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
    v11->__r_.__value_.__r.__words[0] = 0;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)&v58[7];
    __p.__r_.__value_.__l.__size_ = *(_QWORD *)v58;
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = v13;
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v54.__r_.__value_.__l.__data_);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_12:
        v50 = Input;
        if (v60 < 2)
          goto LABEL_60;
LABEL_17:
        v14 = 1;
        while (1)
        {
          v15 = (char)v13;
          if ((v13 & 0x80u) != 0)
            v13 = __p.__r_.__value_.__l.__size_;
          v16 = v13 + 2;
          if (v13 + 2 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v16 >= 0x17)
          {
            v22 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v16 | 7) != 0x17)
              v22 = v16 | 7;
            v23 = v22 + 1;
            p_dst = operator new(v22 + 1);
            __dst.__r_.__value_.__l.__size_ = v13 + 2;
            __dst.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          }
          else
          {
            memset(&__dst, 0, sizeof(__dst));
            p_dst = &__dst;
            *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v13 + 2;
            if (!v13)
            {
              strcpy((char *)&__dst, ", ");
              if ((v15 & 0x80000000) == 0)
                goto LABEL_26;
LABEL_40:
              operator delete(v12);
              goto LABEL_26;
            }
          }
          if (v15 >= 0)
            p_p = &__p;
          else
            p_p = v12;
          memmove(p_dst, p_p, v13);
          strcpy((char *)p_dst + v13, ", ");
          if (v15 < 0)
            goto LABEL_40;
LABEL_26:
          __p = __dst;
          v18 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v19 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          else
            v19 = __dst.__r_.__value_.__l.__size_;
          v20 = v19 + 1;
          if (v19 + 1 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v20 >= 0x17)
          {
            v25 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v20 | 7) != 0x17)
              v25 = v20 | 7;
            v26 = v25 + 1;
            v21 = (char *)operator new(v25 + 1);
            __dst.__r_.__value_.__l.__size_ = v19 + 1;
            __dst.__r_.__value_.__r.__words[2] = v26 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
LABEL_44:
            if (v18 >= 0)
              v27 = &__p;
            else
              v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
            memmove(v21, v27, v19);
            goto LABEL_48;
          }
          memset(&__dst, 0, sizeof(__dst));
          v21 = (char *)&__dst;
          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v19 + 1;
          if (v19)
            goto LABEL_44;
LABEL_48:
          *(_WORD *)&v21[v19] = 64;
          if (v14 >= v60)
            __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
          std::to_string(&v54, v59[v14]);
          if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v28 = &v54;
          else
            v28 = (std::string *)v54.__r_.__value_.__r.__words[0];
          if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v29 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
          else
            v29 = v54.__r_.__value_.__l.__size_;
          v30 = std::string::append(&__dst, (const std::string::value_type *)v28, v29);
          v12 = (std::string *)v30->__r_.__value_.__r.__words[0];
          *(_QWORD *)v58 = v30->__r_.__value_.__l.__size_;
          *(_QWORD *)&v58[7] = *(std::string::size_type *)((char *)&v30->__r_.__value_.__r.__words[1] + 7);
          v13 = HIBYTE(v30->__r_.__value_.__r.__words[2]);
          v30->__r_.__value_.__r.__words[0] = 0;
          v30->__r_.__value_.__l.__size_ = 0;
          v30->__r_.__value_.__r.__words[2] = 0;
          if (v18 < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
          __p.__r_.__value_.__l.__size_ = *(_QWORD *)v58;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)&v58[7];
          *((_BYTE *)&__p.__r_.__value_.__s + 23) = v13;
          if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v54.__r_.__value_.__l.__data_);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_19;
LABEL_59:
            operator delete(__dst.__r_.__value_.__l.__data_);
            if (++v14 >= v60)
              goto LABEL_60;
          }
          else
          {
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              goto LABEL_59;
LABEL_19:
            if (++v14 >= v60)
              goto LABEL_60;
          }
        }
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_12;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    v50 = Input;
    if (v60 < 2)
    {
LABEL_60:
      v8 = __p.__r_.__value_.__l.__size_;
      v7 = v51;
      Input = v50;
LABEL_61:
      v31 = (char)v13;
      if ((v13 & 0x80u) == 0)
        v32 = v13;
      else
        v32 = v8;
      v33 = v32 + 1;
      if (v32 + 1 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      if (v33 >= 0x17)
      {
        v47 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v33 | 7) != 0x17)
          v47 = v33 | 7;
        v48 = v47 + 1;
        v34 = (char *)operator new(v47 + 1);
        __dst.__r_.__value_.__l.__size_ = v32 + 1;
        __dst.__r_.__value_.__r.__words[2] = v48 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
      }
      else
      {
        memset(&__dst, 0, sizeof(__dst));
        v34 = (char *)&__dst;
        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v32 + 1;
        if (!v32)
        {
          LOWORD(__dst.__r_.__value_.__l.__data_) = 93;
          if ((v31 & 0x80000000) == 0)
          {
LABEL_68:
            __p = __dst;
            goto LABEL_69;
          }
LABEL_96:
          operator delete(__p.__r_.__value_.__l.__data_);
          goto LABEL_68;
        }
      }
      if (v31 >= 0)
        v49 = &__p;
      else
        v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
      memmove(v34, v49, v32);
      *(_WORD *)&v34[v32] = 93;
      if ((v31 & 0x80000000) == 0)
        goto LABEL_68;
      goto LABEL_96;
    }
    goto LABEL_17;
  }
LABEL_69:
  v35 = (void *)MEMORY[0x1E0CB3940];
  v36 = &__dst;
  (*((void (**)(std::string *__return_ptr, id *, uint64_t))*a2 + 4))(&__dst, a2, v7);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v36 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  *(_QWORD *)v58 = Input;
  v54.__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
  v37 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), (uint64_t *)v58, (uint64_t)&std::piecewise_construct, &v54);
  v38 = v37 + 3;
  if (*((char *)v37 + 47) < 0)
    v38 = (_QWORD *)*v38;
  v39 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  v40 = __p.__r_.__value_.__r.__words[0];
  v53 = 0;
  LOBYTE(v52) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v51, (uint64_t)&v52, &v54);
  v41 = &__p;
  if (v39 < 0)
    v41 = (std::string *)v40;
  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v42 = &v54;
  else
    v42 = (std::string *)v54.__r_.__value_.__r.__words[0];
  objc_msgSend(v35, "stringWithFormat:", CFSTR("\n    MPSGraphTensor *%s = \n    [graph meanOfTensor:%s\n                   axes:%s\n                   name:%s];\n    "),
    v36,
    v38,
    v41,
    v42);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53 & 0x80000000) == 0)
      goto LABEL_80;
LABEL_87:
    operator delete(v52);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_81;
    goto LABEL_88;
  }
  operator delete(v54.__r_.__value_.__l.__data_);
  if (v53 < 0)
    goto LABEL_87;
LABEL_80:
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_81;
LABEL_88:
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_81:
  objc_msgSend(a2[27], "stringByAppendingString:", v43);
  v44 = objc_claimAutoreleasedReturnValue();
  v45 = a2[27];
  a2[27] = (id)v44;

  if (v59 != v61)
    free(v59);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return this;
}

void sub_180E44D78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  uint64_t v41;
  void *v43;

  if (a29 < 0)
    operator delete(__p);
  if (a35 < 0)
    operator delete(a30);
  v43 = *(void **)(v41 - 144);
  if (v43 != a15)
    free(v43);
  if (a41 < 0)
    operator delete(a36);
  _Unwind_Resume(exception_object);
}

EmitterObjC::ReductionVarianceOpHandler *EmitterObjC::ReductionVarianceOpHandler::ReductionVarianceOpHandler(EmitterObjC::ReductionVarianceOpHandler *this, id *a2, mlir::Operation *a3)
{
  uint64_t Input;
  uint64_t Axes;
  uint64_t v7;
  std::string::size_type v8;
  std::string *v9;
  std::string::size_type size;
  std::string *v11;
  std::string *v12;
  size_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  void *p_dst;
  int v18;
  size_t v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  std::string *p_p;
  uint64_t v25;
  uint64_t v26;
  std::string *v27;
  std::string *v28;
  std::string::size_type v29;
  std::string *v30;
  int v31;
  size_t v32;
  unint64_t v33;
  char *v34;
  void *v35;
  std::string *v36;
  _QWORD *v37;
  _QWORD *v38;
  int v39;
  std::string::size_type v40;
  std::string *v41;
  std::string *v42;
  void *v43;
  uint64_t v44;
  id v45;
  uint64_t v47;
  uint64_t v48;
  std::string *v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  char v53;
  std::string v54;
  std::string __dst;
  std::string __p;
  uint64_t v57;
  _BYTE v58[15];
  uint64_t *v59;
  uint64_t v60;
  _QWORD v61[6];

  v61[4] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *(_QWORD *)this = &off_1E0E14F00;
  if (!a3)
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  v57 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionVarianceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionVarianceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v57);
  v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  *((_BYTE *)&__p.__r_.__value_.__s + 23) = 2;
  strcpy((char *)&__p, "@[");
  v59 = v61;
  v60 = 0x400000000;
  v51 = v7;
  if (mlir::matchConstantWithIntVector<long long>(Axes, (uint64_t)&v59))
  {
    v8 = v60;
    if (!(_DWORD)v60)
    {
      v13 = 2;
      goto LABEL_61;
    }
    __dst.__r_.__value_.__r.__words[2] = 0x300000000000000;
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0x405B40uLL;
    std::to_string(&v54, *v59);
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v9 = &v54;
    else
      v9 = (std::string *)v54.__r_.__value_.__r.__words[0];
    if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v54.__r_.__value_.__r.__words[2]);
    else
      size = v54.__r_.__value_.__l.__size_;
    v11 = std::string::append(&__dst, (const std::string::value_type *)v9, size);
    v12 = (std::string *)v11->__r_.__value_.__r.__words[0];
    *(_QWORD *)v58 = v11->__r_.__value_.__l.__size_;
    *(_QWORD *)&v58[7] = *(std::string::size_type *)((char *)&v11->__r_.__value_.__r.__words[1] + 7);
    v13 = HIBYTE(v11->__r_.__value_.__r.__words[2]);
    v11->__r_.__value_.__r.__words[0] = 0;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)&v58[7];
    __p.__r_.__value_.__l.__size_ = *(_QWORD *)v58;
    *((_BYTE *)&__p.__r_.__value_.__s + 23) = v13;
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v54.__r_.__value_.__l.__data_);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_12:
        v50 = Input;
        if (v60 < 2)
          goto LABEL_60;
LABEL_17:
        v14 = 1;
        while (1)
        {
          v15 = (char)v13;
          if ((v13 & 0x80u) != 0)
            v13 = __p.__r_.__value_.__l.__size_;
          v16 = v13 + 2;
          if (v13 + 2 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v16 >= 0x17)
          {
            v22 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v16 | 7) != 0x17)
              v22 = v16 | 7;
            v23 = v22 + 1;
            p_dst = operator new(v22 + 1);
            __dst.__r_.__value_.__l.__size_ = v13 + 2;
            __dst.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          }
          else
          {
            memset(&__dst, 0, sizeof(__dst));
            p_dst = &__dst;
            *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v13 + 2;
            if (!v13)
            {
              strcpy((char *)&__dst, ", ");
              if ((v15 & 0x80000000) == 0)
                goto LABEL_26;
LABEL_40:
              operator delete(v12);
              goto LABEL_26;
            }
          }
          if (v15 >= 0)
            p_p = &__p;
          else
            p_p = v12;
          memmove(p_dst, p_p, v13);
          strcpy((char *)p_dst + v13, ", ");
          if (v15 < 0)
            goto LABEL_40;
LABEL_26:
          __p = __dst;
          v18 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v19 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          else
            v19 = __dst.__r_.__value_.__l.__size_;
          v20 = v19 + 1;
          if (v19 + 1 > 0x7FFFFFFFFFFFFFF7)
            std::string::__throw_length_error[abi:ne180100]();
          if (v20 >= 0x17)
          {
            v25 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v20 | 7) != 0x17)
              v25 = v20 | 7;
            v26 = v25 + 1;
            v21 = (char *)operator new(v25 + 1);
            __dst.__r_.__value_.__l.__size_ = v19 + 1;
            __dst.__r_.__value_.__r.__words[2] = v26 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
LABEL_44:
            if (v18 >= 0)
              v27 = &__p;
            else
              v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
            memmove(v21, v27, v19);
            goto LABEL_48;
          }
          memset(&__dst, 0, sizeof(__dst));
          v21 = (char *)&__dst;
          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v19 + 1;
          if (v19)
            goto LABEL_44;
LABEL_48:
          *(_WORD *)&v21[v19] = 64;
          if (v14 >= v60)
            __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
          std::to_string(&v54, v59[v14]);
          if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v28 = &v54;
          else
            v28 = (std::string *)v54.__r_.__value_.__r.__words[0];
          if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v29 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
          else
            v29 = v54.__r_.__value_.__l.__size_;
          v30 = std::string::append(&__dst, (const std::string::value_type *)v28, v29);
          v12 = (std::string *)v30->__r_.__value_.__r.__words[0];
          *(_QWORD *)v58 = v30->__r_.__value_.__l.__size_;
          *(_QWORD *)&v58[7] = *(std::string::size_type *)((char *)&v30->__r_.__value_.__r.__words[1] + 7);
          v13 = HIBYTE(v30->__r_.__value_.__r.__words[2]);
          v30->__r_.__value_.__r.__words[0] = 0;
          v30->__r_.__value_.__l.__size_ = 0;
          v30->__r_.__value_.__r.__words[2] = 0;
          if (v18 < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
          __p.__r_.__value_.__l.__size_ = *(_QWORD *)v58;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)&v58[7];
          *((_BYTE *)&__p.__r_.__value_.__s + 23) = v13;
          if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v54.__r_.__value_.__l.__data_);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_19;
LABEL_59:
            operator delete(__dst.__r_.__value_.__l.__data_);
            if (++v14 >= v60)
              goto LABEL_60;
          }
          else
          {
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              goto LABEL_59;
LABEL_19:
            if (++v14 >= v60)
              goto LABEL_60;
          }
        }
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_12;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    v50 = Input;
    if (v60 < 2)
    {
LABEL_60:
      v8 = __p.__r_.__value_.__l.__size_;
      v7 = v51;
      Input = v50;
LABEL_61:
      v31 = (char)v13;
      if ((v13 & 0x80u) == 0)
        v32 = v13;
      else
        v32 = v8;
      v33 = v32 + 1;
      if (v32 + 1 > 0x7FFFFFFFFFFFFFF7)
        std::string::__throw_length_error[abi:ne180100]();
      if (v33 >= 0x17)
      {
        v47 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v33 | 7) != 0x17)
          v47 = v33 | 7;
        v48 = v47 + 1;
        v34 = (char *)operator new(v47 + 1);
        __dst.__r_.__value_.__l.__size_ = v32 + 1;
        __dst.__r_.__value_.__r.__words[2] = v48 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
      }
      else
      {
        memset(&__dst, 0, sizeof(__dst));
        v34 = (char *)&__dst;
        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v32 + 1;
        if (!v32)
        {
          LOWORD(__dst.__r_.__value_.__l.__data_) = 93;
          if ((v31 & 0x80000000) == 0)
          {
LABEL_68:
            __p = __dst;
            goto LABEL_69;
          }
LABEL_96:
          operator delete(__p.__r_.__value_.__l.__data_);
          goto LABEL_68;
        }
      }
      if (v31 >= 0)
        v49 = &__p;
      else
        v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
      memmove(v34, v49, v32);
      *(_WORD *)&v34[v32] = 93;
      if ((v31 & 0x80000000) == 0)
        goto LABEL_68;
      goto LABEL_96;
    }
    goto LABEL_17;
  }
LABEL_69:
  v35 = (void *)MEMORY[0x1E0CB3940];
  v36 = &__dst;
  (*((void (**)(std::string *__return_ptr, id *, uint64_t))*a2 + 4))(&__dst, a2, v7);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v36 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  *(_QWORD *)v58 = Input;
  v54.__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
  v37 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), (uint64_t *)v58, (uint64_t)&std::piecewise_construct, &v54);
  v38 = v37 + 3;
  if (*((char *)v37 + 47) < 0)
    v38 = (_QWORD *)*v38;
  v39 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
  v40 = __p.__r_.__value_.__r.__words[0];
  v53 = 0;
  LOBYTE(v52) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v51, (uint64_t)&v52, &v54);
  v41 = &__p;
  if (v39 < 0)
    v41 = (std::string *)v40;
  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v42 = &v54;
  else
    v42 = (std::string *)v54.__r_.__value_.__r.__words[0];
  objc_msgSend(v35, "stringWithFormat:", CFSTR("\n    MPSGraphTensor *%s = \n    [graph varianceOfTensor:%s\n                       axes:%s\n                       name:%s];\n    "),
    v36,
    v38,
    v41,
    v42);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53 & 0x80000000) == 0)
      goto LABEL_80;
LABEL_87:
    operator delete(v52);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_81;
    goto LABEL_88;
  }
  operator delete(v54.__r_.__value_.__l.__data_);
  if (v53 < 0)
    goto LABEL_87;
LABEL_80:
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_81;
LABEL_88:
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_81:
  objc_msgSend(a2[27], "stringByAppendingString:", v43);
  v44 = objc_claimAutoreleasedReturnValue();
  v45 = a2[27];
  a2[27] = (id)v44;

  if (v59 != v61)
    free(v59);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return this;
}

void sub_180E45530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  uint64_t v41;
  void *v43;

  if (a29 < 0)
    operator delete(__p);
  if (a35 < 0)
    operator delete(a30);
  v43 = *(void **)(v41 - 144);
  if (v43 != a15)
    free(v43);
  if (a41 < 0)
    operator delete(a36);
  _Unwind_Resume(exception_object);
}

EmitterObjC::SoftmaxOpHandler *EmitterObjC::SoftmaxOpHandler::SoftmaxOpHandler(EmitterObjC::SoftmaxOpHandler *this, id *a2, mlir::Operation *a3)
{
  uint64_t **Input;
  uint64_t Filter;
  uint64_t v7;
  uint64_t v8;
  uint64_t DefiningOp;
  unint64_t SingleInt;
  char v11;
  uint64_t v12;
  void *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  std::string *p_p;
  void *v18;
  uint64_t v19;
  id v20;
  void *v22;
  char v23;
  std::string __p;
  void *v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t **v29;

  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *(_QWORD *)this = &off_1E0E14AE0;
  if (!a3)
    __assert_rtn("dyn_cast", "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
  v28 = llvm::DefaultDoCastIfPossible<mlir::mps::SoftmaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SoftmaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a3);
  Input = (uint64_t **)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v28);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v28);
  v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v28);
  v25 = 0;
  v26 = 0;
  v29 = (uint64_t **)&v25;
  __p.__r_.__value_.__r.__words[0] = Filter;
  if (!Filter)
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  v8 = v7;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&__p);
  if (DefiningOp
    && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v29, DefiningOp)
    && (SingleInt = mlir::getSingleIntValue<long long>((uint64_t)v25, v26), v11))
  {
    v12 = SingleInt;
  }
  else
  {
    v12 = -1;
  }
  v13 = (void *)MEMORY[0x1E0CB3940];
  v14 = &v25;
  (*((void (**)(void **__return_ptr, id *, uint64_t))*a2 + 4))(&v25, a2, v8);
  if (v27 < 0)
    v14 = v25;
  v29 = Input;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
  v15 = std::__hash_table<std::__hash_value_type<void *,std::string>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::string>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::string>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::string>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>((uint64_t)(a2 + 32), (uint64_t *)&v29, (uint64_t)&std::piecewise_construct, &__p);
  v16 = v15 + 3;
  if (*((char *)v15 + 47) < 0)
    v16 = (_QWORD *)*v16;
  v23 = 0;
  LOBYTE(v22) = 0;
  EmitObjC::emitTensorName((uint64_t)a2, v8, (uint64_t)&v22, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v13, "stringWithFormat:", CFSTR("\n    MPSGraphTensor *%s = \n    [graph softMaxWithTensor:%s\n                        axis:%ld\n                        name:%s];\n    "),
    v14,
    v16,
    v12,
    p_p);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v23 & 0x80000000) == 0)
      goto LABEL_17;
LABEL_20:
    operator delete(v22);
    if ((v27 & 0x80000000) == 0)
      goto LABEL_18;
LABEL_21:
    operator delete(v25);
    goto LABEL_18;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v23 < 0)
    goto LABEL_20;
LABEL_17:
  if (v27 < 0)
    goto LABEL_21;
LABEL_18:
  objc_msgSend(a2[27], "stringByAppendingString:", v18);
  v19 = objc_claimAutoreleasedReturnValue();
  v20 = a2[27];
  a2[27] = (id)v19;

  return this;
}

void sub_180E45878(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E45888(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0)
  {
    operator delete(a19);
    if ((a18 & 0x80000000) == 0)
    {
LABEL_3:
      if (a30 < 0)
        goto LABEL_4;
      goto LABEL_7;
    }
  }
  else if ((a18 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a13);
  if (a30 < 0)
  {
LABEL_4:
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
LABEL_7:
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMeanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMeanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x756465722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x656D5F6E6F697463
      && *(_WORD *)(AttrData + 16) == 28257)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_mean";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionVarianceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionVarianceOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 22
      && *AttrData == 0x756465722E73706DLL
      && AttrData[1] == 0x61765F6E6F697463
      && *(_QWORD *)((char *)AttrData + 14) == 0x65636E6169726176)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_variance";
      v9[3] = 22;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id)
  {
    return 0;
  }
  return result;
}

id *GPU::PermuteOpHandler::PermuteOpHandler(id *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  GPU::BaseOpHandler *v5;
  char *v6;
  id v7;
  void *v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t Filter;
  uint64_t v14;
  void *v15;
  size_t v16;
  uint64_t *v17;
  uint64_t *v18;
  void *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *AttrData;
  uint64_t v29;
  id v31;
  const char *v32;
  __int16 v33;
  uint64_t v34[4];
  __int16 v35;
  void *v36;
  uint64_t v37;
  _QWORD v38[5];

  v38[4] = *MEMORY[0x1E0C80C00];
  v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)this, a2, a3, a4);
  *(_OWORD *)((char *)v5 + 120) = 0u;
  v6 = (char *)v5 + 120;
  *(_QWORD *)v5 = &off_1E0E1BF70;
  *(_OWORD *)((char *)v5 + 136) = 0u;
  *(_OWORD *)((char *)v5 + 152) = 0u;
  *(_OWORD *)((char *)v5 + 168) = 0u;
  *(_OWORD *)((char *)v5 + 184) = 0u;
  *(_OWORD *)((char *)v5 + 200) = 0u;
  *(_OWORD *)((char *)v5 + 216) = 0u;
  *(_OWORD *)((char *)v5 + 232) = 0u;
  *(_OWORD *)((char *)v5 + 248) = 0u;
  *((_QWORD *)v5 + 33) = 0;
  v7 = objc_alloc(MEMORY[0x1E0CC7030]);
  objc_msgSend(*((id *)this[2] + 6), "metalDevice");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = objc_msgSend(v7, "initWithDevice:", v8);
  v10 = this[1];
  this[1] = (id)v9;

  objc_msgSend(this[1], "setOptions:", objc_msgSend(this[1], "options") | 1);
  v11 = *((_QWORD *)this[3] + 6);
  v12 = *(void **)(v11 + 16);
  if (v12 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v36 = *(void **)(v11 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v36);
    if (v29 == 11 && *AttrData == 0x6D7265702E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6574756D7265702ELL)
    {
      v35 = 1283;
      v34[0] = (uint64_t)"classof on '";
      v34[2] = (uint64_t)"mps.permute";
      v34[3] = 11;
      v32 = "' failed due to the operation not being registered";
      v33 = 259;
      llvm::operator+(v34, (uint64_t *)&v32, (uint64_t)&v36);
      llvm::report_fatal_error((llvm::Twine *)&v36, 1);
    }
LABEL_30:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v12 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
    goto LABEL_30;
  v31 = this[3];
  v36 = v38;
  v37 = 0x400000000;
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v31);
  if (!mlir::matchConstantWithIntVector<long long>(Filter, (uint64_t)&v36))
    goto LABEL_18;
  v14 = v37;
  if ((_DWORD)v37)
  {
    v15 = v36;
    v16 = 8 * v37;
    v17 = (uint64_t *)operator new(v16);
    v18 = &v17[v14];
    memcpy(v17, v15, v16);
    v19 = *(void **)v6;
    if (!*(_QWORD *)v6)
      goto LABEL_7;
    goto LABEL_6;
  }
  v17 = 0;
  v18 = 0;
  v19 = *(void **)v6;
  if (*(_QWORD *)v6)
  {
LABEL_6:
    this[16] = v19;
    operator delete(v19);
    *(_QWORD *)v6 = 0;
    *((_QWORD *)v6 + 1) = 0;
    *((_QWORD *)v6 + 2) = 0;
  }
LABEL_7:
  this[15] = v17;
  this[16] = v18;
  this[17] = v18;
  v20 = (char *)v18 - (char *)v17;
  if (v18 != v17)
  {
    v21 = v20 >> 3;
    v22 = (v20 >> 3) - 1;
    do
    {
      v24 = *v17++;
      v23 = v24;
      if (v24 >= 0)
        v25 = v21;
      else
        v25 = 0;
      v26 = v25 + ~v23;
      if ((v26 < 0 || v26 >= v21) && MTLReportFailureTypeEnabled())
        MTLReportFailure();
      this[v26 + 18] = (id)v22--;
    }
    while (v22 != -1);
  }
LABEL_18:
  if (v36 != v38)
    free(v36);
  return this;
}

void sub_180E45E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  GPU::BaseOpHandler *v20;
  void **v21;
  void *v22;
  void *v24;

  if (a20 == v22)
  {
    v24 = *v21;
    if (!*v21)
      goto LABEL_3;
  }
  else
  {
    free(a20);
    v24 = *v21;
    if (!*v21)
    {
LABEL_3:
      GPU::BaseOpHandler::~BaseOpHandler(v20);
      _Unwind_Resume(a1);
    }
  }
  *((_QWORD *)v20 + 16) = v24;
  operator delete(v24);
  GPU::BaseOpHandler::~BaseOpHandler(v20);
  _Unwind_Resume(a1);
}

unint64_t GPU::PermuteOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4 == 1)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, 1u);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, a4);
}

void GPU::PermuteOpHandler::encodeOp(GPU::PermuteOpHandler *this, void **a2)
{
  uint64_t v4;
  void *v5;
  void *Result;
  void *Input;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  id v14;
  uint64_t v15;
  id v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  void *Filter;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t **StaticType;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t ArgAttrsAttr;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  int64x2_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  int64x2_t *v45;
  int64x2_t v46;
  uint64_t v47;
  int64x2_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t **v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  void *v65;
  void *v66;
  void *v67;
  _QWORD *v68;
  void *v69;
  _QWORD *AttrData;
  uint64_t v71;
  uint64_t *__p;
  id v74;
  id v75;
  void *v76;
  uint64_t v77;
  id v78[4];
  __int16 v79;
  uint64_t v80[4];
  __int16 v81;
  void *v82[2];
  _OWORD v83[7];
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  GPU::BaseOpHandler::_inferJITOutputTypes((uint64_t)this, (GPU::EncodeDescriptor *)a2);
  v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v82[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v82);
    if (v71 == 11 && *AttrData == 0x6D7265702E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6574756D7265702ELL)
    {
      v81 = 1283;
      v80[0] = (uint64_t)"classof on '";
      v80[2] = (uint64_t)"mps.permute";
      v80[3] = 11;
      v78[0] = "' failed due to the operation not being registered";
      v79 = 259;
      llvm::operator+(v80, (uint64_t *)v78, (uint64_t)v82);
      llvm::report_fatal_error((llvm::Twine *)v82, 1);
    }
LABEL_80:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
    goto LABEL_80;
  v77 = *((_QWORD *)this + 3);
  Result = (void *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v77);
  Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v77);
  v8 = *((_QWORD *)this + 2);
  v82[0] = Result;
  v80[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)v82) + 2);
  v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v8 + 88), v80);
  if (v9
    && (v78[0] = v82[0],
        (v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, (uint64_t *)v78)) != 0))
  {
    v75 = (id)v10[3];
  }
  else
  {
    v75 = 0;
  }
  v11 = *((_QWORD *)this + 2);
  v82[0] = Input;
  v80[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)v82) + 2);
  v12 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v11 + 88), v80);
  if (v12
    && (v78[0] = v82[0],
        (v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v12 + 3, (uint64_t *)v78)) != 0))
  {
    v14 = (id)v13[3];
  }
  else
  {
    v14 = 0;
  }
  objc_msgSend(v14, "mpsndarray");
  v15 = objc_claimAutoreleasedReturnValue();
  v16 = *((id *)this + 1);
  v78[0] = v16;
  v76 = (void *)v15;
  if (!v15 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  v17 = (uint64_t *)*((_QWORD *)this + 15);
  v18 = (uint64_t *)*((_QWORD *)this + 16);
  v74 = v14;
  if (v17 == v18)
  {
    v21 = *((_QWORD *)this + 2);
    Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v77);
    GPURegionRuntime::waitAndReadIntTensorData(v21, (uint64_t)a2, Filter, (uint64_t)v82);
    v20 = (uint64_t *)v82[0];
    v19 = (uint64_t *)v82[1];
    v17 = (uint64_t *)*((_QWORD *)this + 15);
    v18 = (uint64_t *)*((_QWORD *)this + 16);
  }
  else
  {
    v19 = 0;
    v20 = 0;
  }
  __p = v20;
  if (v17 == v18)
    v23 = v20;
  else
    v23 = v17;
  if (v17 == v18)
    v24 = v19;
  else
    v24 = v18;
  StaticType = (uint64_t **)GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), (uint64_t)Input);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(StaticType))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_71:
    __assert_rtn(v30, v29, v28, v27);
  }
  if (StaticType)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(StaticType);
    if (!InterfaceFor)
    {
      v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v28 = 98;
      v29 = "InterfaceSupport.h";
      v30 = "Interface";
      goto LABEL_71;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v80[0] = (uint64_t)StaticType;
  v80[1] = InterfaceFor;
  v82[0] = v83;
  v82[1] = (void *)0x400000000;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v80) & 1) == 0)
    __assert_rtn("getRank", "BuiltinTypeInterfaces.h.inc", 156, "(*this).hasRank() && \"cannot query rank of unranked shaped type\"");
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v80);
  if (mlir::getPositiveAxes(v23, v24 - v23, v31, (uint64_t)v82, 0, 0, 0))
  {
    v32 = (uint64_t *)v82[0];
    v33 = LODWORD(v82[1]);
    ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v80);
    if ((_DWORD)v33)
    {
      v35 = 0;
      v36 = 0;
      v37 = 0;
      v38 = &v32[v33];
      v39 = vdupq_n_s64(1uLL);
      while (1)
      {
        while (1)
        {
          if (*v32 > v36)
            v36 = *v32;
          if (v37 == v36)
            break;
          ++v37;
          if (++v32 == v38)
            goto LABEL_46;
        }
        v40 = ArgAttrsAttr + 8 * v35;
        v41 = ArgAttrsAttr + 8 * v37;
        if (v40 != v41 + 8)
          break;
LABEL_45:
        v36 = ++v37;
        v35 = v37;
        if (++v32 == v38)
          goto LABEL_46;
      }
      v42 = (v37 - v35) & 0x1FFFFFFFFFFFFFFFLL;
      if (v42 >= 3)
      {
        v44 = v42 + 1;
        v40 += 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
        v45 = (int64x2_t *)(ArgAttrsAttr + 16 + 8 * v35);
        v46 = 0uLL;
        v47 = v44 & 0x3FFFFFFFFFFFFFFCLL;
        v48 = 0uLL;
        do
        {
          v46 = vsubq_s64(v46, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v45[-1], v39)));
          v48 = vsubq_s64(v48, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v45, v39)));
          v45 += 2;
          v47 -= 4;
        }
        while (v47);
        v43 = vaddvq_s64(vaddq_s64(v48, v46));
        if (v44 == (v44 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_44;
      }
      else
      {
        v43 = 0;
      }
      v49 = v40 - 8;
      do
      {
        v50 = *(_QWORD *)(v49 + 8);
        v49 += 8;
        if (v50 != 1)
          ++v43;
      }
      while (v49 != v41);
LABEL_44:
      if (v43 > 1)
        goto LABEL_48;
      goto LABEL_45;
    }
LABEL_46:
    v51 = (_QWORD *)*((_QWORD *)this + 2);
    v52 = (uint64_t **)GPURegionRuntime::getStaticType((uint64_t)v51, (uint64_t)Result);
    getMPSShapeFromMLIR(v52);
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    GPU::encodeReshape((uint64_t *)Result, v51, a2, v16, v76, v53, v75);

    v54 = v14;
    if (v82[0] != v83)
      free(v82[0]);
  }
  else
  {
LABEL_48:
    if (v82[0] != v83)
      free(v82[0]);
    objc_msgSend(v76, "descriptor");
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    v56 = v55;
    v54 = v14;
    if (*((_QWORD *)this + 15) == *((_QWORD *)this + 16))
    {
      objc_msgSend(v55, "numberOfDimensions");
      memset(v83, 0, sizeof(v83));
      *(_OWORD *)v82 = 0u;
      v57 = (char *)v19 - (char *)__p;
      if (v19 != __p)
      {
        v58 = v57 >> 3;
        v59 = (char *)((v57 >> 3) - 1);
        v60 = __p;
        do
        {
          v62 = *v60++;
          v61 = v62;
          if (v62 >= 0)
            v63 = v58;
          else
            v63 = 0;
          v64 = v63 + ~v61;
          if ((v64 < 0 || v64 >= v58) && MTLReportFailureTypeEnabled())
            MTLReportFailure();
          v82[v64] = v59--;
        }
        while (v59 != (char *)-1);
      }
      objc_msgSend(v56, "permuteWithDimensionOrder:", v82);
      v54 = v74;
    }
    else
    {
      objc_msgSend(v55, "permuteWithDimensionOrder:", (char *)this + 144);
    }
    v65 = a2[1];
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v66 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v76, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v65, v66, v56, 0);
    v67 = (void *)objc_claimAutoreleasedReturnValue();

    v68 = (_QWORD *)*((_QWORD *)this + 2);
    GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
    v69 = (void *)objc_claimAutoreleasedReturnValue();
    GPURegionRuntime::copyNDArrayToTarget(v68, v69, a2[1], v78, v67, v75, (uint64_t *)Result, 0);

  }
  if (__p)
    operator delete(__p);

}

void sub_180E46580(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25)
{
  void *v25;

  _Unwind_Resume(a1);
}

id *GPU::TransposeOpHandler::TransposeOpHandler(id *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  GPU::BaseOpHandler *v5;
  id v6;
  void *v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  void *v11;
  uint64_t DefiningOp;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t **v15;
  uint64_t InterfaceFor;
  uint64_t v17;
  void *v18;
  unint64_t SingleInt;
  char v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t v23;
  uint64_t **v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  unint64_t v28;
  char v29;
  const char *v31;
  int v32;
  const char *v33;
  const char *v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  _QWORD *AttrData;
  uint64_t v40;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t v55;
  const char *v56;
  int v57;
  const char *v58;
  const char *v59;
  const char *v60;
  int v61;
  const char *v62;
  const char *v63;
  id v64;
  const char *v65;
  __int16 v66;
  uint64_t v67[4];
  __int16 v68;
  void *v69;
  unint64_t v70;
  _QWORD v71[4];

  v71[3] = *MEMORY[0x1E0C80C00];
  v5 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)this, a2, a3, a4);
  *(_QWORD *)v5 = &off_1E0E1CA30;
  *((_BYTE *)v5 + 120) = 0;
  *((_BYTE *)v5 + 128) = 0;
  *((_BYTE *)v5 + 136) = 0;
  *((_BYTE *)v5 + 144) = 0;
  v6 = objc_alloc(MEMORY[0x1E0CC7030]);
  objc_msgSend(*((id *)this[2] + 6), "metalDevice");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = objc_msgSend(v6, "initWithDevice:", v7);
  v9 = this[1];
  this[1] = (id)v8;

  objc_msgSend(this[1], "setOptions:", objc_msgSend(this[1], "options") | 1);
  v10 = *((_QWORD *)this[3] + 6);
  v11 = *(void **)(v10 + 16);
  if (v11 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v69 = *(void **)(v10 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v69);
    if (v40 == 13 && *AttrData == 0x6E6172742E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x65736F70736E6172)
    {
      v68 = 1283;
      v67[0] = (uint64_t)"classof on '";
      v67[2] = (uint64_t)"mps.transpose";
      v67[3] = 13;
      v65 = "' failed due to the operation not being registered";
      v66 = 259;
      llvm::operator+(v67, (uint64_t *)&v65, (uint64_t)&v69);
      llvm::report_fatal_error((llvm::Twine *)&v69, 1);
    }
LABEL_89:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v11 != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
    goto LABEL_89;
  v64 = this[3];
  v67[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v64);
  if (!v67[0])
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v67);
  if (DefiningOp)
  {
    if ((v13 & 1) != 0
    {
      goto LABEL_6;
    }
    v69 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
    v70 = 84;
    v42 = llvm::StringRef::find((uint64_t *)&v69, "DesiredTypeName = ", 0x12uLL, 0);
    v44 = (char *)v69;
    v43 = v70;
    if (v70 >= v42)
      v45 = v42;
    else
      v45 = v70;
    v46 = v70 - v45;
    v47 = (char *)v69 + v45;
    v69 = (char *)v69 + v45;
    v70 -= v45;
    if (v43 <= v42)
    {
      v56 = "!Name.empty() && \"Unable to find the template parameter!\"";
      v57 = 33;
    }
    else
    {
      if (v46 < 0x12)
      {
        v56 = "size() >= N && \"Dropping more elements than exist\"";
        v57 = 614;
        v58 = "StringRef.h";
        v59 = "drop_front";
        goto LABEL_94;
      }
      v69 = v47 + 18;
      v70 = v46 - 18;
      if (v46 != 18 && v44[v43 - 1] == 93)
      {
        if (v46 - 18 >= v46 - 19)
          v48 = v46 - 19;
        else
          v48 = v46 - 18;
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)(v47 + 18), v48);
LABEL_6:
        if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(DefiningOp + 48) + 32))(*(_QWORD *)(DefiningOp + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id) & 1) == 0)goto LABEL_21;
        v69 = v71;
        v70 = 0x100000000;
        if (!mlir::Operation::fold(DefiningOp, 0, 0, (uint64_t)&v69))
          __assert_rtn("match", "Matchers.h", 92, "succeeded(result) && \"expected ConstantLike op to be foldable\"");
        if ((_DWORD)v70)
        {
          v14 = *(_QWORD *)v69;
          if ((*(_QWORD *)v69 & 4) != 0)
          {
            v31 = "isa<T>(*this) && \"Invalid accessor called\"";
            v32 = 156;
            v33 = "PointerUnion.h";
            v34 = "get";
          }
          else
          {
            v15 = (uint64_t **)(v14 & 0xFFFFFFFFFFFFFFF8);
            if ((v14 & 0xFFFFFFFFFFFFFFF8) != 0)
            {
              if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor((uint64_t **)(v14 & 0xFFFFFFFFFFFFFFF8)))
              {
                v15 = 0;
                v17 = 0;
                v18 = v69;
                if (v69 == v71)
                  goto LABEL_18;
                goto LABEL_17;
              }
              InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v15);
              if (InterfaceFor)
              {
                if (v15)
                  v17 = InterfaceFor;
                else
                  v17 = 0;
                v18 = v69;
                if (v69 == v71)
                {
LABEL_18:
                  if (v15)
                  {
                    SingleInt = mlir::getSingleIntValue<long long>((uint64_t)v15, v17);
                    if (v20)
                    {
                      this[15] = (id)SingleInt;
                      *((_BYTE *)this + 128) = 1;
                    }
                  }
                  goto LABEL_21;
                }
LABEL_17:
                free(v18);
                goto LABEL_18;
              }
              v31 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              v32 = 98;
              v33 = "InterfaceSupport.h";
              v34 = "Interface";
            }
            else
            {
              v31 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              v32 = 650;
              v33 = "Casting.h";
              v34 = "dyn_cast";
            }
          }
        }
        else
        {
          v31 = "!empty()";
          v32 = 303;
          v33 = "SmallVector.h";
          v34 = "front";
        }
        __assert_rtn(v34, v33, v32, v31);
      }
      v56 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
      v57 = 36;
    }
    v58 = "TypeName.h";
    v59 = "getTypeName";
LABEL_94:
    __assert_rtn(v59, v58, v57, v56);
  }
LABEL_21:
  v67[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v64);
  if (!v67[0])
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  v21 = mlir::Value::getDefiningOp((mlir::Value *)v67);
  if (v21)
  {
    if ((v22 & 1) != 0
    {
      goto LABEL_24;
    }
    v69 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
    v70 = 84;
    v49 = llvm::StringRef::find((uint64_t *)&v69, "DesiredTypeName = ", 0x12uLL, 0);
    v51 = (char *)v69;
    v50 = v70;
    if (v70 >= v49)
      v52 = v49;
    else
      v52 = v70;
    v53 = v70 - v52;
    v54 = (char *)v69 + v52;
    v69 = (char *)v69 + v52;
    v70 -= v52;
    if (v50 <= v49)
    {
      v60 = "!Name.empty() && \"Unable to find the template parameter!\"";
      v61 = 33;
    }
    else
    {
      if (v53 < 0x12)
      {
        v60 = "size() >= N && \"Dropping more elements than exist\"";
        v61 = 614;
        v62 = "StringRef.h";
        v63 = "drop_front";
        goto LABEL_99;
      }
      v69 = v54 + 18;
      v70 = v53 - 18;
      if (v53 != 18 && v51[v50 - 1] == 93)
      {
        if (v53 - 18 >= v53 - 19)
          v55 = v53 - 19;
        else
          v55 = v53 - 18;
        mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)(v54 + 18), v55);
LABEL_24:
        if (((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v21 + 48) + 32))(*(_QWORD *)(v21 + 48), mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id) & 1) == 0)return this;
        v69 = v71;
        v70 = 0x100000000;
        if (!mlir::Operation::fold(v21, 0, 0, (uint64_t)&v69))
          __assert_rtn("match", "Matchers.h", 92, "succeeded(result) && \"expected ConstantLike op to be foldable\"");
        if ((_DWORD)v70)
        {
          v23 = *(_QWORD *)v69;
          if ((*(_QWORD *)v69 & 4) != 0)
          {
            v35 = "isa<T>(*this) && \"Invalid accessor called\"";
            v36 = 156;
            v37 = "PointerUnion.h";
            v38 = "get";
          }
          else
          {
            v24 = (uint64_t **)(v23 & 0xFFFFFFFFFFFFFFF8);
            if ((v23 & 0xFFFFFFFFFFFFFFF8) != 0)
            {
              if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor((uint64_t **)(v23 & 0xFFFFFFFFFFFFFFF8)))
              {
                v24 = 0;
                v26 = 0;
                v27 = v69;
                if (v69 == v71)
                  goto LABEL_36;
                goto LABEL_35;
              }
              v25 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24);
              if (v25)
              {
                if (v24)
                  v26 = v25;
                else
                  v26 = 0;
                v27 = v69;
                if (v69 == v71)
                  goto LABEL_36;
LABEL_35:
                free(v27);
LABEL_36:
                if (v24)
                {
                  v28 = mlir::getSingleIntValue<long long>((uint64_t)v24, v26);
                  if (v29)
                  {
                    this[17] = (id)v28;
                    *((_BYTE *)this + 144) = 1;
                  }
                }
                return this;
              }
              v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
              v36 = 98;
              v37 = "InterfaceSupport.h";
              v38 = "Interface";
            }
            else
            {
              v35 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              v36 = 650;
              v37 = "Casting.h";
              v38 = "dyn_cast";
            }
          }
        }
        else
        {
          v35 = "!empty()";
          v36 = 303;
          v37 = "SmallVector.h";
          v38 = "front";
        }
        __assert_rtn(v38, v37, v36, v35);
      }
      v60 = "Name.ends_with(\"]\") && \"Name doesn't end in the substitution key!\"";
      v61 = 36;
    }
    v62 = "TypeName.h";
    v63 = "getTypeName";
LABEL_99:
    __assert_rtn(v63, v62, v61, v60);
  }
  return this;
}

void sub_180E46DB8(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E46DDC(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;
  void *v2;
  void *v3;

  v3 = v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E46DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  GPU::BaseOpHandler *v21;

  GPU::BaseOpHandler::~BaseOpHandler(v21);
  _Unwind_Resume(a1);
}

unint64_t GPU::TransposeOpHandler::getJITStaticOperandRepr(GPU::BaseOpHandler *this, GPU::EncodeDescriptor *a2, mlir::UnknownLoc **a3, unsigned int a4)
{
  if (a4)
    return GPU::BaseOpHandler::_getJITStaticOperandReprConstant(this, a2, a3, a4);
  else
    return GPU::BaseOpHandler::_getJITStaticOperandReprPlaceholder(this, a2, a3, 0);
}

void GPU::TransposeOpHandler::encodeOp(GPU::TransposeOpHandler *this, void **a2)
{
  uint64_t v4;
  void *v5;
  void *Result;
  void *Input;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  id v14;
  uint64_t **StaticType;
  uint64_t InterfaceFor;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t PositiveAxis;
  uint64_t v24;
  void *Filter;
  uint64_t v26;
  uint64_t Axis;
  uint64_t v28;
  void *Bias;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  uint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  char *v40;
  unint64_t v41;
  int64x2_t v42;
  int64x2_t *v43;
  int64x2_t v44;
  int64x2_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t ArgAttrsAttr;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int64x2_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  int64x2_t *v58;
  int64x2_t v59;
  uint64_t v60;
  int64x2_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t **v65;
  void *v66;
  void *v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  void *v72;
  void *v73;
  void *v74;
  _QWORD *v75;
  void *v76;
  _QWORD *AttrData;
  uint64_t v78;
  void *v80;
  id v81;
  void *v82;
  uint64_t v83;
  id v84[4];
  __int16 v85;
  uint64_t v86[4];
  __int16 v87;
  void *v88;
  uint64_t v89;
  _QWORD v90[6];

  v90[4] = *MEMORY[0x1E0C80C00];
  GPU::BaseOpHandler::_inferJITOutputTypes((uint64_t)this, (GPU::EncodeDescriptor *)a2);
  v4 = *(_QWORD *)(*((_QWORD *)this + 3) + 48);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v88 = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v88);
    if (v78 == 13 && *AttrData == 0x6E6172742E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x65736F70736E6172)
    {
      v87 = 1283;
      v86[0] = (uint64_t)"classof on '";
      v86[2] = (uint64_t)"mps.transpose";
      v86[3] = 13;
      v84[0] = "' failed due to the operation not being registered";
      v85 = 259;
      llvm::operator+(v86, (uint64_t *)v84, (uint64_t)&v88);
      llvm::report_fatal_error((llvm::Twine *)&v88, 1);
    }
LABEL_84:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
    goto LABEL_84;
  v83 = *((_QWORD *)this + 3);
  Result = (void *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v83);
  Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v83);
  v8 = *((_QWORD *)this + 2);
  v88 = Result;
  v86[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v88) + 2);
  v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v8 + 88), v86);
  if (v9
    && (v84[0] = v88,
        (v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v9 + 3, (uint64_t *)v84)) != 0))
  {
    v81 = (id)v10[3];
  }
  else
  {
    v81 = 0;
  }
  v11 = *((_QWORD *)this + 2);
  v88 = Input;
  v86[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v88) + 2);
  v12 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((_QWORD *)(v11 + 88), v86);
  if (v12)
  {
    v84[0] = v88;
    v12 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v12 + 3, (uint64_t *)v84);
    if (v12)
      v12 = (id)v12[3];
  }
  objc_msgSend(v12, "mpsndarray", v12);
  v13 = objc_claimAutoreleasedReturnValue();
  v14 = *((id *)this + 1);
  v84[0] = v14;
  v82 = (void *)v13;
  if (!v13 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  StaticType = (uint64_t **)GPURegionRuntime::getStaticType(*((_QWORD *)this + 2), (uint64_t)Input);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(StaticType))
  {
    v17 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v18 = 566;
    v19 = "Casting.h";
    v20 = "cast";
LABEL_73:
    __assert_rtn(v20, v19, v18, v17);
  }
  if (StaticType)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(StaticType);
    if (!InterfaceFor)
    {
      v17 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v18 = 98;
      v19 = "InterfaceSupport.h";
      v20 = "Interface";
      goto LABEL_73;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v86[0] = (uint64_t)StaticType;
  v86[1] = InterfaceFor;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86) & 1) == 0)
    __assert_rtn("getRank", "BuiltinTypeInterfaces.h.inc", 156, "(*this).hasRank() && \"cannot query rank of unranked shaped type\"");
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v86);
  v22 = v21;
  if (*((_BYTE *)this + 128))
  {
    PositiveAxis = mlir::getPositiveAxis(*((_QWORD *)this + 15), v21);
  }
  else
  {
    v24 = *((_QWORD *)this + 2);
    Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v83);
    PositiveAxis = RuntimeUtils::getAxis(v24, (uint64_t)a2, Filter, v22);
  }
  v26 = PositiveAxis;
  if (*((_BYTE *)this + 144))
  {
    Axis = mlir::getPositiveAxis(*((_QWORD *)this + 17), v22);
  }
  else
  {
    v28 = *((_QWORD *)this + 2);
    Bias = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v83);
    Axis = RuntimeUtils::getAxis(v28, (uint64_t)a2, Bias, v22);
  }
  v30 = Axis;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86) & 1) == 0)
    __assert_rtn("getRank", "BuiltinTypeInterfaces.h.inc", 156, "(*this).hasRank() && \"cannot query rank of unranked shaped type\"");
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v86);
  v32 = v31;
  v88 = v90;
  v89 = 0x400000000;
  if (!v31)
  {
    v35 = 0;
    v36 = (char *)v90;
    v37 = v90;
    goto LABEL_38;
  }
  if (v31 < 5)
  {
    v33 = 0;
    v34 = v31;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v90, v31, 8);
    v33 = v89;
    v34 = v32 - v89;
    if (v32 == v89)
      goto LABEL_31;
  }
  bzero((char *)v88 + 8 * v33, 8 * v34);
LABEL_31:
  if (v32 > HIDWORD(v89))
    __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
  LODWORD(v89) = v32;
  v37 = (uint64_t *)v88;
  v35 = v32;
  v36 = (char *)v88 + 8 * v32;
  v38 = (v35 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v38 >= 3)
  {
    v41 = v38 + 1;
    v39 = (v38 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    v40 = (char *)v88 + 8 * v39;
    v42 = (int64x2_t)xmmword_181233120;
    v43 = (int64x2_t *)((char *)v88 + 16);
    v44 = vdupq_n_s64(2uLL);
    v45 = vdupq_n_s64(4uLL);
    v46 = v39;
    do
    {
      v43[-1] = v42;
      *v43 = vaddq_s64(v42, v44);
      v42 = vaddq_s64(v42, v45);
      v43 += 2;
      v46 -= 4;
    }
    while (v46);
    if (v41 == v39)
      goto LABEL_38;
  }
  else
  {
    v39 = 0;
    v40 = (char *)v88;
  }
  do
  {
    *(_QWORD *)v40 = v39;
    v40 += 8;
    ++v39;
  }
  while (v40 != v36);
LABEL_38:
  if (v26 >= v35 || v30 >= v35)
    __assert_rtn("operator[]", "SmallVector.h", 294, "idx < size()");
  v47 = v37[v26];
  v37[v26] = v37[v30];
  v37[v30] = v47;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v86);
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v52 = vdupq_n_s64(1uLL);
  while (1)
  {
    while (1)
    {
      if (*v37 > v50)
        v50 = *v37;
      if (v51 == v50)
        break;
      ++v51;
      if (++v37 == (uint64_t *)v36)
        goto LABEL_57;
    }
    v53 = ArgAttrsAttr + 8 * v49;
    v54 = ArgAttrsAttr + 8 * v51;
    if (v53 != v54 + 8)
      break;
LABEL_56:
    v50 = ++v51;
    v49 = v51;
    if (++v37 == (uint64_t *)v36)
    {
LABEL_57:
      v64 = (_QWORD *)*((_QWORD *)this + 2);
      v65 = (uint64_t **)GPURegionRuntime::getStaticType((uint64_t)v64, (uint64_t)Result);
      getMPSShapeFromMLIR(v65);
      v66 = (void *)objc_claimAutoreleasedReturnValue();
      GPU::encodeReshape((uint64_t *)Result, v64, a2, v14, v82, v66, v81);

      if (v88 != v90)
        free(v88);
      goto LABEL_68;
    }
  }
  v55 = (v51 - v49) & 0x1FFFFFFFFFFFFFFFLL;
  if (v55 >= 3)
  {
    v57 = v55 + 1;
    v53 += 8 * (v57 & 0x3FFFFFFFFFFFFFFCLL);
    v58 = (int64x2_t *)(ArgAttrsAttr + 16 + 8 * v49);
    v59 = 0uLL;
    v60 = v57 & 0x3FFFFFFFFFFFFFFCLL;
    v61 = 0uLL;
    do
    {
      v59 = vsubq_s64(v59, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v58[-1], v52)));
      v61 = vsubq_s64(v61, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v58, v52)));
      v58 += 2;
      v60 -= 4;
    }
    while (v60);
    v56 = vaddvq_s64(vaddq_s64(v61, v59));
    if (v57 == (v57 & 0x3FFFFFFFFFFFFFFCLL))
      goto LABEL_55;
  }
  else
  {
    v56 = 0;
  }
  v62 = v53 - 8;
  do
  {
    v63 = *(_QWORD *)(v62 + 8);
    v62 += 8;
    if (v63 != 1)
      ++v56;
  }
  while (v62 != v54);
LABEL_55:
  if (v56 <= 1)
    goto LABEL_56;
  if (v88 != v90)
    free(v88);
  objc_msgSend(v82, "descriptor");
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  v68 = v67;
  if (v30 >= 0)
    v69 = v22;
  else
    v69 = 0;
  v70 = v69 + ~v30;
  if (v26 >= 0)
    v71 = v22;
  else
    v71 = 0;
  objc_msgSend(v67, "transposeDimension:withDimension:", v71 + ~v26, v70);
  v72 = a2[1];
  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v82, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v72, v73, v68, 0);
  v74 = (void *)objc_claimAutoreleasedReturnValue();

  v75 = (_QWORD *)*((_QWORD *)this + 2);
  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v76 = (void *)objc_claimAutoreleasedReturnValue();
  GPURegionRuntime::copyNDArrayToTarget(v75, v76, a2[1], v84, v74, v81, (uint64_t *)Result, 0);

  v14 = v84[0];
LABEL_68:

}

void sub_180E475FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  void *v23;

  _Unwind_Resume(a1);
}

void GPU::PermuteOpHandler::~PermuteOpHandler(GPU::PermuteOpHandler *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E0E1BF70;
  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  GPU::BaseOpHandler::~BaseOpHandler(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E0E1BF70;
  v2 = (void *)*((_QWORD *)this + 15);
  if (v2)
  {
    *((_QWORD *)this + 16) = v2;
    operator delete(v2);
  }
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void GPU::TransposeOpHandler::~TransposeOpHandler(GPU::TransposeOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

id *GPU::ReinterpretCastOpHandler::ReinterpretCastOpHandler(id *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  id v5;
  void *v6;
  uint64_t v7;
  id v8;

  *(_QWORD *)GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)this, a2, a3, a4) = &off_1E0E1ECF0;
  v5 = objc_alloc(MEMORY[0x1E0CC7030]);
  objc_msgSend(*((id *)this[2] + 6), "metalDevice");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v5, "initWithDevice:", v6);
  v8 = this[1];
  this[1] = (id)v7;

  objc_msgSend(this[1], "setOptions:", objc_msgSend(this[1], "options") | 1);
  return this;
}

void sub_180E47810(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;
  void *v2;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void sub_180E47828(_Unwind_Exception *a1)
{
  GPU::BaseOpHandler *v1;

  GPU::BaseOpHandler::~BaseOpHandler(v1);
  _Unwind_Resume(a1);
}

void GPU::ReinterpretCastOpHandler::encodeOp(id *this, void **a2)
{
  uint64_t v4;
  void *v5;
  uint64_t Input;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  void *v13;
  void *v14;
  char *v15;
  uint64_t v16;
  void *v17;
  unsigned int v18;
  unsigned int v19;
  int *v20;
  BOOL v21;
  int v22;
  BOOL v23;
  int *v24;
  char *v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  char *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  unsigned int v45;
  uint64_t v46;
  _QWORD *v47;
  void *v48;
  uint64_t AttrData;
  uint64_t v50;
  BOOL v51;
  _QWORD v53[2];
  id v54;
  int MPSDataType;
  uint64_t *Result;
  id *v57;
  char *v58;
  id v59;
  id v60;
  char *v61;
  __int128 v62;
  _OWORD v63[4];
  id v64;
  id v65;
  uint64_t v66[4];
  __int16 v67;
  uint64_t v68[4];
  __int16 v69;
  uint64_t *v70;
  _QWORD v71[2];

  v71[1] = *MEMORY[0x1E0C80C00];
  GPU::BaseOpHandler::_inferJITOutputTypes((uint64_t)this, (GPU::EncodeDescriptor *)a2);
  v54 = this[1];
  v65 = v54;
  v57 = this;
  v4 = *((_QWORD *)this[3] + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v70 = *(uint64_t **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v70);
    if (v50 == 20)
    {
      v51 = *(_QWORD *)AttrData == 0x6E6965722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x5F74657270726574;
      if (v51 && *(_DWORD *)(AttrData + 16) == 1953718627)
      {
        v69 = 1283;
        v68[0] = (uint64_t)"classof on '";
        v68[2] = (uint64_t)"mps.reinterpret_cast";
        v68[3] = 20;
        v66[0] = (uint64_t)"' failed due to the operation not being registered";
        v67 = 259;
        llvm::operator+(v68, v66, (uint64_t)&v70);
        llvm::report_fatal_error((llvm::Twine *)&v70, 1);
      }
    }
LABEL_60:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReinterpretCastOp,void>::id)
    goto LABEL_60;
  v64 = this[3];
  Result = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v64);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v64);
  MPSDataType = getMPSDataType((_QWORD *)(Result[1] & 0xFFFFFFFFFFFFFFF8));
  v7 = v57[2];
  v70 = Result;
  v68[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v70) + 2);
  v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v7 + 11, v68);
  if (v8
    && (v66[0] = (uint64_t)v70,
        (v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v8 + 3, v66)) != 0))
  {
    v60 = (id)v9[3];
  }
  else
  {
    v60 = 0;
  }
  v10 = v57[2];
  v70 = (uint64_t *)Input;
  v68[0] = *((_QWORD *)mlir::Value::getParentRegion((mlir::Value *)&v70) + 2);
  v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 11, v68);
  if (v11)
  {
    v66[0] = (uint64_t)v70;
    v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v11 + 3, v66);
    if (v11)
      v11 = (id)v11[3];
  }
  v59 = v11;
  objc_msgSend(v11, "dataType");
  if (objc_msgSend(v59, "dataType") == -2147483640 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  objc_msgSend(v60, "dataType");
  if (objc_msgSend(v60, "dataType") == -2147483640 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  objc_msgSend(v59, "mpsndarray");
  v61 = (char *)objc_claimAutoreleasedReturnValue();
  if (!v61 && MTLReportFailureTypeEnabled())
    MTLReportFailure();
  objc_msgSend(v59, "mpsndarray");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "descriptor");
  v58 = (char *)objc_claimAutoreleasedReturnValue();

  v13 = a2[1];
  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v61, "safeArrayViewWithCommandBuffer:computeEncoder:descriptor:aliasing:", v13, v14, v58, 1);
  v15 = (char *)objc_claimAutoreleasedReturnValue();

  if (!v15)
  {
    (*(void (**)(id, uint64_t *, void *, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v57[2] + 80))(v57[2], Result, a2[1], 0, 0, 1);
    v17 = (void *)objc_claimAutoreleasedReturnValue();

    v60 = v17;
  }
  v18 = (unsigned __int16)*(_DWORD *)&v58[*MEMORY[0x1E0CC72A0]] >> 3;
  v19 = (unsigned __int16)MPSDataType >> 3;
  v20 = (int *)MEMORY[0x1E0CC7268];
  if (!v15)
    goto LABEL_33;
  if (v18 >= v19)
  {
    if (*(_OWORD *)&v58[*MEMORY[0x1E0CC72B0]])
      v23 = v18 == v19;
    else
      v23 = 1;
    v22 = !v23;
  }
  else
  {
    if (*(_OWORD *)&v58[*MEMORY[0x1E0CC72B0]])
      v21 = v18 == v19;
    else
      v21 = 1;
    v22 = !v21;
    if (*(_DWORD *)&v61[4 * (*(_OWORD *)&v58[*MEMORY[0x1E0CC72B0]] & 0xF) + (int)*MEMORY[0x1E0CC7298]] % v19)
      goto LABEL_33;
  }
  if (!v22)
  {
    v24 = (int *)MEMORY[0x1E0CC7258];
    v25 = v15;
    goto LABEL_37;
  }
LABEL_33:
  v53[1] = v53;
  MEMORY[0x1E0C80A78](v16);
  v29 = (char *)v53 - v28;
  if (v26)
  {
    v30 = 0;
    v31 = &v61[*MEMORY[0x1E0CC7290]];
    v33 = *((_OWORD *)v31 + 2);
    v32 = *((_OWORD *)v31 + 3);
    v35 = *(_OWORD *)v31;
    v34 = *((_OWORD *)v31 + 1);
    v36 = *(_OWORD *)&v61[*v20];
    do
    {
      v62 = v36;
      v63[0] = v35;
      v63[1] = v34;
      v63[2] = v33;
      v63[3] = v32;
      *(_QWORD *)&v29[8 * v30] = *((unsigned int *)v63 + (*(_BYTE *)((unint64_t)&v62 | v30 & 0xF) & 0xF));
      ++v30;
    }
    while (v26 != v30);
  }
  v24 = v27;
  objc_msgSend(MEMORY[0x1E0CC6FE0], "descriptorWithDataType:dimensionCount:dimensionSizes:", *(unsigned int *)&v61[*v27]);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CC7240], "temporaryNDArrayWithCommandBuffer:descriptor:", a2[1], v37);
  v25 = (char *)objc_claimAutoreleasedReturnValue();

  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = a2[1];
  v71[0] = v61;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v71, 1);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v54, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:destinationArray:", v38, v39, v40, v25);

  if (!v25)
    __assert_rtn("encodeOp", "GPUReinterpretCastOps.mm", 93, "reinterpretedNDArray");
LABEL_37:
  *(_DWORD *)&v25[*v24] = MPSDataType;
  v41 = *(_OWORD *)&v25[*v20];
  if (v18 > v19)
  {
    v42 = 4 * (v41 & 0xF);
    v43 = 4 * *(_OWORD *)&v25[*v20];
    *(_DWORD *)&v25[(int)*MEMORY[0x1E0CC7260] + v43] = *(_DWORD *)&v25[(int)*MEMORY[0x1E0CC7260] + v42] * (v18 / v19);
    *(_DWORD *)&v25[(int)*MEMORY[0x1E0CC7290] + v43] = *(_DWORD *)&v25[(int)*MEMORY[0x1E0CC7290] + v42] * (v18 / v19);
    v44 = &v25[*MEMORY[0x1E0CC7298]];
    v45 = *(_DWORD *)&v44[v42] * (v18 / v19);
LABEL_41:
    *(_DWORD *)&v44[v43] = v45;
    goto LABEL_42;
  }
  if (v18 < v19)
  {
    v46 = 4 * (v41 & 0xF);
    v43 = 4 * *(_OWORD *)&v25[*v20];
    *(_DWORD *)&v25[(int)*MEMORY[0x1E0CC7260] + v43] = *(_DWORD *)&v25[(int)*MEMORY[0x1E0CC7260] + v46] / (v19 / v18);
    *(_DWORD *)&v25[(int)*MEMORY[0x1E0CC7290] + v43] = *(_DWORD *)&v25[(int)*MEMORY[0x1E0CC7290] + v46] / (v19 / v18);
    v44 = &v25[*MEMORY[0x1E0CC7298]];
    v45 = *(_DWORD *)&v44[v46] / (v19 / v18);
    goto LABEL_41;
  }
LABEL_42:
  objc_msgSend(v25, "updateStrides");
  v47 = v57[2];
  GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  GPURegionRuntime::copyNDArrayToTarget(v47, v48, a2[1], &v65, v25, v60, Result, 0);

}

void sub_180E4804C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 384) = *(_QWORD *)(v1 - 232);
  _Unwind_Resume(a1);
}

void GPU::ReinterpretCastOpHandler::~ReinterpretCastOpHandler(GPU::ReinterpretCastOpHandler *this)
{
  GPU::BaseOpHandler::~BaseOpHandler(this);
  JUMPOUT(0x186DA1680);
}

void lowerMILProgram(mlir::MLIRContext *a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, _QWORD *a4@<X8>)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[168];
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;

  v14 = 0;
  v15 = 0;
  v16 = 0;
  fillMILToMLIRRewritePatterns(&v14);
  MILToMLIRRewriter::MILToMLIRRewriter((uint64_t)v13, a1, a2, &v14, a3);
  MILToMLIRRewriter::rewrite((MILToMLIRRewriter *)v13, a4);
  MILToMLIRRewriter::~MILToMLIRRewriter((MILToMLIRRewriter *)v13);
  v8 = v14;
  if (v14)
  {
    v9 = v15;
    v10 = v14;
    if (v15 != v14)
    {
      do
      {
        v12 = *--v9;
        v11 = v12;
        *v9 = 0;
        if (v12)
          (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
      }
      while (v9 != v8);
      v10 = v14;
    }
    v15 = v8;
    operator delete(v10);
  }
}

void sub_180E48254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MILToMLIRRewriter::~MILToMLIRRewriter((MILToMLIRRewriter *)&a9);
  std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((_QWORD *)(v9 - 56));
  _Unwind_Resume(a1);
}

void sub_180E48270(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((_QWORD *)(v1 - 56));
  _Unwind_Resume(a1);
}

void sub_180E48284(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((_QWORD *)(v1 - 56));
  _Unwind_Resume(a1);
}

void fillMILToMLIRRewritePatterns(uint64_t **a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  uint64_t *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  char *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t *v42;
  uint64_t *v43;
  char *v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t *v49;
  char *v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  uint64_t *v70;
  uint64_t *v71;
  char *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t *v77;
  char *v78;
  uint64_t v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  char *v97;
  uint64_t *v98;
  uint64_t *v99;
  char *v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t *v105;
  char *v106;
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t *v117;
  uint64_t v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  char *v125;
  uint64_t *v126;
  uint64_t *v127;
  char *v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t *v133;
  char *v134;
  uint64_t v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;
  uint64_t *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t *v145;
  uint64_t v146;
  uint64_t *v147;
  uint64_t v148;
  uint64_t v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  char *v153;
  uint64_t *v154;
  uint64_t *v155;
  char *v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t *v160;
  uint64_t *v161;
  char *v162;
  uint64_t v163;
  __int128 v164;
  __int128 v165;
  uint64_t v166;
  uint64_t *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  uint64_t *v173;
  uint64_t v174;
  uint64_t *v175;
  uint64_t v176;
  uint64_t v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  char *v181;
  uint64_t *v182;
  uint64_t *v183;
  char *v184;
  unint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t *v188;
  uint64_t *v189;
  char *v190;
  uint64_t v191;
  __int128 v192;
  __int128 v193;
  uint64_t v194;
  uint64_t *v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  unint64_t v200;
  uint64_t *v201;
  uint64_t v202;
  uint64_t *v203;
  uint64_t v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  unint64_t v208;
  char *v209;
  uint64_t *v210;
  uint64_t *v211;
  char *v212;
  unint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t *v216;
  uint64_t *v217;
  char *v218;
  uint64_t v219;
  __int128 v220;
  __int128 v221;
  uint64_t v222;
  uint64_t *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  unint64_t v228;
  uint64_t *v229;
  uint64_t v230;
  uint64_t *v231;
  uint64_t v232;
  uint64_t v233;
  unint64_t v234;
  uint64_t v235;
  unint64_t v236;
  char *v237;
  uint64_t *v238;
  uint64_t *v239;
  char *v240;
  unint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t *v244;
  uint64_t *v245;
  char *v246;
  uint64_t v247;
  __int128 v248;
  __int128 v249;
  uint64_t v250;
  uint64_t *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  unint64_t v256;
  uint64_t *v257;
  uint64_t v258;
  uint64_t *v259;
  uint64_t v260;
  uint64_t v261;
  unint64_t v262;
  uint64_t v263;
  unint64_t v264;
  char *v265;
  uint64_t *v266;
  uint64_t *v267;
  char *v268;
  unint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t *v272;
  uint64_t *v273;
  char *v274;
  uint64_t v275;
  __int128 v276;
  __int128 v277;
  uint64_t v278;
  uint64_t *v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  uint64_t *v285;
  uint64_t v286;
  uint64_t *v287;
  uint64_t v288;
  uint64_t v289;
  unint64_t v290;
  uint64_t v291;
  unint64_t v292;
  char *v293;
  uint64_t *v294;
  uint64_t *v295;
  char *v296;
  unint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t *v300;
  uint64_t *v301;
  char *v302;
  uint64_t v303;
  __int128 v304;
  __int128 v305;
  uint64_t v306;
  uint64_t *v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  unint64_t v312;
  uint64_t *v313;
  uint64_t v314;
  uint64_t *v315;
  uint64_t v316;
  uint64_t v317;
  unint64_t v318;
  uint64_t v319;
  unint64_t v320;
  char *v321;
  uint64_t *v322;
  uint64_t *v323;
  char *v324;
  unint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t *v328;
  uint64_t *v329;
  char *v330;
  uint64_t v331;
  __int128 v332;
  __int128 v333;
  uint64_t v334;
  uint64_t *v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  unint64_t v340;
  uint64_t *v341;
  uint64_t v342;
  uint64_t *v343;
  uint64_t v344;
  uint64_t v345;
  unint64_t v346;
  uint64_t v347;
  unint64_t v348;
  char *v349;
  uint64_t *v350;
  uint64_t *v351;
  char *v352;
  unint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t *v356;
  uint64_t *v357;
  char *v358;
  uint64_t v359;
  __int128 v360;
  __int128 v361;
  uint64_t v362;
  uint64_t *v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  unint64_t v368;
  uint64_t *v369;
  uint64_t v370;
  uint64_t *v371;
  uint64_t v372;
  uint64_t v373;
  unint64_t v374;
  uint64_t v375;
  unint64_t v376;
  char *v377;
  uint64_t *v378;
  uint64_t *v379;
  char *v380;
  unint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t *v384;
  uint64_t *v385;
  char *v386;
  uint64_t v387;
  __int128 v388;
  __int128 v389;
  uint64_t v390;
  uint64_t *v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  unint64_t v396;
  uint64_t *v397;
  uint64_t v398;
  uint64_t *v399;
  uint64_t v400;
  uint64_t v401;
  unint64_t v402;
  uint64_t v403;
  unint64_t v404;
  char *v405;
  uint64_t *v406;
  uint64_t *v407;
  char *v408;
  unint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t *v412;
  uint64_t *v413;
  char *v414;
  uint64_t v415;
  __int128 v416;
  __int128 v417;
  uint64_t v418;
  uint64_t *v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  unint64_t v424;
  uint64_t *v425;
  uint64_t v426;
  uint64_t *v427;
  uint64_t v428;
  uint64_t v429;
  unint64_t v430;
  uint64_t v431;
  unint64_t v432;
  char *v433;
  uint64_t *v434;
  uint64_t *v435;
  char *v436;
  unint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t *v440;
  uint64_t *v441;
  char *v442;
  uint64_t v443;
  __int128 v444;
  __int128 v445;
  uint64_t v446;
  uint64_t *v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t *v451;
  uint64_t *v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t *v455;
  uint64_t *v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t *v459;
  uint64_t *v460;
  uint64_t v461;
  uint64_t v462;
  char *v463;
  uint64_t *v464;
  uint64_t *v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t *v468;
  uint64_t *v469;
  uint64_t v470;
  uint64_t v471;
  char *v472;
  uint64_t *v473;
  uint64_t *v474;
  uint64_t v475;
  uint64_t v476;
  char *v477;
  uint64_t *v478;
  uint64_t *v479;
  uint64_t v480;
  uint64_t v481;
  char *v482;
  uint64_t *v483;
  uint64_t *v484;
  uint64_t v485;
  uint64_t v486;
  char *v487;
  uint64_t *v488;
  uint64_t *v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  unint64_t v493;
  uint64_t *v494;
  uint64_t v495;
  uint64_t *v496;
  uint64_t v497;
  uint64_t v498;
  unint64_t v499;
  uint64_t v500;
  unint64_t v501;
  char *v502;
  uint64_t *v503;
  uint64_t *v504;
  char *v505;
  unint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t *v509;
  uint64_t *v510;
  char *v511;
  uint64_t v512;
  __int128 v513;
  __int128 v514;
  uint64_t v515;
  uint64_t *v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  unint64_t v521;
  uint64_t *v522;
  uint64_t v523;
  uint64_t *v524;
  uint64_t v525;
  uint64_t v526;
  unint64_t v527;
  uint64_t v528;
  unint64_t v529;
  char *v530;
  uint64_t *v531;
  uint64_t *v532;
  char *v533;
  unint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t *v537;
  uint64_t *v538;
  char *v539;
  uint64_t v540;
  __int128 v541;
  __int128 v542;
  uint64_t v543;
  uint64_t *v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t v548;
  unint64_t v549;
  uint64_t *v550;
  uint64_t v551;
  uint64_t *v552;
  uint64_t v553;
  uint64_t v554;
  unint64_t v555;
  uint64_t v556;
  unint64_t v557;
  char *v558;
  uint64_t *v559;
  uint64_t *v560;
  char *v561;
  unint64_t v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t *v565;
  uint64_t *v566;
  char *v567;
  uint64_t v568;
  __int128 v569;
  __int128 v570;
  uint64_t v571;
  uint64_t *v572;
  uint64_t v573;
  uint64_t v574;
  uint64_t v575;
  uint64_t v576;
  unint64_t v577;
  uint64_t *v578;
  uint64_t v579;
  uint64_t *v580;
  uint64_t v581;
  uint64_t v582;
  unint64_t v583;
  uint64_t v584;
  unint64_t v585;
  char *v586;
  uint64_t *v587;
  uint64_t *v588;
  char *v589;
  unint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t *v593;
  uint64_t *v594;
  char *v595;
  uint64_t v596;
  __int128 v597;
  __int128 v598;
  uint64_t v599;
  uint64_t *v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  unint64_t v605;
  uint64_t *v606;
  uint64_t v607;
  uint64_t *v608;
  uint64_t v609;
  uint64_t v610;
  unint64_t v611;
  uint64_t v612;
  unint64_t v613;
  char *v614;
  uint64_t *v615;
  uint64_t *v616;
  char *v617;
  unint64_t v618;
  uint64_t v619;
  uint64_t v620;
  uint64_t *v621;
  uint64_t *v622;
  char *v623;
  uint64_t v624;
  __int128 v625;
  __int128 v626;
  uint64_t v627;
  uint64_t *v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  uint64_t v632;
  unint64_t v633;
  uint64_t *v634;
  uint64_t v635;
  uint64_t *v636;
  uint64_t v637;
  uint64_t v638;
  unint64_t v639;
  uint64_t v640;
  unint64_t v641;
  char *v642;
  uint64_t *v643;
  uint64_t *v644;
  char *v645;
  unint64_t v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t *v649;
  uint64_t *v650;
  char *v651;
  uint64_t v652;
  __int128 v653;
  __int128 v654;
  uint64_t v655;
  uint64_t *v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  uint64_t v660;
  unint64_t v661;
  uint64_t *v662;
  uint64_t v663;
  uint64_t *v664;
  uint64_t v665;
  uint64_t v666;
  unint64_t v667;
  uint64_t v668;
  unint64_t v669;
  char *v670;
  uint64_t *v671;
  uint64_t *v672;
  char *v673;
  unint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t *v677;
  uint64_t *v678;
  char *v679;
  uint64_t v680;
  __int128 v681;
  __int128 v682;
  uint64_t v683;
  uint64_t *v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  unint64_t v689;
  uint64_t *v690;
  uint64_t v691;
  uint64_t *v692;
  uint64_t v693;
  uint64_t v694;
  unint64_t v695;
  uint64_t v696;
  unint64_t v697;
  char *v698;
  uint64_t *v699;
  uint64_t *v700;
  char *v701;
  unint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t *v705;
  uint64_t *v706;
  char *v707;
  uint64_t v708;
  __int128 v709;
  __int128 v710;
  uint64_t v711;
  uint64_t *v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  unint64_t v717;
  uint64_t *v718;
  uint64_t v719;
  uint64_t *v720;
  uint64_t v721;
  uint64_t v722;
  unint64_t v723;
  uint64_t v724;
  unint64_t v725;
  char *v726;
  uint64_t *v727;
  uint64_t *v728;
  char *v729;
  unint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t *v733;
  uint64_t *v734;
  char *v735;
  uint64_t v736;
  __int128 v737;
  __int128 v738;
  uint64_t v739;
  uint64_t *v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t *v743;
  uint64_t *v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t *v747;
  uint64_t *v748;
  uint64_t v749;
  uint64_t *v750;
  uint64_t *v751;
  uint64_t v752;
  uint64_t v753;
  uint64_t *v754;
  uint64_t *v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t *v758;
  uint64_t *v759;
  uint64_t v760;
  uint64_t v761;
  uint64_t *v762;
  uint64_t *v763;
  uint64_t v764;
  uint64_t v765;
  uint64_t *v766;
  uint64_t *v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t *v770;
  uint64_t *v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t *v774;
  uint64_t *v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t *v778;
  uint64_t *v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  unint64_t v783;
  uint64_t *v784;
  uint64_t v785;
  uint64_t *v786;
  uint64_t v787;
  uint64_t v788;
  unint64_t v789;
  uint64_t v790;
  unint64_t v791;
  char *v792;
  uint64_t *v793;
  uint64_t *v794;
  char *v795;
  unint64_t v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t *v799;
  uint64_t *v800;
  char *v801;
  uint64_t v802;
  __int128 v803;
  __int128 v804;
  uint64_t v805;
  uint64_t *v806;
  uint64_t v807;
  uint64_t v808;
  uint64_t v809;
  uint64_t v810;
  unint64_t v811;
  uint64_t *v812;
  uint64_t v813;
  uint64_t *v814;
  uint64_t v815;
  uint64_t v816;
  unint64_t v817;
  uint64_t v818;
  unint64_t v819;
  char *v820;
  uint64_t *v821;
  uint64_t *v822;
  char *v823;
  unint64_t v824;
  uint64_t v825;
  uint64_t v826;
  uint64_t *v827;
  uint64_t *v828;
  char *v829;
  uint64_t v830;
  __int128 v831;
  __int128 v832;
  uint64_t v833;
  uint64_t *v834;
  uint64_t v835;
  uint64_t v836;
  uint64_t v837;
  uint64_t v838;
  unint64_t v839;
  uint64_t *v840;
  uint64_t v841;
  uint64_t *v842;
  uint64_t v843;
  uint64_t v844;
  unint64_t v845;
  uint64_t v846;
  unint64_t v847;
  char *v848;
  uint64_t *v849;
  uint64_t *v850;
  char *v851;
  unint64_t v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t *v855;
  uint64_t *v856;
  char *v857;
  uint64_t v858;
  __int128 v859;
  __int128 v860;
  uint64_t v861;
  uint64_t *v862;
  uint64_t v863;
  uint64_t v864;
  uint64_t v865;
  uint64_t v866;
  unint64_t v867;
  uint64_t *v868;
  uint64_t v869;
  uint64_t *v870;
  uint64_t v871;
  uint64_t v872;
  unint64_t v873;
  uint64_t v874;
  unint64_t v875;
  char *v876;
  uint64_t *v877;
  uint64_t *v878;
  char *v879;
  unint64_t v880;
  uint64_t v881;
  uint64_t v882;
  uint64_t *v883;
  uint64_t *v884;
  char *v885;
  uint64_t v886;
  __int128 v887;
  __int128 v888;
  uint64_t v889;
  uint64_t *v890;
  uint64_t v891;
  uint64_t v892;
  uint64_t v893;
  uint64_t *v894;
  uint64_t *v895;
  uint64_t v896;
  uint64_t v897;
  char *v898;
  uint64_t *v899;
  uint64_t *v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  unint64_t v904;
  uint64_t *v905;
  uint64_t v906;
  uint64_t *v907;
  uint64_t v908;
  uint64_t v909;
  unint64_t v910;
  uint64_t v911;
  unint64_t v912;
  char *v913;
  uint64_t *v914;
  uint64_t *v915;
  char *v916;
  unint64_t v917;
  uint64_t v918;
  uint64_t v919;
  uint64_t *v920;
  uint64_t *v921;
  char *v922;
  uint64_t v923;
  __int128 v924;
  __int128 v925;
  uint64_t v926;
  uint64_t *v927;
  uint64_t v928;
  uint64_t v929;
  uint64_t v930;
  uint64_t v931;
  unint64_t v932;
  uint64_t *v933;
  uint64_t v934;
  uint64_t *v935;
  uint64_t v936;
  uint64_t v937;
  unint64_t v938;
  uint64_t v939;
  unint64_t v940;
  char *v941;
  uint64_t *v942;
  uint64_t *v943;
  char *v944;
  unint64_t v945;
  uint64_t v946;
  uint64_t v947;
  uint64_t *v948;
  uint64_t *v949;
  char *v950;
  uint64_t v951;
  __int128 v952;
  __int128 v953;
  uint64_t v954;
  uint64_t *v955;
  uint64_t v956;
  uint64_t v957;
  uint64_t v958;
  char *v959;
  unint64_t v960;
  uint64_t *v961;
  uint64_t v962;
  uint64_t *v963;
  uint64_t v964;
  uint64_t v965;
  unint64_t v966;
  uint64_t v967;
  unint64_t v968;
  char *v969;
  uint64_t *v970;
  uint64_t *v971;
  char *v972;
  unint64_t v973;
  uint64_t v974;
  uint64_t v975;
  uint64_t *v976;
  uint64_t *v977;
  char *v978;
  uint64_t v979;
  __int128 v980;
  __int128 v981;
  uint64_t v982;
  uint64_t *v983;
  uint64_t v984;
  uint64_t v985;
  uint64_t v986;
  uint64_t v987;
  unint64_t v988;
  uint64_t *v989;
  uint64_t v990;
  uint64_t *v991;
  uint64_t v992;
  uint64_t v993;
  unint64_t v994;
  uint64_t v995;
  unint64_t v996;
  char *v997;
  uint64_t *v998;
  uint64_t *v999;
  char *v1000;
  unint64_t v1001;
  uint64_t v1002;
  uint64_t v1003;
  uint64_t *v1004;
  uint64_t *v1005;
  char *v1006;
  uint64_t v1007;
  __int128 v1008;
  __int128 v1009;
  uint64_t v1010;
  uint64_t *v1011;
  uint64_t v1012;
  uint64_t v1013;
  uint64_t v1014;
  uint64_t *v1015;
  uint64_t *v1016;
  uint64_t v1017;
  uint64_t v1018;
  uint64_t *v1019;
  uint64_t *v1020;
  uint64_t v1021;
  uint64_t v1022;
  uint64_t v1023;
  unint64_t v1024;
  uint64_t *v1025;
  uint64_t v1026;
  uint64_t *v1027;
  uint64_t v1028;
  uint64_t v1029;
  unint64_t v1030;
  uint64_t v1031;
  unint64_t v1032;
  char *v1033;
  uint64_t *v1034;
  uint64_t *v1035;
  char *v1036;
  unint64_t v1037;
  uint64_t v1038;
  uint64_t v1039;
  uint64_t *v1040;
  uint64_t *v1041;
  char *v1042;
  uint64_t v1043;
  __int128 v1044;
  __int128 v1045;
  uint64_t v1046;
  uint64_t *v1047;
  uint64_t v1048;
  uint64_t v1049;
  uint64_t v1050;
  uint64_t v1051;
  unint64_t v1052;
  uint64_t *v1053;
  uint64_t v1054;
  uint64_t *v1055;
  uint64_t v1056;
  uint64_t v1057;
  unint64_t v1058;
  uint64_t v1059;
  unint64_t v1060;
  char *v1061;
  uint64_t *v1062;
  uint64_t *v1063;
  char *v1064;
  unint64_t v1065;
  uint64_t v1066;
  uint64_t v1067;
  uint64_t *v1068;
  uint64_t *v1069;
  char *v1070;
  uint64_t v1071;
  __int128 v1072;
  __int128 v1073;
  uint64_t v1074;
  uint64_t *v1075;
  uint64_t v1076;
  uint64_t v1077;
  uint64_t v1078;
  uint64_t v1079;
  unint64_t v1080;
  uint64_t *v1081;
  uint64_t v1082;
  uint64_t *v1083;
  uint64_t v1084;
  uint64_t v1085;
  unint64_t v1086;
  uint64_t v1087;
  unint64_t v1088;
  char *v1089;
  uint64_t *v1090;
  uint64_t *v1091;
  char *v1092;
  unint64_t v1093;
  uint64_t v1094;
  uint64_t v1095;
  uint64_t *v1096;
  uint64_t *v1097;
  char *v1098;
  uint64_t v1099;
  __int128 v1100;
  __int128 v1101;
  uint64_t v1102;
  uint64_t *v1103;
  uint64_t v1104;
  uint64_t v1105;
  uint64_t *v1106;
  uint64_t *v1107;
  uint64_t v1108;
  uint64_t *v1109;
  uint64_t *v1110;
  uint64_t v1111;
  uint64_t v1112;
  uint64_t v1113;
  unint64_t v1114;
  uint64_t *v1115;
  uint64_t v1116;
  uint64_t *v1117;
  uint64_t v1118;
  uint64_t v1119;
  unint64_t v1120;
  uint64_t v1121;
  unint64_t v1122;
  char *v1123;
  uint64_t *v1124;
  uint64_t *v1125;
  char *v1126;
  unint64_t v1127;
  uint64_t v1128;
  uint64_t v1129;
  uint64_t *v1130;
  uint64_t *v1131;
  char *v1132;
  uint64_t v1133;
  __int128 v1134;
  __int128 v1135;
  uint64_t v1136;
  uint64_t *v1137;
  uint64_t v1138;
  uint64_t v1139;
  uint64_t v1140;
  uint64_t v1141;
  unint64_t v1142;
  uint64_t *v1143;
  uint64_t v1144;
  uint64_t *v1145;
  uint64_t v1146;
  uint64_t v1147;
  unint64_t v1148;
  uint64_t v1149;
  unint64_t v1150;
  char *v1151;
  uint64_t *v1152;
  uint64_t *v1153;
  char *v1154;
  unint64_t v1155;
  uint64_t v1156;
  uint64_t v1157;
  uint64_t *v1158;
  uint64_t *v1159;
  char *v1160;
  uint64_t v1161;
  __int128 v1162;
  __int128 v1163;
  uint64_t v1164;
  uint64_t *v1165;
  uint64_t v1166;
  uint64_t v1167;
  uint64_t v1168;
  char *v1169;
  unint64_t v1170;
  uint64_t *v1171;
  uint64_t v1172;
  uint64_t *v1173;
  uint64_t v1174;
  uint64_t v1175;
  unint64_t v1176;
  uint64_t v1177;
  unint64_t v1178;
  char *v1179;
  uint64_t *v1180;
  uint64_t *v1181;
  char *v1182;
  unint64_t v1183;
  uint64_t v1184;
  uint64_t v1185;
  uint64_t *v1186;
  uint64_t *v1187;
  char *v1188;
  uint64_t v1189;
  __int128 v1190;
  __int128 v1191;
  uint64_t v1192;
  uint64_t *v1193;
  uint64_t v1194;
  uint64_t v1195;
  uint64_t v1196;
  uint64_t v1197;
  unint64_t v1198;
  uint64_t *v1199;
  uint64_t v1200;
  uint64_t *v1201;
  uint64_t v1202;
  uint64_t v1203;
  unint64_t v1204;
  uint64_t v1205;
  unint64_t v1206;
  char *v1207;
  uint64_t *v1208;
  uint64_t *v1209;
  char *v1210;
  unint64_t v1211;
  uint64_t v1212;
  uint64_t v1213;
  uint64_t *v1214;
  uint64_t *v1215;
  char *v1216;
  uint64_t v1217;
  __int128 v1218;
  __int128 v1219;
  uint64_t v1220;
  uint64_t *v1221;
  uint64_t v1222;
  uint64_t v1223;
  uint64_t v1224;
  uint64_t v1225;
  unint64_t v1226;
  uint64_t *v1227;
  uint64_t v1228;
  uint64_t *v1229;
  uint64_t v1230;
  uint64_t v1231;
  unint64_t v1232;
  uint64_t v1233;
  unint64_t v1234;
  char *v1235;
  uint64_t *v1236;
  uint64_t *v1237;
  char *v1238;
  unint64_t v1239;
  uint64_t v1240;
  uint64_t v1241;
  uint64_t *v1242;
  uint64_t *v1243;
  char *v1244;
  uint64_t v1245;
  __int128 v1246;
  __int128 v1247;
  uint64_t v1248;
  uint64_t *v1249;
  uint64_t v1250;
  uint64_t v1251;
  _anonymous_namespace_::ReducePatternBase *v1252;
  unint64_t v1253;
  _anonymous_namespace_::ReducePatternBase **v1254;
  uint64_t v1255;
  uint64_t *v1256;
  uint64_t v1257;
  uint64_t v1258;
  unint64_t v1259;
  uint64_t v1260;
  unint64_t v1261;
  char *v1262;
  _anonymous_namespace_::ReducePatternBase **v1263;
  uint64_t *v1264;
  char *v1265;
  unint64_t v1266;
  uint64_t v1267;
  uint64_t v1268;
  _anonymous_namespace_::ReducePatternBase **v1269;
  _anonymous_namespace_::ReducePatternBase **v1270;
  char *v1271;
  uint64_t v1272;
  __int128 v1273;
  __int128 v1274;
  _anonymous_namespace_::ReducePatternBase *v1275;
  _anonymous_namespace_::ReducePatternBase **v1276;
  uint64_t v1277;
  uint64_t v1278;
  _anonymous_namespace_::ReducePatternBase *v1279;
  unint64_t v1280;
  _anonymous_namespace_::ReducePatternBase **v1281;
  uint64_t v1282;
  uint64_t *v1283;
  uint64_t v1284;
  uint64_t v1285;
  unint64_t v1286;
  uint64_t v1287;
  unint64_t v1288;
  char *v1289;
  _anonymous_namespace_::ReducePatternBase **v1290;
  uint64_t *v1291;
  char *v1292;
  unint64_t v1293;
  uint64_t v1294;
  uint64_t v1295;
  _anonymous_namespace_::ReducePatternBase **v1296;
  _anonymous_namespace_::ReducePatternBase **v1297;
  char *v1298;
  uint64_t v1299;
  __int128 v1300;
  __int128 v1301;
  _anonymous_namespace_::ReducePatternBase *v1302;
  _anonymous_namespace_::ReducePatternBase **v1303;
  uint64_t v1304;
  uint64_t v1305;
  _anonymous_namespace_::ReducePatternBase *v1306;
  unint64_t v1307;
  _anonymous_namespace_::ReducePatternBase **v1308;
  uint64_t v1309;
  uint64_t *v1310;
  uint64_t v1311;
  uint64_t v1312;
  unint64_t v1313;
  uint64_t v1314;
  unint64_t v1315;
  char *v1316;
  _anonymous_namespace_::ReducePatternBase **v1317;
  uint64_t *v1318;
  char *v1319;
  unint64_t v1320;
  uint64_t v1321;
  uint64_t v1322;
  _anonymous_namespace_::ReducePatternBase **v1323;
  _anonymous_namespace_::ReducePatternBase **v1324;
  char *v1325;
  uint64_t v1326;
  __int128 v1327;
  __int128 v1328;
  _anonymous_namespace_::ReducePatternBase *v1329;
  _anonymous_namespace_::ReducePatternBase **v1330;
  uint64_t v1331;
  uint64_t v1332;
  _anonymous_namespace_::ReducePatternBase *v1333;
  unint64_t v1334;
  _anonymous_namespace_::ReducePatternBase **v1335;
  uint64_t v1336;
  uint64_t *v1337;
  uint64_t v1338;
  uint64_t v1339;
  unint64_t v1340;
  uint64_t v1341;
  unint64_t v1342;
  char *v1343;
  _anonymous_namespace_::ReducePatternBase **v1344;
  uint64_t *v1345;
  char *v1346;
  unint64_t v1347;
  uint64_t v1348;
  uint64_t v1349;
  _anonymous_namespace_::ReducePatternBase **v1350;
  _anonymous_namespace_::ReducePatternBase **v1351;
  char *v1352;
  uint64_t v1353;
  __int128 v1354;
  __int128 v1355;
  _anonymous_namespace_::ReducePatternBase *v1356;
  _anonymous_namespace_::ReducePatternBase **v1357;
  uint64_t v1358;
  uint64_t v1359;
  _anonymous_namespace_::ReducePatternBase *v1360;
  unint64_t v1361;
  _anonymous_namespace_::ReducePatternBase **v1362;
  uint64_t v1363;
  uint64_t *v1364;
  uint64_t v1365;
  uint64_t v1366;
  unint64_t v1367;
  uint64_t v1368;
  unint64_t v1369;
  char *v1370;
  _anonymous_namespace_::ReducePatternBase **v1371;
  uint64_t *v1372;
  char *v1373;
  unint64_t v1374;
  uint64_t v1375;
  uint64_t v1376;
  _anonymous_namespace_::ReducePatternBase **v1377;
  _anonymous_namespace_::ReducePatternBase **v1378;
  char *v1379;
  uint64_t v1380;
  __int128 v1381;
  __int128 v1382;
  _anonymous_namespace_::ReducePatternBase *v1383;
  _anonymous_namespace_::ReducePatternBase **v1384;
  uint64_t v1385;
  uint64_t v1386;
  _anonymous_namespace_::ReducePatternBase *v1387;
  unint64_t v1388;
  _anonymous_namespace_::ReducePatternBase **v1389;
  uint64_t v1390;
  uint64_t *v1391;
  uint64_t v1392;
  uint64_t v1393;
  unint64_t v1394;
  uint64_t v1395;
  unint64_t v1396;
  char *v1397;
  _anonymous_namespace_::ReducePatternBase **v1398;
  uint64_t *v1399;
  char *v1400;
  unint64_t v1401;
  uint64_t v1402;
  uint64_t v1403;
  _anonymous_namespace_::ReducePatternBase **v1404;
  _anonymous_namespace_::ReducePatternBase **v1405;
  char *v1406;
  uint64_t v1407;
  __int128 v1408;
  __int128 v1409;
  _anonymous_namespace_::ReducePatternBase *v1410;
  _anonymous_namespace_::ReducePatternBase **v1411;
  uint64_t v1412;
  uint64_t v1413;
  _anonymous_namespace_::ReducePatternBase *v1414;
  unint64_t v1415;
  _anonymous_namespace_::ReducePatternBase **v1416;
  uint64_t v1417;
  uint64_t *v1418;
  uint64_t v1419;
  uint64_t v1420;
  unint64_t v1421;
  uint64_t v1422;
  unint64_t v1423;
  char *v1424;
  _anonymous_namespace_::ReducePatternBase **v1425;
  uint64_t *v1426;
  char *v1427;
  unint64_t v1428;
  uint64_t v1429;
  uint64_t v1430;
  _anonymous_namespace_::ReducePatternBase **v1431;
  _anonymous_namespace_::ReducePatternBase **v1432;
  char *v1433;
  uint64_t v1434;
  __int128 v1435;
  __int128 v1436;
  _anonymous_namespace_::ReducePatternBase *v1437;
  _anonymous_namespace_::ReducePatternBase **v1438;
  uint64_t v1439;
  uint64_t v1440;
  _anonymous_namespace_::ReducePatternBase *v1441;
  unint64_t v1442;
  _anonymous_namespace_::ReducePatternBase **v1443;
  uint64_t v1444;
  uint64_t *v1445;
  uint64_t v1446;
  uint64_t v1447;
  unint64_t v1448;
  uint64_t v1449;
  unint64_t v1450;
  char *v1451;
  _anonymous_namespace_::ReducePatternBase **v1452;
  uint64_t *v1453;
  char *v1454;
  unint64_t v1455;
  uint64_t v1456;
  uint64_t v1457;
  _anonymous_namespace_::ReducePatternBase **v1458;
  _anonymous_namespace_::ReducePatternBase **v1459;
  char *v1460;
  uint64_t v1461;
  __int128 v1462;
  __int128 v1463;
  _anonymous_namespace_::ReducePatternBase *v1464;
  _anonymous_namespace_::ReducePatternBase **v1465;
  uint64_t v1466;
  uint64_t v1467;
  _anonymous_namespace_::ReducePatternBase *v1468;
  unint64_t v1469;
  _anonymous_namespace_::ReducePatternBase **v1470;
  uint64_t v1471;
  uint64_t *v1472;
  uint64_t v1473;
  uint64_t v1474;
  unint64_t v1475;
  uint64_t v1476;
  unint64_t v1477;
  char *v1478;
  _anonymous_namespace_::ReducePatternBase **v1479;
  uint64_t *v1480;
  char *v1481;
  unint64_t v1482;
  uint64_t v1483;
  uint64_t v1484;
  _anonymous_namespace_::ReducePatternBase **v1485;
  _anonymous_namespace_::ReducePatternBase **v1486;
  char *v1487;
  uint64_t v1488;
  __int128 v1489;
  __int128 v1490;
  _anonymous_namespace_::ReducePatternBase *v1491;
  _anonymous_namespace_::ReducePatternBase **v1492;
  uint64_t v1493;
  uint64_t v1494;
  _anonymous_namespace_::ReducePatternBase *v1495;
  unint64_t v1496;
  _anonymous_namespace_::ReducePatternBase **v1497;
  uint64_t v1498;
  uint64_t *v1499;
  uint64_t v1500;
  uint64_t v1501;
  unint64_t v1502;
  uint64_t v1503;
  unint64_t v1504;
  char *v1505;
  _anonymous_namespace_::ReducePatternBase **v1506;
  uint64_t *v1507;
  char *v1508;
  unint64_t v1509;
  uint64_t v1510;
  uint64_t v1511;
  _anonymous_namespace_::ReducePatternBase **v1512;
  _anonymous_namespace_::ReducePatternBase **v1513;
  char *v1514;
  uint64_t v1515;
  __int128 v1516;
  __int128 v1517;
  _anonymous_namespace_::ReducePatternBase *v1518;
  _anonymous_namespace_::ReducePatternBase **v1519;
  uint64_t v1520;
  uint64_t v1521;
  _anonymous_namespace_::ReducePatternBase *v1522;
  unint64_t v1523;
  _anonymous_namespace_::ReducePatternBase **v1524;
  uint64_t v1525;
  uint64_t *v1526;
  uint64_t v1527;
  uint64_t v1528;
  unint64_t v1529;
  uint64_t v1530;
  unint64_t v1531;
  char *v1532;
  _anonymous_namespace_::ReducePatternBase **v1533;
  uint64_t *v1534;
  char *v1535;
  unint64_t v1536;
  uint64_t v1537;
  uint64_t v1538;
  _anonymous_namespace_::ReducePatternBase **v1539;
  _anonymous_namespace_::ReducePatternBase **v1540;
  char *v1541;
  uint64_t v1542;
  __int128 v1543;
  __int128 v1544;
  _anonymous_namespace_::ReducePatternBase *v1545;
  _anonymous_namespace_::ReducePatternBase **v1546;
  uint64_t v1547;
  uint64_t v1548;
  _anonymous_namespace_::ReducePatternBase *v1549;
  unint64_t v1550;
  _anonymous_namespace_::ReducePatternBase **v1551;
  uint64_t v1552;
  uint64_t *v1553;
  uint64_t v1554;
  uint64_t v1555;
  unint64_t v1556;
  uint64_t v1557;
  unint64_t v1558;
  char *v1559;
  _anonymous_namespace_::ReducePatternBase **v1560;
  uint64_t *v1561;
  char *v1562;
  unint64_t v1563;
  uint64_t v1564;
  uint64_t v1565;
  _anonymous_namespace_::ReducePatternBase **v1566;
  _anonymous_namespace_::ReducePatternBase **v1567;
  char *v1568;
  uint64_t v1569;
  __int128 v1570;
  __int128 v1571;
  _anonymous_namespace_::ReducePatternBase *v1572;
  _anonymous_namespace_::ReducePatternBase **v1573;
  uint64_t v1574;
  uint64_t v1575;
  uint64_t v1576;
  uint64_t v1577;
  unint64_t v1578;
  uint64_t *v1579;
  uint64_t v1580;
  uint64_t *v1581;
  uint64_t v1582;
  uint64_t v1583;
  unint64_t v1584;
  uint64_t v1585;
  unint64_t v1586;
  char *v1587;
  uint64_t *v1588;
  uint64_t *v1589;
  char *v1590;
  unint64_t v1591;
  uint64_t v1592;
  uint64_t v1593;
  uint64_t *v1594;
  uint64_t *v1595;
  char *v1596;
  uint64_t v1597;
  __int128 v1598;
  __int128 v1599;
  uint64_t v1600;
  uint64_t *v1601;
  uint64_t v1602;
  uint64_t v1603;
  uint64_t v1604;
  uint64_t v1605;
  unint64_t v1606;
  uint64_t *v1607;
  uint64_t v1608;
  uint64_t *v1609;
  uint64_t v1610;
  uint64_t v1611;
  unint64_t v1612;
  uint64_t v1613;
  unint64_t v1614;
  char *v1615;
  uint64_t *v1616;
  uint64_t *v1617;
  char *v1618;
  unint64_t v1619;
  uint64_t v1620;
  uint64_t v1621;
  uint64_t *v1622;
  uint64_t *v1623;
  char *v1624;
  uint64_t v1625;
  __int128 v1626;
  __int128 v1627;
  uint64_t v1628;
  uint64_t *v1629;
  uint64_t v1630;
  uint64_t v1631;
  uint64_t v1632;
  uint64_t v1633;
  unint64_t v1634;
  uint64_t *v1635;
  uint64_t v1636;
  uint64_t *v1637;
  uint64_t v1638;
  uint64_t v1639;
  unint64_t v1640;
  uint64_t v1641;
  unint64_t v1642;
  char *v1643;
  uint64_t *v1644;
  uint64_t *v1645;
  char *v1646;
  unint64_t v1647;
  uint64_t v1648;
  uint64_t v1649;
  uint64_t *v1650;
  uint64_t *v1651;
  char *v1652;
  uint64_t v1653;
  __int128 v1654;
  __int128 v1655;
  uint64_t v1656;
  uint64_t *v1657;
  uint64_t v1658;
  uint64_t v1659;
  uint64_t v1660;

  v2 = operator new();
  v3 = v2;
  *(_QWORD *)(v2 + 8) = 0x6F6E5F6863746162;
  *(_QWORD *)(v2 + 16) = 28018;
  *(_BYTE *)(v2 + 31) = 10;
  *(_QWORD *)v2 = off_1E0E15E28;
  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *v5 = v2;
    v7 = (uint64_t)(v5 + 1);
    goto LABEL_27;
  }
  v8 = *a1;
  v9 = (char *)v5 - (char *)*a1;
  v10 = v9 >> 3;
  v11 = (v9 >> 3) + 1;
  if (v11 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v12 = v4 - (_QWORD)v8;
  if (v12 >> 2 > v11)
    v11 = v12 >> 2;
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v11;
  if (v13)
  {
    if (v13 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v14 = (char *)operator new(8 * v13);
    v15 = (uint64_t *)&v14[8 * v10];
    v16 = (uint64_t *)&v14[8 * v13];
    *v15 = v3;
    v7 = (uint64_t)(v15 + 1);
    v17 = (char *)((char *)v5 - (char *)v8);
    if (v5 != v8)
      goto LABEL_12;
  }
  else
  {
    v14 = 0;
    v15 = (uint64_t *)(8 * v10);
    v16 = 0;
    *(_QWORD *)(8 * v10) = v3;
    v7 = 8 * v10 + 8;
    v17 = (char *)((char *)v5 - (char *)v8);
    if (v5 != v8)
    {
LABEL_12:
      v18 = (unint64_t)(v17 - 8);
      if (v18 < 0x78
        || (uint64_t *)((char *)v5 - (v18 & 0xFFFFFFFFFFFFFFF8) - 8) < v15
        && &v14[v9 - (v18 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v5)
      {
        goto LABEL_1672;
      }
      v19 = (v18 >> 3) + 1;
      v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
      v15 = (uint64_t *)((char *)v15 - v20);
      v6 = &v5[v20 / 0xFFFFFFFFFFFFFFF8];
      v21 = v5 - 2;
      v22 = &v14[8 * v10 - 16];
      v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v25 = *((_OWORD *)v21 - 1);
        v24 = *(_OWORD *)v21;
        *((_OWORD *)v21 - 1) = 0uLL;
        *(_OWORD *)v21 = 0uLL;
        *((_OWORD *)v22 - 1) = v25;
        *(_OWORD *)v22 = v24;
        v21 -= 4;
        v22 -= 32;
        v23 -= 4;
      }
      while (v23);
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1672:
        do
        {
          v26 = *--v6;
          *v6 = 0;
          *--v15 = v26;
        }
        while (v6 != v8);
      }
      v6 = *a1;
      v27 = a1[1];
      *a1 = v15;
      a1[1] = (uint64_t *)v7;
      a1[2] = v16;
      while (v27 != v6)
      {
        v29 = *--v27;
        v28 = v29;
        *v27 = 0;
        if (v29)
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
      }
      goto LABEL_25;
    }
  }
  *a1 = v15;
  a1[1] = (uint64_t *)v7;
  a1[2] = v16;
LABEL_25:
  if (v6)
    operator delete(v6);
LABEL_27:
  a1[1] = (uint64_t *)v7;
  v30 = operator new();
  v31 = v30;
  strcpy((char *)(v30 + 8), "batch_to_space");
  *(_BYTE *)(v30 + 23) = 0;
  *(_BYTE *)(v30 + 31) = 14;
  *(_QWORD *)v30 = off_1E0E172B8;
  v33 = a1[1];
  v32 = (unint64_t)a1[2];
  if ((unint64_t)v33 < v32)
  {
    *v33 = v30;
    v34 = (uint64_t)(v33 + 1);
    goto LABEL_53;
  }
  v35 = *a1;
  v36 = (char *)v33 - (char *)*a1;
  v37 = v36 >> 3;
  v38 = (v36 >> 3) + 1;
  if (v38 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v39 = v32 - (_QWORD)v35;
  if (v39 >> 2 > v38)
    v38 = v39 >> 2;
  if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8)
    v40 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v40 = v38;
  if (v40)
  {
    if (v40 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v41 = (char *)operator new(8 * v40);
    v42 = (uint64_t *)&v41[8 * v37];
    v43 = (uint64_t *)&v41[8 * v40];
    *v42 = v31;
    v34 = (uint64_t)(v42 + 1);
    v44 = (char *)((char *)v33 - (char *)v35);
    if (v33 != v35)
      goto LABEL_38;
  }
  else
  {
    v41 = 0;
    v42 = (uint64_t *)(8 * v37);
    v43 = 0;
    *(_QWORD *)(8 * v37) = v31;
    v34 = 8 * v37 + 8;
    v44 = (char *)((char *)v33 - (char *)v35);
    if (v33 != v35)
    {
LABEL_38:
      v45 = (unint64_t)(v44 - 8);
      if (v45 < 0x78
        || (uint64_t *)((char *)v33 - (v45 & 0xFFFFFFFFFFFFFFF8) - 8) < v42
        && &v41[v36 - (v45 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v33)
      {
        goto LABEL_1673;
      }
      v46 = (v45 >> 3) + 1;
      v47 = 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
      v42 = (uint64_t *)((char *)v42 - v47);
      v48 = &v33[v47 / 0xFFFFFFFFFFFFFFF8];
      v49 = v33 - 2;
      v50 = &v41[8 * v37 - 16];
      v51 = v46 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v53 = *((_OWORD *)v49 - 1);
        v52 = *(_OWORD *)v49;
        *((_OWORD *)v49 - 1) = 0uLL;
        *(_OWORD *)v49 = 0uLL;
        *((_OWORD *)v50 - 1) = v53;
        *(_OWORD *)v50 = v52;
        v49 -= 4;
        v50 -= 32;
        v51 -= 4;
      }
      while (v51);
      v33 = v48;
      if (v46 != (v46 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1673:
        do
        {
          v54 = *--v33;
          *v33 = 0;
          *--v42 = v54;
        }
        while (v33 != v35);
      }
      v33 = *a1;
      v55 = a1[1];
      *a1 = v42;
      a1[1] = (uint64_t *)v34;
      a1[2] = v43;
      while (v55 != v33)
      {
        v57 = *--v55;
        v56 = v57;
        *v55 = 0;
        if (v57)
          (*(void (**)(uint64_t))(*(_QWORD *)v56 + 8))(v56);
      }
      goto LABEL_51;
    }
  }
  *a1 = v42;
  a1[1] = (uint64_t *)v34;
  a1[2] = v43;
LABEL_51:
  if (v33)
    operator delete(v33);
LABEL_53:
  a1[1] = (uint64_t *)v34;
  v58 = operator new();
  v59 = v58;
  *(_BYTE *)(v58 + 31) = 4;
  *(_QWORD *)v58 = off_1E0E15188;
  *(_QWORD *)(v58 + 8) = 1819042147;
  v61 = a1[1];
  v60 = (unint64_t)a1[2];
  if ((unint64_t)v61 < v60)
  {
    *v61 = v58;
    v62 = (uint64_t)(v61 + 1);
    goto LABEL_79;
  }
  v63 = *a1;
  v64 = (char *)v61 - (char *)*a1;
  v65 = v64 >> 3;
  v66 = (v64 >> 3) + 1;
  if (v66 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v67 = v60 - (_QWORD)v63;
  if (v67 >> 2 > v66)
    v66 = v67 >> 2;
  if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
    v68 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v68 = v66;
  if (v68)
  {
    if (v68 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v69 = (char *)operator new(8 * v68);
    v70 = (uint64_t *)&v69[8 * v65];
    v71 = (uint64_t *)&v69[8 * v68];
    *v70 = v59;
    v62 = (uint64_t)(v70 + 1);
    v72 = (char *)((char *)v61 - (char *)v63);
    if (v61 != v63)
      goto LABEL_64;
  }
  else
  {
    v69 = 0;
    v70 = (uint64_t *)(8 * v65);
    v71 = 0;
    *(_QWORD *)(8 * v65) = v59;
    v62 = 8 * v65 + 8;
    v72 = (char *)((char *)v61 - (char *)v63);
    if (v61 != v63)
    {
LABEL_64:
      v73 = (unint64_t)(v72 - 8);
      if (v73 < 0x78
        || (uint64_t *)((char *)v61 - (v73 & 0xFFFFFFFFFFFFFFF8) - 8) < v70
        && &v69[v64 - (v73 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v61)
      {
        goto LABEL_1674;
      }
      v74 = (v73 >> 3) + 1;
      v75 = 8 * (v74 & 0x3FFFFFFFFFFFFFFCLL);
      v70 = (uint64_t *)((char *)v70 - v75);
      v76 = &v61[v75 / 0xFFFFFFFFFFFFFFF8];
      v77 = v61 - 2;
      v78 = &v69[8 * v65 - 16];
      v79 = v74 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v81 = *((_OWORD *)v77 - 1);
        v80 = *(_OWORD *)v77;
        *((_OWORD *)v77 - 1) = 0uLL;
        *(_OWORD *)v77 = 0uLL;
        *((_OWORD *)v78 - 1) = v81;
        *(_OWORD *)v78 = v80;
        v77 -= 4;
        v78 -= 32;
        v79 -= 4;
      }
      while (v79);
      v61 = v76;
      if (v74 != (v74 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1674:
        do
        {
          v82 = *--v61;
          *v61 = 0;
          *--v70 = v82;
        }
        while (v61 != v63);
      }
      v61 = *a1;
      v83 = a1[1];
      *a1 = v70;
      a1[1] = (uint64_t *)v62;
      a1[2] = v71;
      while (v83 != v61)
      {
        v85 = *--v83;
        v84 = v85;
        *v83 = 0;
        if (v85)
          (*(void (**)(uint64_t))(*(_QWORD *)v84 + 8))(v84);
      }
      goto LABEL_77;
    }
  }
  *a1 = v70;
  a1[1] = (uint64_t *)v62;
  a1[2] = v71;
LABEL_77:
  if (v61)
    operator delete(v61);
LABEL_79:
  a1[1] = (uint64_t *)v62;
  v86 = operator new();
  v87 = v86;
  *(_BYTE *)(v86 + 31) = 4;
  *(_QWORD *)v86 = off_1E0E151B0;
  *(_QWORD *)(v86 + 8) = 1953718627;
  v89 = a1[1];
  v88 = (unint64_t)a1[2];
  if ((unint64_t)v89 < v88)
  {
    *v89 = v86;
    v90 = (uint64_t)(v89 + 1);
    goto LABEL_105;
  }
  v91 = *a1;
  v92 = (char *)v89 - (char *)*a1;
  v93 = v92 >> 3;
  v94 = (v92 >> 3) + 1;
  if (v94 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v95 = v88 - (_QWORD)v91;
  if (v95 >> 2 > v94)
    v94 = v95 >> 2;
  if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8)
    v96 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v96 = v94;
  if (v96)
  {
    if (v96 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v97 = (char *)operator new(8 * v96);
    v98 = (uint64_t *)&v97[8 * v93];
    v99 = (uint64_t *)&v97[8 * v96];
    *v98 = v87;
    v90 = (uint64_t)(v98 + 1);
    v100 = (char *)((char *)v89 - (char *)v91);
    if (v89 != v91)
      goto LABEL_90;
  }
  else
  {
    v97 = 0;
    v98 = (uint64_t *)(8 * v93);
    v99 = 0;
    *(_QWORD *)(8 * v93) = v87;
    v90 = 8 * v93 + 8;
    v100 = (char *)((char *)v89 - (char *)v91);
    if (v89 != v91)
    {
LABEL_90:
      v101 = (unint64_t)(v100 - 8);
      if (v101 < 0x78
        || (uint64_t *)((char *)v89 - (v101 & 0xFFFFFFFFFFFFFFF8) - 8) < v98
        && &v97[v92 - (v101 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v89)
      {
        goto LABEL_1675;
      }
      v102 = (v101 >> 3) + 1;
      v103 = 8 * (v102 & 0x3FFFFFFFFFFFFFFCLL);
      v98 = (uint64_t *)((char *)v98 - v103);
      v104 = &v89[v103 / 0xFFFFFFFFFFFFFFF8];
      v105 = v89 - 2;
      v106 = &v97[8 * v93 - 16];
      v107 = v102 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v109 = *((_OWORD *)v105 - 1);
        v108 = *(_OWORD *)v105;
        *((_OWORD *)v105 - 1) = 0uLL;
        *(_OWORD *)v105 = 0uLL;
        *((_OWORD *)v106 - 1) = v109;
        *(_OWORD *)v106 = v108;
        v105 -= 4;
        v106 -= 32;
        v107 -= 4;
      }
      while (v107);
      v89 = v104;
      if (v102 != (v102 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1675:
        do
        {
          v110 = *--v89;
          *v89 = 0;
          *--v98 = v110;
        }
        while (v89 != v91);
      }
      v89 = *a1;
      v111 = a1[1];
      *a1 = v98;
      a1[1] = (uint64_t *)v90;
      a1[2] = v99;
      while (v111 != v89)
      {
        v113 = *--v111;
        v112 = v113;
        *v111 = 0;
        if (v113)
          (*(void (**)(uint64_t))(*(_QWORD *)v112 + 8))(v112);
      }
      goto LABEL_103;
    }
  }
  *a1 = v98;
  a1[1] = (uint64_t *)v90;
  a1[2] = v99;
LABEL_103:
  if (v89)
    operator delete(v89);
LABEL_105:
  a1[1] = (uint64_t *)v90;
  v114 = operator new();
  v115 = v114;
  *(_BYTE *)(v114 + 31) = 6;
  *(_QWORD *)v114 = off_1E0E156D0;
  *(_QWORD *)(v114 + 8) = 0x7461636E6F63;
  v117 = a1[1];
  v116 = (unint64_t)a1[2];
  if ((unint64_t)v117 < v116)
  {
    *v117 = v114;
    v118 = (uint64_t)(v117 + 1);
    goto LABEL_131;
  }
  v119 = *a1;
  v120 = (char *)v117 - (char *)*a1;
  v121 = v120 >> 3;
  v122 = (v120 >> 3) + 1;
  if (v122 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v123 = v116 - (_QWORD)v119;
  if (v123 >> 2 > v122)
    v122 = v123 >> 2;
  if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFF8)
    v124 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v124 = v122;
  if (v124)
  {
    if (v124 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v125 = (char *)operator new(8 * v124);
    v126 = (uint64_t *)&v125[8 * v121];
    v127 = (uint64_t *)&v125[8 * v124];
    *v126 = v115;
    v118 = (uint64_t)(v126 + 1);
    v128 = (char *)((char *)v117 - (char *)v119);
    if (v117 != v119)
      goto LABEL_116;
  }
  else
  {
    v125 = 0;
    v126 = (uint64_t *)(8 * v121);
    v127 = 0;
    *(_QWORD *)(8 * v121) = v115;
    v118 = 8 * v121 + 8;
    v128 = (char *)((char *)v117 - (char *)v119);
    if (v117 != v119)
    {
LABEL_116:
      v129 = (unint64_t)(v128 - 8);
      if (v129 < 0x78
        || (uint64_t *)((char *)v117 - (v129 & 0xFFFFFFFFFFFFFFF8) - 8) < v126
        && &v125[v120 - (v129 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v117)
      {
        goto LABEL_1676;
      }
      v130 = (v129 >> 3) + 1;
      v131 = 8 * (v130 & 0x3FFFFFFFFFFFFFFCLL);
      v126 = (uint64_t *)((char *)v126 - v131);
      v132 = &v117[v131 / 0xFFFFFFFFFFFFFFF8];
      v133 = v117 - 2;
      v134 = &v125[8 * v121 - 16];
      v135 = v130 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v137 = *((_OWORD *)v133 - 1);
        v136 = *(_OWORD *)v133;
        *((_OWORD *)v133 - 1) = 0uLL;
        *(_OWORD *)v133 = 0uLL;
        *((_OWORD *)v134 - 1) = v137;
        *(_OWORD *)v134 = v136;
        v133 -= 4;
        v134 -= 32;
        v135 -= 4;
      }
      while (v135);
      v117 = v132;
      if (v130 != (v130 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1676:
        do
        {
          v138 = *--v117;
          *v117 = 0;
          *--v126 = v138;
        }
        while (v117 != v119);
      }
      v117 = *a1;
      v139 = a1[1];
      *a1 = v126;
      a1[1] = (uint64_t *)v118;
      a1[2] = v127;
      while (v139 != v117)
      {
        v141 = *--v139;
        v140 = v141;
        *v139 = 0;
        if (v141)
          (*(void (**)(uint64_t))(*(_QWORD *)v140 + 8))(v140);
      }
      goto LABEL_129;
    }
  }
  *a1 = v126;
  a1[1] = (uint64_t *)v118;
  a1[2] = v127;
LABEL_129:
  if (v117)
    operator delete(v117);
LABEL_131:
  a1[1] = (uint64_t *)v118;
  v142 = operator new();
  v143 = v142;
  *(_BYTE *)(v142 + 31) = 5;
  *(_QWORD *)v142 = off_1E0E15420;
  *(_QWORD *)(v142 + 8) = 0x74736E6F63;
  v145 = a1[1];
  v144 = (unint64_t)a1[2];
  if ((unint64_t)v145 < v144)
  {
    *v145 = v142;
    v146 = (uint64_t)(v145 + 1);
    goto LABEL_157;
  }
  v147 = *a1;
  v148 = (char *)v145 - (char *)*a1;
  v149 = v148 >> 3;
  v150 = (v148 >> 3) + 1;
  if (v150 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v151 = v144 - (_QWORD)v147;
  if (v151 >> 2 > v150)
    v150 = v151 >> 2;
  if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF8)
    v152 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v152 = v150;
  if (v152)
  {
    if (v152 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v153 = (char *)operator new(8 * v152);
    v154 = (uint64_t *)&v153[8 * v149];
    v155 = (uint64_t *)&v153[8 * v152];
    *v154 = v143;
    v146 = (uint64_t)(v154 + 1);
    v156 = (char *)((char *)v145 - (char *)v147);
    if (v145 != v147)
      goto LABEL_142;
  }
  else
  {
    v153 = 0;
    v154 = (uint64_t *)(8 * v149);
    v155 = 0;
    *(_QWORD *)(8 * v149) = v143;
    v146 = 8 * v149 + 8;
    v156 = (char *)((char *)v145 - (char *)v147);
    if (v145 != v147)
    {
LABEL_142:
      v157 = (unint64_t)(v156 - 8);
      if (v157 < 0x78
        || (uint64_t *)((char *)v145 - (v157 & 0xFFFFFFFFFFFFFFF8) - 8) < v154
        && &v153[v148 - (v157 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v145)
      {
        goto LABEL_1677;
      }
      v158 = (v157 >> 3) + 1;
      v159 = 8 * (v158 & 0x3FFFFFFFFFFFFFFCLL);
      v154 = (uint64_t *)((char *)v154 - v159);
      v160 = &v145[v159 / 0xFFFFFFFFFFFFFFF8];
      v161 = v145 - 2;
      v162 = &v153[8 * v149 - 16];
      v163 = v158 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v165 = *((_OWORD *)v161 - 1);
        v164 = *(_OWORD *)v161;
        *((_OWORD *)v161 - 1) = 0uLL;
        *(_OWORD *)v161 = 0uLL;
        *((_OWORD *)v162 - 1) = v165;
        *(_OWORD *)v162 = v164;
        v161 -= 4;
        v162 -= 32;
        v163 -= 4;
      }
      while (v163);
      v145 = v160;
      if (v158 != (v158 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1677:
        do
        {
          v166 = *--v145;
          *v145 = 0;
          *--v154 = v166;
        }
        while (v145 != v147);
      }
      v145 = *a1;
      v167 = a1[1];
      *a1 = v154;
      a1[1] = (uint64_t *)v146;
      a1[2] = v155;
      while (v167 != v145)
      {
        v169 = *--v167;
        v168 = v169;
        *v167 = 0;
        if (v169)
          (*(void (**)(uint64_t))(*(_QWORD *)v168 + 8))(v168);
      }
      goto LABEL_155;
    }
  }
  *a1 = v154;
  a1[1] = (uint64_t *)v146;
  a1[2] = v155;
LABEL_155:
  if (v145)
    operator delete(v145);
LABEL_157:
  a1[1] = (uint64_t *)v146;
  v170 = operator new();
  v171 = v170;
  *(_BYTE *)(v170 + 31) = 6;
  *(_QWORD *)v170 = off_1E0E156F8;
  *(_QWORD *)(v170 + 8) = 0x6D75736D7563;
  v173 = a1[1];
  v172 = (unint64_t)a1[2];
  if ((unint64_t)v173 < v172)
  {
    *v173 = v170;
    v174 = (uint64_t)(v173 + 1);
    goto LABEL_183;
  }
  v175 = *a1;
  v176 = (char *)v173 - (char *)*a1;
  v177 = v176 >> 3;
  v178 = (v176 >> 3) + 1;
  if (v178 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v179 = v172 - (_QWORD)v175;
  if (v179 >> 2 > v178)
    v178 = v179 >> 2;
  if ((unint64_t)v179 >= 0x7FFFFFFFFFFFFFF8)
    v180 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v180 = v178;
  if (v180)
  {
    if (v180 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v181 = (char *)operator new(8 * v180);
    v182 = (uint64_t *)&v181[8 * v177];
    v183 = (uint64_t *)&v181[8 * v180];
    *v182 = v171;
    v174 = (uint64_t)(v182 + 1);
    v184 = (char *)((char *)v173 - (char *)v175);
    if (v173 != v175)
      goto LABEL_168;
  }
  else
  {
    v181 = 0;
    v182 = (uint64_t *)(8 * v177);
    v183 = 0;
    *(_QWORD *)(8 * v177) = v171;
    v174 = 8 * v177 + 8;
    v184 = (char *)((char *)v173 - (char *)v175);
    if (v173 != v175)
    {
LABEL_168:
      v185 = (unint64_t)(v184 - 8);
      if (v185 < 0x78
        || (uint64_t *)((char *)v173 - (v185 & 0xFFFFFFFFFFFFFFF8) - 8) < v182
        && &v181[v176 - (v185 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v173)
      {
        goto LABEL_1678;
      }
      v186 = (v185 >> 3) + 1;
      v187 = 8 * (v186 & 0x3FFFFFFFFFFFFFFCLL);
      v182 = (uint64_t *)((char *)v182 - v187);
      v188 = &v173[v187 / 0xFFFFFFFFFFFFFFF8];
      v189 = v173 - 2;
      v190 = &v181[8 * v177 - 16];
      v191 = v186 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v193 = *((_OWORD *)v189 - 1);
        v192 = *(_OWORD *)v189;
        *((_OWORD *)v189 - 1) = 0uLL;
        *(_OWORD *)v189 = 0uLL;
        *((_OWORD *)v190 - 1) = v193;
        *(_OWORD *)v190 = v192;
        v189 -= 4;
        v190 -= 32;
        v191 -= 4;
      }
      while (v191);
      v173 = v188;
      if (v186 != (v186 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1678:
        do
        {
          v194 = *--v173;
          *v173 = 0;
          *--v182 = v194;
        }
        while (v173 != v175);
      }
      v173 = *a1;
      v195 = a1[1];
      *a1 = v182;
      a1[1] = (uint64_t *)v174;
      a1[2] = v183;
      while (v195 != v173)
      {
        v197 = *--v195;
        v196 = v197;
        *v195 = 0;
        if (v197)
          (*(void (**)(uint64_t))(*(_QWORD *)v196 + 8))(v196);
      }
      goto LABEL_181;
    }
  }
  *a1 = v182;
  a1[1] = (uint64_t *)v174;
  a1[2] = v183;
LABEL_181:
  if (v173)
    operator delete(v173);
LABEL_183:
  a1[1] = (uint64_t *)v174;
  v198 = operator new();
  v199 = v198;
  *(_BYTE *)(v198 + 31) = 6;
  *(_QWORD *)v198 = off_1E0E15898;
  *(_QWORD *)(v198 + 8) = 0x6D75736E6965;
  v201 = a1[1];
  v200 = (unint64_t)a1[2];
  if ((unint64_t)v201 < v200)
  {
    *v201 = v198;
    v202 = (uint64_t)(v201 + 1);
    goto LABEL_209;
  }
  v203 = *a1;
  v204 = (char *)v201 - (char *)*a1;
  v205 = v204 >> 3;
  v206 = (v204 >> 3) + 1;
  if (v206 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v207 = v200 - (_QWORD)v203;
  if (v207 >> 2 > v206)
    v206 = v207 >> 2;
  if ((unint64_t)v207 >= 0x7FFFFFFFFFFFFFF8)
    v208 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v208 = v206;
  if (v208)
  {
    if (v208 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v209 = (char *)operator new(8 * v208);
    v210 = (uint64_t *)&v209[8 * v205];
    v211 = (uint64_t *)&v209[8 * v208];
    *v210 = v199;
    v202 = (uint64_t)(v210 + 1);
    v212 = (char *)((char *)v201 - (char *)v203);
    if (v201 != v203)
      goto LABEL_194;
  }
  else
  {
    v209 = 0;
    v210 = (uint64_t *)(8 * v205);
    v211 = 0;
    *(_QWORD *)(8 * v205) = v199;
    v202 = 8 * v205 + 8;
    v212 = (char *)((char *)v201 - (char *)v203);
    if (v201 != v203)
    {
LABEL_194:
      v213 = (unint64_t)(v212 - 8);
      if (v213 < 0x78
        || (uint64_t *)((char *)v201 - (v213 & 0xFFFFFFFFFFFFFFF8) - 8) < v210
        && &v209[v204 - (v213 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v201)
      {
        goto LABEL_1679;
      }
      v214 = (v213 >> 3) + 1;
      v215 = 8 * (v214 & 0x3FFFFFFFFFFFFFFCLL);
      v210 = (uint64_t *)((char *)v210 - v215);
      v216 = &v201[v215 / 0xFFFFFFFFFFFFFFF8];
      v217 = v201 - 2;
      v218 = &v209[8 * v205 - 16];
      v219 = v214 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v221 = *((_OWORD *)v217 - 1);
        v220 = *(_OWORD *)v217;
        *((_OWORD *)v217 - 1) = 0uLL;
        *(_OWORD *)v217 = 0uLL;
        *((_OWORD *)v218 - 1) = v221;
        *(_OWORD *)v218 = v220;
        v217 -= 4;
        v218 -= 32;
        v219 -= 4;
      }
      while (v219);
      v201 = v216;
      if (v214 != (v214 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1679:
        do
        {
          v222 = *--v201;
          *v201 = 0;
          *--v210 = v222;
        }
        while (v201 != v203);
      }
      v201 = *a1;
      v223 = a1[1];
      *a1 = v210;
      a1[1] = (uint64_t *)v202;
      a1[2] = v211;
      while (v223 != v201)
      {
        v225 = *--v223;
        v224 = v225;
        *v223 = 0;
        if (v225)
          (*(void (**)(uint64_t))(*(_QWORD *)v224 + 8))(v224);
      }
      goto LABEL_207;
    }
  }
  *a1 = v210;
  a1[1] = (uint64_t *)v202;
  a1[2] = v211;
LABEL_207:
  if (v201)
    operator delete(v201);
LABEL_209:
  a1[1] = (uint64_t *)v202;
  v226 = operator new();
  v227 = v226;
  *(_BYTE *)(v226 + 31) = 4;
  *(_QWORD *)v226 = off_1E0E15230;
  *(_QWORD *)(v226 + 8) = 1970038119;
  v229 = a1[1];
  v228 = (unint64_t)a1[2];
  if ((unint64_t)v229 < v228)
  {
    *v229 = v226;
    v230 = (uint64_t)(v229 + 1);
    goto LABEL_235;
  }
  v231 = *a1;
  v232 = (char *)v229 - (char *)*a1;
  v233 = v232 >> 3;
  v234 = (v232 >> 3) + 1;
  if (v234 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v235 = v228 - (_QWORD)v231;
  if (v235 >> 2 > v234)
    v234 = v235 >> 2;
  if ((unint64_t)v235 >= 0x7FFFFFFFFFFFFFF8)
    v236 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v236 = v234;
  if (v236)
  {
    if (v236 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v237 = (char *)operator new(8 * v236);
    v238 = (uint64_t *)&v237[8 * v233];
    v239 = (uint64_t *)&v237[8 * v236];
    *v238 = v227;
    v230 = (uint64_t)(v238 + 1);
    v240 = (char *)((char *)v229 - (char *)v231);
    if (v229 != v231)
      goto LABEL_220;
  }
  else
  {
    v237 = 0;
    v238 = (uint64_t *)(8 * v233);
    v239 = 0;
    *(_QWORD *)(8 * v233) = v227;
    v230 = 8 * v233 + 8;
    v240 = (char *)((char *)v229 - (char *)v231);
    if (v229 != v231)
    {
LABEL_220:
      v241 = (unint64_t)(v240 - 8);
      if (v241 < 0x78
        || (uint64_t *)((char *)v229 - (v241 & 0xFFFFFFFFFFFFFFF8) - 8) < v238
        && &v237[v232 - (v241 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v229)
      {
        goto LABEL_1680;
      }
      v242 = (v241 >> 3) + 1;
      v243 = 8 * (v242 & 0x3FFFFFFFFFFFFFFCLL);
      v238 = (uint64_t *)((char *)v238 - v243);
      v244 = &v229[v243 / 0xFFFFFFFFFFFFFFF8];
      v245 = v229 - 2;
      v246 = &v237[8 * v233 - 16];
      v247 = v242 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v249 = *((_OWORD *)v245 - 1);
        v248 = *(_OWORD *)v245;
        *((_OWORD *)v245 - 1) = 0uLL;
        *(_OWORD *)v245 = 0uLL;
        *((_OWORD *)v246 - 1) = v249;
        *(_OWORD *)v246 = v248;
        v245 -= 4;
        v246 -= 32;
        v247 -= 4;
      }
      while (v247);
      v229 = v244;
      if (v242 != (v242 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1680:
        do
        {
          v250 = *--v229;
          *v229 = 0;
          *--v238 = v250;
        }
        while (v229 != v231);
      }
      v229 = *a1;
      v251 = a1[1];
      *a1 = v238;
      a1[1] = (uint64_t *)v230;
      a1[2] = v239;
      while (v251 != v229)
      {
        v253 = *--v251;
        v252 = v253;
        *v251 = 0;
        if (v253)
          (*(void (**)(uint64_t))(*(_QWORD *)v252 + 8))(v252);
      }
      goto LABEL_233;
    }
  }
  *a1 = v238;
  a1[1] = (uint64_t *)v230;
  a1[2] = v239;
LABEL_233:
  if (v229)
    operator delete(v229);
LABEL_235:
  a1[1] = (uint64_t *)v230;
  v254 = operator new();
  v255 = v254;
  strcpy((char *)(v254 + 8), "innerproduct");
  *(_BYTE *)(v254 + 21) = 0;
  *(_WORD *)(v254 + 22) = 0;
  *(_BYTE *)(v254 + 31) = 12;
  *(_QWORD *)v254 = off_1E0E17DD8;
  v257 = a1[1];
  v256 = (unint64_t)a1[2];
  if ((unint64_t)v257 < v256)
  {
    *v257 = v254;
    v258 = (uint64_t)(v257 + 1);
    goto LABEL_261;
  }
  v259 = *a1;
  v260 = (char *)v257 - (char *)*a1;
  v261 = v260 >> 3;
  v262 = (v260 >> 3) + 1;
  if (v262 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v263 = v256 - (_QWORD)v259;
  if (v263 >> 2 > v262)
    v262 = v263 >> 2;
  if ((unint64_t)v263 >= 0x7FFFFFFFFFFFFFF8)
    v264 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v264 = v262;
  if (v264)
  {
    if (v264 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v265 = (char *)operator new(8 * v264);
    v266 = (uint64_t *)&v265[8 * v261];
    v267 = (uint64_t *)&v265[8 * v264];
    *v266 = v255;
    v258 = (uint64_t)(v266 + 1);
    v268 = (char *)((char *)v257 - (char *)v259);
    if (v257 != v259)
      goto LABEL_246;
  }
  else
  {
    v265 = 0;
    v266 = (uint64_t *)(8 * v261);
    v267 = 0;
    *(_QWORD *)(8 * v261) = v255;
    v258 = 8 * v261 + 8;
    v268 = (char *)((char *)v257 - (char *)v259);
    if (v257 != v259)
    {
LABEL_246:
      v269 = (unint64_t)(v268 - 8);
      if (v269 < 0x78
        || (uint64_t *)((char *)v257 - (v269 & 0xFFFFFFFFFFFFFFF8) - 8) < v266
        && &v265[v260 - (v269 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v257)
      {
        goto LABEL_1681;
      }
      v270 = (v269 >> 3) + 1;
      v271 = 8 * (v270 & 0x3FFFFFFFFFFFFFFCLL);
      v266 = (uint64_t *)((char *)v266 - v271);
      v272 = &v257[v271 / 0xFFFFFFFFFFFFFFF8];
      v273 = v257 - 2;
      v274 = &v265[8 * v261 - 16];
      v275 = v270 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v277 = *((_OWORD *)v273 - 1);
        v276 = *(_OWORD *)v273;
        *((_OWORD *)v273 - 1) = 0uLL;
        *(_OWORD *)v273 = 0uLL;
        *((_OWORD *)v274 - 1) = v277;
        *(_OWORD *)v274 = v276;
        v273 -= 4;
        v274 -= 32;
        v275 -= 4;
      }
      while (v275);
      v257 = v272;
      if (v270 != (v270 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1681:
        do
        {
          v278 = *--v257;
          *v257 = 0;
          *--v266 = v278;
        }
        while (v257 != v259);
      }
      v257 = *a1;
      v279 = a1[1];
      *a1 = v266;
      a1[1] = (uint64_t *)v258;
      a1[2] = v267;
      while (v279 != v257)
      {
        v281 = *--v279;
        v280 = v281;
        *v279 = 0;
        if (v281)
          (*(void (**)(uint64_t))(*(_QWORD *)v280 + 8))(v280);
      }
      goto LABEL_259;
    }
  }
  *a1 = v266;
  a1[1] = (uint64_t *)v258;
  a1[2] = v267;
LABEL_259:
  if (v257)
    operator delete(v257);
LABEL_261:
  a1[1] = (uint64_t *)v258;
  v282 = operator new();
  v283 = v282;
  strcpy((char *)(v282 + 8), "instance_norm");
  *(_WORD *)(v282 + 22) = 0;
  *(_BYTE *)(v282 + 31) = 13;
  *(_QWORD *)v282 = off_1E0E17E00;
  v285 = a1[1];
  v284 = (unint64_t)a1[2];
  if ((unint64_t)v285 < v284)
  {
    *v285 = v282;
    v286 = (uint64_t)(v285 + 1);
    goto LABEL_287;
  }
  v287 = *a1;
  v288 = (char *)v285 - (char *)*a1;
  v289 = v288 >> 3;
  v290 = (v288 >> 3) + 1;
  if (v290 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v291 = v284 - (_QWORD)v287;
  if (v291 >> 2 > v290)
    v290 = v291 >> 2;
  if ((unint64_t)v291 >= 0x7FFFFFFFFFFFFFF8)
    v292 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v292 = v290;
  if (v292)
  {
    if (v292 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v293 = (char *)operator new(8 * v292);
    v294 = (uint64_t *)&v293[8 * v289];
    v295 = (uint64_t *)&v293[8 * v292];
    *v294 = v283;
    v286 = (uint64_t)(v294 + 1);
    v296 = (char *)((char *)v285 - (char *)v287);
    if (v285 != v287)
      goto LABEL_272;
  }
  else
  {
    v293 = 0;
    v294 = (uint64_t *)(8 * v289);
    v295 = 0;
    *(_QWORD *)(8 * v289) = v283;
    v286 = 8 * v289 + 8;
    v296 = (char *)((char *)v285 - (char *)v287);
    if (v285 != v287)
    {
LABEL_272:
      v297 = (unint64_t)(v296 - 8);
      if (v297 < 0x78
        || (uint64_t *)((char *)v285 - (v297 & 0xFFFFFFFFFFFFFFF8) - 8) < v294
        && &v293[v288 - (v297 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v285)
      {
        goto LABEL_1682;
      }
      v298 = (v297 >> 3) + 1;
      v299 = 8 * (v298 & 0x3FFFFFFFFFFFFFFCLL);
      v294 = (uint64_t *)((char *)v294 - v299);
      v300 = &v285[v299 / 0xFFFFFFFFFFFFFFF8];
      v301 = v285 - 2;
      v302 = &v293[8 * v289 - 16];
      v303 = v298 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v305 = *((_OWORD *)v301 - 1);
        v304 = *(_OWORD *)v301;
        *((_OWORD *)v301 - 1) = 0uLL;
        *(_OWORD *)v301 = 0uLL;
        *((_OWORD *)v302 - 1) = v305;
        *(_OWORD *)v302 = v304;
        v301 -= 4;
        v302 -= 32;
        v303 -= 4;
      }
      while (v303);
      v285 = v300;
      if (v298 != (v298 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1682:
        do
        {
          v306 = *--v285;
          *v285 = 0;
          *--v294 = v306;
        }
        while (v285 != v287);
      }
      v285 = *a1;
      v307 = a1[1];
      *a1 = v294;
      a1[1] = (uint64_t *)v286;
      a1[2] = v295;
      while (v307 != v285)
      {
        v309 = *--v307;
        v308 = v309;
        *v307 = 0;
        if (v309)
          (*(void (**)(uint64_t))(*(_QWORD *)v308 + 8))(v308);
      }
      goto LABEL_285;
    }
  }
  *a1 = v294;
  a1[1] = (uint64_t *)v286;
  a1[2] = v295;
LABEL_285:
  if (v285)
    operator delete(v285);
LABEL_287:
  a1[1] = (uint64_t *)v286;
  v310 = operator new();
  v311 = v310;
  *(_QWORD *)(v310 + 8) = 0x6F6E5F726579616CLL;
  *(_QWORD *)(v310 + 16) = 28018;
  *(_BYTE *)(v310 + 31) = 10;
  *(_QWORD *)v310 = off_1E0E16098;
  v313 = a1[1];
  v312 = (unint64_t)a1[2];
  if ((unint64_t)v313 < v312)
  {
    *v313 = v310;
    v314 = (uint64_t)(v313 + 1);
    goto LABEL_313;
  }
  v315 = *a1;
  v316 = (char *)v313 - (char *)*a1;
  v317 = v316 >> 3;
  v318 = (v316 >> 3) + 1;
  if (v318 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v319 = v312 - (_QWORD)v315;
  if (v319 >> 2 > v318)
    v318 = v319 >> 2;
  if ((unint64_t)v319 >= 0x7FFFFFFFFFFFFFF8)
    v320 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v320 = v318;
  if (v320)
  {
    if (v320 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v321 = (char *)operator new(8 * v320);
    v322 = (uint64_t *)&v321[8 * v317];
    v323 = (uint64_t *)&v321[8 * v320];
    *v322 = v311;
    v314 = (uint64_t)(v322 + 1);
    v324 = (char *)((char *)v313 - (char *)v315);
    if (v313 != v315)
      goto LABEL_298;
  }
  else
  {
    v321 = 0;
    v322 = (uint64_t *)(8 * v317);
    v323 = 0;
    *(_QWORD *)(8 * v317) = v311;
    v314 = 8 * v317 + 8;
    v324 = (char *)((char *)v313 - (char *)v315);
    if (v313 != v315)
    {
LABEL_298:
      v325 = (unint64_t)(v324 - 8);
      if (v325 < 0x78
        || (uint64_t *)((char *)v313 - (v325 & 0xFFFFFFFFFFFFFFF8) - 8) < v322
        && &v321[v316 - (v325 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v313)
      {
        goto LABEL_1683;
      }
      v326 = (v325 >> 3) + 1;
      v327 = 8 * (v326 & 0x3FFFFFFFFFFFFFFCLL);
      v322 = (uint64_t *)((char *)v322 - v327);
      v328 = &v313[v327 / 0xFFFFFFFFFFFFFFF8];
      v329 = v313 - 2;
      v330 = &v321[8 * v317 - 16];
      v331 = v326 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v333 = *((_OWORD *)v329 - 1);
        v332 = *(_OWORD *)v329;
        *((_OWORD *)v329 - 1) = 0uLL;
        *(_OWORD *)v329 = 0uLL;
        *((_OWORD *)v330 - 1) = v333;
        *(_OWORD *)v330 = v332;
        v329 -= 4;
        v330 -= 32;
        v331 -= 4;
      }
      while (v331);
      v313 = v328;
      if (v326 != (v326 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1683:
        do
        {
          v334 = *--v313;
          *v313 = 0;
          *--v322 = v334;
        }
        while (v313 != v315);
      }
      v313 = *a1;
      v335 = a1[1];
      *a1 = v322;
      a1[1] = (uint64_t *)v314;
      a1[2] = v323;
      while (v335 != v313)
      {
        v337 = *--v335;
        v336 = v337;
        *v335 = 0;
        if (v337)
          (*(void (**)(uint64_t))(*(_QWORD *)v336 + 8))(v336);
      }
      goto LABEL_311;
    }
  }
  *a1 = v322;
  a1[1] = (uint64_t *)v314;
  a1[2] = v323;
LABEL_311:
  if (v313)
    operator delete(v313);
LABEL_313:
  a1[1] = (uint64_t *)v314;
  v338 = operator new();
  v339 = v338;
  *(_BYTE *)(v338 + 31) = 6;
  *(_QWORD *)v338 = off_1E0E158E8;
  *(_QWORD *)(v338 + 8) = 0x7261656E696CLL;
  v341 = a1[1];
  v340 = (unint64_t)a1[2];
  if ((unint64_t)v341 < v340)
  {
    *v341 = v338;
    v342 = (uint64_t)(v341 + 1);
    goto LABEL_339;
  }
  v343 = *a1;
  v344 = (char *)v341 - (char *)*a1;
  v345 = v344 >> 3;
  v346 = (v344 >> 3) + 1;
  if (v346 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v347 = v340 - (_QWORD)v343;
  if (v347 >> 2 > v346)
    v346 = v347 >> 2;
  if ((unint64_t)v347 >= 0x7FFFFFFFFFFFFFF8)
    v348 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v348 = v346;
  if (v348)
  {
    if (v348 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v349 = (char *)operator new(8 * v348);
    v350 = (uint64_t *)&v349[8 * v345];
    v351 = (uint64_t *)&v349[8 * v348];
    *v350 = v339;
    v342 = (uint64_t)(v350 + 1);
    v352 = (char *)((char *)v341 - (char *)v343);
    if (v341 != v343)
      goto LABEL_324;
  }
  else
  {
    v349 = 0;
    v350 = (uint64_t *)(8 * v345);
    v351 = 0;
    *(_QWORD *)(8 * v345) = v339;
    v342 = 8 * v345 + 8;
    v352 = (char *)((char *)v341 - (char *)v343);
    if (v341 != v343)
    {
LABEL_324:
      v353 = (unint64_t)(v352 - 8);
      if (v353 < 0x78
        || (uint64_t *)((char *)v341 - (v353 & 0xFFFFFFFFFFFFFFF8) - 8) < v350
        && &v349[v344 - (v353 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v341)
      {
        goto LABEL_1684;
      }
      v354 = (v353 >> 3) + 1;
      v355 = 8 * (v354 & 0x3FFFFFFFFFFFFFFCLL);
      v350 = (uint64_t *)((char *)v350 - v355);
      v356 = &v341[v355 / 0xFFFFFFFFFFFFFFF8];
      v357 = v341 - 2;
      v358 = &v349[8 * v345 - 16];
      v359 = v354 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v361 = *((_OWORD *)v357 - 1);
        v360 = *(_OWORD *)v357;
        *((_OWORD *)v357 - 1) = 0uLL;
        *(_OWORD *)v357 = 0uLL;
        *((_OWORD *)v358 - 1) = v361;
        *(_OWORD *)v358 = v360;
        v357 -= 4;
        v358 -= 32;
        v359 -= 4;
      }
      while (v359);
      v341 = v356;
      if (v354 != (v354 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1684:
        do
        {
          v362 = *--v341;
          *v341 = 0;
          *--v350 = v362;
        }
        while (v341 != v343);
      }
      v341 = *a1;
      v363 = a1[1];
      *a1 = v350;
      a1[1] = (uint64_t *)v342;
      a1[2] = v351;
      while (v363 != v341)
      {
        v365 = *--v363;
        v364 = v365;
        *v363 = 0;
        if (v365)
          (*(void (**)(uint64_t))(*(_QWORD *)v364 + 8))(v364);
      }
      goto LABEL_337;
    }
  }
  *a1 = v350;
  a1[1] = (uint64_t *)v342;
  a1[2] = v351;
LABEL_337:
  if (v341)
    operator delete(v341);
LABEL_339:
  a1[1] = (uint64_t *)v342;
  v366 = operator new();
  v367 = v366;
  strcpy((char *)(v366 + 8), "local_response_norm");
  *(_BYTE *)(v366 + 31) = 19;
  *(_QWORD *)v366 = off_1E0E194F0;
  v369 = a1[1];
  v368 = (unint64_t)a1[2];
  if ((unint64_t)v369 < v368)
  {
    *v369 = v366;
    v370 = (uint64_t)(v369 + 1);
    goto LABEL_365;
  }
  v371 = *a1;
  v372 = (char *)v369 - (char *)*a1;
  v373 = v372 >> 3;
  v374 = (v372 >> 3) + 1;
  if (v374 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v375 = v368 - (_QWORD)v371;
  if (v375 >> 2 > v374)
    v374 = v375 >> 2;
  if ((unint64_t)v375 >= 0x7FFFFFFFFFFFFFF8)
    v376 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v376 = v374;
  if (v376)
  {
    if (v376 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v377 = (char *)operator new(8 * v376);
    v378 = (uint64_t *)&v377[8 * v373];
    v379 = (uint64_t *)&v377[8 * v376];
    *v378 = v367;
    v370 = (uint64_t)(v378 + 1);
    v380 = (char *)((char *)v369 - (char *)v371);
    if (v369 != v371)
      goto LABEL_350;
  }
  else
  {
    v377 = 0;
    v378 = (uint64_t *)(8 * v373);
    v379 = 0;
    *(_QWORD *)(8 * v373) = v367;
    v370 = 8 * v373 + 8;
    v380 = (char *)((char *)v369 - (char *)v371);
    if (v369 != v371)
    {
LABEL_350:
      v381 = (unint64_t)(v380 - 8);
      if (v381 < 0x78
        || (uint64_t *)((char *)v369 - (v381 & 0xFFFFFFFFFFFFFFF8) - 8) < v378
        && &v377[v372 - (v381 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v369)
      {
        goto LABEL_1685;
      }
      v382 = (v381 >> 3) + 1;
      v383 = 8 * (v382 & 0x3FFFFFFFFFFFFFFCLL);
      v378 = (uint64_t *)((char *)v378 - v383);
      v384 = &v369[v383 / 0xFFFFFFFFFFFFFFF8];
      v385 = v369 - 2;
      v386 = &v377[8 * v373 - 16];
      v387 = v382 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v389 = *((_OWORD *)v385 - 1);
        v388 = *(_OWORD *)v385;
        *((_OWORD *)v385 - 1) = 0uLL;
        *(_OWORD *)v385 = 0uLL;
        *((_OWORD *)v386 - 1) = v389;
        *(_OWORD *)v386 = v388;
        v385 -= 4;
        v386 -= 32;
        v387 -= 4;
      }
      while (v387);
      v369 = v384;
      if (v382 != (v382 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1685:
        do
        {
          v390 = *--v369;
          *v369 = 0;
          *--v378 = v390;
        }
        while (v369 != v371);
      }
      v369 = *a1;
      v391 = a1[1];
      *a1 = v378;
      a1[1] = (uint64_t *)v370;
      a1[2] = v379;
      while (v391 != v369)
      {
        v393 = *--v391;
        v392 = v393;
        *v391 = 0;
        if (v393)
          (*(void (**)(uint64_t))(*(_QWORD *)v392 + 8))(v392);
      }
      goto LABEL_363;
    }
  }
  *a1 = v378;
  a1[1] = (uint64_t *)v370;
  a1[2] = v379;
LABEL_363:
  if (v369)
    operator delete(v369);
LABEL_365:
  a1[1] = (uint64_t *)v370;
  v394 = operator new();
  v395 = v394;
  *(_BYTE *)(v394 + 31) = 6;
  *(_QWORD *)v394 = off_1E0E15910;
  *(_QWORD *)(v394 + 8) = 0x6C756D74616DLL;
  v397 = a1[1];
  v396 = (unint64_t)a1[2];
  if ((unint64_t)v397 < v396)
  {
    *v397 = v394;
    v398 = (uint64_t)(v397 + 1);
    goto LABEL_391;
  }
  v399 = *a1;
  v400 = (char *)v397 - (char *)*a1;
  v401 = v400 >> 3;
  v402 = (v400 >> 3) + 1;
  if (v402 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v403 = v396 - (_QWORD)v399;
  if (v403 >> 2 > v402)
    v402 = v403 >> 2;
  if ((unint64_t)v403 >= 0x7FFFFFFFFFFFFFF8)
    v404 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v404 = v402;
  if (v404)
  {
    if (v404 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v405 = (char *)operator new(8 * v404);
    v406 = (uint64_t *)&v405[8 * v401];
    v407 = (uint64_t *)&v405[8 * v404];
    *v406 = v395;
    v398 = (uint64_t)(v406 + 1);
    v408 = (char *)((char *)v397 - (char *)v399);
    if (v397 != v399)
      goto LABEL_376;
  }
  else
  {
    v405 = 0;
    v406 = (uint64_t *)(8 * v401);
    v407 = 0;
    *(_QWORD *)(8 * v401) = v395;
    v398 = 8 * v401 + 8;
    v408 = (char *)((char *)v397 - (char *)v399);
    if (v397 != v399)
    {
LABEL_376:
      v409 = (unint64_t)(v408 - 8);
      if (v409 < 0x78
        || (uint64_t *)((char *)v397 - (v409 & 0xFFFFFFFFFFFFFFF8) - 8) < v406
        && &v405[v400 - (v409 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v397)
      {
        goto LABEL_1686;
      }
      v410 = (v409 >> 3) + 1;
      v411 = 8 * (v410 & 0x3FFFFFFFFFFFFFFCLL);
      v406 = (uint64_t *)((char *)v406 - v411);
      v412 = &v397[v411 / 0xFFFFFFFFFFFFFFF8];
      v413 = v397 - 2;
      v414 = &v405[8 * v401 - 16];
      v415 = v410 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v417 = *((_OWORD *)v413 - 1);
        v416 = *(_OWORD *)v413;
        *((_OWORD *)v413 - 1) = 0uLL;
        *(_OWORD *)v413 = 0uLL;
        *((_OWORD *)v414 - 1) = v417;
        *(_OWORD *)v414 = v416;
        v413 -= 4;
        v414 -= 32;
        v415 -= 4;
      }
      while (v415);
      v397 = v412;
      if (v410 != (v410 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1686:
        do
        {
          v418 = *--v397;
          *v397 = 0;
          *--v406 = v418;
        }
        while (v397 != v399);
      }
      v397 = *a1;
      v419 = a1[1];
      *a1 = v406;
      a1[1] = (uint64_t *)v398;
      a1[2] = v407;
      while (v419 != v397)
      {
        v421 = *--v419;
        v420 = v421;
        *v419 = 0;
        if (v421)
          (*(void (**)(uint64_t))(*(_QWORD *)v420 + 8))(v420);
      }
      goto LABEL_389;
    }
  }
  *a1 = v406;
  a1[1] = (uint64_t *)v398;
  a1[2] = v407;
LABEL_389:
  if (v397)
    operator delete(v397);
LABEL_391:
  a1[1] = (uint64_t *)v398;
  v422 = operator new();
  v423 = v422;
  *(_BYTE *)(v422 + 31) = 7;
  *(_QWORD *)v422 = &unk_1E0E4F310;
  *(_QWORD *)(v422 + 8) = 0x74726F73677261;
  v425 = a1[1];
  v424 = (unint64_t)a1[2];
  if ((unint64_t)v425 < v424)
  {
    *v425 = v422;
    v426 = (uint64_t)(v425 + 1);
    goto LABEL_417;
  }
  v427 = *a1;
  v428 = (char *)v425 - (char *)*a1;
  v429 = v428 >> 3;
  v430 = (v428 >> 3) + 1;
  if (v430 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v431 = v424 - (_QWORD)v427;
  if (v431 >> 2 > v430)
    v430 = v431 >> 2;
  if ((unint64_t)v431 >= 0x7FFFFFFFFFFFFFF8)
    v432 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v432 = v430;
  if (v432)
  {
    if (v432 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v433 = (char *)operator new(8 * v432);
    v434 = (uint64_t *)&v433[8 * v429];
    v435 = (uint64_t *)&v433[8 * v432];
    *v434 = v423;
    v426 = (uint64_t)(v434 + 1);
    v436 = (char *)((char *)v425 - (char *)v427);
    if (v425 != v427)
      goto LABEL_402;
  }
  else
  {
    v433 = 0;
    v434 = (uint64_t *)(8 * v429);
    v435 = 0;
    *(_QWORD *)(8 * v429) = v423;
    v426 = 8 * v429 + 8;
    v436 = (char *)((char *)v425 - (char *)v427);
    if (v425 != v427)
    {
LABEL_402:
      v437 = (unint64_t)(v436 - 8);
      if (v437 < 0x78
        || (uint64_t *)((char *)v425 - (v437 & 0xFFFFFFFFFFFFFFF8) - 8) < v434
        && &v433[v428 - (v437 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v425)
      {
        goto LABEL_1687;
      }
      v438 = (v437 >> 3) + 1;
      v439 = 8 * (v438 & 0x3FFFFFFFFFFFFFFCLL);
      v434 = (uint64_t *)((char *)v434 - v439);
      v440 = &v425[v439 / 0xFFFFFFFFFFFFFFF8];
      v441 = v425 - 2;
      v442 = &v433[8 * v429 - 16];
      v443 = v438 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v445 = *((_OWORD *)v441 - 1);
        v444 = *(_OWORD *)v441;
        *((_OWORD *)v441 - 1) = 0uLL;
        *(_OWORD *)v441 = 0uLL;
        *((_OWORD *)v442 - 1) = v445;
        *(_OWORD *)v442 = v444;
        v441 -= 4;
        v442 -= 32;
        v443 -= 4;
      }
      while (v443);
      v425 = v440;
      if (v438 != (v438 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1687:
        do
        {
          v446 = *--v425;
          *v425 = 0;
          *--v434 = v446;
        }
        while (v425 != v427);
      }
      v425 = *a1;
      v447 = a1[1];
      *a1 = v434;
      a1[1] = (uint64_t *)v426;
      a1[2] = v435;
      while (v447 != v425)
      {
        v449 = *--v447;
        v448 = v449;
        *v447 = 0;
        if (v449)
          (*(void (**)(uint64_t))(*(_QWORD *)v448 + 8))(v448);
      }
      goto LABEL_415;
    }
  }
  *a1 = v434;
  a1[1] = (uint64_t *)v426;
  a1[2] = v435;
LABEL_415:
  if (v425)
    operator delete(v425);
LABEL_417:
  a1[1] = (uint64_t *)v426;
  v450 = operator new();
  *(_BYTE *)(v450 + 31) = 4;
  *(_QWORD *)v450 = &unk_1E0E4F4F0;
  *(_QWORD *)(v450 + 8) = 1986948963;
  v1660 = v450;
  v451 = a1[1];
  if (v451 >= a1[2])
  {
    v452 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v453 = v1660;
    a1[1] = v452;
    if (v453)
      (*(void (**)(uint64_t))(*(_QWORD *)v453 + 8))(v453);
  }
  else
  {
    *v451 = v450;
    a1[1] = v451 + 1;
  }
  v454 = operator new();
  strcpy((char *)(v454 + 8), "conv_transpose");
  *(_BYTE *)(v454 + 23) = 0;
  *(_BYTE *)(v454 + 31) = 14;
  *(_QWORD *)v454 = &unk_1E0E4F4F0;
  v1660 = v454;
  v455 = a1[1];
  if (v455 >= a1[2])
  {
    v456 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v457 = v1660;
    a1[1] = v456;
    if (v457)
      (*(void (**)(uint64_t))(*(_QWORD *)v457 + 8))(v457);
  }
  else
  {
    *v455 = v454;
    a1[1] = v455 + 1;
  }
  v458 = operator new();
  *(_BYTE *)(v458 + 23) = 0;
  *(_BYTE *)(v458 + 31) = 14;
  *(_QWORD *)v458 = &unk_1E0E4F5E0;
  strcpy((char *)(v458 + 8), "constexpr_cast");
  v1660 = v458;
  v459 = a1[1];
  if (v459 >= a1[2])
  {
    v460 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v461 = v1660;
    a1[1] = v460;
    if (v461)
      (*(void (**)(uint64_t))(*(_QWORD *)v461 + 8))(v461);
  }
  else
  {
    *v459 = v458;
    a1[1] = v459 + 1;
  }
  v462 = operator new();
  v463 = (char *)operator new(0x20uLL);
  strcpy(v463, "constexpr_affine_dequantize");
  *(_QWORD *)v462 = &unk_1E0E138C8;
  std::string::__init_copy_ctor_external((std::string *)(v462 + 8), v463, 0x1BuLL);
  *(_QWORD *)v462 = &unk_1E0E4F5E0;
  v1660 = v462;
  operator delete(v463);
  v464 = a1[1];
  if (v464 >= a1[2])
  {
    v465 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v466 = v1660;
    a1[1] = v465;
    if (v466)
      (*(void (**)(uint64_t))(*(_QWORD *)v466 + 8))(v466);
  }
  else
  {
    *v464 = v462;
    a1[1] = v464 + 1;
  }
  v467 = operator new();
  *(_BYTE *)(v467 + 31) = 22;
  *(_QWORD *)v467 = &unk_1E0E4F5E0;
  strcpy((char *)(v467 + 8), "constexpr_lut_to_dense");
  v1660 = v467;
  v468 = a1[1];
  if (v468 >= a1[2])
  {
    v469 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v470 = v1660;
    a1[1] = v469;
    if (v470)
      (*(void (**)(uint64_t))(*(_QWORD *)v470 + 8))(v470);
  }
  else
  {
    *v468 = v467;
    a1[1] = v468 + 1;
  }
  v471 = operator new();
  v472 = (char *)operator new(0x19uLL);
  strcpy(v472, "constexpr_lut_to_sparse");
  *(_QWORD *)v471 = &unk_1E0E138C8;
  std::string::__init_copy_ctor_external((std::string *)(v471 + 8), v472, 0x17uLL);
  *(_QWORD *)v471 = &unk_1E0E4F5E0;
  v1660 = v471;
  operator delete(v472);
  v473 = a1[1];
  if (v473 >= a1[2])
  {
    v474 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v475 = v1660;
    a1[1] = v474;
    if (v475)
      (*(void (**)(uint64_t))(*(_QWORD *)v475 + 8))(v475);
  }
  else
  {
    *v473 = v471;
    a1[1] = v473 + 1;
  }
  v476 = operator new();
  v477 = (char *)operator new(0x20uLL);
  strcpy(v477, "constexpr_sparse_to_dense");
  *(_QWORD *)v476 = &unk_1E0E138C8;
  std::string::__init_copy_ctor_external((std::string *)(v476 + 8), v477, 0x19uLL);
  *(_QWORD *)v476 = &unk_1E0E4F5E0;
  v1660 = v476;
  operator delete(v477);
  v478 = a1[1];
  if (v478 >= a1[2])
  {
    v479 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v480 = v1660;
    a1[1] = v479;
    if (v480)
      (*(void (**)(uint64_t))(*(_QWORD *)v480 + 8))(v480);
  }
  else
  {
    *v478 = v476;
    a1[1] = v478 + 1;
  }
  v481 = operator new();
  v482 = (char *)operator new(0x20uLL);
  strcpy(v482, "constexpr_blockwise_shift_scale");
  *(_QWORD *)v481 = &unk_1E0E138C8;
  std::string::__init_copy_ctor_external((std::string *)(v481 + 8), v482, 0x1FuLL);
  *(_QWORD *)v481 = &unk_1E0E4F5E0;
  v1660 = v481;
  operator delete(v482);
  v483 = a1[1];
  if (v483 >= a1[2])
  {
    v484 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v485 = v1660;
    a1[1] = v484;
    if (v485)
      (*(void (**)(uint64_t))(*(_QWORD *)v485 + 8))(v485);
  }
  else
  {
    *v483 = v481;
    a1[1] = v483 + 1;
  }
  v486 = operator new();
  v487 = (char *)operator new(0x28uLL);
  strcpy(v487, "constexpr_sparse_blockwise_shift_scale");
  *(_QWORD *)v486 = &unk_1E0E138C8;
  std::string::__init_copy_ctor_external((std::string *)(v486 + 8), v487, 0x26uLL);
  *(_QWORD *)v486 = &unk_1E0E4F5E0;
  v1660 = v486;
  operator delete(v487);
  v488 = a1[1];
  if (v488 >= a1[2])
  {
    v489 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v490 = v1660;
    a1[1] = v489;
    if (v490)
      (*(void (**)(uint64_t))(*(_QWORD *)v490 + 8))(v490);
  }
  else
  {
    *v488 = v486;
    a1[1] = v488 + 1;
  }
  v491 = operator new();
  v492 = v491;
  *(_BYTE *)(v491 + 31) = 4;
  *(_QWORD *)v491 = &unk_1E0E4F180;
  *(_QWORD *)(v491 + 8) = 1886351971;
  v494 = a1[1];
  v493 = (unint64_t)a1[2];
  if ((unint64_t)v494 < v493)
  {
    *v494 = v491;
    v495 = (uint64_t)(v494 + 1);
    goto LABEL_479;
  }
  v496 = *a1;
  v497 = (char *)v494 - (char *)*a1;
  v498 = v497 >> 3;
  v499 = (v497 >> 3) + 1;
  if (v499 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v500 = v493 - (_QWORD)v496;
  if (v500 >> 2 > v499)
    v499 = v500 >> 2;
  if ((unint64_t)v500 >= 0x7FFFFFFFFFFFFFF8)
    v501 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v501 = v499;
  if (v501)
  {
    if (v501 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v502 = (char *)operator new(8 * v501);
    v503 = (uint64_t *)&v502[8 * v498];
    v504 = (uint64_t *)&v502[8 * v501];
    *v503 = v492;
    v495 = (uint64_t)(v503 + 1);
    v505 = (char *)((char *)v494 - (char *)v496);
    if (v494 != v496)
      goto LABEL_464;
  }
  else
  {
    v502 = 0;
    v503 = (uint64_t *)(8 * v498);
    v504 = 0;
    *(_QWORD *)(8 * v498) = v492;
    v495 = 8 * v498 + 8;
    v505 = (char *)((char *)v494 - (char *)v496);
    if (v494 != v496)
    {
LABEL_464:
      v506 = (unint64_t)(v505 - 8);
      if (v506 < 0x78
        || (uint64_t *)((char *)v494 - (v506 & 0xFFFFFFFFFFFFFFF8) - 8) < v503
        && &v502[v497 - (v506 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v494)
      {
        goto LABEL_1688;
      }
      v507 = (v506 >> 3) + 1;
      v508 = 8 * (v507 & 0x3FFFFFFFFFFFFFFCLL);
      v503 = (uint64_t *)((char *)v503 - v508);
      v509 = &v494[v508 / 0xFFFFFFFFFFFFFFF8];
      v510 = v494 - 2;
      v511 = &v502[8 * v498 - 16];
      v512 = v507 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v514 = *((_OWORD *)v510 - 1);
        v513 = *(_OWORD *)v510;
        *((_OWORD *)v510 - 1) = 0uLL;
        *(_OWORD *)v510 = 0uLL;
        *((_OWORD *)v511 - 1) = v514;
        *(_OWORD *)v511 = v513;
        v510 -= 4;
        v511 -= 32;
        v512 -= 4;
      }
      while (v512);
      v494 = v509;
      if (v507 != (v507 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1688:
        do
        {
          v515 = *--v494;
          *v494 = 0;
          *--v503 = v515;
        }
        while (v494 != v496);
      }
      v494 = *a1;
      v516 = a1[1];
      *a1 = v503;
      a1[1] = (uint64_t *)v495;
      a1[2] = v504;
      while (v516 != v494)
      {
        v518 = *--v516;
        v517 = v518;
        *v516 = 0;
        if (v518)
          (*(void (**)(uint64_t))(*(_QWORD *)v517 + 8))(v517);
      }
      goto LABEL_477;
    }
  }
  *a1 = v503;
  a1[1] = (uint64_t *)v495;
  a1[2] = v504;
LABEL_477:
  if (v494)
    operator delete(v494);
LABEL_479:
  a1[1] = (uint64_t *)v495;
  v519 = operator new();
  v520 = v519;
  *(_QWORD *)(v519 + 16) = 6650473;
  *(_BYTE *)(v519 + 31) = 11;
  *(_QWORD *)v519 = &unk_1E0E4F4A0;
  *(_QWORD *)(v519 + 8) = 0x7365725F706F7263;
  v522 = a1[1];
  v521 = (unint64_t)a1[2];
  if ((unint64_t)v522 < v521)
  {
    *v522 = v519;
    v523 = (uint64_t)(v522 + 1);
    goto LABEL_505;
  }
  v524 = *a1;
  v525 = (char *)v522 - (char *)*a1;
  v526 = v525 >> 3;
  v527 = (v525 >> 3) + 1;
  if (v527 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v528 = v521 - (_QWORD)v524;
  if (v528 >> 2 > v527)
    v527 = v528 >> 2;
  if ((unint64_t)v528 >= 0x7FFFFFFFFFFFFFF8)
    v529 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v529 = v527;
  if (v529)
  {
    if (v529 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v530 = (char *)operator new(8 * v529);
    v531 = (uint64_t *)&v530[8 * v526];
    v532 = (uint64_t *)&v530[8 * v529];
    *v531 = v520;
    v523 = (uint64_t)(v531 + 1);
    v533 = (char *)((char *)v522 - (char *)v524);
    if (v522 != v524)
      goto LABEL_490;
  }
  else
  {
    v530 = 0;
    v531 = (uint64_t *)(8 * v526);
    v532 = 0;
    *(_QWORD *)(8 * v526) = v520;
    v523 = 8 * v526 + 8;
    v533 = (char *)((char *)v522 - (char *)v524);
    if (v522 != v524)
    {
LABEL_490:
      v534 = (unint64_t)(v533 - 8);
      if (v534 < 0x78
        || (uint64_t *)((char *)v522 - (v534 & 0xFFFFFFFFFFFFFFF8) - 8) < v531
        && &v530[v525 - (v534 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v522)
      {
        goto LABEL_1689;
      }
      v535 = (v534 >> 3) + 1;
      v536 = 8 * (v535 & 0x3FFFFFFFFFFFFFFCLL);
      v531 = (uint64_t *)((char *)v531 - v536);
      v537 = &v522[v536 / 0xFFFFFFFFFFFFFFF8];
      v538 = v522 - 2;
      v539 = &v530[8 * v526 - 16];
      v540 = v535 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v542 = *((_OWORD *)v538 - 1);
        v541 = *(_OWORD *)v538;
        *((_OWORD *)v538 - 1) = 0uLL;
        *(_OWORD *)v538 = 0uLL;
        *((_OWORD *)v539 - 1) = v542;
        *(_OWORD *)v539 = v541;
        v538 -= 4;
        v539 -= 32;
        v540 -= 4;
      }
      while (v540);
      v522 = v537;
      if (v535 != (v535 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1689:
        do
        {
          v543 = *--v522;
          *v522 = 0;
          *--v531 = v543;
        }
        while (v522 != v524);
      }
      v522 = *a1;
      v544 = a1[1];
      *a1 = v531;
      a1[1] = (uint64_t *)v523;
      a1[2] = v532;
      while (v544 != v522)
      {
        v546 = *--v544;
        v545 = v546;
        *v544 = 0;
        if (v546)
          (*(void (**)(uint64_t))(*(_QWORD *)v545 + 8))(v545);
      }
      goto LABEL_503;
    }
  }
  *a1 = v531;
  a1[1] = (uint64_t *)v523;
  a1[2] = v532;
LABEL_503:
  if (v522)
    operator delete(v522);
LABEL_505:
  a1[1] = (uint64_t *)v523;
  v547 = operator new();
  v548 = v547;
  *(_QWORD *)(v547 + 16) = 100;
  *(_BYTE *)(v547 + 31) = 9;
  *(_QWORD *)v547 = &unk_1E0E4F428;
  *(_QWORD *)(v547 + 8) = 0x326E657474616C66;
  v550 = a1[1];
  v549 = (unint64_t)a1[2];
  if ((unint64_t)v550 < v549)
  {
    *v550 = v547;
    v551 = (uint64_t)(v550 + 1);
    goto LABEL_531;
  }
  v552 = *a1;
  v553 = (char *)v550 - (char *)*a1;
  v554 = v553 >> 3;
  v555 = (v553 >> 3) + 1;
  if (v555 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v556 = v549 - (_QWORD)v552;
  if (v556 >> 2 > v555)
    v555 = v556 >> 2;
  if ((unint64_t)v556 >= 0x7FFFFFFFFFFFFFF8)
    v557 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v557 = v555;
  if (v557)
  {
    if (v557 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v558 = (char *)operator new(8 * v557);
    v559 = (uint64_t *)&v558[8 * v554];
    v560 = (uint64_t *)&v558[8 * v557];
    *v559 = v548;
    v551 = (uint64_t)(v559 + 1);
    v561 = (char *)((char *)v550 - (char *)v552);
    if (v550 != v552)
      goto LABEL_516;
  }
  else
  {
    v558 = 0;
    v559 = (uint64_t *)(8 * v554);
    v560 = 0;
    *(_QWORD *)(8 * v554) = v548;
    v551 = 8 * v554 + 8;
    v561 = (char *)((char *)v550 - (char *)v552);
    if (v550 != v552)
    {
LABEL_516:
      v562 = (unint64_t)(v561 - 8);
      if (v562 < 0x78
        || (uint64_t *)((char *)v550 - (v562 & 0xFFFFFFFFFFFFFFF8) - 8) < v559
        && &v558[v553 - (v562 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v550)
      {
        goto LABEL_1690;
      }
      v563 = (v562 >> 3) + 1;
      v564 = 8 * (v563 & 0x3FFFFFFFFFFFFFFCLL);
      v559 = (uint64_t *)((char *)v559 - v564);
      v565 = &v550[v564 / 0xFFFFFFFFFFFFFFF8];
      v566 = v550 - 2;
      v567 = &v558[8 * v554 - 16];
      v568 = v563 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v570 = *((_OWORD *)v566 - 1);
        v569 = *(_OWORD *)v566;
        *((_OWORD *)v566 - 1) = 0uLL;
        *(_OWORD *)v566 = 0uLL;
        *((_OWORD *)v567 - 1) = v570;
        *(_OWORD *)v567 = v569;
        v566 -= 4;
        v567 -= 32;
        v568 -= 4;
      }
      while (v568);
      v550 = v565;
      if (v563 != (v563 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1690:
        do
        {
          v571 = *--v550;
          *v550 = 0;
          *--v559 = v571;
        }
        while (v550 != v552);
      }
      v550 = *a1;
      v572 = a1[1];
      *a1 = v559;
      a1[1] = (uint64_t *)v551;
      a1[2] = v560;
      while (v572 != v550)
      {
        v574 = *--v572;
        v573 = v574;
        *v572 = 0;
        if (v574)
          (*(void (**)(uint64_t))(*(_QWORD *)v573 + 8))(v573);
      }
      goto LABEL_529;
    }
  }
  *a1 = v559;
  a1[1] = (uint64_t *)v551;
  a1[2] = v560;
LABEL_529:
  if (v550)
    operator delete(v550);
LABEL_531:
  a1[1] = (uint64_t *)v551;
  v575 = operator new();
  v576 = v575;
  *(_BYTE *)(v575 + 31) = 3;
  *(_QWORD *)v575 = &unk_1E0E4F130;
  *(_QWORD *)(v575 + 8) = 7696999;
  v578 = a1[1];
  v577 = (unint64_t)a1[2];
  if ((unint64_t)v578 < v577)
  {
    *v578 = v575;
    v579 = (uint64_t)(v578 + 1);
    goto LABEL_557;
  }
  v580 = *a1;
  v581 = (char *)v578 - (char *)*a1;
  v582 = v581 >> 3;
  v583 = (v581 >> 3) + 1;
  if (v583 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v584 = v577 - (_QWORD)v580;
  if (v584 >> 2 > v583)
    v583 = v584 >> 2;
  if ((unint64_t)v584 >= 0x7FFFFFFFFFFFFFF8)
    v585 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v585 = v583;
  if (v585)
  {
    if (v585 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v586 = (char *)operator new(8 * v585);
    v587 = (uint64_t *)&v586[8 * v582];
    v588 = (uint64_t *)&v586[8 * v585];
    *v587 = v576;
    v579 = (uint64_t)(v587 + 1);
    v589 = (char *)((char *)v578 - (char *)v580);
    if (v578 != v580)
      goto LABEL_542;
  }
  else
  {
    v586 = 0;
    v587 = (uint64_t *)(8 * v582);
    v588 = 0;
    *(_QWORD *)(8 * v582) = v576;
    v579 = 8 * v582 + 8;
    v589 = (char *)((char *)v578 - (char *)v580);
    if (v578 != v580)
    {
LABEL_542:
      v590 = (unint64_t)(v589 - 8);
      if (v590 < 0x78
        || (uint64_t *)((char *)v578 - (v590 & 0xFFFFFFFFFFFFFFF8) - 8) < v587
        && &v586[v581 - (v590 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v578)
      {
        goto LABEL_1691;
      }
      v591 = (v590 >> 3) + 1;
      v592 = 8 * (v591 & 0x3FFFFFFFFFFFFFFCLL);
      v587 = (uint64_t *)((char *)v587 - v592);
      v593 = &v578[v592 / 0xFFFFFFFFFFFFFFF8];
      v594 = v578 - 2;
      v595 = &v586[8 * v582 - 16];
      v596 = v591 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v598 = *((_OWORD *)v594 - 1);
        v597 = *(_OWORD *)v594;
        *((_OWORD *)v594 - 1) = 0uLL;
        *(_OWORD *)v594 = 0uLL;
        *((_OWORD *)v595 - 1) = v598;
        *(_OWORD *)v595 = v597;
        v594 -= 4;
        v595 -= 32;
        v596 -= 4;
      }
      while (v596);
      v578 = v593;
      if (v591 != (v591 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1691:
        do
        {
          v599 = *--v578;
          *v578 = 0;
          *--v587 = v599;
        }
        while (v578 != v580);
      }
      v578 = *a1;
      v600 = a1[1];
      *a1 = v587;
      a1[1] = (uint64_t *)v579;
      a1[2] = v588;
      while (v600 != v578)
      {
        v602 = *--v600;
        v601 = v602;
        *v600 = 0;
        if (v602)
          (*(void (**)(uint64_t))(*(_QWORD *)v601 + 8))(v601);
      }
      goto LABEL_555;
    }
  }
  *a1 = v587;
  a1[1] = (uint64_t *)v579;
  a1[2] = v588;
LABEL_555:
  if (v578)
    operator delete(v578);
LABEL_557:
  a1[1] = (uint64_t *)v579;
  v603 = operator new();
  v604 = v603;
  *(_BYTE *)(v603 + 31) = 7;
  *(_QWORD *)v603 = &unk_1E0E4F338;
  *(_QWORD *)(v603 + 8) = 0x65737265766E69;
  v606 = a1[1];
  v605 = (unint64_t)a1[2];
  if ((unint64_t)v606 < v605)
  {
    *v606 = v603;
    v607 = (uint64_t)(v606 + 1);
    goto LABEL_583;
  }
  v608 = *a1;
  v609 = (char *)v606 - (char *)*a1;
  v610 = v609 >> 3;
  v611 = (v609 >> 3) + 1;
  if (v611 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v612 = v605 - (_QWORD)v608;
  if (v612 >> 2 > v611)
    v611 = v612 >> 2;
  if ((unint64_t)v612 >= 0x7FFFFFFFFFFFFFF8)
    v613 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v613 = v611;
  if (v613)
  {
    if (v613 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v614 = (char *)operator new(8 * v613);
    v615 = (uint64_t *)&v614[8 * v610];
    v616 = (uint64_t *)&v614[8 * v613];
    *v615 = v604;
    v607 = (uint64_t)(v615 + 1);
    v617 = (char *)((char *)v606 - (char *)v608);
    if (v606 != v608)
      goto LABEL_568;
  }
  else
  {
    v614 = 0;
    v615 = (uint64_t *)(8 * v610);
    v616 = 0;
    *(_QWORD *)(8 * v610) = v604;
    v607 = 8 * v610 + 8;
    v617 = (char *)((char *)v606 - (char *)v608);
    if (v606 != v608)
    {
LABEL_568:
      v618 = (unint64_t)(v617 - 8);
      if (v618 < 0x78
        || (uint64_t *)((char *)v606 - (v618 & 0xFFFFFFFFFFFFFFF8) - 8) < v615
        && &v614[v609 - (v618 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v606)
      {
        goto LABEL_1692;
      }
      v619 = (v618 >> 3) + 1;
      v620 = 8 * (v619 & 0x3FFFFFFFFFFFFFFCLL);
      v615 = (uint64_t *)((char *)v615 - v620);
      v621 = &v606[v620 / 0xFFFFFFFFFFFFFFF8];
      v622 = v606 - 2;
      v623 = &v614[8 * v610 - 16];
      v624 = v619 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v626 = *((_OWORD *)v622 - 1);
        v625 = *(_OWORD *)v622;
        *((_OWORD *)v622 - 1) = 0uLL;
        *(_OWORD *)v622 = 0uLL;
        *((_OWORD *)v623 - 1) = v626;
        *(_OWORD *)v623 = v625;
        v622 -= 4;
        v623 -= 32;
        v624 -= 4;
      }
      while (v624);
      v606 = v621;
      if (v619 != (v619 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1692:
        do
        {
          v627 = *--v606;
          *v606 = 0;
          *--v615 = v627;
        }
        while (v606 != v608);
      }
      v606 = *a1;
      v628 = a1[1];
      *a1 = v615;
      a1[1] = (uint64_t *)v607;
      a1[2] = v616;
      while (v628 != v606)
      {
        v630 = *--v628;
        v629 = v630;
        *v628 = 0;
        if (v630)
          (*(void (**)(uint64_t))(*(_QWORD *)v629 + 8))(v629);
      }
      goto LABEL_581;
    }
  }
  *a1 = v615;
  a1[1] = (uint64_t *)v607;
  a1[2] = v616;
LABEL_581:
  if (v606)
    operator delete(v606);
LABEL_583:
  a1[1] = (uint64_t *)v607;
  v631 = operator new();
  v632 = v631;
  *(_BYTE *)(v631 + 31) = 7;
  *(_QWORD *)v631 = &unk_1E0E4F298;
  *(_QWORD *)(v631 + 8) = 0x6D726F6E5F326CLL;
  v634 = a1[1];
  v633 = (unint64_t)a1[2];
  if ((unint64_t)v634 < v633)
  {
    *v634 = v631;
    v635 = (uint64_t)(v634 + 1);
    goto LABEL_609;
  }
  v636 = *a1;
  v637 = (char *)v634 - (char *)*a1;
  v638 = v637 >> 3;
  v639 = (v637 >> 3) + 1;
  if (v639 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v640 = v633 - (_QWORD)v636;
  if (v640 >> 2 > v639)
    v639 = v640 >> 2;
  if ((unint64_t)v640 >= 0x7FFFFFFFFFFFFFF8)
    v641 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v641 = v639;
  if (v641)
  {
    if (v641 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v642 = (char *)operator new(8 * v641);
    v643 = (uint64_t *)&v642[8 * v638];
    v644 = (uint64_t *)&v642[8 * v641];
    *v643 = v632;
    v635 = (uint64_t)(v643 + 1);
    v645 = (char *)((char *)v634 - (char *)v636);
    if (v634 != v636)
      goto LABEL_594;
  }
  else
  {
    v642 = 0;
    v643 = (uint64_t *)(8 * v638);
    v644 = 0;
    *(_QWORD *)(8 * v638) = v632;
    v635 = 8 * v638 + 8;
    v645 = (char *)((char *)v634 - (char *)v636);
    if (v634 != v636)
    {
LABEL_594:
      v646 = (unint64_t)(v645 - 8);
      if (v646 < 0x78
        || (uint64_t *)((char *)v634 - (v646 & 0xFFFFFFFFFFFFFFF8) - 8) < v643
        && &v642[v637 - (v646 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v634)
      {
        goto LABEL_1693;
      }
      v647 = (v646 >> 3) + 1;
      v648 = 8 * (v647 & 0x3FFFFFFFFFFFFFFCLL);
      v643 = (uint64_t *)((char *)v643 - v648);
      v649 = &v634[v648 / 0xFFFFFFFFFFFFFFF8];
      v650 = v634 - 2;
      v651 = &v642[8 * v638 - 16];
      v652 = v647 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v654 = *((_OWORD *)v650 - 1);
        v653 = *(_OWORD *)v650;
        *((_OWORD *)v650 - 1) = 0uLL;
        *(_OWORD *)v650 = 0uLL;
        *((_OWORD *)v651 - 1) = v654;
        *(_OWORD *)v651 = v653;
        v650 -= 4;
        v651 -= 32;
        v652 -= 4;
      }
      while (v652);
      v634 = v649;
      if (v647 != (v647 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1693:
        do
        {
          v655 = *--v634;
          *v634 = 0;
          *--v643 = v655;
        }
        while (v634 != v636);
      }
      v634 = *a1;
      v656 = a1[1];
      *a1 = v643;
      a1[1] = (uint64_t *)v635;
      a1[2] = v644;
      while (v656 != v634)
      {
        v658 = *--v656;
        v657 = v658;
        *v656 = 0;
        if (v658)
          (*(void (**)(uint64_t))(*(_QWORD *)v657 + 8))(v657);
      }
      goto LABEL_607;
    }
  }
  *a1 = v643;
  a1[1] = (uint64_t *)v635;
  a1[2] = v644;
LABEL_607:
  if (v634)
    operator delete(v634);
LABEL_609:
  a1[1] = (uint64_t *)v635;
  v659 = operator new();
  v660 = v659;
  *(_BYTE *)(v659 + 31) = 3;
  *(_QWORD *)v659 = &unk_1E0E4F450;
  *(_QWORD *)(v659 + 8) = 6778732;
  v662 = a1[1];
  v661 = (unint64_t)a1[2];
  if ((unint64_t)v662 < v661)
  {
    *v662 = v659;
    v663 = (uint64_t)(v662 + 1);
    goto LABEL_635;
  }
  v664 = *a1;
  v665 = (char *)v662 - (char *)*a1;
  v666 = v665 >> 3;
  v667 = (v665 >> 3) + 1;
  if (v667 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v668 = v661 - (_QWORD)v664;
  if (v668 >> 2 > v667)
    v667 = v668 >> 2;
  if ((unint64_t)v668 >= 0x7FFFFFFFFFFFFFF8)
    v669 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v669 = v667;
  if (v669)
  {
    if (v669 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v670 = (char *)operator new(8 * v669);
    v671 = (uint64_t *)&v670[8 * v666];
    v672 = (uint64_t *)&v670[8 * v669];
    *v671 = v660;
    v663 = (uint64_t)(v671 + 1);
    v673 = (char *)((char *)v662 - (char *)v664);
    if (v662 != v664)
      goto LABEL_620;
  }
  else
  {
    v670 = 0;
    v671 = (uint64_t *)(8 * v666);
    v672 = 0;
    *(_QWORD *)(8 * v666) = v660;
    v663 = 8 * v666 + 8;
    v673 = (char *)((char *)v662 - (char *)v664);
    if (v662 != v664)
    {
LABEL_620:
      v674 = (unint64_t)(v673 - 8);
      if (v674 < 0x78
        || (uint64_t *)((char *)v662 - (v674 & 0xFFFFFFFFFFFFFFF8) - 8) < v671
        && &v670[v665 - (v674 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v662)
      {
        goto LABEL_1694;
      }
      v675 = (v674 >> 3) + 1;
      v676 = 8 * (v675 & 0x3FFFFFFFFFFFFFFCLL);
      v671 = (uint64_t *)((char *)v671 - v676);
      v677 = &v662[v676 / 0xFFFFFFFFFFFFFFF8];
      v678 = v662 - 2;
      v679 = &v670[8 * v666 - 16];
      v680 = v675 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v682 = *((_OWORD *)v678 - 1);
        v681 = *(_OWORD *)v678;
        *((_OWORD *)v678 - 1) = 0uLL;
        *(_OWORD *)v678 = 0uLL;
        *((_OWORD *)v679 - 1) = v682;
        *(_OWORD *)v679 = v681;
        v678 -= 4;
        v679 -= 32;
        v680 -= 4;
      }
      while (v680);
      v662 = v677;
      if (v675 != (v675 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1694:
        do
        {
          v683 = *--v662;
          *v662 = 0;
          *--v671 = v683;
        }
        while (v662 != v664);
      }
      v662 = *a1;
      v684 = a1[1];
      *a1 = v671;
      a1[1] = (uint64_t *)v663;
      a1[2] = v672;
      while (v684 != v662)
      {
        v686 = *--v684;
        v685 = v686;
        *v684 = 0;
        if (v686)
          (*(void (**)(uint64_t))(*(_QWORD *)v685 + 8))(v685);
      }
      goto LABEL_633;
    }
  }
  *a1 = v671;
  a1[1] = (uint64_t *)v663;
  a1[2] = v672;
LABEL_633:
  if (v662)
    operator delete(v662);
LABEL_635:
  a1[1] = (uint64_t *)v663;
  v687 = operator new();
  v688 = v687;
  *(_BYTE *)(v687 + 31) = 4;
  *(_QWORD *)v687 = &unk_1E0E4F1A8;
  *(_QWORD *)(v687 + 8) = 1836348268;
  v690 = a1[1];
  v689 = (unint64_t)a1[2];
  if ((unint64_t)v690 < v689)
  {
    *v690 = v687;
    v691 = (uint64_t)(v690 + 1);
    goto LABEL_661;
  }
  v692 = *a1;
  v693 = (char *)v690 - (char *)*a1;
  v694 = v693 >> 3;
  v695 = (v693 >> 3) + 1;
  if (v695 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v696 = v689 - (_QWORD)v692;
  if (v696 >> 2 > v695)
    v695 = v696 >> 2;
  if ((unint64_t)v696 >= 0x7FFFFFFFFFFFFFF8)
    v697 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v697 = v695;
  if (v697)
  {
    if (v697 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v698 = (char *)operator new(8 * v697);
    v699 = (uint64_t *)&v698[8 * v694];
    v700 = (uint64_t *)&v698[8 * v697];
    *v699 = v688;
    v691 = (uint64_t)(v699 + 1);
    v701 = (char *)((char *)v690 - (char *)v692);
    if (v690 != v692)
      goto LABEL_646;
  }
  else
  {
    v698 = 0;
    v699 = (uint64_t *)(8 * v694);
    v700 = 0;
    *(_QWORD *)(8 * v694) = v688;
    v691 = 8 * v694 + 8;
    v701 = (char *)((char *)v690 - (char *)v692);
    if (v690 != v692)
    {
LABEL_646:
      v702 = (unint64_t)(v701 - 8);
      if (v702 < 0x78
        || (uint64_t *)((char *)v690 - (v702 & 0xFFFFFFFFFFFFFFF8) - 8) < v699
        && &v698[v693 - (v702 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v690)
      {
        goto LABEL_1695;
      }
      v703 = (v702 >> 3) + 1;
      v704 = 8 * (v703 & 0x3FFFFFFFFFFFFFFCLL);
      v699 = (uint64_t *)((char *)v699 - v704);
      v705 = &v690[v704 / 0xFFFFFFFFFFFFFFF8];
      v706 = v690 - 2;
      v707 = &v698[8 * v694 - 16];
      v708 = v703 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v710 = *((_OWORD *)v706 - 1);
        v709 = *(_OWORD *)v706;
        *((_OWORD *)v706 - 1) = 0uLL;
        *(_OWORD *)v706 = 0uLL;
        *((_OWORD *)v707 - 1) = v710;
        *(_OWORD *)v707 = v709;
        v706 -= 4;
        v707 -= 32;
        v708 -= 4;
      }
      while (v708);
      v690 = v705;
      if (v703 != (v703 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1695:
        do
        {
          v711 = *--v690;
          *v690 = 0;
          *--v699 = v711;
        }
        while (v690 != v692);
      }
      v690 = *a1;
      v712 = a1[1];
      *a1 = v699;
      a1[1] = (uint64_t *)v691;
      a1[2] = v700;
      while (v712 != v690)
      {
        v714 = *--v712;
        v713 = v714;
        *v712 = 0;
        if (v714)
          (*(void (**)(uint64_t))(*(_QWORD *)v713 + 8))(v713);
      }
      goto LABEL_659;
    }
  }
  *a1 = v699;
  a1[1] = (uint64_t *)v691;
  a1[2] = v700;
LABEL_659:
  if (v690)
    operator delete(v690);
LABEL_661:
  a1[1] = (uint64_t *)v691;
  v715 = operator new();
  v716 = v715;
  *(_BYTE *)(v715 + 31) = 3;
  *(_QWORD *)v715 = &unk_1E0E4F158;
  *(_QWORD *)(v715 + 8) = 6578544;
  v718 = a1[1];
  v717 = (unint64_t)a1[2];
  if ((unint64_t)v718 < v717)
  {
    *v718 = v715;
    v719 = (uint64_t)(v718 + 1);
    goto LABEL_687;
  }
  v720 = *a1;
  v721 = (char *)v718 - (char *)*a1;
  v722 = v721 >> 3;
  v723 = (v721 >> 3) + 1;
  if (v723 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v724 = v717 - (_QWORD)v720;
  if (v724 >> 2 > v723)
    v723 = v724 >> 2;
  if ((unint64_t)v724 >= 0x7FFFFFFFFFFFFFF8)
    v725 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v725 = v723;
  if (v725)
  {
    if (v725 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v726 = (char *)operator new(8 * v725);
    v727 = (uint64_t *)&v726[8 * v722];
    v728 = (uint64_t *)&v726[8 * v725];
    *v727 = v716;
    v719 = (uint64_t)(v727 + 1);
    v729 = (char *)((char *)v718 - (char *)v720);
    if (v718 != v720)
      goto LABEL_672;
  }
  else
  {
    v726 = 0;
    v727 = (uint64_t *)(8 * v722);
    v728 = 0;
    *(_QWORD *)(8 * v722) = v716;
    v719 = 8 * v722 + 8;
    v729 = (char *)((char *)v718 - (char *)v720);
    if (v718 != v720)
    {
LABEL_672:
      v730 = (unint64_t)(v729 - 8);
      if (v730 < 0x78
        || (uint64_t *)((char *)v718 - (v730 & 0xFFFFFFFFFFFFFFF8) - 8) < v727
        && &v726[v721 - (v730 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v718)
      {
        goto LABEL_1696;
      }
      v731 = (v730 >> 3) + 1;
      v732 = 8 * (v731 & 0x3FFFFFFFFFFFFFFCLL);
      v727 = (uint64_t *)((char *)v727 - v732);
      v733 = &v718[v732 / 0xFFFFFFFFFFFFFFF8];
      v734 = v718 - 2;
      v735 = &v726[8 * v722 - 16];
      v736 = v731 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v738 = *((_OWORD *)v734 - 1);
        v737 = *(_OWORD *)v734;
        *((_OWORD *)v734 - 1) = 0uLL;
        *(_OWORD *)v734 = 0uLL;
        *((_OWORD *)v735 - 1) = v738;
        *(_OWORD *)v735 = v737;
        v734 -= 4;
        v735 -= 32;
        v736 -= 4;
      }
      while (v736);
      v718 = v733;
      if (v731 != (v731 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1696:
        do
        {
          v739 = *--v718;
          *v718 = 0;
          *--v727 = v739;
        }
        while (v718 != v720);
      }
      v718 = *a1;
      v740 = a1[1];
      *a1 = v727;
      a1[1] = (uint64_t *)v719;
      a1[2] = v728;
      while (v740 != v718)
      {
        v742 = *--v740;
        v741 = v742;
        *v740 = 0;
        if (v742)
          (*(void (**)(uint64_t))(*(_QWORD *)v741 + 8))(v741);
      }
      goto LABEL_685;
    }
  }
  *a1 = v727;
  a1[1] = (uint64_t *)v719;
  a1[2] = v728;
LABEL_685:
  if (v718)
    operator delete(v718);
LABEL_687:
  a1[1] = (uint64_t *)v719;
  std::make_unique[abi:ne180100]<MILToMLIR::PoolingPattern,char const(&)[9]>(&v1660, "avg_pool");
  v743 = a1[1];
  if (v743 >= a1[2])
  {
    v744 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v745 = v1660;
    a1[1] = v744;
    if (v745)
      (*(void (**)(uint64_t))(*(_QWORD *)v745 + 8))(v745);
  }
  else
  {
    *v743 = v1660;
    a1[1] = v743 + 1;
  }
  v746 = operator new();
  *(_BYTE *)(v746 + 31) = 7;
  *(_QWORD *)v746 = &unk_1E0E4F360;
  *(_QWORD *)(v746 + 8) = 0x6C6F6F705F326CLL;
  v1660 = v746;
  v747 = a1[1];
  if (v747 >= a1[2])
  {
    v748 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v749 = v1660;
    a1[1] = v748;
    if (v749)
      (*(void (**)(uint64_t))(*(_QWORD *)v749 + 8))(v749);
  }
  else
  {
    *v747 = v746;
    a1[1] = v747 + 1;
  }
  std::make_unique[abi:ne180100]<MILToMLIR::PoolingPattern,char const(&)[9]>(&v1660, "max_pool");
  v750 = a1[1];
  if (v750 >= a1[2])
  {
    v751 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v752 = v1660;
    a1[1] = v751;
    if (v752)
      (*(void (**)(uint64_t))(*(_QWORD *)v752 + 8))(v752);
  }
  else
  {
    *v750 = v1660;
    a1[1] = v750 + 1;
  }
  v753 = operator new();
  *(_QWORD *)(v753 + 16) = 25978;
  *(_BYTE *)(v753 + 31) = 10;
  *(_QWORD *)v753 = &unk_1E0E4F3D8;
  *(_QWORD *)(v753 + 8) = 0x69746E6175716564;
  v1660 = v753;
  v754 = a1[1];
  if (v754 >= a1[2])
  {
    v755 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v756 = v1660;
    a1[1] = v755;
    if (v756)
      (*(void (**)(uint64_t))(*(_QWORD *)v756 + 8))(v756);
  }
  else
  {
    *v754 = v753;
    a1[1] = v754 + 1;
  }
  v757 = operator new();
  strcpy((char *)(v757 + 8), "dynamic_dequantize");
  *(_BYTE *)(v757 + 31) = 18;
  *(_QWORD *)v757 = &unk_1E0E4F3D8;
  v1660 = v757;
  v758 = a1[1];
  if (v758 >= a1[2])
  {
    v759 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v760 = v1660;
    a1[1] = v759;
    if (v760)
      (*(void (**)(uint64_t))(*(_QWORD *)v760 + 8))(v760);
  }
  else
  {
    *v758 = v757;
    a1[1] = v758 + 1;
  }
  v761 = operator new();
  strcpy((char *)(v761 + 8), "dynamic_quantize");
  *(_BYTE *)(v761 + 31) = 16;
  *(_QWORD *)v761 = &unk_1E0E4F3D8;
  v1660 = v761;
  v762 = a1[1];
  if (v762 >= a1[2])
  {
    v763 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v764 = v1660;
    a1[1] = v763;
    if (v764)
      (*(void (**)(uint64_t))(*(_QWORD *)v764 + 8))(v764);
  }
  else
  {
    *v762 = v761;
    a1[1] = v762 + 1;
  }
  v765 = operator new();
  *(_QWORD *)(v765 + 8) = 0x657A69746E617571;
  *(_QWORD *)(v765 + 16) = 0;
  *(_BYTE *)(v765 + 31) = 8;
  *(_QWORD *)v765 = &unk_1E0E4F3D8;
  v1660 = v765;
  v766 = a1[1];
  if (v766 >= a1[2])
  {
    v767 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v768 = v1660;
    a1[1] = v767;
    if (v768)
      (*(void (**)(uint64_t))(*(_QWORD *)v768 + 8))(v768);
  }
  else
  {
    *v766 = v765;
    a1[1] = v766 + 1;
  }
  v769 = operator new();
  *(_BYTE *)(v769 + 31) = 16;
  *(_QWORD *)v769 = &unk_1E0E4F2C0;
  strcpy((char *)(v769 + 8), "random_bernoulli");
  v1660 = v769;
  v770 = a1[1];
  if (v770 >= a1[2])
  {
    v771 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v772 = v1660;
    a1[1] = v771;
    if (v772)
      (*(void (**)(uint64_t))(*(_QWORD *)v772 + 8))(v772);
  }
  else
  {
    *v770 = v769;
    a1[1] = v770 + 1;
  }
  v773 = operator new();
  strcpy((char *)(v773 + 8), "random_normal");
  *(_WORD *)(v773 + 22) = 0;
  *(_BYTE *)(v773 + 31) = 13;
  *(_QWORD *)v773 = &unk_1E0E4F2C0;
  v1660 = v773;
  v774 = a1[1];
  if (v774 >= a1[2])
  {
    v775 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v776 = v1660;
    a1[1] = v775;
    if (v776)
      (*(void (**)(uint64_t))(*(_QWORD *)v776 + 8))(v776);
  }
  else
  {
    *v774 = v773;
    a1[1] = v774 + 1;
  }
  v777 = operator new();
  strcpy((char *)(v777 + 8), "random_uniform");
  *(_BYTE *)(v777 + 23) = 0;
  *(_BYTE *)(v777 + 31) = 14;
  *(_QWORD *)v777 = &unk_1E0E4F2C0;
  v1660 = v777;
  v778 = a1[1];
  if (v778 >= a1[2])
  {
    v779 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v780 = v1660;
    a1[1] = v779;
    if (v780)
      (*(void (**)(uint64_t))(*(_QWORD *)v780 + 8))(v780);
  }
  else
  {
    *v778 = v777;
    a1[1] = v778 + 1;
  }
  v781 = operator new();
  v782 = v781;
  *(_QWORD *)(v781 + 16) = 0;
  *(_BYTE *)(v781 + 31) = 8;
  *(_QWORD *)v781 = &unk_1E0E4F388;
  *(_QWORD *)(v781 + 8) = 0x64315F65676E6172;
  v784 = a1[1];
  v783 = (unint64_t)a1[2];
  if ((unint64_t)v784 < v783)
  {
    *v784 = v781;
    v785 = (uint64_t)(v784 + 1);
    goto LABEL_753;
  }
  v786 = *a1;
  v787 = (char *)v784 - (char *)*a1;
  v788 = v787 >> 3;
  v789 = (v787 >> 3) + 1;
  if (v789 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v790 = v783 - (_QWORD)v786;
  if (v790 >> 2 > v789)
    v789 = v790 >> 2;
  if ((unint64_t)v790 >= 0x7FFFFFFFFFFFFFF8)
    v791 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v791 = v789;
  if (v791)
  {
    if (v791 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v792 = (char *)operator new(8 * v791);
    v793 = (uint64_t *)&v792[8 * v788];
    v794 = (uint64_t *)&v792[8 * v791];
    *v793 = v782;
    v785 = (uint64_t)(v793 + 1);
    v795 = (char *)((char *)v784 - (char *)v786);
    if (v784 != v786)
      goto LABEL_738;
  }
  else
  {
    v792 = 0;
    v793 = (uint64_t *)(8 * v788);
    v794 = 0;
    *(_QWORD *)(8 * v788) = v782;
    v785 = 8 * v788 + 8;
    v795 = (char *)((char *)v784 - (char *)v786);
    if (v784 != v786)
    {
LABEL_738:
      v796 = (unint64_t)(v795 - 8);
      if (v796 < 0x78
        || (uint64_t *)((char *)v784 - (v796 & 0xFFFFFFFFFFFFFFF8) - 8) < v793
        && &v792[v787 - (v796 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v784)
      {
        goto LABEL_1697;
      }
      v797 = (v796 >> 3) + 1;
      v798 = 8 * (v797 & 0x3FFFFFFFFFFFFFFCLL);
      v793 = (uint64_t *)((char *)v793 - v798);
      v799 = &v784[v798 / 0xFFFFFFFFFFFFFFF8];
      v800 = v784 - 2;
      v801 = &v792[8 * v788 - 16];
      v802 = v797 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v804 = *((_OWORD *)v800 - 1);
        v803 = *(_OWORD *)v800;
        *((_OWORD *)v800 - 1) = 0uLL;
        *(_OWORD *)v800 = 0uLL;
        *((_OWORD *)v801 - 1) = v804;
        *(_OWORD *)v801 = v803;
        v800 -= 4;
        v801 -= 32;
        v802 -= 4;
      }
      while (v802);
      v784 = v799;
      if (v797 != (v797 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1697:
        do
        {
          v805 = *--v784;
          *v784 = 0;
          *--v793 = v805;
        }
        while (v784 != v786);
      }
      v784 = *a1;
      v806 = a1[1];
      *a1 = v793;
      a1[1] = (uint64_t *)v785;
      a1[2] = v794;
      while (v806 != v784)
      {
        v808 = *--v806;
        v807 = v808;
        *v806 = 0;
        if (v808)
          (*(void (**)(uint64_t))(*(_QWORD *)v807 + 8))(v807);
      }
      goto LABEL_751;
    }
  }
  *a1 = v793;
  a1[1] = (uint64_t *)v785;
  a1[2] = v794;
LABEL_751:
  if (v784)
    operator delete(v784);
LABEL_753:
  a1[1] = (uint64_t *)v785;
  v809 = operator new();
  v810 = v809;
  *(_QWORD *)(v809 + 16) = 25972;
  *(_BYTE *)(v809 + 31) = 10;
  *(_QWORD *)v809 = &unk_1E0E4F478;
  *(_QWORD *)(v809 + 8) = 0x6174735F64616572;
  v812 = a1[1];
  v811 = (unint64_t)a1[2];
  if ((unint64_t)v812 < v811)
  {
    *v812 = v809;
    v813 = (uint64_t)(v812 + 1);
    goto LABEL_779;
  }
  v814 = *a1;
  v815 = (char *)v812 - (char *)*a1;
  v816 = v815 >> 3;
  v817 = (v815 >> 3) + 1;
  if (v817 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v818 = v811 - (_QWORD)v814;
  if (v818 >> 2 > v817)
    v817 = v818 >> 2;
  if ((unint64_t)v818 >= 0x7FFFFFFFFFFFFFF8)
    v819 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v819 = v817;
  if (v819)
  {
    if (v819 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v820 = (char *)operator new(8 * v819);
    v821 = (uint64_t *)&v820[8 * v816];
    v822 = (uint64_t *)&v820[8 * v819];
    *v821 = v810;
    v813 = (uint64_t)(v821 + 1);
    v823 = (char *)((char *)v812 - (char *)v814);
    if (v812 != v814)
      goto LABEL_764;
  }
  else
  {
    v820 = 0;
    v821 = (uint64_t *)(8 * v816);
    v822 = 0;
    *(_QWORD *)(8 * v816) = v810;
    v813 = 8 * v816 + 8;
    v823 = (char *)((char *)v812 - (char *)v814);
    if (v812 != v814)
    {
LABEL_764:
      v824 = (unint64_t)(v823 - 8);
      if (v824 < 0x78
        || (uint64_t *)((char *)v812 - (v824 & 0xFFFFFFFFFFFFFFF8) - 8) < v821
        && &v820[v815 - (v824 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v812)
      {
        goto LABEL_1698;
      }
      v825 = (v824 >> 3) + 1;
      v826 = 8 * (v825 & 0x3FFFFFFFFFFFFFFCLL);
      v821 = (uint64_t *)((char *)v821 - v826);
      v827 = &v812[v826 / 0xFFFFFFFFFFFFFFF8];
      v828 = v812 - 2;
      v829 = &v820[8 * v816 - 16];
      v830 = v825 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v832 = *((_OWORD *)v828 - 1);
        v831 = *(_OWORD *)v828;
        *((_OWORD *)v828 - 1) = 0uLL;
        *(_OWORD *)v828 = 0uLL;
        *((_OWORD *)v829 - 1) = v832;
        *(_OWORD *)v829 = v831;
        v828 -= 4;
        v829 -= 32;
        v830 -= 4;
      }
      while (v830);
      v812 = v827;
      if (v825 != (v825 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1698:
        do
        {
          v833 = *--v812;
          *v812 = 0;
          *--v821 = v833;
        }
        while (v812 != v814);
      }
      v812 = *a1;
      v834 = a1[1];
      *a1 = v821;
      a1[1] = (uint64_t *)v813;
      a1[2] = v822;
      while (v834 != v812)
      {
        v836 = *--v834;
        v835 = v836;
        *v834 = 0;
        if (v836)
          (*(void (**)(uint64_t))(*(_QWORD *)v835 + 8))(v835);
      }
      goto LABEL_777;
    }
  }
  *a1 = v821;
  a1[1] = (uint64_t *)v813;
  a1[2] = v822;
LABEL_777:
  if (v812)
    operator delete(v812);
LABEL_779:
  a1[1] = (uint64_t *)v813;
  v837 = operator new();
  v838 = v837;
  *(_QWORD *)(v837 + 16) = 0;
  *(_BYTE *)(v837 + 31) = 8;
  *(_QWORD *)v837 = &unk_1E0E4F400;
  *(_QWORD *)(v837 + 8) = 0x656C706D61736572;
  v840 = a1[1];
  v839 = (unint64_t)a1[2];
  if ((unint64_t)v840 < v839)
  {
    *v840 = v837;
    v841 = (uint64_t)(v840 + 1);
    goto LABEL_805;
  }
  v842 = *a1;
  v843 = (char *)v840 - (char *)*a1;
  v844 = v843 >> 3;
  v845 = (v843 >> 3) + 1;
  if (v845 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v846 = v839 - (_QWORD)v842;
  if (v846 >> 2 > v845)
    v845 = v846 >> 2;
  if ((unint64_t)v846 >= 0x7FFFFFFFFFFFFFF8)
    v847 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v847 = v845;
  if (v847)
  {
    if (v847 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v848 = (char *)operator new(8 * v847);
    v849 = (uint64_t *)&v848[8 * v844];
    v850 = (uint64_t *)&v848[8 * v847];
    *v849 = v838;
    v841 = (uint64_t)(v849 + 1);
    v851 = (char *)((char *)v840 - (char *)v842);
    if (v840 != v842)
      goto LABEL_790;
  }
  else
  {
    v848 = 0;
    v849 = (uint64_t *)(8 * v844);
    v850 = 0;
    *(_QWORD *)(8 * v844) = v838;
    v841 = 8 * v844 + 8;
    v851 = (char *)((char *)v840 - (char *)v842);
    if (v840 != v842)
    {
LABEL_790:
      v852 = (unint64_t)(v851 - 8);
      if (v852 < 0x78
        || (uint64_t *)((char *)v840 - (v852 & 0xFFFFFFFFFFFFFFF8) - 8) < v849
        && &v848[v843 - (v852 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v840)
      {
        goto LABEL_1699;
      }
      v853 = (v852 >> 3) + 1;
      v854 = 8 * (v853 & 0x3FFFFFFFFFFFFFFCLL);
      v849 = (uint64_t *)((char *)v849 - v854);
      v855 = &v840[v854 / 0xFFFFFFFFFFFFFFF8];
      v856 = v840 - 2;
      v857 = &v848[8 * v844 - 16];
      v858 = v853 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v860 = *((_OWORD *)v856 - 1);
        v859 = *(_OWORD *)v856;
        *((_OWORD *)v856 - 1) = 0uLL;
        *(_OWORD *)v856 = 0uLL;
        *((_OWORD *)v857 - 1) = v860;
        *(_OWORD *)v857 = v859;
        v856 -= 4;
        v857 -= 32;
        v858 -= 4;
      }
      while (v858);
      v840 = v855;
      if (v853 != (v853 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1699:
        do
        {
          v861 = *--v840;
          *v840 = 0;
          *--v849 = v861;
        }
        while (v840 != v842);
      }
      v840 = *a1;
      v862 = a1[1];
      *a1 = v849;
      a1[1] = (uint64_t *)v841;
      a1[2] = v850;
      while (v862 != v840)
      {
        v864 = *--v862;
        v863 = v864;
        *v862 = 0;
        if (v864)
          (*(void (**)(uint64_t))(*(_QWORD *)v863 + 8))(v863);
      }
      goto LABEL_803;
    }
  }
  *a1 = v849;
  a1[1] = (uint64_t *)v841;
  a1[2] = v850;
LABEL_803:
  if (v840)
    operator delete(v840);
LABEL_805:
  a1[1] = (uint64_t *)v841;
  v865 = operator new();
  v866 = v865;
  *(_BYTE *)(v865 + 21) = 0;
  *(_WORD *)(v865 + 22) = 0;
  *(_BYTE *)(v865 + 31) = 12;
  *(_QWORD *)v865 = &unk_1E0E4F518;
  strcpy((char *)(v865 + 8), "reshape_like");
  v868 = a1[1];
  v867 = (unint64_t)a1[2];
  if ((unint64_t)v868 < v867)
  {
    *v868 = v865;
    v869 = (uint64_t)(v868 + 1);
    goto LABEL_831;
  }
  v870 = *a1;
  v871 = (char *)v868 - (char *)*a1;
  v872 = v871 >> 3;
  v873 = (v871 >> 3) + 1;
  if (v873 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v874 = v867 - (_QWORD)v870;
  if (v874 >> 2 > v873)
    v873 = v874 >> 2;
  if ((unint64_t)v874 >= 0x7FFFFFFFFFFFFFF8)
    v875 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v875 = v873;
  if (v875)
  {
    if (v875 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v876 = (char *)operator new(8 * v875);
    v877 = (uint64_t *)&v876[8 * v872];
    v878 = (uint64_t *)&v876[8 * v875];
    *v877 = v866;
    v869 = (uint64_t)(v877 + 1);
    v879 = (char *)((char *)v868 - (char *)v870);
    if (v868 != v870)
      goto LABEL_816;
  }
  else
  {
    v876 = 0;
    v877 = (uint64_t *)(8 * v872);
    v878 = 0;
    *(_QWORD *)(8 * v872) = v866;
    v869 = 8 * v872 + 8;
    v879 = (char *)((char *)v868 - (char *)v870);
    if (v868 != v870)
    {
LABEL_816:
      v880 = (unint64_t)(v879 - 8);
      if (v880 < 0x78
        || (uint64_t *)((char *)v868 - (v880 & 0xFFFFFFFFFFFFFFF8) - 8) < v877
        && &v876[v871 - (v880 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v868)
      {
        goto LABEL_1700;
      }
      v881 = (v880 >> 3) + 1;
      v882 = 8 * (v881 & 0x3FFFFFFFFFFFFFFCLL);
      v877 = (uint64_t *)((char *)v877 - v882);
      v883 = &v868[v882 / 0xFFFFFFFFFFFFFFF8];
      v884 = v868 - 2;
      v885 = &v876[8 * v872 - 16];
      v886 = v881 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v888 = *((_OWORD *)v884 - 1);
        v887 = *(_OWORD *)v884;
        *((_OWORD *)v884 - 1) = 0uLL;
        *(_OWORD *)v884 = 0uLL;
        *((_OWORD *)v885 - 1) = v888;
        *(_OWORD *)v885 = v887;
        v884 -= 4;
        v885 -= 32;
        v886 -= 4;
      }
      while (v886);
      v868 = v883;
      if (v881 != (v881 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1700:
        do
        {
          v889 = *--v868;
          *v868 = 0;
          *--v877 = v889;
        }
        while (v868 != v870);
      }
      v868 = *a1;
      v890 = a1[1];
      *a1 = v877;
      a1[1] = (uint64_t *)v869;
      a1[2] = v878;
      while (v890 != v868)
      {
        v892 = *--v890;
        v891 = v892;
        *v890 = 0;
        if (v892)
          (*(void (**)(uint64_t))(*(_QWORD *)v891 + 8))(v891);
      }
      goto LABEL_829;
    }
  }
  *a1 = v877;
  a1[1] = (uint64_t *)v869;
  a1[2] = v878;
LABEL_829:
  if (v868)
    operator delete(v868);
LABEL_831:
  a1[1] = (uint64_t *)v869;
  v893 = operator new();
  *(_BYTE *)(v893 + 31) = 15;
  *(_QWORD *)v893 = &unk_1E0E4F2E8;
  strcpy((char *)(v893 + 8), "resize_bilinear");
  v1660 = v893;
  v894 = a1[1];
  if (v894 >= a1[2])
  {
    v895 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v896 = v1660;
    a1[1] = v895;
    if (v896)
      (*(void (**)(uint64_t))(*(_QWORD *)v896 + 8))(v896);
  }
  else
  {
    *v894 = v893;
    a1[1] = v894 + 1;
  }
  v897 = operator new();
  v898 = (char *)operator new(0x19uLL);
  strcpy(v898, "resize_nearest_neighbor");
  *(_QWORD *)v897 = &unk_1E0E138C8;
  std::string::__init_copy_ctor_external((std::string *)(v897 + 8), v898, 0x17uLL);
  *(_QWORD *)v897 = &unk_1E0E4F2E8;
  v1660 = v897;
  operator delete(v898);
  v899 = a1[1];
  if (v899 >= a1[2])
  {
    v900 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v901 = v1660;
    a1[1] = v900;
    if (v901)
      (*(void (**)(uint64_t))(*(_QWORD *)v901 + 8))(v901);
  }
  else
  {
    *v899 = v897;
    a1[1] = v899 + 1;
  }
  v902 = operator new();
  v903 = v902;
  *(_BYTE *)(v902 + 31) = 7;
  *(_QWORD *)v902 = &unk_1E0E4F3B0;
  *(_QWORD *)(v902 + 8) = 0x65737265766572;
  v905 = a1[1];
  v904 = (unint64_t)a1[2];
  if ((unint64_t)v905 < v904)
  {
    *v905 = v902;
    v906 = (uint64_t)(v905 + 1);
    goto LABEL_865;
  }
  v907 = *a1;
  v908 = (char *)v905 - (char *)*a1;
  v909 = v908 >> 3;
  v910 = (v908 >> 3) + 1;
  if (v910 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v911 = v904 - (_QWORD)v907;
  if (v911 >> 2 > v910)
    v910 = v911 >> 2;
  if ((unint64_t)v911 >= 0x7FFFFFFFFFFFFFF8)
    v912 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v912 = v910;
  if (v912)
  {
    if (v912 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v913 = (char *)operator new(8 * v912);
    v914 = (uint64_t *)&v913[8 * v909];
    v915 = (uint64_t *)&v913[8 * v912];
    *v914 = v903;
    v906 = (uint64_t)(v914 + 1);
    v916 = (char *)((char *)v905 - (char *)v907);
    if (v905 != v907)
      goto LABEL_850;
  }
  else
  {
    v913 = 0;
    v914 = (uint64_t *)(8 * v909);
    v915 = 0;
    *(_QWORD *)(8 * v909) = v903;
    v906 = 8 * v909 + 8;
    v916 = (char *)((char *)v905 - (char *)v907);
    if (v905 != v907)
    {
LABEL_850:
      v917 = (unint64_t)(v916 - 8);
      if (v917 < 0x78
        || (uint64_t *)((char *)v905 - (v917 & 0xFFFFFFFFFFFFFFF8) - 8) < v914
        && &v913[v908 - (v917 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v905)
      {
        goto LABEL_1701;
      }
      v918 = (v917 >> 3) + 1;
      v919 = 8 * (v918 & 0x3FFFFFFFFFFFFFFCLL);
      v914 = (uint64_t *)((char *)v914 - v919);
      v920 = &v905[v919 / 0xFFFFFFFFFFFFFFF8];
      v921 = v905 - 2;
      v922 = &v913[8 * v909 - 16];
      v923 = v918 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v925 = *((_OWORD *)v921 - 1);
        v924 = *(_OWORD *)v921;
        *((_OWORD *)v921 - 1) = 0uLL;
        *(_OWORD *)v921 = 0uLL;
        *((_OWORD *)v922 - 1) = v925;
        *(_OWORD *)v922 = v924;
        v921 -= 4;
        v922 -= 32;
        v923 -= 4;
      }
      while (v923);
      v905 = v920;
      if (v918 != (v918 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1701:
        do
        {
          v926 = *--v905;
          *v905 = 0;
          *--v914 = v926;
        }
        while (v905 != v907);
      }
      v905 = *a1;
      v927 = a1[1];
      *a1 = v914;
      a1[1] = (uint64_t *)v906;
      a1[2] = v915;
      while (v927 != v905)
      {
        v929 = *--v927;
        v928 = v929;
        *v927 = 0;
        if (v929)
          (*(void (**)(uint64_t))(*(_QWORD *)v928 + 8))(v928);
      }
      goto LABEL_863;
    }
  }
  *a1 = v914;
  a1[1] = (uint64_t *)v906;
  a1[2] = v915;
LABEL_863:
  if (v905)
    operator delete(v905);
LABEL_865:
  a1[1] = (uint64_t *)v906;
  v930 = operator new();
  v931 = v930;
  *(_BYTE *)(v930 + 31) = 5;
  *(_QWORD *)v930 = &unk_1E0E4F220;
  *(_QWORD *)(v930 + 8) = 0x7472717372;
  v933 = a1[1];
  v932 = (unint64_t)a1[2];
  if ((unint64_t)v933 < v932)
  {
    *v933 = v930;
    v934 = (uint64_t)(v933 + 1);
    goto LABEL_891;
  }
  v935 = *a1;
  v936 = (char *)v933 - (char *)*a1;
  v937 = v936 >> 3;
  v938 = (v936 >> 3) + 1;
  if (v938 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v939 = v932 - (_QWORD)v935;
  if (v939 >> 2 > v938)
    v938 = v939 >> 2;
  if ((unint64_t)v939 >= 0x7FFFFFFFFFFFFFF8)
    v940 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v940 = v938;
  if (v940)
  {
    if (v940 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v941 = (char *)operator new(8 * v940);
    v942 = (uint64_t *)&v941[8 * v937];
    v943 = (uint64_t *)&v941[8 * v940];
    *v942 = v931;
    v934 = (uint64_t)(v942 + 1);
    v944 = (char *)((char *)v933 - (char *)v935);
    if (v933 != v935)
      goto LABEL_876;
  }
  else
  {
    v941 = 0;
    v942 = (uint64_t *)(8 * v937);
    v943 = 0;
    *(_QWORD *)(8 * v937) = v931;
    v934 = 8 * v937 + 8;
    v944 = (char *)((char *)v933 - (char *)v935);
    if (v933 != v935)
    {
LABEL_876:
      v945 = (unint64_t)(v944 - 8);
      if (v945 < 0x78
        || (uint64_t *)((char *)v933 - (v945 & 0xFFFFFFFFFFFFFFF8) - 8) < v942
        && &v941[v936 - (v945 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v933)
      {
        goto LABEL_1702;
      }
      v946 = (v945 >> 3) + 1;
      v947 = 8 * (v946 & 0x3FFFFFFFFFFFFFFCLL);
      v942 = (uint64_t *)((char *)v942 - v947);
      v948 = &v933[v947 / 0xFFFFFFFFFFFFFFF8];
      v949 = v933 - 2;
      v950 = &v941[8 * v937 - 16];
      v951 = v946 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v953 = *((_OWORD *)v949 - 1);
        v952 = *(_OWORD *)v949;
        *((_OWORD *)v949 - 1) = 0uLL;
        *(_OWORD *)v949 = 0uLL;
        *((_OWORD *)v950 - 1) = v953;
        *(_OWORD *)v950 = v952;
        v949 -= 4;
        v950 -= 32;
        v951 -= 4;
      }
      while (v951);
      v933 = v948;
      if (v946 != (v946 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1702:
        do
        {
          v954 = *--v933;
          *v933 = 0;
          *--v942 = v954;
        }
        while (v933 != v935);
      }
      v933 = *a1;
      v955 = a1[1];
      *a1 = v942;
      a1[1] = (uint64_t *)v934;
      a1[2] = v943;
      while (v955 != v933)
      {
        v957 = *--v955;
        v956 = v957;
        *v955 = 0;
        if (v957)
          (*(void (**)(uint64_t))(*(_QWORD *)v956 + 8))(v956);
      }
      goto LABEL_889;
    }
  }
  *a1 = v942;
  a1[1] = (uint64_t *)v934;
  a1[2] = v943;
LABEL_889:
  if (v933)
    operator delete(v933);
LABEL_891:
  a1[1] = (uint64_t *)v934;
  v958 = operator new();
  v959 = (char *)operator new(0x20uLL);
  strcpy(v959, "scaled_dot_product_attention");
  *(_QWORD *)v958 = &unk_1E0E138C8;
  std::string::__init_copy_ctor_external((std::string *)(v958 + 8), v959, 0x1CuLL);
  operator delete(v959);
  *(_QWORD *)v958 = &unk_1E0E4F1D0;
  v961 = a1[1];
  v960 = (unint64_t)a1[2];
  if ((unint64_t)v961 < v960)
  {
    *v961 = v958;
    v962 = (uint64_t)(v961 + 1);
    goto LABEL_917;
  }
  v963 = *a1;
  v964 = (char *)v961 - (char *)*a1;
  v965 = v964 >> 3;
  v966 = (v964 >> 3) + 1;
  if (v966 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v967 = v960 - (_QWORD)v963;
  if (v967 >> 2 > v966)
    v966 = v967 >> 2;
  if ((unint64_t)v967 >= 0x7FFFFFFFFFFFFFF8)
    v968 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v968 = v966;
  if (v968)
  {
    if (v968 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v969 = (char *)operator new(8 * v968);
    v970 = (uint64_t *)&v969[8 * v965];
    v971 = (uint64_t *)&v969[8 * v968];
    *v970 = v958;
    v962 = (uint64_t)(v970 + 1);
    v972 = (char *)((char *)v961 - (char *)v963);
    if (v961 != v963)
      goto LABEL_902;
  }
  else
  {
    v969 = 0;
    v970 = (uint64_t *)(8 * v965);
    v971 = 0;
    *(_QWORD *)(8 * v965) = v958;
    v962 = 8 * v965 + 8;
    v972 = (char *)((char *)v961 - (char *)v963);
    if (v961 != v963)
    {
LABEL_902:
      v973 = (unint64_t)(v972 - 8);
      if (v973 < 0x78
        || (uint64_t *)((char *)v961 - (v973 & 0xFFFFFFFFFFFFFFF8) - 8) < v970
        && &v969[v964 - (v973 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v961)
      {
        goto LABEL_1703;
      }
      v974 = (v973 >> 3) + 1;
      v975 = 8 * (v974 & 0x3FFFFFFFFFFFFFFCLL);
      v970 = (uint64_t *)((char *)v970 - v975);
      v976 = &v961[v975 / 0xFFFFFFFFFFFFFFF8];
      v977 = v961 - 2;
      v978 = &v969[8 * v965 - 16];
      v979 = v974 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v981 = *((_OWORD *)v977 - 1);
        v980 = *(_OWORD *)v977;
        *((_OWORD *)v977 - 1) = 0uLL;
        *(_OWORD *)v977 = 0uLL;
        *((_OWORD *)v978 - 1) = v981;
        *(_OWORD *)v978 = v980;
        v977 -= 4;
        v978 -= 32;
        v979 -= 4;
      }
      while (v979);
      v961 = v976;
      if (v974 != (v974 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1703:
        do
        {
          v982 = *--v961;
          *v961 = 0;
          *--v970 = v982;
        }
        while (v961 != v963);
      }
      v961 = *a1;
      v983 = a1[1];
      *a1 = v970;
      a1[1] = (uint64_t *)v962;
      a1[2] = v971;
      while (v983 != v961)
      {
        v985 = *--v983;
        v984 = v985;
        *v983 = 0;
        if (v985)
          (*(void (**)(uint64_t))(*(_QWORD *)v984 + 8))(v984);
      }
      goto LABEL_915;
    }
  }
  *a1 = v970;
  a1[1] = (uint64_t *)v962;
  a1[2] = v971;
LABEL_915:
  if (v961)
    operator delete(v961);
LABEL_917:
  a1[1] = (uint64_t *)v962;
  v986 = operator new();
  v987 = v986;
  *(_BYTE *)(v986 + 31) = 3;
  *(_QWORD *)v986 = &unk_1E0E4F5B8;
  *(_QWORD *)(v986 + 8) = 7237234;
  v989 = a1[1];
  v988 = (unint64_t)a1[2];
  if ((unint64_t)v989 < v988)
  {
    *v989 = v986;
    v990 = (uint64_t)(v989 + 1);
    goto LABEL_943;
  }
  v991 = *a1;
  v992 = (char *)v989 - (char *)*a1;
  v993 = v992 >> 3;
  v994 = (v992 >> 3) + 1;
  if (v994 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v995 = v988 - (_QWORD)v991;
  if (v995 >> 2 > v994)
    v994 = v995 >> 2;
  if ((unint64_t)v995 >= 0x7FFFFFFFFFFFFFF8)
    v996 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v996 = v994;
  if (v996)
  {
    if (v996 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v997 = (char *)operator new(8 * v996);
    v998 = (uint64_t *)&v997[8 * v993];
    v999 = (uint64_t *)&v997[8 * v996];
    *v998 = v987;
    v990 = (uint64_t)(v998 + 1);
    v1000 = (char *)((char *)v989 - (char *)v991);
    if (v989 != v991)
      goto LABEL_928;
  }
  else
  {
    v997 = 0;
    v998 = (uint64_t *)(8 * v993);
    v999 = 0;
    *(_QWORD *)(8 * v993) = v987;
    v990 = 8 * v993 + 8;
    v1000 = (char *)((char *)v989 - (char *)v991);
    if (v989 != v991)
    {
LABEL_928:
      v1001 = (unint64_t)(v1000 - 8);
      if (v1001 < 0x78
        || (uint64_t *)((char *)v989 - (v1001 & 0xFFFFFFFFFFFFFFF8) - 8) < v998
        && &v997[v992 - (v1001 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v989)
      {
        goto LABEL_1704;
      }
      v1002 = (v1001 >> 3) + 1;
      v1003 = 8 * (v1002 & 0x3FFFFFFFFFFFFFFCLL);
      v998 = (uint64_t *)((char *)v998 - v1003);
      v1004 = &v989[v1003 / 0xFFFFFFFFFFFFFFF8];
      v1005 = v989 - 2;
      v1006 = &v997[8 * v993 - 16];
      v1007 = v1002 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1009 = *((_OWORD *)v1005 - 1);
        v1008 = *(_OWORD *)v1005;
        *((_OWORD *)v1005 - 1) = 0uLL;
        *(_OWORD *)v1005 = 0uLL;
        *((_OWORD *)v1006 - 1) = v1009;
        *(_OWORD *)v1006 = v1008;
        v1005 -= 4;
        v1006 -= 32;
        v1007 -= 4;
      }
      while (v1007);
      v989 = v1004;
      if (v1002 != (v1002 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1704:
        do
        {
          v1010 = *--v989;
          *v989 = 0;
          *--v998 = v1010;
        }
        while (v989 != v991);
      }
      v989 = *a1;
      v1011 = a1[1];
      *a1 = v998;
      a1[1] = (uint64_t *)v990;
      a1[2] = v999;
      while (v1011 != v989)
      {
        v1013 = *--v1011;
        v1012 = v1013;
        *v1011 = 0;
        if (v1013)
          (*(void (**)(uint64_t))(*(_QWORD *)v1012 + 8))(v1012);
      }
      goto LABEL_941;
    }
  }
  *a1 = v998;
  a1[1] = (uint64_t *)v990;
  a1[2] = v999;
LABEL_941:
  if (v989)
    operator delete(v989);
LABEL_943:
  a1[1] = (uint64_t *)v990;
  v1014 = operator new();
  *(_BYTE *)(v1014 + 23) = 0;
  *(_BYTE *)(v1014 + 31) = 14;
  *(_QWORD *)v1014 = &unk_1E0E4F568;
  strcpy((char *)(v1014 + 8), "slice_by_index");
  v1660 = v1014;
  v1015 = a1[1];
  if (v1015 >= a1[2])
  {
    v1016 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v1017 = v1660;
    a1[1] = v1016;
    if (v1017)
      (*(void (**)(uint64_t))(*(_QWORD *)v1017 + 8))(v1017);
  }
  else
  {
    *v1015 = v1014;
    a1[1] = v1015 + 1;
  }
  v1018 = operator new();
  strcpy((char *)(v1018 + 8), "slice_update");
  *(_BYTE *)(v1018 + 21) = 0;
  *(_WORD *)(v1018 + 22) = 0;
  *(_BYTE *)(v1018 + 31) = 12;
  *(_QWORD *)v1018 = &unk_1E0E4F568;
  v1660 = v1018;
  v1019 = a1[1];
  if (v1019 >= a1[2])
  {
    v1020 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v1021 = v1660;
    a1[1] = v1020;
    if (v1021)
      (*(void (**)(uint64_t))(*(_QWORD *)v1021 + 8))(v1021);
  }
  else
  {
    *v1019 = v1018;
    a1[1] = v1019 + 1;
  }
  v1022 = operator new();
  v1023 = v1022;
  *(_WORD *)(v1022 + 22) = 0;
  *(_BYTE *)(v1022 + 31) = 13;
  *(_QWORD *)v1022 = &unk_1E0E4F540;
  strcpy((char *)(v1022 + 8), "slice_by_size");
  v1025 = a1[1];
  v1024 = (unint64_t)a1[2];
  if ((unint64_t)v1025 < v1024)
  {
    *v1025 = v1022;
    v1026 = (uint64_t)(v1025 + 1);
    goto LABEL_977;
  }
  v1027 = *a1;
  v1028 = (char *)v1025 - (char *)*a1;
  v1029 = v1028 >> 3;
  v1030 = (v1028 >> 3) + 1;
  if (v1030 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1031 = v1024 - (_QWORD)v1027;
  if (v1031 >> 2 > v1030)
    v1030 = v1031 >> 2;
  if ((unint64_t)v1031 >= 0x7FFFFFFFFFFFFFF8)
    v1032 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1032 = v1030;
  if (v1032)
  {
    if (v1032 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1033 = (char *)operator new(8 * v1032);
    v1034 = (uint64_t *)&v1033[8 * v1029];
    v1035 = (uint64_t *)&v1033[8 * v1032];
    *v1034 = v1023;
    v1026 = (uint64_t)(v1034 + 1);
    v1036 = (char *)((char *)v1025 - (char *)v1027);
    if (v1025 != v1027)
      goto LABEL_962;
  }
  else
  {
    v1033 = 0;
    v1034 = (uint64_t *)(8 * v1029);
    v1035 = 0;
    *(_QWORD *)(8 * v1029) = v1023;
    v1026 = 8 * v1029 + 8;
    v1036 = (char *)((char *)v1025 - (char *)v1027);
    if (v1025 != v1027)
    {
LABEL_962:
      v1037 = (unint64_t)(v1036 - 8);
      if (v1037 < 0x78
        || (uint64_t *)((char *)v1025 - (v1037 & 0xFFFFFFFFFFFFFFF8) - 8) < v1034
        && &v1033[v1028 - (v1037 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1025)
      {
        goto LABEL_1705;
      }
      v1038 = (v1037 >> 3) + 1;
      v1039 = 8 * (v1038 & 0x3FFFFFFFFFFFFFFCLL);
      v1034 = (uint64_t *)((char *)v1034 - v1039);
      v1040 = &v1025[v1039 / 0xFFFFFFFFFFFFFFF8];
      v1041 = v1025 - 2;
      v1042 = &v1033[8 * v1029 - 16];
      v1043 = v1038 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1045 = *((_OWORD *)v1041 - 1);
        v1044 = *(_OWORD *)v1041;
        *((_OWORD *)v1041 - 1) = 0uLL;
        *(_OWORD *)v1041 = 0uLL;
        *((_OWORD *)v1042 - 1) = v1045;
        *(_OWORD *)v1042 = v1044;
        v1041 -= 4;
        v1042 -= 32;
        v1043 -= 4;
      }
      while (v1043);
      v1025 = v1040;
      if (v1038 != (v1038 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1705:
        do
        {
          v1046 = *--v1025;
          *v1025 = 0;
          *--v1034 = v1046;
        }
        while (v1025 != v1027);
      }
      v1025 = *a1;
      v1047 = a1[1];
      *a1 = v1034;
      a1[1] = (uint64_t *)v1026;
      a1[2] = v1035;
      while (v1047 != v1025)
      {
        v1049 = *--v1047;
        v1048 = v1049;
        *v1047 = 0;
        if (v1049)
          (*(void (**)(uint64_t))(*(_QWORD *)v1048 + 8))(v1048);
      }
      goto LABEL_975;
    }
  }
  *a1 = v1034;
  a1[1] = (uint64_t *)v1026;
  a1[2] = v1035;
LABEL_975:
  if (v1025)
    operator delete(v1025);
LABEL_977:
  a1[1] = (uint64_t *)v1026;
  v1050 = operator new();
  v1051 = v1050;
  *(_BYTE *)(v1050 + 31) = 5;
  *(_QWORD *)v1050 = &unk_1E0E4F248;
  *(_QWORD *)(v1050 + 8) = 0x74696C7073;
  v1053 = a1[1];
  v1052 = (unint64_t)a1[2];
  if ((unint64_t)v1053 < v1052)
  {
    *v1053 = v1050;
    v1054 = (uint64_t)(v1053 + 1);
    goto LABEL_1003;
  }
  v1055 = *a1;
  v1056 = (char *)v1053 - (char *)*a1;
  v1057 = v1056 >> 3;
  v1058 = (v1056 >> 3) + 1;
  if (v1058 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1059 = v1052 - (_QWORD)v1055;
  if (v1059 >> 2 > v1058)
    v1058 = v1059 >> 2;
  if ((unint64_t)v1059 >= 0x7FFFFFFFFFFFFFF8)
    v1060 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1060 = v1058;
  if (v1060)
  {
    if (v1060 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1061 = (char *)operator new(8 * v1060);
    v1062 = (uint64_t *)&v1061[8 * v1057];
    v1063 = (uint64_t *)&v1061[8 * v1060];
    *v1062 = v1051;
    v1054 = (uint64_t)(v1062 + 1);
    v1064 = (char *)((char *)v1053 - (char *)v1055);
    if (v1053 != v1055)
      goto LABEL_988;
  }
  else
  {
    v1061 = 0;
    v1062 = (uint64_t *)(8 * v1057);
    v1063 = 0;
    *(_QWORD *)(8 * v1057) = v1051;
    v1054 = 8 * v1057 + 8;
    v1064 = (char *)((char *)v1053 - (char *)v1055);
    if (v1053 != v1055)
    {
LABEL_988:
      v1065 = (unint64_t)(v1064 - 8);
      if (v1065 < 0x78
        || (uint64_t *)((char *)v1053 - (v1065 & 0xFFFFFFFFFFFFFFF8) - 8) < v1062
        && &v1061[v1056 - (v1065 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1053)
      {
        goto LABEL_1706;
      }
      v1066 = (v1065 >> 3) + 1;
      v1067 = 8 * (v1066 & 0x3FFFFFFFFFFFFFFCLL);
      v1062 = (uint64_t *)((char *)v1062 - v1067);
      v1068 = &v1053[v1067 / 0xFFFFFFFFFFFFFFF8];
      v1069 = v1053 - 2;
      v1070 = &v1061[8 * v1057 - 16];
      v1071 = v1066 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1073 = *((_OWORD *)v1069 - 1);
        v1072 = *(_OWORD *)v1069;
        *((_OWORD *)v1069 - 1) = 0uLL;
        *(_OWORD *)v1069 = 0uLL;
        *((_OWORD *)v1070 - 1) = v1073;
        *(_OWORD *)v1070 = v1072;
        v1069 -= 4;
        v1070 -= 32;
        v1071 -= 4;
      }
      while (v1071);
      v1053 = v1068;
      if (v1066 != (v1066 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1706:
        do
        {
          v1074 = *--v1053;
          *v1053 = 0;
          *--v1062 = v1074;
        }
        while (v1053 != v1055);
      }
      v1053 = *a1;
      v1075 = a1[1];
      *a1 = v1062;
      a1[1] = (uint64_t *)v1054;
      a1[2] = v1063;
      while (v1075 != v1053)
      {
        v1077 = *--v1075;
        v1076 = v1077;
        *v1075 = 0;
        if (v1077)
          (*(void (**)(uint64_t))(*(_QWORD *)v1076 + 8))(v1076);
      }
      goto LABEL_1001;
    }
  }
  *a1 = v1062;
  a1[1] = (uint64_t *)v1054;
  a1[2] = v1063;
LABEL_1001:
  if (v1053)
    operator delete(v1053);
LABEL_1003:
  a1[1] = (uint64_t *)v1054;
  v1078 = operator new();
  v1079 = v1078;
  *(_BYTE *)(v1078 + 31) = 5;
  *(_QWORD *)v1078 = &unk_1E0E4F270;
  *(_QWORD *)(v1078 + 8) = 0x6B63617473;
  v1081 = a1[1];
  v1080 = (unint64_t)a1[2];
  if ((unint64_t)v1081 < v1080)
  {
    *v1081 = v1078;
    v1082 = (uint64_t)(v1081 + 1);
    goto LABEL_1029;
  }
  v1083 = *a1;
  v1084 = (char *)v1081 - (char *)*a1;
  v1085 = v1084 >> 3;
  v1086 = (v1084 >> 3) + 1;
  if (v1086 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1087 = v1080 - (_QWORD)v1083;
  if (v1087 >> 2 > v1086)
    v1086 = v1087 >> 2;
  if ((unint64_t)v1087 >= 0x7FFFFFFFFFFFFFF8)
    v1088 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1088 = v1086;
  if (v1088)
  {
    if (v1088 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1089 = (char *)operator new(8 * v1088);
    v1090 = (uint64_t *)&v1089[8 * v1085];
    v1091 = (uint64_t *)&v1089[8 * v1088];
    *v1090 = v1079;
    v1082 = (uint64_t)(v1090 + 1);
    v1092 = (char *)((char *)v1081 - (char *)v1083);
    if (v1081 != v1083)
      goto LABEL_1014;
  }
  else
  {
    v1089 = 0;
    v1090 = (uint64_t *)(8 * v1085);
    v1091 = 0;
    *(_QWORD *)(8 * v1085) = v1079;
    v1082 = 8 * v1085 + 8;
    v1092 = (char *)((char *)v1081 - (char *)v1083);
    if (v1081 != v1083)
    {
LABEL_1014:
      v1093 = (unint64_t)(v1092 - 8);
      if (v1093 < 0x78
        || (uint64_t *)((char *)v1081 - (v1093 & 0xFFFFFFFFFFFFFFF8) - 8) < v1090
        && &v1089[v1084 - (v1093 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1081)
      {
        goto LABEL_1707;
      }
      v1094 = (v1093 >> 3) + 1;
      v1095 = 8 * (v1094 & 0x3FFFFFFFFFFFFFFCLL);
      v1090 = (uint64_t *)((char *)v1090 - v1095);
      v1096 = &v1081[v1095 / 0xFFFFFFFFFFFFFFF8];
      v1097 = v1081 - 2;
      v1098 = &v1089[8 * v1085 - 16];
      v1099 = v1094 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1101 = *((_OWORD *)v1097 - 1);
        v1100 = *(_OWORD *)v1097;
        *((_OWORD *)v1097 - 1) = 0uLL;
        *(_OWORD *)v1097 = 0uLL;
        *((_OWORD *)v1098 - 1) = v1101;
        *(_OWORD *)v1098 = v1100;
        v1097 -= 4;
        v1098 -= 32;
        v1099 -= 4;
      }
      while (v1099);
      v1081 = v1096;
      if (v1094 != (v1094 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1707:
        do
        {
          v1102 = *--v1081;
          *v1081 = 0;
          *--v1090 = v1102;
        }
        while (v1081 != v1083);
      }
      v1081 = *a1;
      v1103 = a1[1];
      *a1 = v1090;
      a1[1] = (uint64_t *)v1082;
      a1[2] = v1091;
      while (v1103 != v1081)
      {
        v1105 = *--v1103;
        v1104 = v1105;
        *v1103 = 0;
        if (v1105)
          (*(void (**)(uint64_t))(*(_QWORD *)v1104 + 8))(v1104);
      }
      goto LABEL_1027;
    }
  }
  *a1 = v1090;
  a1[1] = (uint64_t *)v1082;
  a1[2] = v1091;
LABEL_1027:
  if (v1081)
    operator delete(v1081);
LABEL_1029:
  a1[1] = (uint64_t *)v1082;
  std::make_unique[abi:ne180100]<MILToMLIR::TensorBufferPattern,char const(&)[24]>(&v1660, "tensor_buffer_to_tensor");
  v1106 = a1[1];
  if (v1106 >= a1[2])
  {
    v1107 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v1108 = v1660;
    a1[1] = v1107;
    if (v1108)
      (*(void (**)(uint64_t))(*(_QWORD *)v1108 + 8))(v1108);
  }
  else
  {
    *v1106 = v1660;
    a1[1] = v1106 + 1;
  }
  std::make_unique[abi:ne180100]<MILToMLIR::TensorBufferPattern,char const(&)[24]>(&v1660, "tensor_to_tensor_buffer");
  v1109 = a1[1];
  if (v1109 >= a1[2])
  {
    v1110 = std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(a1, &v1660);
    v1111 = v1660;
    a1[1] = v1110;
    if (v1111)
      (*(void (**)(uint64_t))(*(_QWORD *)v1111 + 8))(v1111);
  }
  else
  {
    *v1109 = v1660;
    a1[1] = v1109 + 1;
  }
  v1112 = operator new();
  v1113 = v1112;
  *(_BYTE *)(v1112 + 31) = 4;
  *(_QWORD *)v1112 = &unk_1E0E4F1F8;
  *(_QWORD *)(v1112 + 8) = 1802530676;
  v1115 = a1[1];
  v1114 = (unint64_t)a1[2];
  if ((unint64_t)v1115 < v1114)
  {
    *v1115 = v1112;
    v1116 = (uint64_t)(v1115 + 1);
    goto LABEL_1063;
  }
  v1117 = *a1;
  v1118 = (char *)v1115 - (char *)*a1;
  v1119 = v1118 >> 3;
  v1120 = (v1118 >> 3) + 1;
  if (v1120 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1121 = v1114 - (_QWORD)v1117;
  if (v1121 >> 2 > v1120)
    v1120 = v1121 >> 2;
  if ((unint64_t)v1121 >= 0x7FFFFFFFFFFFFFF8)
    v1122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1122 = v1120;
  if (v1122)
  {
    if (v1122 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1123 = (char *)operator new(8 * v1122);
    v1124 = (uint64_t *)&v1123[8 * v1119];
    v1125 = (uint64_t *)&v1123[8 * v1122];
    *v1124 = v1113;
    v1116 = (uint64_t)(v1124 + 1);
    v1126 = (char *)((char *)v1115 - (char *)v1117);
    if (v1115 != v1117)
      goto LABEL_1048;
  }
  else
  {
    v1123 = 0;
    v1124 = (uint64_t *)(8 * v1119);
    v1125 = 0;
    *(_QWORD *)(8 * v1119) = v1113;
    v1116 = 8 * v1119 + 8;
    v1126 = (char *)((char *)v1115 - (char *)v1117);
    if (v1115 != v1117)
    {
LABEL_1048:
      v1127 = (unint64_t)(v1126 - 8);
      if (v1127 < 0x78
        || (uint64_t *)((char *)v1115 - (v1127 & 0xFFFFFFFFFFFFFFF8) - 8) < v1124
        && &v1123[v1118 - (v1127 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1115)
      {
        goto LABEL_1708;
      }
      v1128 = (v1127 >> 3) + 1;
      v1129 = 8 * (v1128 & 0x3FFFFFFFFFFFFFFCLL);
      v1124 = (uint64_t *)((char *)v1124 - v1129);
      v1130 = &v1115[v1129 / 0xFFFFFFFFFFFFFFF8];
      v1131 = v1115 - 2;
      v1132 = &v1123[8 * v1119 - 16];
      v1133 = v1128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1135 = *((_OWORD *)v1131 - 1);
        v1134 = *(_OWORD *)v1131;
        *((_OWORD *)v1131 - 1) = 0uLL;
        *(_OWORD *)v1131 = 0uLL;
        *((_OWORD *)v1132 - 1) = v1135;
        *(_OWORD *)v1132 = v1134;
        v1131 -= 4;
        v1132 -= 32;
        v1133 -= 4;
      }
      while (v1133);
      v1115 = v1130;
      if (v1128 != (v1128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1708:
        do
        {
          v1136 = *--v1115;
          *v1115 = 0;
          *--v1124 = v1136;
        }
        while (v1115 != v1117);
      }
      v1115 = *a1;
      v1137 = a1[1];
      *a1 = v1124;
      a1[1] = (uint64_t *)v1116;
      a1[2] = v1125;
      while (v1137 != v1115)
      {
        v1139 = *--v1137;
        v1138 = v1139;
        *v1137 = 0;
        if (v1139)
          (*(void (**)(uint64_t))(*(_QWORD *)v1138 + 8))(v1138);
      }
      goto LABEL_1061;
    }
  }
  *a1 = v1124;
  a1[1] = (uint64_t *)v1116;
  a1[2] = v1125;
LABEL_1061:
  if (v1115)
    operator delete(v1115);
LABEL_1063:
  a1[1] = (uint64_t *)v1116;
  v1140 = operator new();
  v1141 = v1140;
  *(_BYTE *)(v1140 + 31) = 17;
  *(_QWORD *)v1140 = &unk_1E0E4F608;
  strcpy((char *)(v1140 + 8), "upsample_bilinear");
  v1143 = a1[1];
  v1142 = (unint64_t)a1[2];
  if ((unint64_t)v1143 < v1142)
  {
    *v1143 = v1140;
    v1144 = (uint64_t)(v1143 + 1);
    goto LABEL_1089;
  }
  v1145 = *a1;
  v1146 = (char *)v1143 - (char *)*a1;
  v1147 = v1146 >> 3;
  v1148 = (v1146 >> 3) + 1;
  if (v1148 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1149 = v1142 - (_QWORD)v1145;
  if (v1149 >> 2 > v1148)
    v1148 = v1149 >> 2;
  if ((unint64_t)v1149 >= 0x7FFFFFFFFFFFFFF8)
    v1150 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1150 = v1148;
  if (v1150)
  {
    if (v1150 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1151 = (char *)operator new(8 * v1150);
    v1152 = (uint64_t *)&v1151[8 * v1147];
    v1153 = (uint64_t *)&v1151[8 * v1150];
    *v1152 = v1141;
    v1144 = (uint64_t)(v1152 + 1);
    v1154 = (char *)((char *)v1143 - (char *)v1145);
    if (v1143 != v1145)
      goto LABEL_1074;
  }
  else
  {
    v1151 = 0;
    v1152 = (uint64_t *)(8 * v1147);
    v1153 = 0;
    *(_QWORD *)(8 * v1147) = v1141;
    v1144 = 8 * v1147 + 8;
    v1154 = (char *)((char *)v1143 - (char *)v1145);
    if (v1143 != v1145)
    {
LABEL_1074:
      v1155 = (unint64_t)(v1154 - 8);
      if (v1155 < 0x78
        || (uint64_t *)((char *)v1143 - (v1155 & 0xFFFFFFFFFFFFFFF8) - 8) < v1152
        && &v1151[v1146 - (v1155 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1143)
      {
        goto LABEL_1709;
      }
      v1156 = (v1155 >> 3) + 1;
      v1157 = 8 * (v1156 & 0x3FFFFFFFFFFFFFFCLL);
      v1152 = (uint64_t *)((char *)v1152 - v1157);
      v1158 = &v1143[v1157 / 0xFFFFFFFFFFFFFFF8];
      v1159 = v1143 - 2;
      v1160 = &v1151[8 * v1147 - 16];
      v1161 = v1156 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1163 = *((_OWORD *)v1159 - 1);
        v1162 = *(_OWORD *)v1159;
        *((_OWORD *)v1159 - 1) = 0uLL;
        *(_OWORD *)v1159 = 0uLL;
        *((_OWORD *)v1160 - 1) = v1163;
        *(_OWORD *)v1160 = v1162;
        v1159 -= 4;
        v1160 -= 32;
        v1161 -= 4;
      }
      while (v1161);
      v1143 = v1158;
      if (v1156 != (v1156 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1709:
        do
        {
          v1164 = *--v1143;
          *v1143 = 0;
          *--v1152 = v1164;
        }
        while (v1143 != v1145);
      }
      v1143 = *a1;
      v1165 = a1[1];
      *a1 = v1152;
      a1[1] = (uint64_t *)v1144;
      a1[2] = v1153;
      while (v1165 != v1143)
      {
        v1167 = *--v1165;
        v1166 = v1167;
        *v1165 = 0;
        if (v1167)
          (*(void (**)(uint64_t))(*(_QWORD *)v1166 + 8))(v1166);
      }
      goto LABEL_1087;
    }
  }
  *a1 = v1152;
  a1[1] = (uint64_t *)v1144;
  a1[2] = v1153;
LABEL_1087:
  if (v1143)
    operator delete(v1143);
LABEL_1089:
  a1[1] = (uint64_t *)v1144;
  v1168 = operator new();
  v1169 = (char *)operator new(0x20uLL);
  strcpy(v1169, "upsample_nearest_neighbor");
  *(_QWORD *)v1168 = &unk_1E0E138C8;
  std::string::__init_copy_ctor_external((std::string *)(v1168 + 8), v1169, 0x19uLL);
  operator delete(v1169);
  *(_QWORD *)v1168 = &unk_1E0E4F630;
  v1171 = a1[1];
  v1170 = (unint64_t)a1[2];
  if ((unint64_t)v1171 < v1170)
  {
    *v1171 = v1168;
    v1172 = (uint64_t)(v1171 + 1);
    goto LABEL_1115;
  }
  v1173 = *a1;
  v1174 = (char *)v1171 - (char *)*a1;
  v1175 = v1174 >> 3;
  v1176 = (v1174 >> 3) + 1;
  if (v1176 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1177 = v1170 - (_QWORD)v1173;
  if (v1177 >> 2 > v1176)
    v1176 = v1177 >> 2;
  if ((unint64_t)v1177 >= 0x7FFFFFFFFFFFFFF8)
    v1178 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1178 = v1176;
  if (v1178)
  {
    if (v1178 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1179 = (char *)operator new(8 * v1178);
    v1180 = (uint64_t *)&v1179[8 * v1175];
    v1181 = (uint64_t *)&v1179[8 * v1178];
    *v1180 = v1168;
    v1172 = (uint64_t)(v1180 + 1);
    v1182 = (char *)((char *)v1171 - (char *)v1173);
    if (v1171 != v1173)
      goto LABEL_1100;
  }
  else
  {
    v1179 = 0;
    v1180 = (uint64_t *)(8 * v1175);
    v1181 = 0;
    *(_QWORD *)(8 * v1175) = v1168;
    v1172 = 8 * v1175 + 8;
    v1182 = (char *)((char *)v1171 - (char *)v1173);
    if (v1171 != v1173)
    {
LABEL_1100:
      v1183 = (unint64_t)(v1182 - 8);
      if (v1183 < 0x78
        || (uint64_t *)((char *)v1171 - (v1183 & 0xFFFFFFFFFFFFFFF8) - 8) < v1180
        && &v1179[v1174 - (v1183 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1171)
      {
        goto LABEL_1710;
      }
      v1184 = (v1183 >> 3) + 1;
      v1185 = 8 * (v1184 & 0x3FFFFFFFFFFFFFFCLL);
      v1180 = (uint64_t *)((char *)v1180 - v1185);
      v1186 = &v1171[v1185 / 0xFFFFFFFFFFFFFFF8];
      v1187 = v1171 - 2;
      v1188 = &v1179[8 * v1175 - 16];
      v1189 = v1184 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1191 = *((_OWORD *)v1187 - 1);
        v1190 = *(_OWORD *)v1187;
        *((_OWORD *)v1187 - 1) = 0uLL;
        *(_OWORD *)v1187 = 0uLL;
        *((_OWORD *)v1188 - 1) = v1191;
        *(_OWORD *)v1188 = v1190;
        v1187 -= 4;
        v1188 -= 32;
        v1189 -= 4;
      }
      while (v1189);
      v1171 = v1186;
      if (v1184 != (v1184 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1710:
        do
        {
          v1192 = *--v1171;
          *v1171 = 0;
          *--v1180 = v1192;
        }
        while (v1171 != v1173);
      }
      v1171 = *a1;
      v1193 = a1[1];
      *a1 = v1180;
      a1[1] = (uint64_t *)v1172;
      a1[2] = v1181;
      while (v1193 != v1171)
      {
        v1195 = *--v1193;
        v1194 = v1195;
        *v1193 = 0;
        if (v1195)
          (*(void (**)(uint64_t))(*(_QWORD *)v1194 + 8))(v1194);
      }
      goto LABEL_1113;
    }
  }
  *a1 = v1180;
  a1[1] = (uint64_t *)v1172;
  a1[2] = v1181;
LABEL_1113:
  if (v1171)
    operator delete(v1171);
LABEL_1115:
  a1[1] = (uint64_t *)v1172;
  v1196 = operator new();
  v1197 = v1196;
  *(_QWORD *)(v1196 + 16) = 6648929;
  *(_BYTE *)(v1196 + 31) = 11;
  *(_QWORD *)v1196 = &unk_1E0E4F4C8;
  *(_QWORD *)(v1196 + 8) = 0x74735F6574697277;
  v1199 = a1[1];
  v1198 = (unint64_t)a1[2];
  if ((unint64_t)v1199 < v1198)
  {
    *v1199 = v1196;
    v1200 = (uint64_t)(v1199 + 1);
    goto LABEL_1141;
  }
  v1201 = *a1;
  v1202 = (char *)v1199 - (char *)*a1;
  v1203 = v1202 >> 3;
  v1204 = (v1202 >> 3) + 1;
  if (v1204 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1205 = v1198 - (_QWORD)v1201;
  if (v1205 >> 2 > v1204)
    v1204 = v1205 >> 2;
  if ((unint64_t)v1205 >= 0x7FFFFFFFFFFFFFF8)
    v1206 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1206 = v1204;
  if (v1206)
  {
    if (v1206 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1207 = (char *)operator new(8 * v1206);
    v1208 = (uint64_t *)&v1207[8 * v1203];
    v1209 = (uint64_t *)&v1207[8 * v1206];
    *v1208 = v1197;
    v1200 = (uint64_t)(v1208 + 1);
    v1210 = (char *)((char *)v1199 - (char *)v1201);
    if (v1199 != v1201)
      goto LABEL_1126;
  }
  else
  {
    v1207 = 0;
    v1208 = (uint64_t *)(8 * v1203);
    v1209 = 0;
    *(_QWORD *)(8 * v1203) = v1197;
    v1200 = 8 * v1203 + 8;
    v1210 = (char *)((char *)v1199 - (char *)v1201);
    if (v1199 != v1201)
    {
LABEL_1126:
      v1211 = (unint64_t)(v1210 - 8);
      if (v1211 < 0x78
        || (uint64_t *)((char *)v1199 - (v1211 & 0xFFFFFFFFFFFFFFF8) - 8) < v1208
        && &v1207[v1202 - (v1211 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1199)
      {
        goto LABEL_1711;
      }
      v1212 = (v1211 >> 3) + 1;
      v1213 = 8 * (v1212 & 0x3FFFFFFFFFFFFFFCLL);
      v1208 = (uint64_t *)((char *)v1208 - v1213);
      v1214 = &v1199[v1213 / 0xFFFFFFFFFFFFFFF8];
      v1215 = v1199 - 2;
      v1216 = &v1207[8 * v1203 - 16];
      v1217 = v1212 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1219 = *((_OWORD *)v1215 - 1);
        v1218 = *(_OWORD *)v1215;
        *((_OWORD *)v1215 - 1) = 0uLL;
        *(_OWORD *)v1215 = 0uLL;
        *((_OWORD *)v1216 - 1) = v1219;
        *(_OWORD *)v1216 = v1218;
        v1215 -= 4;
        v1216 -= 32;
        v1217 -= 4;
      }
      while (v1217);
      v1199 = v1214;
      if (v1212 != (v1212 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1711:
        do
        {
          v1220 = *--v1199;
          *v1199 = 0;
          *--v1208 = v1220;
        }
        while (v1199 != v1201);
      }
      v1199 = *a1;
      v1221 = a1[1];
      *a1 = v1208;
      a1[1] = (uint64_t *)v1200;
      a1[2] = v1209;
      while (v1221 != v1199)
      {
        v1223 = *--v1221;
        v1222 = v1223;
        *v1221 = 0;
        if (v1223)
          (*(void (**)(uint64_t))(*(_QWORD *)v1222 + 8))(v1222);
      }
      goto LABEL_1139;
    }
  }
  *a1 = v1208;
  a1[1] = (uint64_t *)v1200;
  a1[2] = v1209;
LABEL_1139:
  if (v1199)
    operator delete(v1199);
LABEL_1141:
  a1[1] = (uint64_t *)v1200;
  v1224 = operator new();
  v1225 = v1224;
  *(_BYTE *)(v1224 + 31) = 5;
  *(_QWORD *)v1224 = off_1E0E15508;
  *(_QWORD *)(v1224 + 8) = 0x756C657270;
  v1227 = a1[1];
  v1226 = (unint64_t)a1[2];
  if ((unint64_t)v1227 < v1226)
  {
    *v1227 = v1224;
    v1228 = (uint64_t)(v1227 + 1);
    goto LABEL_1167;
  }
  v1229 = *a1;
  v1230 = (char *)v1227 - (char *)*a1;
  v1231 = v1230 >> 3;
  v1232 = (v1230 >> 3) + 1;
  if (v1232 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1233 = v1226 - (_QWORD)v1229;
  if (v1233 >> 2 > v1232)
    v1232 = v1233 >> 2;
  if ((unint64_t)v1233 >= 0x7FFFFFFFFFFFFFF8)
    v1234 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1234 = v1232;
  if (v1234)
  {
    if (v1234 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1235 = (char *)operator new(8 * v1234);
    v1236 = (uint64_t *)&v1235[8 * v1231];
    v1237 = (uint64_t *)&v1235[8 * v1234];
    *v1236 = v1225;
    v1228 = (uint64_t)(v1236 + 1);
    v1238 = (char *)((char *)v1227 - (char *)v1229);
    if (v1227 != v1229)
      goto LABEL_1152;
  }
  else
  {
    v1235 = 0;
    v1236 = (uint64_t *)(8 * v1231);
    v1237 = 0;
    *(_QWORD *)(8 * v1231) = v1225;
    v1228 = 8 * v1231 + 8;
    v1238 = (char *)((char *)v1227 - (char *)v1229);
    if (v1227 != v1229)
    {
LABEL_1152:
      v1239 = (unint64_t)(v1238 - 8);
      if (v1239 < 0x78
        || (uint64_t *)((char *)v1227 - (v1239 & 0xFFFFFFFFFFFFFFF8) - 8) < v1236
        && &v1235[v1230 - (v1239 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1227)
      {
        goto LABEL_1712;
      }
      v1240 = (v1239 >> 3) + 1;
      v1241 = 8 * (v1240 & 0x3FFFFFFFFFFFFFFCLL);
      v1236 = (uint64_t *)((char *)v1236 - v1241);
      v1242 = &v1227[v1241 / 0xFFFFFFFFFFFFFFF8];
      v1243 = v1227 - 2;
      v1244 = &v1235[8 * v1231 - 16];
      v1245 = v1240 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1247 = *((_OWORD *)v1243 - 1);
        v1246 = *(_OWORD *)v1243;
        *((_OWORD *)v1243 - 1) = 0uLL;
        *(_OWORD *)v1243 = 0uLL;
        *((_OWORD *)v1244 - 1) = v1247;
        *(_OWORD *)v1244 = v1246;
        v1243 -= 4;
        v1244 -= 32;
        v1245 -= 4;
      }
      while (v1245);
      v1227 = v1242;
      if (v1240 != (v1240 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1712:
        do
        {
          v1248 = *--v1227;
          *v1227 = 0;
          *--v1236 = v1248;
        }
        while (v1227 != v1229);
      }
      v1227 = *a1;
      v1249 = a1[1];
      *a1 = v1236;
      a1[1] = (uint64_t *)v1228;
      a1[2] = v1237;
      while (v1249 != v1227)
      {
        v1251 = *--v1249;
        v1250 = v1251;
        *v1249 = 0;
        if (v1251)
          (*(void (**)(uint64_t))(*(_QWORD *)v1250 + 8))(v1250);
      }
      goto LABEL_1165;
    }
  }
  *a1 = v1236;
  a1[1] = (uint64_t *)v1228;
  a1[2] = v1237;
LABEL_1165:
  if (v1227)
    operator delete(v1227);
LABEL_1167:
  a1[1] = (uint64_t *)v1228;
  v1252 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1252 = off_1E0E17FB8;
  v1254 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1253 = (unint64_t)a1[2];
  if ((unint64_t)v1254 < v1253)
  {
    *v1254 = v1252;
    v1255 = (uint64_t)(v1254 + 1);
    goto LABEL_1193;
  }
  v1256 = *a1;
  v1257 = (char *)v1254 - (char *)*a1;
  v1258 = v1257 >> 3;
  v1259 = (v1257 >> 3) + 1;
  if (v1259 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1260 = v1253 - (_QWORD)v1256;
  if (v1260 >> 2 > v1259)
    v1259 = v1260 >> 2;
  if ((unint64_t)v1260 >= 0x7FFFFFFFFFFFFFF8)
    v1261 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1261 = v1259;
  if (v1261)
  {
    if (v1261 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1262 = (char *)operator new(8 * v1261);
    v1263 = (_anonymous_namespace_::ReducePatternBase **)&v1262[8 * v1258];
    v1264 = (uint64_t *)&v1262[8 * v1261];
    *v1263 = v1252;
    v1255 = (uint64_t)(v1263 + 1);
    v1265 = (char *)((char *)v1254 - (char *)v1256);
    if (v1254 != (_anonymous_namespace_::ReducePatternBase **)v1256)
      goto LABEL_1178;
  }
  else
  {
    v1262 = 0;
    v1263 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1258);
    v1264 = 0;
    *(_QWORD *)(8 * v1258) = v1252;
    v1255 = 8 * v1258 + 8;
    v1265 = (char *)((char *)v1254 - (char *)v1256);
    if (v1254 != (_anonymous_namespace_::ReducePatternBase **)v1256)
    {
LABEL_1178:
      v1266 = (unint64_t)(v1265 - 8);
      if (v1266 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1254 - (v1266 & 0xFFFFFFFFFFFFFFF8) - 8) < v1263
        && &v1262[v1257 - (v1266 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1254)
      {
        goto LABEL_1713;
      }
      v1267 = (v1266 >> 3) + 1;
      v1268 = 8 * (v1267 & 0x3FFFFFFFFFFFFFFCLL);
      v1263 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1263 - v1268);
      v1269 = &v1254[v1268 / 0xFFFFFFFFFFFFFFF8];
      v1270 = v1254 - 2;
      v1271 = &v1262[8 * v1258 - 16];
      v1272 = v1267 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1274 = *((_OWORD *)v1270 - 1);
        v1273 = *(_OWORD *)v1270;
        *((_OWORD *)v1270 - 1) = 0uLL;
        *(_OWORD *)v1270 = 0uLL;
        *((_OWORD *)v1271 - 1) = v1274;
        *(_OWORD *)v1271 = v1273;
        v1270 -= 4;
        v1271 -= 32;
        v1272 -= 4;
      }
      while (v1272);
      v1254 = v1269;
      if (v1267 != (v1267 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1713:
        do
        {
          v1275 = *--v1254;
          *v1254 = 0;
          *--v1263 = v1275;
        }
        while (v1254 != (_anonymous_namespace_::ReducePatternBase **)v1256);
      }
      v1254 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1276 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1263;
      a1[1] = (uint64_t *)v1255;
      a1[2] = v1264;
      while (v1276 != v1254)
      {
        v1278 = (uint64_t)*--v1276;
        v1277 = v1278;
        *v1276 = 0;
        if (v1278)
          (*(void (**)(uint64_t))(*(_QWORD *)v1277 + 8))(v1277);
      }
      goto LABEL_1191;
    }
  }
  *a1 = (uint64_t *)v1263;
  a1[1] = (uint64_t *)v1255;
  a1[2] = v1264;
LABEL_1191:
  if (v1254)
    operator delete(v1254);
LABEL_1193:
  a1[1] = (uint64_t *)v1255;
  v1279 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1279 = off_1E0E17F88;
  v1281 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1280 = (unint64_t)a1[2];
  if ((unint64_t)v1281 < v1280)
  {
    *v1281 = v1279;
    v1282 = (uint64_t)(v1281 + 1);
    goto LABEL_1219;
  }
  v1283 = *a1;
  v1284 = (char *)v1281 - (char *)*a1;
  v1285 = v1284 >> 3;
  v1286 = (v1284 >> 3) + 1;
  if (v1286 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1287 = v1280 - (_QWORD)v1283;
  if (v1287 >> 2 > v1286)
    v1286 = v1287 >> 2;
  if ((unint64_t)v1287 >= 0x7FFFFFFFFFFFFFF8)
    v1288 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1288 = v1286;
  if (v1288)
  {
    if (v1288 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1289 = (char *)operator new(8 * v1288);
    v1290 = (_anonymous_namespace_::ReducePatternBase **)&v1289[8 * v1285];
    v1291 = (uint64_t *)&v1289[8 * v1288];
    *v1290 = v1279;
    v1282 = (uint64_t)(v1290 + 1);
    v1292 = (char *)((char *)v1281 - (char *)v1283);
    if (v1281 != (_anonymous_namespace_::ReducePatternBase **)v1283)
      goto LABEL_1204;
  }
  else
  {
    v1289 = 0;
    v1290 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1285);
    v1291 = 0;
    *(_QWORD *)(8 * v1285) = v1279;
    v1282 = 8 * v1285 + 8;
    v1292 = (char *)((char *)v1281 - (char *)v1283);
    if (v1281 != (_anonymous_namespace_::ReducePatternBase **)v1283)
    {
LABEL_1204:
      v1293 = (unint64_t)(v1292 - 8);
      if (v1293 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1281 - (v1293 & 0xFFFFFFFFFFFFFFF8) - 8) < v1290
        && &v1289[v1284 - (v1293 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1281)
      {
        goto LABEL_1714;
      }
      v1294 = (v1293 >> 3) + 1;
      v1295 = 8 * (v1294 & 0x3FFFFFFFFFFFFFFCLL);
      v1290 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1290 - v1295);
      v1296 = &v1281[v1295 / 0xFFFFFFFFFFFFFFF8];
      v1297 = v1281 - 2;
      v1298 = &v1289[8 * v1285 - 16];
      v1299 = v1294 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1301 = *((_OWORD *)v1297 - 1);
        v1300 = *(_OWORD *)v1297;
        *((_OWORD *)v1297 - 1) = 0uLL;
        *(_OWORD *)v1297 = 0uLL;
        *((_OWORD *)v1298 - 1) = v1301;
        *(_OWORD *)v1298 = v1300;
        v1297 -= 4;
        v1298 -= 32;
        v1299 -= 4;
      }
      while (v1299);
      v1281 = v1296;
      if (v1294 != (v1294 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1714:
        do
        {
          v1302 = *--v1281;
          *v1281 = 0;
          *--v1290 = v1302;
        }
        while (v1281 != (_anonymous_namespace_::ReducePatternBase **)v1283);
      }
      v1281 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1303 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1290;
      a1[1] = (uint64_t *)v1282;
      a1[2] = v1291;
      while (v1303 != v1281)
      {
        v1305 = (uint64_t)*--v1303;
        v1304 = v1305;
        *v1303 = 0;
        if (v1305)
          (*(void (**)(uint64_t))(*(_QWORD *)v1304 + 8))(v1304);
      }
      goto LABEL_1217;
    }
  }
  *a1 = (uint64_t *)v1290;
  a1[1] = (uint64_t *)v1282;
  a1[2] = v1291;
LABEL_1217:
  if (v1281)
    operator delete(v1281);
LABEL_1219:
  a1[1] = (uint64_t *)v1282;
  v1306 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1306 = off_1E0E17FE8;
  v1308 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1307 = (unint64_t)a1[2];
  if ((unint64_t)v1308 < v1307)
  {
    *v1308 = v1306;
    v1309 = (uint64_t)(v1308 + 1);
    goto LABEL_1245;
  }
  v1310 = *a1;
  v1311 = (char *)v1308 - (char *)*a1;
  v1312 = v1311 >> 3;
  v1313 = (v1311 >> 3) + 1;
  if (v1313 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1314 = v1307 - (_QWORD)v1310;
  if (v1314 >> 2 > v1313)
    v1313 = v1314 >> 2;
  if ((unint64_t)v1314 >= 0x7FFFFFFFFFFFFFF8)
    v1315 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1315 = v1313;
  if (v1315)
  {
    if (v1315 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1316 = (char *)operator new(8 * v1315);
    v1317 = (_anonymous_namespace_::ReducePatternBase **)&v1316[8 * v1312];
    v1318 = (uint64_t *)&v1316[8 * v1315];
    *v1317 = v1306;
    v1309 = (uint64_t)(v1317 + 1);
    v1319 = (char *)((char *)v1308 - (char *)v1310);
    if (v1308 != (_anonymous_namespace_::ReducePatternBase **)v1310)
      goto LABEL_1230;
  }
  else
  {
    v1316 = 0;
    v1317 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1312);
    v1318 = 0;
    *(_QWORD *)(8 * v1312) = v1306;
    v1309 = 8 * v1312 + 8;
    v1319 = (char *)((char *)v1308 - (char *)v1310);
    if (v1308 != (_anonymous_namespace_::ReducePatternBase **)v1310)
    {
LABEL_1230:
      v1320 = (unint64_t)(v1319 - 8);
      if (v1320 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1308 - (v1320 & 0xFFFFFFFFFFFFFFF8) - 8) < v1317
        && &v1316[v1311 - (v1320 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1308)
      {
        goto LABEL_1715;
      }
      v1321 = (v1320 >> 3) + 1;
      v1322 = 8 * (v1321 & 0x3FFFFFFFFFFFFFFCLL);
      v1317 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1317 - v1322);
      v1323 = &v1308[v1322 / 0xFFFFFFFFFFFFFFF8];
      v1324 = v1308 - 2;
      v1325 = &v1316[8 * v1312 - 16];
      v1326 = v1321 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1328 = *((_OWORD *)v1324 - 1);
        v1327 = *(_OWORD *)v1324;
        *((_OWORD *)v1324 - 1) = 0uLL;
        *(_OWORD *)v1324 = 0uLL;
        *((_OWORD *)v1325 - 1) = v1328;
        *(_OWORD *)v1325 = v1327;
        v1324 -= 4;
        v1325 -= 32;
        v1326 -= 4;
      }
      while (v1326);
      v1308 = v1323;
      if (v1321 != (v1321 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1715:
        do
        {
          v1329 = *--v1308;
          *v1308 = 0;
          *--v1317 = v1329;
        }
        while (v1308 != (_anonymous_namespace_::ReducePatternBase **)v1310);
      }
      v1308 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1330 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1317;
      a1[1] = (uint64_t *)v1309;
      a1[2] = v1318;
      while (v1330 != v1308)
      {
        v1332 = (uint64_t)*--v1330;
        v1331 = v1332;
        *v1330 = 0;
        if (v1332)
          (*(void (**)(uint64_t))(*(_QWORD *)v1331 + 8))(v1331);
      }
      goto LABEL_1243;
    }
  }
  *a1 = (uint64_t *)v1317;
  a1[1] = (uint64_t *)v1309;
  a1[2] = v1318;
LABEL_1243:
  if (v1308)
    operator delete(v1308);
LABEL_1245:
  a1[1] = (uint64_t *)v1309;
  v1333 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1333 = off_1E0E18018;
  v1335 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1334 = (unint64_t)a1[2];
  if ((unint64_t)v1335 < v1334)
  {
    *v1335 = v1333;
    v1336 = (uint64_t)(v1335 + 1);
    goto LABEL_1271;
  }
  v1337 = *a1;
  v1338 = (char *)v1335 - (char *)*a1;
  v1339 = v1338 >> 3;
  v1340 = (v1338 >> 3) + 1;
  if (v1340 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1341 = v1334 - (_QWORD)v1337;
  if (v1341 >> 2 > v1340)
    v1340 = v1341 >> 2;
  if ((unint64_t)v1341 >= 0x7FFFFFFFFFFFFFF8)
    v1342 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1342 = v1340;
  if (v1342)
  {
    if (v1342 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1343 = (char *)operator new(8 * v1342);
    v1344 = (_anonymous_namespace_::ReducePatternBase **)&v1343[8 * v1339];
    v1345 = (uint64_t *)&v1343[8 * v1342];
    *v1344 = v1333;
    v1336 = (uint64_t)(v1344 + 1);
    v1346 = (char *)((char *)v1335 - (char *)v1337);
    if (v1335 != (_anonymous_namespace_::ReducePatternBase **)v1337)
      goto LABEL_1256;
  }
  else
  {
    v1343 = 0;
    v1344 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1339);
    v1345 = 0;
    *(_QWORD *)(8 * v1339) = v1333;
    v1336 = 8 * v1339 + 8;
    v1346 = (char *)((char *)v1335 - (char *)v1337);
    if (v1335 != (_anonymous_namespace_::ReducePatternBase **)v1337)
    {
LABEL_1256:
      v1347 = (unint64_t)(v1346 - 8);
      if (v1347 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1335 - (v1347 & 0xFFFFFFFFFFFFFFF8) - 8) < v1344
        && &v1343[v1338 - (v1347 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1335)
      {
        goto LABEL_1716;
      }
      v1348 = (v1347 >> 3) + 1;
      v1349 = 8 * (v1348 & 0x3FFFFFFFFFFFFFFCLL);
      v1344 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1344 - v1349);
      v1350 = &v1335[v1349 / 0xFFFFFFFFFFFFFFF8];
      v1351 = v1335 - 2;
      v1352 = &v1343[8 * v1339 - 16];
      v1353 = v1348 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1355 = *((_OWORD *)v1351 - 1);
        v1354 = *(_OWORD *)v1351;
        *((_OWORD *)v1351 - 1) = 0uLL;
        *(_OWORD *)v1351 = 0uLL;
        *((_OWORD *)v1352 - 1) = v1355;
        *(_OWORD *)v1352 = v1354;
        v1351 -= 4;
        v1352 -= 32;
        v1353 -= 4;
      }
      while (v1353);
      v1335 = v1350;
      if (v1348 != (v1348 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1716:
        do
        {
          v1356 = *--v1335;
          *v1335 = 0;
          *--v1344 = v1356;
        }
        while (v1335 != (_anonymous_namespace_::ReducePatternBase **)v1337);
      }
      v1335 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1357 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1344;
      a1[1] = (uint64_t *)v1336;
      a1[2] = v1345;
      while (v1357 != v1335)
      {
        v1359 = (uint64_t)*--v1357;
        v1358 = v1359;
        *v1357 = 0;
        if (v1359)
          (*(void (**)(uint64_t))(*(_QWORD *)v1358 + 8))(v1358);
      }
      goto LABEL_1269;
    }
  }
  *a1 = (uint64_t *)v1344;
  a1[1] = (uint64_t *)v1336;
  a1[2] = v1345;
LABEL_1269:
  if (v1335)
    operator delete(v1335);
LABEL_1271:
  a1[1] = (uint64_t *)v1336;
  v1360 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1360 = off_1E0E18F30;
  v1362 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1361 = (unint64_t)a1[2];
  if ((unint64_t)v1362 < v1361)
  {
    *v1362 = v1360;
    v1363 = (uint64_t)(v1362 + 1);
    goto LABEL_1297;
  }
  v1364 = *a1;
  v1365 = (char *)v1362 - (char *)*a1;
  v1366 = v1365 >> 3;
  v1367 = (v1365 >> 3) + 1;
  if (v1367 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1368 = v1361 - (_QWORD)v1364;
  if (v1368 >> 2 > v1367)
    v1367 = v1368 >> 2;
  if ((unint64_t)v1368 >= 0x7FFFFFFFFFFFFFF8)
    v1369 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1369 = v1367;
  if (v1369)
  {
    if (v1369 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1370 = (char *)operator new(8 * v1369);
    v1371 = (_anonymous_namespace_::ReducePatternBase **)&v1370[8 * v1366];
    v1372 = (uint64_t *)&v1370[8 * v1369];
    *v1371 = v1360;
    v1363 = (uint64_t)(v1371 + 1);
    v1373 = (char *)((char *)v1362 - (char *)v1364);
    if (v1362 != (_anonymous_namespace_::ReducePatternBase **)v1364)
      goto LABEL_1282;
  }
  else
  {
    v1370 = 0;
    v1371 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1366);
    v1372 = 0;
    *(_QWORD *)(8 * v1366) = v1360;
    v1363 = 8 * v1366 + 8;
    v1373 = (char *)((char *)v1362 - (char *)v1364);
    if (v1362 != (_anonymous_namespace_::ReducePatternBase **)v1364)
    {
LABEL_1282:
      v1374 = (unint64_t)(v1373 - 8);
      if (v1374 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1362 - (v1374 & 0xFFFFFFFFFFFFFFF8) - 8) < v1371
        && &v1370[v1365 - (v1374 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1362)
      {
        goto LABEL_1717;
      }
      v1375 = (v1374 >> 3) + 1;
      v1376 = 8 * (v1375 & 0x3FFFFFFFFFFFFFFCLL);
      v1371 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1371 - v1376);
      v1377 = &v1362[v1376 / 0xFFFFFFFFFFFFFFF8];
      v1378 = v1362 - 2;
      v1379 = &v1370[8 * v1366 - 16];
      v1380 = v1375 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1382 = *((_OWORD *)v1378 - 1);
        v1381 = *(_OWORD *)v1378;
        *((_OWORD *)v1378 - 1) = 0uLL;
        *(_OWORD *)v1378 = 0uLL;
        *((_OWORD *)v1379 - 1) = v1382;
        *(_OWORD *)v1379 = v1381;
        v1378 -= 4;
        v1379 -= 32;
        v1380 -= 4;
      }
      while (v1380);
      v1362 = v1377;
      if (v1375 != (v1375 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1717:
        do
        {
          v1383 = *--v1362;
          *v1362 = 0;
          *--v1371 = v1383;
        }
        while (v1362 != (_anonymous_namespace_::ReducePatternBase **)v1364);
      }
      v1362 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1384 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1371;
      a1[1] = (uint64_t *)v1363;
      a1[2] = v1372;
      while (v1384 != v1362)
      {
        v1386 = (uint64_t)*--v1384;
        v1385 = v1386;
        *v1384 = 0;
        if (v1386)
          (*(void (**)(uint64_t))(*(_QWORD *)v1385 + 8))(v1385);
      }
      goto LABEL_1295;
    }
  }
  *a1 = (uint64_t *)v1371;
  a1[1] = (uint64_t *)v1363;
  a1[2] = v1372;
LABEL_1295:
  if (v1362)
    operator delete(v1362);
LABEL_1297:
  a1[1] = (uint64_t *)v1363;
  v1387 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1387 = off_1E0E18048;
  v1389 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1388 = (unint64_t)a1[2];
  if ((unint64_t)v1389 < v1388)
  {
    *v1389 = v1387;
    v1390 = (uint64_t)(v1389 + 1);
    goto LABEL_1323;
  }
  v1391 = *a1;
  v1392 = (char *)v1389 - (char *)*a1;
  v1393 = v1392 >> 3;
  v1394 = (v1392 >> 3) + 1;
  if (v1394 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1395 = v1388 - (_QWORD)v1391;
  if (v1395 >> 2 > v1394)
    v1394 = v1395 >> 2;
  if ((unint64_t)v1395 >= 0x7FFFFFFFFFFFFFF8)
    v1396 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1396 = v1394;
  if (v1396)
  {
    if (v1396 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1397 = (char *)operator new(8 * v1396);
    v1398 = (_anonymous_namespace_::ReducePatternBase **)&v1397[8 * v1393];
    v1399 = (uint64_t *)&v1397[8 * v1396];
    *v1398 = v1387;
    v1390 = (uint64_t)(v1398 + 1);
    v1400 = (char *)((char *)v1389 - (char *)v1391);
    if (v1389 != (_anonymous_namespace_::ReducePatternBase **)v1391)
      goto LABEL_1308;
  }
  else
  {
    v1397 = 0;
    v1398 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1393);
    v1399 = 0;
    *(_QWORD *)(8 * v1393) = v1387;
    v1390 = 8 * v1393 + 8;
    v1400 = (char *)((char *)v1389 - (char *)v1391);
    if (v1389 != (_anonymous_namespace_::ReducePatternBase **)v1391)
    {
LABEL_1308:
      v1401 = (unint64_t)(v1400 - 8);
      if (v1401 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1389 - (v1401 & 0xFFFFFFFFFFFFFFF8) - 8) < v1398
        && &v1397[v1392 - (v1401 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1389)
      {
        goto LABEL_1718;
      }
      v1402 = (v1401 >> 3) + 1;
      v1403 = 8 * (v1402 & 0x3FFFFFFFFFFFFFFCLL);
      v1398 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1398 - v1403);
      v1404 = &v1389[v1403 / 0xFFFFFFFFFFFFFFF8];
      v1405 = v1389 - 2;
      v1406 = &v1397[8 * v1393 - 16];
      v1407 = v1402 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1409 = *((_OWORD *)v1405 - 1);
        v1408 = *(_OWORD *)v1405;
        *((_OWORD *)v1405 - 1) = 0uLL;
        *(_OWORD *)v1405 = 0uLL;
        *((_OWORD *)v1406 - 1) = v1409;
        *(_OWORD *)v1406 = v1408;
        v1405 -= 4;
        v1406 -= 32;
        v1407 -= 4;
      }
      while (v1407);
      v1389 = v1404;
      if (v1402 != (v1402 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1718:
        do
        {
          v1410 = *--v1389;
          *v1389 = 0;
          *--v1398 = v1410;
        }
        while (v1389 != (_anonymous_namespace_::ReducePatternBase **)v1391);
      }
      v1389 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1411 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1398;
      a1[1] = (uint64_t *)v1390;
      a1[2] = v1399;
      while (v1411 != v1389)
      {
        v1413 = (uint64_t)*--v1411;
        v1412 = v1413;
        *v1411 = 0;
        if (v1413)
          (*(void (**)(uint64_t))(*(_QWORD *)v1412 + 8))(v1412);
      }
      goto LABEL_1321;
    }
  }
  *a1 = (uint64_t *)v1398;
  a1[1] = (uint64_t *)v1390;
  a1[2] = v1399;
LABEL_1321:
  if (v1389)
    operator delete(v1389);
LABEL_1323:
  a1[1] = (uint64_t *)v1390;
  v1414 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1414 = off_1E0E16248;
  v1416 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1415 = (unint64_t)a1[2];
  if ((unint64_t)v1416 < v1415)
  {
    *v1416 = v1414;
    v1417 = (uint64_t)(v1416 + 1);
    goto LABEL_1349;
  }
  v1418 = *a1;
  v1419 = (char *)v1416 - (char *)*a1;
  v1420 = v1419 >> 3;
  v1421 = (v1419 >> 3) + 1;
  if (v1421 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1422 = v1415 - (_QWORD)v1418;
  if (v1422 >> 2 > v1421)
    v1421 = v1422 >> 2;
  if ((unint64_t)v1422 >= 0x7FFFFFFFFFFFFFF8)
    v1423 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1423 = v1421;
  if (v1423)
  {
    if (v1423 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1424 = (char *)operator new(8 * v1423);
    v1425 = (_anonymous_namespace_::ReducePatternBase **)&v1424[8 * v1420];
    v1426 = (uint64_t *)&v1424[8 * v1423];
    *v1425 = v1414;
    v1417 = (uint64_t)(v1425 + 1);
    v1427 = (char *)((char *)v1416 - (char *)v1418);
    if (v1416 != (_anonymous_namespace_::ReducePatternBase **)v1418)
      goto LABEL_1334;
  }
  else
  {
    v1424 = 0;
    v1425 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1420);
    v1426 = 0;
    *(_QWORD *)(8 * v1420) = v1414;
    v1417 = 8 * v1420 + 8;
    v1427 = (char *)((char *)v1416 - (char *)v1418);
    if (v1416 != (_anonymous_namespace_::ReducePatternBase **)v1418)
    {
LABEL_1334:
      v1428 = (unint64_t)(v1427 - 8);
      if (v1428 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1416 - (v1428 & 0xFFFFFFFFFFFFFFF8) - 8) < v1425
        && &v1424[v1419 - (v1428 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1416)
      {
        goto LABEL_1719;
      }
      v1429 = (v1428 >> 3) + 1;
      v1430 = 8 * (v1429 & 0x3FFFFFFFFFFFFFFCLL);
      v1425 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1425 - v1430);
      v1431 = &v1416[v1430 / 0xFFFFFFFFFFFFFFF8];
      v1432 = v1416 - 2;
      v1433 = &v1424[8 * v1420 - 16];
      v1434 = v1429 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1436 = *((_OWORD *)v1432 - 1);
        v1435 = *(_OWORD *)v1432;
        *((_OWORD *)v1432 - 1) = 0uLL;
        *(_OWORD *)v1432 = 0uLL;
        *((_OWORD *)v1433 - 1) = v1436;
        *(_OWORD *)v1433 = v1435;
        v1432 -= 4;
        v1433 -= 32;
        v1434 -= 4;
      }
      while (v1434);
      v1416 = v1431;
      if (v1429 != (v1429 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1719:
        do
        {
          v1437 = *--v1416;
          *v1416 = 0;
          *--v1425 = v1437;
        }
        while (v1416 != (_anonymous_namespace_::ReducePatternBase **)v1418);
      }
      v1416 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1438 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1425;
      a1[1] = (uint64_t *)v1417;
      a1[2] = v1426;
      while (v1438 != v1416)
      {
        v1440 = (uint64_t)*--v1438;
        v1439 = v1440;
        *v1438 = 0;
        if (v1440)
          (*(void (**)(uint64_t))(*(_QWORD *)v1439 + 8))(v1439);
      }
      goto LABEL_1347;
    }
  }
  *a1 = (uint64_t *)v1425;
  a1[1] = (uint64_t *)v1417;
  a1[2] = v1426;
LABEL_1347:
  if (v1416)
    operator delete(v1416);
LABEL_1349:
  a1[1] = (uint64_t *)v1417;
  v1441 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1441 = off_1E0E16A88;
  v1443 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1442 = (unint64_t)a1[2];
  if ((unint64_t)v1443 < v1442)
  {
    *v1443 = v1441;
    v1444 = (uint64_t)(v1443 + 1);
    goto LABEL_1375;
  }
  v1445 = *a1;
  v1446 = (char *)v1443 - (char *)*a1;
  v1447 = v1446 >> 3;
  v1448 = (v1446 >> 3) + 1;
  if (v1448 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1449 = v1442 - (_QWORD)v1445;
  if (v1449 >> 2 > v1448)
    v1448 = v1449 >> 2;
  if ((unint64_t)v1449 >= 0x7FFFFFFFFFFFFFF8)
    v1450 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1450 = v1448;
  if (v1450)
  {
    if (v1450 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1451 = (char *)operator new(8 * v1450);
    v1452 = (_anonymous_namespace_::ReducePatternBase **)&v1451[8 * v1447];
    v1453 = (uint64_t *)&v1451[8 * v1450];
    *v1452 = v1441;
    v1444 = (uint64_t)(v1452 + 1);
    v1454 = (char *)((char *)v1443 - (char *)v1445);
    if (v1443 != (_anonymous_namespace_::ReducePatternBase **)v1445)
      goto LABEL_1360;
  }
  else
  {
    v1451 = 0;
    v1452 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1447);
    v1453 = 0;
    *(_QWORD *)(8 * v1447) = v1441;
    v1444 = 8 * v1447 + 8;
    v1454 = (char *)((char *)v1443 - (char *)v1445);
    if (v1443 != (_anonymous_namespace_::ReducePatternBase **)v1445)
    {
LABEL_1360:
      v1455 = (unint64_t)(v1454 - 8);
      if (v1455 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1443 - (v1455 & 0xFFFFFFFFFFFFFFF8) - 8) < v1452
        && &v1451[v1446 - (v1455 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1443)
      {
        goto LABEL_1720;
      }
      v1456 = (v1455 >> 3) + 1;
      v1457 = 8 * (v1456 & 0x3FFFFFFFFFFFFFFCLL);
      v1452 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1452 - v1457);
      v1458 = &v1443[v1457 / 0xFFFFFFFFFFFFFFF8];
      v1459 = v1443 - 2;
      v1460 = &v1451[8 * v1447 - 16];
      v1461 = v1456 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1463 = *((_OWORD *)v1459 - 1);
        v1462 = *(_OWORD *)v1459;
        *((_OWORD *)v1459 - 1) = 0uLL;
        *(_OWORD *)v1459 = 0uLL;
        *((_OWORD *)v1460 - 1) = v1463;
        *(_OWORD *)v1460 = v1462;
        v1459 -= 4;
        v1460 -= 32;
        v1461 -= 4;
      }
      while (v1461);
      v1443 = v1458;
      if (v1456 != (v1456 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1720:
        do
        {
          v1464 = *--v1443;
          *v1443 = 0;
          *--v1452 = v1464;
        }
        while (v1443 != (_anonymous_namespace_::ReducePatternBase **)v1445);
      }
      v1443 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1465 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1452;
      a1[1] = (uint64_t *)v1444;
      a1[2] = v1453;
      while (v1465 != v1443)
      {
        v1467 = (uint64_t)*--v1465;
        v1466 = v1467;
        *v1465 = 0;
        if (v1467)
          (*(void (**)(uint64_t))(*(_QWORD *)v1466 + 8))(v1466);
      }
      goto LABEL_1373;
    }
  }
  *a1 = (uint64_t *)v1452;
  a1[1] = (uint64_t *)v1444;
  a1[2] = v1453;
LABEL_1373:
  if (v1443)
    operator delete(v1443);
LABEL_1375:
  a1[1] = (uint64_t *)v1444;
  v1468 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1468 = off_1E0E16278;
  v1470 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1469 = (unint64_t)a1[2];
  if ((unint64_t)v1470 < v1469)
  {
    *v1470 = v1468;
    v1471 = (uint64_t)(v1470 + 1);
    goto LABEL_1401;
  }
  v1472 = *a1;
  v1473 = (char *)v1470 - (char *)*a1;
  v1474 = v1473 >> 3;
  v1475 = (v1473 >> 3) + 1;
  if (v1475 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1476 = v1469 - (_QWORD)v1472;
  if (v1476 >> 2 > v1475)
    v1475 = v1476 >> 2;
  if ((unint64_t)v1476 >= 0x7FFFFFFFFFFFFFF8)
    v1477 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1477 = v1475;
  if (v1477)
  {
    if (v1477 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1478 = (char *)operator new(8 * v1477);
    v1479 = (_anonymous_namespace_::ReducePatternBase **)&v1478[8 * v1474];
    v1480 = (uint64_t *)&v1478[8 * v1477];
    *v1479 = v1468;
    v1471 = (uint64_t)(v1479 + 1);
    v1481 = (char *)((char *)v1470 - (char *)v1472);
    if (v1470 != (_anonymous_namespace_::ReducePatternBase **)v1472)
      goto LABEL_1386;
  }
  else
  {
    v1478 = 0;
    v1479 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1474);
    v1480 = 0;
    *(_QWORD *)(8 * v1474) = v1468;
    v1471 = 8 * v1474 + 8;
    v1481 = (char *)((char *)v1470 - (char *)v1472);
    if (v1470 != (_anonymous_namespace_::ReducePatternBase **)v1472)
    {
LABEL_1386:
      v1482 = (unint64_t)(v1481 - 8);
      if (v1482 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1470 - (v1482 & 0xFFFFFFFFFFFFFFF8) - 8) < v1479
        && &v1478[v1473 - (v1482 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1470)
      {
        goto LABEL_1721;
      }
      v1483 = (v1482 >> 3) + 1;
      v1484 = 8 * (v1483 & 0x3FFFFFFFFFFFFFFCLL);
      v1479 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1479 - v1484);
      v1485 = &v1470[v1484 / 0xFFFFFFFFFFFFFFF8];
      v1486 = v1470 - 2;
      v1487 = &v1478[8 * v1474 - 16];
      v1488 = v1483 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1490 = *((_OWORD *)v1486 - 1);
        v1489 = *(_OWORD *)v1486;
        *((_OWORD *)v1486 - 1) = 0uLL;
        *(_OWORD *)v1486 = 0uLL;
        *((_OWORD *)v1487 - 1) = v1490;
        *(_OWORD *)v1487 = v1489;
        v1486 -= 4;
        v1487 -= 32;
        v1488 -= 4;
      }
      while (v1488);
      v1470 = v1485;
      if (v1483 != (v1483 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1721:
        do
        {
          v1491 = *--v1470;
          *v1470 = 0;
          *--v1479 = v1491;
        }
        while (v1470 != (_anonymous_namespace_::ReducePatternBase **)v1472);
      }
      v1470 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1492 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1479;
      a1[1] = (uint64_t *)v1471;
      a1[2] = v1480;
      while (v1492 != v1470)
      {
        v1494 = (uint64_t)*--v1492;
        v1493 = v1494;
        *v1492 = 0;
        if (v1494)
          (*(void (**)(uint64_t))(*(_QWORD *)v1493 + 8))(v1493);
      }
      goto LABEL_1399;
    }
  }
  *a1 = (uint64_t *)v1479;
  a1[1] = (uint64_t *)v1471;
  a1[2] = v1480;
LABEL_1399:
  if (v1470)
    operator delete(v1470);
LABEL_1401:
  a1[1] = (uint64_t *)v1471;
  v1495 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1495 = off_1E0E16AE8;
  v1497 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1496 = (unint64_t)a1[2];
  if ((unint64_t)v1497 < v1496)
  {
    *v1497 = v1495;
    v1498 = (uint64_t)(v1497 + 1);
    goto LABEL_1427;
  }
  v1499 = *a1;
  v1500 = (char *)v1497 - (char *)*a1;
  v1501 = v1500 >> 3;
  v1502 = (v1500 >> 3) + 1;
  if (v1502 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1503 = v1496 - (_QWORD)v1499;
  if (v1503 >> 2 > v1502)
    v1502 = v1503 >> 2;
  if ((unint64_t)v1503 >= 0x7FFFFFFFFFFFFFF8)
    v1504 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1504 = v1502;
  if (v1504)
  {
    if (v1504 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1505 = (char *)operator new(8 * v1504);
    v1506 = (_anonymous_namespace_::ReducePatternBase **)&v1505[8 * v1501];
    v1507 = (uint64_t *)&v1505[8 * v1504];
    *v1506 = v1495;
    v1498 = (uint64_t)(v1506 + 1);
    v1508 = (char *)((char *)v1497 - (char *)v1499);
    if (v1497 != (_anonymous_namespace_::ReducePatternBase **)v1499)
      goto LABEL_1412;
  }
  else
  {
    v1505 = 0;
    v1506 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1501);
    v1507 = 0;
    *(_QWORD *)(8 * v1501) = v1495;
    v1498 = 8 * v1501 + 8;
    v1508 = (char *)((char *)v1497 - (char *)v1499);
    if (v1497 != (_anonymous_namespace_::ReducePatternBase **)v1499)
    {
LABEL_1412:
      v1509 = (unint64_t)(v1508 - 8);
      if (v1509 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1497 - (v1509 & 0xFFFFFFFFFFFFFFF8) - 8) < v1506
        && &v1505[v1500 - (v1509 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1497)
      {
        goto LABEL_1722;
      }
      v1510 = (v1509 >> 3) + 1;
      v1511 = 8 * (v1510 & 0x3FFFFFFFFFFFFFFCLL);
      v1506 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1506 - v1511);
      v1512 = &v1497[v1511 / 0xFFFFFFFFFFFFFFF8];
      v1513 = v1497 - 2;
      v1514 = &v1505[8 * v1501 - 16];
      v1515 = v1510 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1517 = *((_OWORD *)v1513 - 1);
        v1516 = *(_OWORD *)v1513;
        *((_OWORD *)v1513 - 1) = 0uLL;
        *(_OWORD *)v1513 = 0uLL;
        *((_OWORD *)v1514 - 1) = v1517;
        *(_OWORD *)v1514 = v1516;
        v1513 -= 4;
        v1514 -= 32;
        v1515 -= 4;
      }
      while (v1515);
      v1497 = v1512;
      if (v1510 != (v1510 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1722:
        do
        {
          v1518 = *--v1497;
          *v1497 = 0;
          *--v1506 = v1518;
        }
        while (v1497 != (_anonymous_namespace_::ReducePatternBase **)v1499);
      }
      v1497 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1519 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1506;
      a1[1] = (uint64_t *)v1498;
      a1[2] = v1507;
      while (v1519 != v1497)
      {
        v1521 = (uint64_t)*--v1519;
        v1520 = v1521;
        *v1519 = 0;
        if (v1521)
          (*(void (**)(uint64_t))(*(_QWORD *)v1520 + 8))(v1520);
      }
      goto LABEL_1425;
    }
  }
  *a1 = (uint64_t *)v1506;
  a1[1] = (uint64_t *)v1498;
  a1[2] = v1507;
LABEL_1425:
  if (v1497)
    operator delete(v1497);
LABEL_1427:
  a1[1] = (uint64_t *)v1498;
  v1522 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1522 = off_1E0E162A8;
  v1524 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1523 = (unint64_t)a1[2];
  if ((unint64_t)v1524 < v1523)
  {
    *v1524 = v1522;
    v1525 = (uint64_t)(v1524 + 1);
    goto LABEL_1453;
  }
  v1526 = *a1;
  v1527 = (char *)v1524 - (char *)*a1;
  v1528 = v1527 >> 3;
  v1529 = (v1527 >> 3) + 1;
  if (v1529 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1530 = v1523 - (_QWORD)v1526;
  if (v1530 >> 2 > v1529)
    v1529 = v1530 >> 2;
  if ((unint64_t)v1530 >= 0x7FFFFFFFFFFFFFF8)
    v1531 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1531 = v1529;
  if (v1531)
  {
    if (v1531 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1532 = (char *)operator new(8 * v1531);
    v1533 = (_anonymous_namespace_::ReducePatternBase **)&v1532[8 * v1528];
    v1534 = (uint64_t *)&v1532[8 * v1531];
    *v1533 = v1522;
    v1525 = (uint64_t)(v1533 + 1);
    v1535 = (char *)((char *)v1524 - (char *)v1526);
    if (v1524 != (_anonymous_namespace_::ReducePatternBase **)v1526)
      goto LABEL_1438;
  }
  else
  {
    v1532 = 0;
    v1533 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1528);
    v1534 = 0;
    *(_QWORD *)(8 * v1528) = v1522;
    v1525 = 8 * v1528 + 8;
    v1535 = (char *)((char *)v1524 - (char *)v1526);
    if (v1524 != (_anonymous_namespace_::ReducePatternBase **)v1526)
    {
LABEL_1438:
      v1536 = (unint64_t)(v1535 - 8);
      if (v1536 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1524 - (v1536 & 0xFFFFFFFFFFFFFFF8) - 8) < v1533
        && &v1532[v1527 - (v1536 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1524)
      {
        goto LABEL_1723;
      }
      v1537 = (v1536 >> 3) + 1;
      v1538 = 8 * (v1537 & 0x3FFFFFFFFFFFFFFCLL);
      v1533 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1533 - v1538);
      v1539 = &v1524[v1538 / 0xFFFFFFFFFFFFFFF8];
      v1540 = v1524 - 2;
      v1541 = &v1532[8 * v1528 - 16];
      v1542 = v1537 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1544 = *((_OWORD *)v1540 - 1);
        v1543 = *(_OWORD *)v1540;
        *((_OWORD *)v1540 - 1) = 0uLL;
        *(_OWORD *)v1540 = 0uLL;
        *((_OWORD *)v1541 - 1) = v1544;
        *(_OWORD *)v1541 = v1543;
        v1540 -= 4;
        v1541 -= 32;
        v1542 -= 4;
      }
      while (v1542);
      v1524 = v1539;
      if (v1537 != (v1537 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1723:
        do
        {
          v1545 = *--v1524;
          *v1524 = 0;
          *--v1533 = v1545;
        }
        while (v1524 != (_anonymous_namespace_::ReducePatternBase **)v1526);
      }
      v1524 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1546 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1533;
      a1[1] = (uint64_t *)v1525;
      a1[2] = v1534;
      while (v1546 != v1524)
      {
        v1548 = (uint64_t)*--v1546;
        v1547 = v1548;
        *v1546 = 0;
        if (v1548)
          (*(void (**)(uint64_t))(*(_QWORD *)v1547 + 8))(v1547);
      }
      goto LABEL_1451;
    }
  }
  *a1 = (uint64_t *)v1533;
  a1[1] = (uint64_t *)v1525;
  a1[2] = v1534;
LABEL_1451:
  if (v1524)
    operator delete(v1524);
LABEL_1453:
  a1[1] = (uint64_t *)v1525;
  v1549 = (_anonymous_namespace_::ReducePatternBase *)operator new();
  *(_QWORD *)v1549 = off_1E0E18F60;
  v1551 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
  v1550 = (unint64_t)a1[2];
  if ((unint64_t)v1551 < v1550)
  {
    *v1551 = v1549;
    v1552 = (uint64_t)(v1551 + 1);
    goto LABEL_1479;
  }
  v1553 = *a1;
  v1554 = (char *)v1551 - (char *)*a1;
  v1555 = v1554 >> 3;
  v1556 = (v1554 >> 3) + 1;
  if (v1556 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1557 = v1550 - (_QWORD)v1553;
  if (v1557 >> 2 > v1556)
    v1556 = v1557 >> 2;
  if ((unint64_t)v1557 >= 0x7FFFFFFFFFFFFFF8)
    v1558 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1558 = v1556;
  if (v1558)
  {
    if (v1558 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1559 = (char *)operator new(8 * v1558);
    v1560 = (_anonymous_namespace_::ReducePatternBase **)&v1559[8 * v1555];
    v1561 = (uint64_t *)&v1559[8 * v1558];
    *v1560 = v1549;
    v1552 = (uint64_t)(v1560 + 1);
    v1562 = (char *)((char *)v1551 - (char *)v1553);
    if (v1551 != (_anonymous_namespace_::ReducePatternBase **)v1553)
      goto LABEL_1464;
  }
  else
  {
    v1559 = 0;
    v1560 = (_anonymous_namespace_::ReducePatternBase **)(8 * v1555);
    v1561 = 0;
    *(_QWORD *)(8 * v1555) = v1549;
    v1552 = 8 * v1555 + 8;
    v1562 = (char *)((char *)v1551 - (char *)v1553);
    if (v1551 != (_anonymous_namespace_::ReducePatternBase **)v1553)
    {
LABEL_1464:
      v1563 = (unint64_t)(v1562 - 8);
      if (v1563 < 0x78
        || (_anonymous_namespace_::ReducePatternBase **)((char *)v1551 - (v1563 & 0xFFFFFFFFFFFFFFF8) - 8) < v1560
        && &v1559[v1554 - (v1563 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1551)
      {
        goto LABEL_1724;
      }
      v1564 = (v1563 >> 3) + 1;
      v1565 = 8 * (v1564 & 0x3FFFFFFFFFFFFFFCLL);
      v1560 = (_anonymous_namespace_::ReducePatternBase **)((char *)v1560 - v1565);
      v1566 = &v1551[v1565 / 0xFFFFFFFFFFFFFFF8];
      v1567 = v1551 - 2;
      v1568 = &v1559[8 * v1555 - 16];
      v1569 = v1564 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1571 = *((_OWORD *)v1567 - 1);
        v1570 = *(_OWORD *)v1567;
        *((_OWORD *)v1567 - 1) = 0uLL;
        *(_OWORD *)v1567 = 0uLL;
        *((_OWORD *)v1568 - 1) = v1571;
        *(_OWORD *)v1568 = v1570;
        v1567 -= 4;
        v1568 -= 32;
        v1569 -= 4;
      }
      while (v1569);
      v1551 = v1566;
      if (v1564 != (v1564 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1724:
        do
        {
          v1572 = *--v1551;
          *v1551 = 0;
          *--v1560 = v1572;
        }
        while (v1551 != (_anonymous_namespace_::ReducePatternBase **)v1553);
      }
      v1551 = (_anonymous_namespace_::ReducePatternBase **)*a1;
      v1573 = (_anonymous_namespace_::ReducePatternBase **)a1[1];
      *a1 = (uint64_t *)v1560;
      a1[1] = (uint64_t *)v1552;
      a1[2] = v1561;
      while (v1573 != v1551)
      {
        v1575 = (uint64_t)*--v1573;
        v1574 = v1575;
        *v1573 = 0;
        if (v1575)
          (*(void (**)(uint64_t))(*(_QWORD *)v1574 + 8))(v1574);
      }
      goto LABEL_1477;
    }
  }
  *a1 = (uint64_t *)v1560;
  a1[1] = (uint64_t *)v1552;
  a1[2] = v1561;
LABEL_1477:
  if (v1551)
    operator delete(v1551);
LABEL_1479:
  a1[1] = (uint64_t *)v1552;
  v1576 = operator new();
  v1577 = v1576;
  *(_BYTE *)(v1576 + 31) = 7;
  *(_QWORD *)v1576 = off_1E0E15C38;
  *(_QWORD *)(v1576 + 8) = 0x65706168736572;
  v1579 = a1[1];
  v1578 = (unint64_t)a1[2];
  if ((unint64_t)v1579 < v1578)
  {
    *v1579 = v1576;
    v1580 = (uint64_t)(v1579 + 1);
    goto LABEL_1505;
  }
  v1581 = *a1;
  v1582 = (char *)v1579 - (char *)*a1;
  v1583 = v1582 >> 3;
  v1584 = (v1582 >> 3) + 1;
  if (v1584 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1585 = v1578 - (_QWORD)v1581;
  if (v1585 >> 2 > v1584)
    v1584 = v1585 >> 2;
  if ((unint64_t)v1585 >= 0x7FFFFFFFFFFFFFF8)
    v1586 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1586 = v1584;
  if (v1586)
  {
    if (v1586 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1587 = (char *)operator new(8 * v1586);
    v1588 = (uint64_t *)&v1587[8 * v1583];
    v1589 = (uint64_t *)&v1587[8 * v1586];
    *v1588 = v1577;
    v1580 = (uint64_t)(v1588 + 1);
    v1590 = (char *)((char *)v1579 - (char *)v1581);
    if (v1579 != v1581)
      goto LABEL_1490;
  }
  else
  {
    v1587 = 0;
    v1588 = (uint64_t *)(8 * v1583);
    v1589 = 0;
    *(_QWORD *)(8 * v1583) = v1577;
    v1580 = 8 * v1583 + 8;
    v1590 = (char *)((char *)v1579 - (char *)v1581);
    if (v1579 != v1581)
    {
LABEL_1490:
      v1591 = (unint64_t)(v1590 - 8);
      if (v1591 < 0x78
        || (uint64_t *)((char *)v1579 - (v1591 & 0xFFFFFFFFFFFFFFF8) - 8) < v1588
        && &v1587[v1582 - (v1591 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1579)
      {
        goto LABEL_1725;
      }
      v1592 = (v1591 >> 3) + 1;
      v1593 = 8 * (v1592 & 0x3FFFFFFFFFFFFFFCLL);
      v1588 = (uint64_t *)((char *)v1588 - v1593);
      v1594 = &v1579[v1593 / 0xFFFFFFFFFFFFFFF8];
      v1595 = v1579 - 2;
      v1596 = &v1587[8 * v1583 - 16];
      v1597 = v1592 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1599 = *((_OWORD *)v1595 - 1);
        v1598 = *(_OWORD *)v1595;
        *((_OWORD *)v1595 - 1) = 0uLL;
        *(_OWORD *)v1595 = 0uLL;
        *((_OWORD *)v1596 - 1) = v1599;
        *(_OWORD *)v1596 = v1598;
        v1595 -= 4;
        v1596 -= 32;
        v1597 -= 4;
      }
      while (v1597);
      v1579 = v1594;
      if (v1592 != (v1592 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1725:
        do
        {
          v1600 = *--v1579;
          *v1579 = 0;
          *--v1588 = v1600;
        }
        while (v1579 != v1581);
      }
      v1579 = *a1;
      v1601 = a1[1];
      *a1 = v1588;
      a1[1] = (uint64_t *)v1580;
      a1[2] = v1589;
      while (v1601 != v1579)
      {
        v1603 = *--v1601;
        v1602 = v1603;
        *v1601 = 0;
        if (v1603)
          (*(void (**)(uint64_t))(*(_QWORD *)v1602 + 8))(v1602);
      }
      goto LABEL_1503;
    }
  }
  *a1 = v1588;
  a1[1] = (uint64_t *)v1580;
  a1[2] = v1589;
LABEL_1503:
  if (v1579)
    operator delete(v1579);
LABEL_1505:
  a1[1] = (uint64_t *)v1580;
  v1604 = operator new();
  v1605 = v1604;
  strcpy((char *)(v1604 + 8), "space_to_batch");
  *(_BYTE *)(v1604 + 23) = 0;
  *(_BYTE *)(v1604 + 31) = 14;
  *(_QWORD *)v1604 = off_1E0E18180;
  v1607 = a1[1];
  v1606 = (unint64_t)a1[2];
  if ((unint64_t)v1607 < v1606)
  {
    *v1607 = v1604;
    v1608 = (uint64_t)(v1607 + 1);
    goto LABEL_1531;
  }
  v1609 = *a1;
  v1610 = (char *)v1607 - (char *)*a1;
  v1611 = v1610 >> 3;
  v1612 = (v1610 >> 3) + 1;
  if (v1612 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1613 = v1606 - (_QWORD)v1609;
  if (v1613 >> 2 > v1612)
    v1612 = v1613 >> 2;
  if ((unint64_t)v1613 >= 0x7FFFFFFFFFFFFFF8)
    v1614 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1614 = v1612;
  if (v1614)
  {
    if (v1614 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1615 = (char *)operator new(8 * v1614);
    v1616 = (uint64_t *)&v1615[8 * v1611];
    v1617 = (uint64_t *)&v1615[8 * v1614];
    *v1616 = v1605;
    v1608 = (uint64_t)(v1616 + 1);
    v1618 = (char *)((char *)v1607 - (char *)v1609);
    if (v1607 != v1609)
      goto LABEL_1516;
  }
  else
  {
    v1615 = 0;
    v1616 = (uint64_t *)(8 * v1611);
    v1617 = 0;
    *(_QWORD *)(8 * v1611) = v1605;
    v1608 = 8 * v1611 + 8;
    v1618 = (char *)((char *)v1607 - (char *)v1609);
    if (v1607 != v1609)
    {
LABEL_1516:
      v1619 = (unint64_t)(v1618 - 8);
      if (v1619 < 0x78
        || (uint64_t *)((char *)v1607 - (v1619 & 0xFFFFFFFFFFFFFFF8) - 8) < v1616
        && &v1615[v1610 - (v1619 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1607)
      {
        goto LABEL_1726;
      }
      v1620 = (v1619 >> 3) + 1;
      v1621 = 8 * (v1620 & 0x3FFFFFFFFFFFFFFCLL);
      v1616 = (uint64_t *)((char *)v1616 - v1621);
      v1622 = &v1607[v1621 / 0xFFFFFFFFFFFFFFF8];
      v1623 = v1607 - 2;
      v1624 = &v1615[8 * v1611 - 16];
      v1625 = v1620 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1627 = *((_OWORD *)v1623 - 1);
        v1626 = *(_OWORD *)v1623;
        *((_OWORD *)v1623 - 1) = 0uLL;
        *(_OWORD *)v1623 = 0uLL;
        *((_OWORD *)v1624 - 1) = v1627;
        *(_OWORD *)v1624 = v1626;
        v1623 -= 4;
        v1624 -= 32;
        v1625 -= 4;
      }
      while (v1625);
      v1607 = v1622;
      if (v1620 != (v1620 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1726:
        do
        {
          v1628 = *--v1607;
          *v1607 = 0;
          *--v1616 = v1628;
        }
        while (v1607 != v1609);
      }
      v1607 = *a1;
      v1629 = a1[1];
      *a1 = v1616;
      a1[1] = (uint64_t *)v1608;
      a1[2] = v1617;
      while (v1629 != v1607)
      {
        v1631 = *--v1629;
        v1630 = v1631;
        *v1629 = 0;
        if (v1631)
          (*(void (**)(uint64_t))(*(_QWORD *)v1630 + 8))(v1630);
      }
      goto LABEL_1529;
    }
  }
  *a1 = v1616;
  a1[1] = (uint64_t *)v1608;
  a1[2] = v1617;
LABEL_1529:
  if (v1607)
    operator delete(v1607);
LABEL_1531:
  a1[1] = (uint64_t *)v1608;
  v1632 = operator new();
  v1633 = v1632;
  *(_BYTE *)(v1632 + 31) = 7;
  *(_QWORD *)v1632 = off_1E0E15C60;
  *(_QWORD *)(v1632 + 8) = 0x657A6565757173;
  v1635 = a1[1];
  v1634 = (unint64_t)a1[2];
  if ((unint64_t)v1635 < v1634)
  {
    *v1635 = v1632;
    v1636 = (uint64_t)(v1635 + 1);
    goto LABEL_1557;
  }
  v1637 = *a1;
  v1638 = (char *)v1635 - (char *)*a1;
  v1639 = v1638 >> 3;
  v1640 = (v1638 >> 3) + 1;
  if (v1640 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1641 = v1634 - (_QWORD)v1637;
  if (v1641 >> 2 > v1640)
    v1640 = v1641 >> 2;
  if ((unint64_t)v1641 >= 0x7FFFFFFFFFFFFFF8)
    v1642 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1642 = v1640;
  if (v1642)
  {
    if (v1642 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1643 = (char *)operator new(8 * v1642);
    v1644 = (uint64_t *)&v1643[8 * v1639];
    v1645 = (uint64_t *)&v1643[8 * v1642];
    *v1644 = v1633;
    v1636 = (uint64_t)(v1644 + 1);
    v1646 = (char *)((char *)v1635 - (char *)v1637);
    if (v1635 != v1637)
      goto LABEL_1542;
  }
  else
  {
    v1643 = 0;
    v1644 = (uint64_t *)(8 * v1639);
    v1645 = 0;
    *(_QWORD *)(8 * v1639) = v1633;
    v1636 = 8 * v1639 + 8;
    v1646 = (char *)((char *)v1635 - (char *)v1637);
    if (v1635 != v1637)
    {
LABEL_1542:
      v1647 = (unint64_t)(v1646 - 8);
      if (v1647 < 0x78
        || (uint64_t *)((char *)v1635 - (v1647 & 0xFFFFFFFFFFFFFFF8) - 8) < v1644
        && &v1643[v1638 - (v1647 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1635)
      {
        goto LABEL_1727;
      }
      v1648 = (v1647 >> 3) + 1;
      v1649 = 8 * (v1648 & 0x3FFFFFFFFFFFFFFCLL);
      v1644 = (uint64_t *)((char *)v1644 - v1649);
      v1650 = &v1635[v1649 / 0xFFFFFFFFFFFFFFF8];
      v1651 = v1635 - 2;
      v1652 = &v1643[8 * v1639 - 16];
      v1653 = v1648 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1655 = *((_OWORD *)v1651 - 1);
        v1654 = *(_OWORD *)v1651;
        *((_OWORD *)v1651 - 1) = 0uLL;
        *(_OWORD *)v1651 = 0uLL;
        *((_OWORD *)v1652 - 1) = v1655;
        *(_OWORD *)v1652 = v1654;
        v1651 -= 4;
        v1652 -= 32;
        v1653 -= 4;
      }
      while (v1653);
      v1635 = v1650;
      if (v1648 != (v1648 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1727:
        do
        {
          v1656 = *--v1635;
          *v1635 = 0;
          *--v1644 = v1656;
        }
        while (v1635 != v1637);
      }
      v1635 = *a1;
      v1657 = a1[1];
      *a1 = v1644;
      a1[1] = (uint64_t *)v1636;
      a1[2] = v1645;
      while (v1657 != v1635)
      {
        v1659 = *--v1657;
        v1658 = v1659;
        *v1657 = 0;
        if (v1659)
          (*(void (**)(uint64_t))(*(_QWORD *)v1658 + 8))(v1658);
      }
      goto LABEL_1555;
    }
  }
  *a1 = v1644;
  a1[1] = (uint64_t *)v1636;
  a1[2] = v1645;
LABEL_1555:
  if (v1635)
    operator delete(v1635);
LABEL_1557:
  a1[1] = (uint64_t *)v1636;
}

void sub_180E4F5E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100](_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = (_QWORD *)*a1;
  if (*a1)
  {
    v3 = (_QWORD *)a1[1];
    v4 = (_QWORD *)*a1;
    if (v3 != v2)
    {
      do
      {
        v6 = *--v3;
        v5 = v6;
        *v3 = 0;
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      }
      while (v3 != v2);
      v4 = (_QWORD *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

__CFDictionary *validateMILProgram(const __CFDictionary *a1)
{
  __CFDictionary *Mutable;
  CFNumberRef v3;
  const __CFData *Value;
  const __CFData *v5;
  const __CFString *v6;
  const __CFString *v7;
  char *CStringPtr;
  char *v9;
  size_t v10;
  void *v11;
  void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v22[168];
  mlir::Operation *v23;
  void *__dst[2];
  unint64_t v25;
  UInt8 buffer[8];
  uint64_t valuePtr;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  mlir::MLIRContextImpl *v31;
  CFRange v32;

  mlir::MLIRContext::MLIRContext(&v31, 0);
  v28 = 0;
  v29 = 0;
  v30 = 0;
  fillMILToMLIRRewritePatterns(&v28);
  loadCommonMPSDialectsInContext((mlir::MLIRContext *)&v31);
  valuePtr = 0;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("resultsVersion"), v3);
  CFRelease(v3);
  *(_QWORD *)buffer = 0;
  Value = (const __CFData *)CFDictionaryGetValue(a1, CFSTR("MIL"));
  v5 = Value;
  if (!Value)
    goto LABEL_23;
  v32.length = CFDataGetLength(Value);
  v32.location = 0;
  CFDataGetBytes(v5, v32, buffer);
  v6 = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("function"));
  v7 = v6;
  if (!v6)
    goto LABEL_23;
  CStringPtr = (char *)CFStringGetCStringPtr(v6, 0x8000100u);
  if (CStringPtr)
  {
    v9 = 0;
  }
  else
  {
    CStringPtr = (char *)malloc_type_malloc(0x400uLL, 0x8CA03EB9uLL);
    if (!CFStringGetCString(v7, CStringPtr, 1024, 0x8000100u))
      goto LABEL_23;
    v9 = CStringPtr;
    if (!CStringPtr)
      goto LABEL_23;
  }
  v10 = strlen(CStringPtr);
  if (v10 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v11 = (void *)v10;
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    v12 = (void **)operator new(v13 + 1);
    __dst[1] = v11;
    v25 = v14 | 0x8000000000000000;
    __dst[0] = v12;
  }
  else
  {
    HIBYTE(v25) = v10;
    v12 = __dst;
    if (!v10)
      goto LABEL_15;
  }
  memmove(v12, CStringPtr, (size_t)v11);
LABEL_15:
  *((_BYTE *)v11 + (_QWORD)v12) = 0;
  v15 = (*(uint64_t (**)(_QWORD, void **))(**(_QWORD **)buffer + 56))(*(_QWORD *)buffer, __dst);
  if (v9)
    free(v9);
  if (v15)
  {
    MILToMLIRRewriter::MILToMLIRRewriter((uint64_t)v22, *(mlir::MLIRContext **)buffer, (uint64_t)&v31, &v28, 1);
    MILToMLIRRewriter::validate((MILToMLIRRewriter *)v22, Mutable, &v23);
    if (v23)
      mlir::Operation::erase(v23);
    MILToMLIRRewriter::~MILToMLIRRewriter((MILToMLIRRewriter *)v22);
  }
  if (SHIBYTE(v25) < 0)
    operator delete(__dst[0]);
LABEL_23:
  v16 = v28;
  if (v28)
  {
    v17 = v29;
    v18 = v28;
    if (v29 != v28)
    {
      do
      {
        v20 = *--v17;
        v19 = v20;
        *v17 = 0;
        if (v20)
          (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
      }
      while (v17 != v16);
      v18 = v28;
    }
    v29 = v16;
    operator delete(v18);
  }
  mlir::MLIRContext::~MLIRContext(&v31);
  return Mutable;
}

void sub_180E4FB60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  MILToMLIRRewriter::~MILToMLIRRewriter((MILToMLIRRewriter *)va);
  if (*(char *)(v2 - 113) < 0)
  {
    operator delete(*(void **)(v2 - 136));
    std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((_QWORD *)(v2 - 96));
    mlir::MLIRContext::~MLIRContext((mlir::MLIRContextImpl **)(v2 - 72));
    _Unwind_Resume(a1);
  }
  std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::~vector[abi:ne180100]((_QWORD *)(v2 - 96));
  mlir::MLIRContext::~MLIRContext((mlir::MLIRContextImpl **)(v2 - 72));
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MILToMLIR::PoolingPattern,char const(&)[9]>(_QWORD *a1, const char *a2)
{
  _QWORD *v4;
  size_t v5;
  size_t v6;
  __int128 *p_dst;
  uint64_t v8;
  uint64_t v9;
  std::string *v10;
  void *v11;
  __int128 __dst;
  unint64_t v13;

  v4 = (_QWORD *)operator new();
  v5 = strlen(a2);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = v5;
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    p_dst = (__int128 *)operator new(v8 + 1);
    *((_QWORD *)&__dst + 1) = v6;
    v13 = v9 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v13) = v5;
  p_dst = &__dst;
  if (v5)
LABEL_8:
    memcpy(p_dst, a2, v6);
  *((_BYTE *)p_dst + v6) = 0;
  *v4 = &unk_1E0E138C8;
  v10 = (std::string *)(v4 + 1);
  if (SHIBYTE(v13) < 0)
  {
    v11 = (void *)__dst;
    std::string::__init_copy_ctor_external(v10, (const std::string::value_type *)__dst, *((std::string::size_type *)&__dst + 1));
    *v4 = &unk_1E0E4F360;
    *a1 = v4;
    operator delete(v11);
  }
  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = __dst;
    v4[3] = v13;
    *v4 = &unk_1E0E4F360;
    *a1 = v4;
  }
}

void sub_180E4FD28(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  operator delete(v2);
  MEMORY[0x186DA1680](v1, 0x1093C402D7449D9);
  _Unwind_Resume(a1);
}

void std::make_unique[abi:ne180100]<MILToMLIR::TensorBufferPattern,char const(&)[24]>(_QWORD *a1, const char *a2)
{
  _QWORD *v4;
  size_t v5;
  size_t v6;
  __int128 *p_dst;
  uint64_t v8;
  uint64_t v9;
  std::string *v10;
  void *v11;
  __int128 __dst;
  unint64_t v13;

  v4 = (_QWORD *)operator new();
  v5 = strlen(a2);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = v5;
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    p_dst = (__int128 *)operator new(v8 + 1);
    *((_QWORD *)&__dst + 1) = v6;
    v13 = v9 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v13) = v5;
  p_dst = &__dst;
  if (v5)
LABEL_8:
    memcpy(p_dst, a2, v6);
  *((_BYTE *)p_dst + v6) = 0;
  *v4 = &unk_1E0E138C8;
  v10 = (std::string *)(v4 + 1);
  if (SHIBYTE(v13) < 0)
  {
    v11 = (void *)__dst;
    std::string::__init_copy_ctor_external(v10, (const std::string::value_type *)__dst, *((std::string::size_type *)&__dst + 1));
    *v4 = &unk_1E0E4F590;
    *a1 = v4;
    operator delete(v11);
  }
  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = __dst;
    v4[3] = v13;
    *v4 = &unk_1E0E4F590;
    *a1 = v4;
  }
}

void sub_180E4FEAC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  operator delete(v2);
  MEMORY[0x186DA1680](v1, 0x1093C402D7449D9);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::populateWithGenerated(uint64_t **a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  uint64_t *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  char *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t *v42;
  uint64_t *v43;
  char *v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t *v49;
  char *v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  uint64_t *v70;
  uint64_t *v71;
  char *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t *v77;
  char *v78;
  uint64_t v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  char *v97;
  uint64_t *v98;
  uint64_t *v99;
  char *v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t *v105;
  char *v106;
  uint64_t v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t *v117;
  uint64_t v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  char *v125;
  uint64_t *v126;
  uint64_t *v127;
  char *v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t *v133;
  char *v134;
  uint64_t v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;
  uint64_t *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t *v145;
  uint64_t v146;
  uint64_t *v147;
  uint64_t v148;
  uint64_t v149;
  unint64_t v150;
  uint64_t v151;
  unint64_t v152;
  char *v153;
  uint64_t *v154;
  uint64_t *v155;
  char *v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t *v160;
  uint64_t *v161;
  char *v162;
  uint64_t v163;
  __int128 v164;
  __int128 v165;
  uint64_t v166;
  uint64_t *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  uint64_t *v173;
  uint64_t v174;
  uint64_t *v175;
  uint64_t v176;
  uint64_t v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  char *v181;
  uint64_t *v182;
  uint64_t *v183;
  char *v184;
  unint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t *v188;
  uint64_t *v189;
  char *v190;
  uint64_t v191;
  __int128 v192;
  __int128 v193;
  uint64_t v194;
  uint64_t *v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  unint64_t v200;
  uint64_t *v201;
  uint64_t v202;
  uint64_t *v203;
  uint64_t v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  unint64_t v208;
  char *v209;
  uint64_t *v210;
  uint64_t *v211;
  char *v212;
  unint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t *v216;
  uint64_t *v217;
  char *v218;
  uint64_t v219;
  __int128 v220;
  __int128 v221;
  uint64_t v222;
  uint64_t *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  unint64_t v228;
  uint64_t *v229;
  uint64_t v230;
  uint64_t *v231;
  uint64_t v232;
  uint64_t v233;
  unint64_t v234;
  uint64_t v235;
  unint64_t v236;
  char *v237;
  uint64_t *v238;
  uint64_t *v239;
  char *v240;
  unint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t *v244;
  uint64_t *v245;
  char *v246;
  uint64_t v247;
  __int128 v248;
  __int128 v249;
  uint64_t v250;
  uint64_t *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  unint64_t v256;
  uint64_t *v257;
  uint64_t v258;
  uint64_t *v259;
  uint64_t v260;
  uint64_t v261;
  unint64_t v262;
  uint64_t v263;
  unint64_t v264;
  char *v265;
  uint64_t *v266;
  uint64_t *v267;
  char *v268;
  unint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t *v272;
  uint64_t *v273;
  char *v274;
  uint64_t v275;
  __int128 v276;
  __int128 v277;
  uint64_t v278;
  uint64_t *v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  unint64_t v284;
  uint64_t *v285;
  uint64_t v286;
  uint64_t *v287;
  uint64_t v288;
  uint64_t v289;
  unint64_t v290;
  uint64_t v291;
  unint64_t v292;
  char *v293;
  uint64_t *v294;
  uint64_t *v295;
  char *v296;
  unint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t *v300;
  uint64_t *v301;
  char *v302;
  uint64_t v303;
  __int128 v304;
  __int128 v305;
  uint64_t v306;
  uint64_t *v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  unint64_t v312;
  uint64_t *v313;
  uint64_t v314;
  uint64_t *v315;
  uint64_t v316;
  uint64_t v317;
  unint64_t v318;
  uint64_t v319;
  unint64_t v320;
  char *v321;
  uint64_t *v322;
  uint64_t *v323;
  char *v324;
  unint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t *v328;
  uint64_t *v329;
  char *v330;
  uint64_t v331;
  __int128 v332;
  __int128 v333;
  uint64_t v334;
  uint64_t *v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  unint64_t v340;
  uint64_t *v341;
  uint64_t v342;
  uint64_t *v343;
  uint64_t v344;
  uint64_t v345;
  unint64_t v346;
  uint64_t v347;
  unint64_t v348;
  char *v349;
  uint64_t *v350;
  uint64_t *v351;
  char *v352;
  unint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t *v356;
  uint64_t *v357;
  char *v358;
  uint64_t v359;
  __int128 v360;
  __int128 v361;
  uint64_t v362;
  uint64_t *v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  unint64_t v368;
  uint64_t *v369;
  uint64_t v370;
  uint64_t *v371;
  uint64_t v372;
  uint64_t v373;
  unint64_t v374;
  uint64_t v375;
  unint64_t v376;
  char *v377;
  uint64_t *v378;
  uint64_t *v379;
  char *v380;
  unint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t *v384;
  uint64_t *v385;
  char *v386;
  uint64_t v387;
  __int128 v388;
  __int128 v389;
  uint64_t v390;
  uint64_t *v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  unint64_t v396;
  uint64_t *v397;
  uint64_t v398;
  uint64_t *v399;
  uint64_t v400;
  uint64_t v401;
  unint64_t v402;
  uint64_t v403;
  unint64_t v404;
  char *v405;
  uint64_t *v406;
  uint64_t *v407;
  char *v408;
  unint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t *v412;
  uint64_t *v413;
  char *v414;
  uint64_t v415;
  __int128 v416;
  __int128 v417;
  uint64_t v418;
  uint64_t *v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  unint64_t v424;
  uint64_t *v425;
  uint64_t v426;
  uint64_t *v427;
  uint64_t v428;
  uint64_t v429;
  unint64_t v430;
  uint64_t v431;
  unint64_t v432;
  char *v433;
  uint64_t *v434;
  uint64_t *v435;
  char *v436;
  unint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t *v440;
  uint64_t *v441;
  char *v442;
  uint64_t v443;
  __int128 v444;
  __int128 v445;
  uint64_t v446;
  uint64_t *v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  unint64_t v452;
  uint64_t *v453;
  uint64_t v454;
  uint64_t *v455;
  uint64_t v456;
  uint64_t v457;
  unint64_t v458;
  uint64_t v459;
  unint64_t v460;
  char *v461;
  uint64_t *v462;
  uint64_t *v463;
  char *v464;
  unint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t *v468;
  uint64_t *v469;
  char *v470;
  uint64_t v471;
  __int128 v472;
  __int128 v473;
  uint64_t v474;
  uint64_t *v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  unint64_t v480;
  uint64_t *v481;
  uint64_t v482;
  uint64_t *v483;
  uint64_t v484;
  uint64_t v485;
  unint64_t v486;
  uint64_t v487;
  unint64_t v488;
  char *v489;
  uint64_t *v490;
  uint64_t *v491;
  char *v492;
  unint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t *v496;
  uint64_t *v497;
  char *v498;
  uint64_t v499;
  __int128 v500;
  __int128 v501;
  uint64_t v502;
  uint64_t *v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  unint64_t v508;
  uint64_t *v509;
  uint64_t v510;
  uint64_t *v511;
  uint64_t v512;
  uint64_t v513;
  unint64_t v514;
  uint64_t v515;
  unint64_t v516;
  char *v517;
  uint64_t *v518;
  uint64_t *v519;
  char *v520;
  unint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t *v524;
  uint64_t *v525;
  char *v526;
  uint64_t v527;
  __int128 v528;
  __int128 v529;
  uint64_t v530;
  uint64_t *v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  unint64_t v536;
  uint64_t *v537;
  uint64_t v538;
  uint64_t *v539;
  uint64_t v540;
  uint64_t v541;
  unint64_t v542;
  uint64_t v543;
  unint64_t v544;
  char *v545;
  uint64_t *v546;
  uint64_t *v547;
  char *v548;
  unint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t *v552;
  uint64_t *v553;
  char *v554;
  uint64_t v555;
  __int128 v556;
  __int128 v557;
  uint64_t v558;
  uint64_t *v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  uint64_t v563;
  unint64_t v564;
  uint64_t *v565;
  uint64_t v566;
  uint64_t *v567;
  uint64_t v568;
  uint64_t v569;
  unint64_t v570;
  uint64_t v571;
  unint64_t v572;
  char *v573;
  uint64_t *v574;
  uint64_t *v575;
  char *v576;
  unint64_t v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t *v580;
  uint64_t *v581;
  char *v582;
  uint64_t v583;
  __int128 v584;
  __int128 v585;
  uint64_t v586;
  uint64_t *v587;
  uint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  unint64_t v592;
  uint64_t *v593;
  uint64_t v594;
  uint64_t *v595;
  uint64_t v596;
  uint64_t v597;
  unint64_t v598;
  uint64_t v599;
  unint64_t v600;
  char *v601;
  uint64_t *v602;
  uint64_t *v603;
  char *v604;
  unint64_t v605;
  uint64_t v606;
  uint64_t v607;
  uint64_t *v608;
  uint64_t *v609;
  char *v610;
  uint64_t v611;
  __int128 v612;
  __int128 v613;
  uint64_t v614;
  uint64_t *v615;
  uint64_t v616;
  uint64_t v617;
  uint64_t v618;
  uint64_t v619;
  unint64_t v620;
  uint64_t *v621;
  uint64_t v622;
  uint64_t *v623;
  uint64_t v624;
  uint64_t v625;
  unint64_t v626;
  uint64_t v627;
  unint64_t v628;
  char *v629;
  uint64_t *v630;
  uint64_t *v631;
  char *v632;
  unint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t *v636;
  uint64_t *v637;
  char *v638;
  uint64_t v639;
  __int128 v640;
  __int128 v641;
  uint64_t v642;
  uint64_t *v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  unint64_t v648;
  uint64_t *v649;
  uint64_t v650;
  uint64_t *v651;
  uint64_t v652;
  uint64_t v653;
  unint64_t v654;
  uint64_t v655;
  unint64_t v656;
  char *v657;
  uint64_t *v658;
  uint64_t *v659;
  char *v660;
  unint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t *v664;
  uint64_t *v665;
  char *v666;
  uint64_t v667;
  __int128 v668;
  __int128 v669;
  uint64_t v670;
  uint64_t *v671;
  uint64_t v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  unint64_t v676;
  uint64_t *v677;
  uint64_t v678;
  uint64_t *v679;
  uint64_t v680;
  uint64_t v681;
  unint64_t v682;
  uint64_t v683;
  unint64_t v684;
  char *v685;
  uint64_t *v686;
  uint64_t *v687;
  char *v688;
  unint64_t v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t *v692;
  uint64_t *v693;
  char *v694;
  uint64_t v695;
  __int128 v696;
  __int128 v697;
  uint64_t v698;
  uint64_t *v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  unint64_t v704;
  uint64_t *v705;
  uint64_t v706;
  uint64_t *v707;
  uint64_t v708;
  uint64_t v709;
  unint64_t v710;
  uint64_t v711;
  unint64_t v712;
  char *v713;
  uint64_t *v714;
  uint64_t *v715;
  char *v716;
  unint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t *v720;
  uint64_t *v721;
  char *v722;
  uint64_t v723;
  __int128 v724;
  __int128 v725;
  uint64_t v726;
  uint64_t *v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  unint64_t v732;
  uint64_t *v733;
  uint64_t v734;
  uint64_t *v735;
  uint64_t v736;
  uint64_t v737;
  unint64_t v738;
  uint64_t v739;
  unint64_t v740;
  char *v741;
  uint64_t *v742;
  uint64_t *v743;
  char *v744;
  unint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t *v748;
  uint64_t *v749;
  char *v750;
  uint64_t v751;
  __int128 v752;
  __int128 v753;
  uint64_t v754;
  uint64_t *v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t v758;
  uint64_t v759;
  unint64_t v760;
  uint64_t *v761;
  uint64_t v762;
  uint64_t *v763;
  uint64_t v764;
  uint64_t v765;
  unint64_t v766;
  uint64_t v767;
  unint64_t v768;
  char *v769;
  uint64_t *v770;
  uint64_t *v771;
  char *v772;
  unint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t *v776;
  uint64_t *v777;
  char *v778;
  uint64_t v779;
  __int128 v780;
  __int128 v781;
  uint64_t v782;
  uint64_t *v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  unint64_t v788;
  uint64_t *v789;
  uint64_t v790;
  uint64_t *v791;
  uint64_t v792;
  uint64_t v793;
  unint64_t v794;
  uint64_t v795;
  unint64_t v796;
  char *v797;
  uint64_t *v798;
  uint64_t *v799;
  char *v800;
  unint64_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t *v804;
  uint64_t *v805;
  char *v806;
  uint64_t v807;
  __int128 v808;
  __int128 v809;
  uint64_t v810;
  uint64_t *v811;
  uint64_t v812;
  uint64_t v813;
  uint64_t v814;
  uint64_t v815;
  unint64_t v816;
  uint64_t *v817;
  uint64_t v818;
  uint64_t *v819;
  uint64_t v820;
  uint64_t v821;
  unint64_t v822;
  uint64_t v823;
  unint64_t v824;
  char *v825;
  uint64_t *v826;
  uint64_t *v827;
  char *v828;
  unint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t *v832;
  uint64_t *v833;
  char *v834;
  uint64_t v835;
  __int128 v836;
  __int128 v837;
  uint64_t v838;
  uint64_t *v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  unint64_t v844;
  uint64_t *v845;
  uint64_t v846;
  uint64_t *v847;
  uint64_t v848;
  uint64_t v849;
  unint64_t v850;
  uint64_t v851;
  unint64_t v852;
  char *v853;
  uint64_t *v854;
  uint64_t *v855;
  char *v856;
  unint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t *v860;
  uint64_t *v861;
  char *v862;
  uint64_t v863;
  __int128 v864;
  __int128 v865;
  uint64_t v866;
  uint64_t *v867;
  uint64_t v868;
  uint64_t v869;
  uint64_t v870;
  uint64_t v871;
  unint64_t v872;
  uint64_t *v873;
  uint64_t v874;
  uint64_t *v875;
  uint64_t v876;
  uint64_t v877;
  unint64_t v878;
  uint64_t v879;
  unint64_t v880;
  char *v881;
  uint64_t *v882;
  uint64_t *v883;
  char *v884;
  unint64_t v885;
  uint64_t v886;
  uint64_t v887;
  uint64_t *v888;
  uint64_t *v889;
  char *v890;
  uint64_t v891;
  __int128 v892;
  __int128 v893;
  uint64_t v894;
  uint64_t *v895;
  uint64_t v896;
  uint64_t v897;
  uint64_t v898;
  uint64_t v899;
  unint64_t v900;
  uint64_t *v901;
  uint64_t v902;
  uint64_t *v903;
  uint64_t v904;
  uint64_t v905;
  unint64_t v906;
  uint64_t v907;
  unint64_t v908;
  char *v909;
  uint64_t *v910;
  uint64_t *v911;
  char *v912;
  unint64_t v913;
  uint64_t v914;
  uint64_t v915;
  uint64_t *v916;
  uint64_t *v917;
  char *v918;
  uint64_t v919;
  __int128 v920;
  __int128 v921;
  uint64_t v922;
  uint64_t *v923;
  uint64_t v924;
  uint64_t v925;
  uint64_t v926;
  uint64_t v927;
  unint64_t v928;
  uint64_t *v929;
  uint64_t v930;
  uint64_t *v931;
  uint64_t v932;
  uint64_t v933;
  unint64_t v934;
  uint64_t v935;
  unint64_t v936;
  char *v937;
  uint64_t *v938;
  uint64_t *v939;
  char *v940;
  unint64_t v941;
  uint64_t v942;
  uint64_t v943;
  uint64_t *v944;
  uint64_t *v945;
  char *v946;
  uint64_t v947;
  __int128 v948;
  __int128 v949;
  uint64_t v950;
  uint64_t *v951;
  uint64_t v952;
  uint64_t v953;
  uint64_t v954;
  uint64_t v955;
  unint64_t v956;
  uint64_t *v957;
  uint64_t v958;
  uint64_t *v959;
  uint64_t v960;
  uint64_t v961;
  unint64_t v962;
  uint64_t v963;
  unint64_t v964;
  char *v965;
  uint64_t *v966;
  uint64_t *v967;
  char *v968;
  unint64_t v969;
  uint64_t v970;
  uint64_t v971;
  uint64_t *v972;
  uint64_t *v973;
  char *v974;
  uint64_t v975;
  __int128 v976;
  __int128 v977;
  uint64_t v978;
  uint64_t *v979;
  uint64_t v980;
  uint64_t v981;
  uint64_t v982;
  uint64_t v983;
  unint64_t v984;
  uint64_t *v985;
  uint64_t v986;
  uint64_t *v987;
  uint64_t v988;
  uint64_t v989;
  unint64_t v990;
  uint64_t v991;
  unint64_t v992;
  char *v993;
  uint64_t *v994;
  uint64_t *v995;
  char *v996;
  unint64_t v997;
  uint64_t v998;
  uint64_t v999;
  uint64_t *v1000;
  uint64_t *v1001;
  char *v1002;
  uint64_t v1003;
  __int128 v1004;
  __int128 v1005;
  uint64_t v1006;
  uint64_t *v1007;
  uint64_t v1008;
  uint64_t v1009;
  uint64_t v1010;
  uint64_t v1011;
  unint64_t v1012;
  uint64_t *v1013;
  uint64_t v1014;
  uint64_t *v1015;
  uint64_t v1016;
  uint64_t v1017;
  unint64_t v1018;
  uint64_t v1019;
  unint64_t v1020;
  char *v1021;
  uint64_t *v1022;
  uint64_t *v1023;
  char *v1024;
  unint64_t v1025;
  uint64_t v1026;
  uint64_t v1027;
  uint64_t *v1028;
  uint64_t *v1029;
  char *v1030;
  uint64_t v1031;
  __int128 v1032;
  __int128 v1033;
  uint64_t v1034;
  uint64_t *v1035;
  uint64_t v1036;
  uint64_t v1037;
  uint64_t v1038;
  uint64_t v1039;
  unint64_t v1040;
  uint64_t *v1041;
  uint64_t v1042;
  uint64_t *v1043;
  uint64_t v1044;
  uint64_t v1045;
  unint64_t v1046;
  uint64_t v1047;
  unint64_t v1048;
  char *v1049;
  uint64_t *v1050;
  uint64_t *v1051;
  char *v1052;
  unint64_t v1053;
  uint64_t v1054;
  uint64_t v1055;
  uint64_t *v1056;
  uint64_t *v1057;
  char *v1058;
  uint64_t v1059;
  __int128 v1060;
  __int128 v1061;
  uint64_t v1062;
  uint64_t *v1063;
  uint64_t v1064;
  uint64_t v1065;
  uint64_t v1066;
  uint64_t v1067;
  unint64_t v1068;
  uint64_t *v1069;
  uint64_t v1070;
  uint64_t *v1071;
  uint64_t v1072;
  uint64_t v1073;
  unint64_t v1074;
  uint64_t v1075;
  unint64_t v1076;
  char *v1077;
  uint64_t *v1078;
  uint64_t *v1079;
  char *v1080;
  unint64_t v1081;
  uint64_t v1082;
  uint64_t v1083;
  uint64_t *v1084;
  uint64_t *v1085;
  char *v1086;
  uint64_t v1087;
  __int128 v1088;
  __int128 v1089;
  uint64_t v1090;
  uint64_t *v1091;
  uint64_t v1092;
  uint64_t v1093;
  uint64_t v1094;
  uint64_t v1095;
  unint64_t v1096;
  uint64_t *v1097;
  uint64_t v1098;
  uint64_t *v1099;
  uint64_t v1100;
  uint64_t v1101;
  unint64_t v1102;
  uint64_t v1103;
  unint64_t v1104;
  char *v1105;
  uint64_t *v1106;
  uint64_t *v1107;
  char *v1108;
  unint64_t v1109;
  uint64_t v1110;
  uint64_t v1111;
  uint64_t *v1112;
  uint64_t *v1113;
  char *v1114;
  uint64_t v1115;
  __int128 v1116;
  __int128 v1117;
  uint64_t v1118;
  uint64_t *v1119;
  uint64_t v1120;
  uint64_t v1121;
  uint64_t v1122;
  uint64_t v1123;
  unint64_t v1124;
  uint64_t *v1125;
  uint64_t v1126;
  uint64_t *v1127;
  uint64_t v1128;
  uint64_t v1129;
  unint64_t v1130;
  uint64_t v1131;
  unint64_t v1132;
  char *v1133;
  uint64_t *v1134;
  uint64_t *v1135;
  char *v1136;
  unint64_t v1137;
  uint64_t v1138;
  uint64_t v1139;
  uint64_t *v1140;
  uint64_t *v1141;
  char *v1142;
  uint64_t v1143;
  __int128 v1144;
  __int128 v1145;
  uint64_t v1146;
  uint64_t *v1147;
  uint64_t v1148;
  uint64_t v1149;
  uint64_t v1150;
  uint64_t v1151;
  unint64_t v1152;
  uint64_t *v1153;
  uint64_t v1154;
  uint64_t *v1155;
  uint64_t v1156;
  uint64_t v1157;
  unint64_t v1158;
  uint64_t v1159;
  unint64_t v1160;
  char *v1161;
  uint64_t *v1162;
  uint64_t *v1163;
  char *v1164;
  unint64_t v1165;
  uint64_t v1166;
  uint64_t v1167;
  uint64_t *v1168;
  uint64_t *v1169;
  char *v1170;
  uint64_t v1171;
  __int128 v1172;
  __int128 v1173;
  uint64_t v1174;
  uint64_t *v1175;
  uint64_t v1176;
  uint64_t v1177;
  uint64_t v1178;
  uint64_t v1179;
  unint64_t v1180;
  uint64_t *v1181;
  uint64_t v1182;
  uint64_t *v1183;
  uint64_t v1184;
  uint64_t v1185;
  unint64_t v1186;
  uint64_t v1187;
  unint64_t v1188;
  char *v1189;
  uint64_t *v1190;
  uint64_t *v1191;
  char *v1192;
  unint64_t v1193;
  uint64_t v1194;
  uint64_t v1195;
  uint64_t *v1196;
  uint64_t *v1197;
  char *v1198;
  uint64_t v1199;
  __int128 v1200;
  __int128 v1201;
  uint64_t v1202;
  uint64_t *v1203;
  uint64_t v1204;
  uint64_t v1205;
  uint64_t v1206;
  uint64_t v1207;
  unint64_t v1208;
  uint64_t *v1209;
  uint64_t v1210;
  uint64_t *v1211;
  uint64_t v1212;
  uint64_t v1213;
  unint64_t v1214;
  uint64_t v1215;
  unint64_t v1216;
  char *v1217;
  uint64_t *v1218;
  uint64_t *v1219;
  char *v1220;
  unint64_t v1221;
  uint64_t v1222;
  uint64_t v1223;
  uint64_t *v1224;
  uint64_t *v1225;
  char *v1226;
  uint64_t v1227;
  __int128 v1228;
  __int128 v1229;
  uint64_t v1230;
  uint64_t *v1231;
  uint64_t v1232;
  uint64_t v1233;
  uint64_t v1234;
  uint64_t v1235;
  unint64_t v1236;
  uint64_t *v1237;
  uint64_t v1238;
  uint64_t *v1239;
  uint64_t v1240;
  uint64_t v1241;
  unint64_t v1242;
  uint64_t v1243;
  unint64_t v1244;
  char *v1245;
  uint64_t *v1246;
  uint64_t *v1247;
  char *v1248;
  unint64_t v1249;
  uint64_t v1250;
  uint64_t v1251;
  uint64_t *v1252;
  uint64_t *v1253;
  char *v1254;
  uint64_t v1255;
  __int128 v1256;
  __int128 v1257;
  uint64_t v1258;
  uint64_t *v1259;
  uint64_t v1260;
  uint64_t v1261;
  uint64_t v1262;
  uint64_t v1263;
  unint64_t v1264;
  uint64_t *v1265;
  uint64_t v1266;
  uint64_t *v1267;
  uint64_t v1268;
  uint64_t v1269;
  unint64_t v1270;
  uint64_t v1271;
  unint64_t v1272;
  char *v1273;
  uint64_t *v1274;
  uint64_t *v1275;
  char *v1276;
  unint64_t v1277;
  uint64_t v1278;
  uint64_t v1279;
  uint64_t *v1280;
  uint64_t *v1281;
  char *v1282;
  uint64_t v1283;
  __int128 v1284;
  __int128 v1285;
  uint64_t v1286;
  uint64_t *v1287;
  uint64_t v1288;
  uint64_t v1289;
  uint64_t v1290;
  uint64_t v1291;
  unint64_t v1292;
  uint64_t *v1293;
  uint64_t v1294;
  uint64_t *v1295;
  uint64_t v1296;
  uint64_t v1297;
  unint64_t v1298;
  uint64_t v1299;
  unint64_t v1300;
  char *v1301;
  uint64_t *v1302;
  uint64_t *v1303;
  char *v1304;
  unint64_t v1305;
  uint64_t v1306;
  uint64_t v1307;
  uint64_t *v1308;
  uint64_t *v1309;
  char *v1310;
  uint64_t v1311;
  __int128 v1312;
  __int128 v1313;
  uint64_t v1314;
  uint64_t *v1315;
  uint64_t v1316;
  uint64_t v1317;
  uint64_t v1318;
  uint64_t v1319;
  unint64_t v1320;
  uint64_t *v1321;
  uint64_t v1322;
  uint64_t *v1323;
  uint64_t v1324;
  uint64_t v1325;
  unint64_t v1326;
  uint64_t v1327;
  unint64_t v1328;
  char *v1329;
  uint64_t *v1330;
  uint64_t *v1331;
  char *v1332;
  unint64_t v1333;
  uint64_t v1334;
  uint64_t v1335;
  uint64_t *v1336;
  uint64_t *v1337;
  char *v1338;
  uint64_t v1339;
  __int128 v1340;
  __int128 v1341;
  uint64_t v1342;
  uint64_t *v1343;
  uint64_t v1344;
  uint64_t v1345;
  uint64_t v1346;
  uint64_t v1347;
  unint64_t v1348;
  uint64_t *v1349;
  uint64_t v1350;
  uint64_t *v1351;
  uint64_t v1352;
  uint64_t v1353;
  unint64_t v1354;
  uint64_t v1355;
  unint64_t v1356;
  char *v1357;
  uint64_t *v1358;
  uint64_t *v1359;
  char *v1360;
  unint64_t v1361;
  uint64_t v1362;
  uint64_t v1363;
  uint64_t *v1364;
  uint64_t *v1365;
  char *v1366;
  uint64_t v1367;
  __int128 v1368;
  __int128 v1369;
  uint64_t v1370;
  uint64_t *v1371;
  uint64_t v1372;
  uint64_t v1373;
  uint64_t v1374;
  uint64_t v1375;
  unint64_t v1376;
  uint64_t *v1377;
  uint64_t v1378;
  uint64_t *v1379;
  uint64_t v1380;
  uint64_t v1381;
  unint64_t v1382;
  uint64_t v1383;
  unint64_t v1384;
  char *v1385;
  uint64_t *v1386;
  uint64_t *v1387;
  char *v1388;
  unint64_t v1389;
  uint64_t v1390;
  uint64_t v1391;
  uint64_t *v1392;
  uint64_t *v1393;
  char *v1394;
  uint64_t v1395;
  __int128 v1396;
  __int128 v1397;
  uint64_t v1398;
  uint64_t *v1399;
  uint64_t v1400;
  uint64_t v1401;
  uint64_t v1402;
  uint64_t v1403;
  unint64_t v1404;
  uint64_t *v1405;
  uint64_t v1406;
  uint64_t *v1407;
  uint64_t v1408;
  uint64_t v1409;
  unint64_t v1410;
  uint64_t v1411;
  unint64_t v1412;
  char *v1413;
  uint64_t *v1414;
  uint64_t *v1415;
  char *v1416;
  unint64_t v1417;
  uint64_t v1418;
  uint64_t v1419;
  uint64_t *v1420;
  uint64_t *v1421;
  char *v1422;
  uint64_t v1423;
  __int128 v1424;
  __int128 v1425;
  uint64_t v1426;
  uint64_t *v1427;
  uint64_t v1428;
  uint64_t v1429;
  uint64_t v1430;
  uint64_t v1431;
  unint64_t v1432;
  uint64_t *v1433;
  uint64_t v1434;
  uint64_t *v1435;
  uint64_t v1436;
  uint64_t v1437;
  unint64_t v1438;
  uint64_t v1439;
  unint64_t v1440;
  char *v1441;
  uint64_t *v1442;
  uint64_t *v1443;
  char *v1444;
  unint64_t v1445;
  uint64_t v1446;
  uint64_t v1447;
  uint64_t *v1448;
  uint64_t *v1449;
  char *v1450;
  uint64_t v1451;
  __int128 v1452;
  __int128 v1453;
  uint64_t v1454;
  uint64_t *v1455;
  uint64_t v1456;
  uint64_t v1457;
  uint64_t v1458;
  uint64_t v1459;
  unint64_t v1460;
  uint64_t *v1461;
  uint64_t v1462;
  uint64_t *v1463;
  uint64_t v1464;
  uint64_t v1465;
  unint64_t v1466;
  uint64_t v1467;
  unint64_t v1468;
  char *v1469;
  uint64_t *v1470;
  uint64_t *v1471;
  char *v1472;
  unint64_t v1473;
  uint64_t v1474;
  uint64_t v1475;
  uint64_t *v1476;
  uint64_t *v1477;
  char *v1478;
  uint64_t v1479;
  __int128 v1480;
  __int128 v1481;
  uint64_t v1482;
  uint64_t *v1483;
  uint64_t v1484;
  uint64_t v1485;
  uint64_t v1486;
  uint64_t v1487;
  unint64_t v1488;
  uint64_t *v1489;
  uint64_t v1490;
  uint64_t *v1491;
  uint64_t v1492;
  uint64_t v1493;
  unint64_t v1494;
  uint64_t v1495;
  unint64_t v1496;
  char *v1497;
  uint64_t *v1498;
  uint64_t *v1499;
  char *v1500;
  unint64_t v1501;
  uint64_t v1502;
  uint64_t v1503;
  uint64_t *v1504;
  uint64_t *v1505;
  char *v1506;
  uint64_t v1507;
  __int128 v1508;
  __int128 v1509;
  uint64_t v1510;
  uint64_t *v1511;
  uint64_t v1512;
  uint64_t v1513;
  uint64_t v1514;
  uint64_t v1515;
  unint64_t v1516;
  uint64_t *v1517;
  uint64_t v1518;
  uint64_t *v1519;
  uint64_t v1520;
  uint64_t v1521;
  unint64_t v1522;
  uint64_t v1523;
  unint64_t v1524;
  char *v1525;
  uint64_t *v1526;
  uint64_t *v1527;
  char *v1528;
  unint64_t v1529;
  uint64_t v1530;
  uint64_t v1531;
  uint64_t *v1532;
  uint64_t *v1533;
  char *v1534;
  uint64_t v1535;
  __int128 v1536;
  __int128 v1537;
  uint64_t v1538;
  uint64_t *v1539;
  uint64_t v1540;
  uint64_t v1541;
  uint64_t v1542;
  uint64_t v1543;
  unint64_t v1544;
  uint64_t *v1545;
  uint64_t v1546;
  uint64_t *v1547;
  uint64_t v1548;
  uint64_t v1549;
  unint64_t v1550;
  uint64_t v1551;
  unint64_t v1552;
  char *v1553;
  uint64_t *v1554;
  uint64_t *v1555;
  char *v1556;
  unint64_t v1557;
  uint64_t v1558;
  uint64_t v1559;
  uint64_t *v1560;
  uint64_t *v1561;
  char *v1562;
  uint64_t v1563;
  __int128 v1564;
  __int128 v1565;
  uint64_t v1566;
  uint64_t *v1567;
  uint64_t v1568;
  uint64_t v1569;
  uint64_t v1570;
  uint64_t v1571;
  unint64_t v1572;
  uint64_t *v1573;
  uint64_t v1574;
  uint64_t *v1575;
  uint64_t v1576;
  uint64_t v1577;
  unint64_t v1578;
  uint64_t v1579;
  unint64_t v1580;
  char *v1581;
  uint64_t *v1582;
  uint64_t *v1583;
  char *v1584;
  unint64_t v1585;
  uint64_t v1586;
  uint64_t v1587;
  uint64_t *v1588;
  uint64_t *v1589;
  char *v1590;
  uint64_t v1591;
  __int128 v1592;
  __int128 v1593;
  uint64_t v1594;
  uint64_t *v1595;
  uint64_t v1596;
  uint64_t v1597;
  uint64_t v1598;
  uint64_t v1599;
  unint64_t v1600;
  uint64_t *v1601;
  uint64_t v1602;
  uint64_t *v1603;
  uint64_t v1604;
  uint64_t v1605;
  unint64_t v1606;
  uint64_t v1607;
  unint64_t v1608;
  char *v1609;
  uint64_t *v1610;
  uint64_t *v1611;
  char *v1612;
  unint64_t v1613;
  uint64_t v1614;
  uint64_t v1615;
  uint64_t *v1616;
  uint64_t *v1617;
  char *v1618;
  uint64_t v1619;
  __int128 v1620;
  __int128 v1621;
  uint64_t v1622;
  uint64_t *v1623;
  uint64_t v1624;
  uint64_t v1625;
  uint64_t v1626;
  uint64_t v1627;
  unint64_t v1628;
  uint64_t *v1629;
  uint64_t v1630;
  uint64_t *v1631;
  uint64_t v1632;
  uint64_t v1633;
  unint64_t v1634;
  uint64_t v1635;
  unint64_t v1636;
  char *v1637;
  uint64_t *v1638;
  uint64_t *v1639;
  char *v1640;
  unint64_t v1641;
  uint64_t v1642;
  uint64_t v1643;
  uint64_t *v1644;
  uint64_t *v1645;
  char *v1646;
  uint64_t v1647;
  __int128 v1648;
  __int128 v1649;
  uint64_t v1650;
  uint64_t *v1651;
  uint64_t v1652;
  uint64_t v1653;
  uint64_t v1654;
  uint64_t v1655;
  unint64_t v1656;
  uint64_t *v1657;
  uint64_t v1658;
  uint64_t *v1659;
  uint64_t v1660;
  uint64_t v1661;
  unint64_t v1662;
  uint64_t v1663;
  unint64_t v1664;
  char *v1665;
  uint64_t *v1666;
  uint64_t *v1667;
  char *v1668;
  unint64_t v1669;
  uint64_t v1670;
  uint64_t v1671;
  uint64_t *v1672;
  uint64_t *v1673;
  char *v1674;
  uint64_t v1675;
  __int128 v1676;
  __int128 v1677;
  uint64_t v1678;
  uint64_t *v1679;
  uint64_t v1680;
  uint64_t v1681;
  uint64_t v1682;
  uint64_t v1683;
  unint64_t v1684;
  uint64_t *v1685;
  uint64_t v1686;
  uint64_t *v1687;
  uint64_t v1688;
  uint64_t v1689;
  unint64_t v1690;
  uint64_t v1691;
  unint64_t v1692;
  char *v1693;
  uint64_t *v1694;
  uint64_t *v1695;
  char *v1696;
  unint64_t v1697;
  uint64_t v1698;
  uint64_t v1699;
  uint64_t *v1700;
  uint64_t *v1701;
  char *v1702;
  uint64_t v1703;
  __int128 v1704;
  __int128 v1705;
  uint64_t v1706;
  uint64_t *v1707;
  uint64_t v1708;
  uint64_t v1709;
  uint64_t v1710;
  uint64_t v1711;
  unint64_t v1712;
  uint64_t *v1713;
  uint64_t v1714;
  uint64_t *v1715;
  uint64_t v1716;
  uint64_t v1717;
  unint64_t v1718;
  uint64_t v1719;
  unint64_t v1720;
  char *v1721;
  uint64_t *v1722;
  uint64_t *v1723;
  char *v1724;
  unint64_t v1725;
  uint64_t v1726;
  uint64_t v1727;
  uint64_t *v1728;
  uint64_t *v1729;
  char *v1730;
  uint64_t v1731;
  __int128 v1732;
  __int128 v1733;
  uint64_t v1734;
  uint64_t *v1735;
  uint64_t v1736;
  uint64_t v1737;
  uint64_t v1738;
  uint64_t v1739;
  unint64_t v1740;
  uint64_t *v1741;
  uint64_t v1742;
  uint64_t *v1743;
  uint64_t v1744;
  uint64_t v1745;
  unint64_t v1746;
  uint64_t v1747;
  unint64_t v1748;
  char *v1749;
  uint64_t *v1750;
  uint64_t *v1751;
  char *v1752;
  unint64_t v1753;
  uint64_t v1754;
  uint64_t v1755;
  uint64_t *v1756;
  uint64_t *v1757;
  char *v1758;
  uint64_t v1759;
  __int128 v1760;
  __int128 v1761;
  uint64_t v1762;
  uint64_t *v1763;
  uint64_t v1764;
  uint64_t v1765;
  uint64_t v1766;
  uint64_t v1767;
  unint64_t v1768;
  uint64_t *v1769;
  uint64_t v1770;
  uint64_t *v1771;
  uint64_t v1772;
  uint64_t v1773;
  unint64_t v1774;
  uint64_t v1775;
  unint64_t v1776;
  char *v1777;
  uint64_t *v1778;
  uint64_t *v1779;
  char *v1780;
  unint64_t v1781;
  uint64_t v1782;
  uint64_t v1783;
  uint64_t *v1784;
  uint64_t *v1785;
  char *v1786;
  uint64_t v1787;
  __int128 v1788;
  __int128 v1789;
  uint64_t v1790;
  uint64_t *v1791;
  uint64_t v1792;
  uint64_t v1793;
  uint64_t v1794;
  uint64_t v1795;
  unint64_t v1796;
  uint64_t *v1797;
  uint64_t v1798;
  uint64_t *v1799;
  uint64_t v1800;
  uint64_t v1801;
  unint64_t v1802;
  uint64_t v1803;
  unint64_t v1804;
  char *v1805;
  uint64_t *v1806;
  uint64_t *v1807;
  char *v1808;
  unint64_t v1809;
  uint64_t v1810;
  uint64_t v1811;
  uint64_t *v1812;
  uint64_t *v1813;
  char *v1814;
  uint64_t v1815;
  __int128 v1816;
  __int128 v1817;
  uint64_t v1818;
  uint64_t *v1819;
  uint64_t v1820;
  uint64_t v1821;
  uint64_t v1822;
  uint64_t v1823;
  unint64_t v1824;
  uint64_t *v1825;
  uint64_t v1826;
  uint64_t *v1827;
  uint64_t v1828;
  uint64_t v1829;
  unint64_t v1830;
  uint64_t v1831;
  unint64_t v1832;
  char *v1833;
  uint64_t *v1834;
  uint64_t *v1835;
  char *v1836;
  unint64_t v1837;
  uint64_t v1838;
  uint64_t v1839;
  uint64_t *v1840;
  uint64_t *v1841;
  char *v1842;
  uint64_t v1843;
  __int128 v1844;
  __int128 v1845;
  uint64_t v1846;
  uint64_t *v1847;
  uint64_t v1848;
  uint64_t v1849;
  uint64_t v1850;
  uint64_t v1851;
  unint64_t v1852;
  uint64_t *v1853;
  uint64_t v1854;
  uint64_t *v1855;
  uint64_t v1856;
  uint64_t v1857;
  unint64_t v1858;
  uint64_t v1859;
  unint64_t v1860;
  char *v1861;
  uint64_t *v1862;
  uint64_t *v1863;
  char *v1864;
  unint64_t v1865;
  uint64_t v1866;
  uint64_t v1867;
  uint64_t *v1868;
  uint64_t *v1869;
  char *v1870;
  uint64_t v1871;
  __int128 v1872;
  __int128 v1873;
  uint64_t v1874;
  uint64_t *v1875;
  uint64_t v1876;
  uint64_t v1877;
  uint64_t v1878;
  uint64_t v1879;
  unint64_t v1880;
  uint64_t *v1881;
  uint64_t v1882;
  uint64_t *v1883;
  uint64_t v1884;
  uint64_t v1885;
  unint64_t v1886;
  uint64_t v1887;
  unint64_t v1888;
  char *v1889;
  uint64_t *v1890;
  uint64_t *v1891;
  char *v1892;
  unint64_t v1893;
  uint64_t v1894;
  uint64_t v1895;
  uint64_t *v1896;
  uint64_t *v1897;
  char *v1898;
  uint64_t v1899;
  __int128 v1900;
  __int128 v1901;
  uint64_t v1902;
  uint64_t *v1903;
  uint64_t v1904;
  uint64_t v1905;
  uint64_t v1906;
  uint64_t v1907;
  unint64_t v1908;
  uint64_t *v1909;
  uint64_t v1910;
  uint64_t *v1911;
  uint64_t v1912;
  uint64_t v1913;
  unint64_t v1914;
  uint64_t v1915;
  unint64_t v1916;
  char *v1917;
  uint64_t *v1918;
  uint64_t *v1919;
  char *v1920;
  unint64_t v1921;
  uint64_t v1922;
  uint64_t v1923;
  uint64_t *v1924;
  uint64_t *v1925;
  char *v1926;
  uint64_t v1927;
  __int128 v1928;
  __int128 v1929;
  uint64_t v1930;
  uint64_t *v1931;
  uint64_t v1932;
  uint64_t v1933;
  uint64_t v1934;
  uint64_t v1935;
  unint64_t v1936;
  uint64_t *v1937;
  uint64_t v1938;
  uint64_t *v1939;
  uint64_t v1940;
  uint64_t v1941;
  unint64_t v1942;
  uint64_t v1943;
  unint64_t v1944;
  char *v1945;
  uint64_t *v1946;
  uint64_t *v1947;
  char *v1948;
  unint64_t v1949;
  uint64_t v1950;
  uint64_t v1951;
  uint64_t *v1952;
  uint64_t *v1953;
  char *v1954;
  uint64_t v1955;
  __int128 v1956;
  __int128 v1957;
  uint64_t v1958;
  uint64_t *v1959;
  uint64_t v1960;
  uint64_t v1961;
  uint64_t v1962;
  uint64_t v1963;
  unint64_t v1964;
  uint64_t *v1965;
  uint64_t v1966;
  uint64_t *v1967;
  uint64_t v1968;
  uint64_t v1969;
  unint64_t v1970;
  uint64_t v1971;
  unint64_t v1972;
  char *v1973;
  uint64_t *v1974;
  uint64_t *v1975;
  char *v1976;
  unint64_t v1977;
  uint64_t v1978;
  uint64_t v1979;
  uint64_t *v1980;
  uint64_t *v1981;
  char *v1982;
  uint64_t v1983;
  __int128 v1984;
  __int128 v1985;
  uint64_t v1986;
  uint64_t *v1987;
  uint64_t v1988;
  uint64_t v1989;
  uint64_t v1990;
  uint64_t v1991;
  unint64_t v1992;
  uint64_t *v1993;
  uint64_t v1994;
  uint64_t *v1995;
  uint64_t v1996;
  uint64_t v1997;
  unint64_t v1998;
  uint64_t v1999;
  unint64_t v2000;
  char *v2001;
  uint64_t *v2002;
  uint64_t *v2003;
  char *v2004;
  unint64_t v2005;
  uint64_t v2006;
  uint64_t v2007;
  uint64_t *v2008;
  uint64_t *v2009;
  char *v2010;
  uint64_t v2011;
  __int128 v2012;
  __int128 v2013;
  uint64_t v2014;
  uint64_t *v2015;
  uint64_t v2016;
  uint64_t v2017;
  uint64_t v2018;
  uint64_t v2019;
  unint64_t v2020;
  uint64_t *v2021;
  uint64_t v2022;
  uint64_t *v2023;
  uint64_t v2024;
  uint64_t v2025;
  unint64_t v2026;
  uint64_t v2027;
  unint64_t v2028;
  char *v2029;
  uint64_t *v2030;
  uint64_t *v2031;
  char *v2032;
  unint64_t v2033;
  uint64_t v2034;
  uint64_t v2035;
  uint64_t *v2036;
  uint64_t *v2037;
  char *v2038;
  uint64_t v2039;
  __int128 v2040;
  __int128 v2041;
  uint64_t v2042;
  uint64_t *v2043;
  uint64_t v2044;
  uint64_t v2045;
  uint64_t v2046;
  uint64_t v2047;
  unint64_t v2048;
  uint64_t *v2049;
  uint64_t v2050;
  uint64_t *v2051;
  uint64_t v2052;
  uint64_t v2053;
  unint64_t v2054;
  uint64_t v2055;
  unint64_t v2056;
  char *v2057;
  uint64_t *v2058;
  uint64_t *v2059;
  char *v2060;
  unint64_t v2061;
  uint64_t v2062;
  uint64_t v2063;
  uint64_t *v2064;
  uint64_t *v2065;
  char *v2066;
  uint64_t v2067;
  __int128 v2068;
  __int128 v2069;
  uint64_t v2070;
  uint64_t *v2071;
  uint64_t v2072;
  uint64_t v2073;
  uint64_t v2074;
  uint64_t v2075;
  unint64_t v2076;
  uint64_t *v2077;
  uint64_t v2078;
  uint64_t *v2079;
  uint64_t v2080;
  uint64_t v2081;
  unint64_t v2082;
  uint64_t v2083;
  unint64_t v2084;
  char *v2085;
  uint64_t *v2086;
  uint64_t *v2087;
  char *v2088;
  unint64_t v2089;
  uint64_t v2090;
  uint64_t v2091;
  uint64_t *v2092;
  uint64_t *v2093;
  char *v2094;
  uint64_t v2095;
  __int128 v2096;
  __int128 v2097;
  uint64_t v2098;
  uint64_t *v2099;
  uint64_t v2100;
  uint64_t v2101;
  uint64_t v2102;
  uint64_t v2103;
  unint64_t v2104;
  uint64_t *v2105;
  uint64_t v2106;
  uint64_t *v2107;
  uint64_t v2108;
  uint64_t v2109;
  unint64_t v2110;
  uint64_t v2111;
  unint64_t v2112;
  char *v2113;
  uint64_t *v2114;
  uint64_t *v2115;
  char *v2116;
  unint64_t v2117;
  uint64_t v2118;
  uint64_t v2119;
  uint64_t *v2120;
  uint64_t *v2121;
  char *v2122;
  uint64_t v2123;
  __int128 v2124;
  __int128 v2125;
  uint64_t v2126;
  uint64_t *v2127;
  uint64_t v2128;
  uint64_t v2129;
  uint64_t v2130;
  uint64_t v2131;
  unint64_t v2132;
  uint64_t *v2133;
  uint64_t v2134;
  uint64_t *v2135;
  uint64_t v2136;
  uint64_t v2137;
  unint64_t v2138;
  uint64_t v2139;
  unint64_t v2140;
  char *v2141;
  uint64_t *v2142;
  uint64_t *v2143;
  char *v2144;
  unint64_t v2145;
  uint64_t v2146;
  uint64_t v2147;
  uint64_t *v2148;
  uint64_t *v2149;
  char *v2150;
  uint64_t v2151;
  __int128 v2152;
  __int128 v2153;
  uint64_t v2154;
  uint64_t *v2155;
  uint64_t v2156;
  uint64_t v2157;
  uint64_t v2158;
  uint64_t v2159;
  unint64_t v2160;
  uint64_t *v2161;
  uint64_t v2162;
  uint64_t *v2163;
  uint64_t v2164;
  uint64_t v2165;
  unint64_t v2166;
  uint64_t v2167;
  unint64_t v2168;
  char *v2169;
  uint64_t *v2170;
  uint64_t *v2171;
  char *v2172;
  unint64_t v2173;
  uint64_t v2174;
  uint64_t v2175;
  uint64_t *v2176;
  uint64_t *v2177;
  char *v2178;
  uint64_t v2179;
  __int128 v2180;
  __int128 v2181;
  uint64_t v2182;
  uint64_t *v2183;
  uint64_t v2184;
  uint64_t v2185;

  v2 = operator new();
  v3 = v2;
  strcpy((char *)(v2 + 8), "clamped_relu");
  *(_BYTE *)(v2 + 21) = 0;
  *(_WORD *)(v2 + 22) = 0;
  *(_BYTE *)(v2 + 31) = 12;
  *(_QWORD *)v2 = off_1E0E16E30;
  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *v5 = v2;
    v7 = (uint64_t)(v5 + 1);
    goto LABEL_27;
  }
  v8 = *a1;
  v9 = (char *)v5 - (char *)*a1;
  v10 = v9 >> 3;
  v11 = (v9 >> 3) + 1;
  if (v11 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v12 = v4 - (_QWORD)v8;
  if (v12 >> 2 > v11)
    v11 = v12 >> 2;
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
    v13 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v13 = v11;
  if (v13)
  {
    if (v13 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v14 = (char *)operator new(8 * v13);
    v15 = (uint64_t *)&v14[8 * v10];
    v16 = (uint64_t *)&v14[8 * v13];
    *v15 = v3;
    v7 = (uint64_t)(v15 + 1);
    v17 = (char *)((char *)v5 - (char *)v8);
    if (v5 != v8)
      goto LABEL_12;
  }
  else
  {
    v14 = 0;
    v15 = (uint64_t *)(8 * v10);
    v16 = 0;
    *(_QWORD *)(8 * v10) = v3;
    v7 = 8 * v10 + 8;
    v17 = (char *)((char *)v5 - (char *)v8);
    if (v5 != v8)
    {
LABEL_12:
      v18 = (unint64_t)(v17 - 8);
      if (v18 < 0x78
        || (uint64_t *)((char *)v5 - (v18 & 0xFFFFFFFFFFFFFFF8) - 8) < v15
        && &v14[v9 - (v18 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v5)
      {
        goto LABEL_2188;
      }
      v19 = (v18 >> 3) + 1;
      v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
      v15 = (uint64_t *)((char *)v15 - v20);
      v6 = &v5[v20 / 0xFFFFFFFFFFFFFFF8];
      v21 = v5 - 2;
      v22 = &v14[8 * v10 - 16];
      v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v25 = *((_OWORD *)v21 - 1);
        v24 = *(_OWORD *)v21;
        *((_OWORD *)v21 - 1) = 0uLL;
        *(_OWORD *)v21 = 0uLL;
        *((_OWORD *)v22 - 1) = v25;
        *(_OWORD *)v22 = v24;
        v21 -= 4;
        v22 -= 32;
        v23 -= 4;
      }
      while (v23);
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2188:
        do
        {
          v26 = *--v6;
          *v6 = 0;
          *--v15 = v26;
        }
        while (v6 != v8);
      }
      v6 = *a1;
      v27 = a1[1];
      *a1 = v15;
      a1[1] = (uint64_t *)v7;
      a1[2] = v16;
      while (v27 != v6)
      {
        v29 = *--v27;
        v28 = v29;
        *v27 = 0;
        if (v29)
          (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
      }
      goto LABEL_25;
    }
  }
  *a1 = v15;
  a1[1] = (uint64_t *)v7;
  a1[2] = v16;
LABEL_25:
  if (v6)
    operator delete(v6);
LABEL_27:
  a1[1] = (uint64_t *)v7;
  v30 = operator new();
  v31 = v30;
  *(_BYTE *)(v30 + 31) = 3;
  *(_QWORD *)v30 = off_1E0E16E58;
  *(_QWORD *)(v30 + 8) = 7695461;
  v33 = a1[1];
  v32 = (unint64_t)a1[2];
  if ((unint64_t)v33 < v32)
  {
    *v33 = v30;
    v34 = (uint64_t)(v33 + 1);
    goto LABEL_53;
  }
  v35 = *a1;
  v36 = (char *)v33 - (char *)*a1;
  v37 = v36 >> 3;
  v38 = (v36 >> 3) + 1;
  if (v38 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v39 = v32 - (_QWORD)v35;
  if (v39 >> 2 > v38)
    v38 = v39 >> 2;
  if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8)
    v40 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v40 = v38;
  if (v40)
  {
    if (v40 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v41 = (char *)operator new(8 * v40);
    v42 = (uint64_t *)&v41[8 * v37];
    v43 = (uint64_t *)&v41[8 * v40];
    *v42 = v31;
    v34 = (uint64_t)(v42 + 1);
    v44 = (char *)((char *)v33 - (char *)v35);
    if (v33 != v35)
      goto LABEL_38;
  }
  else
  {
    v41 = 0;
    v42 = (uint64_t *)(8 * v37);
    v43 = 0;
    *(_QWORD *)(8 * v37) = v31;
    v34 = 8 * v37 + 8;
    v44 = (char *)((char *)v33 - (char *)v35);
    if (v33 != v35)
    {
LABEL_38:
      v45 = (unint64_t)(v44 - 8);
      if (v45 < 0x78
        || (uint64_t *)((char *)v33 - (v45 & 0xFFFFFFFFFFFFFFF8) - 8) < v42
        && &v41[v36 - (v45 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v33)
      {
        goto LABEL_2189;
      }
      v46 = (v45 >> 3) + 1;
      v47 = 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
      v42 = (uint64_t *)((char *)v42 - v47);
      v48 = &v33[v47 / 0xFFFFFFFFFFFFFFF8];
      v49 = v33 - 2;
      v50 = &v41[8 * v37 - 16];
      v51 = v46 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v53 = *((_OWORD *)v49 - 1);
        v52 = *(_OWORD *)v49;
        *((_OWORD *)v49 - 1) = 0uLL;
        *(_OWORD *)v49 = 0uLL;
        *((_OWORD *)v50 - 1) = v53;
        *(_OWORD *)v50 = v52;
        v49 -= 4;
        v50 -= 32;
        v51 -= 4;
      }
      while (v51);
      v33 = v48;
      if (v46 != (v46 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2189:
        do
        {
          v54 = *--v33;
          *v33 = 0;
          *--v42 = v54;
        }
        while (v33 != v35);
      }
      v33 = *a1;
      v55 = a1[1];
      *a1 = v42;
      a1[1] = (uint64_t *)v34;
      a1[2] = v43;
      while (v55 != v33)
      {
        v57 = *--v55;
        v56 = v57;
        *v55 = 0;
        if (v57)
          (*(void (**)(uint64_t))(*(_QWORD *)v56 + 8))(v56);
      }
      goto LABEL_51;
    }
  }
  *a1 = v42;
  a1[1] = (uint64_t *)v34;
  a1[2] = v43;
LABEL_51:
  if (v33)
    operator delete(v33);
LABEL_53:
  a1[1] = (uint64_t *)v34;
  v58 = operator new();
  v59 = v58;
  *(_BYTE *)(v58 + 31) = 3;
  *(_QWORD *)v58 = off_1E0E16E80;
  *(_QWORD *)(v58 + 8) = 6713957;
  v61 = a1[1];
  v60 = (unint64_t)a1[2];
  if ((unint64_t)v61 < v60)
  {
    *v61 = v58;
    v62 = (uint64_t)(v61 + 1);
    goto LABEL_79;
  }
  v63 = *a1;
  v64 = (char *)v61 - (char *)*a1;
  v65 = v64 >> 3;
  v66 = (v64 >> 3) + 1;
  if (v66 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v67 = v60 - (_QWORD)v63;
  if (v67 >> 2 > v66)
    v66 = v67 >> 2;
  if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
    v68 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v68 = v66;
  if (v68)
  {
    if (v68 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v69 = (char *)operator new(8 * v68);
    v70 = (uint64_t *)&v69[8 * v65];
    v71 = (uint64_t *)&v69[8 * v68];
    *v70 = v59;
    v62 = (uint64_t)(v70 + 1);
    v72 = (char *)((char *)v61 - (char *)v63);
    if (v61 != v63)
      goto LABEL_64;
  }
  else
  {
    v69 = 0;
    v70 = (uint64_t *)(8 * v65);
    v71 = 0;
    *(_QWORD *)(8 * v65) = v59;
    v62 = 8 * v65 + 8;
    v72 = (char *)((char *)v61 - (char *)v63);
    if (v61 != v63)
    {
LABEL_64:
      v73 = (unint64_t)(v72 - 8);
      if (v73 < 0x78
        || (uint64_t *)((char *)v61 - (v73 & 0xFFFFFFFFFFFFFFF8) - 8) < v70
        && &v69[v64 - (v73 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v61)
      {
        goto LABEL_2190;
      }
      v74 = (v73 >> 3) + 1;
      v75 = 8 * (v74 & 0x3FFFFFFFFFFFFFFCLL);
      v70 = (uint64_t *)((char *)v70 - v75);
      v76 = &v61[v75 / 0xFFFFFFFFFFFFFFF8];
      v77 = v61 - 2;
      v78 = &v69[8 * v65 - 16];
      v79 = v74 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v81 = *((_OWORD *)v77 - 1);
        v80 = *(_OWORD *)v77;
        *((_OWORD *)v77 - 1) = 0uLL;
        *(_OWORD *)v77 = 0uLL;
        *((_OWORD *)v78 - 1) = v81;
        *(_OWORD *)v78 = v80;
        v77 -= 4;
        v78 -= 32;
        v79 -= 4;
      }
      while (v79);
      v61 = v76;
      if (v74 != (v74 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2190:
        do
        {
          v82 = *--v61;
          *v61 = 0;
          *--v70 = v82;
        }
        while (v61 != v63);
      }
      v61 = *a1;
      v83 = a1[1];
      *a1 = v70;
      a1[1] = (uint64_t *)v62;
      a1[2] = v71;
      while (v83 != v61)
      {
        v85 = *--v83;
        v84 = v85;
        *v83 = 0;
        if (v85)
          (*(void (**)(uint64_t))(*(_QWORD *)v84 + 8))(v84);
      }
      goto LABEL_77;
    }
  }
  *a1 = v70;
  a1[1] = (uint64_t *)v62;
  a1[2] = v71;
LABEL_77:
  if (v61)
    operator delete(v61);
LABEL_79:
  a1[1] = (uint64_t *)v62;
  v86 = operator new();
  v87 = v86;
  *(_QWORD *)(v86 + 8) = 0x65725F796B61656CLL;
  *(_QWORD *)(v86 + 16) = 30060;
  *(_BYTE *)(v86 + 31) = 10;
  *(_QWORD *)v86 = off_1E0E16EA8;
  v89 = a1[1];
  v88 = (unint64_t)a1[2];
  if ((unint64_t)v89 < v88)
  {
    *v89 = v86;
    v90 = (uint64_t)(v89 + 1);
    goto LABEL_105;
  }
  v91 = *a1;
  v92 = (char *)v89 - (char *)*a1;
  v93 = v92 >> 3;
  v94 = (v92 >> 3) + 1;
  if (v94 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v95 = v88 - (_QWORD)v91;
  if (v95 >> 2 > v94)
    v94 = v95 >> 2;
  if ((unint64_t)v95 >= 0x7FFFFFFFFFFFFFF8)
    v96 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v96 = v94;
  if (v96)
  {
    if (v96 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v97 = (char *)operator new(8 * v96);
    v98 = (uint64_t *)&v97[8 * v93];
    v99 = (uint64_t *)&v97[8 * v96];
    *v98 = v87;
    v90 = (uint64_t)(v98 + 1);
    v100 = (char *)((char *)v89 - (char *)v91);
    if (v89 != v91)
      goto LABEL_90;
  }
  else
  {
    v97 = 0;
    v98 = (uint64_t *)(8 * v93);
    v99 = 0;
    *(_QWORD *)(8 * v93) = v87;
    v90 = 8 * v93 + 8;
    v100 = (char *)((char *)v89 - (char *)v91);
    if (v89 != v91)
    {
LABEL_90:
      v101 = (unint64_t)(v100 - 8);
      if (v101 < 0x78
        || (uint64_t *)((char *)v89 - (v101 & 0xFFFFFFFFFFFFFFF8) - 8) < v98
        && &v97[v92 - (v101 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v89)
      {
        goto LABEL_2191;
      }
      v102 = (v101 >> 3) + 1;
      v103 = 8 * (v102 & 0x3FFFFFFFFFFFFFFCLL);
      v98 = (uint64_t *)((char *)v98 - v103);
      v104 = &v89[v103 / 0xFFFFFFFFFFFFFFF8];
      v105 = v89 - 2;
      v106 = &v97[8 * v93 - 16];
      v107 = v102 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v109 = *((_OWORD *)v105 - 1);
        v108 = *(_OWORD *)v105;
        *((_OWORD *)v105 - 1) = 0uLL;
        *(_OWORD *)v105 = 0uLL;
        *((_OWORD *)v106 - 1) = v109;
        *(_OWORD *)v106 = v108;
        v105 -= 4;
        v106 -= 32;
        v107 -= 4;
      }
      while (v107);
      v89 = v104;
      if (v102 != (v102 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2191:
        do
        {
          v110 = *--v89;
          *v89 = 0;
          *--v98 = v110;
        }
        while (v89 != v91);
      }
      v89 = *a1;
      v111 = a1[1];
      *a1 = v98;
      a1[1] = (uint64_t *)v90;
      a1[2] = v99;
      while (v111 != v89)
      {
        v113 = *--v111;
        v112 = v113;
        *v111 = 0;
        if (v113)
          (*(void (**)(uint64_t))(*(_QWORD *)v112 + 8))(v112);
      }
      goto LABEL_103;
    }
  }
  *a1 = v98;
  a1[1] = (uint64_t *)v90;
  a1[2] = v99;
LABEL_103:
  if (v89)
    operator delete(v89);
LABEL_105:
  a1[1] = (uint64_t *)v90;
  v114 = operator new();
  v115 = v114;
  strcpy((char *)(v114 + 8), "linear_activation");
  *(_BYTE *)(v114 + 31) = 17;
  *(_QWORD *)v114 = off_1E0E16ED0;
  v117 = a1[1];
  v116 = (unint64_t)a1[2];
  if ((unint64_t)v117 < v116)
  {
    *v117 = v114;
    v118 = (uint64_t)(v117 + 1);
    goto LABEL_131;
  }
  v119 = *a1;
  v120 = (char *)v117 - (char *)*a1;
  v121 = v120 >> 3;
  v122 = (v120 >> 3) + 1;
  if (v122 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v123 = v116 - (_QWORD)v119;
  if (v123 >> 2 > v122)
    v122 = v123 >> 2;
  if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFF8)
    v124 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v124 = v122;
  if (v124)
  {
    if (v124 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v125 = (char *)operator new(8 * v124);
    v126 = (uint64_t *)&v125[8 * v121];
    v127 = (uint64_t *)&v125[8 * v124];
    *v126 = v115;
    v118 = (uint64_t)(v126 + 1);
    v128 = (char *)((char *)v117 - (char *)v119);
    if (v117 != v119)
      goto LABEL_116;
  }
  else
  {
    v125 = 0;
    v126 = (uint64_t *)(8 * v121);
    v127 = 0;
    *(_QWORD *)(8 * v121) = v115;
    v118 = 8 * v121 + 8;
    v128 = (char *)((char *)v117 - (char *)v119);
    if (v117 != v119)
    {
LABEL_116:
      v129 = (unint64_t)(v128 - 8);
      if (v129 < 0x78
        || (uint64_t *)((char *)v117 - (v129 & 0xFFFFFFFFFFFFFFF8) - 8) < v126
        && &v125[v120 - (v129 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v117)
      {
        goto LABEL_2192;
      }
      v130 = (v129 >> 3) + 1;
      v131 = 8 * (v130 & 0x3FFFFFFFFFFFFFFCLL);
      v126 = (uint64_t *)((char *)v126 - v131);
      v132 = &v117[v131 / 0xFFFFFFFFFFFFFFF8];
      v133 = v117 - 2;
      v134 = &v125[8 * v121 - 16];
      v135 = v130 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v137 = *((_OWORD *)v133 - 1);
        v136 = *(_OWORD *)v133;
        *((_OWORD *)v133 - 1) = 0uLL;
        *(_OWORD *)v133 = 0uLL;
        *((_OWORD *)v134 - 1) = v137;
        *(_OWORD *)v134 = v136;
        v133 -= 4;
        v134 -= 32;
        v135 -= 4;
      }
      while (v135);
      v117 = v132;
      if (v130 != (v130 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2192:
        do
        {
          v138 = *--v117;
          *v117 = 0;
          *--v126 = v138;
        }
        while (v117 != v119);
      }
      v117 = *a1;
      v139 = a1[1];
      *a1 = v126;
      a1[1] = (uint64_t *)v118;
      a1[2] = v127;
      while (v139 != v117)
      {
        v141 = *--v139;
        v140 = v141;
        *v139 = 0;
        if (v141)
          (*(void (**)(uint64_t))(*(_QWORD *)v140 + 8))(v140);
      }
      goto LABEL_129;
    }
  }
  *a1 = v126;
  a1[1] = (uint64_t *)v118;
  a1[2] = v127;
LABEL_129:
  if (v117)
    operator delete(v117);
LABEL_131:
  a1[1] = (uint64_t *)v118;
  v142 = operator new();
  v143 = v142;
  *(_BYTE *)(v142 + 31) = 4;
  *(_QWORD *)v142 = off_1E0E16EF8;
  *(_QWORD *)(v142 + 8) = 1970038130;
  v145 = a1[1];
  v144 = (unint64_t)a1[2];
  if ((unint64_t)v145 < v144)
  {
    *v145 = v142;
    v146 = (uint64_t)(v145 + 1);
    goto LABEL_157;
  }
  v147 = *a1;
  v148 = (char *)v145 - (char *)*a1;
  v149 = v148 >> 3;
  v150 = (v148 >> 3) + 1;
  if (v150 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v151 = v144 - (_QWORD)v147;
  if (v151 >> 2 > v150)
    v150 = v151 >> 2;
  if ((unint64_t)v151 >= 0x7FFFFFFFFFFFFFF8)
    v152 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v152 = v150;
  if (v152)
  {
    if (v152 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v153 = (char *)operator new(8 * v152);
    v154 = (uint64_t *)&v153[8 * v149];
    v155 = (uint64_t *)&v153[8 * v152];
    *v154 = v143;
    v146 = (uint64_t)(v154 + 1);
    v156 = (char *)((char *)v145 - (char *)v147);
    if (v145 != v147)
      goto LABEL_142;
  }
  else
  {
    v153 = 0;
    v154 = (uint64_t *)(8 * v149);
    v155 = 0;
    *(_QWORD *)(8 * v149) = v143;
    v146 = 8 * v149 + 8;
    v156 = (char *)((char *)v145 - (char *)v147);
    if (v145 != v147)
    {
LABEL_142:
      v157 = (unint64_t)(v156 - 8);
      if (v157 < 0x78
        || (uint64_t *)((char *)v145 - (v157 & 0xFFFFFFFFFFFFFFF8) - 8) < v154
        && &v153[v148 - (v157 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v145)
      {
        goto LABEL_2193;
      }
      v158 = (v157 >> 3) + 1;
      v159 = 8 * (v158 & 0x3FFFFFFFFFFFFFFCLL);
      v154 = (uint64_t *)((char *)v154 - v159);
      v160 = &v145[v159 / 0xFFFFFFFFFFFFFFF8];
      v161 = v145 - 2;
      v162 = &v153[8 * v149 - 16];
      v163 = v158 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v165 = *((_OWORD *)v161 - 1);
        v164 = *(_OWORD *)v161;
        *((_OWORD *)v161 - 1) = 0uLL;
        *(_OWORD *)v161 = 0uLL;
        *((_OWORD *)v162 - 1) = v165;
        *(_OWORD *)v162 = v164;
        v161 -= 4;
        v162 -= 32;
        v163 -= 4;
      }
      while (v163);
      v145 = v160;
      if (v158 != (v158 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2193:
        do
        {
          v166 = *--v145;
          *v145 = 0;
          *--v154 = v166;
        }
        while (v145 != v147);
      }
      v145 = *a1;
      v167 = a1[1];
      *a1 = v154;
      a1[1] = (uint64_t *)v146;
      a1[2] = v155;
      while (v167 != v145)
      {
        v169 = *--v167;
        v168 = v169;
        *v167 = 0;
        if (v169)
          (*(void (**)(uint64_t))(*(_QWORD *)v168 + 8))(v168);
      }
      goto LABEL_155;
    }
  }
  *a1 = v154;
  a1[1] = (uint64_t *)v146;
  a1[2] = v155;
LABEL_155:
  if (v145)
    operator delete(v145);
LABEL_157:
  a1[1] = (uint64_t *)v146;
  v170 = operator new();
  v171 = v170;
  *(_BYTE *)(v170 + 31) = 5;
  *(_QWORD *)v170 = off_1E0E16F20;
  *(_QWORD *)(v170 + 8) = 0x36756C6572;
  v173 = a1[1];
  v172 = (unint64_t)a1[2];
  if ((unint64_t)v173 < v172)
  {
    *v173 = v170;
    v174 = (uint64_t)(v173 + 1);
    goto LABEL_183;
  }
  v175 = *a1;
  v176 = (char *)v173 - (char *)*a1;
  v177 = v176 >> 3;
  v178 = (v176 >> 3) + 1;
  if (v178 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v179 = v172 - (_QWORD)v175;
  if (v179 >> 2 > v178)
    v178 = v179 >> 2;
  if ((unint64_t)v179 >= 0x7FFFFFFFFFFFFFF8)
    v180 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v180 = v178;
  if (v180)
  {
    if (v180 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v181 = (char *)operator new(8 * v180);
    v182 = (uint64_t *)&v181[8 * v177];
    v183 = (uint64_t *)&v181[8 * v180];
    *v182 = v171;
    v174 = (uint64_t)(v182 + 1);
    v184 = (char *)((char *)v173 - (char *)v175);
    if (v173 != v175)
      goto LABEL_168;
  }
  else
  {
    v181 = 0;
    v182 = (uint64_t *)(8 * v177);
    v183 = 0;
    *(_QWORD *)(8 * v177) = v171;
    v174 = 8 * v177 + 8;
    v184 = (char *)((char *)v173 - (char *)v175);
    if (v173 != v175)
    {
LABEL_168:
      v185 = (unint64_t)(v184 - 8);
      if (v185 < 0x78
        || (uint64_t *)((char *)v173 - (v185 & 0xFFFFFFFFFFFFFFF8) - 8) < v182
        && &v181[v176 - (v185 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v173)
      {
        goto LABEL_2194;
      }
      v186 = (v185 >> 3) + 1;
      v187 = 8 * (v186 & 0x3FFFFFFFFFFFFFFCLL);
      v182 = (uint64_t *)((char *)v182 - v187);
      v188 = &v173[v187 / 0xFFFFFFFFFFFFFFF8];
      v189 = v173 - 2;
      v190 = &v181[8 * v177 - 16];
      v191 = v186 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v193 = *((_OWORD *)v189 - 1);
        v192 = *(_OWORD *)v189;
        *((_OWORD *)v189 - 1) = 0uLL;
        *(_OWORD *)v189 = 0uLL;
        *((_OWORD *)v190 - 1) = v193;
        *(_OWORD *)v190 = v192;
        v189 -= 4;
        v190 -= 32;
        v191 -= 4;
      }
      while (v191);
      v173 = v188;
      if (v186 != (v186 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2194:
        do
        {
          v194 = *--v173;
          *v173 = 0;
          *--v182 = v194;
        }
        while (v173 != v175);
      }
      v173 = *a1;
      v195 = a1[1];
      *a1 = v182;
      a1[1] = (uint64_t *)v174;
      a1[2] = v183;
      while (v195 != v173)
      {
        v197 = *--v195;
        v196 = v197;
        *v195 = 0;
        if (v197)
          (*(void (**)(uint64_t))(*(_QWORD *)v196 + 8))(v196);
      }
      goto LABEL_181;
    }
  }
  *a1 = v182;
  a1[1] = (uint64_t *)v174;
  a1[2] = v183;
LABEL_181:
  if (v173)
    operator delete(v173);
LABEL_183:
  a1[1] = (uint64_t *)v174;
  v198 = operator new();
  v199 = v198;
  *(_QWORD *)(v198 + 8) = 0x745F64656C616373;
  *(_QWORD *)(v198 + 16) = 6844001;
  *(_BYTE *)(v198 + 31) = 11;
  *(_QWORD *)v198 = off_1E0E16F48;
  v201 = a1[1];
  v200 = (unint64_t)a1[2];
  if ((unint64_t)v201 < v200)
  {
    *v201 = v198;
    v202 = (uint64_t)(v201 + 1);
    goto LABEL_209;
  }
  v203 = *a1;
  v204 = (char *)v201 - (char *)*a1;
  v205 = v204 >> 3;
  v206 = (v204 >> 3) + 1;
  if (v206 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v207 = v200 - (_QWORD)v203;
  if (v207 >> 2 > v206)
    v206 = v207 >> 2;
  if ((unint64_t)v207 >= 0x7FFFFFFFFFFFFFF8)
    v208 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v208 = v206;
  if (v208)
  {
    if (v208 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v209 = (char *)operator new(8 * v208);
    v210 = (uint64_t *)&v209[8 * v205];
    v211 = (uint64_t *)&v209[8 * v208];
    *v210 = v199;
    v202 = (uint64_t)(v210 + 1);
    v212 = (char *)((char *)v201 - (char *)v203);
    if (v201 != v203)
      goto LABEL_194;
  }
  else
  {
    v209 = 0;
    v210 = (uint64_t *)(8 * v205);
    v211 = 0;
    *(_QWORD *)(8 * v205) = v199;
    v202 = 8 * v205 + 8;
    v212 = (char *)((char *)v201 - (char *)v203);
    if (v201 != v203)
    {
LABEL_194:
      v213 = (unint64_t)(v212 - 8);
      if (v213 < 0x78
        || (uint64_t *)((char *)v201 - (v213 & 0xFFFFFFFFFFFFFFF8) - 8) < v210
        && &v209[v204 - (v213 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v201)
      {
        goto LABEL_2195;
      }
      v214 = (v213 >> 3) + 1;
      v215 = 8 * (v214 & 0x3FFFFFFFFFFFFFFCLL);
      v210 = (uint64_t *)((char *)v210 - v215);
      v216 = &v201[v215 / 0xFFFFFFFFFFFFFFF8];
      v217 = v201 - 2;
      v218 = &v209[8 * v205 - 16];
      v219 = v214 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v221 = *((_OWORD *)v217 - 1);
        v220 = *(_OWORD *)v217;
        *((_OWORD *)v217 - 1) = 0uLL;
        *(_OWORD *)v217 = 0uLL;
        *((_OWORD *)v218 - 1) = v221;
        *(_OWORD *)v218 = v220;
        v217 -= 4;
        v218 -= 32;
        v219 -= 4;
      }
      while (v219);
      v201 = v216;
      if (v214 != (v214 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2195:
        do
        {
          v222 = *--v201;
          *v201 = 0;
          *--v210 = v222;
        }
        while (v201 != v203);
      }
      v201 = *a1;
      v223 = a1[1];
      *a1 = v210;
      a1[1] = (uint64_t *)v202;
      a1[2] = v211;
      while (v223 != v201)
      {
        v225 = *--v223;
        v224 = v225;
        *v223 = 0;
        if (v225)
          (*(void (**)(uint64_t))(*(_QWORD *)v224 + 8))(v224);
      }
      goto LABEL_207;
    }
  }
  *a1 = v210;
  a1[1] = (uint64_t *)v202;
  a1[2] = v211;
LABEL_207:
  if (v201)
    operator delete(v201);
LABEL_209:
  a1[1] = (uint64_t *)v202;
  v226 = operator new();
  v227 = v226;
  *(_BYTE *)(v226 + 31) = 7;
  *(_QWORD *)v226 = off_1E0E16F70;
  *(_QWORD *)(v226 + 8) = 0x64696F6D676973;
  v229 = a1[1];
  v228 = (unint64_t)a1[2];
  if ((unint64_t)v229 < v228)
  {
    *v229 = v226;
    v230 = (uint64_t)(v229 + 1);
    goto LABEL_235;
  }
  v231 = *a1;
  v232 = (char *)v229 - (char *)*a1;
  v233 = v232 >> 3;
  v234 = (v232 >> 3) + 1;
  if (v234 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v235 = v228 - (_QWORD)v231;
  if (v235 >> 2 > v234)
    v234 = v235 >> 2;
  if ((unint64_t)v235 >= 0x7FFFFFFFFFFFFFF8)
    v236 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v236 = v234;
  if (v236)
  {
    if (v236 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v237 = (char *)operator new(8 * v236);
    v238 = (uint64_t *)&v237[8 * v233];
    v239 = (uint64_t *)&v237[8 * v236];
    *v238 = v227;
    v230 = (uint64_t)(v238 + 1);
    v240 = (char *)((char *)v229 - (char *)v231);
    if (v229 != v231)
      goto LABEL_220;
  }
  else
  {
    v237 = 0;
    v238 = (uint64_t *)(8 * v233);
    v239 = 0;
    *(_QWORD *)(8 * v233) = v227;
    v230 = 8 * v233 + 8;
    v240 = (char *)((char *)v229 - (char *)v231);
    if (v229 != v231)
    {
LABEL_220:
      v241 = (unint64_t)(v240 - 8);
      if (v241 < 0x78
        || (uint64_t *)((char *)v229 - (v241 & 0xFFFFFFFFFFFFFFF8) - 8) < v238
        && &v237[v232 - (v241 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v229)
      {
        goto LABEL_2196;
      }
      v242 = (v241 >> 3) + 1;
      v243 = 8 * (v242 & 0x3FFFFFFFFFFFFFFCLL);
      v238 = (uint64_t *)((char *)v238 - v243);
      v244 = &v229[v243 / 0xFFFFFFFFFFFFFFF8];
      v245 = v229 - 2;
      v246 = &v237[8 * v233 - 16];
      v247 = v242 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v249 = *((_OWORD *)v245 - 1);
        v248 = *(_OWORD *)v245;
        *((_OWORD *)v245 - 1) = 0uLL;
        *(_OWORD *)v245 = 0uLL;
        *((_OWORD *)v246 - 1) = v249;
        *(_OWORD *)v246 = v248;
        v245 -= 4;
        v246 -= 32;
        v247 -= 4;
      }
      while (v247);
      v229 = v244;
      if (v242 != (v242 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2196:
        do
        {
          v250 = *--v229;
          *v229 = 0;
          *--v238 = v250;
        }
        while (v229 != v231);
      }
      v229 = *a1;
      v251 = a1[1];
      *a1 = v238;
      a1[1] = (uint64_t *)v230;
      a1[2] = v239;
      while (v251 != v229)
      {
        v253 = *--v251;
        v252 = v253;
        *v251 = 0;
        if (v253)
          (*(void (**)(uint64_t))(*(_QWORD *)v252 + 8))(v252);
      }
      goto LABEL_233;
    }
  }
  *a1 = v238;
  a1[1] = (uint64_t *)v230;
  a1[2] = v239;
LABEL_233:
  if (v229)
    operator delete(v229);
LABEL_235:
  a1[1] = (uint64_t *)v230;
  v254 = operator new();
  v255 = v254;
  strcpy((char *)(v254 + 8), "sigmoid_hard");
  *(_BYTE *)(v254 + 21) = 0;
  *(_WORD *)(v254 + 22) = 0;
  *(_BYTE *)(v254 + 31) = 12;
  *(_QWORD *)v254 = off_1E0E16F98;
  v257 = a1[1];
  v256 = (unint64_t)a1[2];
  if ((unint64_t)v257 < v256)
  {
    *v257 = v254;
    v258 = (uint64_t)(v257 + 1);
    goto LABEL_261;
  }
  v259 = *a1;
  v260 = (char *)v257 - (char *)*a1;
  v261 = v260 >> 3;
  v262 = (v260 >> 3) + 1;
  if (v262 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v263 = v256 - (_QWORD)v259;
  if (v263 >> 2 > v262)
    v262 = v263 >> 2;
  if ((unint64_t)v263 >= 0x7FFFFFFFFFFFFFF8)
    v264 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v264 = v262;
  if (v264)
  {
    if (v264 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v265 = (char *)operator new(8 * v264);
    v266 = (uint64_t *)&v265[8 * v261];
    v267 = (uint64_t *)&v265[8 * v264];
    *v266 = v255;
    v258 = (uint64_t)(v266 + 1);
    v268 = (char *)((char *)v257 - (char *)v259);
    if (v257 != v259)
      goto LABEL_246;
  }
  else
  {
    v265 = 0;
    v266 = (uint64_t *)(8 * v261);
    v267 = 0;
    *(_QWORD *)(8 * v261) = v255;
    v258 = 8 * v261 + 8;
    v268 = (char *)((char *)v257 - (char *)v259);
    if (v257 != v259)
    {
LABEL_246:
      v269 = (unint64_t)(v268 - 8);
      if (v269 < 0x78
        || (uint64_t *)((char *)v257 - (v269 & 0xFFFFFFFFFFFFFFF8) - 8) < v266
        && &v265[v260 - (v269 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v257)
      {
        goto LABEL_2197;
      }
      v270 = (v269 >> 3) + 1;
      v271 = 8 * (v270 & 0x3FFFFFFFFFFFFFFCLL);
      v266 = (uint64_t *)((char *)v266 - v271);
      v272 = &v257[v271 / 0xFFFFFFFFFFFFFFF8];
      v273 = v257 - 2;
      v274 = &v265[8 * v261 - 16];
      v275 = v270 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v277 = *((_OWORD *)v273 - 1);
        v276 = *(_OWORD *)v273;
        *((_OWORD *)v273 - 1) = 0uLL;
        *(_OWORD *)v273 = 0uLL;
        *((_OWORD *)v274 - 1) = v277;
        *(_OWORD *)v274 = v276;
        v273 -= 4;
        v274 -= 32;
        v275 -= 4;
      }
      while (v275);
      v257 = v272;
      if (v270 != (v270 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2197:
        do
        {
          v278 = *--v257;
          *v257 = 0;
          *--v266 = v278;
        }
        while (v257 != v259);
      }
      v257 = *a1;
      v279 = a1[1];
      *a1 = v266;
      a1[1] = (uint64_t *)v258;
      a1[2] = v267;
      while (v279 != v257)
      {
        v281 = *--v279;
        v280 = v281;
        *v279 = 0;
        if (v281)
          (*(void (**)(uint64_t))(*(_QWORD *)v280 + 8))(v280);
      }
      goto LABEL_259;
    }
  }
  *a1 = v266;
  a1[1] = (uint64_t *)v258;
  a1[2] = v267;
LABEL_259:
  if (v257)
    operator delete(v257);
LABEL_261:
  a1[1] = (uint64_t *)v258;
  v282 = operator new();
  v283 = v282;
  *(_BYTE *)(v282 + 31) = 4;
  *(_QWORD *)v282 = off_1E0E17338;
  *(_QWORD *)(v282 + 8) = 1970039155;
  v285 = a1[1];
  v284 = (unint64_t)a1[2];
  if ((unint64_t)v285 < v284)
  {
    *v285 = v282;
    v286 = (uint64_t)(v285 + 1);
    goto LABEL_287;
  }
  v287 = *a1;
  v288 = (char *)v285 - (char *)*a1;
  v289 = v288 >> 3;
  v290 = (v288 >> 3) + 1;
  if (v290 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v291 = v284 - (_QWORD)v287;
  if (v291 >> 2 > v290)
    v290 = v291 >> 2;
  if ((unint64_t)v291 >= 0x7FFFFFFFFFFFFFF8)
    v292 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v292 = v290;
  if (v292)
  {
    if (v292 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v293 = (char *)operator new(8 * v292);
    v294 = (uint64_t *)&v293[8 * v289];
    v295 = (uint64_t *)&v293[8 * v292];
    *v294 = v283;
    v286 = (uint64_t)(v294 + 1);
    v296 = (char *)((char *)v285 - (char *)v287);
    if (v285 != v287)
      goto LABEL_272;
  }
  else
  {
    v293 = 0;
    v294 = (uint64_t *)(8 * v289);
    v295 = 0;
    *(_QWORD *)(8 * v289) = v283;
    v286 = 8 * v289 + 8;
    v296 = (char *)((char *)v285 - (char *)v287);
    if (v285 != v287)
    {
LABEL_272:
      v297 = (unint64_t)(v296 - 8);
      if (v297 < 0x78
        || (uint64_t *)((char *)v285 - (v297 & 0xFFFFFFFFFFFFFFF8) - 8) < v294
        && &v293[v288 - (v297 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v285)
      {
        goto LABEL_2198;
      }
      v298 = (v297 >> 3) + 1;
      v299 = 8 * (v298 & 0x3FFFFFFFFFFFFFFCLL);
      v294 = (uint64_t *)((char *)v294 - v299);
      v300 = &v285[v299 / 0xFFFFFFFFFFFFFFF8];
      v301 = v285 - 2;
      v302 = &v293[8 * v289 - 16];
      v303 = v298 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v305 = *((_OWORD *)v301 - 1);
        v304 = *(_OWORD *)v301;
        *((_OWORD *)v301 - 1) = 0uLL;
        *(_OWORD *)v301 = 0uLL;
        *((_OWORD *)v302 - 1) = v305;
        *(_OWORD *)v302 = v304;
        v301 -= 4;
        v302 -= 32;
        v303 -= 4;
      }
      while (v303);
      v285 = v300;
      if (v298 != (v298 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2198:
        do
        {
          v306 = *--v285;
          *v285 = 0;
          *--v294 = v306;
        }
        while (v285 != v287);
      }
      v285 = *a1;
      v307 = a1[1];
      *a1 = v294;
      a1[1] = (uint64_t *)v286;
      a1[2] = v295;
      while (v307 != v285)
      {
        v309 = *--v307;
        v308 = v309;
        *v307 = 0;
        if (v309)
          (*(void (**)(uint64_t))(*(_QWORD *)v308 + 8))(v308);
      }
      goto LABEL_285;
    }
  }
  *a1 = v294;
  a1[1] = (uint64_t *)v286;
  a1[2] = v295;
LABEL_285:
  if (v285)
    operator delete(v285);
LABEL_287:
  a1[1] = (uint64_t *)v286;
  v310 = operator new();
  v311 = v310;
  *(_BYTE *)(v310 + 31) = 7;
  *(_QWORD *)v310 = off_1E0E17360;
  *(_QWORD *)(v310 + 8) = 0x78616D74666F73;
  v313 = a1[1];
  v312 = (unint64_t)a1[2];
  if ((unint64_t)v313 < v312)
  {
    *v313 = v310;
    v314 = (uint64_t)(v313 + 1);
    goto LABEL_313;
  }
  v315 = *a1;
  v316 = (char *)v313 - (char *)*a1;
  v317 = v316 >> 3;
  v318 = (v316 >> 3) + 1;
  if (v318 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v319 = v312 - (_QWORD)v315;
  if (v319 >> 2 > v318)
    v318 = v319 >> 2;
  if ((unint64_t)v319 >= 0x7FFFFFFFFFFFFFF8)
    v320 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v320 = v318;
  if (v320)
  {
    if (v320 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v321 = (char *)operator new(8 * v320);
    v322 = (uint64_t *)&v321[8 * v317];
    v323 = (uint64_t *)&v321[8 * v320];
    *v322 = v311;
    v314 = (uint64_t)(v322 + 1);
    v324 = (char *)((char *)v313 - (char *)v315);
    if (v313 != v315)
      goto LABEL_298;
  }
  else
  {
    v321 = 0;
    v322 = (uint64_t *)(8 * v317);
    v323 = 0;
    *(_QWORD *)(8 * v317) = v311;
    v314 = 8 * v317 + 8;
    v324 = (char *)((char *)v313 - (char *)v315);
    if (v313 != v315)
    {
LABEL_298:
      v325 = (unint64_t)(v324 - 8);
      if (v325 < 0x78
        || (uint64_t *)((char *)v313 - (v325 & 0xFFFFFFFFFFFFFFF8) - 8) < v322
        && &v321[v316 - (v325 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v313)
      {
        goto LABEL_2199;
      }
      v326 = (v325 >> 3) + 1;
      v327 = 8 * (v326 & 0x3FFFFFFFFFFFFFFCLL);
      v322 = (uint64_t *)((char *)v322 - v327);
      v328 = &v313[v327 / 0xFFFFFFFFFFFFFFF8];
      v329 = v313 - 2;
      v330 = &v321[8 * v317 - 16];
      v331 = v326 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v333 = *((_OWORD *)v329 - 1);
        v332 = *(_OWORD *)v329;
        *((_OWORD *)v329 - 1) = 0uLL;
        *(_OWORD *)v329 = 0uLL;
        *((_OWORD *)v330 - 1) = v333;
        *(_OWORD *)v330 = v332;
        v329 -= 4;
        v330 -= 32;
        v331 -= 4;
      }
      while (v331);
      v313 = v328;
      if (v326 != (v326 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2199:
        do
        {
          v334 = *--v313;
          *v313 = 0;
          *--v322 = v334;
        }
        while (v313 != v315);
      }
      v313 = *a1;
      v335 = a1[1];
      *a1 = v322;
      a1[1] = (uint64_t *)v314;
      a1[2] = v323;
      while (v335 != v313)
      {
        v337 = *--v335;
        v336 = v337;
        *v335 = 0;
        if (v337)
          (*(void (**)(uint64_t))(*(_QWORD *)v336 + 8))(v336);
      }
      goto LABEL_311;
    }
  }
  *a1 = v322;
  a1[1] = (uint64_t *)v314;
  a1[2] = v323;
LABEL_311:
  if (v313)
    operator delete(v313);
LABEL_313:
  a1[1] = (uint64_t *)v314;
  v338 = operator new();
  v339 = v338;
  *(_QWORD *)(v338 + 8) = 0x73756C7074666F73;
  *(_QWORD *)(v338 + 16) = 0;
  *(_BYTE *)(v338 + 31) = 8;
  *(_QWORD *)v338 = off_1E0E17388;
  v341 = a1[1];
  v340 = (unint64_t)a1[2];
  if ((unint64_t)v341 < v340)
  {
    *v341 = v338;
    v342 = (uint64_t)(v341 + 1);
    goto LABEL_339;
  }
  v343 = *a1;
  v344 = (char *)v341 - (char *)*a1;
  v345 = v344 >> 3;
  v346 = (v344 >> 3) + 1;
  if (v346 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v347 = v340 - (_QWORD)v343;
  if (v347 >> 2 > v346)
    v346 = v347 >> 2;
  if ((unint64_t)v347 >= 0x7FFFFFFFFFFFFFF8)
    v348 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v348 = v346;
  if (v348)
  {
    if (v348 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v349 = (char *)operator new(8 * v348);
    v350 = (uint64_t *)&v349[8 * v345];
    v351 = (uint64_t *)&v349[8 * v348];
    *v350 = v339;
    v342 = (uint64_t)(v350 + 1);
    v352 = (char *)((char *)v341 - (char *)v343);
    if (v341 != v343)
      goto LABEL_324;
  }
  else
  {
    v349 = 0;
    v350 = (uint64_t *)(8 * v345);
    v351 = 0;
    *(_QWORD *)(8 * v345) = v339;
    v342 = 8 * v345 + 8;
    v352 = (char *)((char *)v341 - (char *)v343);
    if (v341 != v343)
    {
LABEL_324:
      v353 = (unint64_t)(v352 - 8);
      if (v353 < 0x78
        || (uint64_t *)((char *)v341 - (v353 & 0xFFFFFFFFFFFFFFF8) - 8) < v350
        && &v349[v344 - (v353 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v341)
      {
        goto LABEL_2200;
      }
      v354 = (v353 >> 3) + 1;
      v355 = 8 * (v354 & 0x3FFFFFFFFFFFFFFCLL);
      v350 = (uint64_t *)((char *)v350 - v355);
      v356 = &v341[v355 / 0xFFFFFFFFFFFFFFF8];
      v357 = v341 - 2;
      v358 = &v349[8 * v345 - 16];
      v359 = v354 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v361 = *((_OWORD *)v357 - 1);
        v360 = *(_OWORD *)v357;
        *((_OWORD *)v357 - 1) = 0uLL;
        *(_OWORD *)v357 = 0uLL;
        *((_OWORD *)v358 - 1) = v361;
        *(_OWORD *)v358 = v360;
        v357 -= 4;
        v358 -= 32;
        v359 -= 4;
      }
      while (v359);
      v341 = v356;
      if (v354 != (v354 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2200:
        do
        {
          v362 = *--v341;
          *v341 = 0;
          *--v350 = v362;
        }
        while (v341 != v343);
      }
      v341 = *a1;
      v363 = a1[1];
      *a1 = v350;
      a1[1] = (uint64_t *)v342;
      a1[2] = v351;
      while (v363 != v341)
      {
        v365 = *--v363;
        v364 = v365;
        *v363 = 0;
        if (v365)
          (*(void (**)(uint64_t))(*(_QWORD *)v364 + 8))(v364);
      }
      goto LABEL_337;
    }
  }
  *a1 = v350;
  a1[1] = (uint64_t *)v342;
  a1[2] = v351;
LABEL_337:
  if (v341)
    operator delete(v341);
LABEL_339:
  a1[1] = (uint64_t *)v342;
  v366 = operator new();
  v367 = v366;
  strcpy((char *)(v366 + 8), "softplus_parametric");
  *(_BYTE *)(v366 + 31) = 19;
  *(_QWORD *)v366 = off_1E0E173B0;
  v369 = a1[1];
  v368 = (unint64_t)a1[2];
  if ((unint64_t)v369 < v368)
  {
    *v369 = v366;
    v370 = (uint64_t)(v369 + 1);
    goto LABEL_365;
  }
  v371 = *a1;
  v372 = (char *)v369 - (char *)*a1;
  v373 = v372 >> 3;
  v374 = (v372 >> 3) + 1;
  if (v374 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v375 = v368 - (_QWORD)v371;
  if (v375 >> 2 > v374)
    v374 = v375 >> 2;
  if ((unint64_t)v375 >= 0x7FFFFFFFFFFFFFF8)
    v376 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v376 = v374;
  if (v376)
  {
    if (v376 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v377 = (char *)operator new(8 * v376);
    v378 = (uint64_t *)&v377[8 * v373];
    v379 = (uint64_t *)&v377[8 * v376];
    *v378 = v367;
    v370 = (uint64_t)(v378 + 1);
    v380 = (char *)((char *)v369 - (char *)v371);
    if (v369 != v371)
      goto LABEL_350;
  }
  else
  {
    v377 = 0;
    v378 = (uint64_t *)(8 * v373);
    v379 = 0;
    *(_QWORD *)(8 * v373) = v367;
    v370 = 8 * v373 + 8;
    v380 = (char *)((char *)v369 - (char *)v371);
    if (v369 != v371)
    {
LABEL_350:
      v381 = (unint64_t)(v380 - 8);
      if (v381 < 0x78
        || (uint64_t *)((char *)v369 - (v381 & 0xFFFFFFFFFFFFFFF8) - 8) < v378
        && &v377[v372 - (v381 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v369)
      {
        goto LABEL_2201;
      }
      v382 = (v381 >> 3) + 1;
      v383 = 8 * (v382 & 0x3FFFFFFFFFFFFFFCLL);
      v378 = (uint64_t *)((char *)v378 - v383);
      v384 = &v369[v383 / 0xFFFFFFFFFFFFFFF8];
      v385 = v369 - 2;
      v386 = &v377[8 * v373 - 16];
      v387 = v382 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v389 = *((_OWORD *)v385 - 1);
        v388 = *(_OWORD *)v385;
        *((_OWORD *)v385 - 1) = 0uLL;
        *(_OWORD *)v385 = 0uLL;
        *((_OWORD *)v386 - 1) = v389;
        *(_OWORD *)v386 = v388;
        v385 -= 4;
        v386 -= 32;
        v387 -= 4;
      }
      while (v387);
      v369 = v384;
      if (v382 != (v382 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2201:
        do
        {
          v390 = *--v369;
          *v369 = 0;
          *--v378 = v390;
        }
        while (v369 != v371);
      }
      v369 = *a1;
      v391 = a1[1];
      *a1 = v378;
      a1[1] = (uint64_t *)v370;
      a1[2] = v379;
      while (v391 != v369)
      {
        v393 = *--v391;
        v392 = v393;
        *v391 = 0;
        if (v393)
          (*(void (**)(uint64_t))(*(_QWORD *)v392 + 8))(v392);
      }
      goto LABEL_363;
    }
  }
  *a1 = v378;
  a1[1] = (uint64_t *)v370;
  a1[2] = v379;
LABEL_363:
  if (v369)
    operator delete(v369);
LABEL_365:
  a1[1] = (uint64_t *)v370;
  v394 = operator new();
  v395 = v394;
  *(_QWORD *)(v394 + 8) = 0x6E67697374666F73;
  *(_QWORD *)(v394 + 16) = 0;
  *(_BYTE *)(v394 + 31) = 8;
  *(_QWORD *)v394 = off_1E0E173D8;
  v397 = a1[1];
  v396 = (unint64_t)a1[2];
  if ((unint64_t)v397 < v396)
  {
    *v397 = v394;
    v398 = (uint64_t)(v397 + 1);
    goto LABEL_391;
  }
  v399 = *a1;
  v400 = (char *)v397 - (char *)*a1;
  v401 = v400 >> 3;
  v402 = (v400 >> 3) + 1;
  if (v402 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v403 = v396 - (_QWORD)v399;
  if (v403 >> 2 > v402)
    v402 = v403 >> 2;
  if ((unint64_t)v403 >= 0x7FFFFFFFFFFFFFF8)
    v404 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v404 = v402;
  if (v404)
  {
    if (v404 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v405 = (char *)operator new(8 * v404);
    v406 = (uint64_t *)&v405[8 * v401];
    v407 = (uint64_t *)&v405[8 * v404];
    *v406 = v395;
    v398 = (uint64_t)(v406 + 1);
    v408 = (char *)((char *)v397 - (char *)v399);
    if (v397 != v399)
      goto LABEL_376;
  }
  else
  {
    v405 = 0;
    v406 = (uint64_t *)(8 * v401);
    v407 = 0;
    *(_QWORD *)(8 * v401) = v395;
    v398 = 8 * v401 + 8;
    v408 = (char *)((char *)v397 - (char *)v399);
    if (v397 != v399)
    {
LABEL_376:
      v409 = (unint64_t)(v408 - 8);
      if (v409 < 0x78
        || (uint64_t *)((char *)v397 - (v409 & 0xFFFFFFFFFFFFFFF8) - 8) < v406
        && &v405[v400 - (v409 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v397)
      {
        goto LABEL_2202;
      }
      v410 = (v409 >> 3) + 1;
      v411 = 8 * (v410 & 0x3FFFFFFFFFFFFFFCLL);
      v406 = (uint64_t *)((char *)v406 - v411);
      v412 = &v397[v411 / 0xFFFFFFFFFFFFFFF8];
      v413 = v397 - 2;
      v414 = &v405[8 * v401 - 16];
      v415 = v410 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v417 = *((_OWORD *)v413 - 1);
        v416 = *(_OWORD *)v413;
        *((_OWORD *)v413 - 1) = 0uLL;
        *(_OWORD *)v413 = 0uLL;
        *((_OWORD *)v414 - 1) = v417;
        *(_OWORD *)v414 = v416;
        v413 -= 4;
        v414 -= 32;
        v415 -= 4;
      }
      while (v415);
      v397 = v412;
      if (v410 != (v410 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2202:
        do
        {
          v418 = *--v397;
          *v397 = 0;
          *--v406 = v418;
        }
        while (v397 != v399);
      }
      v397 = *a1;
      v419 = a1[1];
      *a1 = v406;
      a1[1] = (uint64_t *)v398;
      a1[2] = v407;
      while (v419 != v397)
      {
        v421 = *--v419;
        v420 = v421;
        *v419 = 0;
        if (v421)
          (*(void (**)(uint64_t))(*(_QWORD *)v420 + 8))(v420);
      }
      goto LABEL_389;
    }
  }
  *a1 = v406;
  a1[1] = (uint64_t *)v398;
  a1[2] = v407;
LABEL_389:
  if (v397)
    operator delete(v397);
LABEL_391:
  a1[1] = (uint64_t *)v398;
  v422 = operator new();
  v423 = v422;
  strcpy((char *)(v422 + 8), "thresholded_relu");
  *(_BYTE *)(v422 + 31) = 16;
  *(_QWORD *)v422 = off_1E0E17400;
  v425 = a1[1];
  v424 = (unint64_t)a1[2];
  if ((unint64_t)v425 < v424)
  {
    *v425 = v422;
    v426 = (uint64_t)(v425 + 1);
    goto LABEL_417;
  }
  v427 = *a1;
  v428 = (char *)v425 - (char *)*a1;
  v429 = v428 >> 3;
  v430 = (v428 >> 3) + 1;
  if (v430 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v431 = v424 - (_QWORD)v427;
  if (v431 >> 2 > v430)
    v430 = v431 >> 2;
  if ((unint64_t)v431 >= 0x7FFFFFFFFFFFFFF8)
    v432 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v432 = v430;
  if (v432)
  {
    if (v432 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v433 = (char *)operator new(8 * v432);
    v434 = (uint64_t *)&v433[8 * v429];
    v435 = (uint64_t *)&v433[8 * v432];
    *v434 = v423;
    v426 = (uint64_t)(v434 + 1);
    v436 = (char *)((char *)v425 - (char *)v427);
    if (v425 != v427)
      goto LABEL_402;
  }
  else
  {
    v433 = 0;
    v434 = (uint64_t *)(8 * v429);
    v435 = 0;
    *(_QWORD *)(8 * v429) = v423;
    v426 = 8 * v429 + 8;
    v436 = (char *)((char *)v425 - (char *)v427);
    if (v425 != v427)
    {
LABEL_402:
      v437 = (unint64_t)(v436 - 8);
      if (v437 < 0x78
        || (uint64_t *)((char *)v425 - (v437 & 0xFFFFFFFFFFFFFFF8) - 8) < v434
        && &v433[v428 - (v437 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v425)
      {
        goto LABEL_2203;
      }
      v438 = (v437 >> 3) + 1;
      v439 = 8 * (v438 & 0x3FFFFFFFFFFFFFFCLL);
      v434 = (uint64_t *)((char *)v434 - v439);
      v440 = &v425[v439 / 0xFFFFFFFFFFFFFFF8];
      v441 = v425 - 2;
      v442 = &v433[8 * v429 - 16];
      v443 = v438 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v445 = *((_OWORD *)v441 - 1);
        v444 = *(_OWORD *)v441;
        *((_OWORD *)v441 - 1) = 0uLL;
        *(_OWORD *)v441 = 0uLL;
        *((_OWORD *)v442 - 1) = v445;
        *(_OWORD *)v442 = v444;
        v441 -= 4;
        v442 -= 32;
        v443 -= 4;
      }
      while (v443);
      v425 = v440;
      if (v438 != (v438 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2203:
        do
        {
          v446 = *--v425;
          *v425 = 0;
          *--v434 = v446;
        }
        while (v425 != v427);
      }
      v425 = *a1;
      v447 = a1[1];
      *a1 = v434;
      a1[1] = (uint64_t *)v426;
      a1[2] = v435;
      while (v447 != v425)
      {
        v449 = *--v447;
        v448 = v449;
        *v447 = 0;
        if (v449)
          (*(void (**)(uint64_t))(*(_QWORD *)v448 + 8))(v448);
      }
      goto LABEL_415;
    }
  }
  *a1 = v434;
  a1[1] = (uint64_t *)v426;
  a1[2] = v435;
LABEL_415:
  if (v425)
    operator delete(v425);
LABEL_417:
  a1[1] = (uint64_t *)v426;
  v450 = operator new();
  v451 = v450;
  *(_BYTE *)(v450 + 31) = 3;
  *(_QWORD *)v450 = off_1E0E17428;
  *(_QWORD *)(v450 + 8) = 6579297;
  v453 = a1[1];
  v452 = (unint64_t)a1[2];
  if ((unint64_t)v453 < v452)
  {
    *v453 = v450;
    v454 = (uint64_t)(v453 + 1);
    goto LABEL_443;
  }
  v455 = *a1;
  v456 = (char *)v453 - (char *)*a1;
  v457 = v456 >> 3;
  v458 = (v456 >> 3) + 1;
  if (v458 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v459 = v452 - (_QWORD)v455;
  if (v459 >> 2 > v458)
    v458 = v459 >> 2;
  if ((unint64_t)v459 >= 0x7FFFFFFFFFFFFFF8)
    v460 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v460 = v458;
  if (v460)
  {
    if (v460 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v461 = (char *)operator new(8 * v460);
    v462 = (uint64_t *)&v461[8 * v457];
    v463 = (uint64_t *)&v461[8 * v460];
    *v462 = v451;
    v454 = (uint64_t)(v462 + 1);
    v464 = (char *)((char *)v453 - (char *)v455);
    if (v453 != v455)
      goto LABEL_428;
  }
  else
  {
    v461 = 0;
    v462 = (uint64_t *)(8 * v457);
    v463 = 0;
    *(_QWORD *)(8 * v457) = v451;
    v454 = 8 * v457 + 8;
    v464 = (char *)((char *)v453 - (char *)v455);
    if (v453 != v455)
    {
LABEL_428:
      v465 = (unint64_t)(v464 - 8);
      if (v465 < 0x78
        || (uint64_t *)((char *)v453 - (v465 & 0xFFFFFFFFFFFFFFF8) - 8) < v462
        && &v461[v456 - (v465 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v453)
      {
        goto LABEL_2204;
      }
      v466 = (v465 >> 3) + 1;
      v467 = 8 * (v466 & 0x3FFFFFFFFFFFFFFCLL);
      v462 = (uint64_t *)((char *)v462 - v467);
      v468 = &v453[v467 / 0xFFFFFFFFFFFFFFF8];
      v469 = v453 - 2;
      v470 = &v461[8 * v457 - 16];
      v471 = v466 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v473 = *((_OWORD *)v469 - 1);
        v472 = *(_OWORD *)v469;
        *((_OWORD *)v469 - 1) = 0uLL;
        *(_OWORD *)v469 = 0uLL;
        *((_OWORD *)v470 - 1) = v473;
        *(_OWORD *)v470 = v472;
        v469 -= 4;
        v470 -= 32;
        v471 -= 4;
      }
      while (v471);
      v453 = v468;
      if (v466 != (v466 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2204:
        do
        {
          v474 = *--v453;
          *v453 = 0;
          *--v462 = v474;
        }
        while (v453 != v455);
      }
      v453 = *a1;
      v475 = a1[1];
      *a1 = v462;
      a1[1] = (uint64_t *)v454;
      a1[2] = v463;
      while (v475 != v453)
      {
        v477 = *--v475;
        v476 = v477;
        *v475 = 0;
        if (v477)
          (*(void (**)(uint64_t))(*(_QWORD *)v476 + 8))(v476);
      }
      goto LABEL_441;
    }
  }
  *a1 = v462;
  a1[1] = (uint64_t *)v454;
  a1[2] = v463;
LABEL_441:
  if (v453)
    operator delete(v453);
LABEL_443:
  a1[1] = (uint64_t *)v454;
  v478 = operator new();
  v479 = v478;
  *(_BYTE *)(v478 + 31) = 3;
  *(_QWORD *)v478 = off_1E0E17450;
  *(_QWORD *)(v478 + 8) = 6452595;
  v481 = a1[1];
  v480 = (unint64_t)a1[2];
  if ((unint64_t)v481 < v480)
  {
    *v481 = v478;
    v482 = (uint64_t)(v481 + 1);
    goto LABEL_469;
  }
  v483 = *a1;
  v484 = (char *)v481 - (char *)*a1;
  v485 = v484 >> 3;
  v486 = (v484 >> 3) + 1;
  if (v486 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v487 = v480 - (_QWORD)v483;
  if (v487 >> 2 > v486)
    v486 = v487 >> 2;
  if ((unint64_t)v487 >= 0x7FFFFFFFFFFFFFF8)
    v488 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v488 = v486;
  if (v488)
  {
    if (v488 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v489 = (char *)operator new(8 * v488);
    v490 = (uint64_t *)&v489[8 * v485];
    v491 = (uint64_t *)&v489[8 * v488];
    *v490 = v479;
    v482 = (uint64_t)(v490 + 1);
    v492 = (char *)((char *)v481 - (char *)v483);
    if (v481 != v483)
      goto LABEL_454;
  }
  else
  {
    v489 = 0;
    v490 = (uint64_t *)(8 * v485);
    v491 = 0;
    *(_QWORD *)(8 * v485) = v479;
    v482 = 8 * v485 + 8;
    v492 = (char *)((char *)v481 - (char *)v483);
    if (v481 != v483)
    {
LABEL_454:
      v493 = (unint64_t)(v492 - 8);
      if (v493 < 0x78
        || (uint64_t *)((char *)v481 - (v493 & 0xFFFFFFFFFFFFFFF8) - 8) < v490
        && &v489[v484 - (v493 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v481)
      {
        goto LABEL_2205;
      }
      v494 = (v493 >> 3) + 1;
      v495 = 8 * (v494 & 0x3FFFFFFFFFFFFFFCLL);
      v490 = (uint64_t *)((char *)v490 - v495);
      v496 = &v481[v495 / 0xFFFFFFFFFFFFFFF8];
      v497 = v481 - 2;
      v498 = &v489[8 * v485 - 16];
      v499 = v494 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v501 = *((_OWORD *)v497 - 1);
        v500 = *(_OWORD *)v497;
        *((_OWORD *)v497 - 1) = 0uLL;
        *(_OWORD *)v497 = 0uLL;
        *((_OWORD *)v498 - 1) = v501;
        *(_OWORD *)v498 = v500;
        v497 -= 4;
        v498 -= 32;
        v499 -= 4;
      }
      while (v499);
      v481 = v496;
      if (v494 != (v494 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2205:
        do
        {
          v502 = *--v481;
          *v481 = 0;
          *--v490 = v502;
        }
        while (v481 != v483);
      }
      v481 = *a1;
      v503 = a1[1];
      *a1 = v490;
      a1[1] = (uint64_t *)v482;
      a1[2] = v491;
      while (v503 != v481)
      {
        v505 = *--v503;
        v504 = v505;
        *v503 = 0;
        if (v505)
          (*(void (**)(uint64_t))(*(_QWORD *)v504 + 8))(v504);
      }
      goto LABEL_467;
    }
  }
  *a1 = v490;
  a1[1] = (uint64_t *)v482;
  a1[2] = v491;
LABEL_467:
  if (v481)
    operator delete(v481);
LABEL_469:
  a1[1] = (uint64_t *)v482;
  v506 = operator new();
  v507 = v506;
  *(_BYTE *)(v506 + 31) = 5;
  *(_QWORD *)v506 = off_1E0E17478;
  *(_QWORD *)(v506 + 8) = 0x6C61757165;
  v509 = a1[1];
  v508 = (unint64_t)a1[2];
  if ((unint64_t)v509 < v508)
  {
    *v509 = v506;
    v510 = (uint64_t)(v509 + 1);
    goto LABEL_495;
  }
  v511 = *a1;
  v512 = (char *)v509 - (char *)*a1;
  v513 = v512 >> 3;
  v514 = (v512 >> 3) + 1;
  if (v514 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v515 = v508 - (_QWORD)v511;
  if (v515 >> 2 > v514)
    v514 = v515 >> 2;
  if ((unint64_t)v515 >= 0x7FFFFFFFFFFFFFF8)
    v516 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v516 = v514;
  if (v516)
  {
    if (v516 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v517 = (char *)operator new(8 * v516);
    v518 = (uint64_t *)&v517[8 * v513];
    v519 = (uint64_t *)&v517[8 * v516];
    *v518 = v507;
    v510 = (uint64_t)(v518 + 1);
    v520 = (char *)((char *)v509 - (char *)v511);
    if (v509 != v511)
      goto LABEL_480;
  }
  else
  {
    v517 = 0;
    v518 = (uint64_t *)(8 * v513);
    v519 = 0;
    *(_QWORD *)(8 * v513) = v507;
    v510 = 8 * v513 + 8;
    v520 = (char *)((char *)v509 - (char *)v511);
    if (v509 != v511)
    {
LABEL_480:
      v521 = (unint64_t)(v520 - 8);
      if (v521 < 0x78
        || (uint64_t *)((char *)v509 - (v521 & 0xFFFFFFFFFFFFFFF8) - 8) < v518
        && &v517[v512 - (v521 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v509)
      {
        goto LABEL_2206;
      }
      v522 = (v521 >> 3) + 1;
      v523 = 8 * (v522 & 0x3FFFFFFFFFFFFFFCLL);
      v518 = (uint64_t *)((char *)v518 - v523);
      v524 = &v509[v523 / 0xFFFFFFFFFFFFFFF8];
      v525 = v509 - 2;
      v526 = &v517[8 * v513 - 16];
      v527 = v522 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v529 = *((_OWORD *)v525 - 1);
        v528 = *(_OWORD *)v525;
        *((_OWORD *)v525 - 1) = 0uLL;
        *(_OWORD *)v525 = 0uLL;
        *((_OWORD *)v526 - 1) = v529;
        *(_OWORD *)v526 = v528;
        v525 -= 4;
        v526 -= 32;
        v527 -= 4;
      }
      while (v527);
      v509 = v524;
      if (v522 != (v522 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2206:
        do
        {
          v530 = *--v509;
          *v509 = 0;
          *--v518 = v530;
        }
        while (v509 != v511);
      }
      v509 = *a1;
      v531 = a1[1];
      *a1 = v518;
      a1[1] = (uint64_t *)v510;
      a1[2] = v519;
      while (v531 != v509)
      {
        v533 = *--v531;
        v532 = v533;
        *v531 = 0;
        if (v533)
          (*(void (**)(uint64_t))(*(_QWORD *)v532 + 8))(v532);
      }
      goto LABEL_493;
    }
  }
  *a1 = v518;
  a1[1] = (uint64_t *)v510;
  a1[2] = v519;
LABEL_493:
  if (v509)
    operator delete(v509);
LABEL_495:
  a1[1] = (uint64_t *)v510;
  v534 = operator new();
  v535 = v534;
  *(_BYTE *)(v534 + 31) = 3;
  *(_QWORD *)v534 = off_1E0E174A0;
  *(_QWORD *)(v534 + 8) = 7107949;
  v537 = a1[1];
  v536 = (unint64_t)a1[2];
  if ((unint64_t)v537 < v536)
  {
    *v537 = v534;
    v538 = (uint64_t)(v537 + 1);
    goto LABEL_521;
  }
  v539 = *a1;
  v540 = (char *)v537 - (char *)*a1;
  v541 = v540 >> 3;
  v542 = (v540 >> 3) + 1;
  if (v542 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v543 = v536 - (_QWORD)v539;
  if (v543 >> 2 > v542)
    v542 = v543 >> 2;
  if ((unint64_t)v543 >= 0x7FFFFFFFFFFFFFF8)
    v544 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v544 = v542;
  if (v544)
  {
    if (v544 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v545 = (char *)operator new(8 * v544);
    v546 = (uint64_t *)&v545[8 * v541];
    v547 = (uint64_t *)&v545[8 * v544];
    *v546 = v535;
    v538 = (uint64_t)(v546 + 1);
    v548 = (char *)((char *)v537 - (char *)v539);
    if (v537 != v539)
      goto LABEL_506;
  }
  else
  {
    v545 = 0;
    v546 = (uint64_t *)(8 * v541);
    v547 = 0;
    *(_QWORD *)(8 * v541) = v535;
    v538 = 8 * v541 + 8;
    v548 = (char *)((char *)v537 - (char *)v539);
    if (v537 != v539)
    {
LABEL_506:
      v549 = (unint64_t)(v548 - 8);
      if (v549 < 0x78
        || (uint64_t *)((char *)v537 - (v549 & 0xFFFFFFFFFFFFFFF8) - 8) < v546
        && &v545[v540 - (v549 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v537)
      {
        goto LABEL_2207;
      }
      v550 = (v549 >> 3) + 1;
      v551 = 8 * (v550 & 0x3FFFFFFFFFFFFFFCLL);
      v546 = (uint64_t *)((char *)v546 - v551);
      v552 = &v537[v551 / 0xFFFFFFFFFFFFFFF8];
      v553 = v537 - 2;
      v554 = &v545[8 * v541 - 16];
      v555 = v550 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v557 = *((_OWORD *)v553 - 1);
        v556 = *(_OWORD *)v553;
        *((_OWORD *)v553 - 1) = 0uLL;
        *(_OWORD *)v553 = 0uLL;
        *((_OWORD *)v554 - 1) = v557;
        *(_OWORD *)v554 = v556;
        v553 -= 4;
        v554 -= 32;
        v555 -= 4;
      }
      while (v555);
      v537 = v552;
      if (v550 != (v550 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2207:
        do
        {
          v558 = *--v537;
          *v537 = 0;
          *--v546 = v558;
        }
        while (v537 != v539);
      }
      v537 = *a1;
      v559 = a1[1];
      *a1 = v546;
      a1[1] = (uint64_t *)v538;
      a1[2] = v547;
      while (v559 != v537)
      {
        v561 = *--v559;
        v560 = v561;
        *v559 = 0;
        if (v561)
          (*(void (**)(uint64_t))(*(_QWORD *)v560 + 8))(v560);
      }
      goto LABEL_519;
    }
  }
  *a1 = v546;
  a1[1] = (uint64_t *)v538;
  a1[2] = v547;
LABEL_519:
  if (v537)
    operator delete(v537);
LABEL_521:
  a1[1] = (uint64_t *)v538;
  v562 = operator new();
  v563 = v562;
  *(_BYTE *)(v562 + 31) = 3;
  *(_QWORD *)v562 = off_1E0E174C8;
  *(_QWORD *)(v562 + 8) = 7827312;
  v565 = a1[1];
  v564 = (unint64_t)a1[2];
  if ((unint64_t)v565 < v564)
  {
    *v565 = v562;
    v566 = (uint64_t)(v565 + 1);
    goto LABEL_547;
  }
  v567 = *a1;
  v568 = (char *)v565 - (char *)*a1;
  v569 = v568 >> 3;
  v570 = (v568 >> 3) + 1;
  if (v570 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v571 = v564 - (_QWORD)v567;
  if (v571 >> 2 > v570)
    v570 = v571 >> 2;
  if ((unint64_t)v571 >= 0x7FFFFFFFFFFFFFF8)
    v572 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v572 = v570;
  if (v572)
  {
    if (v572 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v573 = (char *)operator new(8 * v572);
    v574 = (uint64_t *)&v573[8 * v569];
    v575 = (uint64_t *)&v573[8 * v572];
    *v574 = v563;
    v566 = (uint64_t)(v574 + 1);
    v576 = (char *)((char *)v565 - (char *)v567);
    if (v565 != v567)
      goto LABEL_532;
  }
  else
  {
    v573 = 0;
    v574 = (uint64_t *)(8 * v569);
    v575 = 0;
    *(_QWORD *)(8 * v569) = v563;
    v566 = 8 * v569 + 8;
    v576 = (char *)((char *)v565 - (char *)v567);
    if (v565 != v567)
    {
LABEL_532:
      v577 = (unint64_t)(v576 - 8);
      if (v577 < 0x78
        || (uint64_t *)((char *)v565 - (v577 & 0xFFFFFFFFFFFFFFF8) - 8) < v574
        && &v573[v568 - (v577 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v565)
      {
        goto LABEL_2208;
      }
      v578 = (v577 >> 3) + 1;
      v579 = 8 * (v578 & 0x3FFFFFFFFFFFFFFCLL);
      v574 = (uint64_t *)((char *)v574 - v579);
      v580 = &v565[v579 / 0xFFFFFFFFFFFFFFF8];
      v581 = v565 - 2;
      v582 = &v573[8 * v569 - 16];
      v583 = v578 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v585 = *((_OWORD *)v581 - 1);
        v584 = *(_OWORD *)v581;
        *((_OWORD *)v581 - 1) = 0uLL;
        *(_OWORD *)v581 = 0uLL;
        *((_OWORD *)v582 - 1) = v585;
        *(_OWORD *)v582 = v584;
        v581 -= 4;
        v582 -= 32;
        v583 -= 4;
      }
      while (v583);
      v565 = v580;
      if (v578 != (v578 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2208:
        do
        {
          v586 = *--v565;
          *v565 = 0;
          *--v574 = v586;
        }
        while (v565 != v567);
      }
      v565 = *a1;
      v587 = a1[1];
      *a1 = v574;
      a1[1] = (uint64_t *)v566;
      a1[2] = v575;
      while (v587 != v565)
      {
        v589 = *--v587;
        v588 = v589;
        *v587 = 0;
        if (v589)
          (*(void (**)(uint64_t))(*(_QWORD *)v588 + 8))(v588);
      }
      goto LABEL_545;
    }
  }
  *a1 = v574;
  a1[1] = (uint64_t *)v566;
  a1[2] = v575;
LABEL_545:
  if (v565)
    operator delete(v565);
LABEL_547:
  a1[1] = (uint64_t *)v566;
  v590 = operator new();
  v591 = v590;
  *(_BYTE *)(v590 + 31) = 7;
  *(_QWORD *)v590 = off_1E0E174F0;
  *(_QWORD *)(v590 + 8) = 0x6D756D696E696DLL;
  v593 = a1[1];
  v592 = (unint64_t)a1[2];
  if ((unint64_t)v593 < v592)
  {
    *v593 = v590;
    v594 = (uint64_t)(v593 + 1);
    goto LABEL_573;
  }
  v595 = *a1;
  v596 = (char *)v593 - (char *)*a1;
  v597 = v596 >> 3;
  v598 = (v596 >> 3) + 1;
  if (v598 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v599 = v592 - (_QWORD)v595;
  if (v599 >> 2 > v598)
    v598 = v599 >> 2;
  if ((unint64_t)v599 >= 0x7FFFFFFFFFFFFFF8)
    v600 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v600 = v598;
  if (v600)
  {
    if (v600 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v601 = (char *)operator new(8 * v600);
    v602 = (uint64_t *)&v601[8 * v597];
    v603 = (uint64_t *)&v601[8 * v600];
    *v602 = v591;
    v594 = (uint64_t)(v602 + 1);
    v604 = (char *)((char *)v593 - (char *)v595);
    if (v593 != v595)
      goto LABEL_558;
  }
  else
  {
    v601 = 0;
    v602 = (uint64_t *)(8 * v597);
    v603 = 0;
    *(_QWORD *)(8 * v597) = v591;
    v594 = 8 * v597 + 8;
    v604 = (char *)((char *)v593 - (char *)v595);
    if (v593 != v595)
    {
LABEL_558:
      v605 = (unint64_t)(v604 - 8);
      if (v605 < 0x78
        || (uint64_t *)((char *)v593 - (v605 & 0xFFFFFFFFFFFFFFF8) - 8) < v602
        && &v601[v596 - (v605 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v593)
      {
        goto LABEL_2209;
      }
      v606 = (v605 >> 3) + 1;
      v607 = 8 * (v606 & 0x3FFFFFFFFFFFFFFCLL);
      v602 = (uint64_t *)((char *)v602 - v607);
      v608 = &v593[v607 / 0xFFFFFFFFFFFFFFF8];
      v609 = v593 - 2;
      v610 = &v601[8 * v597 - 16];
      v611 = v606 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v613 = *((_OWORD *)v609 - 1);
        v612 = *(_OWORD *)v609;
        *((_OWORD *)v609 - 1) = 0uLL;
        *(_OWORD *)v609 = 0uLL;
        *((_OWORD *)v610 - 1) = v613;
        *(_OWORD *)v610 = v612;
        v609 -= 4;
        v610 -= 32;
        v611 -= 4;
      }
      while (v611);
      v593 = v608;
      if (v606 != (v606 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2209:
        do
        {
          v614 = *--v593;
          *v593 = 0;
          *--v602 = v614;
        }
        while (v593 != v595);
      }
      v593 = *a1;
      v615 = a1[1];
      *a1 = v602;
      a1[1] = (uint64_t *)v594;
      a1[2] = v603;
      while (v615 != v593)
      {
        v617 = *--v615;
        v616 = v617;
        *v615 = 0;
        if (v617)
          (*(void (**)(uint64_t))(*(_QWORD *)v616 + 8))(v616);
      }
      goto LABEL_571;
    }
  }
  *a1 = v602;
  a1[1] = (uint64_t *)v594;
  a1[2] = v603;
LABEL_571:
  if (v593)
    operator delete(v593);
LABEL_573:
  a1[1] = (uint64_t *)v594;
  v618 = operator new();
  v619 = v618;
  *(_BYTE *)(v618 + 31) = 7;
  *(_QWORD *)v618 = off_1E0E17518;
  *(_QWORD *)(v618 + 8) = 0x6D756D6978616DLL;
  v621 = a1[1];
  v620 = (unint64_t)a1[2];
  if ((unint64_t)v621 < v620)
  {
    *v621 = v618;
    v622 = (uint64_t)(v621 + 1);
    goto LABEL_599;
  }
  v623 = *a1;
  v624 = (char *)v621 - (char *)*a1;
  v625 = v624 >> 3;
  v626 = (v624 >> 3) + 1;
  if (v626 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v627 = v620 - (_QWORD)v623;
  if (v627 >> 2 > v626)
    v626 = v627 >> 2;
  if ((unint64_t)v627 >= 0x7FFFFFFFFFFFFFF8)
    v628 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v628 = v626;
  if (v628)
  {
    if (v628 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v629 = (char *)operator new(8 * v628);
    v630 = (uint64_t *)&v629[8 * v625];
    v631 = (uint64_t *)&v629[8 * v628];
    *v630 = v619;
    v622 = (uint64_t)(v630 + 1);
    v632 = (char *)((char *)v621 - (char *)v623);
    if (v621 != v623)
      goto LABEL_584;
  }
  else
  {
    v629 = 0;
    v630 = (uint64_t *)(8 * v625);
    v631 = 0;
    *(_QWORD *)(8 * v625) = v619;
    v622 = 8 * v625 + 8;
    v632 = (char *)((char *)v621 - (char *)v623);
    if (v621 != v623)
    {
LABEL_584:
      v633 = (unint64_t)(v632 - 8);
      if (v633 < 0x78
        || (uint64_t *)((char *)v621 - (v633 & 0xFFFFFFFFFFFFFFF8) - 8) < v630
        && &v629[v624 - (v633 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v621)
      {
        goto LABEL_2210;
      }
      v634 = (v633 >> 3) + 1;
      v635 = 8 * (v634 & 0x3FFFFFFFFFFFFFFCLL);
      v630 = (uint64_t *)((char *)v630 - v635);
      v636 = &v621[v635 / 0xFFFFFFFFFFFFFFF8];
      v637 = v621 - 2;
      v638 = &v629[8 * v625 - 16];
      v639 = v634 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v641 = *((_OWORD *)v637 - 1);
        v640 = *(_OWORD *)v637;
        *((_OWORD *)v637 - 1) = 0uLL;
        *(_OWORD *)v637 = 0uLL;
        *((_OWORD *)v638 - 1) = v641;
        *(_OWORD *)v638 = v640;
        v637 -= 4;
        v638 -= 32;
        v639 -= 4;
      }
      while (v639);
      v621 = v636;
      if (v634 != (v634 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2210:
        do
        {
          v642 = *--v621;
          *v621 = 0;
          *--v630 = v642;
        }
        while (v621 != v623);
      }
      v621 = *a1;
      v643 = a1[1];
      *a1 = v630;
      a1[1] = (uint64_t *)v622;
      a1[2] = v631;
      while (v643 != v621)
      {
        v645 = *--v643;
        v644 = v645;
        *v643 = 0;
        if (v645)
          (*(void (**)(uint64_t))(*(_QWORD *)v644 + 8))(v644);
      }
      goto LABEL_597;
    }
  }
  *a1 = v630;
  a1[1] = (uint64_t *)v622;
  a1[2] = v631;
LABEL_597:
  if (v621)
    operator delete(v621);
LABEL_599:
  a1[1] = (uint64_t *)v622;
  v646 = operator new();
  v647 = v646;
  *(_BYTE *)(v646 + 31) = 3;
  *(_QWORD *)v646 = off_1E0E17540;
  *(_QWORD *)(v646 + 8) = 6582125;
  v649 = a1[1];
  v648 = (unint64_t)a1[2];
  if ((unint64_t)v649 < v648)
  {
    *v649 = v646;
    v650 = (uint64_t)(v649 + 1);
    goto LABEL_625;
  }
  v651 = *a1;
  v652 = (char *)v649 - (char *)*a1;
  v653 = v652 >> 3;
  v654 = (v652 >> 3) + 1;
  if (v654 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v655 = v648 - (_QWORD)v651;
  if (v655 >> 2 > v654)
    v654 = v655 >> 2;
  if ((unint64_t)v655 >= 0x7FFFFFFFFFFFFFF8)
    v656 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v656 = v654;
  if (v656)
  {
    if (v656 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v657 = (char *)operator new(8 * v656);
    v658 = (uint64_t *)&v657[8 * v653];
    v659 = (uint64_t *)&v657[8 * v656];
    *v658 = v647;
    v650 = (uint64_t)(v658 + 1);
    v660 = (char *)((char *)v649 - (char *)v651);
    if (v649 != v651)
      goto LABEL_610;
  }
  else
  {
    v657 = 0;
    v658 = (uint64_t *)(8 * v653);
    v659 = 0;
    *(_QWORD *)(8 * v653) = v647;
    v650 = 8 * v653 + 8;
    v660 = (char *)((char *)v649 - (char *)v651);
    if (v649 != v651)
    {
LABEL_610:
      v661 = (unint64_t)(v660 - 8);
      if (v661 < 0x78
        || (uint64_t *)((char *)v649 - (v661 & 0xFFFFFFFFFFFFFFF8) - 8) < v658
        && &v657[v652 - (v661 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v649)
      {
        goto LABEL_2211;
      }
      v662 = (v661 >> 3) + 1;
      v663 = 8 * (v662 & 0x3FFFFFFFFFFFFFFCLL);
      v658 = (uint64_t *)((char *)v658 - v663);
      v664 = &v649[v663 / 0xFFFFFFFFFFFFFFF8];
      v665 = v649 - 2;
      v666 = &v657[8 * v653 - 16];
      v667 = v662 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v669 = *((_OWORD *)v665 - 1);
        v668 = *(_OWORD *)v665;
        *((_OWORD *)v665 - 1) = 0uLL;
        *(_OWORD *)v665 = 0uLL;
        *((_OWORD *)v666 - 1) = v669;
        *(_OWORD *)v666 = v668;
        v665 -= 4;
        v666 -= 32;
        v667 -= 4;
      }
      while (v667);
      v649 = v664;
      if (v662 != (v662 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2211:
        do
        {
          v670 = *--v649;
          *v649 = 0;
          *--v658 = v670;
        }
        while (v649 != v651);
      }
      v649 = *a1;
      v671 = a1[1];
      *a1 = v658;
      a1[1] = (uint64_t *)v650;
      a1[2] = v659;
      while (v671 != v649)
      {
        v673 = *--v671;
        v672 = v673;
        *v671 = 0;
        if (v673)
          (*(void (**)(uint64_t))(*(_QWORD *)v672 + 8))(v672);
      }
      goto LABEL_623;
    }
  }
  *a1 = v658;
  a1[1] = (uint64_t *)v650;
  a1[2] = v659;
LABEL_623:
  if (v649)
    operator delete(v649);
LABEL_625:
  a1[1] = (uint64_t *)v650;
  v674 = operator new();
  v675 = v674;
  *(_QWORD *)(v674 + 8) = 0x7669645F6C616572;
  *(_QWORD *)(v674 + 16) = 0;
  *(_BYTE *)(v674 + 31) = 8;
  *(_QWORD *)v674 = off_1E0E17568;
  v677 = a1[1];
  v676 = (unint64_t)a1[2];
  if ((unint64_t)v677 < v676)
  {
    *v677 = v674;
    v678 = (uint64_t)(v677 + 1);
    goto LABEL_651;
  }
  v679 = *a1;
  v680 = (char *)v677 - (char *)*a1;
  v681 = v680 >> 3;
  v682 = (v680 >> 3) + 1;
  if (v682 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v683 = v676 - (_QWORD)v679;
  if (v683 >> 2 > v682)
    v682 = v683 >> 2;
  if ((unint64_t)v683 >= 0x7FFFFFFFFFFFFFF8)
    v684 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v684 = v682;
  if (v684)
  {
    if (v684 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v685 = (char *)operator new(8 * v684);
    v686 = (uint64_t *)&v685[8 * v681];
    v687 = (uint64_t *)&v685[8 * v684];
    *v686 = v675;
    v678 = (uint64_t)(v686 + 1);
    v688 = (char *)((char *)v677 - (char *)v679);
    if (v677 != v679)
      goto LABEL_636;
  }
  else
  {
    v685 = 0;
    v686 = (uint64_t *)(8 * v681);
    v687 = 0;
    *(_QWORD *)(8 * v681) = v675;
    v678 = 8 * v681 + 8;
    v688 = (char *)((char *)v677 - (char *)v679);
    if (v677 != v679)
    {
LABEL_636:
      v689 = (unint64_t)(v688 - 8);
      if (v689 < 0x78
        || (uint64_t *)((char *)v677 - (v689 & 0xFFFFFFFFFFFFFFF8) - 8) < v686
        && &v685[v680 - (v689 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v677)
      {
        goto LABEL_2212;
      }
      v690 = (v689 >> 3) + 1;
      v691 = 8 * (v690 & 0x3FFFFFFFFFFFFFFCLL);
      v686 = (uint64_t *)((char *)v686 - v691);
      v692 = &v677[v691 / 0xFFFFFFFFFFFFFFF8];
      v693 = v677 - 2;
      v694 = &v685[8 * v681 - 16];
      v695 = v690 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v697 = *((_OWORD *)v693 - 1);
        v696 = *(_OWORD *)v693;
        *((_OWORD *)v693 - 1) = 0uLL;
        *(_OWORD *)v693 = 0uLL;
        *((_OWORD *)v694 - 1) = v697;
        *(_OWORD *)v694 = v696;
        v693 -= 4;
        v694 -= 32;
        v695 -= 4;
      }
      while (v695);
      v677 = v692;
      if (v690 != (v690 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2212:
        do
        {
          v698 = *--v677;
          *v677 = 0;
          *--v686 = v698;
        }
        while (v677 != v679);
      }
      v677 = *a1;
      v699 = a1[1];
      *a1 = v686;
      a1[1] = (uint64_t *)v678;
      a1[2] = v687;
      while (v699 != v677)
      {
        v701 = *--v699;
        v700 = v701;
        *v699 = 0;
        if (v701)
          (*(void (**)(uint64_t))(*(_QWORD *)v700 + 8))(v700);
      }
      goto LABEL_649;
    }
  }
  *a1 = v686;
  a1[1] = (uint64_t *)v678;
  a1[2] = v687;
LABEL_649:
  if (v677)
    operator delete(v677);
LABEL_651:
  a1[1] = (uint64_t *)v678;
  v702 = operator new();
  v703 = v702;
  *(_BYTE *)(v702 + 31) = 7;
  *(_QWORD *)v702 = off_1E0E17590;
  *(_QWORD *)(v702 + 8) = 0x72657461657267;
  v705 = a1[1];
  v704 = (unint64_t)a1[2];
  if ((unint64_t)v705 < v704)
  {
    *v705 = v702;
    v706 = (uint64_t)(v705 + 1);
    goto LABEL_677;
  }
  v707 = *a1;
  v708 = (char *)v705 - (char *)*a1;
  v709 = v708 >> 3;
  v710 = (v708 >> 3) + 1;
  if (v710 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v711 = v704 - (_QWORD)v707;
  if (v711 >> 2 > v710)
    v710 = v711 >> 2;
  if ((unint64_t)v711 >= 0x7FFFFFFFFFFFFFF8)
    v712 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v712 = v710;
  if (v712)
  {
    if (v712 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v713 = (char *)operator new(8 * v712);
    v714 = (uint64_t *)&v713[8 * v709];
    v715 = (uint64_t *)&v713[8 * v712];
    *v714 = v703;
    v706 = (uint64_t)(v714 + 1);
    v716 = (char *)((char *)v705 - (char *)v707);
    if (v705 != v707)
      goto LABEL_662;
  }
  else
  {
    v713 = 0;
    v714 = (uint64_t *)(8 * v709);
    v715 = 0;
    *(_QWORD *)(8 * v709) = v703;
    v706 = 8 * v709 + 8;
    v716 = (char *)((char *)v705 - (char *)v707);
    if (v705 != v707)
    {
LABEL_662:
      v717 = (unint64_t)(v716 - 8);
      if (v717 < 0x78
        || (uint64_t *)((char *)v705 - (v717 & 0xFFFFFFFFFFFFFFF8) - 8) < v714
        && &v713[v708 - (v717 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v705)
      {
        goto LABEL_2213;
      }
      v718 = (v717 >> 3) + 1;
      v719 = 8 * (v718 & 0x3FFFFFFFFFFFFFFCLL);
      v714 = (uint64_t *)((char *)v714 - v719);
      v720 = &v705[v719 / 0xFFFFFFFFFFFFFFF8];
      v721 = v705 - 2;
      v722 = &v713[8 * v709 - 16];
      v723 = v718 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v725 = *((_OWORD *)v721 - 1);
        v724 = *(_OWORD *)v721;
        *((_OWORD *)v721 - 1) = 0uLL;
        *(_OWORD *)v721 = 0uLL;
        *((_OWORD *)v722 - 1) = v725;
        *(_OWORD *)v722 = v724;
        v721 -= 4;
        v722 -= 32;
        v723 -= 4;
      }
      while (v723);
      v705 = v720;
      if (v718 != (v718 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2213:
        do
        {
          v726 = *--v705;
          *v705 = 0;
          *--v714 = v726;
        }
        while (v705 != v707);
      }
      v705 = *a1;
      v727 = a1[1];
      *a1 = v714;
      a1[1] = (uint64_t *)v706;
      a1[2] = v715;
      while (v727 != v705)
      {
        v729 = *--v727;
        v728 = v729;
        *v727 = 0;
        if (v729)
          (*(void (**)(uint64_t))(*(_QWORD *)v728 + 8))(v728);
      }
      goto LABEL_675;
    }
  }
  *a1 = v714;
  a1[1] = (uint64_t *)v706;
  a1[2] = v715;
LABEL_675:
  if (v705)
    operator delete(v705);
LABEL_677:
  a1[1] = (uint64_t *)v706;
  v730 = operator new();
  v731 = v730;
  strcpy((char *)(v730 + 8), "greater_equal");
  *(_WORD *)(v730 + 22) = 0;
  *(_BYTE *)(v730 + 31) = 13;
  *(_QWORD *)v730 = off_1E0E175B8;
  v733 = a1[1];
  v732 = (unint64_t)a1[2];
  if ((unint64_t)v733 < v732)
  {
    *v733 = v730;
    v734 = (uint64_t)(v733 + 1);
    goto LABEL_703;
  }
  v735 = *a1;
  v736 = (char *)v733 - (char *)*a1;
  v737 = v736 >> 3;
  v738 = (v736 >> 3) + 1;
  if (v738 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v739 = v732 - (_QWORD)v735;
  if (v739 >> 2 > v738)
    v738 = v739 >> 2;
  if ((unint64_t)v739 >= 0x7FFFFFFFFFFFFFF8)
    v740 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v740 = v738;
  if (v740)
  {
    if (v740 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v741 = (char *)operator new(8 * v740);
    v742 = (uint64_t *)&v741[8 * v737];
    v743 = (uint64_t *)&v741[8 * v740];
    *v742 = v731;
    v734 = (uint64_t)(v742 + 1);
    v744 = (char *)((char *)v733 - (char *)v735);
    if (v733 != v735)
      goto LABEL_688;
  }
  else
  {
    v741 = 0;
    v742 = (uint64_t *)(8 * v737);
    v743 = 0;
    *(_QWORD *)(8 * v737) = v731;
    v734 = 8 * v737 + 8;
    v744 = (char *)((char *)v733 - (char *)v735);
    if (v733 != v735)
    {
LABEL_688:
      v745 = (unint64_t)(v744 - 8);
      if (v745 < 0x78
        || (uint64_t *)((char *)v733 - (v745 & 0xFFFFFFFFFFFFFFF8) - 8) < v742
        && &v741[v736 - (v745 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v733)
      {
        goto LABEL_2214;
      }
      v746 = (v745 >> 3) + 1;
      v747 = 8 * (v746 & 0x3FFFFFFFFFFFFFFCLL);
      v742 = (uint64_t *)((char *)v742 - v747);
      v748 = &v733[v747 / 0xFFFFFFFFFFFFFFF8];
      v749 = v733 - 2;
      v750 = &v741[8 * v737 - 16];
      v751 = v746 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v753 = *((_OWORD *)v749 - 1);
        v752 = *(_OWORD *)v749;
        *((_OWORD *)v749 - 1) = 0uLL;
        *(_OWORD *)v749 = 0uLL;
        *((_OWORD *)v750 - 1) = v753;
        *(_OWORD *)v750 = v752;
        v749 -= 4;
        v750 -= 32;
        v751 -= 4;
      }
      while (v751);
      v733 = v748;
      if (v746 != (v746 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2214:
        do
        {
          v754 = *--v733;
          *v733 = 0;
          *--v742 = v754;
        }
        while (v733 != v735);
      }
      v733 = *a1;
      v755 = a1[1];
      *a1 = v742;
      a1[1] = (uint64_t *)v734;
      a1[2] = v743;
      while (v755 != v733)
      {
        v757 = *--v755;
        v756 = v757;
        *v755 = 0;
        if (v757)
          (*(void (**)(uint64_t))(*(_QWORD *)v756 + 8))(v756);
      }
      goto LABEL_701;
    }
  }
  *a1 = v742;
  a1[1] = (uint64_t *)v734;
  a1[2] = v743;
LABEL_701:
  if (v733)
    operator delete(v733);
LABEL_703:
  a1[1] = (uint64_t *)v734;
  v758 = operator new();
  v759 = v758;
  *(_BYTE *)(v758 + 31) = 4;
  *(_QWORD *)v758 = off_1E0E175E0;
  *(_QWORD *)(v758 + 8) = 1936942444;
  v761 = a1[1];
  v760 = (unint64_t)a1[2];
  if ((unint64_t)v761 < v760)
  {
    *v761 = v758;
    v762 = (uint64_t)(v761 + 1);
    goto LABEL_729;
  }
  v763 = *a1;
  v764 = (char *)v761 - (char *)*a1;
  v765 = v764 >> 3;
  v766 = (v764 >> 3) + 1;
  if (v766 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v767 = v760 - (_QWORD)v763;
  if (v767 >> 2 > v766)
    v766 = v767 >> 2;
  if ((unint64_t)v767 >= 0x7FFFFFFFFFFFFFF8)
    v768 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v768 = v766;
  if (v768)
  {
    if (v768 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v769 = (char *)operator new(8 * v768);
    v770 = (uint64_t *)&v769[8 * v765];
    v771 = (uint64_t *)&v769[8 * v768];
    *v770 = v759;
    v762 = (uint64_t)(v770 + 1);
    v772 = (char *)((char *)v761 - (char *)v763);
    if (v761 != v763)
      goto LABEL_714;
  }
  else
  {
    v769 = 0;
    v770 = (uint64_t *)(8 * v765);
    v771 = 0;
    *(_QWORD *)(8 * v765) = v759;
    v762 = 8 * v765 + 8;
    v772 = (char *)((char *)v761 - (char *)v763);
    if (v761 != v763)
    {
LABEL_714:
      v773 = (unint64_t)(v772 - 8);
      if (v773 < 0x78
        || (uint64_t *)((char *)v761 - (v773 & 0xFFFFFFFFFFFFFFF8) - 8) < v770
        && &v769[v764 - (v773 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v761)
      {
        goto LABEL_2215;
      }
      v774 = (v773 >> 3) + 1;
      v775 = 8 * (v774 & 0x3FFFFFFFFFFFFFFCLL);
      v770 = (uint64_t *)((char *)v770 - v775);
      v776 = &v761[v775 / 0xFFFFFFFFFFFFFFF8];
      v777 = v761 - 2;
      v778 = &v769[8 * v765 - 16];
      v779 = v774 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v781 = *((_OWORD *)v777 - 1);
        v780 = *(_OWORD *)v777;
        *((_OWORD *)v777 - 1) = 0uLL;
        *(_OWORD *)v777 = 0uLL;
        *((_OWORD *)v778 - 1) = v781;
        *(_OWORD *)v778 = v780;
        v777 -= 4;
        v778 -= 32;
        v779 -= 4;
      }
      while (v779);
      v761 = v776;
      if (v774 != (v774 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2215:
        do
        {
          v782 = *--v761;
          *v761 = 0;
          *--v770 = v782;
        }
        while (v761 != v763);
      }
      v761 = *a1;
      v783 = a1[1];
      *a1 = v770;
      a1[1] = (uint64_t *)v762;
      a1[2] = v771;
      while (v783 != v761)
      {
        v785 = *--v783;
        v784 = v785;
        *v783 = 0;
        if (v785)
          (*(void (**)(uint64_t))(*(_QWORD *)v784 + 8))(v784);
      }
      goto LABEL_727;
    }
  }
  *a1 = v770;
  a1[1] = (uint64_t *)v762;
  a1[2] = v771;
LABEL_727:
  if (v761)
    operator delete(v761);
LABEL_729:
  a1[1] = (uint64_t *)v762;
  v786 = operator new();
  v787 = v786;
  *(_QWORD *)(v786 + 8) = 0x7571655F7373656CLL;
  *(_QWORD *)(v786 + 16) = 27745;
  *(_BYTE *)(v786 + 31) = 10;
  *(_QWORD *)v786 = off_1E0E17608;
  v789 = a1[1];
  v788 = (unint64_t)a1[2];
  if ((unint64_t)v789 < v788)
  {
    *v789 = v786;
    v790 = (uint64_t)(v789 + 1);
    goto LABEL_755;
  }
  v791 = *a1;
  v792 = (char *)v789 - (char *)*a1;
  v793 = v792 >> 3;
  v794 = (v792 >> 3) + 1;
  if (v794 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v795 = v788 - (_QWORD)v791;
  if (v795 >> 2 > v794)
    v794 = v795 >> 2;
  if ((unint64_t)v795 >= 0x7FFFFFFFFFFFFFF8)
    v796 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v796 = v794;
  if (v796)
  {
    if (v796 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v797 = (char *)operator new(8 * v796);
    v798 = (uint64_t *)&v797[8 * v793];
    v799 = (uint64_t *)&v797[8 * v796];
    *v798 = v787;
    v790 = (uint64_t)(v798 + 1);
    v800 = (char *)((char *)v789 - (char *)v791);
    if (v789 != v791)
      goto LABEL_740;
  }
  else
  {
    v797 = 0;
    v798 = (uint64_t *)(8 * v793);
    v799 = 0;
    *(_QWORD *)(8 * v793) = v787;
    v790 = 8 * v793 + 8;
    v800 = (char *)((char *)v789 - (char *)v791);
    if (v789 != v791)
    {
LABEL_740:
      v801 = (unint64_t)(v800 - 8);
      if (v801 < 0x78
        || (uint64_t *)((char *)v789 - (v801 & 0xFFFFFFFFFFFFFFF8) - 8) < v798
        && &v797[v792 - (v801 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v789)
      {
        goto LABEL_2216;
      }
      v802 = (v801 >> 3) + 1;
      v803 = 8 * (v802 & 0x3FFFFFFFFFFFFFFCLL);
      v798 = (uint64_t *)((char *)v798 - v803);
      v804 = &v789[v803 / 0xFFFFFFFFFFFFFFF8];
      v805 = v789 - 2;
      v806 = &v797[8 * v793 - 16];
      v807 = v802 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v809 = *((_OWORD *)v805 - 1);
        v808 = *(_OWORD *)v805;
        *((_OWORD *)v805 - 1) = 0uLL;
        *(_OWORD *)v805 = 0uLL;
        *((_OWORD *)v806 - 1) = v809;
        *(_OWORD *)v806 = v808;
        v805 -= 4;
        v806 -= 32;
        v807 -= 4;
      }
      while (v807);
      v789 = v804;
      if (v802 != (v802 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2216:
        do
        {
          v810 = *--v789;
          *v789 = 0;
          *--v798 = v810;
        }
        while (v789 != v791);
      }
      v789 = *a1;
      v811 = a1[1];
      *a1 = v798;
      a1[1] = (uint64_t *)v790;
      a1[2] = v799;
      while (v811 != v789)
      {
        v813 = *--v811;
        v812 = v813;
        *v811 = 0;
        if (v813)
          (*(void (**)(uint64_t))(*(_QWORD *)v812 + 8))(v812);
      }
      goto LABEL_753;
    }
  }
  *a1 = v798;
  a1[1] = (uint64_t *)v790;
  a1[2] = v799;
LABEL_753:
  if (v789)
    operator delete(v789);
LABEL_755:
  a1[1] = (uint64_t *)v790;
  v814 = operator new();
  v815 = v814;
  *(_QWORD *)(v814 + 8) = 0x5F6C616369676F6CLL;
  *(_QWORD *)(v814 + 16) = 6581857;
  *(_BYTE *)(v814 + 31) = 11;
  *(_QWORD *)v814 = off_1E0E17630;
  v817 = a1[1];
  v816 = (unint64_t)a1[2];
  if ((unint64_t)v817 < v816)
  {
    *v817 = v814;
    v818 = (uint64_t)(v817 + 1);
    goto LABEL_781;
  }
  v819 = *a1;
  v820 = (char *)v817 - (char *)*a1;
  v821 = v820 >> 3;
  v822 = (v820 >> 3) + 1;
  if (v822 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v823 = v816 - (_QWORD)v819;
  if (v823 >> 2 > v822)
    v822 = v823 >> 2;
  if ((unint64_t)v823 >= 0x7FFFFFFFFFFFFFF8)
    v824 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v824 = v822;
  if (v824)
  {
    if (v824 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v825 = (char *)operator new(8 * v824);
    v826 = (uint64_t *)&v825[8 * v821];
    v827 = (uint64_t *)&v825[8 * v824];
    *v826 = v815;
    v818 = (uint64_t)(v826 + 1);
    v828 = (char *)((char *)v817 - (char *)v819);
    if (v817 != v819)
      goto LABEL_766;
  }
  else
  {
    v825 = 0;
    v826 = (uint64_t *)(8 * v821);
    v827 = 0;
    *(_QWORD *)(8 * v821) = v815;
    v818 = 8 * v821 + 8;
    v828 = (char *)((char *)v817 - (char *)v819);
    if (v817 != v819)
    {
LABEL_766:
      v829 = (unint64_t)(v828 - 8);
      if (v829 < 0x78
        || (uint64_t *)((char *)v817 - (v829 & 0xFFFFFFFFFFFFFFF8) - 8) < v826
        && &v825[v820 - (v829 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v817)
      {
        goto LABEL_2217;
      }
      v830 = (v829 >> 3) + 1;
      v831 = 8 * (v830 & 0x3FFFFFFFFFFFFFFCLL);
      v826 = (uint64_t *)((char *)v826 - v831);
      v832 = &v817[v831 / 0xFFFFFFFFFFFFFFF8];
      v833 = v817 - 2;
      v834 = &v825[8 * v821 - 16];
      v835 = v830 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v837 = *((_OWORD *)v833 - 1);
        v836 = *(_OWORD *)v833;
        *((_OWORD *)v833 - 1) = 0uLL;
        *(_OWORD *)v833 = 0uLL;
        *((_OWORD *)v834 - 1) = v837;
        *(_OWORD *)v834 = v836;
        v833 -= 4;
        v834 -= 32;
        v835 -= 4;
      }
      while (v835);
      v817 = v832;
      if (v830 != (v830 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2217:
        do
        {
          v838 = *--v817;
          *v817 = 0;
          *--v826 = v838;
        }
        while (v817 != v819);
      }
      v817 = *a1;
      v839 = a1[1];
      *a1 = v826;
      a1[1] = (uint64_t *)v818;
      a1[2] = v827;
      while (v839 != v817)
      {
        v841 = *--v839;
        v840 = v841;
        *v839 = 0;
        if (v841)
          (*(void (**)(uint64_t))(*(_QWORD *)v840 + 8))(v840);
      }
      goto LABEL_779;
    }
  }
  *a1 = v826;
  a1[1] = (uint64_t *)v818;
  a1[2] = v827;
LABEL_779:
  if (v817)
    operator delete(v817);
LABEL_781:
  a1[1] = (uint64_t *)v818;
  v842 = operator new();
  v843 = v842;
  *(_QWORD *)(v842 + 8) = 0x617571655F746F6ELL;
  *(_QWORD *)(v842 + 16) = 108;
  *(_BYTE *)(v842 + 31) = 9;
  *(_QWORD *)v842 = off_1E0E17658;
  v845 = a1[1];
  v844 = (unint64_t)a1[2];
  if ((unint64_t)v845 < v844)
  {
    *v845 = v842;
    v846 = (uint64_t)(v845 + 1);
    goto LABEL_807;
  }
  v847 = *a1;
  v848 = (char *)v845 - (char *)*a1;
  v849 = v848 >> 3;
  v850 = (v848 >> 3) + 1;
  if (v850 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v851 = v844 - (_QWORD)v847;
  if (v851 >> 2 > v850)
    v850 = v851 >> 2;
  if ((unint64_t)v851 >= 0x7FFFFFFFFFFFFFF8)
    v852 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v852 = v850;
  if (v852)
  {
    if (v852 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v853 = (char *)operator new(8 * v852);
    v854 = (uint64_t *)&v853[8 * v849];
    v855 = (uint64_t *)&v853[8 * v852];
    *v854 = v843;
    v846 = (uint64_t)(v854 + 1);
    v856 = (char *)((char *)v845 - (char *)v847);
    if (v845 != v847)
      goto LABEL_792;
  }
  else
  {
    v853 = 0;
    v854 = (uint64_t *)(8 * v849);
    v855 = 0;
    *(_QWORD *)(8 * v849) = v843;
    v846 = 8 * v849 + 8;
    v856 = (char *)((char *)v845 - (char *)v847);
    if (v845 != v847)
    {
LABEL_792:
      v857 = (unint64_t)(v856 - 8);
      if (v857 < 0x78
        || (uint64_t *)((char *)v845 - (v857 & 0xFFFFFFFFFFFFFFF8) - 8) < v854
        && &v853[v848 - (v857 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v845)
      {
        goto LABEL_2218;
      }
      v858 = (v857 >> 3) + 1;
      v859 = 8 * (v858 & 0x3FFFFFFFFFFFFFFCLL);
      v854 = (uint64_t *)((char *)v854 - v859);
      v860 = &v845[v859 / 0xFFFFFFFFFFFFFFF8];
      v861 = v845 - 2;
      v862 = &v853[8 * v849 - 16];
      v863 = v858 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v865 = *((_OWORD *)v861 - 1);
        v864 = *(_OWORD *)v861;
        *((_OWORD *)v861 - 1) = 0uLL;
        *(_OWORD *)v861 = 0uLL;
        *((_OWORD *)v862 - 1) = v865;
        *(_OWORD *)v862 = v864;
        v861 -= 4;
        v862 -= 32;
        v863 -= 4;
      }
      while (v863);
      v845 = v860;
      if (v858 != (v858 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2218:
        do
        {
          v866 = *--v845;
          *v845 = 0;
          *--v854 = v866;
        }
        while (v845 != v847);
      }
      v845 = *a1;
      v867 = a1[1];
      *a1 = v854;
      a1[1] = (uint64_t *)v846;
      a1[2] = v855;
      while (v867 != v845)
      {
        v869 = *--v867;
        v868 = v869;
        *v867 = 0;
        if (v869)
          (*(void (**)(uint64_t))(*(_QWORD *)v868 + 8))(v868);
      }
      goto LABEL_805;
    }
  }
  *a1 = v854;
  a1[1] = (uint64_t *)v846;
  a1[2] = v855;
LABEL_805:
  if (v845)
    operator delete(v845);
LABEL_807:
  a1[1] = (uint64_t *)v846;
  v870 = operator new();
  v871 = v870;
  *(_QWORD *)(v870 + 8) = 0x5F6C616369676F6CLL;
  *(_QWORD *)(v870 + 16) = 29295;
  *(_BYTE *)(v870 + 31) = 10;
  *(_QWORD *)v870 = off_1E0E17680;
  v873 = a1[1];
  v872 = (unint64_t)a1[2];
  if ((unint64_t)v873 < v872)
  {
    *v873 = v870;
    v874 = (uint64_t)(v873 + 1);
    goto LABEL_833;
  }
  v875 = *a1;
  v876 = (char *)v873 - (char *)*a1;
  v877 = v876 >> 3;
  v878 = (v876 >> 3) + 1;
  if (v878 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v879 = v872 - (_QWORD)v875;
  if (v879 >> 2 > v878)
    v878 = v879 >> 2;
  if ((unint64_t)v879 >= 0x7FFFFFFFFFFFFFF8)
    v880 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v880 = v878;
  if (v880)
  {
    if (v880 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v881 = (char *)operator new(8 * v880);
    v882 = (uint64_t *)&v881[8 * v877];
    v883 = (uint64_t *)&v881[8 * v880];
    *v882 = v871;
    v874 = (uint64_t)(v882 + 1);
    v884 = (char *)((char *)v873 - (char *)v875);
    if (v873 != v875)
      goto LABEL_818;
  }
  else
  {
    v881 = 0;
    v882 = (uint64_t *)(8 * v877);
    v883 = 0;
    *(_QWORD *)(8 * v877) = v871;
    v874 = 8 * v877 + 8;
    v884 = (char *)((char *)v873 - (char *)v875);
    if (v873 != v875)
    {
LABEL_818:
      v885 = (unint64_t)(v884 - 8);
      if (v885 < 0x78
        || (uint64_t *)((char *)v873 - (v885 & 0xFFFFFFFFFFFFFFF8) - 8) < v882
        && &v881[v876 - (v885 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v873)
      {
        goto LABEL_2219;
      }
      v886 = (v885 >> 3) + 1;
      v887 = 8 * (v886 & 0x3FFFFFFFFFFFFFFCLL);
      v882 = (uint64_t *)((char *)v882 - v887);
      v888 = &v873[v887 / 0xFFFFFFFFFFFFFFF8];
      v889 = v873 - 2;
      v890 = &v881[8 * v877 - 16];
      v891 = v886 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v893 = *((_OWORD *)v889 - 1);
        v892 = *(_OWORD *)v889;
        *((_OWORD *)v889 - 1) = 0uLL;
        *(_OWORD *)v889 = 0uLL;
        *((_OWORD *)v890 - 1) = v893;
        *(_OWORD *)v890 = v892;
        v889 -= 4;
        v890 -= 32;
        v891 -= 4;
      }
      while (v891);
      v873 = v888;
      if (v886 != (v886 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2219:
        do
        {
          v894 = *--v873;
          *v873 = 0;
          *--v882 = v894;
        }
        while (v873 != v875);
      }
      v873 = *a1;
      v895 = a1[1];
      *a1 = v882;
      a1[1] = (uint64_t *)v874;
      a1[2] = v883;
      while (v895 != v873)
      {
        v897 = *--v895;
        v896 = v897;
        *v895 = 0;
        if (v897)
          (*(void (**)(uint64_t))(*(_QWORD *)v896 + 8))(v896);
      }
      goto LABEL_831;
    }
  }
  *a1 = v882;
  a1[1] = (uint64_t *)v874;
  a1[2] = v883;
LABEL_831:
  if (v873)
    operator delete(v873);
LABEL_833:
  a1[1] = (uint64_t *)v874;
  v898 = operator new();
  v899 = v898;
  *(_QWORD *)(v898 + 8) = 0x5F6C616369676F6CLL;
  *(_QWORD *)(v898 + 16) = 7499640;
  *(_BYTE *)(v898 + 31) = 11;
  *(_QWORD *)v898 = off_1E0E176A8;
  v901 = a1[1];
  v900 = (unint64_t)a1[2];
  if ((unint64_t)v901 < v900)
  {
    *v901 = v898;
    v902 = (uint64_t)(v901 + 1);
    goto LABEL_859;
  }
  v903 = *a1;
  v904 = (char *)v901 - (char *)*a1;
  v905 = v904 >> 3;
  v906 = (v904 >> 3) + 1;
  if (v906 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v907 = v900 - (_QWORD)v903;
  if (v907 >> 2 > v906)
    v906 = v907 >> 2;
  if ((unint64_t)v907 >= 0x7FFFFFFFFFFFFFF8)
    v908 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v908 = v906;
  if (v908)
  {
    if (v908 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v909 = (char *)operator new(8 * v908);
    v910 = (uint64_t *)&v909[8 * v905];
    v911 = (uint64_t *)&v909[8 * v908];
    *v910 = v899;
    v902 = (uint64_t)(v910 + 1);
    v912 = (char *)((char *)v901 - (char *)v903);
    if (v901 != v903)
      goto LABEL_844;
  }
  else
  {
    v909 = 0;
    v910 = (uint64_t *)(8 * v905);
    v911 = 0;
    *(_QWORD *)(8 * v905) = v899;
    v902 = 8 * v905 + 8;
    v912 = (char *)((char *)v901 - (char *)v903);
    if (v901 != v903)
    {
LABEL_844:
      v913 = (unint64_t)(v912 - 8);
      if (v913 < 0x78
        || (uint64_t *)((char *)v901 - (v913 & 0xFFFFFFFFFFFFFFF8) - 8) < v910
        && &v909[v904 - (v913 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v901)
      {
        goto LABEL_2220;
      }
      v914 = (v913 >> 3) + 1;
      v915 = 8 * (v914 & 0x3FFFFFFFFFFFFFFCLL);
      v910 = (uint64_t *)((char *)v910 - v915);
      v916 = &v901[v915 / 0xFFFFFFFFFFFFFFF8];
      v917 = v901 - 2;
      v918 = &v909[8 * v905 - 16];
      v919 = v914 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v921 = *((_OWORD *)v917 - 1);
        v920 = *(_OWORD *)v917;
        *((_OWORD *)v917 - 1) = 0uLL;
        *(_OWORD *)v917 = 0uLL;
        *((_OWORD *)v918 - 1) = v921;
        *(_OWORD *)v918 = v920;
        v917 -= 4;
        v918 -= 32;
        v919 -= 4;
      }
      while (v919);
      v901 = v916;
      if (v914 != (v914 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2220:
        do
        {
          v922 = *--v901;
          *v901 = 0;
          *--v910 = v922;
        }
        while (v901 != v903);
      }
      v901 = *a1;
      v923 = a1[1];
      *a1 = v910;
      a1[1] = (uint64_t *)v902;
      a1[2] = v911;
      while (v923 != v901)
      {
        v925 = *--v923;
        v924 = v925;
        *v923 = 0;
        if (v925)
          (*(void (**)(uint64_t))(*(_QWORD *)v924 + 8))(v924);
      }
      goto LABEL_857;
    }
  }
  *a1 = v910;
  a1[1] = (uint64_t *)v902;
  a1[2] = v911;
LABEL_857:
  if (v901)
    operator delete(v901);
LABEL_859:
  a1[1] = (uint64_t *)v902;
  v926 = operator new();
  v927 = v926;
  *(_QWORD *)(v926 + 8) = 0x69645F726F6F6C66;
  *(_QWORD *)(v926 + 16) = 118;
  *(_BYTE *)(v926 + 31) = 9;
  *(_QWORD *)v926 = off_1E0E176D0;
  v929 = a1[1];
  v928 = (unint64_t)a1[2];
  if ((unint64_t)v929 < v928)
  {
    *v929 = v926;
    v930 = (uint64_t)(v929 + 1);
    goto LABEL_885;
  }
  v931 = *a1;
  v932 = (char *)v929 - (char *)*a1;
  v933 = v932 >> 3;
  v934 = (v932 >> 3) + 1;
  if (v934 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v935 = v928 - (_QWORD)v931;
  if (v935 >> 2 > v934)
    v934 = v935 >> 2;
  if ((unint64_t)v935 >= 0x7FFFFFFFFFFFFFF8)
    v936 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v936 = v934;
  if (v936)
  {
    if (v936 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v937 = (char *)operator new(8 * v936);
    v938 = (uint64_t *)&v937[8 * v933];
    v939 = (uint64_t *)&v937[8 * v936];
    *v938 = v927;
    v930 = (uint64_t)(v938 + 1);
    v940 = (char *)((char *)v929 - (char *)v931);
    if (v929 != v931)
      goto LABEL_870;
  }
  else
  {
    v937 = 0;
    v938 = (uint64_t *)(8 * v933);
    v939 = 0;
    *(_QWORD *)(8 * v933) = v927;
    v930 = 8 * v933 + 8;
    v940 = (char *)((char *)v929 - (char *)v931);
    if (v929 != v931)
    {
LABEL_870:
      v941 = (unint64_t)(v940 - 8);
      if (v941 < 0x78
        || (uint64_t *)((char *)v929 - (v941 & 0xFFFFFFFFFFFFFFF8) - 8) < v938
        && &v937[v932 - (v941 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v929)
      {
        goto LABEL_2221;
      }
      v942 = (v941 >> 3) + 1;
      v943 = 8 * (v942 & 0x3FFFFFFFFFFFFFFCLL);
      v938 = (uint64_t *)((char *)v938 - v943);
      v944 = &v929[v943 / 0xFFFFFFFFFFFFFFF8];
      v945 = v929 - 2;
      v946 = &v937[8 * v933 - 16];
      v947 = v942 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v949 = *((_OWORD *)v945 - 1);
        v948 = *(_OWORD *)v945;
        *((_OWORD *)v945 - 1) = 0uLL;
        *(_OWORD *)v945 = 0uLL;
        *((_OWORD *)v946 - 1) = v949;
        *(_OWORD *)v946 = v948;
        v945 -= 4;
        v946 -= 32;
        v947 -= 4;
      }
      while (v947);
      v929 = v944;
      if (v942 != (v942 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2221:
        do
        {
          v950 = *--v929;
          *v929 = 0;
          *--v938 = v950;
        }
        while (v929 != v931);
      }
      v929 = *a1;
      v951 = a1[1];
      *a1 = v938;
      a1[1] = (uint64_t *)v930;
      a1[2] = v939;
      while (v951 != v929)
      {
        v953 = *--v951;
        v952 = v953;
        *v951 = 0;
        if (v953)
          (*(void (**)(uint64_t))(*(_QWORD *)v952 + 8))(v952);
      }
      goto LABEL_883;
    }
  }
  *a1 = v938;
  a1[1] = (uint64_t *)v930;
  a1[2] = v939;
LABEL_883:
  if (v929)
    operator delete(v929);
LABEL_885:
  a1[1] = (uint64_t *)v930;
  v954 = operator new();
  v955 = v954;
  *(_BYTE *)(v954 + 31) = 3;
  *(_QWORD *)v954 = off_1E0E176F8;
  *(_QWORD *)(v954 + 8) = 7561825;
  v957 = a1[1];
  v956 = (unint64_t)a1[2];
  if ((unint64_t)v957 < v956)
  {
    *v957 = v954;
    v958 = (uint64_t)(v957 + 1);
    goto LABEL_911;
  }
  v959 = *a1;
  v960 = (char *)v957 - (char *)*a1;
  v961 = v960 >> 3;
  v962 = (v960 >> 3) + 1;
  if (v962 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v963 = v956 - (_QWORD)v959;
  if (v963 >> 2 > v962)
    v962 = v963 >> 2;
  if ((unint64_t)v963 >= 0x7FFFFFFFFFFFFFF8)
    v964 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v964 = v962;
  if (v964)
  {
    if (v964 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v965 = (char *)operator new(8 * v964);
    v966 = (uint64_t *)&v965[8 * v961];
    v967 = (uint64_t *)&v965[8 * v964];
    *v966 = v955;
    v958 = (uint64_t)(v966 + 1);
    v968 = (char *)((char *)v957 - (char *)v959);
    if (v957 != v959)
      goto LABEL_896;
  }
  else
  {
    v965 = 0;
    v966 = (uint64_t *)(8 * v961);
    v967 = 0;
    *(_QWORD *)(8 * v961) = v955;
    v958 = 8 * v961 + 8;
    v968 = (char *)((char *)v957 - (char *)v959);
    if (v957 != v959)
    {
LABEL_896:
      v969 = (unint64_t)(v968 - 8);
      if (v969 < 0x78
        || (uint64_t *)((char *)v957 - (v969 & 0xFFFFFFFFFFFFFFF8) - 8) < v966
        && &v965[v960 - (v969 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v957)
      {
        goto LABEL_2222;
      }
      v970 = (v969 >> 3) + 1;
      v971 = 8 * (v970 & 0x3FFFFFFFFFFFFFFCLL);
      v966 = (uint64_t *)((char *)v966 - v971);
      v972 = &v957[v971 / 0xFFFFFFFFFFFFFFF8];
      v973 = v957 - 2;
      v974 = &v965[8 * v961 - 16];
      v975 = v970 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v977 = *((_OWORD *)v973 - 1);
        v976 = *(_OWORD *)v973;
        *((_OWORD *)v973 - 1) = 0uLL;
        *(_OWORD *)v973 = 0uLL;
        *((_OWORD *)v974 - 1) = v977;
        *(_OWORD *)v974 = v976;
        v973 -= 4;
        v974 -= 32;
        v975 -= 4;
      }
      while (v975);
      v957 = v972;
      if (v970 != (v970 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2222:
        do
        {
          v978 = *--v957;
          *v957 = 0;
          *--v966 = v978;
        }
        while (v957 != v959);
      }
      v957 = *a1;
      v979 = a1[1];
      *a1 = v966;
      a1[1] = (uint64_t *)v958;
      a1[2] = v967;
      while (v979 != v957)
      {
        v981 = *--v979;
        v980 = v981;
        *v979 = 0;
        if (v981)
          (*(void (**)(uint64_t))(*(_QWORD *)v980 + 8))(v980);
      }
      goto LABEL_909;
    }
  }
  *a1 = v966;
  a1[1] = (uint64_t *)v958;
  a1[2] = v967;
LABEL_909:
  if (v957)
    operator delete(v957);
LABEL_911:
  a1[1] = (uint64_t *)v958;
  v982 = operator new();
  v983 = v982;
  *(_BYTE *)(v982 + 31) = 4;
  *(_QWORD *)v982 = off_1E0E17720;
  *(_QWORD *)(v982 + 8) = 1936679777;
  v985 = a1[1];
  v984 = (unint64_t)a1[2];
  if ((unint64_t)v985 < v984)
  {
    *v985 = v982;
    v986 = (uint64_t)(v985 + 1);
    goto LABEL_937;
  }
  v987 = *a1;
  v988 = (char *)v985 - (char *)*a1;
  v989 = v988 >> 3;
  v990 = (v988 >> 3) + 1;
  if (v990 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v991 = v984 - (_QWORD)v987;
  if (v991 >> 2 > v990)
    v990 = v991 >> 2;
  if ((unint64_t)v991 >= 0x7FFFFFFFFFFFFFF8)
    v992 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v992 = v990;
  if (v992)
  {
    if (v992 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v993 = (char *)operator new(8 * v992);
    v994 = (uint64_t *)&v993[8 * v989];
    v995 = (uint64_t *)&v993[8 * v992];
    *v994 = v983;
    v986 = (uint64_t)(v994 + 1);
    v996 = (char *)((char *)v985 - (char *)v987);
    if (v985 != v987)
      goto LABEL_922;
  }
  else
  {
    v993 = 0;
    v994 = (uint64_t *)(8 * v989);
    v995 = 0;
    *(_QWORD *)(8 * v989) = v983;
    v986 = 8 * v989 + 8;
    v996 = (char *)((char *)v985 - (char *)v987);
    if (v985 != v987)
    {
LABEL_922:
      v997 = (unint64_t)(v996 - 8);
      if (v997 < 0x78
        || (uint64_t *)((char *)v985 - (v997 & 0xFFFFFFFFFFFFFFF8) - 8) < v994
        && &v993[v988 - (v997 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v985)
      {
        goto LABEL_2223;
      }
      v998 = (v997 >> 3) + 1;
      v999 = 8 * (v998 & 0x3FFFFFFFFFFFFFFCLL);
      v994 = (uint64_t *)((char *)v994 - v999);
      v1000 = &v985[v999 / 0xFFFFFFFFFFFFFFF8];
      v1001 = v985 - 2;
      v1002 = &v993[8 * v989 - 16];
      v1003 = v998 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1005 = *((_OWORD *)v1001 - 1);
        v1004 = *(_OWORD *)v1001;
        *((_OWORD *)v1001 - 1) = 0uLL;
        *(_OWORD *)v1001 = 0uLL;
        *((_OWORD *)v1002 - 1) = v1005;
        *(_OWORD *)v1002 = v1004;
        v1001 -= 4;
        v1002 -= 32;
        v1003 -= 4;
      }
      while (v1003);
      v985 = v1000;
      if (v998 != (v998 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2223:
        do
        {
          v1006 = *--v985;
          *v985 = 0;
          *--v994 = v1006;
        }
        while (v985 != v987);
      }
      v985 = *a1;
      v1007 = a1[1];
      *a1 = v994;
      a1[1] = (uint64_t *)v986;
      a1[2] = v995;
      while (v1007 != v985)
      {
        v1009 = *--v1007;
        v1008 = v1009;
        *v1007 = 0;
        if (v1009)
          (*(void (**)(uint64_t))(*(_QWORD *)v1008 + 8))(v1008);
      }
      goto LABEL_935;
    }
  }
  *a1 = v994;
  a1[1] = (uint64_t *)v986;
  a1[2] = v995;
LABEL_935:
  if (v985)
    operator delete(v985);
LABEL_937:
  a1[1] = (uint64_t *)v986;
  v1010 = operator new();
  v1011 = v1010;
  *(_BYTE *)(v1010 + 31) = 5;
  *(_QWORD *)v1010 = off_1E0E17748;
  *(_QWORD *)(v1010 + 8) = 0x68736F6361;
  v1013 = a1[1];
  v1012 = (unint64_t)a1[2];
  if ((unint64_t)v1013 < v1012)
  {
    *v1013 = v1010;
    v1014 = (uint64_t)(v1013 + 1);
    goto LABEL_963;
  }
  v1015 = *a1;
  v1016 = (char *)v1013 - (char *)*a1;
  v1017 = v1016 >> 3;
  v1018 = (v1016 >> 3) + 1;
  if (v1018 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1019 = v1012 - (_QWORD)v1015;
  if (v1019 >> 2 > v1018)
    v1018 = v1019 >> 2;
  if ((unint64_t)v1019 >= 0x7FFFFFFFFFFFFFF8)
    v1020 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1020 = v1018;
  if (v1020)
  {
    if (v1020 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1021 = (char *)operator new(8 * v1020);
    v1022 = (uint64_t *)&v1021[8 * v1017];
    v1023 = (uint64_t *)&v1021[8 * v1020];
    *v1022 = v1011;
    v1014 = (uint64_t)(v1022 + 1);
    v1024 = (char *)((char *)v1013 - (char *)v1015);
    if (v1013 != v1015)
      goto LABEL_948;
  }
  else
  {
    v1021 = 0;
    v1022 = (uint64_t *)(8 * v1017);
    v1023 = 0;
    *(_QWORD *)(8 * v1017) = v1011;
    v1014 = 8 * v1017 + 8;
    v1024 = (char *)((char *)v1013 - (char *)v1015);
    if (v1013 != v1015)
    {
LABEL_948:
      v1025 = (unint64_t)(v1024 - 8);
      if (v1025 < 0x78
        || (uint64_t *)((char *)v1013 - (v1025 & 0xFFFFFFFFFFFFFFF8) - 8) < v1022
        && &v1021[v1016 - (v1025 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1013)
      {
        goto LABEL_2224;
      }
      v1026 = (v1025 >> 3) + 1;
      v1027 = 8 * (v1026 & 0x3FFFFFFFFFFFFFFCLL);
      v1022 = (uint64_t *)((char *)v1022 - v1027);
      v1028 = &v1013[v1027 / 0xFFFFFFFFFFFFFFF8];
      v1029 = v1013 - 2;
      v1030 = &v1021[8 * v1017 - 16];
      v1031 = v1026 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1033 = *((_OWORD *)v1029 - 1);
        v1032 = *(_OWORD *)v1029;
        *((_OWORD *)v1029 - 1) = 0uLL;
        *(_OWORD *)v1029 = 0uLL;
        *((_OWORD *)v1030 - 1) = v1033;
        *(_OWORD *)v1030 = v1032;
        v1029 -= 4;
        v1030 -= 32;
        v1031 -= 4;
      }
      while (v1031);
      v1013 = v1028;
      if (v1026 != (v1026 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2224:
        do
        {
          v1034 = *--v1013;
          *v1013 = 0;
          *--v1022 = v1034;
        }
        while (v1013 != v1015);
      }
      v1013 = *a1;
      v1035 = a1[1];
      *a1 = v1022;
      a1[1] = (uint64_t *)v1014;
      a1[2] = v1023;
      while (v1035 != v1013)
      {
        v1037 = *--v1035;
        v1036 = v1037;
        *v1035 = 0;
        if (v1037)
          (*(void (**)(uint64_t))(*(_QWORD *)v1036 + 8))(v1036);
      }
      goto LABEL_961;
    }
  }
  *a1 = v1022;
  a1[1] = (uint64_t *)v1014;
  a1[2] = v1023;
LABEL_961:
  if (v1013)
    operator delete(v1013);
LABEL_963:
  a1[1] = (uint64_t *)v1014;
  v1038 = operator new();
  v1039 = v1038;
  *(_BYTE *)(v1038 + 31) = 4;
  *(_QWORD *)v1038 = off_1E0E17770;
  *(_QWORD *)(v1038 + 8) = 1852404577;
  v1041 = a1[1];
  v1040 = (unint64_t)a1[2];
  if ((unint64_t)v1041 < v1040)
  {
    *v1041 = v1038;
    v1042 = (uint64_t)(v1041 + 1);
    goto LABEL_989;
  }
  v1043 = *a1;
  v1044 = (char *)v1041 - (char *)*a1;
  v1045 = v1044 >> 3;
  v1046 = (v1044 >> 3) + 1;
  if (v1046 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1047 = v1040 - (_QWORD)v1043;
  if (v1047 >> 2 > v1046)
    v1046 = v1047 >> 2;
  if ((unint64_t)v1047 >= 0x7FFFFFFFFFFFFFF8)
    v1048 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1048 = v1046;
  if (v1048)
  {
    if (v1048 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1049 = (char *)operator new(8 * v1048);
    v1050 = (uint64_t *)&v1049[8 * v1045];
    v1051 = (uint64_t *)&v1049[8 * v1048];
    *v1050 = v1039;
    v1042 = (uint64_t)(v1050 + 1);
    v1052 = (char *)((char *)v1041 - (char *)v1043);
    if (v1041 != v1043)
      goto LABEL_974;
  }
  else
  {
    v1049 = 0;
    v1050 = (uint64_t *)(8 * v1045);
    v1051 = 0;
    *(_QWORD *)(8 * v1045) = v1039;
    v1042 = 8 * v1045 + 8;
    v1052 = (char *)((char *)v1041 - (char *)v1043);
    if (v1041 != v1043)
    {
LABEL_974:
      v1053 = (unint64_t)(v1052 - 8);
      if (v1053 < 0x78
        || (uint64_t *)((char *)v1041 - (v1053 & 0xFFFFFFFFFFFFFFF8) - 8) < v1050
        && &v1049[v1044 - (v1053 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1041)
      {
        goto LABEL_2225;
      }
      v1054 = (v1053 >> 3) + 1;
      v1055 = 8 * (v1054 & 0x3FFFFFFFFFFFFFFCLL);
      v1050 = (uint64_t *)((char *)v1050 - v1055);
      v1056 = &v1041[v1055 / 0xFFFFFFFFFFFFFFF8];
      v1057 = v1041 - 2;
      v1058 = &v1049[8 * v1045 - 16];
      v1059 = v1054 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1061 = *((_OWORD *)v1057 - 1);
        v1060 = *(_OWORD *)v1057;
        *((_OWORD *)v1057 - 1) = 0uLL;
        *(_OWORD *)v1057 = 0uLL;
        *((_OWORD *)v1058 - 1) = v1061;
        *(_OWORD *)v1058 = v1060;
        v1057 -= 4;
        v1058 -= 32;
        v1059 -= 4;
      }
      while (v1059);
      v1041 = v1056;
      if (v1054 != (v1054 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2225:
        do
        {
          v1062 = *--v1041;
          *v1041 = 0;
          *--v1050 = v1062;
        }
        while (v1041 != v1043);
      }
      v1041 = *a1;
      v1063 = a1[1];
      *a1 = v1050;
      a1[1] = (uint64_t *)v1042;
      a1[2] = v1051;
      while (v1063 != v1041)
      {
        v1065 = *--v1063;
        v1064 = v1065;
        *v1063 = 0;
        if (v1065)
          (*(void (**)(uint64_t))(*(_QWORD *)v1064 + 8))(v1064);
      }
      goto LABEL_987;
    }
  }
  *a1 = v1050;
  a1[1] = (uint64_t *)v1042;
  a1[2] = v1051;
LABEL_987:
  if (v1041)
    operator delete(v1041);
LABEL_989:
  a1[1] = (uint64_t *)v1042;
  v1066 = operator new();
  v1067 = v1066;
  *(_BYTE *)(v1066 + 31) = 5;
  *(_QWORD *)v1066 = off_1E0E17798;
  *(_QWORD *)(v1066 + 8) = 0x686E697361;
  v1069 = a1[1];
  v1068 = (unint64_t)a1[2];
  if ((unint64_t)v1069 < v1068)
  {
    *v1069 = v1066;
    v1070 = (uint64_t)(v1069 + 1);
    goto LABEL_1015;
  }
  v1071 = *a1;
  v1072 = (char *)v1069 - (char *)*a1;
  v1073 = v1072 >> 3;
  v1074 = (v1072 >> 3) + 1;
  if (v1074 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1075 = v1068 - (_QWORD)v1071;
  if (v1075 >> 2 > v1074)
    v1074 = v1075 >> 2;
  if ((unint64_t)v1075 >= 0x7FFFFFFFFFFFFFF8)
    v1076 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1076 = v1074;
  if (v1076)
  {
    if (v1076 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1077 = (char *)operator new(8 * v1076);
    v1078 = (uint64_t *)&v1077[8 * v1073];
    v1079 = (uint64_t *)&v1077[8 * v1076];
    *v1078 = v1067;
    v1070 = (uint64_t)(v1078 + 1);
    v1080 = (char *)((char *)v1069 - (char *)v1071);
    if (v1069 != v1071)
      goto LABEL_1000;
  }
  else
  {
    v1077 = 0;
    v1078 = (uint64_t *)(8 * v1073);
    v1079 = 0;
    *(_QWORD *)(8 * v1073) = v1067;
    v1070 = 8 * v1073 + 8;
    v1080 = (char *)((char *)v1069 - (char *)v1071);
    if (v1069 != v1071)
    {
LABEL_1000:
      v1081 = (unint64_t)(v1080 - 8);
      if (v1081 < 0x78
        || (uint64_t *)((char *)v1069 - (v1081 & 0xFFFFFFFFFFFFFFF8) - 8) < v1078
        && &v1077[v1072 - (v1081 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1069)
      {
        goto LABEL_2226;
      }
      v1082 = (v1081 >> 3) + 1;
      v1083 = 8 * (v1082 & 0x3FFFFFFFFFFFFFFCLL);
      v1078 = (uint64_t *)((char *)v1078 - v1083);
      v1084 = &v1069[v1083 / 0xFFFFFFFFFFFFFFF8];
      v1085 = v1069 - 2;
      v1086 = &v1077[8 * v1073 - 16];
      v1087 = v1082 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1089 = *((_OWORD *)v1085 - 1);
        v1088 = *(_OWORD *)v1085;
        *((_OWORD *)v1085 - 1) = 0uLL;
        *(_OWORD *)v1085 = 0uLL;
        *((_OWORD *)v1086 - 1) = v1089;
        *(_OWORD *)v1086 = v1088;
        v1085 -= 4;
        v1086 -= 32;
        v1087 -= 4;
      }
      while (v1087);
      v1069 = v1084;
      if (v1082 != (v1082 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2226:
        do
        {
          v1090 = *--v1069;
          *v1069 = 0;
          *--v1078 = v1090;
        }
        while (v1069 != v1071);
      }
      v1069 = *a1;
      v1091 = a1[1];
      *a1 = v1078;
      a1[1] = (uint64_t *)v1070;
      a1[2] = v1079;
      while (v1091 != v1069)
      {
        v1093 = *--v1091;
        v1092 = v1093;
        *v1091 = 0;
        if (v1093)
          (*(void (**)(uint64_t))(*(_QWORD *)v1092 + 8))(v1092);
      }
      goto LABEL_1013;
    }
  }
  *a1 = v1078;
  a1[1] = (uint64_t *)v1070;
  a1[2] = v1079;
LABEL_1013:
  if (v1069)
    operator delete(v1069);
LABEL_1015:
  a1[1] = (uint64_t *)v1070;
  v1094 = operator new();
  v1095 = v1094;
  *(_BYTE *)(v1094 + 31) = 4;
  *(_QWORD *)v1094 = off_1E0E177C0;
  *(_QWORD *)(v1094 + 8) = 1851880545;
  v1097 = a1[1];
  v1096 = (unint64_t)a1[2];
  if ((unint64_t)v1097 < v1096)
  {
    *v1097 = v1094;
    v1098 = (uint64_t)(v1097 + 1);
    goto LABEL_1041;
  }
  v1099 = *a1;
  v1100 = (char *)v1097 - (char *)*a1;
  v1101 = v1100 >> 3;
  v1102 = (v1100 >> 3) + 1;
  if (v1102 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1103 = v1096 - (_QWORD)v1099;
  if (v1103 >> 2 > v1102)
    v1102 = v1103 >> 2;
  if ((unint64_t)v1103 >= 0x7FFFFFFFFFFFFFF8)
    v1104 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1104 = v1102;
  if (v1104)
  {
    if (v1104 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1105 = (char *)operator new(8 * v1104);
    v1106 = (uint64_t *)&v1105[8 * v1101];
    v1107 = (uint64_t *)&v1105[8 * v1104];
    *v1106 = v1095;
    v1098 = (uint64_t)(v1106 + 1);
    v1108 = (char *)((char *)v1097 - (char *)v1099);
    if (v1097 != v1099)
      goto LABEL_1026;
  }
  else
  {
    v1105 = 0;
    v1106 = (uint64_t *)(8 * v1101);
    v1107 = 0;
    *(_QWORD *)(8 * v1101) = v1095;
    v1098 = 8 * v1101 + 8;
    v1108 = (char *)((char *)v1097 - (char *)v1099);
    if (v1097 != v1099)
    {
LABEL_1026:
      v1109 = (unint64_t)(v1108 - 8);
      if (v1109 < 0x78
        || (uint64_t *)((char *)v1097 - (v1109 & 0xFFFFFFFFFFFFFFF8) - 8) < v1106
        && &v1105[v1100 - (v1109 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1097)
      {
        goto LABEL_2227;
      }
      v1110 = (v1109 >> 3) + 1;
      v1111 = 8 * (v1110 & 0x3FFFFFFFFFFFFFFCLL);
      v1106 = (uint64_t *)((char *)v1106 - v1111);
      v1112 = &v1097[v1111 / 0xFFFFFFFFFFFFFFF8];
      v1113 = v1097 - 2;
      v1114 = &v1105[8 * v1101 - 16];
      v1115 = v1110 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1117 = *((_OWORD *)v1113 - 1);
        v1116 = *(_OWORD *)v1113;
        *((_OWORD *)v1113 - 1) = 0uLL;
        *(_OWORD *)v1113 = 0uLL;
        *((_OWORD *)v1114 - 1) = v1117;
        *(_OWORD *)v1114 = v1116;
        v1113 -= 4;
        v1114 -= 32;
        v1115 -= 4;
      }
      while (v1115);
      v1097 = v1112;
      if (v1110 != (v1110 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2227:
        do
        {
          v1118 = *--v1097;
          *v1097 = 0;
          *--v1106 = v1118;
        }
        while (v1097 != v1099);
      }
      v1097 = *a1;
      v1119 = a1[1];
      *a1 = v1106;
      a1[1] = (uint64_t *)v1098;
      a1[2] = v1107;
      while (v1119 != v1097)
      {
        v1121 = *--v1119;
        v1120 = v1121;
        *v1119 = 0;
        if (v1121)
          (*(void (**)(uint64_t))(*(_QWORD *)v1120 + 8))(v1120);
      }
      goto LABEL_1039;
    }
  }
  *a1 = v1106;
  a1[1] = (uint64_t *)v1098;
  a1[2] = v1107;
LABEL_1039:
  if (v1097)
    operator delete(v1097);
LABEL_1041:
  a1[1] = (uint64_t *)v1098;
  v1122 = operator new();
  v1123 = v1122;
  *(_BYTE *)(v1122 + 31) = 5;
  *(_QWORD *)v1122 = off_1E0E177E8;
  *(_QWORD *)(v1122 + 8) = 0x686E617461;
  v1125 = a1[1];
  v1124 = (unint64_t)a1[2];
  if ((unint64_t)v1125 < v1124)
  {
    *v1125 = v1122;
    v1126 = (uint64_t)(v1125 + 1);
    goto LABEL_1067;
  }
  v1127 = *a1;
  v1128 = (char *)v1125 - (char *)*a1;
  v1129 = v1128 >> 3;
  v1130 = (v1128 >> 3) + 1;
  if (v1130 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1131 = v1124 - (_QWORD)v1127;
  if (v1131 >> 2 > v1130)
    v1130 = v1131 >> 2;
  if ((unint64_t)v1131 >= 0x7FFFFFFFFFFFFFF8)
    v1132 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1132 = v1130;
  if (v1132)
  {
    if (v1132 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1133 = (char *)operator new(8 * v1132);
    v1134 = (uint64_t *)&v1133[8 * v1129];
    v1135 = (uint64_t *)&v1133[8 * v1132];
    *v1134 = v1123;
    v1126 = (uint64_t)(v1134 + 1);
    v1136 = (char *)((char *)v1125 - (char *)v1127);
    if (v1125 != v1127)
      goto LABEL_1052;
  }
  else
  {
    v1133 = 0;
    v1134 = (uint64_t *)(8 * v1129);
    v1135 = 0;
    *(_QWORD *)(8 * v1129) = v1123;
    v1126 = 8 * v1129 + 8;
    v1136 = (char *)((char *)v1125 - (char *)v1127);
    if (v1125 != v1127)
    {
LABEL_1052:
      v1137 = (unint64_t)(v1136 - 8);
      if (v1137 < 0x78
        || (uint64_t *)((char *)v1125 - (v1137 & 0xFFFFFFFFFFFFFFF8) - 8) < v1134
        && &v1133[v1128 - (v1137 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1125)
      {
        goto LABEL_2228;
      }
      v1138 = (v1137 >> 3) + 1;
      v1139 = 8 * (v1138 & 0x3FFFFFFFFFFFFFFCLL);
      v1134 = (uint64_t *)((char *)v1134 - v1139);
      v1140 = &v1125[v1139 / 0xFFFFFFFFFFFFFFF8];
      v1141 = v1125 - 2;
      v1142 = &v1133[8 * v1129 - 16];
      v1143 = v1138 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1145 = *((_OWORD *)v1141 - 1);
        v1144 = *(_OWORD *)v1141;
        *((_OWORD *)v1141 - 1) = 0uLL;
        *(_OWORD *)v1141 = 0uLL;
        *((_OWORD *)v1142 - 1) = v1145;
        *(_OWORD *)v1142 = v1144;
        v1141 -= 4;
        v1142 -= 32;
        v1143 -= 4;
      }
      while (v1143);
      v1125 = v1140;
      if (v1138 != (v1138 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2228:
        do
        {
          v1146 = *--v1125;
          *v1125 = 0;
          *--v1134 = v1146;
        }
        while (v1125 != v1127);
      }
      v1125 = *a1;
      v1147 = a1[1];
      *a1 = v1134;
      a1[1] = (uint64_t *)v1126;
      a1[2] = v1135;
      while (v1147 != v1125)
      {
        v1149 = *--v1147;
        v1148 = v1149;
        *v1147 = 0;
        if (v1149)
          (*(void (**)(uint64_t))(*(_QWORD *)v1148 + 8))(v1148);
      }
      goto LABEL_1065;
    }
  }
  *a1 = v1134;
  a1[1] = (uint64_t *)v1126;
  a1[2] = v1135;
LABEL_1065:
  if (v1125)
    operator delete(v1125);
LABEL_1067:
  a1[1] = (uint64_t *)v1126;
  v1150 = operator new();
  v1151 = v1150;
  *(_BYTE *)(v1150 + 31) = 4;
  *(_QWORD *)v1150 = off_1E0E17810;
  *(_QWORD *)(v1150 + 8) = 1818846563;
  v1153 = a1[1];
  v1152 = (unint64_t)a1[2];
  if ((unint64_t)v1153 < v1152)
  {
    *v1153 = v1150;
    v1154 = (uint64_t)(v1153 + 1);
    goto LABEL_1093;
  }
  v1155 = *a1;
  v1156 = (char *)v1153 - (char *)*a1;
  v1157 = v1156 >> 3;
  v1158 = (v1156 >> 3) + 1;
  if (v1158 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1159 = v1152 - (_QWORD)v1155;
  if (v1159 >> 2 > v1158)
    v1158 = v1159 >> 2;
  if ((unint64_t)v1159 >= 0x7FFFFFFFFFFFFFF8)
    v1160 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1160 = v1158;
  if (v1160)
  {
    if (v1160 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1161 = (char *)operator new(8 * v1160);
    v1162 = (uint64_t *)&v1161[8 * v1157];
    v1163 = (uint64_t *)&v1161[8 * v1160];
    *v1162 = v1151;
    v1154 = (uint64_t)(v1162 + 1);
    v1164 = (char *)((char *)v1153 - (char *)v1155);
    if (v1153 != v1155)
      goto LABEL_1078;
  }
  else
  {
    v1161 = 0;
    v1162 = (uint64_t *)(8 * v1157);
    v1163 = 0;
    *(_QWORD *)(8 * v1157) = v1151;
    v1154 = 8 * v1157 + 8;
    v1164 = (char *)((char *)v1153 - (char *)v1155);
    if (v1153 != v1155)
    {
LABEL_1078:
      v1165 = (unint64_t)(v1164 - 8);
      if (v1165 < 0x78
        || (uint64_t *)((char *)v1153 - (v1165 & 0xFFFFFFFFFFFFFFF8) - 8) < v1162
        && &v1161[v1156 - (v1165 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1153)
      {
        goto LABEL_2229;
      }
      v1166 = (v1165 >> 3) + 1;
      v1167 = 8 * (v1166 & 0x3FFFFFFFFFFFFFFCLL);
      v1162 = (uint64_t *)((char *)v1162 - v1167);
      v1168 = &v1153[v1167 / 0xFFFFFFFFFFFFFFF8];
      v1169 = v1153 - 2;
      v1170 = &v1161[8 * v1157 - 16];
      v1171 = v1166 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1173 = *((_OWORD *)v1169 - 1);
        v1172 = *(_OWORD *)v1169;
        *((_OWORD *)v1169 - 1) = 0uLL;
        *(_OWORD *)v1169 = 0uLL;
        *((_OWORD *)v1170 - 1) = v1173;
        *(_OWORD *)v1170 = v1172;
        v1169 -= 4;
        v1170 -= 32;
        v1171 -= 4;
      }
      while (v1171);
      v1153 = v1168;
      if (v1166 != (v1166 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2229:
        do
        {
          v1174 = *--v1153;
          *v1153 = 0;
          *--v1162 = v1174;
        }
        while (v1153 != v1155);
      }
      v1153 = *a1;
      v1175 = a1[1];
      *a1 = v1162;
      a1[1] = (uint64_t *)v1154;
      a1[2] = v1163;
      while (v1175 != v1153)
      {
        v1177 = *--v1175;
        v1176 = v1177;
        *v1175 = 0;
        if (v1177)
          (*(void (**)(uint64_t))(*(_QWORD *)v1176 + 8))(v1176);
      }
      goto LABEL_1091;
    }
  }
  *a1 = v1162;
  a1[1] = (uint64_t *)v1154;
  a1[2] = v1163;
LABEL_1091:
  if (v1153)
    operator delete(v1153);
LABEL_1093:
  a1[1] = (uint64_t *)v1154;
  v1178 = operator new();
  v1179 = v1178;
  *(_BYTE *)(v1178 + 31) = 3;
  *(_QWORD *)v1178 = off_1E0E17838;
  *(_QWORD *)(v1178 + 8) = 7565155;
  v1181 = a1[1];
  v1180 = (unint64_t)a1[2];
  if ((unint64_t)v1181 < v1180)
  {
    *v1181 = v1178;
    v1182 = (uint64_t)(v1181 + 1);
    goto LABEL_1119;
  }
  v1183 = *a1;
  v1184 = (char *)v1181 - (char *)*a1;
  v1185 = v1184 >> 3;
  v1186 = (v1184 >> 3) + 1;
  if (v1186 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1187 = v1180 - (_QWORD)v1183;
  if (v1187 >> 2 > v1186)
    v1186 = v1187 >> 2;
  if ((unint64_t)v1187 >= 0x7FFFFFFFFFFFFFF8)
    v1188 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1188 = v1186;
  if (v1188)
  {
    if (v1188 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1189 = (char *)operator new(8 * v1188);
    v1190 = (uint64_t *)&v1189[8 * v1185];
    v1191 = (uint64_t *)&v1189[8 * v1188];
    *v1190 = v1179;
    v1182 = (uint64_t)(v1190 + 1);
    v1192 = (char *)((char *)v1181 - (char *)v1183);
    if (v1181 != v1183)
      goto LABEL_1104;
  }
  else
  {
    v1189 = 0;
    v1190 = (uint64_t *)(8 * v1185);
    v1191 = 0;
    *(_QWORD *)(8 * v1185) = v1179;
    v1182 = 8 * v1185 + 8;
    v1192 = (char *)((char *)v1181 - (char *)v1183);
    if (v1181 != v1183)
    {
LABEL_1104:
      v1193 = (unint64_t)(v1192 - 8);
      if (v1193 < 0x78
        || (uint64_t *)((char *)v1181 - (v1193 & 0xFFFFFFFFFFFFFFF8) - 8) < v1190
        && &v1189[v1184 - (v1193 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1181)
      {
        goto LABEL_2230;
      }
      v1194 = (v1193 >> 3) + 1;
      v1195 = 8 * (v1194 & 0x3FFFFFFFFFFFFFFCLL);
      v1190 = (uint64_t *)((char *)v1190 - v1195);
      v1196 = &v1181[v1195 / 0xFFFFFFFFFFFFFFF8];
      v1197 = v1181 - 2;
      v1198 = &v1189[8 * v1185 - 16];
      v1199 = v1194 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1201 = *((_OWORD *)v1197 - 1);
        v1200 = *(_OWORD *)v1197;
        *((_OWORD *)v1197 - 1) = 0uLL;
        *(_OWORD *)v1197 = 0uLL;
        *((_OWORD *)v1198 - 1) = v1201;
        *(_OWORD *)v1198 = v1200;
        v1197 -= 4;
        v1198 -= 32;
        v1199 -= 4;
      }
      while (v1199);
      v1181 = v1196;
      if (v1194 != (v1194 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2230:
        do
        {
          v1202 = *--v1181;
          *v1181 = 0;
          *--v1190 = v1202;
        }
        while (v1181 != v1183);
      }
      v1181 = *a1;
      v1203 = a1[1];
      *a1 = v1190;
      a1[1] = (uint64_t *)v1182;
      a1[2] = v1191;
      while (v1203 != v1181)
      {
        v1205 = *--v1203;
        v1204 = v1205;
        *v1203 = 0;
        if (v1205)
          (*(void (**)(uint64_t))(*(_QWORD *)v1204 + 8))(v1204);
      }
      goto LABEL_1117;
    }
  }
  *a1 = v1190;
  a1[1] = (uint64_t *)v1182;
  a1[2] = v1191;
LABEL_1117:
  if (v1181)
    operator delete(v1181);
LABEL_1119:
  a1[1] = (uint64_t *)v1182;
  v1206 = operator new();
  v1207 = v1206;
  *(_BYTE *)(v1206 + 31) = 4;
  *(_QWORD *)v1206 = off_1E0E17860;
  *(_QWORD *)(v1206 + 8) = 1752395619;
  v1209 = a1[1];
  v1208 = (unint64_t)a1[2];
  if ((unint64_t)v1209 < v1208)
  {
    *v1209 = v1206;
    v1210 = (uint64_t)(v1209 + 1);
    goto LABEL_1145;
  }
  v1211 = *a1;
  v1212 = (char *)v1209 - (char *)*a1;
  v1213 = v1212 >> 3;
  v1214 = (v1212 >> 3) + 1;
  if (v1214 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1215 = v1208 - (_QWORD)v1211;
  if (v1215 >> 2 > v1214)
    v1214 = v1215 >> 2;
  if ((unint64_t)v1215 >= 0x7FFFFFFFFFFFFFF8)
    v1216 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1216 = v1214;
  if (v1216)
  {
    if (v1216 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1217 = (char *)operator new(8 * v1216);
    v1218 = (uint64_t *)&v1217[8 * v1213];
    v1219 = (uint64_t *)&v1217[8 * v1216];
    *v1218 = v1207;
    v1210 = (uint64_t)(v1218 + 1);
    v1220 = (char *)((char *)v1209 - (char *)v1211);
    if (v1209 != v1211)
      goto LABEL_1130;
  }
  else
  {
    v1217 = 0;
    v1218 = (uint64_t *)(8 * v1213);
    v1219 = 0;
    *(_QWORD *)(8 * v1213) = v1207;
    v1210 = 8 * v1213 + 8;
    v1220 = (char *)((char *)v1209 - (char *)v1211);
    if (v1209 != v1211)
    {
LABEL_1130:
      v1221 = (unint64_t)(v1220 - 8);
      if (v1221 < 0x78
        || (uint64_t *)((char *)v1209 - (v1221 & 0xFFFFFFFFFFFFFFF8) - 8) < v1218
        && &v1217[v1212 - (v1221 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1209)
      {
        goto LABEL_2231;
      }
      v1222 = (v1221 >> 3) + 1;
      v1223 = 8 * (v1222 & 0x3FFFFFFFFFFFFFFCLL);
      v1218 = (uint64_t *)((char *)v1218 - v1223);
      v1224 = &v1209[v1223 / 0xFFFFFFFFFFFFFFF8];
      v1225 = v1209 - 2;
      v1226 = &v1217[8 * v1213 - 16];
      v1227 = v1222 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1229 = *((_OWORD *)v1225 - 1);
        v1228 = *(_OWORD *)v1225;
        *((_OWORD *)v1225 - 1) = 0uLL;
        *(_OWORD *)v1225 = 0uLL;
        *((_OWORD *)v1226 - 1) = v1229;
        *(_OWORD *)v1226 = v1228;
        v1225 -= 4;
        v1226 -= 32;
        v1227 -= 4;
      }
      while (v1227);
      v1209 = v1224;
      if (v1222 != (v1222 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2231:
        do
        {
          v1230 = *--v1209;
          *v1209 = 0;
          *--v1218 = v1230;
        }
        while (v1209 != v1211);
      }
      v1209 = *a1;
      v1231 = a1[1];
      *a1 = v1218;
      a1[1] = (uint64_t *)v1210;
      a1[2] = v1219;
      while (v1231 != v1209)
      {
        v1233 = *--v1231;
        v1232 = v1233;
        *v1231 = 0;
        if (v1233)
          (*(void (**)(uint64_t))(*(_QWORD *)v1232 + 8))(v1232);
      }
      goto LABEL_1143;
    }
  }
  *a1 = v1218;
  a1[1] = (uint64_t *)v1210;
  a1[2] = v1219;
LABEL_1143:
  if (v1209)
    operator delete(v1209);
LABEL_1145:
  a1[1] = (uint64_t *)v1210;
  v1234 = operator new();
  v1235 = v1234;
  *(_BYTE *)(v1234 + 31) = 4;
  *(_QWORD *)v1234 = off_1E0E17888;
  *(_QWORD *)(v1234 + 8) = 1885957219;
  v1237 = a1[1];
  v1236 = (unint64_t)a1[2];
  if ((unint64_t)v1237 < v1236)
  {
    *v1237 = v1234;
    v1238 = (uint64_t)(v1237 + 1);
    goto LABEL_1171;
  }
  v1239 = *a1;
  v1240 = (char *)v1237 - (char *)*a1;
  v1241 = v1240 >> 3;
  v1242 = (v1240 >> 3) + 1;
  if (v1242 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1243 = v1236 - (_QWORD)v1239;
  if (v1243 >> 2 > v1242)
    v1242 = v1243 >> 2;
  if ((unint64_t)v1243 >= 0x7FFFFFFFFFFFFFF8)
    v1244 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1244 = v1242;
  if (v1244)
  {
    if (v1244 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1245 = (char *)operator new(8 * v1244);
    v1246 = (uint64_t *)&v1245[8 * v1241];
    v1247 = (uint64_t *)&v1245[8 * v1244];
    *v1246 = v1235;
    v1238 = (uint64_t)(v1246 + 1);
    v1248 = (char *)((char *)v1237 - (char *)v1239);
    if (v1237 != v1239)
      goto LABEL_1156;
  }
  else
  {
    v1245 = 0;
    v1246 = (uint64_t *)(8 * v1241);
    v1247 = 0;
    *(_QWORD *)(8 * v1241) = v1235;
    v1238 = 8 * v1241 + 8;
    v1248 = (char *)((char *)v1237 - (char *)v1239);
    if (v1237 != v1239)
    {
LABEL_1156:
      v1249 = (unint64_t)(v1248 - 8);
      if (v1249 < 0x78
        || (uint64_t *)((char *)v1237 - (v1249 & 0xFFFFFFFFFFFFFFF8) - 8) < v1246
        && &v1245[v1240 - (v1249 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1237)
      {
        goto LABEL_2232;
      }
      v1250 = (v1249 >> 3) + 1;
      v1251 = 8 * (v1250 & 0x3FFFFFFFFFFFFFFCLL);
      v1246 = (uint64_t *)((char *)v1246 - v1251);
      v1252 = &v1237[v1251 / 0xFFFFFFFFFFFFFFF8];
      v1253 = v1237 - 2;
      v1254 = &v1245[8 * v1241 - 16];
      v1255 = v1250 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1257 = *((_OWORD *)v1253 - 1);
        v1256 = *(_OWORD *)v1253;
        *((_OWORD *)v1253 - 1) = 0uLL;
        *(_OWORD *)v1253 = 0uLL;
        *((_OWORD *)v1254 - 1) = v1257;
        *(_OWORD *)v1254 = v1256;
        v1253 -= 4;
        v1254 -= 32;
        v1255 -= 4;
      }
      while (v1255);
      v1237 = v1252;
      if (v1250 != (v1250 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2232:
        do
        {
          v1258 = *--v1237;
          *v1237 = 0;
          *--v1246 = v1258;
        }
        while (v1237 != v1239);
      }
      v1237 = *a1;
      v1259 = a1[1];
      *a1 = v1246;
      a1[1] = (uint64_t *)v1238;
      a1[2] = v1247;
      while (v1259 != v1237)
      {
        v1261 = *--v1259;
        v1260 = v1261;
        *v1259 = 0;
        if (v1261)
          (*(void (**)(uint64_t))(*(_QWORD *)v1260 + 8))(v1260);
      }
      goto LABEL_1169;
    }
  }
  *a1 = v1246;
  a1[1] = (uint64_t *)v1238;
  a1[2] = v1247;
LABEL_1169:
  if (v1237)
    operator delete(v1237);
LABEL_1171:
  a1[1] = (uint64_t *)v1238;
  v1262 = operator new();
  v1263 = v1262;
  *(_BYTE *)(v1262 + 31) = 3;
  *(_QWORD *)v1262 = off_1E0E178B0;
  *(_QWORD *)(v1262 + 8) = 7370853;
  v1265 = a1[1];
  v1264 = (unint64_t)a1[2];
  if ((unint64_t)v1265 < v1264)
  {
    *v1265 = v1262;
    v1266 = (uint64_t)(v1265 + 1);
    goto LABEL_1197;
  }
  v1267 = *a1;
  v1268 = (char *)v1265 - (char *)*a1;
  v1269 = v1268 >> 3;
  v1270 = (v1268 >> 3) + 1;
  if (v1270 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1271 = v1264 - (_QWORD)v1267;
  if (v1271 >> 2 > v1270)
    v1270 = v1271 >> 2;
  if ((unint64_t)v1271 >= 0x7FFFFFFFFFFFFFF8)
    v1272 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1272 = v1270;
  if (v1272)
  {
    if (v1272 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1273 = (char *)operator new(8 * v1272);
    v1274 = (uint64_t *)&v1273[8 * v1269];
    v1275 = (uint64_t *)&v1273[8 * v1272];
    *v1274 = v1263;
    v1266 = (uint64_t)(v1274 + 1);
    v1276 = (char *)((char *)v1265 - (char *)v1267);
    if (v1265 != v1267)
      goto LABEL_1182;
  }
  else
  {
    v1273 = 0;
    v1274 = (uint64_t *)(8 * v1269);
    v1275 = 0;
    *(_QWORD *)(8 * v1269) = v1263;
    v1266 = 8 * v1269 + 8;
    v1276 = (char *)((char *)v1265 - (char *)v1267);
    if (v1265 != v1267)
    {
LABEL_1182:
      v1277 = (unint64_t)(v1276 - 8);
      if (v1277 < 0x78
        || (uint64_t *)((char *)v1265 - (v1277 & 0xFFFFFFFFFFFFFFF8) - 8) < v1274
        && &v1273[v1268 - (v1277 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1265)
      {
        goto LABEL_2233;
      }
      v1278 = (v1277 >> 3) + 1;
      v1279 = 8 * (v1278 & 0x3FFFFFFFFFFFFFFCLL);
      v1274 = (uint64_t *)((char *)v1274 - v1279);
      v1280 = &v1265[v1279 / 0xFFFFFFFFFFFFFFF8];
      v1281 = v1265 - 2;
      v1282 = &v1273[8 * v1269 - 16];
      v1283 = v1278 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1285 = *((_OWORD *)v1281 - 1);
        v1284 = *(_OWORD *)v1281;
        *((_OWORD *)v1281 - 1) = 0uLL;
        *(_OWORD *)v1281 = 0uLL;
        *((_OWORD *)v1282 - 1) = v1285;
        *(_OWORD *)v1282 = v1284;
        v1281 -= 4;
        v1282 -= 32;
        v1283 -= 4;
      }
      while (v1283);
      v1265 = v1280;
      if (v1278 != (v1278 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2233:
        do
        {
          v1286 = *--v1265;
          *v1265 = 0;
          *--v1274 = v1286;
        }
        while (v1265 != v1267);
      }
      v1265 = *a1;
      v1287 = a1[1];
      *a1 = v1274;
      a1[1] = (uint64_t *)v1266;
      a1[2] = v1275;
      while (v1287 != v1265)
      {
        v1289 = *--v1287;
        v1288 = v1289;
        *v1287 = 0;
        if (v1289)
          (*(void (**)(uint64_t))(*(_QWORD *)v1288 + 8))(v1288);
      }
      goto LABEL_1195;
    }
  }
  *a1 = v1274;
  a1[1] = (uint64_t *)v1266;
  a1[2] = v1275;
LABEL_1195:
  if (v1265)
    operator delete(v1265);
LABEL_1197:
  a1[1] = (uint64_t *)v1266;
  v1290 = operator new();
  v1291 = v1290;
  *(_BYTE *)(v1290 + 31) = 4;
  *(_QWORD *)v1290 = off_1E0E178D8;
  *(_QWORD *)(v1290 + 8) = 846231653;
  v1293 = a1[1];
  v1292 = (unint64_t)a1[2];
  if ((unint64_t)v1293 < v1292)
  {
    *v1293 = v1290;
    v1294 = (uint64_t)(v1293 + 1);
    goto LABEL_1223;
  }
  v1295 = *a1;
  v1296 = (char *)v1293 - (char *)*a1;
  v1297 = v1296 >> 3;
  v1298 = (v1296 >> 3) + 1;
  if (v1298 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1299 = v1292 - (_QWORD)v1295;
  if (v1299 >> 2 > v1298)
    v1298 = v1299 >> 2;
  if ((unint64_t)v1299 >= 0x7FFFFFFFFFFFFFF8)
    v1300 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1300 = v1298;
  if (v1300)
  {
    if (v1300 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1301 = (char *)operator new(8 * v1300);
    v1302 = (uint64_t *)&v1301[8 * v1297];
    v1303 = (uint64_t *)&v1301[8 * v1300];
    *v1302 = v1291;
    v1294 = (uint64_t)(v1302 + 1);
    v1304 = (char *)((char *)v1293 - (char *)v1295);
    if (v1293 != v1295)
      goto LABEL_1208;
  }
  else
  {
    v1301 = 0;
    v1302 = (uint64_t *)(8 * v1297);
    v1303 = 0;
    *(_QWORD *)(8 * v1297) = v1291;
    v1294 = 8 * v1297 + 8;
    v1304 = (char *)((char *)v1293 - (char *)v1295);
    if (v1293 != v1295)
    {
LABEL_1208:
      v1305 = (unint64_t)(v1304 - 8);
      if (v1305 < 0x78
        || (uint64_t *)((char *)v1293 - (v1305 & 0xFFFFFFFFFFFFFFF8) - 8) < v1302
        && &v1301[v1296 - (v1305 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1293)
      {
        goto LABEL_2234;
      }
      v1306 = (v1305 >> 3) + 1;
      v1307 = 8 * (v1306 & 0x3FFFFFFFFFFFFFFCLL);
      v1302 = (uint64_t *)((char *)v1302 - v1307);
      v1308 = &v1293[v1307 / 0xFFFFFFFFFFFFFFF8];
      v1309 = v1293 - 2;
      v1310 = &v1301[8 * v1297 - 16];
      v1311 = v1306 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1313 = *((_OWORD *)v1309 - 1);
        v1312 = *(_OWORD *)v1309;
        *((_OWORD *)v1309 - 1) = 0uLL;
        *(_OWORD *)v1309 = 0uLL;
        *((_OWORD *)v1310 - 1) = v1313;
        *(_OWORD *)v1310 = v1312;
        v1309 -= 4;
        v1310 -= 32;
        v1311 -= 4;
      }
      while (v1311);
      v1293 = v1308;
      if (v1306 != (v1306 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2234:
        do
        {
          v1314 = *--v1293;
          *v1293 = 0;
          *--v1302 = v1314;
        }
        while (v1293 != v1295);
      }
      v1293 = *a1;
      v1315 = a1[1];
      *a1 = v1302;
      a1[1] = (uint64_t *)v1294;
      a1[2] = v1303;
      while (v1315 != v1293)
      {
        v1317 = *--v1315;
        v1316 = v1317;
        *v1315 = 0;
        if (v1317)
          (*(void (**)(uint64_t))(*(_QWORD *)v1316 + 8))(v1316);
      }
      goto LABEL_1221;
    }
  }
  *a1 = v1302;
  a1[1] = (uint64_t *)v1294;
  a1[2] = v1303;
LABEL_1221:
  if (v1293)
    operator delete(v1293);
LABEL_1223:
  a1[1] = (uint64_t *)v1294;
  v1318 = operator new();
  v1319 = v1318;
  *(_BYTE *)(v1318 + 31) = 5;
  *(_QWORD *)v1318 = off_1E0E17900;
  *(_QWORD *)(v1318 + 8) = 0x726F6F6C66;
  v1321 = a1[1];
  v1320 = (unint64_t)a1[2];
  if ((unint64_t)v1321 < v1320)
  {
    *v1321 = v1318;
    v1322 = (uint64_t)(v1321 + 1);
    goto LABEL_1249;
  }
  v1323 = *a1;
  v1324 = (char *)v1321 - (char *)*a1;
  v1325 = v1324 >> 3;
  v1326 = (v1324 >> 3) + 1;
  if (v1326 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1327 = v1320 - (_QWORD)v1323;
  if (v1327 >> 2 > v1326)
    v1326 = v1327 >> 2;
  if ((unint64_t)v1327 >= 0x7FFFFFFFFFFFFFF8)
    v1328 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1328 = v1326;
  if (v1328)
  {
    if (v1328 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1329 = (char *)operator new(8 * v1328);
    v1330 = (uint64_t *)&v1329[8 * v1325];
    v1331 = (uint64_t *)&v1329[8 * v1328];
    *v1330 = v1319;
    v1322 = (uint64_t)(v1330 + 1);
    v1332 = (char *)((char *)v1321 - (char *)v1323);
    if (v1321 != v1323)
      goto LABEL_1234;
  }
  else
  {
    v1329 = 0;
    v1330 = (uint64_t *)(8 * v1325);
    v1331 = 0;
    *(_QWORD *)(8 * v1325) = v1319;
    v1322 = 8 * v1325 + 8;
    v1332 = (char *)((char *)v1321 - (char *)v1323);
    if (v1321 != v1323)
    {
LABEL_1234:
      v1333 = (unint64_t)(v1332 - 8);
      if (v1333 < 0x78
        || (uint64_t *)((char *)v1321 - (v1333 & 0xFFFFFFFFFFFFFFF8) - 8) < v1330
        && &v1329[v1324 - (v1333 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1321)
      {
        goto LABEL_2235;
      }
      v1334 = (v1333 >> 3) + 1;
      v1335 = 8 * (v1334 & 0x3FFFFFFFFFFFFFFCLL);
      v1330 = (uint64_t *)((char *)v1330 - v1335);
      v1336 = &v1321[v1335 / 0xFFFFFFFFFFFFFFF8];
      v1337 = v1321 - 2;
      v1338 = &v1329[8 * v1325 - 16];
      v1339 = v1334 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1341 = *((_OWORD *)v1337 - 1);
        v1340 = *(_OWORD *)v1337;
        *((_OWORD *)v1337 - 1) = 0uLL;
        *(_OWORD *)v1337 = 0uLL;
        *((_OWORD *)v1338 - 1) = v1341;
        *(_OWORD *)v1338 = v1340;
        v1337 -= 4;
        v1338 -= 32;
        v1339 -= 4;
      }
      while (v1339);
      v1321 = v1336;
      if (v1334 != (v1334 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2235:
        do
        {
          v1342 = *--v1321;
          *v1321 = 0;
          *--v1330 = v1342;
        }
        while (v1321 != v1323);
      }
      v1321 = *a1;
      v1343 = a1[1];
      *a1 = v1330;
      a1[1] = (uint64_t *)v1322;
      a1[2] = v1331;
      while (v1343 != v1321)
      {
        v1345 = *--v1343;
        v1344 = v1345;
        *v1343 = 0;
        if (v1345)
          (*(void (**)(uint64_t))(*(_QWORD *)v1344 + 8))(v1344);
      }
      goto LABEL_1247;
    }
  }
  *a1 = v1330;
  a1[1] = (uint64_t *)v1322;
  a1[2] = v1331;
LABEL_1247:
  if (v1321)
    operator delete(v1321);
LABEL_1249:
  a1[1] = (uint64_t *)v1322;
  v1346 = operator new();
  v1347 = v1346;
  *(_QWORD *)(v1346 + 8) = 0x5F6C616369676F6CLL;
  *(_QWORD *)(v1346 + 16) = 7630702;
  *(_BYTE *)(v1346 + 31) = 11;
  *(_QWORD *)v1346 = off_1E0E17928;
  v1349 = a1[1];
  v1348 = (unint64_t)a1[2];
  if ((unint64_t)v1349 < v1348)
  {
    *v1349 = v1346;
    v1350 = (uint64_t)(v1349 + 1);
    goto LABEL_1275;
  }
  v1351 = *a1;
  v1352 = (char *)v1349 - (char *)*a1;
  v1353 = v1352 >> 3;
  v1354 = (v1352 >> 3) + 1;
  if (v1354 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1355 = v1348 - (_QWORD)v1351;
  if (v1355 >> 2 > v1354)
    v1354 = v1355 >> 2;
  if ((unint64_t)v1355 >= 0x7FFFFFFFFFFFFFF8)
    v1356 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1356 = v1354;
  if (v1356)
  {
    if (v1356 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1357 = (char *)operator new(8 * v1356);
    v1358 = (uint64_t *)&v1357[8 * v1353];
    v1359 = (uint64_t *)&v1357[8 * v1356];
    *v1358 = v1347;
    v1350 = (uint64_t)(v1358 + 1);
    v1360 = (char *)((char *)v1349 - (char *)v1351);
    if (v1349 != v1351)
      goto LABEL_1260;
  }
  else
  {
    v1357 = 0;
    v1358 = (uint64_t *)(8 * v1353);
    v1359 = 0;
    *(_QWORD *)(8 * v1353) = v1347;
    v1350 = 8 * v1353 + 8;
    v1360 = (char *)((char *)v1349 - (char *)v1351);
    if (v1349 != v1351)
    {
LABEL_1260:
      v1361 = (unint64_t)(v1360 - 8);
      if (v1361 < 0x78
        || (uint64_t *)((char *)v1349 - (v1361 & 0xFFFFFFFFFFFFFFF8) - 8) < v1358
        && &v1357[v1352 - (v1361 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1349)
      {
        goto LABEL_2236;
      }
      v1362 = (v1361 >> 3) + 1;
      v1363 = 8 * (v1362 & 0x3FFFFFFFFFFFFFFCLL);
      v1358 = (uint64_t *)((char *)v1358 - v1363);
      v1364 = &v1349[v1363 / 0xFFFFFFFFFFFFFFF8];
      v1365 = v1349 - 2;
      v1366 = &v1357[8 * v1353 - 16];
      v1367 = v1362 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1369 = *((_OWORD *)v1365 - 1);
        v1368 = *(_OWORD *)v1365;
        *((_OWORD *)v1365 - 1) = 0uLL;
        *(_OWORD *)v1365 = 0uLL;
        *((_OWORD *)v1366 - 1) = v1369;
        *(_OWORD *)v1366 = v1368;
        v1365 -= 4;
        v1366 -= 32;
        v1367 -= 4;
      }
      while (v1367);
      v1349 = v1364;
      if (v1362 != (v1362 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2236:
        do
        {
          v1370 = *--v1349;
          *v1349 = 0;
          *--v1358 = v1370;
        }
        while (v1349 != v1351);
      }
      v1349 = *a1;
      v1371 = a1[1];
      *a1 = v1358;
      a1[1] = (uint64_t *)v1350;
      a1[2] = v1359;
      while (v1371 != v1349)
      {
        v1373 = *--v1371;
        v1372 = v1373;
        *v1371 = 0;
        if (v1373)
          (*(void (**)(uint64_t))(*(_QWORD *)v1372 + 8))(v1372);
      }
      goto LABEL_1273;
    }
  }
  *a1 = v1358;
  a1[1] = (uint64_t *)v1350;
  a1[2] = v1359;
LABEL_1273:
  if (v1349)
    operator delete(v1349);
LABEL_1275:
  a1[1] = (uint64_t *)v1350;
  v1374 = operator new();
  v1375 = v1374;
  *(_BYTE *)(v1374 + 31) = 5;
  *(_QWORD *)v1374 = off_1E0E17950;
  *(_QWORD *)(v1374 + 8) = 0x646E756F72;
  v1377 = a1[1];
  v1376 = (unint64_t)a1[2];
  if ((unint64_t)v1377 < v1376)
  {
    *v1377 = v1374;
    v1378 = (uint64_t)(v1377 + 1);
    goto LABEL_1301;
  }
  v1379 = *a1;
  v1380 = (char *)v1377 - (char *)*a1;
  v1381 = v1380 >> 3;
  v1382 = (v1380 >> 3) + 1;
  if (v1382 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1383 = v1376 - (_QWORD)v1379;
  if (v1383 >> 2 > v1382)
    v1382 = v1383 >> 2;
  if ((unint64_t)v1383 >= 0x7FFFFFFFFFFFFFF8)
    v1384 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1384 = v1382;
  if (v1384)
  {
    if (v1384 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1385 = (char *)operator new(8 * v1384);
    v1386 = (uint64_t *)&v1385[8 * v1381];
    v1387 = (uint64_t *)&v1385[8 * v1384];
    *v1386 = v1375;
    v1378 = (uint64_t)(v1386 + 1);
    v1388 = (char *)((char *)v1377 - (char *)v1379);
    if (v1377 != v1379)
      goto LABEL_1286;
  }
  else
  {
    v1385 = 0;
    v1386 = (uint64_t *)(8 * v1381);
    v1387 = 0;
    *(_QWORD *)(8 * v1381) = v1375;
    v1378 = 8 * v1381 + 8;
    v1388 = (char *)((char *)v1377 - (char *)v1379);
    if (v1377 != v1379)
    {
LABEL_1286:
      v1389 = (unint64_t)(v1388 - 8);
      if (v1389 < 0x78
        || (uint64_t *)((char *)v1377 - (v1389 & 0xFFFFFFFFFFFFFFF8) - 8) < v1386
        && &v1385[v1380 - (v1389 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1377)
      {
        goto LABEL_2237;
      }
      v1390 = (v1389 >> 3) + 1;
      v1391 = 8 * (v1390 & 0x3FFFFFFFFFFFFFFCLL);
      v1386 = (uint64_t *)((char *)v1386 - v1391);
      v1392 = &v1377[v1391 / 0xFFFFFFFFFFFFFFF8];
      v1393 = v1377 - 2;
      v1394 = &v1385[8 * v1381 - 16];
      v1395 = v1390 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1397 = *((_OWORD *)v1393 - 1);
        v1396 = *(_OWORD *)v1393;
        *((_OWORD *)v1393 - 1) = 0uLL;
        *(_OWORD *)v1393 = 0uLL;
        *((_OWORD *)v1394 - 1) = v1397;
        *(_OWORD *)v1394 = v1396;
        v1393 -= 4;
        v1394 -= 32;
        v1395 -= 4;
      }
      while (v1395);
      v1377 = v1392;
      if (v1390 != (v1390 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2237:
        do
        {
          v1398 = *--v1377;
          *v1377 = 0;
          *--v1386 = v1398;
        }
        while (v1377 != v1379);
      }
      v1377 = *a1;
      v1399 = a1[1];
      *a1 = v1386;
      a1[1] = (uint64_t *)v1378;
      a1[2] = v1387;
      while (v1399 != v1377)
      {
        v1401 = *--v1399;
        v1400 = v1401;
        *v1399 = 0;
        if (v1401)
          (*(void (**)(uint64_t))(*(_QWORD *)v1400 + 8))(v1400);
      }
      goto LABEL_1299;
    }
  }
  *a1 = v1386;
  a1[1] = (uint64_t *)v1378;
  a1[2] = v1387;
LABEL_1299:
  if (v1377)
    operator delete(v1377);
LABEL_1301:
  a1[1] = (uint64_t *)v1378;
  v1402 = operator new();
  v1403 = v1402;
  *(_BYTE *)(v1402 + 31) = 4;
  *(_QWORD *)v1402 = off_1E0E17978;
  *(_QWORD *)(v1402 + 8) = 1852270963;
  v1405 = a1[1];
  v1404 = (unint64_t)a1[2];
  if ((unint64_t)v1405 < v1404)
  {
    *v1405 = v1402;
    v1406 = (uint64_t)(v1405 + 1);
    goto LABEL_1327;
  }
  v1407 = *a1;
  v1408 = (char *)v1405 - (char *)*a1;
  v1409 = v1408 >> 3;
  v1410 = (v1408 >> 3) + 1;
  if (v1410 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1411 = v1404 - (_QWORD)v1407;
  if (v1411 >> 2 > v1410)
    v1410 = v1411 >> 2;
  if ((unint64_t)v1411 >= 0x7FFFFFFFFFFFFFF8)
    v1412 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1412 = v1410;
  if (v1412)
  {
    if (v1412 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1413 = (char *)operator new(8 * v1412);
    v1414 = (uint64_t *)&v1413[8 * v1409];
    v1415 = (uint64_t *)&v1413[8 * v1412];
    *v1414 = v1403;
    v1406 = (uint64_t)(v1414 + 1);
    v1416 = (char *)((char *)v1405 - (char *)v1407);
    if (v1405 != v1407)
      goto LABEL_1312;
  }
  else
  {
    v1413 = 0;
    v1414 = (uint64_t *)(8 * v1409);
    v1415 = 0;
    *(_QWORD *)(8 * v1409) = v1403;
    v1406 = 8 * v1409 + 8;
    v1416 = (char *)((char *)v1405 - (char *)v1407);
    if (v1405 != v1407)
    {
LABEL_1312:
      v1417 = (unint64_t)(v1416 - 8);
      if (v1417 < 0x78
        || (uint64_t *)((char *)v1405 - (v1417 & 0xFFFFFFFFFFFFFFF8) - 8) < v1414
        && &v1413[v1408 - (v1417 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1405)
      {
        goto LABEL_2238;
      }
      v1418 = (v1417 >> 3) + 1;
      v1419 = 8 * (v1418 & 0x3FFFFFFFFFFFFFFCLL);
      v1414 = (uint64_t *)((char *)v1414 - v1419);
      v1420 = &v1405[v1419 / 0xFFFFFFFFFFFFFFF8];
      v1421 = v1405 - 2;
      v1422 = &v1413[8 * v1409 - 16];
      v1423 = v1418 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1425 = *((_OWORD *)v1421 - 1);
        v1424 = *(_OWORD *)v1421;
        *((_OWORD *)v1421 - 1) = 0uLL;
        *(_OWORD *)v1421 = 0uLL;
        *((_OWORD *)v1422 - 1) = v1425;
        *(_OWORD *)v1422 = v1424;
        v1421 -= 4;
        v1422 -= 32;
        v1423 -= 4;
      }
      while (v1423);
      v1405 = v1420;
      if (v1418 != (v1418 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2238:
        do
        {
          v1426 = *--v1405;
          *v1405 = 0;
          *--v1414 = v1426;
        }
        while (v1405 != v1407);
      }
      v1405 = *a1;
      v1427 = a1[1];
      *a1 = v1414;
      a1[1] = (uint64_t *)v1406;
      a1[2] = v1415;
      while (v1427 != v1405)
      {
        v1429 = *--v1427;
        v1428 = v1429;
        *v1427 = 0;
        if (v1429)
          (*(void (**)(uint64_t))(*(_QWORD *)v1428 + 8))(v1428);
      }
      goto LABEL_1325;
    }
  }
  *a1 = v1414;
  a1[1] = (uint64_t *)v1406;
  a1[2] = v1415;
LABEL_1325:
  if (v1405)
    operator delete(v1405);
LABEL_1327:
  a1[1] = (uint64_t *)v1406;
  v1430 = operator new();
  v1431 = v1430;
  *(_BYTE *)(v1430 + 31) = 3;
  *(_QWORD *)v1430 = off_1E0E179A0;
  *(_QWORD *)(v1430 + 8) = 7235955;
  v1433 = a1[1];
  v1432 = (unint64_t)a1[2];
  if ((unint64_t)v1433 < v1432)
  {
    *v1433 = v1430;
    v1434 = (uint64_t)(v1433 + 1);
    goto LABEL_1353;
  }
  v1435 = *a1;
  v1436 = (char *)v1433 - (char *)*a1;
  v1437 = v1436 >> 3;
  v1438 = (v1436 >> 3) + 1;
  if (v1438 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1439 = v1432 - (_QWORD)v1435;
  if (v1439 >> 2 > v1438)
    v1438 = v1439 >> 2;
  if ((unint64_t)v1439 >= 0x7FFFFFFFFFFFFFF8)
    v1440 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1440 = v1438;
  if (v1440)
  {
    if (v1440 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1441 = (char *)operator new(8 * v1440);
    v1442 = (uint64_t *)&v1441[8 * v1437];
    v1443 = (uint64_t *)&v1441[8 * v1440];
    *v1442 = v1431;
    v1434 = (uint64_t)(v1442 + 1);
    v1444 = (char *)((char *)v1433 - (char *)v1435);
    if (v1433 != v1435)
      goto LABEL_1338;
  }
  else
  {
    v1441 = 0;
    v1442 = (uint64_t *)(8 * v1437);
    v1443 = 0;
    *(_QWORD *)(8 * v1437) = v1431;
    v1434 = 8 * v1437 + 8;
    v1444 = (char *)((char *)v1433 - (char *)v1435);
    if (v1433 != v1435)
    {
LABEL_1338:
      v1445 = (unint64_t)(v1444 - 8);
      if (v1445 < 0x78
        || (uint64_t *)((char *)v1433 - (v1445 & 0xFFFFFFFFFFFFFFF8) - 8) < v1442
        && &v1441[v1436 - (v1445 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1433)
      {
        goto LABEL_2239;
      }
      v1446 = (v1445 >> 3) + 1;
      v1447 = 8 * (v1446 & 0x3FFFFFFFFFFFFFFCLL);
      v1442 = (uint64_t *)((char *)v1442 - v1447);
      v1448 = &v1433[v1447 / 0xFFFFFFFFFFFFFFF8];
      v1449 = v1433 - 2;
      v1450 = &v1441[8 * v1437 - 16];
      v1451 = v1446 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1453 = *((_OWORD *)v1449 - 1);
        v1452 = *(_OWORD *)v1449;
        *((_OWORD *)v1449 - 1) = 0uLL;
        *(_OWORD *)v1449 = 0uLL;
        *((_OWORD *)v1450 - 1) = v1453;
        *(_OWORD *)v1450 = v1452;
        v1449 -= 4;
        v1450 -= 32;
        v1451 -= 4;
      }
      while (v1451);
      v1433 = v1448;
      if (v1446 != (v1446 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2239:
        do
        {
          v1454 = *--v1433;
          *v1433 = 0;
          *--v1442 = v1454;
        }
        while (v1433 != v1435);
      }
      v1433 = *a1;
      v1455 = a1[1];
      *a1 = v1442;
      a1[1] = (uint64_t *)v1434;
      a1[2] = v1443;
      while (v1455 != v1433)
      {
        v1457 = *--v1455;
        v1456 = v1457;
        *v1455 = 0;
        if (v1457)
          (*(void (**)(uint64_t))(*(_QWORD *)v1456 + 8))(v1456);
      }
      goto LABEL_1351;
    }
  }
  *a1 = v1442;
  a1[1] = (uint64_t *)v1434;
  a1[2] = v1443;
LABEL_1351:
  if (v1433)
    operator delete(v1433);
LABEL_1353:
  a1[1] = (uint64_t *)v1434;
  v1458 = operator new();
  v1459 = v1458;
  *(_BYTE *)(v1458 + 31) = 4;
  *(_QWORD *)v1458 = off_1E0E179C8;
  *(_QWORD *)(v1458 + 8) = 1752066419;
  v1461 = a1[1];
  v1460 = (unint64_t)a1[2];
  if ((unint64_t)v1461 < v1460)
  {
    *v1461 = v1458;
    v1462 = (uint64_t)(v1461 + 1);
    goto LABEL_1379;
  }
  v1463 = *a1;
  v1464 = (char *)v1461 - (char *)*a1;
  v1465 = v1464 >> 3;
  v1466 = (v1464 >> 3) + 1;
  if (v1466 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1467 = v1460 - (_QWORD)v1463;
  if (v1467 >> 2 > v1466)
    v1466 = v1467 >> 2;
  if ((unint64_t)v1467 >= 0x7FFFFFFFFFFFFFF8)
    v1468 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1468 = v1466;
  if (v1468)
  {
    if (v1468 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1469 = (char *)operator new(8 * v1468);
    v1470 = (uint64_t *)&v1469[8 * v1465];
    v1471 = (uint64_t *)&v1469[8 * v1468];
    *v1470 = v1459;
    v1462 = (uint64_t)(v1470 + 1);
    v1472 = (char *)((char *)v1461 - (char *)v1463);
    if (v1461 != v1463)
      goto LABEL_1364;
  }
  else
  {
    v1469 = 0;
    v1470 = (uint64_t *)(8 * v1465);
    v1471 = 0;
    *(_QWORD *)(8 * v1465) = v1459;
    v1462 = 8 * v1465 + 8;
    v1472 = (char *)((char *)v1461 - (char *)v1463);
    if (v1461 != v1463)
    {
LABEL_1364:
      v1473 = (unint64_t)(v1472 - 8);
      if (v1473 < 0x78
        || (uint64_t *)((char *)v1461 - (v1473 & 0xFFFFFFFFFFFFFFF8) - 8) < v1470
        && &v1469[v1464 - (v1473 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1461)
      {
        goto LABEL_2240;
      }
      v1474 = (v1473 >> 3) + 1;
      v1475 = 8 * (v1474 & 0x3FFFFFFFFFFFFFFCLL);
      v1470 = (uint64_t *)((char *)v1470 - v1475);
      v1476 = &v1461[v1475 / 0xFFFFFFFFFFFFFFF8];
      v1477 = v1461 - 2;
      v1478 = &v1469[8 * v1465 - 16];
      v1479 = v1474 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1481 = *((_OWORD *)v1477 - 1);
        v1480 = *(_OWORD *)v1477;
        *((_OWORD *)v1477 - 1) = 0uLL;
        *(_OWORD *)v1477 = 0uLL;
        *((_OWORD *)v1478 - 1) = v1481;
        *(_OWORD *)v1478 = v1480;
        v1477 -= 4;
        v1478 -= 32;
        v1479 -= 4;
      }
      while (v1479);
      v1461 = v1476;
      if (v1474 != (v1474 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2240:
        do
        {
          v1482 = *--v1461;
          *v1461 = 0;
          *--v1470 = v1482;
        }
        while (v1461 != v1463);
      }
      v1461 = *a1;
      v1483 = a1[1];
      *a1 = v1470;
      a1[1] = (uint64_t *)v1462;
      a1[2] = v1471;
      while (v1483 != v1461)
      {
        v1485 = *--v1483;
        v1484 = v1485;
        *v1483 = 0;
        if (v1485)
          (*(void (**)(uint64_t))(*(_QWORD *)v1484 + 8))(v1484);
      }
      goto LABEL_1377;
    }
  }
  *a1 = v1470;
  a1[1] = (uint64_t *)v1462;
  a1[2] = v1471;
LABEL_1377:
  if (v1461)
    operator delete(v1461);
LABEL_1379:
  a1[1] = (uint64_t *)v1462;
  v1486 = operator new();
  v1487 = v1486;
  *(_BYTE *)(v1486 + 31) = 4;
  *(_QWORD *)v1486 = off_1E0E179F0;
  *(_QWORD *)(v1486 + 8) = 1953657203;
  v1489 = a1[1];
  v1488 = (unint64_t)a1[2];
  if ((unint64_t)v1489 < v1488)
  {
    *v1489 = v1486;
    v1490 = (uint64_t)(v1489 + 1);
    goto LABEL_1405;
  }
  v1491 = *a1;
  v1492 = (char *)v1489 - (char *)*a1;
  v1493 = v1492 >> 3;
  v1494 = (v1492 >> 3) + 1;
  if (v1494 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1495 = v1488 - (_QWORD)v1491;
  if (v1495 >> 2 > v1494)
    v1494 = v1495 >> 2;
  if ((unint64_t)v1495 >= 0x7FFFFFFFFFFFFFF8)
    v1496 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1496 = v1494;
  if (v1496)
  {
    if (v1496 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1497 = (char *)operator new(8 * v1496);
    v1498 = (uint64_t *)&v1497[8 * v1493];
    v1499 = (uint64_t *)&v1497[8 * v1496];
    *v1498 = v1487;
    v1490 = (uint64_t)(v1498 + 1);
    v1500 = (char *)((char *)v1489 - (char *)v1491);
    if (v1489 != v1491)
      goto LABEL_1390;
  }
  else
  {
    v1497 = 0;
    v1498 = (uint64_t *)(8 * v1493);
    v1499 = 0;
    *(_QWORD *)(8 * v1493) = v1487;
    v1490 = 8 * v1493 + 8;
    v1500 = (char *)((char *)v1489 - (char *)v1491);
    if (v1489 != v1491)
    {
LABEL_1390:
      v1501 = (unint64_t)(v1500 - 8);
      if (v1501 < 0x78
        || (uint64_t *)((char *)v1489 - (v1501 & 0xFFFFFFFFFFFFFFF8) - 8) < v1498
        && &v1497[v1492 - (v1501 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1489)
      {
        goto LABEL_2241;
      }
      v1502 = (v1501 >> 3) + 1;
      v1503 = 8 * (v1502 & 0x3FFFFFFFFFFFFFFCLL);
      v1498 = (uint64_t *)((char *)v1498 - v1503);
      v1504 = &v1489[v1503 / 0xFFFFFFFFFFFFFFF8];
      v1505 = v1489 - 2;
      v1506 = &v1497[8 * v1493 - 16];
      v1507 = v1502 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1509 = *((_OWORD *)v1505 - 1);
        v1508 = *(_OWORD *)v1505;
        *((_OWORD *)v1505 - 1) = 0uLL;
        *(_OWORD *)v1505 = 0uLL;
        *((_OWORD *)v1506 - 1) = v1509;
        *(_OWORD *)v1506 = v1508;
        v1505 -= 4;
        v1506 -= 32;
        v1507 -= 4;
      }
      while (v1507);
      v1489 = v1504;
      if (v1502 != (v1502 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2241:
        do
        {
          v1510 = *--v1489;
          *v1489 = 0;
          *--v1498 = v1510;
        }
        while (v1489 != v1491);
      }
      v1489 = *a1;
      v1511 = a1[1];
      *a1 = v1498;
      a1[1] = (uint64_t *)v1490;
      a1[2] = v1499;
      while (v1511 != v1489)
      {
        v1513 = *--v1511;
        v1512 = v1513;
        *v1511 = 0;
        if (v1513)
          (*(void (**)(uint64_t))(*(_QWORD *)v1512 + 8))(v1512);
      }
      goto LABEL_1403;
    }
  }
  *a1 = v1498;
  a1[1] = (uint64_t *)v1490;
  a1[2] = v1499;
LABEL_1403:
  if (v1489)
    operator delete(v1489);
LABEL_1405:
  a1[1] = (uint64_t *)v1490;
  v1514 = operator new();
  v1515 = v1514;
  *(_BYTE *)(v1514 + 31) = 6;
  *(_QWORD *)v1514 = off_1E0E17A18;
  *(_QWORD *)(v1514 + 8) = 0x657261757173;
  v1517 = a1[1];
  v1516 = (unint64_t)a1[2];
  if ((unint64_t)v1517 < v1516)
  {
    *v1517 = v1514;
    v1518 = (uint64_t)(v1517 + 1);
    goto LABEL_1431;
  }
  v1519 = *a1;
  v1520 = (char *)v1517 - (char *)*a1;
  v1521 = v1520 >> 3;
  v1522 = (v1520 >> 3) + 1;
  if (v1522 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1523 = v1516 - (_QWORD)v1519;
  if (v1523 >> 2 > v1522)
    v1522 = v1523 >> 2;
  if ((unint64_t)v1523 >= 0x7FFFFFFFFFFFFFF8)
    v1524 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1524 = v1522;
  if (v1524)
  {
    if (v1524 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1525 = (char *)operator new(8 * v1524);
    v1526 = (uint64_t *)&v1525[8 * v1521];
    v1527 = (uint64_t *)&v1525[8 * v1524];
    *v1526 = v1515;
    v1518 = (uint64_t)(v1526 + 1);
    v1528 = (char *)((char *)v1517 - (char *)v1519);
    if (v1517 != v1519)
      goto LABEL_1416;
  }
  else
  {
    v1525 = 0;
    v1526 = (uint64_t *)(8 * v1521);
    v1527 = 0;
    *(_QWORD *)(8 * v1521) = v1515;
    v1518 = 8 * v1521 + 8;
    v1528 = (char *)((char *)v1517 - (char *)v1519);
    if (v1517 != v1519)
    {
LABEL_1416:
      v1529 = (unint64_t)(v1528 - 8);
      if (v1529 < 0x78
        || (uint64_t *)((char *)v1517 - (v1529 & 0xFFFFFFFFFFFFFFF8) - 8) < v1526
        && &v1525[v1520 - (v1529 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1517)
      {
        goto LABEL_2242;
      }
      v1530 = (v1529 >> 3) + 1;
      v1531 = 8 * (v1530 & 0x3FFFFFFFFFFFFFFCLL);
      v1526 = (uint64_t *)((char *)v1526 - v1531);
      v1532 = &v1517[v1531 / 0xFFFFFFFFFFFFFFF8];
      v1533 = v1517 - 2;
      v1534 = &v1525[8 * v1521 - 16];
      v1535 = v1530 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1537 = *((_OWORD *)v1533 - 1);
        v1536 = *(_OWORD *)v1533;
        *((_OWORD *)v1533 - 1) = 0uLL;
        *(_OWORD *)v1533 = 0uLL;
        *((_OWORD *)v1534 - 1) = v1537;
        *(_OWORD *)v1534 = v1536;
        v1533 -= 4;
        v1534 -= 32;
        v1535 -= 4;
      }
      while (v1535);
      v1517 = v1532;
      if (v1530 != (v1530 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2242:
        do
        {
          v1538 = *--v1517;
          *v1517 = 0;
          *--v1526 = v1538;
        }
        while (v1517 != v1519);
      }
      v1517 = *a1;
      v1539 = a1[1];
      *a1 = v1526;
      a1[1] = (uint64_t *)v1518;
      a1[2] = v1527;
      while (v1539 != v1517)
      {
        v1541 = *--v1539;
        v1540 = v1541;
        *v1539 = 0;
        if (v1541)
          (*(void (**)(uint64_t))(*(_QWORD *)v1540 + 8))(v1540);
      }
      goto LABEL_1429;
    }
  }
  *a1 = v1526;
  a1[1] = (uint64_t *)v1518;
  a1[2] = v1527;
LABEL_1429:
  if (v1517)
    operator delete(v1517);
LABEL_1431:
  a1[1] = (uint64_t *)v1518;
  v1542 = operator new();
  v1543 = v1542;
  *(_BYTE *)(v1542 + 31) = 3;
  *(_QWORD *)v1542 = off_1E0E17A40;
  *(_QWORD *)(v1542 + 8) = 7233908;
  v1545 = a1[1];
  v1544 = (unint64_t)a1[2];
  if ((unint64_t)v1545 < v1544)
  {
    *v1545 = v1542;
    v1546 = (uint64_t)(v1545 + 1);
    goto LABEL_1457;
  }
  v1547 = *a1;
  v1548 = (char *)v1545 - (char *)*a1;
  v1549 = v1548 >> 3;
  v1550 = (v1548 >> 3) + 1;
  if (v1550 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1551 = v1544 - (_QWORD)v1547;
  if (v1551 >> 2 > v1550)
    v1550 = v1551 >> 2;
  if ((unint64_t)v1551 >= 0x7FFFFFFFFFFFFFF8)
    v1552 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1552 = v1550;
  if (v1552)
  {
    if (v1552 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1553 = (char *)operator new(8 * v1552);
    v1554 = (uint64_t *)&v1553[8 * v1549];
    v1555 = (uint64_t *)&v1553[8 * v1552];
    *v1554 = v1543;
    v1546 = (uint64_t)(v1554 + 1);
    v1556 = (char *)((char *)v1545 - (char *)v1547);
    if (v1545 != v1547)
      goto LABEL_1442;
  }
  else
  {
    v1553 = 0;
    v1554 = (uint64_t *)(8 * v1549);
    v1555 = 0;
    *(_QWORD *)(8 * v1549) = v1543;
    v1546 = 8 * v1549 + 8;
    v1556 = (char *)((char *)v1545 - (char *)v1547);
    if (v1545 != v1547)
    {
LABEL_1442:
      v1557 = (unint64_t)(v1556 - 8);
      if (v1557 < 0x78
        || (uint64_t *)((char *)v1545 - (v1557 & 0xFFFFFFFFFFFFFFF8) - 8) < v1554
        && &v1553[v1548 - (v1557 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1545)
      {
        goto LABEL_2243;
      }
      v1558 = (v1557 >> 3) + 1;
      v1559 = 8 * (v1558 & 0x3FFFFFFFFFFFFFFCLL);
      v1554 = (uint64_t *)((char *)v1554 - v1559);
      v1560 = &v1545[v1559 / 0xFFFFFFFFFFFFFFF8];
      v1561 = v1545 - 2;
      v1562 = &v1553[8 * v1549 - 16];
      v1563 = v1558 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1565 = *((_OWORD *)v1561 - 1);
        v1564 = *(_OWORD *)v1561;
        *((_OWORD *)v1561 - 1) = 0uLL;
        *(_OWORD *)v1561 = 0uLL;
        *((_OWORD *)v1562 - 1) = v1565;
        *(_OWORD *)v1562 = v1564;
        v1561 -= 4;
        v1562 -= 32;
        v1563 -= 4;
      }
      while (v1563);
      v1545 = v1560;
      if (v1558 != (v1558 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2243:
        do
        {
          v1566 = *--v1545;
          *v1545 = 0;
          *--v1554 = v1566;
        }
        while (v1545 != v1547);
      }
      v1545 = *a1;
      v1567 = a1[1];
      *a1 = v1554;
      a1[1] = (uint64_t *)v1546;
      a1[2] = v1555;
      while (v1567 != v1545)
      {
        v1569 = *--v1567;
        v1568 = v1569;
        *v1567 = 0;
        if (v1569)
          (*(void (**)(uint64_t))(*(_QWORD *)v1568 + 8))(v1568);
      }
      goto LABEL_1455;
    }
  }
  *a1 = v1554;
  a1[1] = (uint64_t *)v1546;
  a1[2] = v1555;
LABEL_1455:
  if (v1545)
    operator delete(v1545);
LABEL_1457:
  a1[1] = (uint64_t *)v1546;
  v1570 = operator new();
  v1571 = v1570;
  *(_BYTE *)(v1570 + 31) = 4;
  *(_QWORD *)v1570 = off_1E0E17A68;
  *(_QWORD *)(v1570 + 8) = 1752064372;
  v1573 = a1[1];
  v1572 = (unint64_t)a1[2];
  if ((unint64_t)v1573 < v1572)
  {
    *v1573 = v1570;
    v1574 = (uint64_t)(v1573 + 1);
    goto LABEL_1483;
  }
  v1575 = *a1;
  v1576 = (char *)v1573 - (char *)*a1;
  v1577 = v1576 >> 3;
  v1578 = (v1576 >> 3) + 1;
  if (v1578 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1579 = v1572 - (_QWORD)v1575;
  if (v1579 >> 2 > v1578)
    v1578 = v1579 >> 2;
  if ((unint64_t)v1579 >= 0x7FFFFFFFFFFFFFF8)
    v1580 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1580 = v1578;
  if (v1580)
  {
    if (v1580 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1581 = (char *)operator new(8 * v1580);
    v1582 = (uint64_t *)&v1581[8 * v1577];
    v1583 = (uint64_t *)&v1581[8 * v1580];
    *v1582 = v1571;
    v1574 = (uint64_t)(v1582 + 1);
    v1584 = (char *)((char *)v1573 - (char *)v1575);
    if (v1573 != v1575)
      goto LABEL_1468;
  }
  else
  {
    v1581 = 0;
    v1582 = (uint64_t *)(8 * v1577);
    v1583 = 0;
    *(_QWORD *)(8 * v1577) = v1571;
    v1574 = 8 * v1577 + 8;
    v1584 = (char *)((char *)v1573 - (char *)v1575);
    if (v1573 != v1575)
    {
LABEL_1468:
      v1585 = (unint64_t)(v1584 - 8);
      if (v1585 < 0x78
        || (uint64_t *)((char *)v1573 - (v1585 & 0xFFFFFFFFFFFFFFF8) - 8) < v1582
        && &v1581[v1576 - (v1585 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1573)
      {
        goto LABEL_2244;
      }
      v1586 = (v1585 >> 3) + 1;
      v1587 = 8 * (v1586 & 0x3FFFFFFFFFFFFFFCLL);
      v1582 = (uint64_t *)((char *)v1582 - v1587);
      v1588 = &v1573[v1587 / 0xFFFFFFFFFFFFFFF8];
      v1589 = v1573 - 2;
      v1590 = &v1581[8 * v1577 - 16];
      v1591 = v1586 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1593 = *((_OWORD *)v1589 - 1);
        v1592 = *(_OWORD *)v1589;
        *((_OWORD *)v1589 - 1) = 0uLL;
        *(_OWORD *)v1589 = 0uLL;
        *((_OWORD *)v1590 - 1) = v1593;
        *(_OWORD *)v1590 = v1592;
        v1589 -= 4;
        v1590 -= 32;
        v1591 -= 4;
      }
      while (v1591);
      v1573 = v1588;
      if (v1586 != (v1586 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2244:
        do
        {
          v1594 = *--v1573;
          *v1573 = 0;
          *--v1582 = v1594;
        }
        while (v1573 != v1575);
      }
      v1573 = *a1;
      v1595 = a1[1];
      *a1 = v1582;
      a1[1] = (uint64_t *)v1574;
      a1[2] = v1583;
      while (v1595 != v1573)
      {
        v1597 = *--v1595;
        v1596 = v1597;
        *v1595 = 0;
        if (v1597)
          (*(void (**)(uint64_t))(*(_QWORD *)v1596 + 8))(v1596);
      }
      goto LABEL_1481;
    }
  }
  *a1 = v1582;
  a1[1] = (uint64_t *)v1574;
  a1[2] = v1583;
LABEL_1481:
  if (v1573)
    operator delete(v1573);
LABEL_1483:
  a1[1] = (uint64_t *)v1574;
  v1598 = operator new();
  v1599 = v1598;
  *(_QWORD *)(v1598 + 16) = 100;
  *(_BYTE *)(v1598 + 31) = 9;
  *(_QWORD *)v1598 = off_1E0E17A90;
  *(_QWORD *)(v1598 + 8) = 0x6C6F687365726874;
  v1601 = a1[1];
  v1600 = (unint64_t)a1[2];
  if ((unint64_t)v1601 < v1600)
  {
    *v1601 = v1598;
    v1602 = (uint64_t)(v1601 + 1);
    goto LABEL_1509;
  }
  v1603 = *a1;
  v1604 = (char *)v1601 - (char *)*a1;
  v1605 = v1604 >> 3;
  v1606 = (v1604 >> 3) + 1;
  if (v1606 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1607 = v1600 - (_QWORD)v1603;
  if (v1607 >> 2 > v1606)
    v1606 = v1607 >> 2;
  if ((unint64_t)v1607 >= 0x7FFFFFFFFFFFFFF8)
    v1608 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1608 = v1606;
  if (v1608)
  {
    if (v1608 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1609 = (char *)operator new(8 * v1608);
    v1610 = (uint64_t *)&v1609[8 * v1605];
    v1611 = (uint64_t *)&v1609[8 * v1608];
    *v1610 = v1599;
    v1602 = (uint64_t)(v1610 + 1);
    v1612 = (char *)((char *)v1601 - (char *)v1603);
    if (v1601 != v1603)
      goto LABEL_1494;
  }
  else
  {
    v1609 = 0;
    v1610 = (uint64_t *)(8 * v1605);
    v1611 = 0;
    *(_QWORD *)(8 * v1605) = v1599;
    v1602 = 8 * v1605 + 8;
    v1612 = (char *)((char *)v1601 - (char *)v1603);
    if (v1601 != v1603)
    {
LABEL_1494:
      v1613 = (unint64_t)(v1612 - 8);
      if (v1613 < 0x78
        || (uint64_t *)((char *)v1601 - (v1613 & 0xFFFFFFFFFFFFFFF8) - 8) < v1610
        && &v1609[v1604 - (v1613 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1601)
      {
        goto LABEL_2245;
      }
      v1614 = (v1613 >> 3) + 1;
      v1615 = 8 * (v1614 & 0x3FFFFFFFFFFFFFFCLL);
      v1610 = (uint64_t *)((char *)v1610 - v1615);
      v1616 = &v1601[v1615 / 0xFFFFFFFFFFFFFFF8];
      v1617 = v1601 - 2;
      v1618 = &v1609[8 * v1605 - 16];
      v1619 = v1614 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1621 = *((_OWORD *)v1617 - 1);
        v1620 = *(_OWORD *)v1617;
        *((_OWORD *)v1617 - 1) = 0uLL;
        *(_OWORD *)v1617 = 0uLL;
        *((_OWORD *)v1618 - 1) = v1621;
        *(_OWORD *)v1618 = v1620;
        v1617 -= 4;
        v1618 -= 32;
        v1619 -= 4;
      }
      while (v1619);
      v1601 = v1616;
      if (v1614 != (v1614 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2245:
        do
        {
          v1622 = *--v1601;
          *v1601 = 0;
          *--v1610 = v1622;
        }
        while (v1601 != v1603);
      }
      v1601 = *a1;
      v1623 = a1[1];
      *a1 = v1610;
      a1[1] = (uint64_t *)v1602;
      a1[2] = v1611;
      while (v1623 != v1601)
      {
        v1625 = *--v1623;
        v1624 = v1625;
        *v1623 = 0;
        if (v1625)
          (*(void (**)(uint64_t))(*(_QWORD *)v1624 + 8))(v1624);
      }
      goto LABEL_1507;
    }
  }
  *a1 = v1610;
  a1[1] = (uint64_t *)v1602;
  a1[2] = v1611;
LABEL_1507:
  if (v1601)
    operator delete(v1601);
LABEL_1509:
  a1[1] = (uint64_t *)v1602;
  v1626 = operator new();
  v1627 = v1626;
  *(_BYTE *)(v1626 + 31) = 6;
  *(_QWORD *)v1626 = off_1E0E17AB8;
  *(_QWORD *)(v1626 + 8) = 0x7463656C6573;
  v1629 = a1[1];
  v1628 = (unint64_t)a1[2];
  if ((unint64_t)v1629 < v1628)
  {
    *v1629 = v1626;
    v1630 = (uint64_t)(v1629 + 1);
    goto LABEL_1535;
  }
  v1631 = *a1;
  v1632 = (char *)v1629 - (char *)*a1;
  v1633 = v1632 >> 3;
  v1634 = (v1632 >> 3) + 1;
  if (v1634 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1635 = v1628 - (_QWORD)v1631;
  if (v1635 >> 2 > v1634)
    v1634 = v1635 >> 2;
  if ((unint64_t)v1635 >= 0x7FFFFFFFFFFFFFF8)
    v1636 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1636 = v1634;
  if (v1636)
  {
    if (v1636 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1637 = (char *)operator new(8 * v1636);
    v1638 = (uint64_t *)&v1637[8 * v1633];
    v1639 = (uint64_t *)&v1637[8 * v1636];
    *v1638 = v1627;
    v1630 = (uint64_t)(v1638 + 1);
    v1640 = (char *)((char *)v1629 - (char *)v1631);
    if (v1629 != v1631)
      goto LABEL_1520;
  }
  else
  {
    v1637 = 0;
    v1638 = (uint64_t *)(8 * v1633);
    v1639 = 0;
    *(_QWORD *)(8 * v1633) = v1627;
    v1630 = 8 * v1633 + 8;
    v1640 = (char *)((char *)v1629 - (char *)v1631);
    if (v1629 != v1631)
    {
LABEL_1520:
      v1641 = (unint64_t)(v1640 - 8);
      if (v1641 < 0x78
        || (uint64_t *)((char *)v1629 - (v1641 & 0xFFFFFFFFFFFFFFF8) - 8) < v1638
        && &v1637[v1632 - (v1641 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1629)
      {
        goto LABEL_2246;
      }
      v1642 = (v1641 >> 3) + 1;
      v1643 = 8 * (v1642 & 0x3FFFFFFFFFFFFFFCLL);
      v1638 = (uint64_t *)((char *)v1638 - v1643);
      v1644 = &v1629[v1643 / 0xFFFFFFFFFFFFFFF8];
      v1645 = v1629 - 2;
      v1646 = &v1637[8 * v1633 - 16];
      v1647 = v1642 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1649 = *((_OWORD *)v1645 - 1);
        v1648 = *(_OWORD *)v1645;
        *((_OWORD *)v1645 - 1) = 0uLL;
        *(_OWORD *)v1645 = 0uLL;
        *((_OWORD *)v1646 - 1) = v1649;
        *(_OWORD *)v1646 = v1648;
        v1645 -= 4;
        v1646 -= 32;
        v1647 -= 4;
      }
      while (v1647);
      v1629 = v1644;
      if (v1642 != (v1642 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2246:
        do
        {
          v1650 = *--v1629;
          *v1629 = 0;
          *--v1638 = v1650;
        }
        while (v1629 != v1631);
      }
      v1629 = *a1;
      v1651 = a1[1];
      *a1 = v1638;
      a1[1] = (uint64_t *)v1630;
      a1[2] = v1639;
      while (v1651 != v1629)
      {
        v1653 = *--v1651;
        v1652 = v1653;
        *v1651 = 0;
        if (v1653)
          (*(void (**)(uint64_t))(*(_QWORD *)v1652 + 8))(v1652);
      }
      goto LABEL_1533;
    }
  }
  *a1 = v1638;
  a1[1] = (uint64_t *)v1630;
  a1[2] = v1639;
LABEL_1533:
  if (v1629)
    operator delete(v1629);
LABEL_1535:
  a1[1] = (uint64_t *)v1630;
  v1654 = operator new();
  v1655 = v1654;
  *(_QWORD *)(v1654 + 8) = 0x797469746E656469;
  *(_QWORD *)(v1654 + 16) = 0;
  *(_BYTE *)(v1654 + 31) = 8;
  *(_QWORD *)v1654 = off_1E0E17AE0;
  v1657 = a1[1];
  v1656 = (unint64_t)a1[2];
  if ((unint64_t)v1657 < v1656)
  {
    *v1657 = v1654;
    v1658 = (uint64_t)(v1657 + 1);
    goto LABEL_1561;
  }
  v1659 = *a1;
  v1660 = (char *)v1657 - (char *)*a1;
  v1661 = v1660 >> 3;
  v1662 = (v1660 >> 3) + 1;
  if (v1662 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1663 = v1656 - (_QWORD)v1659;
  if (v1663 >> 2 > v1662)
    v1662 = v1663 >> 2;
  if ((unint64_t)v1663 >= 0x7FFFFFFFFFFFFFF8)
    v1664 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1664 = v1662;
  if (v1664)
  {
    if (v1664 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1665 = (char *)operator new(8 * v1664);
    v1666 = (uint64_t *)&v1665[8 * v1661];
    v1667 = (uint64_t *)&v1665[8 * v1664];
    *v1666 = v1655;
    v1658 = (uint64_t)(v1666 + 1);
    v1668 = (char *)((char *)v1657 - (char *)v1659);
    if (v1657 != v1659)
      goto LABEL_1546;
  }
  else
  {
    v1665 = 0;
    v1666 = (uint64_t *)(8 * v1661);
    v1667 = 0;
    *(_QWORD *)(8 * v1661) = v1655;
    v1658 = 8 * v1661 + 8;
    v1668 = (char *)((char *)v1657 - (char *)v1659);
    if (v1657 != v1659)
    {
LABEL_1546:
      v1669 = (unint64_t)(v1668 - 8);
      if (v1669 < 0x78
        || (uint64_t *)((char *)v1657 - (v1669 & 0xFFFFFFFFFFFFFFF8) - 8) < v1666
        && &v1665[v1660 - (v1669 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1657)
      {
        goto LABEL_2247;
      }
      v1670 = (v1669 >> 3) + 1;
      v1671 = 8 * (v1670 & 0x3FFFFFFFFFFFFFFCLL);
      v1666 = (uint64_t *)((char *)v1666 - v1671);
      v1672 = &v1657[v1671 / 0xFFFFFFFFFFFFFFF8];
      v1673 = v1657 - 2;
      v1674 = &v1665[8 * v1661 - 16];
      v1675 = v1670 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1677 = *((_OWORD *)v1673 - 1);
        v1676 = *(_OWORD *)v1673;
        *((_OWORD *)v1673 - 1) = 0uLL;
        *(_OWORD *)v1673 = 0uLL;
        *((_OWORD *)v1674 - 1) = v1677;
        *(_OWORD *)v1674 = v1676;
        v1673 -= 4;
        v1674 -= 32;
        v1675 -= 4;
      }
      while (v1675);
      v1657 = v1672;
      if (v1670 != (v1670 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2247:
        do
        {
          v1678 = *--v1657;
          *v1657 = 0;
          *--v1666 = v1678;
        }
        while (v1657 != v1659);
      }
      v1657 = *a1;
      v1679 = a1[1];
      *a1 = v1666;
      a1[1] = (uint64_t *)v1658;
      a1[2] = v1667;
      while (v1679 != v1657)
      {
        v1681 = *--v1679;
        v1680 = v1681;
        *v1679 = 0;
        if (v1681)
          (*(void (**)(uint64_t))(*(_QWORD *)v1680 + 8))(v1680);
      }
      goto LABEL_1559;
    }
  }
  *a1 = v1666;
  a1[1] = (uint64_t *)v1658;
  a1[2] = v1667;
LABEL_1559:
  if (v1657)
    operator delete(v1657);
LABEL_1561:
  a1[1] = (uint64_t *)v1658;
  v1682 = operator new();
  v1683 = v1682;
  *(_BYTE *)(v1682 + 31) = 7;
  *(_QWORD *)v1682 = off_1E0E17B08;
  *(_QWORD *)(v1682 + 8) = 0x746F685F656E6FLL;
  v1685 = a1[1];
  v1684 = (unint64_t)a1[2];
  if ((unint64_t)v1685 < v1684)
  {
    *v1685 = v1682;
    v1686 = (uint64_t)(v1685 + 1);
    goto LABEL_1587;
  }
  v1687 = *a1;
  v1688 = (char *)v1685 - (char *)*a1;
  v1689 = v1688 >> 3;
  v1690 = (v1688 >> 3) + 1;
  if (v1690 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1691 = v1684 - (_QWORD)v1687;
  if (v1691 >> 2 > v1690)
    v1690 = v1691 >> 2;
  if ((unint64_t)v1691 >= 0x7FFFFFFFFFFFFFF8)
    v1692 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1692 = v1690;
  if (v1692)
  {
    if (v1692 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1693 = (char *)operator new(8 * v1692);
    v1694 = (uint64_t *)&v1693[8 * v1689];
    v1695 = (uint64_t *)&v1693[8 * v1692];
    *v1694 = v1683;
    v1686 = (uint64_t)(v1694 + 1);
    v1696 = (char *)((char *)v1685 - (char *)v1687);
    if (v1685 != v1687)
      goto LABEL_1572;
  }
  else
  {
    v1693 = 0;
    v1694 = (uint64_t *)(8 * v1689);
    v1695 = 0;
    *(_QWORD *)(8 * v1689) = v1683;
    v1686 = 8 * v1689 + 8;
    v1696 = (char *)((char *)v1685 - (char *)v1687);
    if (v1685 != v1687)
    {
LABEL_1572:
      v1697 = (unint64_t)(v1696 - 8);
      if (v1697 < 0x78
        || (uint64_t *)((char *)v1685 - (v1697 & 0xFFFFFFFFFFFFFFF8) - 8) < v1694
        && &v1693[v1688 - (v1697 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1685)
      {
        goto LABEL_2248;
      }
      v1698 = (v1697 >> 3) + 1;
      v1699 = 8 * (v1698 & 0x3FFFFFFFFFFFFFFCLL);
      v1694 = (uint64_t *)((char *)v1694 - v1699);
      v1700 = &v1685[v1699 / 0xFFFFFFFFFFFFFFF8];
      v1701 = v1685 - 2;
      v1702 = &v1693[8 * v1689 - 16];
      v1703 = v1698 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1705 = *((_OWORD *)v1701 - 1);
        v1704 = *(_OWORD *)v1701;
        *((_OWORD *)v1701 - 1) = 0uLL;
        *(_OWORD *)v1701 = 0uLL;
        *((_OWORD *)v1702 - 1) = v1705;
        *(_OWORD *)v1702 = v1704;
        v1701 -= 4;
        v1702 -= 32;
        v1703 -= 4;
      }
      while (v1703);
      v1685 = v1700;
      if (v1698 != (v1698 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2248:
        do
        {
          v1706 = *--v1685;
          *v1685 = 0;
          *--v1694 = v1706;
        }
        while (v1685 != v1687);
      }
      v1685 = *a1;
      v1707 = a1[1];
      *a1 = v1694;
      a1[1] = (uint64_t *)v1686;
      a1[2] = v1695;
      while (v1707 != v1685)
      {
        v1709 = *--v1707;
        v1708 = v1709;
        *v1707 = 0;
        if (v1709)
          (*(void (**)(uint64_t))(*(_QWORD *)v1708 + 8))(v1708);
      }
      goto LABEL_1585;
    }
  }
  *a1 = v1694;
  a1[1] = (uint64_t *)v1686;
  a1[2] = v1695;
LABEL_1585:
  if (v1685)
    operator delete(v1685);
LABEL_1587:
  a1[1] = (uint64_t *)v1686;
  v1710 = operator new();
  v1711 = v1710;
  *(_BYTE *)(v1710 + 31) = 5;
  *(_QWORD *)v1710 = off_1E0E17B30;
  *(_QWORD *)(v1710 + 8) = 0x6570616873;
  v1713 = a1[1];
  v1712 = (unint64_t)a1[2];
  if ((unint64_t)v1713 < v1712)
  {
    *v1713 = v1710;
    v1714 = (uint64_t)(v1713 + 1);
    goto LABEL_1613;
  }
  v1715 = *a1;
  v1716 = (char *)v1713 - (char *)*a1;
  v1717 = v1716 >> 3;
  v1718 = (v1716 >> 3) + 1;
  if (v1718 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1719 = v1712 - (_QWORD)v1715;
  if (v1719 >> 2 > v1718)
    v1718 = v1719 >> 2;
  if ((unint64_t)v1719 >= 0x7FFFFFFFFFFFFFF8)
    v1720 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1720 = v1718;
  if (v1720)
  {
    if (v1720 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1721 = (char *)operator new(8 * v1720);
    v1722 = (uint64_t *)&v1721[8 * v1717];
    v1723 = (uint64_t *)&v1721[8 * v1720];
    *v1722 = v1711;
    v1714 = (uint64_t)(v1722 + 1);
    v1724 = (char *)((char *)v1713 - (char *)v1715);
    if (v1713 != v1715)
      goto LABEL_1598;
  }
  else
  {
    v1721 = 0;
    v1722 = (uint64_t *)(8 * v1717);
    v1723 = 0;
    *(_QWORD *)(8 * v1717) = v1711;
    v1714 = 8 * v1717 + 8;
    v1724 = (char *)((char *)v1713 - (char *)v1715);
    if (v1713 != v1715)
    {
LABEL_1598:
      v1725 = (unint64_t)(v1724 - 8);
      if (v1725 < 0x78
        || (uint64_t *)((char *)v1713 - (v1725 & 0xFFFFFFFFFFFFFFF8) - 8) < v1722
        && &v1721[v1716 - (v1725 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1713)
      {
        goto LABEL_2249;
      }
      v1726 = (v1725 >> 3) + 1;
      v1727 = 8 * (v1726 & 0x3FFFFFFFFFFFFFFCLL);
      v1722 = (uint64_t *)((char *)v1722 - v1727);
      v1728 = &v1713[v1727 / 0xFFFFFFFFFFFFFFF8];
      v1729 = v1713 - 2;
      v1730 = &v1721[8 * v1717 - 16];
      v1731 = v1726 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1733 = *((_OWORD *)v1729 - 1);
        v1732 = *(_OWORD *)v1729;
        *((_OWORD *)v1729 - 1) = 0uLL;
        *(_OWORD *)v1729 = 0uLL;
        *((_OWORD *)v1730 - 1) = v1733;
        *(_OWORD *)v1730 = v1732;
        v1729 -= 4;
        v1730 -= 32;
        v1731 -= 4;
      }
      while (v1731);
      v1713 = v1728;
      if (v1726 != (v1726 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2249:
        do
        {
          v1734 = *--v1713;
          *v1713 = 0;
          *--v1722 = v1734;
        }
        while (v1713 != v1715);
      }
      v1713 = *a1;
      v1735 = a1[1];
      *a1 = v1722;
      a1[1] = (uint64_t *)v1714;
      a1[2] = v1723;
      while (v1735 != v1713)
      {
        v1737 = *--v1735;
        v1736 = v1737;
        *v1735 = 0;
        if (v1737)
          (*(void (**)(uint64_t))(*(_QWORD *)v1736 + 8))(v1736);
      }
      goto LABEL_1611;
    }
  }
  *a1 = v1722;
  a1[1] = (uint64_t *)v1714;
  a1[2] = v1723;
LABEL_1611:
  if (v1713)
    operator delete(v1713);
LABEL_1613:
  a1[1] = (uint64_t *)v1714;
  v1738 = operator new();
  v1739 = v1738;
  *(_BYTE *)(v1738 + 31) = 4;
  *(_QWORD *)v1738 = off_1E0E17B58;
  *(_QWORD *)(v1738 + 8) = 1701603700;
  v1741 = a1[1];
  v1740 = (unint64_t)a1[2];
  if ((unint64_t)v1741 < v1740)
  {
    *v1741 = v1738;
    v1742 = (uint64_t)(v1741 + 1);
    goto LABEL_1639;
  }
  v1743 = *a1;
  v1744 = (char *)v1741 - (char *)*a1;
  v1745 = v1744 >> 3;
  v1746 = (v1744 >> 3) + 1;
  if (v1746 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1747 = v1740 - (_QWORD)v1743;
  if (v1747 >> 2 > v1746)
    v1746 = v1747 >> 2;
  if ((unint64_t)v1747 >= 0x7FFFFFFFFFFFFFF8)
    v1748 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1748 = v1746;
  if (v1748)
  {
    if (v1748 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1749 = (char *)operator new(8 * v1748);
    v1750 = (uint64_t *)&v1749[8 * v1745];
    v1751 = (uint64_t *)&v1749[8 * v1748];
    *v1750 = v1739;
    v1742 = (uint64_t)(v1750 + 1);
    v1752 = (char *)((char *)v1741 - (char *)v1743);
    if (v1741 != v1743)
      goto LABEL_1624;
  }
  else
  {
    v1749 = 0;
    v1750 = (uint64_t *)(8 * v1745);
    v1751 = 0;
    *(_QWORD *)(8 * v1745) = v1739;
    v1742 = 8 * v1745 + 8;
    v1752 = (char *)((char *)v1741 - (char *)v1743);
    if (v1741 != v1743)
    {
LABEL_1624:
      v1753 = (unint64_t)(v1752 - 8);
      if (v1753 < 0x78
        || (uint64_t *)((char *)v1741 - (v1753 & 0xFFFFFFFFFFFFFFF8) - 8) < v1750
        && &v1749[v1744 - (v1753 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1741)
      {
        goto LABEL_2250;
      }
      v1754 = (v1753 >> 3) + 1;
      v1755 = 8 * (v1754 & 0x3FFFFFFFFFFFFFFCLL);
      v1750 = (uint64_t *)((char *)v1750 - v1755);
      v1756 = &v1741[v1755 / 0xFFFFFFFFFFFFFFF8];
      v1757 = v1741 - 2;
      v1758 = &v1749[8 * v1745 - 16];
      v1759 = v1754 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1761 = *((_OWORD *)v1757 - 1);
        v1760 = *(_OWORD *)v1757;
        *((_OWORD *)v1757 - 1) = 0uLL;
        *(_OWORD *)v1757 = 0uLL;
        *((_OWORD *)v1758 - 1) = v1761;
        *(_OWORD *)v1758 = v1760;
        v1757 -= 4;
        v1758 -= 32;
        v1759 -= 4;
      }
      while (v1759);
      v1741 = v1756;
      if (v1754 != (v1754 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2250:
        do
        {
          v1762 = *--v1741;
          *v1741 = 0;
          *--v1750 = v1762;
        }
        while (v1741 != v1743);
      }
      v1741 = *a1;
      v1763 = a1[1];
      *a1 = v1750;
      a1[1] = (uint64_t *)v1742;
      a1[2] = v1751;
      while (v1763 != v1741)
      {
        v1765 = *--v1763;
        v1764 = v1765;
        *v1763 = 0;
        if (v1765)
          (*(void (**)(uint64_t))(*(_QWORD *)v1764 + 8))(v1764);
      }
      goto LABEL_1637;
    }
  }
  *a1 = v1750;
  a1[1] = (uint64_t *)v1742;
  a1[2] = v1751;
LABEL_1637:
  if (v1741)
    operator delete(v1741);
LABEL_1639:
  a1[1] = (uint64_t *)v1742;
  v1766 = operator new();
  v1767 = v1766;
  *(_QWORD *)(v1766 + 8) = 0x5F72657474616373;
  *(_QWORD *)(v1766 + 16) = 25710;
  *(_BYTE *)(v1766 + 31) = 10;
  *(_QWORD *)v1766 = off_1E0E17B80;
  v1769 = a1[1];
  v1768 = (unint64_t)a1[2];
  if ((unint64_t)v1769 < v1768)
  {
    *v1769 = v1766;
    v1770 = (uint64_t)(v1769 + 1);
    goto LABEL_1665;
  }
  v1771 = *a1;
  v1772 = (char *)v1769 - (char *)*a1;
  v1773 = v1772 >> 3;
  v1774 = (v1772 >> 3) + 1;
  if (v1774 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1775 = v1768 - (_QWORD)v1771;
  if (v1775 >> 2 > v1774)
    v1774 = v1775 >> 2;
  if ((unint64_t)v1775 >= 0x7FFFFFFFFFFFFFF8)
    v1776 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1776 = v1774;
  if (v1776)
  {
    if (v1776 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1777 = (char *)operator new(8 * v1776);
    v1778 = (uint64_t *)&v1777[8 * v1773];
    v1779 = (uint64_t *)&v1777[8 * v1776];
    *v1778 = v1767;
    v1770 = (uint64_t)(v1778 + 1);
    v1780 = (char *)((char *)v1769 - (char *)v1771);
    if (v1769 != v1771)
      goto LABEL_1650;
  }
  else
  {
    v1777 = 0;
    v1778 = (uint64_t *)(8 * v1773);
    v1779 = 0;
    *(_QWORD *)(8 * v1773) = v1767;
    v1770 = 8 * v1773 + 8;
    v1780 = (char *)((char *)v1769 - (char *)v1771);
    if (v1769 != v1771)
    {
LABEL_1650:
      v1781 = (unint64_t)(v1780 - 8);
      if (v1781 < 0x78
        || (uint64_t *)((char *)v1769 - (v1781 & 0xFFFFFFFFFFFFFFF8) - 8) < v1778
        && &v1777[v1772 - (v1781 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1769)
      {
        goto LABEL_2251;
      }
      v1782 = (v1781 >> 3) + 1;
      v1783 = 8 * (v1782 & 0x3FFFFFFFFFFFFFFCLL);
      v1778 = (uint64_t *)((char *)v1778 - v1783);
      v1784 = &v1769[v1783 / 0xFFFFFFFFFFFFFFF8];
      v1785 = v1769 - 2;
      v1786 = &v1777[8 * v1773 - 16];
      v1787 = v1782 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1789 = *((_OWORD *)v1785 - 1);
        v1788 = *(_OWORD *)v1785;
        *((_OWORD *)v1785 - 1) = 0uLL;
        *(_OWORD *)v1785 = 0uLL;
        *((_OWORD *)v1786 - 1) = v1789;
        *(_OWORD *)v1786 = v1788;
        v1785 -= 4;
        v1786 -= 32;
        v1787 -= 4;
      }
      while (v1787);
      v1769 = v1784;
      if (v1782 != (v1782 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2251:
        do
        {
          v1790 = *--v1769;
          *v1769 = 0;
          *--v1778 = v1790;
        }
        while (v1769 != v1771);
      }
      v1769 = *a1;
      v1791 = a1[1];
      *a1 = v1778;
      a1[1] = (uint64_t *)v1770;
      a1[2] = v1779;
      while (v1791 != v1769)
      {
        v1793 = *--v1791;
        v1792 = v1793;
        *v1791 = 0;
        if (v1793)
          (*(void (**)(uint64_t))(*(_QWORD *)v1792 + 8))(v1792);
      }
      goto LABEL_1663;
    }
  }
  *a1 = v1778;
  a1[1] = (uint64_t *)v1770;
  a1[2] = v1779;
LABEL_1663:
  if (v1769)
    operator delete(v1769);
LABEL_1665:
  a1[1] = (uint64_t *)v1770;
  v1794 = operator new();
  v1795 = v1794;
  *(_BYTE *)(v1794 + 31) = 7;
  *(_QWORD *)v1794 = off_1E0E17BA8;
  *(_QWORD *)(v1794 + 8) = 0x72657474616373;
  v1797 = a1[1];
  v1796 = (unint64_t)a1[2];
  if ((unint64_t)v1797 < v1796)
  {
    *v1797 = v1794;
    v1798 = (uint64_t)(v1797 + 1);
    goto LABEL_1691;
  }
  v1799 = *a1;
  v1800 = (char *)v1797 - (char *)*a1;
  v1801 = v1800 >> 3;
  v1802 = (v1800 >> 3) + 1;
  if (v1802 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1803 = v1796 - (_QWORD)v1799;
  if (v1803 >> 2 > v1802)
    v1802 = v1803 >> 2;
  if ((unint64_t)v1803 >= 0x7FFFFFFFFFFFFFF8)
    v1804 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1804 = v1802;
  if (v1804)
  {
    if (v1804 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1805 = (char *)operator new(8 * v1804);
    v1806 = (uint64_t *)&v1805[8 * v1801];
    v1807 = (uint64_t *)&v1805[8 * v1804];
    *v1806 = v1795;
    v1798 = (uint64_t)(v1806 + 1);
    v1808 = (char *)((char *)v1797 - (char *)v1799);
    if (v1797 != v1799)
      goto LABEL_1676;
  }
  else
  {
    v1805 = 0;
    v1806 = (uint64_t *)(8 * v1801);
    v1807 = 0;
    *(_QWORD *)(8 * v1801) = v1795;
    v1798 = 8 * v1801 + 8;
    v1808 = (char *)((char *)v1797 - (char *)v1799);
    if (v1797 != v1799)
    {
LABEL_1676:
      v1809 = (unint64_t)(v1808 - 8);
      if (v1809 < 0x78
        || (uint64_t *)((char *)v1797 - (v1809 & 0xFFFFFFFFFFFFFFF8) - 8) < v1806
        && &v1805[v1800 - (v1809 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1797)
      {
        goto LABEL_2252;
      }
      v1810 = (v1809 >> 3) + 1;
      v1811 = 8 * (v1810 & 0x3FFFFFFFFFFFFFFCLL);
      v1806 = (uint64_t *)((char *)v1806 - v1811);
      v1812 = &v1797[v1811 / 0xFFFFFFFFFFFFFFF8];
      v1813 = v1797 - 2;
      v1814 = &v1805[8 * v1801 - 16];
      v1815 = v1810 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1817 = *((_OWORD *)v1813 - 1);
        v1816 = *(_OWORD *)v1813;
        *((_OWORD *)v1813 - 1) = 0uLL;
        *(_OWORD *)v1813 = 0uLL;
        *((_OWORD *)v1814 - 1) = v1817;
        *(_OWORD *)v1814 = v1816;
        v1813 -= 4;
        v1814 -= 32;
        v1815 -= 4;
      }
      while (v1815);
      v1797 = v1812;
      if (v1810 != (v1810 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2252:
        do
        {
          v1818 = *--v1797;
          *v1797 = 0;
          *--v1806 = v1818;
        }
        while (v1797 != v1799);
      }
      v1797 = *a1;
      v1819 = a1[1];
      *a1 = v1806;
      a1[1] = (uint64_t *)v1798;
      a1[2] = v1807;
      while (v1819 != v1797)
      {
        v1821 = *--v1819;
        v1820 = v1821;
        *v1819 = 0;
        if (v1821)
          (*(void (**)(uint64_t))(*(_QWORD *)v1820 + 8))(v1820);
      }
      goto LABEL_1689;
    }
  }
  *a1 = v1806;
  a1[1] = (uint64_t *)v1798;
  a1[2] = v1807;
LABEL_1689:
  if (v1797)
    operator delete(v1797);
LABEL_1691:
  a1[1] = (uint64_t *)v1798;
  v1822 = operator new();
  v1823 = v1822;
  strcpy((char *)(v1822 + 8), "scatter_along_axis");
  *(_BYTE *)(v1822 + 31) = 18;
  *(_QWORD *)v1822 = off_1E0E17BD0;
  v1825 = a1[1];
  v1824 = (unint64_t)a1[2];
  if ((unint64_t)v1825 < v1824)
  {
    *v1825 = v1822;
    v1826 = (uint64_t)(v1825 + 1);
    goto LABEL_1717;
  }
  v1827 = *a1;
  v1828 = (char *)v1825 - (char *)*a1;
  v1829 = v1828 >> 3;
  v1830 = (v1828 >> 3) + 1;
  if (v1830 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1831 = v1824 - (_QWORD)v1827;
  if (v1831 >> 2 > v1830)
    v1830 = v1831 >> 2;
  if ((unint64_t)v1831 >= 0x7FFFFFFFFFFFFFF8)
    v1832 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1832 = v1830;
  if (v1832)
  {
    if (v1832 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1833 = (char *)operator new(8 * v1832);
    v1834 = (uint64_t *)&v1833[8 * v1829];
    v1835 = (uint64_t *)&v1833[8 * v1832];
    *v1834 = v1823;
    v1826 = (uint64_t)(v1834 + 1);
    v1836 = (char *)((char *)v1825 - (char *)v1827);
    if (v1825 != v1827)
      goto LABEL_1702;
  }
  else
  {
    v1833 = 0;
    v1834 = (uint64_t *)(8 * v1829);
    v1835 = 0;
    *(_QWORD *)(8 * v1829) = v1823;
    v1826 = 8 * v1829 + 8;
    v1836 = (char *)((char *)v1825 - (char *)v1827);
    if (v1825 != v1827)
    {
LABEL_1702:
      v1837 = (unint64_t)(v1836 - 8);
      if (v1837 < 0x78
        || (uint64_t *)((char *)v1825 - (v1837 & 0xFFFFFFFFFFFFFFF8) - 8) < v1834
        && &v1833[v1828 - (v1837 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1825)
      {
        goto LABEL_2253;
      }
      v1838 = (v1837 >> 3) + 1;
      v1839 = 8 * (v1838 & 0x3FFFFFFFFFFFFFFCLL);
      v1834 = (uint64_t *)((char *)v1834 - v1839);
      v1840 = &v1825[v1839 / 0xFFFFFFFFFFFFFFF8];
      v1841 = v1825 - 2;
      v1842 = &v1833[8 * v1829 - 16];
      v1843 = v1838 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1845 = *((_OWORD *)v1841 - 1);
        v1844 = *(_OWORD *)v1841;
        *((_OWORD *)v1841 - 1) = 0uLL;
        *(_OWORD *)v1841 = 0uLL;
        *((_OWORD *)v1842 - 1) = v1845;
        *(_OWORD *)v1842 = v1844;
        v1841 -= 4;
        v1842 -= 32;
        v1843 -= 4;
      }
      while (v1843);
      v1825 = v1840;
      if (v1838 != (v1838 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2253:
        do
        {
          v1846 = *--v1825;
          *v1825 = 0;
          *--v1834 = v1846;
        }
        while (v1825 != v1827);
      }
      v1825 = *a1;
      v1847 = a1[1];
      *a1 = v1834;
      a1[1] = (uint64_t *)v1826;
      a1[2] = v1835;
      while (v1847 != v1825)
      {
        v1849 = *--v1847;
        v1848 = v1849;
        *v1847 = 0;
        if (v1849)
          (*(void (**)(uint64_t))(*(_QWORD *)v1848 + 8))(v1848);
      }
      goto LABEL_1715;
    }
  }
  *a1 = v1834;
  a1[1] = (uint64_t *)v1826;
  a1[2] = v1835;
LABEL_1715:
  if (v1825)
    operator delete(v1825);
LABEL_1717:
  a1[1] = (uint64_t *)v1826;
  v1850 = operator new();
  v1851 = v1850;
  *(_QWORD *)(v1850 + 8) = 0x6E5F726568746167;
  *(_QWORD *)(v1850 + 16) = 100;
  *(_BYTE *)(v1850 + 31) = 9;
  *(_QWORD *)v1850 = off_1E0E17BF8;
  v1853 = a1[1];
  v1852 = (unint64_t)a1[2];
  if ((unint64_t)v1853 < v1852)
  {
    *v1853 = v1850;
    v1854 = (uint64_t)(v1853 + 1);
    goto LABEL_1743;
  }
  v1855 = *a1;
  v1856 = (char *)v1853 - (char *)*a1;
  v1857 = v1856 >> 3;
  v1858 = (v1856 >> 3) + 1;
  if (v1858 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1859 = v1852 - (_QWORD)v1855;
  if (v1859 >> 2 > v1858)
    v1858 = v1859 >> 2;
  if ((unint64_t)v1859 >= 0x7FFFFFFFFFFFFFF8)
    v1860 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1860 = v1858;
  if (v1860)
  {
    if (v1860 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1861 = (char *)operator new(8 * v1860);
    v1862 = (uint64_t *)&v1861[8 * v1857];
    v1863 = (uint64_t *)&v1861[8 * v1860];
    *v1862 = v1851;
    v1854 = (uint64_t)(v1862 + 1);
    v1864 = (char *)((char *)v1853 - (char *)v1855);
    if (v1853 != v1855)
      goto LABEL_1728;
  }
  else
  {
    v1861 = 0;
    v1862 = (uint64_t *)(8 * v1857);
    v1863 = 0;
    *(_QWORD *)(8 * v1857) = v1851;
    v1854 = 8 * v1857 + 8;
    v1864 = (char *)((char *)v1853 - (char *)v1855);
    if (v1853 != v1855)
    {
LABEL_1728:
      v1865 = (unint64_t)(v1864 - 8);
      if (v1865 < 0x78
        || (uint64_t *)((char *)v1853 - (v1865 & 0xFFFFFFFFFFFFFFF8) - 8) < v1862
        && &v1861[v1856 - (v1865 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1853)
      {
        goto LABEL_2254;
      }
      v1866 = (v1865 >> 3) + 1;
      v1867 = 8 * (v1866 & 0x3FFFFFFFFFFFFFFCLL);
      v1862 = (uint64_t *)((char *)v1862 - v1867);
      v1868 = &v1853[v1867 / 0xFFFFFFFFFFFFFFF8];
      v1869 = v1853 - 2;
      v1870 = &v1861[8 * v1857 - 16];
      v1871 = v1866 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1873 = *((_OWORD *)v1869 - 1);
        v1872 = *(_OWORD *)v1869;
        *((_OWORD *)v1869 - 1) = 0uLL;
        *(_OWORD *)v1869 = 0uLL;
        *((_OWORD *)v1870 - 1) = v1873;
        *(_OWORD *)v1870 = v1872;
        v1869 -= 4;
        v1870 -= 32;
        v1871 -= 4;
      }
      while (v1871);
      v1853 = v1868;
      if (v1866 != (v1866 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2254:
        do
        {
          v1874 = *--v1853;
          *v1853 = 0;
          *--v1862 = v1874;
        }
        while (v1853 != v1855);
      }
      v1853 = *a1;
      v1875 = a1[1];
      *a1 = v1862;
      a1[1] = (uint64_t *)v1854;
      a1[2] = v1863;
      while (v1875 != v1853)
      {
        v1877 = *--v1875;
        v1876 = v1877;
        *v1875 = 0;
        if (v1877)
          (*(void (**)(uint64_t))(*(_QWORD *)v1876 + 8))(v1876);
      }
      goto LABEL_1741;
    }
  }
  *a1 = v1862;
  a1[1] = (uint64_t *)v1854;
  a1[2] = v1863;
LABEL_1741:
  if (v1853)
    operator delete(v1853);
LABEL_1743:
  a1[1] = (uint64_t *)v1854;
  v1878 = operator new();
  v1879 = v1878;
  *(_BYTE *)(v1878 + 31) = 6;
  *(_QWORD *)v1878 = off_1E0E17C20;
  *(_QWORD *)(v1878 + 8) = 0x726568746167;
  v1881 = a1[1];
  v1880 = (unint64_t)a1[2];
  if ((unint64_t)v1881 < v1880)
  {
    *v1881 = v1878;
    v1882 = (uint64_t)(v1881 + 1);
    goto LABEL_1769;
  }
  v1883 = *a1;
  v1884 = (char *)v1881 - (char *)*a1;
  v1885 = v1884 >> 3;
  v1886 = (v1884 >> 3) + 1;
  if (v1886 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1887 = v1880 - (_QWORD)v1883;
  if (v1887 >> 2 > v1886)
    v1886 = v1887 >> 2;
  if ((unint64_t)v1887 >= 0x7FFFFFFFFFFFFFF8)
    v1888 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1888 = v1886;
  if (v1888)
  {
    if (v1888 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1889 = (char *)operator new(8 * v1888);
    v1890 = (uint64_t *)&v1889[8 * v1885];
    v1891 = (uint64_t *)&v1889[8 * v1888];
    *v1890 = v1879;
    v1882 = (uint64_t)(v1890 + 1);
    v1892 = (char *)((char *)v1881 - (char *)v1883);
    if (v1881 != v1883)
      goto LABEL_1754;
  }
  else
  {
    v1889 = 0;
    v1890 = (uint64_t *)(8 * v1885);
    v1891 = 0;
    *(_QWORD *)(8 * v1885) = v1879;
    v1882 = 8 * v1885 + 8;
    v1892 = (char *)((char *)v1881 - (char *)v1883);
    if (v1881 != v1883)
    {
LABEL_1754:
      v1893 = (unint64_t)(v1892 - 8);
      if (v1893 < 0x78
        || (uint64_t *)((char *)v1881 - (v1893 & 0xFFFFFFFFFFFFFFF8) - 8) < v1890
        && &v1889[v1884 - (v1893 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1881)
      {
        goto LABEL_2255;
      }
      v1894 = (v1893 >> 3) + 1;
      v1895 = 8 * (v1894 & 0x3FFFFFFFFFFFFFFCLL);
      v1890 = (uint64_t *)((char *)v1890 - v1895);
      v1896 = &v1881[v1895 / 0xFFFFFFFFFFFFFFF8];
      v1897 = v1881 - 2;
      v1898 = &v1889[8 * v1885 - 16];
      v1899 = v1894 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1901 = *((_OWORD *)v1897 - 1);
        v1900 = *(_OWORD *)v1897;
        *((_OWORD *)v1897 - 1) = 0uLL;
        *(_OWORD *)v1897 = 0uLL;
        *((_OWORD *)v1898 - 1) = v1901;
        *(_OWORD *)v1898 = v1900;
        v1897 -= 4;
        v1898 -= 32;
        v1899 -= 4;
      }
      while (v1899);
      v1881 = v1896;
      if (v1894 != (v1894 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2255:
        do
        {
          v1902 = *--v1881;
          *v1881 = 0;
          *--v1890 = v1902;
        }
        while (v1881 != v1883);
      }
      v1881 = *a1;
      v1903 = a1[1];
      *a1 = v1890;
      a1[1] = (uint64_t *)v1882;
      a1[2] = v1891;
      while (v1903 != v1881)
      {
        v1905 = *--v1903;
        v1904 = v1905;
        *v1903 = 0;
        if (v1905)
          (*(void (**)(uint64_t))(*(_QWORD *)v1904 + 8))(v1904);
      }
      goto LABEL_1767;
    }
  }
  *a1 = v1890;
  a1[1] = (uint64_t *)v1882;
  a1[2] = v1891;
LABEL_1767:
  if (v1881)
    operator delete(v1881);
LABEL_1769:
  a1[1] = (uint64_t *)v1882;
  v1906 = operator new();
  v1907 = v1906;
  strcpy((char *)(v1906 + 8), "gather_along_axis");
  *(_BYTE *)(v1906 + 31) = 17;
  *(_QWORD *)v1906 = off_1E0E17C48;
  v1909 = a1[1];
  v1908 = (unint64_t)a1[2];
  if ((unint64_t)v1909 < v1908)
  {
    *v1909 = v1906;
    v1910 = (uint64_t)(v1909 + 1);
    goto LABEL_1795;
  }
  v1911 = *a1;
  v1912 = (char *)v1909 - (char *)*a1;
  v1913 = v1912 >> 3;
  v1914 = (v1912 >> 3) + 1;
  if (v1914 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1915 = v1908 - (_QWORD)v1911;
  if (v1915 >> 2 > v1914)
    v1914 = v1915 >> 2;
  if ((unint64_t)v1915 >= 0x7FFFFFFFFFFFFFF8)
    v1916 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1916 = v1914;
  if (v1916)
  {
    if (v1916 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1917 = (char *)operator new(8 * v1916);
    v1918 = (uint64_t *)&v1917[8 * v1913];
    v1919 = (uint64_t *)&v1917[8 * v1916];
    *v1918 = v1907;
    v1910 = (uint64_t)(v1918 + 1);
    v1920 = (char *)((char *)v1909 - (char *)v1911);
    if (v1909 != v1911)
      goto LABEL_1780;
  }
  else
  {
    v1917 = 0;
    v1918 = (uint64_t *)(8 * v1913);
    v1919 = 0;
    *(_QWORD *)(8 * v1913) = v1907;
    v1910 = 8 * v1913 + 8;
    v1920 = (char *)((char *)v1909 - (char *)v1911);
    if (v1909 != v1911)
    {
LABEL_1780:
      v1921 = (unint64_t)(v1920 - 8);
      if (v1921 < 0x78
        || (uint64_t *)((char *)v1909 - (v1921 & 0xFFFFFFFFFFFFFFF8) - 8) < v1918
        && &v1917[v1912 - (v1921 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1909)
      {
        goto LABEL_2256;
      }
      v1922 = (v1921 >> 3) + 1;
      v1923 = 8 * (v1922 & 0x3FFFFFFFFFFFFFFCLL);
      v1918 = (uint64_t *)((char *)v1918 - v1923);
      v1924 = &v1909[v1923 / 0xFFFFFFFFFFFFFFF8];
      v1925 = v1909 - 2;
      v1926 = &v1917[8 * v1913 - 16];
      v1927 = v1922 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1929 = *((_OWORD *)v1925 - 1);
        v1928 = *(_OWORD *)v1925;
        *((_OWORD *)v1925 - 1) = 0uLL;
        *(_OWORD *)v1925 = 0uLL;
        *((_OWORD *)v1926 - 1) = v1929;
        *(_OWORD *)v1926 = v1928;
        v1925 -= 4;
        v1926 -= 32;
        v1927 -= 4;
      }
      while (v1927);
      v1909 = v1924;
      if (v1922 != (v1922 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2256:
        do
        {
          v1930 = *--v1909;
          *v1909 = 0;
          *--v1918 = v1930;
        }
        while (v1909 != v1911);
      }
      v1909 = *a1;
      v1931 = a1[1];
      *a1 = v1918;
      a1[1] = (uint64_t *)v1910;
      a1[2] = v1919;
      while (v1931 != v1909)
      {
        v1933 = *--v1931;
        v1932 = v1933;
        *v1931 = 0;
        if (v1933)
          (*(void (**)(uint64_t))(*(_QWORD *)v1932 + 8))(v1932);
      }
      goto LABEL_1793;
    }
  }
  *a1 = v1918;
  a1[1] = (uint64_t *)v1910;
  a1[2] = v1919;
LABEL_1793:
  if (v1909)
    operator delete(v1909);
LABEL_1795:
  a1[1] = (uint64_t *)v1910;
  v1934 = operator new();
  v1935 = v1934;
  *(_QWORD *)(v1934 + 8) = 0x645F646E61707865;
  *(_QWORD *)(v1934 + 16) = 7564649;
  *(_BYTE *)(v1934 + 31) = 11;
  *(_QWORD *)v1934 = off_1E0E17C70;
  v1937 = a1[1];
  v1936 = (unint64_t)a1[2];
  if ((unint64_t)v1937 < v1936)
  {
    *v1937 = v1934;
    v1938 = (uint64_t)(v1937 + 1);
    goto LABEL_1821;
  }
  v1939 = *a1;
  v1940 = (char *)v1937 - (char *)*a1;
  v1941 = v1940 >> 3;
  v1942 = (v1940 >> 3) + 1;
  if (v1942 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1943 = v1936 - (_QWORD)v1939;
  if (v1943 >> 2 > v1942)
    v1942 = v1943 >> 2;
  if ((unint64_t)v1943 >= 0x7FFFFFFFFFFFFFF8)
    v1944 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1944 = v1942;
  if (v1944)
  {
    if (v1944 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1945 = (char *)operator new(8 * v1944);
    v1946 = (uint64_t *)&v1945[8 * v1941];
    v1947 = (uint64_t *)&v1945[8 * v1944];
    *v1946 = v1935;
    v1938 = (uint64_t)(v1946 + 1);
    v1948 = (char *)((char *)v1937 - (char *)v1939);
    if (v1937 != v1939)
      goto LABEL_1806;
  }
  else
  {
    v1945 = 0;
    v1946 = (uint64_t *)(8 * v1941);
    v1947 = 0;
    *(_QWORD *)(8 * v1941) = v1935;
    v1938 = 8 * v1941 + 8;
    v1948 = (char *)((char *)v1937 - (char *)v1939);
    if (v1937 != v1939)
    {
LABEL_1806:
      v1949 = (unint64_t)(v1948 - 8);
      if (v1949 < 0x78
        || (uint64_t *)((char *)v1937 - (v1949 & 0xFFFFFFFFFFFFFFF8) - 8) < v1946
        && &v1945[v1940 - (v1949 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1937)
      {
        goto LABEL_2257;
      }
      v1950 = (v1949 >> 3) + 1;
      v1951 = 8 * (v1950 & 0x3FFFFFFFFFFFFFFCLL);
      v1946 = (uint64_t *)((char *)v1946 - v1951);
      v1952 = &v1937[v1951 / 0xFFFFFFFFFFFFFFF8];
      v1953 = v1937 - 2;
      v1954 = &v1945[8 * v1941 - 16];
      v1955 = v1950 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1957 = *((_OWORD *)v1953 - 1);
        v1956 = *(_OWORD *)v1953;
        *((_OWORD *)v1953 - 1) = 0uLL;
        *(_OWORD *)v1953 = 0uLL;
        *((_OWORD *)v1954 - 1) = v1957;
        *(_OWORD *)v1954 = v1956;
        v1953 -= 4;
        v1954 -= 32;
        v1955 -= 4;
      }
      while (v1955);
      v1937 = v1952;
      if (v1950 != (v1950 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2257:
        do
        {
          v1958 = *--v1937;
          *v1937 = 0;
          *--v1946 = v1958;
        }
        while (v1937 != v1939);
      }
      v1937 = *a1;
      v1959 = a1[1];
      *a1 = v1946;
      a1[1] = (uint64_t *)v1938;
      a1[2] = v1947;
      while (v1959 != v1937)
      {
        v1961 = *--v1959;
        v1960 = v1961;
        *v1959 = 0;
        if (v1961)
          (*(void (**)(uint64_t))(*(_QWORD *)v1960 + 8))(v1960);
      }
      goto LABEL_1819;
    }
  }
  *a1 = v1946;
  a1[1] = (uint64_t *)v1938;
  a1[2] = v1947;
LABEL_1819:
  if (v1937)
    operator delete(v1937);
LABEL_1821:
  a1[1] = (uint64_t *)v1938;
  v1962 = operator new();
  v1963 = v1962;
  *(_BYTE *)(v1962 + 31) = 4;
  *(_QWORD *)v1962 = off_1E0E17C98;
  *(_QWORD *)(v1962 + 8) = 1819044198;
  v1965 = a1[1];
  v1964 = (unint64_t)a1[2];
  if ((unint64_t)v1965 < v1964)
  {
    *v1965 = v1962;
    v1966 = (uint64_t)(v1965 + 1);
    goto LABEL_1847;
  }
  v1967 = *a1;
  v1968 = (char *)v1965 - (char *)*a1;
  v1969 = v1968 >> 3;
  v1970 = (v1968 >> 3) + 1;
  if (v1970 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1971 = v1964 - (_QWORD)v1967;
  if (v1971 >> 2 > v1970)
    v1970 = v1971 >> 2;
  if ((unint64_t)v1971 >= 0x7FFFFFFFFFFFFFF8)
    v1972 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v1972 = v1970;
  if (v1972)
  {
    if (v1972 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v1973 = (char *)operator new(8 * v1972);
    v1974 = (uint64_t *)&v1973[8 * v1969];
    v1975 = (uint64_t *)&v1973[8 * v1972];
    *v1974 = v1963;
    v1966 = (uint64_t)(v1974 + 1);
    v1976 = (char *)((char *)v1965 - (char *)v1967);
    if (v1965 != v1967)
      goto LABEL_1832;
  }
  else
  {
    v1973 = 0;
    v1974 = (uint64_t *)(8 * v1969);
    v1975 = 0;
    *(_QWORD *)(8 * v1969) = v1963;
    v1966 = 8 * v1969 + 8;
    v1976 = (char *)((char *)v1965 - (char *)v1967);
    if (v1965 != v1967)
    {
LABEL_1832:
      v1977 = (unint64_t)(v1976 - 8);
      if (v1977 < 0x78
        || (uint64_t *)((char *)v1965 - (v1977 & 0xFFFFFFFFFFFFFFF8) - 8) < v1974
        && &v1973[v1968 - (v1977 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1965)
      {
        goto LABEL_2258;
      }
      v1978 = (v1977 >> 3) + 1;
      v1979 = 8 * (v1978 & 0x3FFFFFFFFFFFFFFCLL);
      v1974 = (uint64_t *)((char *)v1974 - v1979);
      v1980 = &v1965[v1979 / 0xFFFFFFFFFFFFFFF8];
      v1981 = v1965 - 2;
      v1982 = &v1973[8 * v1969 - 16];
      v1983 = v1978 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v1985 = *((_OWORD *)v1981 - 1);
        v1984 = *(_OWORD *)v1981;
        *((_OWORD *)v1981 - 1) = 0uLL;
        *(_OWORD *)v1981 = 0uLL;
        *((_OWORD *)v1982 - 1) = v1985;
        *(_OWORD *)v1982 = v1984;
        v1981 -= 4;
        v1982 -= 32;
        v1983 -= 4;
      }
      while (v1983);
      v1965 = v1980;
      if (v1978 != (v1978 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2258:
        do
        {
          v1986 = *--v1965;
          *v1965 = 0;
          *--v1974 = v1986;
        }
        while (v1965 != v1967);
      }
      v1965 = *a1;
      v1987 = a1[1];
      *a1 = v1974;
      a1[1] = (uint64_t *)v1966;
      a1[2] = v1975;
      while (v1987 != v1965)
      {
        v1989 = *--v1987;
        v1988 = v1989;
        *v1987 = 0;
        if (v1989)
          (*(void (**)(uint64_t))(*(_QWORD *)v1988 + 8))(v1988);
      }
      goto LABEL_1845;
    }
  }
  *a1 = v1974;
  a1[1] = (uint64_t *)v1966;
  a1[2] = v1975;
LABEL_1845:
  if (v1965)
    operator delete(v1965);
LABEL_1847:
  a1[1] = (uint64_t *)v1966;
  v1990 = operator new();
  v1991 = v1990;
  *(_QWORD *)(v1990 + 8) = 0x6B696C5F6C6C6966;
  *(_QWORD *)(v1990 + 16) = 101;
  *(_BYTE *)(v1990 + 31) = 9;
  *(_QWORD *)v1990 = off_1E0E17CC0;
  v1993 = a1[1];
  v1992 = (unint64_t)a1[2];
  if ((unint64_t)v1993 < v1992)
  {
    *v1993 = v1990;
    v1994 = (uint64_t)(v1993 + 1);
    goto LABEL_1873;
  }
  v1995 = *a1;
  v1996 = (char *)v1993 - (char *)*a1;
  v1997 = v1996 >> 3;
  v1998 = (v1996 >> 3) + 1;
  if (v1998 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v1999 = v1992 - (_QWORD)v1995;
  if (v1999 >> 2 > v1998)
    v1998 = v1999 >> 2;
  if ((unint64_t)v1999 >= 0x7FFFFFFFFFFFFFF8)
    v2000 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v2000 = v1998;
  if (v2000)
  {
    if (v2000 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v2001 = (char *)operator new(8 * v2000);
    v2002 = (uint64_t *)&v2001[8 * v1997];
    v2003 = (uint64_t *)&v2001[8 * v2000];
    *v2002 = v1991;
    v1994 = (uint64_t)(v2002 + 1);
    v2004 = (char *)((char *)v1993 - (char *)v1995);
    if (v1993 != v1995)
      goto LABEL_1858;
  }
  else
  {
    v2001 = 0;
    v2002 = (uint64_t *)(8 * v1997);
    v2003 = 0;
    *(_QWORD *)(8 * v1997) = v1991;
    v1994 = 8 * v1997 + 8;
    v2004 = (char *)((char *)v1993 - (char *)v1995);
    if (v1993 != v1995)
    {
LABEL_1858:
      v2005 = (unint64_t)(v2004 - 8);
      if (v2005 < 0x78
        || (uint64_t *)((char *)v1993 - (v2005 & 0xFFFFFFFFFFFFFFF8) - 8) < v2002
        && &v2001[v1996 - (v2005 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v1993)
      {
        goto LABEL_2259;
      }
      v2006 = (v2005 >> 3) + 1;
      v2007 = 8 * (v2006 & 0x3FFFFFFFFFFFFFFCLL);
      v2002 = (uint64_t *)((char *)v2002 - v2007);
      v2008 = &v1993[v2007 / 0xFFFFFFFFFFFFFFF8];
      v2009 = v1993 - 2;
      v2010 = &v2001[8 * v1997 - 16];
      v2011 = v2006 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v2013 = *((_OWORD *)v2009 - 1);
        v2012 = *(_OWORD *)v2009;
        *((_OWORD *)v2009 - 1) = 0uLL;
        *(_OWORD *)v2009 = 0uLL;
        *((_OWORD *)v2010 - 1) = v2013;
        *(_OWORD *)v2010 = v2012;
        v2009 -= 4;
        v2010 -= 32;
        v2011 -= 4;
      }
      while (v2011);
      v1993 = v2008;
      if (v2006 != (v2006 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2259:
        do
        {
          v2014 = *--v1993;
          *v1993 = 0;
          *--v2002 = v2014;
        }
        while (v1993 != v1995);
      }
      v1993 = *a1;
      v2015 = a1[1];
      *a1 = v2002;
      a1[1] = (uint64_t *)v1994;
      a1[2] = v2003;
      while (v2015 != v1993)
      {
        v2017 = *--v2015;
        v2016 = v2017;
        *v2015 = 0;
        if (v2017)
          (*(void (**)(uint64_t))(*(_QWORD *)v2016 + 8))(v2016);
      }
      goto LABEL_1871;
    }
  }
  *a1 = v2002;
  a1[1] = (uint64_t *)v1994;
  a1[2] = v2003;
LABEL_1871:
  if (v1993)
    operator delete(v1993);
LABEL_1873:
  a1[1] = (uint64_t *)v1994;
  v2018 = operator new();
  v2019 = v2018;
  *(_QWORD *)(v2018 + 8) = 0x736F70736E617274;
  *(_QWORD *)(v2018 + 16) = 101;
  *(_BYTE *)(v2018 + 31) = 9;
  *(_QWORD *)v2018 = off_1E0E17CE8;
  v2021 = a1[1];
  v2020 = (unint64_t)a1[2];
  if ((unint64_t)v2021 < v2020)
  {
    *v2021 = v2018;
    v2022 = (uint64_t)(v2021 + 1);
    goto LABEL_1899;
  }
  v2023 = *a1;
  v2024 = (char *)v2021 - (char *)*a1;
  v2025 = v2024 >> 3;
  v2026 = (v2024 >> 3) + 1;
  if (v2026 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v2027 = v2020 - (_QWORD)v2023;
  if (v2027 >> 2 > v2026)
    v2026 = v2027 >> 2;
  if ((unint64_t)v2027 >= 0x7FFFFFFFFFFFFFF8)
    v2028 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v2028 = v2026;
  if (v2028)
  {
    if (v2028 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v2029 = (char *)operator new(8 * v2028);
    v2030 = (uint64_t *)&v2029[8 * v2025];
    v2031 = (uint64_t *)&v2029[8 * v2028];
    *v2030 = v2019;
    v2022 = (uint64_t)(v2030 + 1);
    v2032 = (char *)((char *)v2021 - (char *)v2023);
    if (v2021 != v2023)
      goto LABEL_1884;
  }
  else
  {
    v2029 = 0;
    v2030 = (uint64_t *)(8 * v2025);
    v2031 = 0;
    *(_QWORD *)(8 * v2025) = v2019;
    v2022 = 8 * v2025 + 8;
    v2032 = (char *)((char *)v2021 - (char *)v2023);
    if (v2021 != v2023)
    {
LABEL_1884:
      v2033 = (unint64_t)(v2032 - 8);
      if (v2033 < 0x78
        || (uint64_t *)((char *)v2021 - (v2033 & 0xFFFFFFFFFFFFFFF8) - 8) < v2030
        && &v2029[v2024 - (v2033 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v2021)
      {
        goto LABEL_2260;
      }
      v2034 = (v2033 >> 3) + 1;
      v2035 = 8 * (v2034 & 0x3FFFFFFFFFFFFFFCLL);
      v2030 = (uint64_t *)((char *)v2030 - v2035);
      v2036 = &v2021[v2035 / 0xFFFFFFFFFFFFFFF8];
      v2037 = v2021 - 2;
      v2038 = &v2029[8 * v2025 - 16];
      v2039 = v2034 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v2041 = *((_OWORD *)v2037 - 1);
        v2040 = *(_OWORD *)v2037;
        *((_OWORD *)v2037 - 1) = 0uLL;
        *(_OWORD *)v2037 = 0uLL;
        *((_OWORD *)v2038 - 1) = v2041;
        *(_OWORD *)v2038 = v2040;
        v2037 -= 4;
        v2038 -= 32;
        v2039 -= 4;
      }
      while (v2039);
      v2021 = v2036;
      if (v2034 != (v2034 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2260:
        do
        {
          v2042 = *--v2021;
          *v2021 = 0;
          *--v2030 = v2042;
        }
        while (v2021 != v2023);
      }
      v2021 = *a1;
      v2043 = a1[1];
      *a1 = v2030;
      a1[1] = (uint64_t *)v2022;
      a1[2] = v2031;
      while (v2043 != v2021)
      {
        v2045 = *--v2043;
        v2044 = v2045;
        *v2043 = 0;
        if (v2045)
          (*(void (**)(uint64_t))(*(_QWORD *)v2044 + 8))(v2044);
      }
      goto LABEL_1897;
    }
  }
  *a1 = v2030;
  a1[1] = (uint64_t *)v2022;
  a1[2] = v2031;
LABEL_1897:
  if (v2021)
    operator delete(v2021);
LABEL_1899:
  a1[1] = (uint64_t *)v2022;
  v2046 = operator new();
  v2047 = v2046;
  strcpy((char *)(v2046 + 8), "depth_to_space");
  *(_BYTE *)(v2046 + 23) = 0;
  *(_BYTE *)(v2046 + 31) = 14;
  *(_QWORD *)v2046 = off_1E0E17D10;
  v2049 = a1[1];
  v2048 = (unint64_t)a1[2];
  if ((unint64_t)v2049 < v2048)
  {
    *v2049 = v2046;
    v2050 = (uint64_t)(v2049 + 1);
    goto LABEL_1925;
  }
  v2051 = *a1;
  v2052 = (char *)v2049 - (char *)*a1;
  v2053 = v2052 >> 3;
  v2054 = (v2052 >> 3) + 1;
  if (v2054 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v2055 = v2048 - (_QWORD)v2051;
  if (v2055 >> 2 > v2054)
    v2054 = v2055 >> 2;
  if ((unint64_t)v2055 >= 0x7FFFFFFFFFFFFFF8)
    v2056 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v2056 = v2054;
  if (v2056)
  {
    if (v2056 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v2057 = (char *)operator new(8 * v2056);
    v2058 = (uint64_t *)&v2057[8 * v2053];
    v2059 = (uint64_t *)&v2057[8 * v2056];
    *v2058 = v2047;
    v2050 = (uint64_t)(v2058 + 1);
    v2060 = (char *)((char *)v2049 - (char *)v2051);
    if (v2049 != v2051)
      goto LABEL_1910;
  }
  else
  {
    v2057 = 0;
    v2058 = (uint64_t *)(8 * v2053);
    v2059 = 0;
    *(_QWORD *)(8 * v2053) = v2047;
    v2050 = 8 * v2053 + 8;
    v2060 = (char *)((char *)v2049 - (char *)v2051);
    if (v2049 != v2051)
    {
LABEL_1910:
      v2061 = (unint64_t)(v2060 - 8);
      if (v2061 < 0x78
        || (uint64_t *)((char *)v2049 - (v2061 & 0xFFFFFFFFFFFFFFF8) - 8) < v2058
        && &v2057[v2052 - (v2061 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v2049)
      {
        goto LABEL_2261;
      }
      v2062 = (v2061 >> 3) + 1;
      v2063 = 8 * (v2062 & 0x3FFFFFFFFFFFFFFCLL);
      v2058 = (uint64_t *)((char *)v2058 - v2063);
      v2064 = &v2049[v2063 / 0xFFFFFFFFFFFFFFF8];
      v2065 = v2049 - 2;
      v2066 = &v2057[8 * v2053 - 16];
      v2067 = v2062 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v2069 = *((_OWORD *)v2065 - 1);
        v2068 = *(_OWORD *)v2065;
        *((_OWORD *)v2065 - 1) = 0uLL;
        *(_OWORD *)v2065 = 0uLL;
        *((_OWORD *)v2066 - 1) = v2069;
        *(_OWORD *)v2066 = v2068;
        v2065 -= 4;
        v2066 -= 32;
        v2067 -= 4;
      }
      while (v2067);
      v2049 = v2064;
      if (v2062 != (v2062 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2261:
        do
        {
          v2070 = *--v2049;
          *v2049 = 0;
          *--v2058 = v2070;
        }
        while (v2049 != v2051);
      }
      v2049 = *a1;
      v2071 = a1[1];
      *a1 = v2058;
      a1[1] = (uint64_t *)v2050;
      a1[2] = v2059;
      while (v2071 != v2049)
      {
        v2073 = *--v2071;
        v2072 = v2073;
        *v2071 = 0;
        if (v2073)
          (*(void (**)(uint64_t))(*(_QWORD *)v2072 + 8))(v2072);
      }
      goto LABEL_1923;
    }
  }
  *a1 = v2058;
  a1[1] = (uint64_t *)v2050;
  a1[2] = v2059;
LABEL_1923:
  if (v2049)
    operator delete(v2049);
LABEL_1925:
  a1[1] = (uint64_t *)v2050;
  v2074 = operator new();
  v2075 = v2074;
  strcpy((char *)(v2074 + 8), "space_to_depth");
  *(_BYTE *)(v2074 + 23) = 0;
  *(_BYTE *)(v2074 + 31) = 14;
  *(_QWORD *)v2074 = off_1E0E17D38;
  v2077 = a1[1];
  v2076 = (unint64_t)a1[2];
  if ((unint64_t)v2077 < v2076)
  {
    *v2077 = v2074;
    v2078 = (uint64_t)(v2077 + 1);
    goto LABEL_1951;
  }
  v2079 = *a1;
  v2080 = (char *)v2077 - (char *)*a1;
  v2081 = v2080 >> 3;
  v2082 = (v2080 >> 3) + 1;
  if (v2082 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v2083 = v2076 - (_QWORD)v2079;
  if (v2083 >> 2 > v2082)
    v2082 = v2083 >> 2;
  if ((unint64_t)v2083 >= 0x7FFFFFFFFFFFFFF8)
    v2084 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v2084 = v2082;
  if (v2084)
  {
    if (v2084 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v2085 = (char *)operator new(8 * v2084);
    v2086 = (uint64_t *)&v2085[8 * v2081];
    v2087 = (uint64_t *)&v2085[8 * v2084];
    *v2086 = v2075;
    v2078 = (uint64_t)(v2086 + 1);
    v2088 = (char *)((char *)v2077 - (char *)v2079);
    if (v2077 != v2079)
      goto LABEL_1936;
  }
  else
  {
    v2085 = 0;
    v2086 = (uint64_t *)(8 * v2081);
    v2087 = 0;
    *(_QWORD *)(8 * v2081) = v2075;
    v2078 = 8 * v2081 + 8;
    v2088 = (char *)((char *)v2077 - (char *)v2079);
    if (v2077 != v2079)
    {
LABEL_1936:
      v2089 = (unint64_t)(v2088 - 8);
      if (v2089 < 0x78
        || (uint64_t *)((char *)v2077 - (v2089 & 0xFFFFFFFFFFFFFFF8) - 8) < v2086
        && &v2085[v2080 - (v2089 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v2077)
      {
        goto LABEL_2262;
      }
      v2090 = (v2089 >> 3) + 1;
      v2091 = 8 * (v2090 & 0x3FFFFFFFFFFFFFFCLL);
      v2086 = (uint64_t *)((char *)v2086 - v2091);
      v2092 = &v2077[v2091 / 0xFFFFFFFFFFFFFFF8];
      v2093 = v2077 - 2;
      v2094 = &v2085[8 * v2081 - 16];
      v2095 = v2090 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v2097 = *((_OWORD *)v2093 - 1);
        v2096 = *(_OWORD *)v2093;
        *((_OWORD *)v2093 - 1) = 0uLL;
        *(_OWORD *)v2093 = 0uLL;
        *((_OWORD *)v2094 - 1) = v2097;
        *(_OWORD *)v2094 = v2096;
        v2093 -= 4;
        v2094 -= 32;
        v2095 -= 4;
      }
      while (v2095);
      v2077 = v2092;
      if (v2090 != (v2090 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2262:
        do
        {
          v2098 = *--v2077;
          *v2077 = 0;
          *--v2086 = v2098;
        }
        while (v2077 != v2079);
      }
      v2077 = *a1;
      v2099 = a1[1];
      *a1 = v2086;
      a1[1] = (uint64_t *)v2078;
      a1[2] = v2087;
      while (v2099 != v2077)
      {
        v2101 = *--v2099;
        v2100 = v2101;
        *v2099 = 0;
        if (v2101)
          (*(void (**)(uint64_t))(*(_QWORD *)v2100 + 8))(v2100);
      }
      goto LABEL_1949;
    }
  }
  *a1 = v2086;
  a1[1] = (uint64_t *)v2078;
  a1[2] = v2087;
LABEL_1949:
  if (v2077)
    operator delete(v2077);
LABEL_1951:
  a1[1] = (uint64_t *)v2078;
  v2102 = operator new();
  v2103 = v2102;
  strcpy((char *)(v2102 + 8), "pixel_shuffle");
  *(_WORD *)(v2102 + 22) = 0;
  *(_BYTE *)(v2102 + 31) = 13;
  *(_QWORD *)v2102 = off_1E0E17D60;
  v2105 = a1[1];
  v2104 = (unint64_t)a1[2];
  if ((unint64_t)v2105 < v2104)
  {
    *v2105 = v2102;
    v2106 = (uint64_t)(v2105 + 1);
    goto LABEL_1977;
  }
  v2107 = *a1;
  v2108 = (char *)v2105 - (char *)*a1;
  v2109 = v2108 >> 3;
  v2110 = (v2108 >> 3) + 1;
  if (v2110 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v2111 = v2104 - (_QWORD)v2107;
  if (v2111 >> 2 > v2110)
    v2110 = v2111 >> 2;
  if ((unint64_t)v2111 >= 0x7FFFFFFFFFFFFFF8)
    v2112 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v2112 = v2110;
  if (v2112)
  {
    if (v2112 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v2113 = (char *)operator new(8 * v2112);
    v2114 = (uint64_t *)&v2113[8 * v2109];
    v2115 = (uint64_t *)&v2113[8 * v2112];
    *v2114 = v2103;
    v2106 = (uint64_t)(v2114 + 1);
    v2116 = (char *)((char *)v2105 - (char *)v2107);
    if (v2105 != v2107)
      goto LABEL_1962;
  }
  else
  {
    v2113 = 0;
    v2114 = (uint64_t *)(8 * v2109);
    v2115 = 0;
    *(_QWORD *)(8 * v2109) = v2103;
    v2106 = 8 * v2109 + 8;
    v2116 = (char *)((char *)v2105 - (char *)v2107);
    if (v2105 != v2107)
    {
LABEL_1962:
      v2117 = (unint64_t)(v2116 - 8);
      if (v2117 < 0x78
        || (uint64_t *)((char *)v2105 - (v2117 & 0xFFFFFFFFFFFFFFF8) - 8) < v2114
        && &v2113[v2108 - (v2117 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v2105)
      {
        goto LABEL_2263;
      }
      v2118 = (v2117 >> 3) + 1;
      v2119 = 8 * (v2118 & 0x3FFFFFFFFFFFFFFCLL);
      v2114 = (uint64_t *)((char *)v2114 - v2119);
      v2120 = &v2105[v2119 / 0xFFFFFFFFFFFFFFF8];
      v2121 = v2105 - 2;
      v2122 = &v2113[8 * v2109 - 16];
      v2123 = v2118 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v2125 = *((_OWORD *)v2121 - 1);
        v2124 = *(_OWORD *)v2121;
        *((_OWORD *)v2121 - 1) = 0uLL;
        *(_OWORD *)v2121 = 0uLL;
        *((_OWORD *)v2122 - 1) = v2125;
        *(_OWORD *)v2122 = v2124;
        v2121 -= 4;
        v2122 -= 32;
        v2123 -= 4;
      }
      while (v2123);
      v2105 = v2120;
      if (v2118 != (v2118 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2263:
        do
        {
          v2126 = *--v2105;
          *v2105 = 0;
          *--v2114 = v2126;
        }
        while (v2105 != v2107);
      }
      v2105 = *a1;
      v2127 = a1[1];
      *a1 = v2114;
      a1[1] = (uint64_t *)v2106;
      a1[2] = v2115;
      while (v2127 != v2105)
      {
        v2129 = *--v2127;
        v2128 = v2129;
        *v2127 = 0;
        if (v2129)
          (*(void (**)(uint64_t))(*(_QWORD *)v2128 + 8))(v2128);
      }
      goto LABEL_1975;
    }
  }
  *a1 = v2114;
  a1[1] = (uint64_t *)v2106;
  a1[2] = v2115;
LABEL_1975:
  if (v2105)
    operator delete(v2105);
LABEL_1977:
  a1[1] = (uint64_t *)v2106;
  v2130 = operator new();
  v2131 = v2130;
  strcpy((char *)(v2130 + 8), "pixel_unshuffle");
  *(_BYTE *)(v2130 + 31) = 15;
  *(_QWORD *)v2130 = off_1E0E17D88;
  v2133 = a1[1];
  v2132 = (unint64_t)a1[2];
  if ((unint64_t)v2133 < v2132)
  {
    *v2133 = v2130;
    v2134 = (uint64_t)(v2133 + 1);
    goto LABEL_2003;
  }
  v2135 = *a1;
  v2136 = (char *)v2133 - (char *)*a1;
  v2137 = v2136 >> 3;
  v2138 = (v2136 >> 3) + 1;
  if (v2138 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v2139 = v2132 - (_QWORD)v2135;
  if (v2139 >> 2 > v2138)
    v2138 = v2139 >> 2;
  if ((unint64_t)v2139 >= 0x7FFFFFFFFFFFFFF8)
    v2140 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v2140 = v2138;
  if (v2140)
  {
    if (v2140 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v2141 = (char *)operator new(8 * v2140);
    v2142 = (uint64_t *)&v2141[8 * v2137];
    v2143 = (uint64_t *)&v2141[8 * v2140];
    *v2142 = v2131;
    v2134 = (uint64_t)(v2142 + 1);
    v2144 = (char *)((char *)v2133 - (char *)v2135);
    if (v2133 != v2135)
      goto LABEL_1988;
  }
  else
  {
    v2141 = 0;
    v2142 = (uint64_t *)(8 * v2137);
    v2143 = 0;
    *(_QWORD *)(8 * v2137) = v2131;
    v2134 = 8 * v2137 + 8;
    v2144 = (char *)((char *)v2133 - (char *)v2135);
    if (v2133 != v2135)
    {
LABEL_1988:
      v2145 = (unint64_t)(v2144 - 8);
      if (v2145 < 0x78
        || (uint64_t *)((char *)v2133 - (v2145 & 0xFFFFFFFFFFFFFFF8) - 8) < v2142
        && &v2141[v2136 - (v2145 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v2133)
      {
        goto LABEL_2264;
      }
      v2146 = (v2145 >> 3) + 1;
      v2147 = 8 * (v2146 & 0x3FFFFFFFFFFFFFFCLL);
      v2142 = (uint64_t *)((char *)v2142 - v2147);
      v2148 = &v2133[v2147 / 0xFFFFFFFFFFFFFFF8];
      v2149 = v2133 - 2;
      v2150 = &v2141[8 * v2137 - 16];
      v2151 = v2146 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v2153 = *((_OWORD *)v2149 - 1);
        v2152 = *(_OWORD *)v2149;
        *((_OWORD *)v2149 - 1) = 0uLL;
        *(_OWORD *)v2149 = 0uLL;
        *((_OWORD *)v2150 - 1) = v2153;
        *(_OWORD *)v2150 = v2152;
        v2149 -= 4;
        v2150 -= 32;
        v2151 -= 4;
      }
      while (v2151);
      v2133 = v2148;
      if (v2146 != (v2146 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2264:
        do
        {
          v2154 = *--v2133;
          *v2133 = 0;
          *--v2142 = v2154;
        }
        while (v2133 != v2135);
      }
      v2133 = *a1;
      v2155 = a1[1];
      *a1 = v2142;
      a1[1] = (uint64_t *)v2134;
      a1[2] = v2143;
      while (v2155 != v2133)
      {
        v2157 = *--v2155;
        v2156 = v2157;
        *v2155 = 0;
        if (v2157)
          (*(void (**)(uint64_t))(*(_QWORD *)v2156 + 8))(v2156);
      }
      goto LABEL_2001;
    }
  }
  *a1 = v2142;
  a1[1] = (uint64_t *)v2134;
  a1[2] = v2143;
LABEL_2001:
  if (v2133)
    operator delete(v2133);
LABEL_2003:
  a1[1] = (uint64_t *)v2134;
  v2158 = operator new();
  v2159 = v2158;
  *(_QWORD *)(v2158 + 8) = 0x7261705F646E6162;
  *(_QWORD *)(v2158 + 16) = 116;
  *(_BYTE *)(v2158 + 31) = 9;
  *(_QWORD *)v2158 = off_1E0E17DB0;
  v2161 = a1[1];
  v2160 = (unint64_t)a1[2];
  if ((unint64_t)v2161 < v2160)
  {
    *v2161 = v2158;
    v2162 = (uint64_t)(v2161 + 1);
    goto LABEL_2029;
  }
  v2163 = *a1;
  v2164 = (char *)v2161 - (char *)*a1;
  v2165 = v2164 >> 3;
  v2166 = (v2164 >> 3) + 1;
  if (v2166 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v2167 = v2160 - (_QWORD)v2163;
  if (v2167 >> 2 > v2166)
    v2166 = v2167 >> 2;
  if ((unint64_t)v2167 >= 0x7FFFFFFFFFFFFFF8)
    v2168 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v2168 = v2166;
  if (v2168)
  {
    if (v2168 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v2169 = (char *)operator new(8 * v2168);
    v2170 = (uint64_t *)&v2169[8 * v2165];
    v2171 = (uint64_t *)&v2169[8 * v2168];
    *v2170 = v2159;
    v2162 = (uint64_t)(v2170 + 1);
    v2172 = (char *)((char *)v2161 - (char *)v2163);
    if (v2161 != v2163)
      goto LABEL_2014;
  }
  else
  {
    v2169 = 0;
    v2170 = (uint64_t *)(8 * v2165);
    v2171 = 0;
    *(_QWORD *)(8 * v2165) = v2159;
    v2162 = 8 * v2165 + 8;
    v2172 = (char *)((char *)v2161 - (char *)v2163);
    if (v2161 != v2163)
    {
LABEL_2014:
      v2173 = (unint64_t)(v2172 - 8);
      if (v2173 < 0x78
        || (uint64_t *)((char *)v2161 - (v2173 & 0xFFFFFFFFFFFFFFF8) - 8) < v2170
        && &v2169[v2164 - (v2173 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v2161)
      {
        goto LABEL_2265;
      }
      v2174 = (v2173 >> 3) + 1;
      v2175 = 8 * (v2174 & 0x3FFFFFFFFFFFFFFCLL);
      v2170 = (uint64_t *)((char *)v2170 - v2175);
      v2176 = &v2161[v2175 / 0xFFFFFFFFFFFFFFF8];
      v2177 = v2161 - 2;
      v2178 = &v2169[8 * v2165 - 16];
      v2179 = v2174 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v2181 = *((_OWORD *)v2177 - 1);
        v2180 = *(_OWORD *)v2177;
        *((_OWORD *)v2177 - 1) = 0uLL;
        *(_OWORD *)v2177 = 0uLL;
        *((_OWORD *)v2178 - 1) = v2181;
        *(_OWORD *)v2178 = v2180;
        v2177 -= 4;
        v2178 -= 32;
        v2179 -= 4;
      }
      while (v2179);
      v2161 = v2176;
      if (v2174 != (v2174 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_2265:
        do
        {
          v2182 = *--v2161;
          *v2161 = 0;
          *--v2170 = v2182;
        }
        while (v2161 != v2163);
      }
      v2161 = *a1;
      v2183 = a1[1];
      *a1 = v2170;
      a1[1] = (uint64_t *)v2162;
      a1[2] = v2171;
      while (v2183 != v2161)
      {
        v2185 = *--v2183;
        v2184 = v2185;
        *v2183 = 0;
        if (v2185)
          (*(void (**)(uint64_t))(*(_QWORD *)v2184 + 8))(v2184);
      }
      goto LABEL_2027;
    }
  }
  *a1 = v2170;
  a1[1] = (uint64_t *)v2162;
  a1[2] = v2171;
LABEL_2027:
  if (v2161)
    operator delete(v2161);
LABEL_2029:
  a1[1] = (uint64_t *)v2162;
}

void sub_180E58B58(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::BatchNormPattern::~BatchNormPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::BatchNormPattern::matchAndRewrite(_anonymous_namespace_::BatchNormPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::Float32Type **v6;
  uint64_t ArgValue;
  mlir::MLIRContext *v8;
  uint64_t v9;
  uint64_t *v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  uint64_t *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v17;
  mlir::GenericProgramPoint *v18;
  const void ***v19;
  const void ***v20;
  const void **v21;
  const void **v22;
  const void ***v23;
  BOOL v24;
  char *v25;
  char **v26;
  char *v27;
  char **v28;
  char *v29;
  char *v30;
  unint64_t v31;
  int v32;
  char *v33;
  size_t v34;
  _BOOL4 v35;
  int v36;
  char **v37;
  char *v38;
  _QWORD *v39;
  unint64_t v40;
  int v41;
  unint64_t v42;
  char *v43;
  char *v44;
  size_t v45;
  _BOOL4 v46;
  int v47;
  _BOOL4 v48;
  uint64_t v49;
  _QWORD *v51;
  uint64_t ParameterValue;
  uint64_t v53;
  uint64_t v54;
  int v55;
  mlir::MLIRContext *v56;
  float v57;
  llvm::APFloatBase *F32FloatAttr;
  mlir::MLIRContext *v59;
  float v60;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v62;
  uint64_t IntegerType;
  uint64_t **v64;
  uint64_t InterfaceFor;
  const char *v66;
  int v67;
  const char *v68;
  const char *v69;
  unint64_t *v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  char *v74;
  char *v75;
  uint64_t *v76;
  mlir::GenericProgramPoint *v77;
  mlir::GenericProgramPoint *v78;
  mlir::GenericProgramPoint *v79;
  mlir::GenericProgramPoint *v80;
  uint64_t v81;
  char *__s2;
  __int128 v83;
  uint64_t Constant;
  char *v85[2];
  uint64_t ElementTypeOrSelf;
  llvm::APFloatBase *v87;
  uint64_t v88;
  uint64_t OptionalArgValue;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  __int128 v93;
  unint64_t v94;
  int v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v6 = a3 + 13;
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v92 = ArgValue;
  v91 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "mean");
  v90 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "variance");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "beta");
  v87 = 0;
  v88 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "gamma");
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  if (!OptionalArgValue)
  {
    v9 = mlir::Float32Type::get(*v6, v8);
    Constant = 1;
    v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v9, 0);
    Constant = mlir::mps::getConstantAttr<float>(v10, 0.0);
    v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&Constant);
    if (!*((_DWORD *)v11 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    OptionalArgValue = (uint64_t)v11 - 16;
    if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    {
      v12 = mlir::getElementTypeOrSelf(ArgValue);
      Constant = mlir::TypeAttr::get(v12);
      v13 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &OptionalArgValue, &Constant);
      if (!*((_DWORD *)v13 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      OptionalArgValue = (uint64_t)v13 - 16;
    }
  }
  if (!v88)
  {
    v14 = mlir::Float32Type::get(*v6, v8);
    Constant = 1;
    v15 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v14, 0);
    Constant = mlir::mps::getConstantAttr<float>(v15, 1.0);
    v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&Constant);
    if (!*((_DWORD *)v16 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v88 = (uint64_t)v16 - 16;
    if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    {
      v17 = mlir::getElementTypeOrSelf(ArgValue);
      Constant = mlir::TypeAttr::get(v17);
      v18 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v88, &Constant);
      if (!*((_DWORD *)v18 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v88 = (uint64_t)v18 - 16;
    }
  }
  v95 = 1;
  v94 = 0xFFFFFFFF00000001;
  v93 = xmmword_181240F20;
  v19 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v85[0] = 0;
  v85[1] = 0;
  Constant = (uint64_t)v85;
  v20 = v19 + 1;
  v21 = *v19;
  if (*v19 == (const void **)(v19 + 1))
    goto LABEL_53;
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&Constant, (uint64_t *)v85, v21 + 4, (uint64_t)(v21 + 4));
    v22 = (const void **)v21[1];
    if (v22)
    {
      do
      {
        v23 = (const void ***)v22;
        v22 = (const void **)*v22;
      }
      while (v22);
    }
    else
    {
      do
      {
        v23 = (const void ***)v21[2];
        v24 = *v23 == v21;
        v21 = (const void **)v23;
      }
      while (!v24);
    }
    v21 = (const void **)v23;
  }
  while (v23 != v20);
  v25 = v85[0];
  HIBYTE(v83) = 7;
  strcpy((char *)&__s2, "epsilon");
  if (!v85[0])
    goto LABEL_53;
  v26 = v85;
  do
  {
    v27 = v25;
    v28 = v26;
    v30 = v25 + 32;
    v29 = (char *)*((_QWORD *)v25 + 4);
    v31 = v27[55];
    v32 = (char)v31;
    if ((v31 & 0x80u) != 0)
      v31 = *((_QWORD *)v27 + 5);
    if (v32 >= 0)
      v33 = v30;
    else
      v33 = v29;
    if (v31 >= 7)
      v34 = 7;
    else
      v34 = v31;
    v35 = v31 < 7;
    v36 = memcmp(v33, &__s2, v34);
    if (v36)
      v35 = v36 < 0;
    v37 = (char **)(v27 + 8);
    if (v35)
    {
      v26 = v28;
    }
    else
    {
      v37 = (char **)v27;
      v26 = (char **)v27;
    }
    v25 = *v37;
  }
  while (v25);
  if (v26 == v85)
    goto LABEL_53;
  v38 = (char *)(v28 + 4);
  if (v35)
    v39 = v28;
  else
    v39 = v27;
  if (!v35)
    v38 = v30;
  v40 = *((unsigned __int8 *)v26 + 55);
  v41 = (char)v40;
  v43 = (char *)v39[4];
  v42 = v39[5];
  if ((v40 & 0x80u) != 0)
    v40 = v42;
  if (v41 >= 0)
    v44 = v38;
  else
    v44 = v43;
  if (v40 >= 7)
    v45 = 7;
  else
    v45 = v40;
  v46 = v40 > 7;
  v47 = memcmp(&__s2, v44, v45);
  v48 = v47 < 0;
  if (!v47)
    v48 = v46;
  if (v48)
  {
LABEL_53:
    __s2 = (char *)operator new(0x30uLL);
    v83 = xmmword_181286A90;
    strcpy(__s2, "Could not find parameter with name 'epsilon'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_54:
    if (SHIBYTE(v83) < 0)
      operator delete(__s2);
    v49 = 0;
    goto LABEL_57;
  }
  if (v35)
    v51 = v28;
  else
    v51 = v27;
  if (v51[8] - v51[7] != 16)
  {
    __s2 = (char *)operator new(0x28uLL);
    v83 = xmmword_181287DB0;
    strcpy(__s2, "Unexpected argument size for 'epsilon'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v83) = 7;
  strcpy((char *)&__s2, "epsilon");
  ParameterValue = MIL::IROperation::GetParameterValue();
  v53 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
  if (SHIBYTE(v83) < 0)
    operator delete(__s2);
  if (!v53)
  {
    __s2 = (char *)operator new(0x38uLL);
    v83 = xmmword_181286AB0;
    strcpy(__s2, "Failed to materialize constant: value is not a tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
    goto LABEL_54;
  }
  v54 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v53 + 32))(v53);
  v55 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v54 + 88))(v54);
  if (v55 == 4)
  {
    HIBYTE(v83) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    LOWORD(v81) = MIL::IRValue::GetScalar<MIL::Fp16>();
    MIL::Fp16::GetFloat((MIL::Fp16 *)&v81);
    F32FloatAttr = mlir::Builder::getF32FloatAttr(a3 + 13, v60, v59);
  }
  else
  {
    if (v55 != 5)
    {
      __s2 = (char *)operator new(0x20uLL);
      v83 = xmmword_181268750;
      strcpy(__s2, "Unexpected MIL element type.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
      goto LABEL_54;
    }
    HIBYTE(v83) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    MIL::IRValue::GetScalar<float>();
    F32FloatAttr = mlir::Builder::getF32FloatAttr(a3 + 13, v57, v56);
  }
  v87 = F32FloatAttr;
  if (SHIBYTE(v83) < 0)
    operator delete(__s2);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 1)
  {
    __s2 = (char *)operator new(0x40uLL);
    v83 = xmmword_18125E6C0;
    strcpy(__s2, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v83) = 1;
  LOWORD(__s2) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(v83) < 0)
    operator delete(__s2);
  v62 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v81 = 0;
  v81 = MIL::IRTensorValueType::Rank(v62);
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v64 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v81, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64))
  {
    v66 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v67 = 566;
    v68 = "Casting.h";
    v69 = "cast";
LABEL_105:
    __assert_rtn(v69, v68, v67, v66);
  }
  if (v64)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64);
    if (!InterfaceFor)
    {
      v66 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v67 = 98;
      v68 = "InterfaceSupport.h";
      v69 = "Interface";
      goto LABEL_105;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  if (v81 == 3)
    v70 = &v94;
  else
    v70 = (unint64_t *)&v93;
  if (v81 == 3)
    v71 = 12;
  else
    v71 = 16;
  v72 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v64, InterfaceFor, v70, v71, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v72) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  __s2 = (char *)v72;
  v80 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__s2);
  __s2 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 13, LocationForOp, &v91, &v80);
  v79 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 13, LocationForOp, &v90, &v80);
  v78 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 13, LocationForOp, &v88, &v80);
  v77 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 13, LocationForOp, &OptionalArgValue, &v80);
  v73 = mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::FloatAttr &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v92, (uint64_t)&__s2, (uint64_t)&v79, (uint64_t)&v78, (uint64_t)&v77, (uint64_t *)&v87);
  (*(void (**)(char **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__s2, a2);
  if (!*(_DWORD *)(v73 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  MILToMLIRRewriter::setValue((uint64_t)a3, (__int128 *)__s2, v73 - 16);
  v74 = __s2;
  if (__s2)
  {
    v75 = (char *)v83;
    v76 = (uint64_t *)__s2;
    if ((char *)v83 != __s2)
    {
      do
      {
        if (*(v75 - 1) < 0)
          operator delete(*((void **)v75 - 3));
        v75 -= 24;
      }
      while (v75 != v74);
      v76 = (uint64_t *)__s2;
    }
    *(_QWORD *)&v83 = v74;
    operator delete(v76);
  }
  v49 = 1;
LABEL_57:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&Constant, v85[0]);
  return v49;
}

void sub_180E59708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,char *a21)
{
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a20, a21);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::FloatAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _BYTE v31[40];
  _QWORD v32[39];

  v32[38] = *MEMORY[0x1E0C80C00];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.normalization", (const unsigned __int8 *)0x11, Context);
  if (!v18)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"mps.normalization";
    v29[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36)
    || !*(_DWORD *)(*(_QWORD *)a5 + 36)
    || !*(_DWORD *)(*(_QWORD *)a6 + 36)
    || !*(_DWORD *)(*(_QWORD *)a7 + 36))
  {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::NormalizationOp::build((uint64_t)a1, (uint64_t)v32, *a3, *(_QWORD *)a4 - 16, *(_QWORD *)a5 - 16, *(_QWORD *)a6 - 16, *(_QWORD *)a7 - 16, *a8);
  v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v23 = 662;
    v24 = "Casting.h";
    v25 = "dyn_cast";
    goto LABEL_13;
  }
  v20 = llvm::DefaultDoCastIfPossible<mlir::mps::NormalizationOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NormalizationOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    v22 = "result && \"builder didn't return the right type\"";
    v23 = 497;
    v24 = "Builders.h";
    v25 = "create";
LABEL_13:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180E599D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E599E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::NormalizationOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NormalizationOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(_QWORD *)AttrData == 0x6D726F6E2E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x6F6974617A696C61
      && *(_BYTE *)(AttrData + 16) == 110)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.normalization";
      v9[3] = 17;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::BatchToSpacePattern::~BatchToSpacePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::BatchToSpacePattern::matchAndRewrite(_anonymous_namespace_::BatchToSpacePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void ***v7;
  const void **v8;
  const void **v9;
  const void ***v10;
  BOOL v11;
  char *v12;
  char **v13;
  char *v14;
  char **v15;
  char *v16;
  char *v17;
  unint64_t v18;
  int v19;
  char *v20;
  size_t v21;
  _BOOL4 v22;
  int v23;
  char **v24;
  char *v25;
  _QWORD *v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  char *v30;
  char *v31;
  size_t v32;
  _BOOL4 v33;
  int v34;
  _BOOL4 v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  _QWORD *v40;
  uint64_t ParameterValue;
  uint64_t Data;
  unint64_t v43;
  unint64_t v44;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v46;
  uint64_t v47;
  unint64_t v48;
  int v49;
  char *v50;
  uint64_t v51;
  uint64_t Context;
  uint64_t v53;
  uint64_t **v54;
  uint64_t InterfaceFor;
  const char *v56;
  int v57;
  const char *v58;
  const char *v59;
  int32x4_t *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t **v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  int32x4_t v68;
  int32x4_t v69;
  int32x4_t *v70;
  int32x4_t v71;
  int32x4_t v72;
  unint64_t v73;
  int32x4_t v74;
  unint64_t v75;
  __int32 *v76;
  __int32 v77;
  int64_t v78;
  int32x4_t *v79;
  uint64_t v80;
  uint64_t v81;
  const char *v82;
  int v83;
  const char *v84;
  const char *v85;
  void *v86;
  mlir::GenericProgramPoint *v87;
  mlir::GenericProgramPoint *v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  uint64_t v95;
  uint64_t *v96;
  mlir::GenericProgramPoint *v97;
  uint64_t v98;
  void **v99;
  void **v100;
  void *v101;
  int v102;
  const char *v103;
  const char *v104;
  const char *v105;
  int v106;
  const char *v107;
  const char *v108;
  const char *v109;
  const char *v110;
  int v111;
  const char *v112;
  const char *v113;
  std::runtime_error *v114;
  std::runtime_error *exception;
  uint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  uint64_t v119;
  int v120;
  uint64_t *v121;
  int v122;
  int v123;
  uint64_t v124;
  void *__p;
  __int128 v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t *v129;
  uint64_t **v130;
  uint64_t v131;
  char **v132;
  char *v133[2];
  uint64_t v134;
  uint64_t ArgValue;
  unint64_t __src;
  char *v137;
  char *v138;
  char *__s2;
  __int128 v140;
  uint64_t v141;

  v141 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v134 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "block_shape");
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v133[0] = 0;
  v133[1] = 0;
  v132 = v133;
  v7 = v6 + 1;
  v8 = *v6;
  if (*v6 == (const void **)(v6 + 1))
    goto LABEL_43;
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v132, (uint64_t *)v133, v8 + 4, (uint64_t)(v8 + 4));
    v9 = (const void **)v8[1];
    if (v9)
    {
      do
      {
        v10 = (const void ***)v9;
        v9 = (const void **)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        v10 = (const void ***)v8[2];
        v11 = *v10 == v8;
        v8 = (const void **)v10;
      }
      while (!v11);
    }
    v8 = (const void **)v10;
  }
  while (v10 != v7);
  v12 = v133[0];
  HIBYTE(v140) = 5;
  strcpy((char *)&__s2, "crops");
  if (!v133[0])
    goto LABEL_43;
  v13 = v133;
  do
  {
    v14 = v12;
    v15 = v13;
    v17 = v12 + 32;
    v16 = (char *)*((_QWORD *)v12 + 4);
    v18 = v14[55];
    v19 = (char)v18;
    if ((v18 & 0x80u) != 0)
      v18 = *((_QWORD *)v14 + 5);
    if (v19 >= 0)
      v20 = v17;
    else
      v20 = v16;
    if (v18 >= 5)
      v21 = 5;
    else
      v21 = v18;
    v22 = v18 < 5;
    v23 = memcmp(v20, &__s2, v21);
    if (v23)
      v22 = v23 < 0;
    v24 = (char **)(v14 + 8);
    if (v22)
    {
      v13 = v15;
    }
    else
    {
      v24 = (char **)v14;
      v13 = (char **)v14;
    }
    v12 = *v24;
  }
  while (v12);
  if (v13 == v133)
    goto LABEL_43;
  v25 = (char *)(v15 + 4);
  if (v22)
    v26 = v15;
  else
    v26 = v14;
  if (!v22)
    v25 = v17;
  v27 = *((unsigned __int8 *)v13 + 55);
  v28 = (char)v27;
  v30 = (char *)v26[4];
  v29 = v26[5];
  if ((v27 & 0x80u) != 0)
    v27 = v29;
  if (v28 >= 0)
    v31 = v25;
  else
    v31 = v30;
  if (v27 >= 5)
    v32 = 5;
  else
    v32 = v27;
  v33 = v27 > 5;
  v34 = memcmp(&__s2, v31, v32);
  v35 = v34 < 0;
  if (!v34)
    v35 = v33;
  if (v35)
  {
LABEL_43:
    __s2 = (char *)operator new(0x30uLL);
    v140 = xmmword_181287DD0;
    strcpy(__s2, "Could not find parameter with name 'crops'.");
    v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_44;
  }
  if (v22)
    v40 = v15;
  else
    v40 = v14;
  if (v40[8] - v40[7] == 16)
  {
    HIBYTE(v140) = 5;
    strcpy((char *)&__s2, "crops");
    ParameterValue = MIL::IROperation::TryGetParameterValue();
    if (SHIBYTE(v140) < 0)
      operator delete(__s2);
    (*(void (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
    Data = MIL::IRTensorValue::GetDataView<int>();
    v44 = v43;
    HIBYTE(v140) = 1;
    LOWORD(__s2) = 120;
    ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
    v46 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
    v47 = MIL::IRTensorValueType::Rank(v46);
    if (SHIBYTE(v140) < 0)
      operator delete(__s2);
    v48 = v44 >> 1;
    if (v47 < (uint64_t)((v44 >> 1 << 32) + 0x100000000) >> 32)
    {
      __s2 = (char *)operator new(0x40uLL);
      v140 = xmmword_18125E6C0;
      strcpy(__s2, "Unexpected length for 'crops' or 'block_shape' or 'rank(x)'");
      v37 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
      if ((SHIBYTE(v140) & 0x80000000) == 0)
        goto LABEL_47;
      v38 = __s2;
      goto LABEL_46;
    }
    v119 = Data;
    v117 = v44 >> 1 << 32;
    if (v47 <= 0)
      v49 = 0;
    else
      v49 = v47 - v48;
    __src = (int)(v44 >> 1);
    v116 = __src;
    __s2 = (char *)&v140 + 8;
    *(_QWORD *)&v140 = 0x100000000;
    llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)&__s2, &__src, &v137);
    v50 = __s2;
    v51 = v140;
    __src = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
    Context = mlir::Attribute::getContext((mlir::Attribute *)&__src);
    v53 = mlir::IntegerType::get(Context, 0x20u, 1u);
    v54 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v50, v51, v53, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54))
    {
      v56 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v57 = 566;
      v58 = "Casting.h";
      v59 = "cast";
LABEL_132:
      __assert_rtn(v59, v58, v57, v56);
    }
    if (v54)
    {
      InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54);
      if (!InterfaceFor)
      {
        v56 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v57 = 98;
        v58 = "InterfaceSupport.h";
        v59 = "Interface";
        goto LABEL_132;
      }
    }
    else
    {
      InterfaceFor = 0;
    }
    v130 = v54;
    v131 = InterfaceFor;
    __src = 0;
    v137 = 0;
    v138 = 0;
    if (v117)
    {
      if (v117 < 0)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      v60 = (int32x4_t *)operator new((4 * (v44 >> 1)) & 0x3FFFFFFFFLL);
      __src = (unint64_t)v60;
      v138 = &v60->i8[4 * v116];
      bzero(v60, (4 * (v44 >> 1)) & 0x3FFFFFFFFLL);
      v118 = v60;
      v61 = &v60->i8[(4 * (v44 >> 1)) & 0x3FFFFFFFFLL];
      v137 = v61;
    }
    else
    {
      v61 = 0;
      v118 = 0;
    }
    __p = (void *)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
    v62 = mlir::Attribute::getContext((mlir::Attribute *)&__p);
    v63 = mlir::IntegerType::get(v62, 0x20u, 1u);
    v64 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v63, 0);
    if ((_DWORD)v48)
    {
      v65 = (v44 >> 1);
      if (v65 < 8)
      {
        v66 = 0;
LABEL_78:
        v75 = v65 - v66;
        v76 = &v118->i32[v66];
        v77 = v66 - v48;
        do
        {
          *v76++ = v77++;
          --v75;
        }
        while (v75);
        goto LABEL_80;
      }
      v67 = (v44 >> 1) & 7;
      v66 = v65 - v67;
      v68 = vdupq_n_s32(v48);
      v69 = (int32x4_t)xmmword_181235170;
      v70 = v118 + 1;
      v71.i64[0] = 0x400000004;
      v71.i64[1] = 0x400000004;
      v72.i64[0] = 0x800000008;
      v72.i64[1] = 0x800000008;
      v73 = v65 - v67;
      do
      {
        v74 = vsubq_s32(v69, v68);
        v70[-1] = v74;
        *v70 = vaddq_s32(v74, v71);
        v69 = vaddq_s32(v69, v72);
        v70 += 2;
        v73 -= 8;
      }
      while (v73);
      if (v67)
        goto LABEL_78;
    }
LABEL_80:
    v78 = v61 - (char *)v118;
    v79 = v118;
    v129 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v130, v131, v118, v78, 4, 1, 1);
    v80 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t *)&v130, &v129);
    if (!*(_DWORD *)(v80 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v128 = v80 - 16;
    if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64))
    {
      if (v64)
      {
        v81 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64);
        if (!v81)
        {
          v82 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          v83 = 98;
          v84 = "InterfaceSupport.h";
          v85 = "Interface";
          goto LABEL_135;
        }
      }
      else
      {
        v81 = 0;
      }
      LODWORD(v124) = 0;
      v86 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v64, v81, &v124, 4, 4, 1, 1);
      if (mlir::DenseIntElementsAttr::classof((uint64_t)v86))
      {
        __p = v86;
        v87 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&__p);
        if (*((_DWORD *)v87 + 9))
        {
          v127 = (uint64_t)v87 - 16;
          if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
          {
            LOBYTE(__p) = 0;
            v88 = mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>(a3 + 13, LocationForOp, &ArgValue, &v128, &v127, &v134, (unsigned __int8 *)&__p);
            if (!*((_DWORD *)v88 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v124 = (uint64_t)v88 - 16;
            if (v117 >= 1)
            {
              v89 = 0;
              v90 = (int)(v44 >> 1);
              if (v116 <= 1)
                v90 = 1;
              v91 = 2 * v90;
              do
              {
                v123 = 0;
                if (v44 <= v89)
                {
                  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                  std::runtime_error::runtime_error(exception, "index out of bounds");
                  exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
                  __cxa_throw(exception, (struct type_info *)off_1E0DF5DB8, MEMORY[0x1E0DE42B0]);
                }
                v92 = *(_DWORD *)(v119 + 4 * v89);
                v122 = 0;
                v123 = v92;
                if (v44 <= v89 + 1)
                {
                  v114 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                  std::runtime_error::runtime_error(v114, "index out of bounds");
                  v114->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
                  __cxa_throw(v114, (struct type_info *)off_1E0DF5DB8, MEMORY[0x1E0DE42B0]);
                }
                v93 = *(_DWORD *)(v119 + 4 * v89 + 4);
                v122 = v93;
                if (v92 > 0 || v93 >= 1)
                {
                  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64))
                  {
                    v106 = 566;
                    v109 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
                    v108 = "Casting.h";
                    v107 = "cast";
LABEL_130:
                    __assert_rtn(v107, v108, v106, v109);
                  }
                  if (v64)
                  {
                    v95 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v64);
                    if (!v95)
                    {
                      v106 = 98;
                      v107 = "Interface";
                      v108 = "InterfaceSupport.h";
                      v109 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
                      goto LABEL_130;
                    }
                  }
                  else
                  {
                    v95 = 0;
                  }
                  v120 = v49;
                  v96 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v64, v95, &v120, 4, 4, 1, 1);
                  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v96) & 1) == 0)
                  {
                    v102 = 566;
                    v103 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
                    v104 = "Casting.h";
                    v105 = "cast";
                    goto LABEL_129;
                  }
                  v121 = v96;
                  v97 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v121);
                  if (!*((_DWORD *)v97 + 9))
                  {
                    v102 = 984;
                    v105 = "getOpResultImpl";
                    v104 = "Operation.h";
                    v103 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
LABEL_129:
                    __assert_rtn(v105, v104, v102, v103);
                  }
                  __p = (char *)v97 - 16;
                  v98 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::Value &,mlir::Value &,int &,int &>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v124, (uint64_t *)&__p, (unsigned int *)&v123, (unsigned int *)&v122);
                  if (!*(_DWORD *)(v98 + 36))
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  v124 = v98 - 16;
                }
                v89 += 2;
                ++v49;
              }
              while (v91 != v89);
            }
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
            MILToMLIRRewriter::setValue((uint64_t)a3, (__int128 *)__p, v124);
            v99 = (void **)__p;
            if (__p)
            {
              v100 = (void **)v126;
              v101 = __p;
              if ((void *)v126 != __p)
              {
                do
                {
                  if (*((char *)v100 - 1) < 0)
                    operator delete(*(v100 - 3));
                  v100 -= 3;
                }
                while (v100 != v99);
                v101 = __p;
              }
              *(_QWORD *)&v126 = v99;
              operator delete(v101);
            }
            v37 = 1;
            v79 = v118;
          }
          else
          {
            __p = operator new(0x40uLL);
            v126 = xmmword_18125E6C0;
            strcpy((char *)__p, "The number of outputs does not match the number of results.");
            v37 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
            if (SHIBYTE(v126) < 0)
              operator delete(__p);
          }
          if (v79)
            operator delete(v79);
          if (__s2 != (char *)&v140 + 8)
            free(__s2);
          goto LABEL_47;
        }
        v110 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
        v111 = 984;
        v112 = "Operation.h";
        v113 = "getOpResultImpl";
      }
      else
      {
        v110 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v111 = 566;
        v112 = "Casting.h";
        v113 = "cast";
      }
      __assert_rtn(v113, v112, v111, v110);
    }
    v82 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v83 = 566;
    v84 = "Casting.h";
    v85 = "cast";
LABEL_135:
    __assert_rtn(v85, v84, v83, v82);
  }
  __s2 = (char *)operator new(0x28uLL);
  v140 = xmmword_181287DC0;
  strcpy(__s2, "Unexpected argument size for 'crops'");
  v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_44:
  v37 = v36;
  if (SHIBYTE(v140) < 0)
  {
    v38 = __s2;
LABEL_46:
    operator delete(v38);
  }
LABEL_47:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v132, v133[0]);
  return v37;
}

void sub_180E5A6F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,char *a30)
{
  uint64_t v30;
  void *v32;

  std::vector<std::string>::~vector[abi:ne180100](&a18);
  if (__p)
    operator delete(__p);
  v32 = *(void **)(v30 + 24);
  if (v32 != a10)
    free(v32);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a29, a30);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::CallPattern::~CallPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::CallPattern::matchAndRewrite(_anonymous_namespace_::CallPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  mlir::MLIRContext **v11;
  const MIL::IRValueType **v12;
  const MIL::IRValueType **v13;
  uint64_t v14;
  uint64_t *Context;
  uint64_t v16;
  char v17;
  void *v18;
  void **v19;
  mlir::MLIRContext *v20;
  mlir::GenericProgramPoint *v21;
  uint64_t v22;
  unint64_t i;
  const char *v24;
  uint64_t ArgValue;
  uint64_t v26;
  _BYTE *v27;
  _BYTE *v28;
  int64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  _BYTE *v34;
  uint64_t *v35;
  int64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  _OWORD *v41;
  __int128 *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  BOOL v48;
  void *v49;
  unint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t NextResultAtOffset;
  char *v54;
  uint64_t *v55;
  void **v56;
  void **v57;
  uint64_t v58;
  const char *v60;
  int v61;
  const char *v62;
  const char *v63;
  uint64_t v64;
  void *v65;
  void *v67;
  int v68[2];
  uint64_t v69;
  void *v70;
  char *v71;
  char *v72;
  void *v73[2];
  unsigned __int8 v74;
  uint64_t v75;
  const char *v76;
  __int16 v77;
  void *__p[38];
  uint64_t v79[4];
  __int16 v80;
  char *v81;
  char *v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  HIBYTE(__p[2]) = 8;
  strcpy((char *)__p, "function");
  MIL::IRObject::GetAttribute();
  MIL::IRValue::GetScalar<std::string>();
  v5 = (*(uint64_t (**)(mlir::StringAttr *, void **))(*(_QWORD *)*a3 + 56))(*a3, v73);
  v6 = (void *)v5;
  if (!v5)
  {
    __p[0] = operator new(0x30uLL);
    *(_OWORD *)&__p[1] = xmmword_181267490;
    strcpy((char *)__p[0], "cannot find the function in the MIL program.");
    v58 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
    if (SHIBYTE(__p[2]) < 0)
    {
      operator delete(__p[0]);
      if (((char)v74 & 0x80000000) == 0)
        return v58;
    }
    else if (((char)v74 & 0x80000000) == 0)
    {
      return v58;
    }
    goto LABEL_71;
  }
  v64 = LocationForOp;
  v70 = 0;
  v71 = 0;
  v72 = 0;
  v7 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 128))(v5);
  v65 = v6;
  v9 = v7 + 1;
  v8 = (_QWORD *)*v7;
  if ((_QWORD *)*v7 != v7 + 1)
  {
    while (1)
    {
      v24 = (const char *)(v8 + 4);
      if (*((char *)v8 + 55) < 0)
        v24 = *(const char **)v24;
      ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, v24);
      v26 = ArgValue;
      v27 = v71;
      if (v71 >= v72)
      {
        v28 = v70;
        v29 = v71 - (_BYTE *)v70;
        v30 = (v71 - (_BYTE *)v70) >> 3;
        v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 61)
          std::vector<long>::__throw_length_error[abi:ne180100]();
        v32 = v72 - (_BYTE *)v70;
        if ((v72 - (_BYTE *)v70) >> 2 > v31)
          v31 = v32 >> 2;
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8)
          v33 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v33 = v31;
        if (v33)
        {
          if (v33 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v34 = operator new(8 * v33);
          v35 = (uint64_t *)&v34[8 * v30];
          *v35 = v26;
          v10 = (uint64_t)(v35 + 1);
          v36 = v27 - v28;
          if (v27 != v28)
          {
LABEL_32:
            v37 = v36 - 8;
            if (v37 < 0x58)
              goto LABEL_89;
            if ((unint64_t)(v27 - v34 - v29) < 0x20)
              goto LABEL_89;
            v38 = (v37 >> 3) + 1;
            v39 = 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
            v40 = &v27[-v39];
            v35 = (uint64_t *)((char *)v35 - v39);
            v41 = &v34[8 * v30 - 16];
            v42 = (__int128 *)(v27 - 16);
            v43 = v38 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v44 = *v42;
              *(v41 - 1) = *(v42 - 1);
              *v41 = v44;
              v41 -= 2;
              v42 -= 2;
              v43 -= 4;
            }
            while (v43);
            v27 = v40;
            if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_89:
              do
              {
                v45 = *((_QWORD *)v27 - 1);
                v27 -= 8;
                *--v35 = v45;
              }
              while (v27 != v28);
            }
            v27 = v70;
            v70 = v35;
            v72 = &v34[8 * v33];
            if (!v27)
              goto LABEL_43;
LABEL_42:
            operator delete(v27);
            goto LABEL_43;
          }
        }
        else
        {
          v34 = 0;
          v35 = (uint64_t *)(8 * v30);
          *(_QWORD *)(8 * v30) = v26;
          v10 = 8 * v30 + 8;
          v36 = v27 - v28;
          if (v27 != v28)
            goto LABEL_32;
        }
        v70 = v35;
        v72 = &v34[8 * v33];
        if (v27)
          goto LABEL_42;
      }
      else
      {
        *(_QWORD *)v71 = ArgValue;
        v10 = (uint64_t)(v27 + 8);
      }
LABEL_43:
      v71 = (char *)v10;
      v46 = (_QWORD *)v8[1];
      if (v46)
      {
        do
        {
          v47 = v46;
          v46 = (_QWORD *)*v46;
        }
        while (v46);
      }
      else
      {
        do
        {
          v47 = (_QWORD *)v8[2];
          v48 = *v47 == (_QWORD)v8;
          v8 = v47;
        }
        while (!v48);
      }
      v8 = v47;
      if (v47 == v9)
        goto LABEL_4;
    }
  }
  v10 = 0;
LABEL_4:
  v67 = 0;
  *(_QWORD *)v68 = 0;
  v69 = 0;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v65 + 160))(__p);
  v11 = a3 + 13;
  v13 = (const MIL::IRValueType **)__p[0];
  v12 = (const MIL::IRValueType **)__p[1];
  if (__p[0] == __p[1])
  {
    v14 = v64;
    if (!__p[0])
      goto LABEL_7;
    goto LABEL_6;
  }
  do
  {
    getMLIRTypes(*v13, *v11, (uint64_t *)&v81);
    std::vector<mlir::Type>::__insert_with_size[abi:ne180100]<std::__wrap_iter<mlir::Type*>,std::__wrap_iter<mlir::Type*>>((uint64_t)&v67, *(uint64_t *)v68, v81, v82, (v82 - v81) >> 3);
    if (v81)
    {
      v82 = v81;
      operator delete(v81);
    }
    ++v13;
  }
  while (v13 != v12);
  v13 = (const MIL::IRValueType **)__p[0];
  v14 = v64;
  if (__p[0])
  {
LABEL_6:
    __p[1] = v13;
    operator delete(v13);
  }
LABEL_7:
  v75 = v14;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v75);
  v16 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.call", (const unsigned __int8 *)8, Context);
  if (!v17)
  {
    v80 = 1283;
    v79[2] = (uint64_t)"mps.call";
    v79[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v77 = 259;
    llvm::operator+(v79, (uint64_t *)&v76, (uint64_t)&v81);
    llvm::report_fatal_error((llvm::Twine *)&v81, 1);
  }
  mlir::OperationState::OperationState(__p, v14, v16);
  mlir::ValueRange::ValueRange((unint64_t *)&v81, (uint64_t)v67, (uint64_t)(*(_QWORD *)v68 - (_QWORD)v67) >> 3);
  v18 = v70;
  mlir::ValueRange::ValueRange((unint64_t *)v79, (uint64_t)v70, (v10 - (uint64_t)v70) >> 3);
  if ((v74 & 0x80u) == 0)
    v19 = v73;
  else
    v19 = (void **)v73[0];
  if ((v74 & 0x80u) == 0)
    v20 = (mlir::MLIRContext *)v74;
  else
    v20 = (mlir::MLIRContext *)v73[1];
  mlir::mps::CallOp::build(v11, (uint64_t)__p, (uint64_t)v81, (uint64_t)v82, v79[0], v79[1], v19, v20, 0);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)v11, (const mlir::OperationState *)__p);
  if (!v21)
  {
    v60 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v61 = 662;
    v62 = "Casting.h";
    v63 = "dyn_cast";
    goto LABEL_83;
  }
  v22 = llvm::DefaultDoCastIfPossible<mlir::mps::CallOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CallOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
  if (!v22)
  {
    v60 = "result && \"builder didn't return the right type\"";
    v61 = 497;
    v62 = "Builders.h";
    v63 = "create";
LABEL_83:
    __assert_rtn(v63, v62, v61, v60);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != *(_DWORD *)(v22 + 36))
    __assert_rtn("matchAndRewrite", "MPSGraphMIL.mm", 1335, "milOp.GetNumOutputs() == callOp->getNumResults()");
  for (i = 0; i != (*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2); ++i)
  {
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
    v50 = *(unsigned int *)(v22 + 36);
    if (i >= v50)
      __assert_rtn("operator[]", "STLExtras.h", 1281, "Index < size() && \"invalid index for value range\"");
    v51 = (char *)__p[0];
    if ((_DWORD)v50)
      v52 = v22 - 16;
    else
      v52 = 0;
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v52, i);
    v54 = (char *)operator new(8uLL);
    *(_QWORD *)v54 = NextResultAtOffset;
    v81 = &v51[24 * i];
    v55 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v81, (uint64_t)&std::piecewise_construct, (__int128 **)&v81);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v55 + 5, v54, v54 + 8, 1uLL);
    operator delete(v54);
    v56 = (void **)__p[0];
    if (__p[0])
    {
      v57 = (void **)__p[1];
      v49 = __p[0];
      if (__p[1] != __p[0])
      {
        do
        {
          if (*((char *)v57 - 1) < 0)
            operator delete(*(v57 - 3));
          v57 -= 3;
        }
        while (v57 != v56);
        v49 = __p[0];
      }
      __p[1] = v56;
      operator delete(v49);
    }
  }
  if (v67)
  {
    *(_QWORD *)v68 = v67;
    operator delete(v67);
  }
  if (v18)
    operator delete(v18);
  v58 = 1;
  if ((char)v74 < 0)
LABEL_71:
    operator delete(v73[0]);
  return v58;
}

void sub_180E5B054(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, _Unwind_Exception *exception_objecta, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);
  _Unwind_Resume(exception_object);
}

char *std::vector<mlir::Type>::__insert_with_size[abi:ne180100]<std::__wrap_iter<mlir::Type*>,std::__wrap_iter<mlir::Type*>>(uint64_t a1, uint64_t a2, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  size_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  __int128 *v38;
  _OWORD *v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  char *v43;
  char *v44;
  unint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _OWORD *v51;
  __int128 *v52;
  uint64_t v53;
  __int128 v54;
  uint64_t v55;
  _BYTE *v56;
  char *v57;
  size_t v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  _OWORD *v62;
  __int128 *v63;
  uint64_t v64;
  __int128 v65;
  uint64_t v66;
  char *v68;

  v5 = *(_QWORD *)a1;
  v6 = a2 - *(_QWORD *)a1;
  v7 = (char *)(*(_QWORD *)a1 + (v6 & 0xFFFFFFFFFFFFFFF8));
  v8 = a5 - 1;
  if (a5 < 1)
    return v7;
  v12 = v6 >> 3;
  v14 = *(char **)(a1 + 8);
  v13 = *(_QWORD *)(a1 + 16);
  if (a5 > (v13 - (uint64_t)v14) >> 3)
  {
    v15 = a5 + ((uint64_t)&v14[-v5] >> 3);
    if (v15 >> 61)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v16 = v13 - v5;
    if (v16 >> 2 > v15)
      v15 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v15;
    if (v17)
    {
      if (v17 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v18 = v17;
      v19 = operator new(8 * v17);
      v17 = v18;
      v12 = v6 >> 3;
    }
    else
    {
      v19 = 0;
    }
    v32 = &v19[8 * v12];
    v33 = &v32[8 * a5];
    v34 = v32;
    v35 = __src;
    if ((v8 & 0x1FFFFFFFFFFFFFFFuLL) < 7)
      goto LABEL_58;
    v34 = &v19[8 * v12];
    v35 = __src;
    if ((unint64_t)(&v19[v6 & 0xFFFFFFFFFFFFFFF8] - __src) < 0x20)
      goto LABEL_58;
    v36 = (v8 & 0x1FFFFFFFFFFFFFFFLL) + 1;
    v37 = 8 * (v36 & 0x3FFFFFFFFFFFFFFCLL);
    v34 = &v32[v37];
    v35 = &__src[v37];
    v38 = (__int128 *)(__src + 16);
    v39 = &v19[8 * v12 + 16];
    v40 = v36 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v41 = *v38;
      *(v39 - 1) = *(v38 - 1);
      *v39 = v41;
      v38 += 2;
      v39 += 2;
      v40 -= 4;
    }
    while (v40);
    if (v36 != (v36 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_58:
      do
      {
        v42 = *(_QWORD *)v35;
        v35 += 8;
        *(_QWORD *)v34 = v42;
        v34 += 8;
      }
      while (v34 != v33);
    }
    v43 = *(char **)a1;
    if (*(char **)a1 == v7)
    {
      v47 = &v19[8 * v12];
      v57 = &v19[8 * v17];
      v58 = v14 - v7;
      if (v14 == v7)
        goto LABEL_39;
    }
    else
    {
      v44 = (char *)((v6 & 0xFFFFFFFFFFFFFFF8) + v5);
      v45 = v44 - v43 - 8;
      v46 = v7;
      v47 = &v19[8 * v12];
      if (v45 < 0x68)
        goto LABEL_59;
      v46 = v7;
      v47 = &v19[8 * v12];
      if ((unint64_t)(v44 - &v19[v6 & 0xFFFFFFFFFFFFFFF8]) < 0x20)
        goto LABEL_59;
      v48 = (v45 >> 3) + 1;
      v49 = 8 * (v48 & 0x3FFFFFFFFFFFFFFCLL);
      v46 = &v7[-v49];
      v47 = &v32[-v49];
      v50 = 8 * v12 - 16;
      v51 = &v19[v50];
      v52 = (__int128 *)(v5 + v50);
      v53 = v48 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v54 = *v52;
        *(v51 - 1) = *(v52 - 1);
        *v51 = v54;
        v51 -= 2;
        v52 -= 2;
        v53 -= 4;
      }
      while (v53);
      if (v48 != (v48 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_59:
        do
        {
          v55 = *((_QWORD *)v46 - 1);
          v46 -= 8;
          *((_QWORD *)v47 - 1) = v55;
          v47 -= 8;
        }
        while (v46 != v43);
      }
      v56 = *(_BYTE **)(a1 + 8);
      v57 = &v19[8 * v17];
      v58 = v56 - v7;
      if (v56 == v7)
        goto LABEL_39;
    }
    memmove(v33, v7, v58);
LABEL_39:
    v59 = *(void **)a1;
    *(_QWORD *)a1 = v47;
    *(_QWORD *)(a1 + 8) = &v33[v58];
    *(_QWORD *)(a1 + 16) = v57;
    if (v59)
      operator delete(v59);
    return v32;
  }
  v20 = (v14 - v7) >> 3;
  if (v20 >= a5)
  {
    v21 = &__src[8 * a5];
    v23 = *(char **)(a1 + 8);
    goto LABEL_18;
  }
  v21 = &__src[8 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
  {
    v68 = &__src[8 * v20];
    memmove(*(void **)(a1 + 8), v68, a4 - v21);
    v12 = v6 >> 3;
    v21 = v68;
  }
  v23 = &v14[v22];
  *(_QWORD *)(a1 + 8) = &v14[v22];
  if (v14 - v7 >= 1)
  {
LABEL_18:
    v24 = &v7[8 * a5];
    v25 = v23 - v24;
    v26 = (v23 - v24) >> 3;
    v27 = &v23[-8 * a5];
    v28 = v23;
    if (v27 < v14)
    {
      v29 = (v6 & 0xFFFFFFFFFFFFFFF8) + v25;
      v30 = v29 + v5 + 8;
      if ((unint64_t)v14 > v30)
        v30 = (unint64_t)v14;
      v31 = v30 + ~v5 - v29;
      if (v31 >= 0x58)
      {
        v28 = v23;
        if ((unint64_t)&v24[-(v6 & 0xFFFFFFFFFFFFFFF8) - v5] >= 0x20)
        {
          v60 = (v31 >> 3) + 1;
          v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
          v27 += v61;
          v28 = &v23[v61];
          v62 = v23 + 16;
          v63 = (__int128 *)(8 * v26 + 8 * v12 + v5 + 16);
          v64 = v60 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v65 = *v63;
            *(v62 - 1) = *(v63 - 1);
            *v62 = v65;
            v62 += 2;
            v63 += 2;
            v64 -= 4;
          }
          while (v64);
          if (v60 == (v60 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_49;
        }
      }
      else
      {
        v28 = v23;
      }
      do
      {
        v66 = *(_QWORD *)v27;
        v27 += 8;
        *(_QWORD *)v28 = v66;
        v28 += 8;
      }
      while (v27 < v14);
    }
LABEL_49:
    *(_QWORD *)(a1 + 8) = v28;
    if (v23 != v24)
      memmove(&v23[-8 * v26], v7, v25);
    if (v21 != __src)
      memmove(v7, __src, v21 - __src);
  }
  return v7;
}

void `anonymous namespace'::CastPattern::~CastPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::CastPattern::matchAndRewrite(_anonymous_namespace_::CastPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t v13;
  uint64_t MLIRElemType;
  void *__p;
  __int128 v17;
  void *v18;
  char v19;
  uint64_t ArgValue;
  __int128 *v21;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  HIBYTE(v17) = 5;
  strcpy((char *)&__p, "dtype");
  MIL::IROperation::TryGetParameterValue();
  MIL::IRValue::GetScalar<std::string>();
  MLIRElemType = MILToMLIRRewriter::getMLIRElemType((uint64_t)a3, (uint64_t)&v18);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &ArgValue, &MLIRElemType);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v21 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v21);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v17;
      v12 = __p;
      if ((void *)v17 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v17 = v10;
      operator delete(v12);
    }
    v13 = 1;
    if (v19 < 0)
      goto LABEL_17;
    return v13;
  }
  __p = operator new(0x40uLL);
  v17 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v13 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v17) < 0)
  {
    operator delete(__p);
    if ((v19 & 0x80000000) == 0)
      return v13;
  }
  else if ((v19 & 0x80000000) == 0)
  {
    return v13;
  }
LABEL_17:
  operator delete(v18);
  return v13;
}

void sub_180E5B868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::ConcatPattern::~ConcatPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::ConcatPattern::matchAndRewrite(_anonymous_namespace_::ConcatPattern *this, const MIL::IROperation *a2, MILToMLIRRewriter *a3)
{
  uint64_t LocationForOp;
  unsigned __int8 v6;
  MIL::IRValue *ParameterValue;
  MIL::IRValueType *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  __int128 *v15;
  char *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v24;
  unsigned __int8 v25;
  _BYTE __p[24];
  void *v27[3];
  __int128 *v28;

  LocationForOp = MILToMLIRRewriter::getLocationForOp((mlir::StringAttr **)a3, a2);
  MILToMLIRRewriter::getArgValues((int8x8_t *)a3, a2, "values", v27);
  strcpy(__p, "interleave");
  if (MIL::IROperation::TryGetParameterValue())
    v6 = MIL::IRValue::GetScalar<BOOL>();
  else
    v6 = 0;
  v25 = v6;
  __p[23] = 4;
  strcpy(__p, "axis");
  ParameterValue = (MIL::IRValue *)MIL::IROperation::GetParameterValue();
  v8 = (MIL::IRValueType *)(*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)ParameterValue + 32))(ParameterValue);
  v9 = MIL::IRValueType::AsTensorType(v8);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 88))(v9) == 11)
  {
    MIL::IRValue::AsTensor(ParameterValue);
    v10 = *(_DWORD *)MIL::IRTensorValue::GetDataView<int>();
    v11 = mlir::IntegerType::get(*((_QWORD *)a3 + 13), 0x20u, 1u);
    v12 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v11, 0);
    *(_QWORD *)__p = mlir::mps::getConstantAttr<int>(v12, v10);
    v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((MILToMLIRRewriter *)((char *)a3 + 104), LocationForOp, (uint64_t **)__p);
    if (!*((_DWORD *)v13 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v24 = (uint64_t)v13 - 16;
    if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
    {
      v14 = mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL &>((mlir::UnitAttr **)a3 + 13, LocationForOp, (uint64_t *)v27, &v24, &v25);
      (*(void (**)(_BYTE *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
      if (!*(_DWORD *)(v14 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v15 = *(__int128 **)__p;
      v16 = (char *)operator new(8uLL);
      *(_QWORD *)v16 = v14 - 16;
      v28 = v15;
      v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a3 + 64, (uint64_t)v15, (uint64_t)&std::piecewise_construct, &v28);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
      operator delete(v16);
      v18 = *(_QWORD *)__p;
      if (*(_QWORD *)__p)
      {
        v19 = *(_QWORD *)&__p[8];
        v20 = *(void **)__p;
        if (*(_QWORD *)&__p[8] != *(_QWORD *)__p)
        {
          do
          {
            if (*(char *)(v19 - 1) < 0)
              operator delete(*(void **)(v19 - 24));
            v19 -= 24;
          }
          while (v19 != v18);
          v20 = *(void **)__p;
        }
        *(_QWORD *)&__p[8] = v18;
        operator delete(v20);
      }
      v21 = 1;
      v22 = v27[0];
      if (!v27[0])
        return v21;
LABEL_19:
      v27[1] = v22;
      operator delete(v22);
      return v21;
    }
    *(_QWORD *)__p = operator new(0x40uLL);
    *(_OWORD *)&__p[8] = xmmword_18125E6C0;
    strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  }
  else
  {
    *(_QWORD *)__p = operator new(0x20uLL);
    *(_OWORD *)&__p[8] = xmmword_18125D370;
    strcpy(*(char **)__p, "unexpected type for axis");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  }
  if ((__p[23] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  v21 = 0;
  v22 = v27[0];
  if (v27[0])
    goto LABEL_19;
  return v21;
}

void sub_180E5BD04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18)
{
  void *v19;

  if (a16 < 0)
  {
    operator delete(__p);
    v19 = a17;
    if (!a17)
LABEL_3:
      _Unwind_Resume(exception_object);
  }
  else
  {
    v19 = a17;
    if (!a17)
      goto LABEL_3;
  }
  operator delete(v19);
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ConcatOp,std::vector<mlir::Value> &,mlir::Value&,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  unint64_t v26[2];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.concat";
    v23[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v11);
  mlir::ValueRange::ValueRange(v26, *a3, (a3[1] - *a3) >> 3);
  mlir::mps::ConcatOp::build(a1, (uint64_t)v27, v26[0], v26[1], *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v27);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ConcatOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ConcatOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v14;
}

void sub_180E5BF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void sub_180E5BF58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::ConstPattern::~ConstPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::ConstPattern::matchAndRewrite(_anonymous_namespace_::ConstPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  MIL::IRValue *Attribute;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 *v10;
  char *v11;
  uint64_t *v12;
  void **v13;
  void **v14;
  void *v15;
  uint64_t result;
  uint64_t v17;
  void *__p;
  __int128 v19;
  uint64_t LocationForOp;
  __int128 *v21;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  HIBYTE(v19) = 3;
  LODWORD(__p) = 7102838;
  Attribute = (MIL::IRValue *)MIL::IRObject::GetAttribute();
  v6 = (*(uint64_t (**)(MIL::IRValue *))(*(_QWORD *)Attribute + 40))(Attribute);
  if (v6)
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 32))(v6);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 88))(v7) == 3)
      return 1;
    v8 = MILToMLIRRewriter::materializeConstant((uint64_t)a3, Attribute, &LocationForOp);
    if (v8)
    {
      v9 = v8;
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
      v10 = (__int128 *)__p;
      v11 = (char *)operator new(8uLL);
      *(_QWORD *)v11 = v9;
      v21 = v10;
      v12 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v10, (uint64_t)&std::piecewise_construct, &v21);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v12 + 5, v11, v11 + 8, 1uLL);
      operator delete(v11);
      v13 = (void **)__p;
      if (__p)
      {
        v14 = (void **)v19;
        v15 = __p;
        if ((void *)v19 != __p)
        {
          do
          {
            if (*((char *)v14 - 1) < 0)
              operator delete(*(v14 - 3));
            v14 -= 3;
          }
          while (v14 != v13);
          v15 = __p;
        }
        *(_QWORD *)&v19 = v13;
        operator delete(v15);
      }
      return 1;
    }
    __p = operator new(0x20uLL);
    v19 = xmmword_181261470;
    strcpy((char *)__p, "Failed to materialize constant.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  }
  else
  {
    __p = operator new(0x28uLL);
    v19 = xmmword_181261460;
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  }
  v17 = result;
  if (SHIBYTE(v19) < 0)
  {
    operator delete(__p);
    return v17;
  }
  return result;
}

void sub_180E5C258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::CumSumPattern::~CumSumPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::CumSumPattern::matchAndRewrite(_anonymous_namespace_::CumSumPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  int v7;
  int v8;
  uint64_t IntegerType;
  uint64_t **v10;
  uint64_t InterfaceFor;
  uint64_t v12;
  mlir::GenericProgramPoint *v13;
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v18;
  __int128 *v19;
  char *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  int v31;
  uint64_t v32;
  const char *v33;
  __int16 v34;
  uint64_t v35[4];
  __int16 v36;
  __int128 *v37[5];
  _BYTE v38[288];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  strcpy(v38, "exclusive");
  MIL::IROperation::TryGetParameterValue();
  v7 = MIL::IRValue::GetScalar<BOOL>();
  strcpy(v38, "reverse");
  MIL::IROperation::TryGetParameterValue();
  v8 = MIL::IRValue::GetScalar<BOOL>();
  v31 = 0;
  v38[23] = 4;
  strcpy(v38, "axis");
  if (MIL::IROperation::TryGetParameterValue())
    v31 = MIL::IRValue::GetScalar<int>();
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v10 = (uint64_t **)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v10))
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  if (v10)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v10);
    if (!InterfaceFor)
      __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
  }
  else
  {
    InterfaceFor = 0;
  }
  v12 = mlir::DenseElementsAttr::getFromRawBuffer(v10, InterfaceFor, &v31, 4, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v12) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  *(_QWORD *)v38 = v12;
  v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)v38);
  if (!*((_DWORD *)v13 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v32 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v32);
    v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_sum", (const unsigned __int8 *)0x12, Context);
    if (!v16)
    {
      v36 = 1283;
      v35[2] = (uint64_t)"mps.cumulative_sum";
      v35[3] = 18;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v34 = 259;
      llvm::operator+(v35, (uint64_t *)&v33, (uint64_t)v37);
      llvm::report_fatal_error((llvm::Twine *)v37, 1);
    }
    mlir::OperationState::OperationState(v38, LocationForOp, v15);
    mlir::mps::CumulativeSumOp::build(a3 + 13, (uint64_t)v38, ArgValue, (uint64_t)v13 - 16, v7, v8);
    v17 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)v38);
    if (v17)
    {
      v18 = llvm::DefaultDoCastIfPossible<mlir::mps::CumulativeSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CumulativeSumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v17);
      if (v18)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)v38);
        (*(void (**)(_BYTE *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(v38, a2);
        if (!*(_DWORD *)(v18 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v19 = *(__int128 **)v38;
        v20 = (char *)operator new(8uLL);
        *(_QWORD *)v20 = v18 - 16;
        v37[0] = v19;
        v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v19, (uint64_t)&std::piecewise_construct, v37);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v21 + 5, v20, v20 + 8, 1uLL);
        operator delete(v20);
        v22 = *(_QWORD *)v38;
        if (*(_QWORD *)v38)
        {
          v23 = *(_QWORD *)&v38[8];
          v24 = *(void **)v38;
          if (*(_QWORD *)&v38[8] != *(_QWORD *)v38)
          {
            do
            {
              if (*(char *)(v23 - 1) < 0)
                operator delete(*(void **)(v23 - 24));
              v23 -= 24;
            }
            while (v23 != v22);
            v24 = *(void **)v38;
          }
          *(_QWORD *)&v38[8] = v22;
          operator delete(v24);
        }
        return 1;
      }
      v27 = "result && \"builder didn't return the right type\"";
      v28 = 497;
      v29 = "Builders.h";
      v30 = "create";
    }
    else
    {
      v27 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v28 = 662;
      v29 = "Casting.h";
      v30 = "dyn_cast";
    }
    __assert_rtn(v30, v29, v28, v27);
  }
  *(_QWORD *)v38 = operator new(0x40uLL);
  *(_OWORD *)&v38[8] = xmmword_18125E6C0;
  strcpy(*(char **)v38, "The number of outputs does not match the number of results.");
  v25 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, v38);
  if ((v38[23] & 0x80000000) != 0)
    operator delete(*(void **)v38);
  return v25;
}

void sub_180E5C85C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a27);
  _Unwind_Resume(a1);
}

void sub_180E5C870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  void **v32;

  if (a32 < 0)
  {
    operator delete(*v32);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::EinsumPattern::~EinsumPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::EinsumPattern::matchAndRewrite(_anonymous_namespace_::EinsumPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  mlir::GenericProgramPoint *v7;
  mlir::GenericProgramPoint *v8;
  uint64_t v9;
  mlir::GenericProgramPoint *v10;
  __int128 *v11;
  uint64_t v12;
  char *v13;
  uint64_t *v14;
  void **v15;
  void **v16;
  void *v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *__p;
  __int128 v24;
  void *v25;
  _BYTE *v26;
  __int128 *v27;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  MILToMLIRRewriter::getArgValues((int8x8_t *)a3, a2, "values", &v25);
  if (v26 - (_BYTE *)v25 == 16)
  {
    v6 = *(_QWORD *)v25;
    v21 = *((_QWORD *)v25 + 1);
    v22 = v6;
    LODWORD(__p) = -2;
    LODWORD(v27) = -3;
    v7 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v22, (unsigned int *)&__p, (unsigned int *)&v27);
    if (!*((_DWORD *)v7 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v22 = (uint64_t)v7 - 16;
    LODWORD(__p) = -2;
    LODWORD(v27) = -3;
    v8 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v21, (unsigned int *)&__p, (unsigned int *)&v27);
    if (!*((_DWORD *)v8 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v21 = (uint64_t)v8 - 16;
    LOBYTE(__p) = 0;
    LOBYTE(v27) = 0;
    v9 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 13, LocationForOp, &v22, &v21, (unsigned __int8 *)&__p, (unsigned __int8 *)&v27);
    if (!*(_DWORD *)(v9 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v20 = v9 - 16;
    LODWORD(__p) = -2;
    LODWORD(v27) = -3;
    v10 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 13), LocationForOp, &v20, (unsigned int *)&__p, (unsigned int *)&v27);
    if (!*((_DWORD *)v10 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v20 = (uint64_t)v10 - 16;
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    v11 = (__int128 *)__p;
    v12 = v20;
    v13 = (char *)operator new(8uLL);
    *(_QWORD *)v13 = v12;
    v27 = v11;
    v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v11, (uint64_t)&std::piecewise_construct, &v27);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v14 + 5, v13, v13 + 8, 1uLL);
    operator delete(v13);
    v15 = (void **)__p;
    if (__p)
    {
      v16 = (void **)v24;
      v17 = __p;
      if ((void *)v24 != __p)
      {
        do
        {
          if (*((char *)v16 - 1) < 0)
            operator delete(*(v16 - 3));
          v16 -= 3;
        }
        while (v16 != v15);
        v17 = __p;
      }
      *(_QWORD *)&v24 = v15;
      operator delete(v17);
    }
    v18 = 1;
  }
  else
  {
    __p = operator new(0x20uLL);
    v24 = xmmword_181261470;
    strcpy((char *)__p, "Non-supported number of inputs.");
    v18 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v24) < 0)
      operator delete(__p);
  }
  if (v25)
  {
    v26 = v25;
    operator delete(v25);
  }
  return v18;
}

void sub_180E5CC88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20)
{
  std::vector<std::string>::~vector[abi:ne180100](&a13);
  if (__p)
  {
    a20 = (uint64_t)__p;
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GELUPattern::~GELUPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GELUPattern::matchAndRewrite(_anonymous_namespace_::GELUPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void **v7;
  const void ***v8;
  const void **v9;
  const void ***v10;
  char *v12;
  char **v13;
  char *v14;
  char **v15;
  char *v16;
  char *v17;
  unint64_t v18;
  int v19;
  char *v20;
  size_t v21;
  _BOOL4 v22;
  int v23;
  char **v24;
  char *v25;
  _QWORD *v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  char *v30;
  char *v31;
  size_t v32;
  _BOOL4 v33;
  int v34;
  _BOOL4 v35;
  char **v36;
  BOOL v37;
  void *v39;
  uint64_t ElementTypeOrSelf;
  _QWORD *v45;
  uint64_t v46;
  _BOOL4 v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t *Context;
  uint64_t v54;
  char v55;
  mlir::GenericProgramPoint *v56;
  mlir::GenericProgramPoint *v57;
  uint64_t v58;
  void *v59;
  __int128 *v60;
  char *v61;
  uint64_t *v62;
  void **v63;
  void **v64;
  void *v65;
  const char *v66;
  int v67;
  const char *v68;
  const char *v69;
  _QWORD *AttrData;
  uint64_t v71;
  mlir::GenericProgramPoint *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  mlir::GenericProgramPoint *v77;
  uint64_t v78;
  char **v79;
  char *v80[2];
  uint64_t ArgValue;
  mlir::GenericProgramPoint *v82;
  uint64_t v83[4];
  __int16 v84;
  uint64_t v85[2];
  const char *v86;
  uint64_t v87;
  __int16 v88;
  __int128 *v89[5];
  void *__p;
  __int128 v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
    v80[0] = 0;
    v80[1] = 0;
    v79 = v80;
    v8 = v6 + 1;
    v7 = *v6;
    if (*v6 == (const void **)(v6 + 1))
      goto LABEL_99;
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v79, (uint64_t *)v80, v7 + 4, (uint64_t)(v7 + 4));
      v9 = (const void **)v7[1];
      if (v9)
      {
        do
        {
          v10 = (const void ***)v9;
          v9 = (const void **)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (const void ***)v7[2];
          v37 = *v10 == v7;
          v7 = (const void **)v10;
        }
        while (!v37);
      }
      v7 = (const void **)v10;
    }
    while (v10 != v8);
    v12 = v80[0];
    HIBYTE(v91) = 4;
    strcpy((char *)&__p, "mode");
    if (!v80[0])
      goto LABEL_99;
    v13 = v80;
    do
    {
      v14 = v12;
      v15 = v13;
      v17 = v12 + 32;
      v16 = (char *)*((_QWORD *)v12 + 4);
      v18 = v14[55];
      v19 = (char)v18;
      if ((v18 & 0x80u) != 0)
        v18 = *((_QWORD *)v14 + 5);
      if (v19 >= 0)
        v20 = v17;
      else
        v20 = v16;
      if (v18 >= 4)
        v21 = 4;
      else
        v21 = v18;
      v22 = v18 < 4;
      v23 = memcmp(v20, &__p, v21);
      if (v23)
        v22 = v23 < 0;
      v24 = (char **)(v14 + 8);
      if (v22)
      {
        v13 = v15;
      }
      else
      {
        v24 = (char **)v14;
        v13 = (char **)v14;
      }
      v12 = *v24;
    }
    while (v12);
    if (v13 == v80)
      goto LABEL_99;
    v25 = (char *)(v15 + 4);
    if (v22)
      v26 = v15;
    else
      v26 = v14;
    if (!v22)
      v25 = v17;
    v27 = *((unsigned __int8 *)v13 + 55);
    v28 = (char)v27;
    v30 = (char *)v26[4];
    v29 = v26[5];
    if ((v27 & 0x80u) != 0)
      v27 = v29;
    if (v28 >= 0)
      v31 = v25;
    else
      v31 = v30;
    if (v27 >= 4)
      v32 = 4;
    else
      v32 = v27;
    v33 = v27 > 4;
    v34 = memcmp(&__p, v31, v32);
    v35 = v34 < 0;
    if (!v34)
      v35 = v33;
    if (v35)
      goto LABEL_99;
    v36 = v22 ? v15 : (char **)v14;
    if (v36[8] - v36[7] != 16)
      goto LABEL_99;
    HIBYTE(v91) = 4;
    strcpy((char *)&__p, "mode");
    MIL::IROperation::TryGetParameterValue();
    if (SHIBYTE(v91) < 0)
      operator delete(__p);
    MIL::IRValue::GetScalar<std::string>();
    if ((SHIBYTE(v91) & 0x80000000) == 0)
    {
      if (HIBYTE(v91) != 18)
      {
        if (HIBYTE(v91) != 21)
          goto LABEL_99;
        v37 = __p == (void *)0x5F44494F4D474953 && (_QWORD)v91 == 0x4D49584F52505041;
        if (!v37 || *(_QWORD *)((char *)&v91 + 5) != 0x4E4F4954414D4958)
          goto LABEL_99;
        goto LABEL_96;
      }
      if (__p != (void *)0x5050415F484E4154 || (_QWORD)v91 != 0x4954414D49584F52 || WORD4(v91) != 20047)
        goto LABEL_99;
LABEL_83:
      __p = (void *)1;
      ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
      v45 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
      __p = (void *)createConstantOpFromScalar((mlir::OpBuilder *)(a3 + 13), LocationForOp, v45, 0.797884583);
      v89[0] = (__int128 *)createConstantOpFromScalar((mlir::OpBuilder *)(a3 + 13), LocationForOp, v45, 0.0447149985);
      v85[0] = createConstantOpFromScalar((mlir::OpBuilder *)(a3 + 13), LocationForOp, v45, 0.5);
      v83[0] = createConstantOpFromScalar((mlir::OpBuilder *)(a3 + 13), LocationForOp, v45, 1.0);
      v82 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, (uint64_t *)v89, &ArgValue);
      v78 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::Value &>(a3 + 13, LocationForOp, (uint64_t)&v82, &ArgValue);
      v77 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, (uint64_t *)&__p, &ArgValue);
      v76 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::MultiplyOp &>(a3 + 13, LocationForOp, v83, (uint64_t)&v78);
      v75 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::mps::AddOp &>(a3 + 13, LocationForOp, (uint64_t)&v77, (uint64_t)&v76);
      v74 = mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::mps::MultiplyOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t)&v75);
      v73 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::TanhOp &>(a3 + 13, LocationForOp, v83, (uint64_t)&v74);
      v72 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, v85, &ArgValue);
      v46 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::mps::AddOp &>(a3 + 13, LocationForOp, (uint64_t)&v72, (uint64_t)&v73);
      if (!*(_DWORD *)(v46 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      goto LABEL_97;
    }
    if ((_QWORD)v91 == 18)
    {
      v39 = __p;
      if (*(_QWORD *)__p == 0x5050415F484E4154
        && *((_QWORD *)__p + 1) == 0x4954414D49584F52
        && *((_WORD *)__p + 8) == 20047)
      {
        operator delete(__p);
        goto LABEL_83;
      }
    }
    else
    {
      v39 = __p;
      if ((_QWORD)v91 == 21)
      {
        v49 = *(_QWORD *)__p != 0x5F44494F4D474953
           || *((_QWORD *)__p + 1) != 0x4D49584F52505041
           || *(_QWORD *)((char *)__p + 13) != 0x4E4F4954414D4958;
        operator delete(__p);
        if (!v49)
        {
LABEL_96:
          __p = (void *)1;
          v50 = mlir::getElementTypeOrSelf(ArgValue);
          v51 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v50, 0);
          __p = (void *)createConstantOpFromScalar((mlir::OpBuilder *)(a3 + 13), LocationForOp, v51, 1.70200002);
          v89[0] = (__int128 *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, (uint64_t *)&__p, &ArgValue);
          v85[0] = mlir::OpBuilder::create<mlir::mps::SigmoidOp,mlir::mps::MultiplyOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t)v89);
          v46 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::SigmoidOp &>(a3 + 13, LocationForOp, &ArgValue, (uint64_t)v85);
          if (!*(_DWORD *)(v46 + 36))
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_97:
          v52 = v46 - 16;
LABEL_105:
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
          v60 = (__int128 *)__p;
          v61 = (char *)operator new(8uLL);
          *(_QWORD *)v61 = v52;
          v89[0] = v60;
          v62 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v60, (uint64_t)&std::piecewise_construct, v89);
          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v62 + 5, v61, v61 + 8, 1uLL);
          operator delete(v61);
          v63 = (void **)__p;
          if (__p)
          {
            v64 = (void **)v91;
            v65 = __p;
            if ((void *)v91 != __p)
            {
              do
              {
                if (*((char *)v64 - 1) < 0)
                  operator delete(*(v64 - 3));
                v64 -= 3;
              }
              while (v64 != v63);
              v65 = __p;
            }
            *(_QWORD *)&v91 = v63;
            operator delete(v65);
          }
          std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v79, v80[0]);
          return 1;
        }
LABEL_99:
        v82 = (mlir::GenericProgramPoint *)LocationForOp;
        Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v82);
        v54 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gelu", (const unsigned __int8 *)8, Context);
        if (!v55)
        {
          v88 = 1283;
          v86 = "mps.gelu";
          v87 = 8;
                            "sn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#register"
                            "ed-loaded-dependent-whats-up-with-dialects-management";
          v84 = 259;
          llvm::operator+(v85, v83, (uint64_t)v89);
          llvm::report_fatal_error((llvm::Twine *)v89, 1);
        }
        mlir::OperationState::OperationState(&__p, LocationForOp, v54);
        mlir::mps::ACosOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue);
        v56 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
        v57 = v56;
        if (v56)
        {
          v58 = *((_QWORD *)v56 + 6);
          v59 = *(void **)(v58 + 16);
          if (v59 == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v89[0] = *(__int128 **)(v58 + 8);
            AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v89);
            if (v71 == 8 && *AttrData == 0x756C65672E73706DLL)
            {
              v88 = 1283;
              v85[0] = (uint64_t)"classof on '";
              v86 = "mps.gelu";
              v87 = 8;
              v83[0] = (uint64_t)"' failed due to the operation not being registered";
              v84 = 259;
              llvm::operator+(v85, v83, (uint64_t)v89);
              llvm::report_fatal_error((llvm::Twine *)v89, 1);
            }
          }
          else if (v59 == &mlir::detail::TypeIDResolver<mlir::mps::GeluOp,void>::id)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
            if (!*((_DWORD *)v57 + 9))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v52 = (uint64_t)v57 - 16;
            goto LABEL_105;
          }
          v66 = "result && \"builder didn't return the right type\"";
          v67 = 497;
          v68 = "Builders.h";
          v69 = "create";
        }
        else
        {
          v66 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          v67 = 662;
          v68 = "Casting.h";
          v69 = "dyn_cast";
        }
        __assert_rtn(v69, v68, v67, v66);
      }
    }
    operator delete(v39);
    goto LABEL_99;
  }
  __p = operator new(0x40uLL);
  v91 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v91) < 0)
    operator delete(__p);
  return 0;
}

void sub_180E5D6D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, char *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a17, a18);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *(_QWORD *)a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E5D9B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5D9C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::MultiplyOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.add";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E5DB84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5DB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::MultiplyOp&,mlir::mps::AddOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36) || !*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *(_QWORD *)a3 - 16, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_11;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_11:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E5DD68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5DD7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::mps::MultiplyOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tanh", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.tanh";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *(_QWORD *)a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_10;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::TanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_10:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E5DF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5DF48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::TanhOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.add";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E5E104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5E11C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SigmoidOp,mlir::mps::MultiplyOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sigmoid", (const unsigned __int8 *)0xB, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.sigmoid";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *(_QWORD *)a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_10;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SigmoidOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SigmoidOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_10:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E5E2D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5E2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::SigmoidOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E5E4A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5E4BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanhOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x686E61742E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.tanh";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TanhOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SigmoidOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SigmoidOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x6D6769732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x64696F6D6769732ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.sigmoid";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::InnerProductPattern::~InnerProductPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::InnerProductPattern::matchAndRewrite(_anonymous_namespace_::InnerProductPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t OptionalArgValue;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  char *v10;
  uint64_t *v11;
  void **v12;
  void **v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  __int128 *v17;
  char *v18;
  uint64_t *v19;
  void **v20;
  uint64_t v22;
  void *__p;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t ArgValue;
  __int128 *v28;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v26 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weights");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  v25 = OptionalArgValue;
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    LOBYTE(__p) = 0;
    LOBYTE(v28) = 1;
    v7 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 13, LocationForOp, &ArgValue, &v26, (unsigned __int8 *)&__p, (unsigned __int8 *)&v28);
    v22 = v7;
    if (OptionalArgValue)
    {
      v8 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MatMulOp &,mlir::Value &>(a3 + 13, LocationForOp, (uint64_t)&v22, &v25);
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
      if (!*(_DWORD *)(v8 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v9 = (__int128 *)__p;
      v10 = (char *)operator new(8uLL);
      *(_QWORD *)v10 = v8 - 16;
      v28 = v9;
      v11 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v9, (uint64_t)&std::piecewise_construct, &v28);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v11 + 5, v10, v10 + 8, 1uLL);
      operator delete(v10);
      v12 = (void **)__p;
      if (!__p)
        return 1;
      v13 = (void **)v24;
      v14 = __p;
      if ((void *)v24 == __p)
      {
LABEL_20:
        *(_QWORD *)&v24 = v12;
        operator delete(v14);
        return 1;
      }
      do
      {
        if (*((char *)v13 - 1) < 0)
          operator delete(*(v13 - 3));
        v13 -= 3;
      }
      while (v13 != v12);
    }
    else
    {
      v16 = v7;
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
      if (!*(_DWORD *)(v16 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v17 = (__int128 *)__p;
      v18 = (char *)operator new(8uLL);
      *(_QWORD *)v18 = v16 - 16;
      v28 = v17;
      v19 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v17, (uint64_t)&std::piecewise_construct, &v28);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v19 + 5, v18, v18 + 8, 1uLL);
      operator delete(v18);
      v12 = (void **)__p;
      if (!__p)
        return 1;
      v20 = (void **)v24;
      v14 = __p;
      if ((void *)v24 == __p)
        goto LABEL_20;
      do
      {
        if (*((char *)v20 - 1) < 0)
          operator delete(*(v20 - 3));
        v20 -= 3;
      }
      while (v20 != v12);
    }
    v14 = __p;
    goto LABEL_20;
  }
  __p = operator new(0x40uLL);
  v24 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v15 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v24) < 0)
    operator delete(__p);
  return v15;
}

void sub_180E5EA48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;

  operator delete(v16);
  std::vector<std::string>::~vector[abi:ne180100](&__p);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::InstanceNormPattern::~InstanceNormPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::InstanceNormPattern::matchAndRewrite(_anonymous_namespace_::InstanceNormPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::Float32Type **v6;
  uint64_t ArgValue;
  mlir::MLIRContext *v8;
  uint64_t v9;
  uint64_t *v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  uint64_t *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v17;
  mlir::GenericProgramPoint *v18;
  _DWORD *v19;
  _OWORD *v20;
  char *v21;
  char *v22;
  char *v23;
  const void ***v24;
  const void **v25;
  const void ***v26;
  const void **v27;
  const void ***v28;
  BOOL v29;
  char *v30;
  char **v31;
  char *v32;
  char **v33;
  char *v34;
  char *v35;
  unint64_t v36;
  int v37;
  char *v38;
  size_t v39;
  _BOOL4 v40;
  int v41;
  char **v42;
  char *v43;
  _QWORD *v44;
  unint64_t v45;
  int v46;
  unint64_t v47;
  char *v48;
  char *v49;
  size_t v50;
  _BOOL4 v51;
  int v52;
  _BOOL4 v53;
  void *v54;
  char *v55;
  uint64_t v56;
  _QWORD *v58;
  uint64_t ParameterValue;
  uint64_t v60;
  uint64_t v61;
  int v62;
  mlir::MLIRContext *v63;
  float v64;
  llvm::APFloatBase *F32FloatAttr;
  mlir::MLIRContext *v66;
  float v67;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v69;
  uint64_t IntegerType;
  uint64_t **v71;
  uint64_t InterfaceFor;
  const char *v73;
  int v74;
  const char *v75;
  const char *v76;
  char *v77;
  char *v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t **v81;
  uint64_t v82;
  const char *v83;
  int v84;
  const char *v85;
  const char *v86;
  char *v87;
  char *v88;
  uint64_t *v89;
  uint64_t v90;
  char *v91;
  char *v92;
  uint64_t *v93;
  char *v94;
  uint64_t v95;
  _DWORD *v96;
  mlir::Float32Type **v97;
  char *v98;
  _OWORD *v99;
  char *__p;
  mlir::GenericProgramPoint *v101;
  mlir::GenericProgramPoint *v102;
  unsigned __int8 v103;
  uint64_t v104;
  unsigned __int8 v105;
  mlir::GenericProgramPoint *v106;
  mlir::GenericProgramPoint *v107;
  uint64_t v108;
  char *__s2;
  __int128 v110;
  uint64_t Constant;
  char *v112[2];
  uint64_t ElementTypeOrSelf;
  llvm::APFloatBase *v114;
  uint64_t v115;
  uint64_t OptionalArgValue;
  uint64_t v117[2];

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v6 = a3 + 13;
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v117[0] = ArgValue;
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "beta");
  v114 = 0;
  v115 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "gamma");
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  if (!OptionalArgValue)
  {
    v9 = mlir::Float32Type::get(*v6, v8);
    Constant = 1;
    v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v9, 0);
    Constant = mlir::mps::getConstantAttr<float>(v10, 0.0);
    v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&Constant);
    if (!*((_DWORD *)v11 + 9))
      goto LABEL_110;
    OptionalArgValue = (uint64_t)v11 - 16;
    if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    {
      v12 = mlir::getElementTypeOrSelf(ArgValue);
      Constant = mlir::TypeAttr::get(v12);
      v13 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &OptionalArgValue, &Constant);
      if (!*((_DWORD *)v13 + 9))
        goto LABEL_110;
      OptionalArgValue = (uint64_t)v13 - 16;
    }
  }
  if (v115)
    goto LABEL_11;
  v14 = mlir::Float32Type::get(*v6, v8);
  Constant = 1;
  v15 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v14, 0);
  Constant = mlir::mps::getConstantAttr<float>(v15, 1.0);
  v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&Constant);
  if (!*((_DWORD *)v16 + 9))
    goto LABEL_110;
  v115 = (uint64_t)v16 - 16;
  if (mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    goto LABEL_11;
  v17 = mlir::getElementTypeOrSelf(ArgValue);
  Constant = mlir::TypeAttr::get(v17);
  v18 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v115, &Constant);
  if (!*((_DWORD *)v18 + 9))
LABEL_110:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v115 = (uint64_t)v18 - 16;
LABEL_11:
  v19 = operator new(0xCuLL);
  *(_QWORD *)v19 = 0xFFFFFFFF00000001;
  v19[2] = 1;
  v20 = operator new(0x10uLL);
  v97 = a3 + 13;
  *v20 = xmmword_181240F20;
  v21 = (char *)(v20 + 1);
  v99 = v20;
  v98 = (char *)operator new(4uLL);
  *(_DWORD *)v98 = 2;
  v22 = (char *)operator new(8uLL);
  *(_QWORD *)v22 = 0x300000002;
  v23 = v22 + 8;
  __p = v22;
  v24 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v112[0] = 0;
  v112[1] = 0;
  Constant = (uint64_t)v112;
  v26 = v24 + 1;
  v25 = *v24;
  if (*v24 == (const void **)(v24 + 1))
    goto LABEL_53;
  v94 = (char *)(v19 + 3);
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&Constant, (uint64_t *)v112, v25 + 4, (uint64_t)(v25 + 4));
    v27 = (const void **)v25[1];
    if (v27)
    {
      do
      {
        v28 = (const void ***)v27;
        v27 = (const void **)*v27;
      }
      while (v27);
    }
    else
    {
      do
      {
        v28 = (const void ***)v25[2];
        v29 = *v28 == v25;
        v25 = (const void **)v28;
      }
      while (!v29);
    }
    v25 = (const void **)v28;
  }
  while (v28 != v26);
  v95 = LocationForOp;
  v30 = v112[0];
  HIBYTE(v110) = 7;
  strcpy((char *)&__s2, "epsilon");
  if (!v112[0])
    goto LABEL_53;
  v96 = v19;
  v31 = v112;
  do
  {
    v32 = v30;
    v33 = v31;
    v35 = v30 + 32;
    v34 = (char *)*((_QWORD *)v30 + 4);
    v36 = v32[55];
    v37 = (char)v36;
    if ((v36 & 0x80u) != 0)
      v36 = *((_QWORD *)v32 + 5);
    if (v37 >= 0)
      v38 = v35;
    else
      v38 = v34;
    if (v36 >= 7)
      v39 = 7;
    else
      v39 = v36;
    v40 = v36 < 7;
    v41 = memcmp(v38, &__s2, v39);
    if (v41)
      v40 = v41 < 0;
    v42 = (char **)(v32 + 8);
    if (v40)
    {
      v31 = v33;
    }
    else
    {
      v42 = (char **)v32;
      v31 = (char **)v32;
    }
    v30 = *v42;
  }
  while (v30);
  if (v31 == v112)
    goto LABEL_53;
  v43 = (char *)(v33 + 4);
  if (v40)
    v44 = v33;
  else
    v44 = v32;
  if (!v40)
    v43 = v35;
  v45 = *((unsigned __int8 *)v31 + 55);
  v46 = (char)v45;
  v48 = (char *)v44[4];
  v47 = v44[5];
  if ((v45 & 0x80u) != 0)
    v45 = v47;
  if (v46 >= 0)
    v49 = v43;
  else
    v49 = v48;
  if (v45 >= 7)
    v50 = 7;
  else
    v50 = v45;
  v51 = v45 > 7;
  v52 = memcmp(&__s2, v49, v50);
  v53 = v52 < 0;
  if (!v52)
    v53 = v51;
  v19 = v96;
  if (v53)
  {
LABEL_53:
    __s2 = (char *)operator new(0x30uLL);
    v110 = xmmword_181286A90;
    strcpy(__s2, "Could not find parameter with name 'epsilon'.");
    v55 = v98;
    v54 = v99;
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_54:
    if (SHIBYTE(v110) < 0)
      operator delete(__s2);
    v56 = 0;
    goto LABEL_57;
  }
  if (v40)
    v58 = v33;
  else
    v58 = v32;
  if (v58[8] - v58[7] != 16)
  {
    v55 = v98;
    v54 = v99;
    __s2 = (char *)operator new(0x28uLL);
    v110 = xmmword_181287DB0;
    strcpy(__s2, "Unexpected argument size for 'epsilon'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v110) = 7;
  strcpy((char *)&__s2, "epsilon");
  v55 = v98;
  v54 = v99;
  ParameterValue = MIL::IROperation::GetParameterValue();
  v60 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
  if (SHIBYTE(v110) < 0)
    operator delete(__s2);
  if (!v60)
  {
    __s2 = (char *)operator new(0x38uLL);
    v110 = xmmword_181286AB0;
    strcpy(__s2, "Failed to materialize constant: value is not a tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
    goto LABEL_54;
  }
  v61 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v60 + 32))(v60);
  v62 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v61 + 88))(v61);
  if (v62 == 4)
  {
    HIBYTE(v110) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    LOWORD(v108) = MIL::IRValue::GetScalar<MIL::Fp16>();
    MIL::Fp16::GetFloat((MIL::Fp16 *)&v108);
    F32FloatAttr = mlir::Builder::getF32FloatAttr(v97, v67, v66);
  }
  else
  {
    if (v62 != 5)
    {
      __s2 = (char *)operator new(0x20uLL);
      v110 = xmmword_181268750;
      strcpy(__s2, "Unexpected MIL element type.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
      goto LABEL_54;
    }
    HIBYTE(v110) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    MIL::IRValue::GetScalar<float>();
    F32FloatAttr = mlir::Builder::getF32FloatAttr(v97, v64, v63);
  }
  v114 = F32FloatAttr;
  if (SHIBYTE(v110) < 0)
    operator delete(__s2);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 1)
  {
    __s2 = (char *)operator new(0x40uLL);
    v110 = xmmword_18125E6C0;
    strcpy(__s2, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v110) = 1;
  LOWORD(__s2) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(v110) < 0)
    operator delete(__s2);
  v69 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v108 = 0;
  v108 = MIL::IRTensorValueType::Rank(v69);
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v97, 0x20u, 1);
  v71 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v108, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v71))
    goto LABEL_111;
  if (v71)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v71);
    if (!InterfaceFor)
    {
      v73 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v74 = 98;
      v75 = "InterfaceSupport.h";
      v76 = "Interface";
      goto LABEL_112;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  if (v108 == 3)
    v77 = (char *)v96;
  else
    v77 = (char *)v99;
  v78 = v94;
  if (v108 != 3)
    v78 = v21;
  v79 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v71, InterfaceFor, v77, v78 - v77, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v79) & 1) == 0)
  {
LABEL_111:
    v73 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v74 = 566;
    v75 = "Casting.h";
    v76 = "cast";
LABEL_112:
    __assert_rtn(v76, v75, v74, v73);
  }
  __s2 = (char *)v79;
  v107 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v97, v95, (uint64_t **)&__s2);
  __s2 = (char *)(v108 - 2);
  v80 = mlir::Builder::getIntegerType((mlir::Builder *)v97, 0x20u, 1);
  v81 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__s2, 1, v80, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v81))
    goto LABEL_113;
  if (v81)
  {
    v82 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v81);
    if (!v82)
    {
      v83 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v84 = 98;
      v85 = "InterfaceSupport.h";
      v86 = "Interface";
      goto LABEL_114;
    }
  }
  else
  {
    v82 = 0;
  }
  if (v108 == 3)
    v87 = v98;
  else
    v87 = __p;
  v88 = v98 + 4;
  if (v108 != 3)
    v88 = v23;
  v89 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v81, v82, v87, v88 - v87, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v89) & 1) == 0)
  {
LABEL_113:
    v83 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v84 = 566;
    v85 = "Casting.h";
    v86 = "cast";
LABEL_114:
    __assert_rtn(v86, v85, v84, v83);
  }
  __s2 = (char *)v89;
  v106 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)v97, v95, (uint64_t **)&__s2);
  v105 = 1;
  __s2 = (char *)mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::mps::ConstantOp &,BOOL>(v97, v95, v117, (uint64_t)&v106, &v105);
  v103 = 1;
  v104 = mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::mps::ConstantOp &,BOOL>(v97, v95, v117, (uint64_t)&v106, &v103);
  v102 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(v97, v95, &v115, &v107);
  v101 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(v97, v95, &OptionalArgValue, &v107);
  v90 = mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReductionMeanOp,mlir::mps::ReductionVarianceOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::FloatAttr &>((mlir::OpBuilder *)v97, v95, v117, (uint64_t)&__s2, (uint64_t)&v104, (uint64_t)&v102, (uint64_t)&v101, (uint64_t *)&v114);
  (*(void (**)(char **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__s2, a2);
  if (!*(_DWORD *)(v90 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  MILToMLIRRewriter::setValue((uint64_t)a3, (__int128 *)__s2, v90 - 16);
  v91 = __s2;
  if (__s2)
  {
    v92 = (char *)v110;
    v93 = (uint64_t *)__s2;
    if ((char *)v110 != __s2)
    {
      do
      {
        if (*(v92 - 1) < 0)
          operator delete(*((void **)v92 - 3));
        v92 -= 24;
      }
      while (v92 != v91);
      v93 = (uint64_t *)__s2;
    }
    *(_QWORD *)&v110 = v91;
    operator delete(v93);
  }
  v56 = 1;
LABEL_57:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&Constant, v112[0]);
  operator delete(__p);
  operator delete(v55);
  operator delete(v54);
  operator delete(v19);
  return v56;
}

void sub_180E5F5A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *a14, void *a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,char *a32)
{
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a31, a32);
  operator delete(__p);
  operator delete(a14);
  operator delete(a15);
  operator delete(a12);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReductionMeanOp,mlir::mps::ReductionVarianceOp,mlir::mps::ReshapeOp,mlir::mps::ReshapeOp,mlir::FloatAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _BYTE v31[40];
  _QWORD v32[39];

  v32[38] = *MEMORY[0x1E0C80C00];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.normalization", (const unsigned __int8 *)0x11, Context);
  if (!v18)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"mps.normalization";
    v29[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36)
    || !*(_DWORD *)(*(_QWORD *)a5 + 36)
    || !*(_DWORD *)(*(_QWORD *)a6 + 36)
    || !*(_DWORD *)(*(_QWORD *)a7 + 36))
  {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::NormalizationOp::build((uint64_t)a1, (uint64_t)v32, *a3, *(_QWORD *)a4 - 16, *(_QWORD *)a5 - 16, *(_QWORD *)a6 - 16, *(_QWORD *)a7 - 16, *a8);
  v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v23 = 662;
    v24 = "Casting.h";
    v25 = "dyn_cast";
    goto LABEL_13;
  }
  v20 = llvm::DefaultDoCastIfPossible<mlir::mps::NormalizationOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NormalizationOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    v22 = "result && \"builder didn't return the right type\"";
    v23 = 497;
    v24 = "Builders.h";
    v25 = "create";
LABEL_13:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180E5F8C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5F8D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::mps::ConstantOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.reduction_mean";
    v23[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ReductionMeanOp::build(a1, (uint64_t)v26, *a3, *(_QWORD *)a4 - 16, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_10;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMeanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMeanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_10:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E5FAA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5FABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::mps::ConstantOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_variance", (const unsigned __int8 *)0x16, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.reduction_variance";
    v23[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ReductionVarianceOp::build(a1, (uint64_t)v26, *a3, *(_QWORD *)a4 - 16, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_10;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionVarianceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionVarianceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_10:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E5FC88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E5FCA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::LayerNormPattern::~LayerNormPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::LayerNormPattern::matchAndRewrite(_anonymous_namespace_::LayerNormPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::Float32Type **v6;
  mlir::MLIRContext *v7;
  uint64_t v8;
  uint64_t *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  uint64_t *v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  mlir::GenericProgramPoint *v17;
  const void ***v18;
  const void **v19;
  const void ***v20;
  const void **v21;
  const void ***v22;
  BOOL v23;
  char *v24;
  char **v25;
  char *v26;
  char **v27;
  char *v28;
  char *v29;
  unint64_t v30;
  int v31;
  char *v32;
  size_t v33;
  _BOOL4 v34;
  int v35;
  char **v36;
  char *v37;
  _QWORD *v38;
  unint64_t v39;
  int v40;
  unint64_t v41;
  char *v42;
  char *v43;
  size_t v44;
  _BOOL4 v45;
  int v46;
  _BOOL4 v47;
  uint64_t v48;
  _QWORD *v50;
  uint64_t ParameterValue;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  mlir::MLIRContext *v56;
  float v57;
  llvm::APFloatBase *F32FloatAttr;
  mlir::MLIRContext *v59;
  float v60;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v62;
  unint64_t v63;
  char *v64;
  char *v65;
  uint64_t v66;
  int *Data;
  uint64_t v68;
  char *v69;
  int v70;
  int v71;
  uint64_t IntegerType;
  uint64_t **v73;
  uint64_t InterfaceFor;
  const char *v75;
  int v76;
  const char *v77;
  const char *v78;
  void *v79;
  mlir::GenericProgramPoint *v80;
  uint64_t v81;
  mlir::GenericProgramPoint *v82;
  uint64_t v83;
  const char *v84;
  int v85;
  const char *v86;
  const char *v87;
  unint64_t v88;
  size_t v89;
  char *v90;
  uint64_t *v91;
  uint64_t v92;
  mlir::GenericProgramPoint *v93;
  uint64_t v94;
  const char *v95;
  int v96;
  const char *v97;
  const char *v98;
  unint64_t v99;
  size_t v100;
  char *v101;
  uint64_t *v102;
  uint64_t v103;
  void **v104;
  void **v105;
  void *v106;
  uint64_t v107;
  unsigned __int8 v108;
  uint64_t *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  mlir::GenericProgramPoint *v113;
  void *__p;
  void **v115;
  uint64_t v116;
  char *v117;
  char *v118;
  char *v119;
  unint64_t v120;
  char *__s2;
  __int128 v122;
  uint64_t Constant;
  char *v124[2];
  uint64_t ElementTypeOrSelf;
  llvm::APFloatBase *v126;
  uint64_t v127;
  uint64_t OptionalArgValue;
  uint64_t ArgValue;
  uint64_t v130[2];

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v6 = a3 + 13;
  v130[0] = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axes");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "beta");
  v126 = 0;
  v127 = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "gamma");
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v130[0]);
  if (!OptionalArgValue)
  {
    v8 = mlir::Float32Type::get(*v6, v7);
    Constant = 1;
    v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v8, 0);
    Constant = mlir::mps::getConstantAttr<float>(v9, 0.0);
    v10 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&Constant);
    if (!*((_DWORD *)v10 + 9))
      goto LABEL_141;
    OptionalArgValue = (uint64_t)v10 - 16;
    if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    {
      v11 = mlir::getElementTypeOrSelf(v130[0]);
      Constant = mlir::TypeAttr::get(v11);
      v12 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &OptionalArgValue, &Constant);
      if (!*((_DWORD *)v12 + 9))
        goto LABEL_141;
      OptionalArgValue = (uint64_t)v12 - 16;
    }
  }
  if (v127)
    goto LABEL_11;
  v13 = mlir::Float32Type::get(*v6, v7);
  Constant = 1;
  v14 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, v13, 0);
  Constant = mlir::mps::getConstantAttr<float>(v14, 1.0);
  v15 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t **)&Constant);
  if (!*((_DWORD *)v15 + 9))
    goto LABEL_141;
  v127 = (uint64_t)v15 - 16;
  if (mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    goto LABEL_11;
  v16 = mlir::getElementTypeOrSelf(v130[0]);
  Constant = mlir::TypeAttr::get(v16);
  v17 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v127, &Constant);
  if (!*((_DWORD *)v17 + 9))
LABEL_141:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v127 = (uint64_t)v17 - 16;
LABEL_11:
  v18 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v124[0] = 0;
  v124[1] = 0;
  Constant = (uint64_t)v124;
  v20 = v18 + 1;
  v19 = *v18;
  if (*v18 == (const void **)(v18 + 1))
    goto LABEL_53;
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&Constant, (uint64_t *)v124, v19 + 4, (uint64_t)(v19 + 4));
    v21 = (const void **)v19[1];
    if (v21)
    {
      do
      {
        v22 = (const void ***)v21;
        v21 = (const void **)*v21;
      }
      while (v21);
    }
    else
    {
      do
      {
        v22 = (const void ***)v19[2];
        v23 = *v22 == v19;
        v19 = (const void **)v22;
      }
      while (!v23);
    }
    v19 = (const void **)v22;
  }
  while (v22 != v20);
  v107 = LocationForOp;
  v24 = v124[0];
  HIBYTE(v122) = 7;
  strcpy((char *)&__s2, "epsilon");
  if (!v124[0])
    goto LABEL_53;
  v25 = v124;
  do
  {
    v26 = v24;
    v27 = v25;
    v29 = v24 + 32;
    v28 = (char *)*((_QWORD *)v24 + 4);
    v30 = v26[55];
    v31 = (char)v30;
    if ((v30 & 0x80u) != 0)
      v30 = *((_QWORD *)v26 + 5);
    if (v31 >= 0)
      v32 = v29;
    else
      v32 = v28;
    if (v30 >= 7)
      v33 = 7;
    else
      v33 = v30;
    v34 = v30 < 7;
    v35 = memcmp(v32, &__s2, v33);
    if (v35)
      v34 = v35 < 0;
    v36 = (char **)(v26 + 8);
    if (v34)
    {
      v25 = v27;
    }
    else
    {
      v36 = (char **)v26;
      v25 = (char **)v26;
    }
    v24 = *v36;
  }
  while (v24);
  if (v25 == v124)
    goto LABEL_53;
  v37 = (char *)(v27 + 4);
  if (v34)
    v38 = v27;
  else
    v38 = v26;
  if (!v34)
    v37 = v29;
  v39 = *((unsigned __int8 *)v25 + 55);
  v40 = (char)v39;
  v42 = (char *)v38[4];
  v41 = v38[5];
  if ((v39 & 0x80u) != 0)
    v39 = v41;
  if (v40 >= 0)
    v43 = v37;
  else
    v43 = v42;
  if (v39 >= 7)
    v44 = 7;
  else
    v44 = v39;
  v45 = v39 > 7;
  v46 = memcmp(&__s2, v43, v44);
  v47 = v46 < 0;
  if (!v46)
    v47 = v45;
  if (v47)
  {
LABEL_53:
    __s2 = (char *)operator new(0x30uLL);
    v122 = xmmword_181286A90;
    strcpy(__s2, "Could not find parameter with name 'epsilon'.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
LABEL_54:
    if (SHIBYTE(v122) < 0)
      operator delete(__s2);
    v48 = 0;
    goto LABEL_57;
  }
  if (v34)
    v50 = v27;
  else
    v50 = v26;
  if (v50[8] - v50[7] != 16)
  {
    __s2 = (char *)operator new(0x28uLL);
    v122 = xmmword_181287DB0;
    strcpy(__s2, "Unexpected argument size for 'epsilon'");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v122) = 7;
  strcpy((char *)&__s2, "epsilon");
  ParameterValue = MIL::IROperation::GetParameterValue();
  v52 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
  if (SHIBYTE(v122) < 0)
    operator delete(__s2);
  v53 = v107;
  if (!v52)
  {
    __s2 = (char *)operator new(0x38uLL);
    v122 = xmmword_181286AB0;
    strcpy(__s2, "Failed to materialize constant: value is not a tensor.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
    goto LABEL_54;
  }
  v54 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v52 + 32))(v52);
  v55 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v54 + 88))(v54);
  if (v55 == 4)
  {
    HIBYTE(v122) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    LOWORD(v117) = MIL::IRValue::GetScalar<MIL::Fp16>();
    MIL::Fp16::GetFloat((MIL::Fp16 *)&v117);
    F32FloatAttr = mlir::Builder::getF32FloatAttr(a3 + 13, v60, v59);
  }
  else
  {
    if (v55 != 5)
    {
      __s2 = (char *)operator new(0x20uLL);
      v122 = xmmword_181268750;
      strcpy(__s2, "Unexpected MIL element type.");
      MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t *)&__s2);
      goto LABEL_54;
    }
    HIBYTE(v122) = 7;
    strcpy((char *)&__s2, "epsilon");
    MIL::IROperation::GetParameterValue();
    MIL::IRValue::GetScalar<float>();
    F32FloatAttr = mlir::Builder::getF32FloatAttr(a3 + 13, v57, v56);
  }
  v126 = F32FloatAttr;
  if (SHIBYTE(v122) < 0)
    operator delete(__s2);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 1)
  {
    __s2 = (char *)operator new(0x40uLL);
    v122 = xmmword_18125E6C0;
    strcpy(__s2, "The number of outputs does not match the number of results.");
    MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__s2);
    goto LABEL_54;
  }
  HIBYTE(v122) = 1;
  LOWORD(__s2) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (SHIBYTE(v122) < 0)
    operator delete(__s2);
  v62 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v120 = 0;
  v120 = MIL::IRTensorValueType::Rank(v62);
  getMLIRShape(v62, (uint64_t)&__s2);
  v63 = v120;
  v118 = 0;
  v119 = 0;
  v117 = 0;
  if (v120)
  {
    if (v120 >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v64 = (char *)operator new(4 * v120);
    v65 = &v64[4 * v63];
    v117 = v64;
    v119 = v65;
    memset_pattern16(v64, &xmmword_1812876C0, 4 * v63);
    v118 = v65;
  }
  else
  {
    v65 = 0;
    v64 = 0;
  }
  HIBYTE(v116) = 4;
  strcpy((char *)&__p, "axes");
  v66 = MIL::IROperation::GetParameterValue();
  (*(void (**)(uint64_t))(*(_QWORD *)v66 + 40))(v66);
  Data = (int *)MIL::IRTensorValue::GetDataView<int>();
  if (v68)
  {
    v69 = __s2;
    v70 = v120;
    do
    {
      v71 = *Data++;
      *(_DWORD *)&v64[4 * (v70 & (v71 >> 31)) + 4 * v71] = *(_QWORD *)&v69[8 * (v70 & (v71 >> 31)) + 8 * v71];
      --v68;
    }
    while (v68);
  }
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
  v73 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v120, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73))
  {
    v75 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v76 = 566;
    v77 = "Casting.h";
    v78 = "cast";
LABEL_143:
    __assert_rtn(v78, v77, v76, v75);
  }
  if (v73)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73);
    if (!InterfaceFor)
    {
      v75 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v76 = 98;
      v77 = "InterfaceSupport.h";
      v78 = "Interface";
      goto LABEL_143;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v79 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v73, InterfaceFor, v64, v65 - v64, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v79) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  __p = v79;
  v80 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v107, (uint64_t **)&__p);
  v112 = v127;
  v113 = v80;
  v111 = OptionalArgValue;
  HIBYTE(v116) = 5;
  strcpy((char *)&__p, "gamma");
  v81 = MIL::IROperation::TryGetParameterValue();
  if (SHIBYTE(v116) < 0)
    operator delete(__p);
  if (v81)
  {
    v82 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 13, v107, &v127, &v113);
    if (!*((_DWORD *)v82 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    goto LABEL_109;
  }
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73))
  {
    v84 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v85 = 566;
    v86 = "Casting.h";
    v87 = "cast";
LABEL_147:
    __assert_rtn(v87, v86, v85, v84);
  }
  if (v73)
  {
    v83 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73);
    if (!v83)
    {
      v84 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v85 = 98;
      v86 = "InterfaceSupport.h";
      v87 = "Interface";
      goto LABEL_147;
    }
  }
  else
  {
    v83 = 0;
  }
  v88 = v120;
  v115 = 0;
  v116 = 0;
  __p = 0;
  if (v120)
  {
    if (v120 >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v89 = 4 * v120;
    v90 = (char *)operator new(4 * v120);
    v88 = (unint64_t)&v90[4 * v88];
    memset_pattern16(v90, &xmmword_1812876C0, v89);
    v53 = v107;
  }
  else
  {
    v90 = 0;
  }
  v91 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v73, v83, v90, v88 - (_QWORD)v90, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v91) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  v109 = v91;
  v110 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v53, &v109);
  if (v90)
    operator delete(v90);
  v82 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 13, v53, &v127, &v110);
  if (!*((_DWORD *)v82 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_109:
  v112 = (uint64_t)v82 - 16;
  HIBYTE(v116) = 4;
  strcpy((char *)&__p, "beta");
  v92 = MIL::IROperation::TryGetParameterValue();
  if (SHIBYTE(v116) < 0)
    operator delete(__p);
  if (!v92)
  {
    if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73))
    {
      if (v73)
      {
        v94 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v73);
        if (!v94)
        {
          v95 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          v96 = 98;
          v97 = "InterfaceSupport.h";
          v98 = "Interface";
          goto LABEL_150;
        }
      }
      else
      {
        v94 = 0;
      }
      v99 = v120;
      v115 = 0;
      v116 = 0;
      __p = 0;
      if (v120)
      {
        if (v120 >> 62)
          std::vector<int>::__throw_length_error[abi:ne180100]();
        v100 = 4 * v120;
        v101 = (char *)operator new(4 * v120);
        v99 = (unint64_t)&v101[4 * v99];
        memset_pattern16(v101, &xmmword_1812876C0, v100);
        v53 = v107;
      }
      else
      {
        v101 = 0;
      }
      v102 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v73, v94, v101, v99 - (_QWORD)v101, 4, 1, 1);
      if ((mlir::DenseIntElementsAttr::classof((uint64_t)v102) & 1) == 0)
        __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
      v109 = v102;
      v110 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v53, &v109);
      if (v101)
        operator delete(v101);
      v93 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 13, v53, &OptionalArgValue, &v110);
      if (!*((_DWORD *)v93 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      goto LABEL_127;
    }
    v95 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v96 = 566;
    v97 = "Casting.h";
    v98 = "cast";
LABEL_150:
    __assert_rtn(v98, v97, v96, v95);
  }
  v93 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>(a3 + 13, v53, &OptionalArgValue, &v113);
  if (!*((_DWORD *)v93 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_127:
  v111 = (uint64_t)v93 - 16;
  LOBYTE(v109) = 1;
  __p = mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,BOOL>(a3 + 13, v53, v130, &ArgValue, (unsigned __int8 *)&v109);
  v108 = 1;
  v110 = mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,BOOL>(a3 + 13, v53, v130, &ArgValue, &v108);
  v103 = mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReductionMeanOp,mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,mlir::FloatAttr &>((mlir::OpBuilder *)(a3 + 13), v53, v130, (uint64_t)&__p, (uint64_t)&v110, &v112, &v111, (uint64_t *)&v126);
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
  if (!*(_DWORD *)(v103 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  MILToMLIRRewriter::setValue((uint64_t)a3, (__int128 *)__p, v103 - 16);
  v104 = (void **)__p;
  if (__p)
  {
    v105 = v115;
    v106 = __p;
    if (v115 != __p)
    {
      do
      {
        if (*((char *)v105 - 1) < 0)
          operator delete(*(v105 - 3));
        v105 -= 3;
      }
      while (v105 != v104);
      v106 = __p;
    }
    v115 = v104;
    operator delete(v106);
  }
  if (v64)
    operator delete(v64);
  if (__s2)
  {
    *(_QWORD *)&v122 = __s2;
    operator delete(__s2);
  }
  v48 = 1;
LABEL_57:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&Constant, v124[0]);
  return v48;
}

void sub_180E60B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33)
{
  void *v33;
  uint64_t v34;

  if (__p)
    operator delete(__p);
  if (v33)
    operator delete(v33);
  if (a27)
  {
    operator delete(a27);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a33, *(char **)(v34 + 8));
    _Unwind_Resume(a1);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a33, *(char **)(v34 + 8));
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::NormalizationOp,mlir::Value &,mlir::mps::ReductionMeanOp,mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,mlir::FloatAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _BYTE v31[40];
  _QWORD v32[39];

  v32[38] = *MEMORY[0x1E0C80C00];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.normalization", (const unsigned __int8 *)0x11, Context);
  if (!v18)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"mps.normalization";
    v29[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36) || !*(_DWORD *)(*(_QWORD *)a5 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::NormalizationOp::build((uint64_t)a1, (uint64_t)v32, *a3, *(_QWORD *)a4 - 16, *(_QWORD *)a5 - 16, *a6, *a7, *a8);
  v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v23 = 662;
    v24 = "Casting.h";
    v25 = "dyn_cast";
    goto LABEL_11;
  }
  v20 = llvm::DefaultDoCastIfPossible<mlir::mps::NormalizationOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NormalizationOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    v22 = "result && \"builder didn't return the right type\"";
    v23 = 497;
    v24 = "Builders.h";
    v25 = "create";
LABEL_11:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180E60E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E60E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_variance", (const unsigned __int8 *)0x16, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.reduction_variance";
    v23[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  mlir::mps::ReductionVarianceOp::build(a1, (uint64_t)v26, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_8;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionVarianceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionVarianceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_8:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E61020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E61038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::LinearPattern::~LinearPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::LinearPattern::matchAndRewrite(_anonymous_namespace_::LinearPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t OptionalArgValue;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t IntegerType;
  uint64_t **v12;
  uint64_t InterfaceFor;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t **v21;
  uint64_t v22;
  const char *v23;
  int v24;
  const char *v25;
  const char *v26;
  uint64_t *v27;
  mlir::GenericProgramPoint *v28;
  uint64_t v29;
  uint64_t *v30;
  mlir::GenericProgramPoint *v31;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v33;
  mlir::GenericProgramPoint *v34;
  uint64_t *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  void **v39;
  void **v40;
  void *v41;
  uint64_t v43;
  void *__p;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t ArgValue;
  uint64_t *v49;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v47 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "weight");
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "bias");
  v46 = OptionalArgValue;
  HIBYTE(v45) = 1;
  LOWORD(__p) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  v8 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v9 = MIL::IRTensorValueType::Rank(v8);
  if (v9 == 1)
  {
    v10 = operator new(4uLL);
    *v10 = 0;
    __p = (void *)1;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
    v12 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, IntegerType, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v12))
      goto LABEL_38;
    if (v12)
    {
      InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v12);
      if (!InterfaceFor)
      {
        v14 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v15 = 98;
        v16 = "InterfaceSupport.h";
        v17 = "Interface";
        goto LABEL_39;
      }
    }
    else
    {
      InterfaceFor = 0;
    }
    v27 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v12, InterfaceFor, v10, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v27) & 1) == 0)
    {
LABEL_38:
      v14 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v15 = 566;
      v16 = "Casting.h";
      v17 = "cast";
LABEL_39:
      __assert_rtn(v17, v16, v15, v14);
    }
    v49 = v27;
    __p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v49);
    v28 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &__p);
    if (!*((_DWORD *)v28 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    ArgValue = (uint64_t)v28 - 16;
    operator delete(v10);
    if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 1)
      goto LABEL_17;
  }
  else if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 1)
  {
LABEL_17:
    __p = operator new(0x40uLL);
    v45 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    v29 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v45) < 0)
      operator delete(__p);
    return v29;
  }
  LOBYTE(__p) = 0;
  LOBYTE(v49) = 1;
  v18 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(a3 + 13, LocationForOp, &ArgValue, &v47, (unsigned __int8 *)&__p, (unsigned __int8 *)&v49);
  if (!*(_DWORD *)(v18 + 36))
    goto LABEL_37;
  v43 = v18 - 16;
  if (v9 == 1)
  {
    v19 = operator new(4uLL);
    *v19 = -2;
    __p = (void *)1;
    v20 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
    v21 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v20, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v21))
      goto LABEL_41;
    if (v21)
    {
      v22 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v21);
      if (!v22)
      {
        v23 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v24 = 98;
        v25 = "InterfaceSupport.h";
        v26 = "Interface";
        goto LABEL_42;
      }
    }
    else
    {
      v22 = 0;
    }
    v30 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v21, v22, v19, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v30) & 1) == 0)
    {
LABEL_41:
      v23 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v24 = 566;
      v25 = "Casting.h";
      v26 = "cast";
LABEL_42:
      __assert_rtn(v26, v25, v24, v23);
    }
    v49 = v30;
    __p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v49);
    v31 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v43, &__p);
    if (!*((_DWORD *)v31 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v43 = (uint64_t)v31 - 16;
    operator delete(v19);
  }
  if (OptionalArgValue)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(v43);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v33 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v46, (uint64_t *)&__p);
    if (*((_DWORD *)v33 + 9))
    {
      v46 = (uint64_t)v33 - 16;
      v34 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &v43, &v46);
      if (*((_DWORD *)v34 + 9))
      {
        v43 = (uint64_t)v34 - 16;
        goto LABEL_27;
      }
    }
LABEL_37:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
LABEL_27:
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
  v36 = v43;
  v35 = (uint64_t *)__p;
  v37 = (char *)operator new(8uLL);
  *(_QWORD *)v37 = v36;
  v49 = v35;
  v38 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v35, (uint64_t)&std::piecewise_construct, (__int128 **)&v49);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v38 + 5, v37, v37 + 8, 1uLL);
  operator delete(v37);
  v39 = (void **)__p;
  if (__p)
  {
    v40 = (void **)v45;
    v41 = __p;
    if ((void *)v45 != __p)
    {
      do
      {
        if (*((char *)v40 - 1) < 0)
          operator delete(*(v40 - 3));
        v40 -= 3;
      }
      while (v40 != v39);
      v41 = __p;
    }
    *(_QWORD *)&v45 = v39;
    operator delete(v41);
  }
  return 1;
}

void sub_180E61644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  std::vector<std::string>::~vector[abi:ne180100](&__p);
  _Unwind_Resume(a1);
}

void sub_180E61680(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E616B0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E616C4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E616D8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E616EC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::LocalResponseNormPattern::~LocalResponseNormPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::LocalResponseNormPattern::matchAndRewrite(_anonymous_namespace_::LocalResponseNormPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v7;
  mlir::Builder *v8;
  _DWORD *v9;
  uint64_t IntegerType;
  uint64_t **v11;
  uint64_t InterfaceFor;
  const char *v13;
  int v14;
  const char *v15;
  const char *v16;
  uint64_t *v17;
  mlir::GenericProgramPoint *v18;
  int v19;
  int v20;
  uint64_t ElementTypeOrSelf;
  _QWORD *v22;
  int MPSDataType;
  void *v24;
  uint64_t ConstantOp;
  _DWORD *v26;
  uint64_t v27;
  uint64_t **v28;
  uint64_t v29;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t **v37;
  uint64_t v38;
  uint64_t **v39;
  uint64_t v40;
  const char *v41;
  int v42;
  const char *v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  int v48;
  const char *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  int v54;
  const char *v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t **v59;
  uint64_t v60;
  const char *v61;
  int v62;
  const char *v63;
  const char *v64;
  uint64_t v65;
  llvm::APFloatBase *v66;
  void *v67;
  uint64_t *Context;
  uint64_t v69;
  char v70;
  llvm::APFloatBase *v71;
  void *v72;
  void *v73;
  mlir::GenericProgramPoint *v74;
  uint64_t v75;
  uint64_t v76;
  mlir::GenericProgramPoint *v77;
  uint64_t *v78;
  uint64_t v79;
  char v80;
  mlir::GenericProgramPoint *v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  char v85;
  mlir::GenericProgramPoint *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  char v92;
  mlir::GenericProgramPoint *v93;
  uint64_t v94;
  uint64_t *v95;
  uint64_t v96;
  char v97;
  mlir::GenericProgramPoint *v98;
  uint64_t v99;
  _DWORD *v100;
  uint64_t v101;
  uint64_t **v102;
  uint64_t v103;
  const char *v104;
  int v105;
  const char *v106;
  const char *v107;
  uint64_t v108;
  mlir::GenericProgramPoint *v109;
  uint64_t *v110;
  uint64_t v111;
  char v112;
  mlir::GenericProgramPoint *v113;
  uint64_t *v114;
  char *v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  void *v119;
  const char *v121;
  int v122;
  const char *v123;
  const char *v124;
  const char *v125;
  int v126;
  const char *v127;
  const char *v128;
  const char *v129;
  int v130;
  const char *v131;
  const char *v132;
  const char *v133;
  int v134;
  const char *v135;
  const char *v136;
  const char *v137;
  int v138;
  const char *v139;
  const char *v140;
  const char *v141;
  int v142;
  const char *v143;
  const char *v144;
  void *v145;
  void *v146;
  mlir::StringAttr **v147;
  uint64_t v148;
  mlir::GenericProgramPoint *v149;
  uint64_t v150;
  uint64_t v151;
  mlir::GenericProgramPoint *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t ArgValue;
  uint64_t v159;
  uint64_t v160[4];
  __int16 v161;
  uint64_t v162[2];
  const char *v163;
  uint64_t v164;
  __int16 v165;
  void *v166;
  uint64_t v167;
  __int128 __p;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  uint64_t *v172;
  void *v173;
  _QWORD v174[6];

  v174[3] = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v157 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "size");
  v148 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  v156 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  v147 = a3;
  v155 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "k");
  BYTE7(v169) = 1;
  LOWORD(__p) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  v7 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v150 = MIL::IRTensorValueType::Rank(v7);
  v8 = (mlir::Builder *)(v147 + 13);
  v154 = 0;
  if (v150 > 3)
  {
    v154 = ArgValue;
  }
  else
  {
    v9 = operator new(4uLL);
    *v9 = 0;
    *(_QWORD *)&__p = 1;
    IntegerType = mlir::Builder::getIntegerType(v8, 0x20u, 1);
    v11 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, IntegerType, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v11))
      goto LABEL_107;
    if (v11)
    {
      InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v11);
      if (!InterfaceFor)
      {
        v13 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v14 = 98;
        v15 = "InterfaceSupport.h";
        v16 = "Interface";
        goto LABEL_108;
      }
    }
    else
    {
      InterfaceFor = 0;
    }
    v17 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v11, InterfaceFor, v9, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v17) & 1) == 0)
    {
LABEL_107:
      v13 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v14 = 566;
      v15 = "Casting.h";
      v16 = "cast";
LABEL_108:
      __assert_rtn(v16, v15, v14, v13);
    }
    v172 = v17;
    *(_QWORD *)&__p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v8, LocationForOp, &v172);
    v18 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v8, LocationForOp, &ArgValue, &__p);
    if (!*((_DWORD *)v18 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v154 = (uint64_t)v18 - 16;
    operator delete(v9);
  }
  BYTE7(v169) = 4;
  strcpy((char *)&__p, "size");
  MIL::IROperation::TryGetParameterValue();
  v19 = MIL::IRValue::GetScalar<int>();
  if (SBYTE7(v169) < 0)
    operator delete((void *)__p);
  v20 = v19 & 1;
  if (v19 < 0)
    v20 = -v20;
  *(_QWORD *)&__p = v19 - v20 + 1;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  v22 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&__p, 1, ElementTypeOrSelf, 0);
  MPSDataType = getMPSDataType(v22);
  getConstantDataForScalar(MPSDataType, 1.0);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  ConstantOp = createConstantOp(v8, LocationForOp, v24, v22, 1);

  v153 = ConstantOp;
  v26 = operator new(0xCuLL);
  *(_QWORD *)v26 = 0x200000000;
  v26[2] = 3;
  *(_QWORD *)&__p = 3;
  v27 = mlir::Builder::getIntegerType(v8, 0x20u, 1);
  v28 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v27, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v28))
    goto LABEL_102;
  if (v28)
  {
    v29 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v28);
    if (!v29)
    {
      v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v31 = 98;
      v32 = "InterfaceSupport.h";
      v33 = "Interface";
      goto LABEL_103;
    }
  }
  else
  {
    v29 = 0;
  }
  v34 = mlir::DenseElementsAttr::getFromRawBuffer(v28, v29, v26, 12, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v34) & 1) == 0)
  {
LABEL_102:
    v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v31 = 566;
    v32 = "Casting.h";
    v33 = "cast";
LABEL_103:
    __assert_rtn(v33, v32, v31, v30);
  }
  *(_QWORD *)&__p = v34;
  v152 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v8, LocationForOp, (uint64_t **)&__p);
  v149 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v8, LocationForOp, &v153, &v152);
  v35 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>(v8, LocationForOp, &v154);
  *(_QWORD *)&__p = 4;
  v36 = mlir::Builder::getIntegerType(v8, 0x40u, 0);
  v37 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v36, 0);
  *(_QWORD *)&__p = 4;
  v38 = mlir::Builder::getIntegerType(v8, 0x40u, 1);
  v39 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v38, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v39))
  {
    v41 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v42 = 566;
    v43 = "Casting.h";
    v44 = "cast";
LABEL_110:
    __assert_rtn(v44, v43, v42, v41);
  }
  if (v39)
  {
    v40 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v39);
    if (!v40)
    {
      v41 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v42 = 98;
      v43 = "InterfaceSupport.h";
      v44 = "Interface";
      goto LABEL_110;
    }
  }
  else
  {
    v40 = 0;
  }
  __p = 0u;
  v169 = 0u;
  v45 = mlir::DenseElementsAttr::getFromRawBuffer(v39, v40, &__p, 32, 8, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof(v45) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v37))
  {
    v47 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v48 = 566;
    v49 = "Casting.h";
    v50 = "cast";
LABEL_113:
    __assert_rtn(v50, v49, v48, v47);
  }
  if (v37)
  {
    v46 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v37);
    if (!v46)
    {
      v47 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v48 = 98;
      v49 = "InterfaceSupport.h";
      v50 = "Interface";
      goto LABEL_113;
    }
  }
  else
  {
    v46 = 0;
  }
  __p = xmmword_181287FE0;
  v169 = unk_181287FF0;
  v51 = mlir::DenseElementsAttr::getFromRawBuffer(v37, v46, &__p, 32, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v51) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v37))
  {
    v53 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v54 = 566;
    v55 = "Casting.h";
    v56 = "cast";
LABEL_116:
    __assert_rtn(v56, v55, v54, v53);
  }
  if (v37)
  {
    v52 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v37);
    if (!v52)
    {
      v53 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v54 = 98;
      v55 = "InterfaceSupport.h";
      v56 = "Interface";
      goto LABEL_116;
    }
  }
  else
  {
    v52 = 0;
  }
  __p = xmmword_181287FE0;
  v169 = unk_181287FF0;
  v57 = mlir::DenseElementsAttr::getFromRawBuffer(v37, v52, &__p, 32, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v57) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  *(_QWORD *)&__p = 8;
  v58 = mlir::Builder::getIntegerType(v8, 0x40u, 0);
  v59 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v58, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v59))
  {
    v61 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v62 = 566;
    v63 = "Casting.h";
    v64 = "cast";
LABEL_119:
    __assert_rtn(v64, v63, v62, v61);
  }
  if (v59)
  {
    v60 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v59);
    if (!v60)
    {
      v61 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v62 = 98;
      v63 = "InterfaceSupport.h";
      v64 = "Interface";
      goto LABEL_119;
    }
  }
  else
  {
    v60 = 0;
  }
  v170 = 0u;
  v171 = 0u;
  __p = 0u;
  v169 = 0u;
  v65 = mlir::DenseElementsAttr::getFromRawBuffer(v59, v60, &__p, 64, 8, 1, 0);
  if ((mlir::DenseIntElementsAttr::classof(v65) & 1) == 0)
    __assert_rtn("cast", "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  v66 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&__p, 0.0);
  v67 = llvm::APFloatBase::IEEEsingle(v66);
  llvm::APFloat::Storage::Storage(&v166, &__p, v67);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p);
  v159 = LocationForOp;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  v69 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.stencil", (const unsigned __int8 *)0xB, Context);
  if (!v70)
  {
    v165 = 1283;
    v163 = "mps.stencil";
    v164 = 11;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v69);
  if (!*(_DWORD *)(v35 + 36) || !*((_DWORD *)v149 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v145 = v26;
  v72 = v166;
  v146 = llvm::APFloatBase::PPCDoubleDouble(v71);
  if (v146 == v72)
  {
    v73 = v145;
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v173, (const llvm::detail::DoubleAPFloat *)&v166);
  }
  else
  {
    v73 = v145;
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v173, (const llvm::detail::IEEEFloat *)&v166);
  }
  mlir::mps::StencilOp::build((mlir::Float32Type **)v8, (uint64_t)&__p, v35 - 16, (uint64_t)v149 - 16, v45, v51, v57, v65, (uint64_t)&v172, 2u, 4u, 2u);
  if (v146 == v173)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v174);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v173);
  v74 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v74)
  {
    v121 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v122 = 662;
    v123 = "Casting.h";
    v124 = "dyn_cast";
    goto LABEL_124;
  }
  v75 = llvm::DefaultDoCastIfPossible<mlir::mps::StencilOp,mlir::Operation *,llvm::CastInfo<mlir::mps::StencilOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v74);
  if (!v75)
  {
    v121 = "result && \"builder didn't return the right type\"";
    v122 = 497;
    v123 = "Builders.h";
    v124 = "create";
LABEL_124:
    __assert_rtn(v124, v123, v122, v121);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  v76 = mlir::getElementTypeOrSelf(v148);
  *(_QWORD *)&__p = mlir::TypeAttr::get(v76);
  v77 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)v8, LocationForOp, &v157, (uint64_t *)&__p);
  v159 = LocationForOp;
  v78 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  v79 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, v78);
  if (!v80)
  {
    v165 = 1283;
    v163 = "mps.divide";
    v164 = 10;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v79);
  if (!*((_DWORD *)v77 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build((mlir::Float32Type **)v8, (uint64_t)&__p, v148, (uint64_t)v77 - 16);
  v81 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v81)
  {
    v125 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v126 = 662;
    v127 = "Casting.h";
    v128 = "dyn_cast";
    goto LABEL_129;
  }
  v82 = llvm::DefaultDoCastIfPossible<mlir::mps::DivideOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DivideOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v81);
  if (!v82)
  {
    v125 = "result && \"builder didn't return the right type\"";
    v126 = 497;
    v127 = "Builders.h";
    v128 = "create";
LABEL_129:
    __assert_rtn(v128, v127, v126, v125);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  v159 = LocationForOp;
  v83 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  v84 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v83);
  if (!v85)
  {
    v165 = 1283;
    v163 = "mps.multiply";
    v164 = 12;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v84);
  if (!*(_DWORD *)(v82 + 36) || !*(_DWORD *)(v75 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build((mlir::Float32Type **)v8, (uint64_t)&__p, v82 - 16, v75 - 16);
  v86 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v86)
  {
    v129 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v130 = 662;
    v131 = "Casting.h";
    v132 = "dyn_cast";
    goto LABEL_133;
  }
  v87 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v86);
  if (!v87)
  {
    v129 = "result && \"builder didn't return the right type\"";
    v130 = 497;
    v131 = "Builders.h";
    v132 = "create";
LABEL_133:
    __assert_rtn(v132, v131, v130, v129);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  v151 = v87;
  v88 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::MultiplyOp &>((mlir::Float32Type **)v8, LocationForOp, &v155, (uint64_t)&v151);
  v89 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value &>(v8, LocationForOp, &v156);
  v159 = LocationForOp;
  v90 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  v91 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.power", (const unsigned __int8 *)9, v90);
  if (!v92)
  {
    v165 = 1283;
    v163 = "mps.power";
    v164 = 9;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v91);
  if (!*(_DWORD *)(v88 + 36) || !*(_DWORD *)(v89 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build((mlir::Float32Type **)v8, (uint64_t)&__p, v88 - 16, v89 - 16);
  v93 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v93)
  {
    v133 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v134 = 662;
    v135 = "Casting.h";
    v136 = "dyn_cast";
    goto LABEL_137;
  }
  v94 = llvm::DefaultDoCastIfPossible<mlir::mps::PowerOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PowerOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v93);
  if (!v94)
  {
    v133 = "result && \"builder didn't return the right type\"";
    v134 = 497;
    v135 = "Builders.h";
    v136 = "create";
LABEL_137:
    __assert_rtn(v136, v135, v134, v133);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  v159 = LocationForOp;
  v95 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
  v96 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, v95);
  if (!v97)
  {
    v165 = 1283;
    v163 = "mps.multiply";
    v164 = 12;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v161 = 259;
    llvm::operator+(v162, v160, (uint64_t)&v172);
    llvm::report_fatal_error((llvm::Twine *)&v172, 1);
  }
  mlir::OperationState::OperationState(&__p, LocationForOp, v96);
  if (!*(_DWORD *)(v94 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build((mlir::Float32Type **)v8, (uint64_t)&__p, v94 - 16, v154);
  v98 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
  if (!v98)
  {
    v137 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v138 = 662;
    v139 = "Casting.h";
    v140 = "dyn_cast";
    goto LABEL_142;
  }
  v99 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v98);
  if (!v99)
  {
    v137 = "result && \"builder didn't return the right type\"";
    v138 = 497;
    v139 = "Builders.h";
    v140 = "create";
LABEL_142:
    __assert_rtn(v140, v139, v138, v137);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  if (v150 <= 3)
  {
    v100 = operator new(4uLL);
    *v100 = 0;
    *(_QWORD *)&__p = 1;
    v101 = mlir::Builder::getIntegerType(v8, 0x20u, 1);
    v102 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, v101, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v102))
      goto LABEL_143;
    if (v102)
    {
      v103 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v102);
      if (!v103)
      {
        v104 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v105 = 98;
        v106 = "InterfaceSupport.h";
        v107 = "Interface";
        goto LABEL_144;
      }
    }
    else
    {
      v103 = 0;
    }
    v108 = mlir::DenseElementsAttr::getFromRawBuffer(v102, v103, v100, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof(v108) & 1) == 0)
    {
LABEL_143:
      v104 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v105 = 566;
      v106 = "Casting.h";
      v107 = "cast";
LABEL_144:
      __assert_rtn(v107, v106, v105, v104);
    }
    *(_QWORD *)&__p = v108;
    v109 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v8, LocationForOp, (uint64_t **)&__p);
    v159 = LocationForOp;
    v110 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v159);
    v111 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, v110);
    if (!v112)
    {
      v165 = 1283;
      v163 = "mps.squeeze";
      v164 = 11;
                         "t been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loa"
                         "ded-dependent-whats-up-with-dialects-management";
      v161 = 259;
      llvm::operator+(v162, v160, (uint64_t)&v172);
      llvm::report_fatal_error((llvm::Twine *)&v172, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v111);
    if (!*(_DWORD *)(v99 + 36) || !*((_DWORD *)v109 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::SqueezeOp::build((uint64_t)v8, (uint64_t)&__p, v99 - 16, (uint64_t)v109 - 16);
    v113 = mlir::OpBuilder::create(v8, (const mlir::OperationState *)&__p);
    if (v113)
    {
      v99 = llvm::DefaultDoCastIfPossible<mlir::mps::SqueezeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SqueezeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v113);
      if (v99)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (!*(_DWORD *)(v99 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        operator delete(v100);
        goto LABEL_90;
      }
      v141 = "result && \"builder didn't return the right type\"";
      v142 = 497;
      v143 = "Builders.h";
      v144 = "create";
    }
    else
    {
      v141 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v142 = 662;
      v143 = "Casting.h";
      v144 = "dyn_cast";
    }
    __assert_rtn(v144, v143, v142, v141);
  }
  if (!*(_DWORD *)(v99 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_90:
  (*(void (**)(__int128 *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
  v114 = (uint64_t *)__p;
  v115 = (char *)operator new(8uLL);
  *(_QWORD *)v115 = v99 - 16;
  v172 = v114;
  v116 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v147 + 8), (uint64_t)v114, (uint64_t)&std::piecewise_construct, (__int128 **)&v172);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v116 + 5, v115, v115 + 8, 1uLL);
  operator delete(v115);
  v117 = __p;
  if ((_QWORD)__p)
  {
    v118 = *((_QWORD *)&__p + 1);
    v119 = (void *)__p;
    if (*((_QWORD *)&__p + 1) != (_QWORD)__p)
    {
      do
      {
        if (*(char *)(v118 - 1) < 0)
          operator delete(*(void **)(v118 - 24));
        v118 -= 24;
      }
      while (v118 != v117);
      v119 = (void *)__p;
    }
    *((_QWORD *)&__p + 1) = v117;
    operator delete(v119);
  }
  if (v146 == v166)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v167);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v166);
  operator delete(v73);
  return 1;
}

void sub_180E62A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  void *v50;

  llvm::APFloat::~APFloat((llvm::APFloat *)&a41);
  operator delete(v50);
  _Unwind_Resume(a1);
}

void sub_180E62C30(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E62C44(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E62C7C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E62C90(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E62CA4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E62CB8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E62CCC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E62CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  void *v45;

  mlir::OperationState::~OperationState((mlir::OperationState *)&a45);
  llvm::APFloat::~APFloat((llvm::APFloat *)&a41);
  operator delete(v45);
  _Unwind_Resume(a1);
}

void sub_180E62D20(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.square";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SquareOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E62EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E62EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SquareOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(_QWORD *)AttrData == 0x617571732E73706DLL && *(_WORD *)(AttrData + 8) == 25970)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.square";
      v8[3] = 10;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::StencilOp,mlir::Operation *,llvm::CastInfo<mlir::mps::StencilOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x6E6574732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.stencil";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::PowerOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PowerOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x65776F702E73706DLL && *(_BYTE *)(AttrData + 8) == 114)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.power";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::MatMulPattern::~MatMulPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::MatMulPattern::matchAndRewrite(_anonymous_namespace_::MatMulPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v7;
  uint64_t v8;
  MIL::IRValueType *v9;
  MIL::IRTensorValueType *v10;
  uint64_t v11;
  uint64_t ParameterValue;
  uint64_t v13;
  mlir::MLIRContext *v14;
  uint64_t v15;
  mlir::MLIRContext *v16;
  _DWORD *v17;
  uint64_t IntegerType;
  uint64_t **v19;
  uint64_t InterfaceFor;
  const char *v21;
  int v22;
  const char *v23;
  const char *v24;
  uint64_t *v25;
  mlir::GenericProgramPoint *v26;
  _DWORD *v27;
  uint64_t v28;
  uint64_t **v29;
  uint64_t v30;
  const char *v31;
  int v32;
  const char *v33;
  const char *v34;
  uint64_t *v35;
  mlir::GenericProgramPoint *v36;
  uint64_t *Context;
  uint64_t v38;
  char v39;
  mlir::GenericProgramPoint *v40;
  uint64_t v41;
  _DWORD *v42;
  uint64_t v43;
  uint64_t **v44;
  uint64_t v45;
  const char *v46;
  int v47;
  const char *v48;
  const char *v49;
  uint64_t *v50;
  mlir::GenericProgramPoint *v51;
  _DWORD *v52;
  uint64_t v53;
  uint64_t **v54;
  uint64_t v55;
  const char *v56;
  int v57;
  const char *v58;
  const char *v59;
  uint64_t *v60;
  mlir::GenericProgramPoint *v61;
  uint64_t *v62;
  uint64_t v63;
  char *v64;
  uint64_t *v65;
  void **v66;
  void **v67;
  void *v68;
  const char *v70;
  int v71;
  const char *v72;
  const char *v73;
  uint64_t v74;
  uint64_t ArgValue;
  uint64_t v76;
  const char *v77;
  __int16 v78;
  uint64_t v79[4];
  __int16 v80;
  uint64_t *v81[5];
  void *__p[40];

  __p[38] = *(void **)MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v74 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) != 1)
  {
    __p[0] = operator new(0x40uLL);
    *(_OWORD *)&__p[1] = xmmword_18125E6C0;
    strcpy((char *)__p[0], "The number of outputs does not match the number of results.");
    v15 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    return v15;
  }
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  v7 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v8 = MIL::IRTensorValueType::Rank(v7);
  v9 = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  v10 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(v9);
  v11 = MIL::IRTensorValueType::Rank(v10);
  strcpy((char *)__p, "transpose_x");
  ParameterValue = MIL::IROperation::TryGetParameterValue();
  HIBYTE(__p[2]) = 11;
  strcpy((char *)__p, "transpose_y");
  v13 = MIL::IROperation::TryGetParameterValue();
  v14 = 0;
  if (ParameterValue && v8 != 1)
    v14 = (mlir::MLIRContext *)MIL::IRValue::GetScalar<BOOL>();
  v16 = 0;
  if (v13 && v11 != 1)
    v16 = (mlir::MLIRContext *)MIL::IRValue::GetScalar<BOOL>();
  if (v8 == 1)
  {
    v17 = operator new(4uLL);
    *v17 = 0;
    __p[0] = (void *)1;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
    v19 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, IntegerType, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v19))
      goto LABEL_61;
    if (v19)
    {
      InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v19);
      if (!InterfaceFor)
      {
        v21 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v22 = 98;
        v23 = "InterfaceSupport.h";
        v24 = "Interface";
        goto LABEL_62;
      }
    }
    else
    {
      InterfaceFor = 0;
    }
    v25 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v19, InterfaceFor, v17, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v25) & 1) == 0)
    {
LABEL_61:
      v21 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v22 = 566;
      v23 = "Casting.h";
      v24 = "cast";
LABEL_62:
      __assert_rtn(v24, v23, v22, v21);
    }
    v81[0] = v25;
    __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, v81);
    v26 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, __p);
    if (!*((_DWORD *)v26 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    ArgValue = (uint64_t)v26 - 16;
    operator delete(v17);
  }
  if (v11 == 1)
  {
    v27 = operator new(4uLL);
    *v27 = 1;
    __p[0] = (void *)1;
    v28 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
    v29 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v28, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v29))
      goto LABEL_63;
    if (v29)
    {
      v30 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v29);
      if (!v30)
      {
        v31 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v32 = 98;
        v33 = "InterfaceSupport.h";
        v34 = "Interface";
        goto LABEL_64;
      }
    }
    else
    {
      v30 = 0;
    }
    v35 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v29, v30, v27, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v35) & 1) == 0)
    {
LABEL_63:
      v31 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v32 = 566;
      v33 = "Casting.h";
      v34 = "cast";
LABEL_64:
      __assert_rtn(v34, v33, v32, v31);
    }
    v81[0] = v35;
    __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, v81);
    v36 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v74, __p);
    if (!*((_DWORD *)v36 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v74 = (uint64_t)v36 - 16;
    operator delete(v27);
  }
  v76 = LocationForOp;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v76);
  v38 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, Context);
  if (!v39)
  {
    v80 = 1283;
    v79[2] = (uint64_t)"mps.matmul";
    v79[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v78 = 259;
    llvm::operator+(v79, (uint64_t *)&v77, (uint64_t)v81);
    llvm::report_fatal_error((llvm::Twine *)v81, 1);
  }
  mlir::OperationState::OperationState(__p, LocationForOp, v38);
  mlir::mps::MatMulOp::build(a3 + 13, (uint64_t)__p, ArgValue, v74, v14, v16);
  v40 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)__p);
  if (!v40)
  {
    v70 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v71 = 662;
    v72 = "Casting.h";
    v73 = "dyn_cast";
    goto LABEL_68;
  }
  v41 = llvm::DefaultDoCastIfPossible<mlir::mps::MatMulOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MatMulOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v40);
  if (!v41)
  {
    v70 = "result && \"builder didn't return the right type\"";
    v71 = 497;
    v72 = "Builders.h";
    v73 = "create";
LABEL_68:
    __assert_rtn(v73, v72, v71, v70);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
  if (!*(_DWORD *)(v41 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v79[0] = v41 - 16;
  if (v8 == 1)
  {
    v42 = operator new(4uLL);
    *v42 = -2;
    __p[0] = (void *)1;
    v43 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
    v44 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v43, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v44))
      goto LABEL_70;
    if (v44)
    {
      v45 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v44);
      if (!v45)
      {
        v46 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v47 = 98;
        v48 = "InterfaceSupport.h";
        v49 = "Interface";
        goto LABEL_71;
      }
    }
    else
    {
      v45 = 0;
    }
    v50 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v44, v45, v42, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v50) & 1) == 0)
    {
LABEL_70:
      v46 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v47 = 566;
      v48 = "Casting.h";
      v49 = "cast";
LABEL_71:
      __assert_rtn(v49, v48, v47, v46);
    }
    v81[0] = v50;
    __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, v81);
    v51 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, v79, __p);
    if (!*((_DWORD *)v51 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v79[0] = (uint64_t)v51 - 16;
    operator delete(v42);
  }
  if (v11 == 1)
  {
    v52 = operator new(4uLL);
    *v52 = -1;
    __p[0] = (void *)1;
    v53 = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 1);
    v54 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)__p, 1, v53, 0);
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54))
      goto LABEL_72;
    if (v54)
    {
      v55 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54);
      if (!v55)
      {
        v56 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        v57 = 98;
        v58 = "InterfaceSupport.h";
        v59 = "Interface";
        goto LABEL_73;
      }
    }
    else
    {
      v55 = 0;
    }
    v60 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v54, v55, v52, 4, 4, 1, 1);
    if ((mlir::DenseIntElementsAttr::classof((uint64_t)v60) & 1) == 0)
    {
LABEL_72:
      v56 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v57 = 566;
      v58 = "Casting.h";
      v59 = "cast";
LABEL_73:
      __assert_rtn(v59, v58, v57, v56);
    }
    v81[0] = v60;
    __p[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), LocationForOp, v81);
    v61 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, v79, __p);
    if (!*((_DWORD *)v61 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v79[0] = (uint64_t)v61 - 16;
    operator delete(v52);
  }
  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
  v62 = (uint64_t *)__p[0];
  v63 = v79[0];
  v64 = (char *)operator new(8uLL);
  *(_QWORD *)v64 = v63;
  v81[0] = v62;
  v65 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v62, (uint64_t)&std::piecewise_construct, (__int128 **)v81);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v65 + 5, v64, v64 + 8, 1uLL);
  operator delete(v64);
  v66 = (void **)__p[0];
  if (__p[0])
  {
    v67 = (void **)__p[1];
    v68 = __p[0];
    if (__p[1] != __p[0])
    {
      do
      {
        if (*((char *)v67 - 1) < 0)
          operator delete(*(v67 - 3));
        v67 -= 3;
      }
      while (v67 != v66);
      v68 = __p[0];
    }
    __p[1] = v66;
    operator delete(v68);
  }
  return 1;
}

void sub_180E63BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  std::vector<std::string>::~vector[abi:ne180100](&a27);
  _Unwind_Resume(a1);
}

void sub_180E63BB4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E63BC8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E63BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a27);
  _Unwind_Resume(a1);
}

void sub_180E63BF0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E63C04(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_180E63C18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::unique_ptr<MILToMLIRRewritePattern>>::__emplace_back_slow_path<std::unique_ptr<MILToMLIR::ConvolutionPattern>>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;

  v2 = a1[1] - *a1;
  v3 = v2 >> 3;
  v4 = (v2 >> 3) + 1;
  if (v4 >> 61)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v7 = a1[2] - *a1;
  if (v7 >> 2 > v4)
    v4 = v7 >> 2;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8)
    v8 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v8 = v4;
  if (v8)
  {
    if (v8 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v9 = (char *)operator new(8 * v8);
  }
  else
  {
    v9 = 0;
  }
  v10 = &v9[8 * v3];
  v11 = &v9[8 * v8];
  v12 = *a2;
  *a2 = 0;
  *(_QWORD *)v10 = v12;
  v13 = v10 + 8;
  v14 = (char *)*a1;
  v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
  }
  else
  {
    v16 = (unint64_t)&v15[-*a1 - 8];
    if (v16 < 0x78 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15)
      goto LABEL_31;
    v17 = (v16 >> 3) + 1;
    v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    v10 -= v18;
    v19 = &v15[-v18];
    v20 = v15 - 16;
    v21 = &v9[8 * v3 - 16];
    v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v24 = *((_OWORD *)v20 - 1);
      v23 = *(_OWORD *)v20;
      *((_OWORD *)v20 - 1) = 0uLL;
      *(_OWORD *)v20 = 0uLL;
      *((_OWORD *)v21 - 1) = v24;
      *(_OWORD *)v21 = v23;
      v20 -= 32;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    v15 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      do
      {
        v25 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *(_QWORD *)v15 = 0;
        *((_QWORD *)v10 - 1) = v25;
        v10 -= 8;
      }
      while (v15 != v14);
    }
    v15 = (char *)*a1;
    v26 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    while (v26 != v15)
    {
      v28 = *((_QWORD *)v26 - 1);
      v26 -= 8;
      v27 = v28;
      *(_QWORD *)v26 = 0;
      if (v28)
        (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
    }
  }
  if (v15)
    operator delete(v15);
  return v13;
}

void `anonymous namespace'::PReLUPattern::~PReLUPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::PReLUPattern::matchAndRewrite(_anonymous_namespace_::PReLUPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void **v7;
  const void ***v8;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v10;
  uint64_t v11;
  int *v12;
  int *v13;
  uint64_t v14;
  const void **v15;
  const void ***v16;
  BOOL v17;
  int *v18;
  int v19;
  int *v20;
  int64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  _BYTE *v26;
  int *v27;
  int64_t v28;
  unint64_t v29;
  int *v30;
  int v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _OWORD *v35;
  int *v36;
  uint64_t v37;
  __int128 v38;
  mlir::StringAttr **v39;
  uint64_t v40;
  uint64_t v41;
  int *v42;
  int64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  _BYTE *v48;
  _DWORD *v49;
  char *v50;
  int64_t v51;
  unint64_t v52;
  int *v53;
  uint64_t v54;
  uint64_t v55;
  _OWORD *v56;
  __int128 *v57;
  uint64_t v58;
  __int128 v59;
  int v60;
  uint64_t IntegerType;
  uint64_t **v62;
  uint64_t InterfaceFor;
  const char *v64;
  int v65;
  const char *v66;
  const char *v67;
  void *v68;
  mlir::GenericProgramPoint *v69;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v71;
  uint64_t v72;
  uint64_t *v73;
  mlir::GenericProgramPoint *v74;
  uint64_t *Context;
  uint64_t v76;
  char v77;
  mlir::GenericProgramPoint *v78;
  uint64_t v79;
  mlir::GenericProgramPoint *v80;
  uint64_t *v81;
  uint64_t v82;
  char v83;
  mlir::GenericProgramPoint *v84;
  uint64_t v85;
  __int128 *v86;
  char *v87;
  uint64_t *v88;
  void **v89;
  void **v90;
  void *v91;
  const char *v93;
  int v94;
  const char *v95;
  const char *v96;
  const char *v97;
  int v98;
  const char *v99;
  const char *v100;
  const MIL::IROperation *v101;
  uint64_t v102;
  mlir::StringAttr **v103;
  mlir::GenericProgramPoint *v104;
  void *v105;
  _BYTE *v106;
  int *v107;
  char **v108;
  char *v109[2];
  uint64_t v110;
  uint64_t ArgValue;
  uint64_t v112;
  uint64_t v113[4];
  __int16 v114;
  uint64_t v115[2];
  const char *v116;
  uint64_t v117;
  __int16 v118;
  __int128 *v119[5];
  void *__p;
  void **v121;
  char v122;
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v110 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v109[0] = 0;
  v109[1] = 0;
  v108 = v109;
  v8 = v6 + 1;
  v7 = *v6;
  if (*v6 != (const void **)(v6 + 1))
  {
    do
    {
      std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v108, (uint64_t *)v109, v7 + 4, (uint64_t)(v7 + 4));
      v15 = (const void **)v7[1];
      if (v15)
      {
        do
        {
          v16 = (const void ***)v15;
          v15 = (const void **)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v16 = (const void ***)v7[2];
          v17 = *v16 == v7;
          v7 = (const void **)v16;
        }
        while (!v17);
      }
      v7 = (const void **)v16;
    }
    while (v16 != v8);
  }
  v122 = 1;
  LOWORD(__p) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  if (v122 < 0)
    operator delete(__p);
  v10 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v11 = MIL::IRTensorValueType::Rank(v10);
  v12 = (int *)operator new(0x10uLL);
  v13 = v12;
  v102 = LocationForOp;
  v103 = a3;
  v101 = a2;
  v105 = v12;
  v106 = v12;
  v107 = v12 + 4;
  if (v11 > 2)
  {
    v14 = 0;
    while (1)
    {
      v19 = ~(_DWORD)v14;
      if (v13 >= v107)
        break;
      *v13 = v19;
      v18 = v13 + 1;
LABEL_14:
      v106 = v18;
      v13 = v18;
      v17 = v14++ == v11 - 3;
      if (v17)
        goto LABEL_43;
    }
    v20 = (int *)v105;
    v21 = (char *)v13 - (_BYTE *)v105;
    v22 = ((char *)v13 - (_BYTE *)v105) >> 2;
    v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v24 = (char *)v107 - (_BYTE *)v105;
    if (((char *)v107 - (_BYTE *)v105) >> 1 > v23)
      v23 = v24 >> 1;
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
      v25 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v25 = v23;
    if (v25)
    {
      if (v25 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v26 = operator new(4 * v25);
      v27 = (int *)&v26[4 * v22];
      *v27 = v19;
      v18 = v27 + 1;
      v28 = (char *)v13 - (char *)v20;
      if (v13 == v20)
        goto LABEL_30;
    }
    else
    {
      v26 = 0;
      v27 = (int *)(4 * v22);
      *(_DWORD *)(4 * v22) = v19;
      v18 = (int *)(4 * v22 + 4);
      v28 = (char *)v13 - (char *)v20;
      if (v13 == v20)
        goto LABEL_30;
    }
    v29 = v28 - 4;
    if (v29 >= 0xBC)
    {
      v32 = ((char *)(v13 - 1) - (char *)v20) & 0xFFFFFFFFFFFFFFFCLL;
      if (&v26[v21 - 4 - v32] > &v26[v21 - 4])
      {
        v30 = v13;
      }
      else if ((int *)((char *)v13 - v32 - 4) > v13 - 1)
      {
        v30 = v13;
      }
      else if ((unint64_t)((char *)v13 - v26 - v21) >= 0x20)
      {
        v33 = (v29 >> 2) + 1;
        v34 = 4 * (v33 & 0x7FFFFFFFFFFFFFF8);
        v30 = &v13[v34 / 0xFFFFFFFFFFFFFFFCLL];
        v27 = (int *)((char *)v27 - v34);
        v35 = &v26[4 * v22 - 16];
        v36 = v13 - 4;
        v37 = v33 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v38 = *(_OWORD *)v36;
          *(v35 - 1) = *((_OWORD *)v36 - 1);
          *v35 = v38;
          v35 -= 2;
          v36 -= 8;
          v37 -= 8;
        }
        while (v37);
        if (v33 == (v33 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_30:
          v105 = v27;
          v106 = v18;
          v107 = (int *)&v26[4 * v25];
          if (v20)
            operator delete(v20);
          goto LABEL_14;
        }
      }
      else
      {
        v30 = v13;
      }
    }
    else
    {
      v30 = v13;
    }
    do
    {
      v31 = *--v30;
      *--v27 = v31;
    }
    while (v30 != v20);
    goto LABEL_30;
  }
  v18 = v12;
LABEL_43:
  if (v11 >= 2)
  {
    v40 = v102;
    v39 = v103;
    if (v18 < v107)
    {
      *v18 = 0;
      v41 = (uint64_t)(v18 + 1);
LABEL_68:
      v106 = (_BYTE *)v41;
      v18 = (int *)v41;
      goto LABEL_69;
    }
    v42 = (int *)v105;
    v43 = (char *)v18 - (_BYTE *)v105;
    v44 = ((char *)v18 - (_BYTE *)v105) >> 2;
    v45 = v44 + 1;
    if ((unint64_t)(v44 + 1) >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v46 = (char *)v107 - (_BYTE *)v105;
    if (((char *)v107 - (_BYTE *)v105) >> 1 > v45)
      v45 = v46 >> 1;
    if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFFCLL)
      v47 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v47 = v45;
    if (v47)
    {
      if (v47 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v48 = operator new(4 * v47);
      v49 = &v48[4 * v44];
      v50 = &v48[4 * v47];
      *v49 = 0;
      v41 = (uint64_t)(v49 + 1);
      v51 = (char *)v18 - (char *)v42;
      if (v18 == v42)
        goto LABEL_66;
    }
    else
    {
      v48 = 0;
      v49 = (_DWORD *)(4 * v44);
      v50 = 0;
      *(_DWORD *)(4 * v44) = 0;
      v41 = 4 * v44 + 4;
      v51 = (char *)v18 - (char *)v42;
      if (v18 == v42)
        goto LABEL_66;
    }
    v52 = v51 - 4;
    if (v52 >= 0x2C)
    {
      if ((unint64_t)((char *)v18 - v48 - v43) >= 0x20)
      {
        v54 = (v52 >> 2) + 1;
        v55 = 4 * (v54 & 0x7FFFFFFFFFFFFFF8);
        v53 = &v18[v55 / 0xFFFFFFFFFFFFFFFCLL];
        v49 = (_DWORD *)((char *)v49 - v55);
        v56 = &v48[4 * v44 - 16];
        v57 = (__int128 *)(v18 - 4);
        v58 = v54 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v59 = *v57;
          *(v56 - 1) = *(v57 - 1);
          *v56 = v59;
          v56 -= 2;
          v57 -= 2;
          v58 -= 8;
        }
        while (v58);
        if (v54 == (v54 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_66:
          v105 = v49;
          v106 = (_BYTE *)v41;
          v107 = (int *)v50;
          if (v42)
            operator delete(v42);
          goto LABEL_68;
        }
      }
      else
      {
        v53 = v18;
      }
    }
    else
    {
      v53 = v18;
    }
    do
    {
      v60 = *--v53;
      *--v49 = v60;
    }
    while (v53 != v42);
    goto LABEL_66;
  }
  v40 = v102;
  v39 = v103;
LABEL_69:
  __p = (void *)(((char *)v18 - (_BYTE *)v105) >> 2);
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(v39 + 13), 0x20u, 1);
  v62 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, IntegerType, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v62))
    goto LABEL_98;
  if (v62)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v62);
    if (!InterfaceFor)
    {
      v64 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v65 = 98;
      v66 = "InterfaceSupport.h";
      v67 = "Interface";
      goto LABEL_99;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v68 = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v62, InterfaceFor, v105, v106 - (_BYTE *)v105, 4, 1, 1);
  if ((mlir::DenseIntElementsAttr::classof((uint64_t)v68) & 1) == 0)
  {
LABEL_98:
    v64 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v65 = 566;
    v66 = "Casting.h";
    v67 = "cast";
LABEL_99:
    __assert_rtn(v67, v66, v65, v64);
  }
  __p = v68;
  v104 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(v39 + 13), v40, (uint64_t **)&__p);
  v69 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(v39 + 13), v40, &v110, &v104);
  if (!*((_DWORD *)v69 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v110 = (uint64_t)v69 - 16;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
  v71 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v39 + 13, v40, &v110, (uint64_t *)&__p);
  if (!*((_DWORD *)v71 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v110 = (uint64_t)v71 - 16;
  v72 = mlir::getElementTypeOrSelf(ArgValue);
  __p = (void *)1;
  v73 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&__p, 1, v72, 0);
  __p = (void *)mlir::mps::getConstantAttr<int>(v73, 0);
  v74 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(v39 + 13), v40, (uint64_t **)&__p);
  v112 = v40;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v112);
  v76 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater_equal", (const unsigned __int8 *)0x11, Context);
  if (!v77)
  {
    v118 = 1283;
    v116 = "mps.greater_equal";
    v117 = 17;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v114 = 259;
    llvm::operator+(v115, v113, (uint64_t)v119);
    llvm::report_fatal_error((llvm::Twine *)v119, 1);
  }
  mlir::OperationState::OperationState(&__p, v40, v76);
  if (!*((_DWORD *)v74 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::EqualToOp::build((uint64_t)(v39 + 13), (uint64_t)&__p, ArgValue, (uint64_t)v74 - 16);
  v78 = mlir::OpBuilder::create((mlir::OpBuilder *)(v39 + 13), (const mlir::OperationState *)&__p);
  if (!v78)
  {
    v93 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v94 = 662;
    v95 = "Casting.h";
    v96 = "dyn_cast";
    goto LABEL_107;
  }
  v79 = llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v78);
  if (!v79)
  {
    v93 = "result && \"builder didn't return the right type\"";
    v94 = 497;
    v95 = "Builders.h";
    v96 = "create";
LABEL_107:
    __assert_rtn(v96, v95, v94, v93);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  v80 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(v39 + 13, v40, &v110, &ArgValue);
  v112 = v40;
  v81 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v112);
  v82 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v81);
  if (!v83)
  {
    v118 = 1283;
    v116 = "mps.select";
    v117 = 10;
                       "been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-"
                       "dependent-whats-up-with-dialects-management";
    v114 = 259;
    llvm::operator+(v115, v113, (uint64_t)v119);
    llvm::report_fatal_error((llvm::Twine *)v119, 1);
  }
  mlir::OperationState::OperationState(&__p, v40, v82);
  if (!*(_DWORD *)(v79 + 36) || !*((_DWORD *)v80 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::SelectOp::build((uint64_t)(v39 + 13), (uint64_t)&__p, v79 - 16, ArgValue, (uint64_t)v80 - 16);
  v84 = mlir::OpBuilder::create((mlir::OpBuilder *)(v39 + 13), (const mlir::OperationState *)&__p);
  if (!v84)
  {
    v97 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v98 = 662;
    v99 = "Casting.h";
    v100 = "dyn_cast";
    goto LABEL_111;
  }
  v85 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v84);
  if (!v85)
  {
    v97 = "result && \"builder didn't return the right type\"";
    v98 = 497;
    v99 = "Builders.h";
    v100 = "create";
LABEL_111:
    __assert_rtn(v100, v99, v98, v97);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
  (*(void (**)(void **__return_ptr))(*(_QWORD *)v101 + 200))(&__p);
  if (!*(_DWORD *)(v85 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v86 = (__int128 *)__p;
  v87 = (char *)operator new(8uLL);
  *(_QWORD *)v87 = v85 - 16;
  v119[0] = v86;
  v88 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(v39 + 8), (uint64_t)v86, (uint64_t)&std::piecewise_construct, v119);
  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v88 + 5, v87, v87 + 8, 1uLL);
  operator delete(v87);
  v89 = (void **)__p;
  if (__p)
  {
    v90 = v121;
    v91 = __p;
    if (v121 != __p)
    {
      do
      {
        if (*((char *)v90 - 1) < 0)
          operator delete(*(v90 - 3));
        v90 -= 3;
      }
      while (v90 != v89);
      v91 = __p;
    }
    v121 = v89;
    operator delete(v91);
  }
  if (v105)
  {
    v106 = v105;
    operator delete(v105);
  }
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v108, v109[0]);
  return 1;
}

void sub_180E64954(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, char a18, char *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  if (__p)
    operator delete(__p);
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a18, a19);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(_QWORD *)AttrData == 0x616572672E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x617571655F726574
      && *(_BYTE *)(AttrData + 16) == 108)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.greater_equal";
      v9[3] = 17;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOrEqualToOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::ReduceArgMinPattern::~ReduceArgMinPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::ReducePatternBase::matchAndRewrite(_anonymous_namespace_::ReducePatternBase *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  mlir::Float32Type **v6;
  uint64_t LocationForOp;
  mlir::MLIRContext *v8;
  _BOOL4 isF16;
  uint64_t v10;
  mlir::GenericProgramPoint *v11;
  _BOOL4 isSignedInteger;
  uint64_t IntegerType;
  mlir::GenericProgramPoint *v14;
  const char *v15;
  uint64_t OptionalArgValue;
  uint64_t ParameterValue;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  mlir::GenericProgramPoint *v21;
  __int128 *v22;
  uint64_t v23;
  char *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v31;
  _BYTE __p[24];
  uint64_t ElementTypeOrSelf;
  uint64_t ArgValue;
  uint64_t v35;
  __int128 *v36;

  v6 = a3 + 13;
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v35 = LocationForOp;
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
  if (*((_BYTE *)this + 33))
  {
    isF16 = mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf);
    if (isF16)
    {
      v10 = mlir::Float32Type::get(*v6, v8);
      *(_QWORD *)__p = mlir::TypeAttr::get(v10);
      v11 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v6, LocationForOp, &ArgValue, (uint64_t *)__p);
      if (!*((_DWORD *)v11 + 9))
        goto LABEL_35;
      ArgValue = (uint64_t)v11 - 16;
    }
    if (mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 8)
      || mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 16))
    {
      isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf);
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)v6, 0x20u, isSignedInteger);
      *(_QWORD *)__p = mlir::TypeAttr::get(IntegerType);
      v14 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v6, LocationForOp, &ArgValue, (uint64_t *)__p);
      if (!*((_DWORD *)v14 + 9))
        goto LABEL_35;
      ArgValue = (uint64_t)v14 - 16;
      isF16 = 1;
    }
  }
  else
  {
    isF16 = 0;
  }
  if (*((_BYTE *)this + 32))
    v15 = "axis";
  else
    v15 = "axes";
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, v15);
  __p[23] = 9;
  strcpy(__p, "keep_dims");
  ParameterValue = MIL::IROperation::TryGetParameterValue();
  v18 = ParameterValue;
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (v18)
      goto LABEL_15;
  }
  else if (ParameterValue)
  {
LABEL_15:
    v19 = MIL::IRValue::GetScalar<BOOL>();
    goto LABEL_18;
  }
  v19 = 1;
LABEL_18:
  v31 = (*(uint64_t (**)(_anonymous_namespace_::ReducePatternBase *, mlir::Float32Type **, uint64_t, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)this + 24))(this, v6, ArgValue, OptionalArgValue, v19, &v35);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    if (!isF16 || *((_BYTE *)this + 32))
      goto LABEL_23;
    v20 = v35;
    *(_QWORD *)__p = mlir::TypeAttr::get(ElementTypeOrSelf);
    v21 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(v6, v20, &v31, (uint64_t *)__p);
    if (*((_DWORD *)v21 + 9))
    {
      v31 = (uint64_t)v21 - 16;
LABEL_23:
      (*(void (**)(_BYTE *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
      v23 = v31;
      v22 = *(__int128 **)__p;
      v24 = (char *)operator new(8uLL);
      *(_QWORD *)v24 = v23;
      v36 = v22;
      v25 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v22, (uint64_t)&std::piecewise_construct, &v36);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v25 + 5, v24, v24 + 8, 1uLL);
      operator delete(v24);
      v26 = *(_QWORD *)__p;
      if (*(_QWORD *)__p)
      {
        v27 = *(_QWORD *)&__p[8];
        v28 = *(void **)__p;
        if (*(_QWORD *)&__p[8] != *(_QWORD *)__p)
        {
          do
          {
            if (*(char *)(v27 - 1) < 0)
              operator delete(*(void **)(v27 - 24));
            v27 -= 24;
          }
          while (v27 != v26);
          v28 = *(void **)__p;
        }
        *(_QWORD *)&__p[8] = v26;
        operator delete(v28);
      }
      return 1;
    }
LABEL_35:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  *(_QWORD *)__p = operator new(0x40uLL);
  *(_OWORD *)&__p[8] = xmmword_18125E6C0;
  strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
  v29 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
  if ((__p[23] & 0x80000000) != 0)
    operator delete(*(void **)__p);
  return v29;
}

void sub_180E64F64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t `anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionArgMinOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  _BYTE v26[40];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v10 = *a6;
  v21 = *a6;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_argmin", (const unsigned __int8 *)0x14, Context);
  if (!v13)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_argmin";
    v24[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionArgMinOp::build(a2, (uint64_t)v27, a3, a4, a5);
  v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v18 = 662;
    v19 = "Casting.h";
    v20 = "dyn_cast";
    goto LABEL_9;
  }
  v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionArgMinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionArgMinOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    v17 = "result && \"builder didn't return the right type\"";
    v18 = 497;
    v19 = "Builders.h";
    v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v15 - 16;
}

void sub_180E6515C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E65170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::ReducePatternBase *`anonymous namespace'::ReducePatternBase::ReducePatternBase(_anonymous_namespace_::ReducePatternBase *this, const char *__s, char a3, char a4)
{
  size_t v8;
  size_t v9;
  __int128 *p_dst;
  uint64_t v11;
  uint64_t v12;
  std::string *v13;
  void *v14;
  __int128 __dst;
  unint64_t v17;

  v8 = strlen(__s);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    p_dst = (__int128 *)operator new(v11 + 1);
    *((_QWORD *)&__dst + 1) = v9;
    v17 = v12 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v17) = v8;
  p_dst = &__dst;
  if (v8)
LABEL_8:
    memcpy(p_dst, __s, v9);
  *((_BYTE *)p_dst + v9) = 0;
  *(_QWORD *)this = &unk_1E0E138C8;
  v13 = (std::string *)((char *)this + 8);
  if (SHIBYTE(v17) < 0)
  {
    v14 = (void *)__dst;
    std::string::__init_copy_ctor_external(v13, (const std::string::value_type *)__dst, *((std::string::size_type *)&__dst + 1));
    operator delete(v14);
  }
  else
  {
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = __dst;
    *((_QWORD *)this + 3) = v17;
  }
  *(_QWORD *)this = off_1E0E16AB8;
  *((_BYTE *)this + 32) = a4;
  *((_BYTE *)this + 33) = a3;
  return this;
}

void sub_180E652A8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionArgMinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionArgMinOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 20
      && *(_QWORD *)AttrData == 0x756465722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x72615F6E6F697463
      && *(_DWORD *)(AttrData + 16) == 1852403047)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_argmin";
      v9[3] = 20;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMinOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::ReduceArgMaxPattern::~ReduceArgMaxPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionArgMaxOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  _BYTE v26[40];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v10 = *a6;
  v21 = *a6;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_argmax", (const unsigned __int8 *)0x14, Context);
  if (!v13)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_argmax";
    v24[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionArgMaxOp::build(a2, (uint64_t)v27, a3, a4, a5);
  v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v18 = 662;
    v19 = "Casting.h";
    v20 = "dyn_cast";
    goto LABEL_9;
  }
  v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionArgMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionArgMaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    v17 = "result && \"builder didn't return the right type\"";
    v18 = 497;
    v19 = "Builders.h";
    v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v15 - 16;
}

void sub_180E65614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E65628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionArgMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionArgMaxOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 20
      && *(_QWORD *)AttrData == 0x756465722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x72615F6E6F697463
      && *(_DWORD *)(AttrData + 16) == 2019650919)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_argmax";
      v9[3] = 20;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMaxOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::ReduceL1NormPattern::~ReduceL1NormPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::ReduceL1NormPattern::lower(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  uint64_t v26[4];
  __int16 v27;
  _BYTE v28[40];
  _QWORD v29[39];

  v29[38] = *MEMORY[0x1E0C80C00];
  v22 = a3;
  v10 = mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>(a2, *a6, &v22);
  v11 = *a6;
  v23 = v11;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v23);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v14)
  {
    v27 = 1283;
    v26[2] = (uint64_t)"mps.reduction_sum";
    v26[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v25 = 259;
    llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
    llvm::report_fatal_error((llvm::Twine *)v28, 1);
  }
  mlir::OperationState::OperationState(v29, v11, v13);
  if (!*(_DWORD *)(v10 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ReductionSumOp::build((mlir::UnitAttr **)a2, (uint64_t)v29, v10 - 16, a4, a5);
  v15 = mlir::OpBuilder::create(a2, (const mlir::OperationState *)v29);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_11;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionSumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_11:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  if (!*(_DWORD *)(v16 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v16 - 16;
}

void sub_180E659D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E659E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionSumOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 17
      && *(_QWORD *)AttrData == 0x756465722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x75735F6E6F697463
      && *(_BYTE *)(AttrData + 16) == 109)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_sum";
      v9[3] = 17;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::ReduceL2NormPattern::~ReduceL2NormPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::ReduceL2NormPattern::lower(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t *a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  unsigned __int8 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _BYTE v29[40];
  _QWORD v30[39];

  v30[38] = *MEMORY[0x1E0C80C00];
  v22 = a4;
  v23 = a3;
  v21 = a5;
  v20 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>(a2, *a6, &v23);
  v8 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>((mlir::UnitAttr **)a2, *a6, (uint64_t)&v20, &v22, &v21);
  v9 = *a6;
  v24 = v9;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, Context);
  if (!v12)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mps.square_root";
    v27[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v30, v9, v11);
  if (!*(_DWORD *)(v8 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ACosOp::build((uint64_t)a2, (uint64_t)v30, v8 - 16);
  v13 = mlir::OpBuilder::create(a2, (const mlir::OperationState *)v30);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_11;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::SquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareRootOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_11:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  if (!*(_DWORD *)(v14 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v14 - 16;
}

void sub_180E65D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

void sub_180E65DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _BYTE v25[40];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.reduction_sum";
    v23[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  if (!*(_DWORD *)(*(_QWORD *)a3 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ReductionSumOp::build(a1, (uint64_t)v26, *(_QWORD *)a3 - 16, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_10;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionSumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionSumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_10:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v14;
}

void sub_180E65F7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E65F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareRootOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 15 && *AttrData == 0x617571732E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x746F6F725F657261)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.square_root";
      v8[3] = 15;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::ReduceLogSumExpPattern::~ReduceLogSumExpPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

char *`anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionLogSumExpOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  void *v17;
  const char *v19;
  int v20;
  const char *v21;
  const char *v22;
  _QWORD *AttrData;
  uint64_t v24;
  BOOL v25;
  uint64_t v27;
  uint64_t v28[4];
  __int16 v29;
  uint64_t v30[2];
  const char *v31;
  uint64_t v32;
  __int16 v33;
  _QWORD v34[5];
  _QWORD v35[39];

  v35[38] = *MEMORY[0x1E0C80C00];
  v10 = *a6;
  v27 = *a6;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_logsumexp", (const unsigned __int8 *)0x17, Context);
  if (!v13)
  {
    v33 = 1283;
    v31 = "mps.reduction_logsumexp";
    v32 = 23;
                      "een added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-de"
                      "pendent-whats-up-with-dialects-management";
    v29 = 259;
    llvm::operator+(v30, v28, (uint64_t)v34);
    llvm::report_fatal_error((llvm::Twine *)v34, 1);
  }
  mlir::OperationState::OperationState(v35, v10, v12);
  mlir::mps::ReductionLogSumExpOp::build(a2, (uint64_t)v35, a3, a4, a5);
  v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v35);
  v15 = v14;
  if (!v14)
  {
    v19 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v20 = 662;
    v21 = "Casting.h";
    v22 = "dyn_cast";
    goto LABEL_21;
  }
  v16 = *((_QWORD *)v14 + 6);
  v17 = *(void **)(v16 + 16);
  if (v17 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v34[0] = *(_QWORD *)(v16 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v34);
    if (v24 == 23)
    {
      v25 = *AttrData == 0x756465722E73706DLL && AttrData[1] == 0x6F6C5F6E6F697463;
      if (v25 && *(_QWORD *)((char *)AttrData + 15) == 0x7078656D7573676FLL)
      {
        v33 = 1283;
        v30[0] = (uint64_t)"classof on '";
        v31 = "mps.reduction_logsumexp";
        v32 = 23;
        v28[0] = (uint64_t)"' failed due to the operation not being registered";
        v29 = 259;
        llvm::operator+(v30, v28, (uint64_t)v34);
        llvm::report_fatal_error((llvm::Twine *)v34, 1);
      }
    }
    goto LABEL_20;
  }
  if (v17 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionLogSumExpOp,void>::id)
  {
LABEL_20:
    v19 = "result && \"builder didn't return the right type\"";
    v20 = 497;
    v21 = "Builders.h";
    v22 = "create";
LABEL_21:
    __assert_rtn(v22, v21, v20, v19);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v35);
  if (!*((_DWORD *)v15 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return (char *)v15 - 16;
}

void sub_180E663BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E663D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::ReduceLogSumPattern::~ReduceLogSumPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::ReduceLogSumPattern::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t *a6)
{
  mlir::GenericProgramPoint *v8;
  uint64_t v9;
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  const char *v16;
  int v17;
  const char *v18;
  const char *v19;
  unsigned __int8 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  __int16 v25;
  uint64_t v26[4];
  __int16 v27;
  _BYTE v28[40];
  _QWORD v29[39];

  v29[38] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  v20 = a5;
  v8 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>(a2, *a6, &v22, &v21, &v20);
  v9 = *a6;
  v23 = v9;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v23);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    v27 = 1283;
    v26[2] = (uint64_t)"mps.logarithm";
    v26[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v25 = 259;
    llvm::operator+(v26, (uint64_t *)&v24, (uint64_t)v28);
    llvm::report_fatal_error((llvm::Twine *)v28, 1);
  }
  mlir::OperationState::OperationState(v29, v9, v11);
  if (!*((_DWORD *)v8 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ACosOp::build((uint64_t)a2, (uint64_t)v29, (uint64_t)v8 - 16);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v29);
  if (!v13)
  {
    v16 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v17 = 662;
    v18 = "Casting.h";
    v19 = "dyn_cast";
    goto LABEL_11;
  }
  v14 = llvm::DefaultDoCastIfPossible<mlir::mps::LogarithmOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LogarithmOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
  if (!v14)
  {
    v16 = "result && \"builder didn't return the right type\"";
    v17 = 497;
    v18 = "Builders.h";
    v19 = "create";
LABEL_11:
    __assert_rtn(v19, v18, v17, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  if (!*(_DWORD *)(v14 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v14 - 16;
}

void sub_180E66674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void sub_180E66688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::ReduceMaxPattern::~ReduceMaxPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionMaxOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  _BYTE v26[40];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v10 = *a6;
  v21 = *a6;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_max", (const unsigned __int8 *)0x11, Context);
  if (!v13)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_max";
    v24[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionMaxOp::build(a2, (uint64_t)v27, a3, a4, a5, 0);
  v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v18 = 662;
    v19 = "Casting.h";
    v20 = "dyn_cast";
    goto LABEL_9;
  }
  v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    v17 = "result && \"builder didn't return the right type\"";
    v18 = 497;
    v19 = "Builders.h";
    v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v15 - 16;
}

void sub_180E668F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6690C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::ReduceMeanPattern::~ReduceMeanPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionMeanOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  _BYTE v26[40];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v10 = *a6;
  v21 = *a6;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v13)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_mean";
    v24[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionMeanOp::build(a2, (uint64_t)v27, a3, a4, a5);
  v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v18 = 662;
    v19 = "Casting.h";
    v20 = "dyn_cast";
    goto LABEL_9;
  }
  v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMeanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMeanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    v17 = "result && \"builder didn't return the right type\"";
    v18 = 497;
    v19 = "Builders.h";
    v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v15 - 16;
}

void sub_180E66B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E66B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::ReduceMinPattern::~ReduceMinPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionMinOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  _BYTE v26[40];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v10 = *a6;
  v21 = *a6;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_min", (const unsigned __int8 *)0x11, Context);
  if (!v13)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_min";
    v24[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionMinOp::build(a2, (uint64_t)v27, a3, a4, a5, 0);
  v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v18 = 662;
    v19 = "Casting.h";
    v20 = "dyn_cast";
    goto LABEL_9;
  }
  v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionMinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionMinOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    v17 = "result && \"builder didn't return the right type\"";
    v18 = 497;
    v19 = "Builders.h";
    v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v15 - 16;
}

void sub_180E66DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E66E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::ReduceProdPattern::~ReduceProdPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionProdOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  _BYTE v26[40];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v10 = *a6;
  v21 = *a6;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_prod", (const unsigned __int8 *)0x12, Context);
  if (!v13)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"mps.reduction_prod";
    v24[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v27, v10, v12);
  mlir::mps::ReductionProdOp::build(a2, (uint64_t)v27, a3, a4, a5);
  v14 = mlir::OpBuilder::create((mlir::OpBuilder *)a2, (const mlir::OperationState *)v27);
  if (!v14)
  {
    v17 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v18 = 662;
    v19 = "Casting.h";
    v20 = "dyn_cast";
    goto LABEL_9;
  }
  v15 = llvm::DefaultDoCastIfPossible<mlir::mps::ReductionProdOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionProdOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
  if (!v15)
  {
    v17 = "result && \"builder didn't return the right type\"";
    v18 = 497;
    v19 = "Builders.h";
    v20 = "create";
LABEL_9:
    __assert_rtn(v20, v19, v18, v17);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  if (!*(_DWORD *)(v15 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v15 - 16;
}

void sub_180E6707C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E67090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReductionProdOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReductionProdOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 18
      && *(_QWORD *)AttrData == 0x756465722E73706DLL
      && *(_QWORD *)(AttrData + 8) == 0x72705F6E6F697463
      && *(_WORD *)(AttrData + 16) == 25711)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.reduction_prod";
      v9[3] = 18;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::ReduceSumPattern::~ReduceSumPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

char *`anonymous namespace'::OneToOneReducePattern<mlir::mps::ReductionSumOp>::lower(uint64_t a1, mlir::UnitAttr **a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t *a6)
{
  mlir::GenericProgramPoint *v6;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = a3;
  v9 = a4;
  v8 = a5;
  v6 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>(a2, *a6, &v10, &v9, &v8);
  if (!*((_DWORD *)v6 + 9))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return (char *)v6 - 16;
}

void `anonymous namespace'::ReduceSumSquarePattern::~ReduceSumSquarePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::ReduceSumSquarePattern::lower(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t *a6)
{
  uint64_t v8;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t v12;
  uint64_t v13;

  v12 = a4;
  v13 = a3;
  v11 = a5;
  v10 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>(a2, *a6, &v13);
  v8 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>((mlir::UnitAttr **)a2, *a6, (uint64_t)&v10, &v12, &v11);
  if (!*(_DWORD *)(v8 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  return v8 - 16;
}

void `anonymous namespace'::ReshapePattern::~ReshapePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::ReshapePattern::matchAndRewrite(_anonymous_namespace_::ReshapePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  MIL::IRValue *ParameterValue;
  MIL::IRValueType *ParameterType;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  int64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  __int128 *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  _BYTE *v27;
  __int128 *v28;
  int64_t v29;
  unint64_t v30;
  __int128 *v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _OWORD *v36;
  char *v37;
  uint64_t v38;
  __int128 v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  int v44;
  __int128 *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _BYTE *v50;
  __int128 *v51;
  int64_t v52;
  unint64_t v53;
  __int128 *v54;
  int v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _OWORD *v59;
  char *v60;
  uint64_t v61;
  __int128 v62;
  unint64_t v63;
  unint64_t v64;
  char *v65;
  uint64_t v66;
  int v67;
  __int128 *v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  _BYTE *v73;
  __int128 *v74;
  int64_t v75;
  unint64_t v76;
  __int128 *v77;
  int v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _OWORD *v82;
  char *v83;
  uint64_t v84;
  __int128 v85;
  __int128 *v86;
  uint64_t v87;
  char *v88;
  char v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  char *v94;
  char *v95;
  int *v96;
  char *v97;
  int v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  uint64_t IntegerType;
  uint64_t **v109;
  uint64_t InterfaceFor;
  const char *v111;
  int v112;
  const char *v113;
  const char *v114;
  char *v115;
  char v116;
  mlir::GenericProgramPoint *v117;
  uint64_t v118;
  mlir::GenericProgramPoint *v119;
  mlir::GenericProgramPoint *v120;
  __int128 *v121;
  char *v122;
  uint64_t *v123;
  char *v124;
  char *v125;
  char *v126;
  uint64_t LocationForOp;
  mlir::Builder *v129;
  int8x8_t *v130;
  const MIL::IROperation *v131;
  char *v132;
  char *v133;
  uint64_t v134;
  void *__p;
  __int128 v136;
  void *v137;
  char *v138;
  char *v139;
  _QWORD v140[2];
  unint64_t v141;
  _QWORD v142[2];
  unint64_t v143;
  _QWORD v144[2];
  unint64_t v145;
  __int128 *v146;
  __int128 *v147;
  char *v148;
  char *ElementTypeOrSelf;
  __int128 v150;
  uint64_t v151;
  uint64_t ArgValue;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  v151 = 0;
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  HIBYTE(v150) = 5;
  strcpy((char *)&ElementTypeOrSelf, "shape");
  v131 = a2;
  ParameterValue = (MIL::IRValue *)MIL::IROperation::TryGetParameterValue();
  v129 = (mlir::Builder *)(a3 + 13);
  v130 = (int8x8_t *)a3;
  if (!ParameterValue)
    goto LABEL_157;
  HIBYTE(v148) = 1;
  LOWORD(v146) = 120;
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  v7 = MIL::IRValueType::AsTensorType(ParameterType);
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 96))(v7);
  ElementTypeOrSelf = 0;
  v150 = 0uLL;
  v10 = *(const void **)v8;
  v9 = *(_QWORD *)(v8 + 8);
  v11 = v9 - *(_QWORD *)v8;
  if (v9 == *(_QWORD *)v8)
  {
    v12 = 0;
    v13 = 0;
    if (SHIBYTE(v148) < 0)
LABEL_5:
      operator delete(v146);
  }
  else
  {
    if (v11 < 0)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v12 = (char *)operator new(v9 - *(_QWORD *)v8);
    v13 = &v12[8 * (v11 >> 3)];
    ElementTypeOrSelf = v12;
    *((_QWORD *)&v150 + 1) = v13;
    memcpy(v12, v10, v11);
    *(_QWORD *)&v150 = v13;
    if (SHIBYTE(v148) < 0)
      goto LABEL_5;
  }
  v146 = 0;
  v147 = 0;
  v148 = 0;
  v14 = MIL::IRValue::AsTensor(ParameterValue);
  MEMORY[0x186DA10B0](v144, v14);
  v15 = MIL::IRValue::AsTensor(ParameterValue);
  MEMORY[0x186DA10BC](v142, v15);
  v16 = MIL::IRValue::AsTensor(ParameterValue);
  MEMORY[0x186DA10A4](v140, v16);
  v132 = v12;
  v133 = v13;
  if (LOBYTE(v144[0]))
  {
    v17 = v145;
    if (v145)
    {
      v18 = 0;
      v19 = (char *)v147;
      while (1)
      {
        v21 = *(_DWORD *)(v144[1] + 4 * v18);
        if (v19 >= v148)
          break;
        *(_DWORD *)v19 = v21;
        v20 = (uint64_t)(v19 + 4);
LABEL_10:
        v147 = (__int128 *)v20;
        ++v18;
        v19 = (char *)v20;
        if (v18 >= v17)
          goto LABEL_104;
      }
      v22 = v146;
      v23 = (v19 - (char *)v146) >> 2;
      v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 62)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      v25 = v148 - (char *)v146;
      if ((v148 - (char *)v146) >> 1 > v24)
        v24 = v25 >> 1;
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL)
        v26 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v26 = v24;
      if (v26)
      {
        if (v26 >> 62)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v27 = operator new(4 * v26);
        v28 = (__int128 *)&v27[4 * v23];
        *(_DWORD *)v28 = v21;
        v20 = (uint64_t)v28 + 4;
        v29 = v19 - (char *)v22;
        if (v19 == (char *)v22)
          goto LABEL_26;
      }
      else
      {
        v27 = 0;
        v28 = (__int128 *)(4 * v23);
        *(_DWORD *)(4 * v23) = v21;
        v20 = 4 * v23 + 4;
        v29 = v19 - (char *)v22;
        if (v19 == (char *)v22)
          goto LABEL_26;
      }
      v30 = v29 - 4;
      if (v30 >= 0xBC)
      {
        v33 = (v19 - 4 - (char *)v22) & 0xFFFFFFFFFFFFFFFCLL;
        if (&v27[v19 - (char *)v22 - 4 - v33] > &v27[v19 - (char *)v22 - 4])
        {
          v31 = (__int128 *)v19;
        }
        else if (&v19[-v33 - 4] > v19 - 4)
        {
          v31 = (__int128 *)v19;
        }
        else if ((unint64_t)((char *)v22 - v27) >= 0x20)
        {
          v34 = (v30 >> 2) + 1;
          v35 = 4 * (v34 & 0x7FFFFFFFFFFFFFF8);
          v31 = (__int128 *)&v19[-v35];
          v28 = (__int128 *)((char *)v28 - v35);
          v36 = &v27[4 * v23 - 16];
          v37 = v19 - 16;
          v38 = v34 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v39 = *(_OWORD *)v37;
            *(v36 - 1) = *((_OWORD *)v37 - 1);
            *v36 = v39;
            v36 -= 2;
            v37 -= 32;
            v38 -= 8;
          }
          while (v38);
          if (v34 == (v34 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_26:
            v146 = v28;
            v147 = (__int128 *)v20;
            v148 = &v27[4 * v26];
            if (v22)
            {
              operator delete(v22);
              v17 = v145;
            }
            goto LABEL_10;
          }
        }
        else
        {
          v31 = (__int128 *)v19;
        }
      }
      else
      {
        v31 = (__int128 *)v19;
      }
      do
      {
        v32 = *((_DWORD *)v31 - 1);
        v31 = (__int128 *)((char *)v31 - 4);
        *((_DWORD *)v28 - 1) = v32;
        v28 = (__int128 *)((char *)v28 - 4);
      }
      while (v31 != v22);
      goto LABEL_26;
    }
    goto LABEL_104;
  }
  if (!LOBYTE(v142[0]))
  {
    if (!LOBYTE(v140[0]))
      goto LABEL_104;
    v63 = v141;
    if (!v141)
      goto LABEL_104;
    v64 = 0;
    v65 = (char *)v147;
    while (1)
    {
      v67 = *(char *)(v140[1] + v64);
      if (v65 >= v148)
        break;
      *(_DWORD *)v65 = v67;
      v66 = (uint64_t)(v65 + 4);
LABEL_76:
      v147 = (__int128 *)v66;
      ++v64;
      v65 = (char *)v66;
      if (v64 >= v63)
        goto LABEL_104;
    }
    v68 = v146;
    v69 = (v65 - (char *)v146) >> 2;
    v70 = v69 + 1;
    if ((unint64_t)(v69 + 1) >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v71 = v148 - (char *)v146;
    if ((v148 - (char *)v146) >> 1 > v70)
      v70 = v71 >> 1;
    if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFFCLL)
      v72 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v72 = v70;
    if (v72)
    {
      if (v72 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v73 = operator new(4 * v72);
      v74 = (__int128 *)&v73[4 * v69];
      *(_DWORD *)v74 = v67;
      v66 = (uint64_t)v74 + 4;
      v75 = v65 - (char *)v68;
      if (v65 == (char *)v68)
        goto LABEL_92;
    }
    else
    {
      v73 = 0;
      v74 = (__int128 *)(4 * v69);
      *(_DWORD *)(4 * v69) = v67;
      v66 = 4 * v69 + 4;
      v75 = v65 - (char *)v68;
      if (v65 == (char *)v68)
        goto LABEL_92;
    }
    v76 = v75 - 4;
    if (v76 >= 0xBC)
    {
      v79 = (v65 - 4 - (char *)v68) & 0xFFFFFFFFFFFFFFFCLL;
      if (&v73[v65 - (char *)v68 - 4 - v79] > &v73[v65 - (char *)v68 - 4])
      {
        v77 = (__int128 *)v65;
      }
      else if (&v65[-v79 - 4] > v65 - 4)
      {
        v77 = (__int128 *)v65;
      }
      else if ((unint64_t)((char *)v68 - v73) >= 0x20)
      {
        v80 = (v76 >> 2) + 1;
        v81 = 4 * (v80 & 0x7FFFFFFFFFFFFFF8);
        v77 = (__int128 *)&v65[-v81];
        v74 = (__int128 *)((char *)v74 - v81);
        v82 = &v73[4 * v69 - 16];
        v83 = v65 - 16;
        v84 = v80 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v85 = *(_OWORD *)v83;
          *(v82 - 1) = *((_OWORD *)v83 - 1);
          *v82 = v85;
          v82 -= 2;
          v83 -= 32;
          v84 -= 8;
        }
        while (v84);
        if (v80 == (v80 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_92:
          v146 = v74;
          v147 = (__int128 *)v66;
          v148 = &v73[4 * v72];
          if (v68)
          {
            operator delete(v68);
            v63 = v141;
          }
          goto LABEL_76;
        }
      }
      else
      {
        v77 = (__int128 *)v65;
      }
    }
    else
    {
      v77 = (__int128 *)v65;
    }
    do
    {
      v78 = *((_DWORD *)v77 - 1);
      v77 = (__int128 *)((char *)v77 - 4);
      *((_DWORD *)v74 - 1) = v78;
      v74 = (__int128 *)((char *)v74 - 4);
    }
    while (v77 != v68);
    goto LABEL_92;
  }
  v40 = v143;
  if (v143)
  {
    v41 = 0;
    v42 = (char *)v147;
    while (1)
    {
      v44 = *(__int16 *)(v142[1] + 2 * v41);
      if (v42 >= v148)
        break;
      *(_DWORD *)v42 = v44;
      v43 = (uint64_t)(v42 + 4);
LABEL_44:
      v147 = (__int128 *)v43;
      ++v41;
      v42 = (char *)v43;
      if (v41 >= v40)
        goto LABEL_104;
    }
    v45 = v146;
    v46 = (v42 - (char *)v146) >> 2;
    v47 = v46 + 1;
    if ((unint64_t)(v46 + 1) >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v48 = v148 - (char *)v146;
    if ((v148 - (char *)v146) >> 1 > v47)
      v47 = v48 >> 1;
    if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL)
      v49 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v49 = v47;
    if (v49)
    {
      if (v49 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v50 = operator new(4 * v49);
      v51 = (__int128 *)&v50[4 * v46];
      *(_DWORD *)v51 = v44;
      v43 = (uint64_t)v51 + 4;
      v52 = v42 - (char *)v45;
      if (v42 == (char *)v45)
        goto LABEL_60;
    }
    else
    {
      v50 = 0;
      v51 = (__int128 *)(4 * v46);
      *(_DWORD *)(4 * v46) = v44;
      v43 = 4 * v46 + 4;
      v52 = v42 - (char *)v45;
      if (v42 == (char *)v45)
        goto LABEL_60;
    }
    v53 = v52 - 4;
    if (v53 >= 0xBC)
    {
      v56 = (v42 - 4 - (char *)v45) & 0xFFFFFFFFFFFFFFFCLL;
      if (&v50[v42 - (char *)v45 - 4 - v56] > &v50[v42 - (char *)v45 - 4])
      {
        v54 = (__int128 *)v42;
      }
      else if (&v42[-v56 - 4] > v42 - 4)
      {
        v54 = (__int128 *)v42;
      }
      else if ((unint64_t)((char *)v45 - v50) >= 0x20)
      {
        v57 = (v53 >> 2) + 1;
        v58 = 4 * (v57 & 0x7FFFFFFFFFFFFFF8);
        v54 = (__int128 *)&v42[-v58];
        v51 = (__int128 *)((char *)v51 - v58);
        v59 = &v50[4 * v46 - 16];
        v60 = v42 - 16;
        v61 = v57 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v62 = *(_OWORD *)v60;
          *(v59 - 1) = *((_OWORD *)v60 - 1);
          *v59 = v62;
          v59 -= 2;
          v60 -= 32;
          v61 -= 8;
        }
        while (v61);
        if (v57 == (v57 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_60:
          v146 = v51;
          v147 = (__int128 *)v43;
          v148 = &v50[4 * v49];
          if (v45)
          {
            operator delete(v45);
            v40 = v143;
          }
          goto LABEL_44;
        }
      }
      else
      {
        v54 = (__int128 *)v42;
      }
    }
    else
    {
      v54 = (__int128 *)v42;
    }
    do
    {
      v55 = *((_DWORD *)v54 - 1);
      v54 = (__int128 *)((char *)v54 - 4);
      *((_DWORD *)v51 - 1) = v55;
      v51 = (__int128 *)((char *)v51 - 4);
    }
    while (v54 != v45);
    goto LABEL_60;
  }
LABEL_104:
  v137 = 0;
  v138 = 0;
  v139 = 0;
  v86 = v146;
  v87 = (char *)v147 - (char *)v146;
  if (v147 == v146)
    goto LABEL_141;
  if (v87 < 0)
    std::vector<int>::__throw_length_error[abi:ne180100]();
  v88 = (char *)operator new((char *)v147 - (char *)v146);
  v89 = 0;
  v90 = 0;
  v91 = v87 >> 2;
  v137 = v88;
  v138 = v88;
  v139 = &v88[4 * (v87 >> 2)];
  v134 = (v133 - v132) >> 3;
  while (1)
  {
    v92 = ~v90;
    v87 = *((unsigned int *)v86 + v91 + ~v90);
    if ((_DWORD)v87)
    {
      v94 = (char *)v137;
      v93 = (unint64_t)v138;
      v95 = v139;
      if (v138 >= v139)
        goto LABEL_122;
      goto LABEL_111;
    }
    if ((uint64_t)(v134 + v92) >= 0)
      break;
    v87 = 1;
    v89 = 1;
    v94 = (char *)v137;
    v93 = (unint64_t)v138;
    v95 = v139;
    if (v138 >= v139)
    {
LABEL_122:
      v101 = (uint64_t)(v93 - (_QWORD)v94) >> 2;
      v102 = v101 + 1;
      if ((unint64_t)(v101 + 1) >> 62)
        std::vector<int>::__throw_length_error[abi:ne180100]();
      v103 = v95 - v94;
      if (v103 >> 1 > v102)
        v102 = v103 >> 1;
      if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFFCLL)
        v104 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v104 = v102;
      if (v104)
      {
        if (v104 >> 62)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v105 = (char *)operator new(4 * v104);
        v106 = &v105[4 * v104];
        *(_DWORD *)v105 = v87;
        v107 = v105 + 4;
        if ((char *)v93 != v94)
LABEL_131:
          memmove(v107, v94, v93 - (_QWORD)v94);
      }
      else
      {
        v105 = (char *)operator new(4uLL);
        v106 = v105 + 4;
        *(_DWORD *)v105 = v87;
        v107 = v105 + 4;
        if ((char *)v93 != v94)
          goto LABEL_131;
      }
      v137 = v105;
      v138 = &v107[4 * v101];
      v139 = v106;
      if (v94)
        operator delete(v94);
      goto LABEL_108;
    }
LABEL_111:
    if (v94 == (char *)v93)
    {
      *(_DWORD *)v94 = v87;
      v138 = v94 + 4;
    }
    else
    {
      v96 = (int *)(v93 - 4);
      v97 = (char *)v93;
      if (v93 >= 4)
      {
        do
        {
          v98 = *v96++;
          *(_DWORD *)v97 = v98;
          v97 += 4;
        }
        while ((unint64_t)v96 < v93);
      }
      v138 = v97;
      if ((char *)v93 != v94 + 4)
        memmove((void *)(v93 - 4 * ((uint64_t)(v93 - (_QWORD)(v94 + 4)) >> 2)), v94, v93 - (_QWORD)(v94 + 4));
      *(_DWORD *)v94 = v87;
    }
LABEL_108:
    ++v90;
    v86 = v146;
    v91 = ((char *)v147 - (char *)v146) >> 2;
    if (v90 >= v91)
    {
      if ((v89 & 1) != 0)
      {
        __p = (void *)((v138 - (_BYTE *)v137) >> 2);
        IntegerType = mlir::Builder::getIntegerType(v129, 0x20u, 1);
        v109 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&__p, 1, IntegerType, 0);
        v99 = v132;
        if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v109))
          goto LABEL_175;
        if (v109)
        {
          InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v109);
          if (!InterfaceFor)
          {
            v111 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v112 = 98;
            v113 = "InterfaceSupport.h";
            v114 = "Interface";
            goto LABEL_178;
          }
        }
        else
        {
          InterfaceFor = 0;
        }
        v87 = mlir::DenseElementsAttr::getFromRawBuffer(v109, InterfaceFor, v137, v138 - (_BYTE *)v137, 4, 1, 1);
        if (mlir::DenseIntElementsAttr::classof(v87))
        {
          __p = (void *)v87;
          v117 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v129, LocationForOp, (uint64_t **)&__p);
          if (*((_DWORD *)v117 + 9))
          {
            v116 = 0;
            v115 = (char *)v117 - 16;
            v151 = (uint64_t)v117 - 16;
            goto LABEL_149;
          }
          v111 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
          v112 = 984;
          v113 = "Operation.h";
          v114 = "getOpResultImpl";
        }
        else
        {
LABEL_175:
          v111 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
          v112 = 566;
          v113 = "Casting.h";
          v114 = "cast";
        }
LABEL_178:
        __assert_rtn(v114, v113, v112, v111);
      }
LABEL_141:
      v115 = 0;
      v116 = 0;
      v99 = v132;
      goto LABEL_149;
    }
  }
  v99 = v132;
  v100 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)&v132[8 * v134 + 8 * v92] + 16))(*(_QWORD *)&v132[8 * v134 + 8 * v92]);
  if (v100)
  {
    v87 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v100 + 48))(v100);
    v89 = 1;
    v94 = (char *)v137;
    v93 = (unint64_t)v138;
    v95 = v139;
    if (v138 >= v139)
      goto LABEL_122;
    goto LABEL_111;
  }
  __p = operator new(0x38uLL);
  v136 = xmmword_181286AB0;
  strcpy((char *)__p, "reshape with 0 (copy from input) targeting an unknown ");
  v87 = MILToMLIRRewriter::notifyFailure((uint64_t)v130, (uint64_t)v131, (const std::string::value_type *)&__p);
  if (SHIBYTE(v136) < 0)
    operator delete(__p);
  v115 = 0;
  v116 = 1;
LABEL_149:
  if (v137)
  {
    v138 = (char *)v137;
    operator delete(v137);
  }
  if (v146)
  {
    v147 = v146;
    operator delete(v146);
  }
  if (v99)
    operator delete(v99);
  if ((v116 & 1) == 0)
  {
    if (!v115)
    {
LABEL_157:
      v151 = MILToMLIRRewriter::getArgValue(v130, v131, "shape");
      ElementTypeOrSelf = (char *)mlir::getElementTypeOrSelf(v151);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf, 32))
      {
        v118 = mlir::Builder::getIntegerType(v129, 0x20u, 1);
        ElementTypeOrSelf = (char *)mlir::TypeAttr::get(v118);
        v119 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)v129, LocationForOp, &v151, (uint64_t *)&ElementTypeOrSelf);
        if (!*((_DWORD *)v119 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v151 = (uint64_t)v119 - 16;
      }
    }
    if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)v131 + 192))(v131) == 1)
    {
      v120 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)v129, LocationForOp, &ArgValue, &v151);
      (*(void (**)(char **__return_ptr, const MIL::IROperation *))(*(_QWORD *)v131 + 200))(&ElementTypeOrSelf, v131);
      if (!*((_DWORD *)v120 + 9))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
      v121 = (__int128 *)ElementTypeOrSelf;
      v122 = (char *)operator new(8uLL);
      *(_QWORD *)v122 = (char *)v120 - 16;
      v146 = v121;
      v123 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v130[8], (uint64_t)v121, (uint64_t)&std::piecewise_construct, &v146);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v123 + 5, v122, v122 + 8, 1uLL);
      operator delete(v122);
      v124 = ElementTypeOrSelf;
      if (ElementTypeOrSelf)
      {
        v125 = (char *)v150;
        v126 = ElementTypeOrSelf;
        if ((char *)v150 != ElementTypeOrSelf)
        {
          do
          {
            if (*(v125 - 1) < 0)
              operator delete(*((void **)v125 - 3));
            v125 -= 24;
          }
          while (v125 != v124);
          v126 = ElementTypeOrSelf;
        }
        *(_QWORD *)&v150 = v124;
        operator delete(v126);
      }
      return 1;
    }
    else
    {
      ElementTypeOrSelf = (char *)operator new(0x40uLL);
      v150 = xmmword_18125E6C0;
      strcpy(ElementTypeOrSelf, "The number of outputs does not match the number of results.");
      v87 = MILToMLIRRewriter::notifyFailure((uint64_t)v130, (uint64_t)v131, (const std::string::value_type *)&ElementTypeOrSelf);
      if (SHIBYTE(v150) < 0)
        operator delete(ElementTypeOrSelf);
    }
  }
  return v87;
}

void sub_180E68124(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22)
{
  uint64_t v22;
  void *v24;

  if (a20 < 0)
    operator delete(__p);
  if (a21)
  {
    operator delete(a21);
    v24 = *(void **)(v22 - 152);
    if (!v24)
    {
LABEL_5:
      if (!a13)
        goto LABEL_6;
      goto LABEL_9;
    }
  }
  else
  {
    v24 = *(void **)(v22 - 152);
    if (!v24)
      goto LABEL_5;
  }
  *(_QWORD *)(v22 - 144) = v24;
  operator delete(v24);
  if (!a13)
LABEL_6:
    _Unwind_Resume(exception_object);
LABEL_9:
  operator delete(a13);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::SpaceToBatchPattern::~SpaceToBatchPattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::SpaceToBatchPattern::matchAndRewrite(_anonymous_namespace_::SpaceToBatchPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  const void ***v6;
  const void **v7;
  const void ***v8;
  const void **v9;
  const void ***v10;
  BOOL v11;
  char *v12;
  char **v13;
  char *v14;
  char **v15;
  char *v16;
  char *v17;
  unint64_t v18;
  int v19;
  char *v20;
  size_t v21;
  _BOOL4 v22;
  int v23;
  char **v24;
  char *v25;
  _QWORD *v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  char *v30;
  char *v31;
  size_t v32;
  _BOOL4 v33;
  int v34;
  _BOOL4 v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v39;
  uint64_t ParameterValue;
  uint64_t Data;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  MIL::IRValueType *ParameterType;
  MIL::IRTensorValueType *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t Context;
  uint64_t v53;
  uint64_t **v54;
  uint64_t InterfaceFor;
  const char *v56;
  int v57;
  const char *v58;
  const char *v59;
  int32x4_t *v60;
  unint64_t v61;
  int32x4_t v62;
  int32x4_t v63;
  int32x4_t *v64;
  int32x4_t v65;
  int32x4_t v66;
  unint64_t v67;
  int32x4_t v68;
  unint64_t v69;
  __int32 *v70;
  __int32 v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t **v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t **v79;
  uint64_t v80;
  const char *v81;
  int v82;
  const char *v83;
  const char *v84;
  uint64_t v85;
  char v86;
  uint64_t v87;
  std::vector<int>::pointer begin;
  uint64_t v89;
  int *v90;
  int v91;
  uint64_t v92;
  uint64_t ElementTypeOrSelf;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  const char *v98;
  int v99;
  const char *v100;
  const char *v101;
  uint64_t v102;
  mlir::GenericProgramPoint *v103;
  mlir::GenericProgramPoint *v104;
  __int128 *v105;
  __int128 *v106;
  __int128 *v107;
  const char *v108;
  int v109;
  const char *v110;
  const char *v111;
  std::runtime_error *exception;
  int v113;
  __int8 *v114;
  uint64_t v115;
  mlir::OpBuilder *v116;
  std::vector<int>::value_type __x[2];
  __int128 v118;
  int v119;
  mlir::GenericProgramPoint *v120;
  uint64_t v121;
  uint64_t *v122;
  uint64_t **v123;
  uint64_t v124;
  int32x4_t *v125;
  __int8 *v126;
  __int8 *v127;
  uint64_t **v128;
  uint64_t v129;
  char **v130;
  char *v131[2];
  uint64_t v132;
  uint64_t ArgValue;
  std::vector<int> __src;
  _BYTE __s2[24];
  _QWORD *v136;
  uint64_t v137;
  _QWORD v138[3];

  v138[1] = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v132 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "block_shape");
  v6 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 160))(a2);
  v131[0] = 0;
  v131[1] = 0;
  v130 = v131;
  v8 = v6 + 1;
  v7 = *v6;
  if (*v6 == (const void **)(v6 + 1))
    goto LABEL_43;
  do
  {
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v130, (uint64_t *)v131, v7 + 4, (uint64_t)(v7 + 4));
    v9 = (const void **)v7[1];
    if (v9)
    {
      do
      {
        v10 = (const void ***)v9;
        v9 = (const void **)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        v10 = (const void ***)v7[2];
        v11 = *v10 == v7;
        v7 = (const void **)v10;
      }
      while (!v11);
    }
    v7 = (const void **)v10;
  }
  while (v10 != v8);
  v115 = LocationForOp;
  v116 = (mlir::OpBuilder *)(a3 + 13);
  v12 = v131[0];
  __s2[23] = 8;
  strcpy(__s2, "paddings");
  if (!v131[0])
    goto LABEL_43;
  v13 = v131;
  do
  {
    v14 = v12;
    v15 = v13;
    v17 = v12 + 32;
    v16 = (char *)*((_QWORD *)v12 + 4);
    v18 = v14[55];
    v19 = (char)v18;
    if ((v18 & 0x80u) != 0)
      v18 = *((_QWORD *)v14 + 5);
    if (v19 >= 0)
      v20 = v17;
    else
      v20 = v16;
    if (v18 >= 8)
      v21 = 8;
    else
      v21 = v18;
    v22 = v18 < 8;
    v23 = memcmp(v20, __s2, v21);
    if (v23)
      v22 = v23 < 0;
    v24 = (char **)(v14 + 8);
    if (v22)
    {
      v13 = v15;
    }
    else
    {
      v24 = (char **)v14;
      v13 = (char **)v14;
    }
    v12 = *v24;
  }
  while (v12);
  if (v13 == v131)
    goto LABEL_43;
  v25 = (char *)(v15 + 4);
  if (v22)
    v26 = v15;
  else
    v26 = v14;
  if (!v22)
    v25 = v17;
  v27 = *((unsigned __int8 *)v13 + 55);
  v28 = (char)v27;
  v30 = (char *)v26[4];
  v29 = v26[5];
  if ((v27 & 0x80u) != 0)
    v27 = v29;
  if (v28 >= 0)
    v31 = v25;
  else
    v31 = v30;
  if (v27 >= 8)
    v32 = 8;
  else
    v32 = v27;
  v33 = v27 > 8;
  v34 = memcmp(__s2, v31, v32);
  v35 = v34 < 0;
  if (!v34)
    v35 = v33;
  if (v35)
  {
LABEL_43:
    *(_QWORD *)__s2 = operator new(0x30uLL);
    *(_OWORD *)&__s2[8] = xmmword_181267470;
    strcpy(*(char **)__s2, "Could not find parameter with name 'paddings'.");
    v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  if (v22)
    v39 = v15;
  else
    v39 = v14;
  if (v39[8] - v39[7] != 16)
  {
    *(_QWORD *)__s2 = operator new(0x28uLL);
    *(_OWORD *)&__s2[8] = xmmword_181261450;
    strcpy(*(char **)__s2, "Unexpected argument size for 'paddings'");
    v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
    goto LABEL_44;
  }
  __s2[23] = 8;
  strcpy(__s2, "paddings");
  ParameterValue = MIL::IROperation::TryGetParameterValue();
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  (*(void (**)(uint64_t))(*(_QWORD *)ParameterValue + 40))(ParameterValue);
  Data = MIL::IRTensorValue::GetDataView<int>();
  v43 = v42;
  __s2[23] = 11;
  strcpy(__s2, "block_shape");
  v44 = MIL::IROperation::TryGetParameterValue();
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  (*(void (**)(uint64_t))(*(_QWORD *)v44 + 40))(v44);
  MIL::IRTensorValue::GetDataView<int>();
  v46 = v45;
  __s2[23] = 1;
  strcpy(__s2, "x");
  ParameterType = (MIL::IRValueType *)MIL::IROperation::GetParameterType();
  v48 = (MIL::IRTensorValueType *)MIL::IRValueType::AsTensorType(ParameterType);
  v49 = MIL::IRTensorValueType::Rank(v48);
  if ((__s2[23] & 0x80000000) != 0)
    operator delete(*(void **)__s2);
  if (v43 != 2 * (_DWORD)v46)
  {
    *(_QWORD *)__s2 = operator new(0x38uLL);
    *(_OWORD *)&__s2[8] = xmmword_181286A70;
    strcpy(*(char **)__s2, "Unexpected length for 'paddings' or 'block_shape'");
    v36 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __s2);
LABEL_44:
    v37 = v36;
    if ((__s2[23] & 0x80000000) != 0)
      operator delete(*(void **)__s2);
    goto LABEL_46;
  }
  *(_QWORD *)__s2 = (int)v46;
  v136 = v138;
  v137 = 0x100000000;
  llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)&v136, __s2, &__s2[8]);
  v50 = (uint64_t)v136;
  v51 = v137;
  *(_QWORD *)__s2 = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  Context = mlir::Attribute::getContext((mlir::Attribute *)__s2);
  v53 = mlir::IntegerType::get(Context, 0x20u, 1u);
  v54 = (uint64_t **)mlir::RankedTensorType::get(v50, v51, v53, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54))
  {
    v56 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v57 = 566;
    v58 = "Casting.h";
    v59 = "cast";
LABEL_133:
    __assert_rtn(v59, v58, v57, v56);
  }
  if (v54)
  {
    InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v54);
    if (!InterfaceFor)
    {
      v56 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v57 = 98;
      v58 = "InterfaceSupport.h";
      v59 = "Interface";
      goto LABEL_133;
    }
  }
  else
  {
    InterfaceFor = 0;
  }
  v128 = v54;
  v129 = InterfaceFor;
  v125 = 0;
  v126 = 0;
  v127 = 0;
  v113 = 2 * v46;
  if (v46 << 32)
  {
    if (v46 << 32 < 0)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v60 = (int32x4_t *)operator new((4 * v46) & 0x3FFFFFFFFLL);
    v125 = v60;
    v127 = &v60->i8[4 * (int)v46];
    bzero(v60, (4 * v46) & 0x3FFFFFFFFLL);
    v114 = &v60->i8[(4 * v46) & 0x3FFFFFFFFLL];
    v126 = v114;
  }
  else
  {
    v114 = 0;
    v60 = 0;
  }
  if ((_DWORD)v46)
  {
    if (v46 < 8uLL)
    {
      v61 = 0;
LABEL_75:
      v69 = v46 - v61;
      v70 = &v60->i32[v61];
      v71 = v61 - v46;
      do
      {
        *v70++ = v71++;
        --v69;
      }
      while (v69);
      goto LABEL_77;
    }
    v61 = v46 - (unint64_t)(v46 & 7);
    v62 = vdupq_n_s32(v46);
    v63 = (int32x4_t)xmmword_181235170;
    v64 = v60 + 1;
    v65.i64[0] = 0x400000004;
    v65.i64[1] = 0x400000004;
    v66.i64[0] = 0x800000008;
    v66.i64[1] = 0x800000008;
    v67 = v61;
    do
    {
      v68 = vsubq_s32(v63, v62);
      v64[-1] = v68;
      *v64 = vaddq_s32(v68, v65);
      v63 = vaddq_s32(v63, v66);
      v64 += 2;
      v67 -= 8;
    }
    while (v67);
    if ((v46 & 7) != 0)
      goto LABEL_75;
  }
LABEL_77:
  *(_QWORD *)__s2 = *(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8;
  v72 = mlir::Attribute::getContext((mlir::Attribute *)__s2);
  v73 = mlir::IntegerType::get(v72, 0x20u, 1u);
  v74 = (uint64_t **)mlir::RankedTensorType::get(0, 0, v73, 0);
  __src.__begin_ = (std::vector<int>::pointer)v49;
  __src.__end_ = (std::vector<int>::pointer)2;
  *(_QWORD *)__s2 = &__s2[16];
  *(_QWORD *)&__s2[8] = 0x200000000;
  llvm::SmallVectorImpl<long long>::append<long long const*,void>((uint64_t)__s2, &__src, &__src.__end_cap_);
  v75 = *(_QWORD *)__s2;
  v76 = *(unsigned int *)&__s2[8];
  __src.__begin_ = (std::vector<int>::pointer)(*(_QWORD *)(ArgValue + 8) & 0xFFFFFFFFFFFFFFF8);
  v77 = mlir::Attribute::getContext((mlir::Attribute *)&__src);
  v78 = mlir::IntegerType::get(v77, 0x20u, 1u);
  v79 = (uint64_t **)mlir::RankedTensorType::get(v75, v76, v78, 0);
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v79))
  {
    v81 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v82 = 566;
    v83 = "Casting.h";
    v84 = "cast";
LABEL_135:
    __assert_rtn(v84, v83, v82, v81);
  }
  if (v79)
  {
    v80 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v79);
    if (!v80)
    {
      v81 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v82 = 98;
      v83 = "InterfaceSupport.h";
      v84 = "Interface";
      goto LABEL_135;
    }
  }
  else
  {
    v80 = 0;
  }
  v123 = v79;
  v124 = v80;
  memset(&__src, 0, sizeof(__src));
  __x[0] = 0;
  if (v49)
    std::vector<int>::__append(&__src, 2 * v49, __x);
  if ((int)v46 >= 1)
  {
    v85 = 0;
    v86 = 0;
    if (v49 <= 0)
      v87 = 0;
    else
      v87 = 2 * (v49 - (int)v46);
    begin = __src.__begin_;
    if (v113 <= 1)
      v89 = 1;
    else
      v89 = v113;
    v90 = &__src.__begin_[v87];
    do
    {
      while (1)
      {
        if (v43 == v85)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::runtime_error::runtime_error(exception, "index out of bounds");
          exception->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E0DE5008] + 16);
          __cxa_throw(exception, (struct type_info *)off_1E0DF5DB8, MEMORY[0x1E0DE42B0]);
        }
        v91 = *(_DWORD *)(Data + 4 * v85);
        if (v91 <= 0)
          break;
        v90[v85] = v91;
        v86 = 1;
        v11 = v89 - 1 == v85++;
        if (v11)
          goto LABEL_100;
      }
      ++v85;
    }
    while (v89 != v85);
    if ((v86 & 1) == 0)
      goto LABEL_103;
LABEL_100:
    v122 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v123, v124, begin, (char *)__src.__end_ - (char *)begin, 4, 1, 1);
    v92 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>(v116, v115, (uint64_t *)&v123, &v122);
    if (!*(_DWORD *)(v92 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v121 = v92 - 16;
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    *(_QWORD *)__x = 1;
    v94 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)__x, 1, ElementTypeOrSelf, 0);
    *(_QWORD *)__x = mlir::mps::getConstantAttr<int>(v94, 0);
    v120 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v116, v115, (uint64_t **)__x);
    __x[0] = 0;
    v95 = mlir::OpBuilder::create<mlir::mps::PadOp,mlir::Value &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::PaddingMode>((mlir::MLIRContext **)v116, v115, &ArgValue, &v121, (uint64_t)&v120, (unsigned int *)__x);
    if (!*(_DWORD *)(v95 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    ArgValue = v95 - 16;
  }
LABEL_103:
  v122 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v128, v129, v60, v114 - (__int8 *)v60, 4, 1, 1);
  v96 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ShapedType &,mlir::DenseElementsAttr &>(v116, v115, (uint64_t *)&v128, &v122);
  if (!*(_DWORD *)(v96 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  v121 = v96 - 16;
  if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74))
  {
    v98 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v99 = 566;
    v100 = "Casting.h";
    v101 = "cast";
LABEL_138:
    __assert_rtn(v101, v100, v99, v98);
  }
  if (v74)
  {
    v97 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v74);
    if (!v97)
    {
      v98 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
      v99 = 98;
      v100 = "InterfaceSupport.h";
      v101 = "Interface";
      goto LABEL_138;
    }
  }
  else
  {
    v97 = 0;
  }
  v119 = 0;
  v102 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v97, &v119, 4, 4, 1, 1);
  if (!mlir::DenseIntElementsAttr::classof(v102))
  {
    v108 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v109 = 566;
    v110 = "Casting.h";
    v111 = "cast";
    goto LABEL_141;
  }
  *(_QWORD *)__x = v102;
  v103 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v116, v115, (uint64_t **)__x);
  if (!*((_DWORD *)v103 + 9))
  {
    v108 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
    v109 = 984;
    v110 = "Operation.h";
    v111 = "getOpResultImpl";
LABEL_141:
    __assert_rtn(v111, v110, v109, v108);
  }
  v120 = (mlir::GenericProgramPoint *)((char *)v103 - 16);
  LOBYTE(__x[0]) = 0;
  v104 = mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)v116, v115, &ArgValue, &v121, (uint64_t *)&v120, &v132, (unsigned __int8 *)__x);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    (*(void (**)(std::vector<int>::value_type *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__x, a2);
    if (!*((_DWORD *)v104 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    MILToMLIRRewriter::setValue((uint64_t)a3, *(__int128 **)__x, (uint64_t)v104 - 16);
    v105 = *(__int128 **)__x;
    if (*(_QWORD *)__x)
    {
      v106 = (__int128 *)v118;
      v107 = *(__int128 **)__x;
      if ((_QWORD)v118 != *(_QWORD *)__x)
      {
        do
        {
          if (*((char *)v106 - 1) < 0)
            operator delete(*((void **)v106 - 3));
          v106 = (__int128 *)((char *)v106 - 24);
        }
        while (v106 != v105);
        v107 = *(__int128 **)__x;
      }
      *(_QWORD *)&v118 = v105;
      operator delete(v107);
    }
    v37 = 1;
  }
  else
  {
    *(_QWORD *)__x = operator new(0x40uLL);
    v118 = xmmword_18125E6C0;
    strcpy(*(char **)__x, "The number of outputs does not match the number of results.");
    v37 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__x);
    if (SHIBYTE(v118) < 0)
      operator delete(*(void **)__x);
  }
  if (__src.__begin_)
  {
    __src.__end_ = __src.__begin_;
    operator delete(__src.__begin_);
  }
  if (*(_BYTE **)__s2 != &__s2[16])
    free(*(void **)__s2);
  if (v60)
    operator delete(v60);
  if (v136 != v138)
    free(v136);
LABEL_46:
  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v130, v131[0]);
  return v37;
}

void sub_180E68F20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,char *a34)
{
  void *v34;
  uint64_t v35;
  void *v36;
  void *v38;
  void *v39;

  v38 = *(void **)(v35 - 176);
  if (v38)
  {
    *(_QWORD *)(v35 - 168) = v38;
    operator delete(v38);
    v36 = *(void **)(v35 - 152);
    if (v36 != a11)
    {
LABEL_7:
      free(v36);
      if (!v34)
        goto LABEL_9;
      goto LABEL_8;
    }
  }
  else
  {
    v36 = *(void **)(v35 - 152);
    if (v36 != a11)
      goto LABEL_7;
  }
  if (!v34)
  {
LABEL_9:
    v39 = *(void **)(v35 - 120);
    if (v39 != a12)
      free(v39);
    std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&a33, a34);
    _Unwind_Resume(a1);
  }
LABEL_8:
  operator delete(v34);
  goto LABEL_9;
}

uint64_t mlir::OpBuilder::create<mlir::mps::PadOp,mlir::Value &,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::PaddingMode>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _BYTE v27[40];
  _QWORD v28[39];

  v28[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad", (const unsigned __int8 *)7, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.pad";
    v25[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v28, a2, v13);
  if (!*(_DWORD *)(*(_QWORD *)a5 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::PadOp::build(a1, (uint64_t)v28, *a3, *a4, *(_QWORD *)a5 - 16, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v28);
  if (!v15)
  {
    v18 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v19 = 662;
    v20 = "Casting.h";
    v21 = "dyn_cast";
    goto LABEL_10;
  }
  v16 = llvm::DefaultDoCastIfPossible<mlir::mps::PadOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PadOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
  if (!v16)
  {
    v18 = "result && \"builder didn't return the right type\"";
    v19 = 497;
    v20 = "Builders.h";
    v21 = "create";
LABEL_10:
    __assert_rtn(v21, v20, v19, v18);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v28);
  return v16;
}

void sub_180E692CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E692E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  int *value;
  std::vector<int>::pointer end;
  int *v8;
  std::vector<int>::pointer begin;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  std::vector<int>::size_type v16;
  std::vector<int>::size_type v17;
  float32x4_t v18;
  float32x4_t *v19;
  uint64_t v20;
  int *v21;
  int *v22;
  std::vector<int>::size_type v23;
  int *v24;
  std::vector<int>::size_type v25;
  float32x4_t v26;
  float32x4_t *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD *v32;
  __int128 *v33;
  uint64_t v34;
  __int128 v35;
  int v36;

  end = this->__end_;
  value = this->__end_cap_.__value_;
  v8 = end;
  if (__n <= value - end)
  {
    if (__n)
    {
      v16 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 < 0xF || end < __x + 1 && &end[__n] > __x)
        goto LABEL_43;
      v17 = v16 + 1;
      v8 = &end[v17 & 0x7FFFFFFFFFFFFFF8];
      v18 = vld1q_dup_f32((const float *)__x);
      v19 = (float32x4_t *)(end + 4);
      v20 = v17 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v19[-1] = v18;
        *v19 = v18;
        v19 += 2;
        v20 -= 8;
      }
      while (v20);
      if (v17 != (v17 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_43:
        do
          *v8++ = *__x;
        while (v8 != &end[__n]);
      }
      v8 = &end[__n];
    }
    this->__end_ = v8;
  }
  else
  {
    begin = this->__begin_;
    v10 = (char *)end - (char *)this->__begin_;
    v11 = v10 >> 2;
    v12 = (v10 >> 2) + __n;
    if (v12 >> 62)
      std::vector<int>::__throw_length_error[abi:ne180100]();
    v13 = (char *)value - (char *)begin;
    if (v13 >> 1 > v12)
      v12 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v14 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    if (v14)
    {
      if (v14 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v15 = operator new(4 * v14);
    }
    else
    {
      v15 = 0;
    }
    v21 = (int *)&v15[4 * v11];
    v22 = &v21[__n];
    v23 = (__n - 1) & 0x3FFFFFFFFFFFFFFFLL;
    v24 = v21;
    if (v23 < 0x13)
      goto LABEL_44;
    if (v21 < __x + 1)
    {
      v24 = (int *)&v15[4 * v11];
      if (&v15[4 * __n + v10] > (_BYTE *)__x)
        goto LABEL_44;
    }
    v25 = v23 + 1;
    v24 = &v21[v25 & 0x7FFFFFFFFFFFFFF8];
    v26 = vld1q_dup_f32((const float *)__x);
    v27 = (float32x4_t *)&v15[4 * v11 + 16];
    v28 = v25 & 0x7FFFFFFFFFFFFFF8;
    do
    {
      v27[-1] = v26;
      *v27 = v26;
      v27 += 2;
      v28 -= 8;
    }
    while (v28);
    if (v25 != (v25 & 0x7FFFFFFFFFFFFFF8))
    {
LABEL_44:
      do
        *v24++ = *__x;
      while (v24 != v22);
    }
    if (end != begin)
    {
      v29 = (char *)end - (char *)begin - 4;
      if (v29 < 0x2C)
        goto LABEL_45;
      if ((unint64_t)((char *)end - &v15[v10]) < 0x20)
        goto LABEL_45;
      v30 = (v29 >> 2) + 1;
      v31 = 4 * (v30 & 0x7FFFFFFFFFFFFFF8);
      v8 = &end[v31 / 0xFFFFFFFFFFFFFFFCLL];
      v21 = (int *)((char *)v21 - v31);
      v32 = &v15[4 * v11 - 16];
      v33 = (__int128 *)(end - 4);
      v34 = v30 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v35 = *v33;
        *(v32 - 1) = *(v33 - 1);
        *v32 = v35;
        v32 -= 2;
        v33 -= 2;
        v34 -= 8;
      }
      while (v34);
      if (v30 != (v30 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_45:
        do
        {
          v36 = *--v8;
          *--v21 = v36;
        }
        while (v8 != begin);
      }
    }
    this->__begin_ = v21;
    this->__end_ = v22;
    this->__end_cap_.__value_ = (int *)&v15[4 * v14];
    if (begin)
      operator delete(begin);
  }
}

void `anonymous namespace'::SqueezePattern::~SqueezePattern(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::SqueezePattern::matchAndRewrite(_anonymous_namespace_::SqueezePattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t OptionalArgValue;
  uint64_t v7;
  uint64_t *Context;
  uint64_t v10;
  char v11;
  mlir::GenericProgramPoint *v12;
  __int128 *v13;
  char *v14;
  uint64_t *v15;
  void **v16;
  void **v17;
  void *v18;
  const char *v19;
  int v20;
  const char *v21;
  const char *v22;
  uint64_t ArgValue;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  __int128 *v30[5];
  void *__p;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "axes");
  v24 = OptionalArgValue;
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    if (OptionalArgValue)
    {
      v7 = mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v24);
      if (!*(_DWORD *)(v7 + 36))
        __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
LABEL_12:
      (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
      v13 = (__int128 *)__p;
      v14 = (char *)operator new(8uLL);
      *(_QWORD *)v14 = v7 - 16;
      v30[0] = v13;
      v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v13, (uint64_t)&std::piecewise_construct, v30);
      std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v15 + 5, v14, v14 + 8, 1uLL);
      operator delete(v14);
      v16 = (void **)__p;
      if (__p)
      {
        v17 = (void **)v32;
        v18 = __p;
        if ((void *)v32 != __p)
        {
          do
          {
            if (*((char *)v17 - 1) < 0)
              operator delete(*(v17 - 3));
            v17 -= 3;
          }
          while (v17 != v16);
          v18 = __p;
        }
        *(_QWORD *)&v32 = v16;
        operator delete(v18);
      }
      return 1;
    }
    v25 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
    v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, Context);
    if (!v11)
    {
      v29 = 1283;
      v28[2] = (uint64_t)"mps.squeeze";
      v28[3] = 11;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v27 = 259;
      llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
      llvm::report_fatal_error((llvm::Twine *)v30, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    mlir::mps::SqueezeOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, (uint64_t)&ArgValue, 1, 0, 0);
    v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v12)
    {
      v7 = llvm::DefaultDoCastIfPossible<mlir::mps::SqueezeOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SqueezeOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v7)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (!*(_DWORD *)(v7 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        goto LABEL_12;
      }
      v19 = "result && \"builder didn't return the right type\"";
      v20 = 497;
      v21 = "Builders.h";
      v22 = "create";
    }
    else
    {
      v19 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v20 = 662;
      v21 = "Casting.h";
      v22 = "dyn_cast";
    }
    __assert_rtn(v22, v21, v20, v19);
  }
  __p = operator new(0x40uLL);
  v32 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v32) < 0)
    operator delete(__p);
  return 0;
}

void sub_180E69954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void sub_180E69968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  std::vector<std::string>::~vector[abi:ne180100](&a28);
  _Unwind_Resume(a1);
}

void sub_180E6997C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter0::~GeneratedRewriter0(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter0::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter0 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ElementTypeOrSelf;
  uint64_t v8;
  uint64_t v9;
  mlir::GenericProgramPoint *v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  __int128 *v16;
  char *v17;
  uint64_t *v18;
  void **v19;
  void **v20;
  void *v21;
  uint64_t v22;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  mlir::GenericProgramPoint *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  __int16 v34;
  uint64_t v35[4];
  __int16 v36;
  __int128 *v37[5];
  void *__p;
  __int128 v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v30 = ArgValue;
  v29 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  v31 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v28 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v29, (uint64_t *)&__p);
    v8 = mlir::OpBuilder::create<mlir::mps::LeakyReluOp,mlir::Value &,mlir::mps::CastOp &>(a3 + 13, LocationForOp, &v30, (uint64_t)&v28);
    v9 = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(v9);
    v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v31, (uint64_t *)&__p);
    v32 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v32);
    v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, Context);
    if (!v13)
    {
      v36 = 1283;
      v35[2] = (uint64_t)"mps.minimum";
      v35[3] = 11;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v34 = 259;
      llvm::operator+(v35, (uint64_t *)&v33, (uint64_t)v37);
      llvm::report_fatal_error((llvm::Twine *)v37, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*(_DWORD *)(v8 + 36) || !*((_DWORD *)v10 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, v8 - 16, (uint64_t)v10 - 16);
    v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v14)
    {
      v15 = llvm::DefaultDoCastIfPossible<mlir::mps::MinimumOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MinimumOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
      if (v15)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v15 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v16 = (__int128 *)__p;
        v17 = (char *)operator new(8uLL);
        *(_QWORD *)v17 = v15 - 16;
        v37[0] = v16;
        v18 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v16, (uint64_t)&std::piecewise_construct, v37);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v18 + 5, v17, v17 + 8, 1uLL);
        operator delete(v17);
        v19 = (void **)__p;
        if (__p)
        {
          v20 = (void **)v39;
          v21 = __p;
          if ((void *)v39 != __p)
          {
            do
            {
              if (*((char *)v20 - 1) < 0)
                operator delete(*(v20 - 3));
              v20 -= 3;
            }
            while (v20 != v19);
            v21 = __p;
          }
          *(_QWORD *)&v39 = v19;
          operator delete(v21);
        }
        return 1;
      }
      v24 = "result && \"builder didn't return the right type\"";
      v25 = 497;
      v26 = "Builders.h";
      v27 = "create";
    }
    else
    {
      v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v25 = 662;
      v26 = "Casting.h";
      v27 = "dyn_cast";
    }
    __assert_rtn(v27, v26, v25, v24);
  }
  __p = operator new(0x40uLL);
  v39 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v22 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v39) < 0)
    operator delete(__p);
  return v22;
}

void sub_180E69E40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E69E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

void sub_180E69EAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::LeakyReluOp,mlir::Value &,mlir::mps::CastOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.leaky_relu", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.leaky_relu";
    v21[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::LeakyReluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LeakyReluOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E6A068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6A080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LeakyReluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LeakyReluOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x6B61656C2E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x756C65725F796B61)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.leaky_relu";
      v8[3] = 14;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LeakyReluOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter1::~GeneratedRewriter1(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter1::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter1 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v8;
  uint64_t *Context;
  uint64_t v10;
  char v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  __int16 v29;
  uint64_t v30[4];
  __int16 v31;
  __int128 *v32[5];
  void *__p;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v26 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v8 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v26, (uint64_t *)&__p);
    v27 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
    v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.elu", (const unsigned __int8 *)7, Context);
    if (!v11)
    {
      v31 = 1283;
      v30[2] = (uint64_t)"mps.elu";
      v30[3] = 7;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v29 = 259;
      llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v32);
      llvm::report_fatal_error((llvm::Twine *)v32, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*((_DWORD *)v8 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, ArgValue, (uint64_t)v8 - 16);
    v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v12)
    {
      v13 = llvm::DefaultDoCastIfPossible<mlir::mps::EluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::EluOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v13 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v14 = (__int128 *)__p;
        v15 = (char *)operator new(8uLL);
        *(_QWORD *)v15 = v13 - 16;
        v32[0] = v14;
        v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v32);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        v17 = (void **)__p;
        if (__p)
        {
          v18 = (void **)v34;
          v19 = __p;
          if ((void *)v34 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0)
                operator delete(*(v18 - 3));
              v18 -= 3;
            }
            while (v18 != v17);
            v19 = __p;
          }
          *(_QWORD *)&v34 = v17;
          operator delete(v19);
        }
        return 1;
      }
      v22 = "result && \"builder didn't return the right type\"";
      v23 = 497;
      v24 = "Builders.h";
      v25 = "create";
    }
    else
    {
      v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v23 = 662;
      v24 = "Casting.h";
      v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  v34 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v34) < 0)
    operator delete(__p);
  return v20;
}

void sub_180E6A58C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6A5F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::EluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::EluOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970038062)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.elu";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::EluOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter2::~GeneratedRewriter2(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter2::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter2 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ErfOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E6A980(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ErfOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.erf", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.erf";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ErfOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ErfOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E6AB30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6AB48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ErfOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ErfOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1718773038)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.erf";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ErfOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter3::~GeneratedRewriter3(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter3::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter3 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ElementTypeOrSelf;
  uint64_t v8;
  __int128 *v9;
  char *v10;
  uint64_t *v11;
  void **v12;
  void **v13;
  void *v14;
  uint64_t v15;
  mlir::GenericProgramPoint *v17;
  void *__p;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v21 = ArgValue;
  v20 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v17 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v20, (uint64_t *)&__p);
    v8 = mlir::OpBuilder::create<mlir::mps::LeakyReluOp,mlir::Value &,mlir::mps::CastOp &>(a3 + 13, LocationForOp, &v21, (uint64_t)&v17);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v8 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v9 = (__int128 *)__p;
    v10 = (char *)operator new(8uLL);
    *(_QWORD *)v10 = v8 - 16;
    v22 = v9;
    v11 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v9, (uint64_t)&std::piecewise_construct, &v22);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v11 + 5, v10, v10 + 8, 1uLL);
    operator delete(v10);
    v12 = (void **)__p;
    if (__p)
    {
      v13 = (void **)v19;
      v14 = __p;
      if ((void *)v19 != __p)
      {
        do
        {
          if (*((char *)v13 - 1) < 0)
            operator delete(*(v13 - 3));
          v13 -= 3;
        }
        while (v13 != v12);
        v14 = __p;
      }
      *(_QWORD *)&v19 = v12;
      operator delete(v14);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v19 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    v15 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    if (SHIBYTE(v19) < 0)
      operator delete(__p);
  }
  return v15;
}

void sub_180E6AEF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter4::~GeneratedRewriter4(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter4::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter4 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ElementTypeOrSelf;
  uint64_t v8;
  uint64_t v9;
  mlir::GenericProgramPoint *v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  __int128 *v16;
  char *v17;
  uint64_t *v18;
  void **v19;
  void **v20;
  void *v21;
  uint64_t v22;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  mlir::GenericProgramPoint *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  __int16 v34;
  uint64_t v35[4];
  __int16 v36;
  __int128 *v37[5];
  void *__p;
  __int128 v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v30 = ArgValue;
  v29 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  v31 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v28 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v29, (uint64_t *)&__p);
    v8 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::CastOp &>(a3 + 13, LocationForOp, &v30, (uint64_t)&v28);
    v9 = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(v9);
    v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v31, (uint64_t *)&__p);
    v32 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v32);
    v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
    if (!v13)
    {
      v36 = 1283;
      v35[2] = (uint64_t)"mps.add";
      v35[3] = 7;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v34 = 259;
      llvm::operator+(v35, (uint64_t *)&v33, (uint64_t)v37);
      llvm::report_fatal_error((llvm::Twine *)v37, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*(_DWORD *)(v8 + 36) || !*((_DWORD *)v10 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, v8 - 16, (uint64_t)v10 - 16);
    v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v14)
    {
      v15 = llvm::DefaultDoCastIfPossible<mlir::mps::AddOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AddOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
      if (v15)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v15 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v16 = (__int128 *)__p;
        v17 = (char *)operator new(8uLL);
        *(_QWORD *)v17 = v15 - 16;
        v37[0] = v16;
        v18 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v16, (uint64_t)&std::piecewise_construct, v37);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v18 + 5, v17, v17 + 8, 1uLL);
        operator delete(v17);
        v19 = (void **)__p;
        if (__p)
        {
          v20 = (void **)v39;
          v21 = __p;
          if ((void *)v39 != __p)
          {
            do
            {
              if (*((char *)v20 - 1) < 0)
                operator delete(*(v20 - 3));
              v20 -= 3;
            }
            while (v20 != v19);
            v21 = __p;
          }
          *(_QWORD *)&v39 = v19;
          operator delete(v21);
        }
        return 1;
      }
      v24 = "result && \"builder didn't return the right type\"";
      v25 = 497;
      v26 = "Builders.h";
      v27 = "create";
    }
    else
    {
      v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v25 = 662;
      v26 = "Casting.h";
      v27 = "dyn_cast";
    }
    __assert_rtn(v27, v26, v25, v24);
  }
  __p = operator new(0x40uLL);
  v39 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v22 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v39) < 0)
    operator delete(__p);
  return v22;
}

void sub_180E6B3A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6B3FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

void sub_180E6B410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::CastOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(_QWORD *)a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E6B5CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6B5E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter5::~GeneratedRewriter5(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter5::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter5 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E6B88C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.relu";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ReluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReluOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E6BA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6BA54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReluOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x756C65722E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.relu";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter6::~GeneratedRewriter6(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter6::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter6 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t *Context;
  uint64_t v8;
  char v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v11;
  __int128 *v12;
  char *v13;
  uint64_t *v14;
  void **v15;
  void **v16;
  void *v17;
  uint64_t v18;
  const char *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  __int128 *v29[5];
  void *__p;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v24 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
    v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu6", (const unsigned __int8 *)9, Context);
    if (!v9)
    {
      v28 = 1283;
      v27[2] = (uint64_t)"mps.relu6";
      v27[3] = 9;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v26 = 259;
      llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
      llvm::report_fatal_error((llvm::Twine *)v29, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    mlir::mps::ACosOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue);
    v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v10)
    {
      v11 = llvm::DefaultDoCastIfPossible<mlir::mps::Relu6Op,mlir::Operation *,llvm::CastInfo<mlir::mps::Relu6Op,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v10);
      if (v11)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v11 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v12 = (__int128 *)__p;
        v13 = (char *)operator new(8uLL);
        *(_QWORD *)v13 = v11 - 16;
        v29[0] = v12;
        v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v12, (uint64_t)&std::piecewise_construct, v29);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v14 + 5, v13, v13 + 8, 1uLL);
        operator delete(v13);
        v15 = (void **)__p;
        if (__p)
        {
          v16 = (void **)v31;
          v17 = __p;
          if ((void *)v31 != __p)
          {
            do
            {
              if (*((char *)v16 - 1) < 0)
                operator delete(*(v16 - 3));
              v16 -= 3;
            }
            while (v16 != v15);
            v17 = __p;
          }
          *(_QWORD *)&v31 = v15;
          operator delete(v17);
        }
        return 1;
      }
      v20 = "result && \"builder didn't return the right type\"";
      v21 = 497;
      v22 = "Builders.h";
      v23 = "create";
    }
    else
    {
      v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v21 = 662;
      v22 = "Casting.h";
      v23 = "dyn_cast";
    }
    __assert_rtn(v23, v22, v21, v20);
  }
  __p = operator new(0x40uLL);
  v31 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v18 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v31) < 0)
    operator delete(__p);
  return v18;
}

void sub_180E6BED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6BEE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6BF3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Relu6Op,mlir::Operation *,llvm::CastInfo<mlir::mps::Relu6Op,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x756C65722E73706DLL && *(_BYTE *)(AttrData + 8) == 54)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.relu6";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Relu6Op,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter7::~GeneratedRewriter7(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter7::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter7 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ElementTypeOrSelf;
  uint64_t v8;
  uint64_t v9;
  mlir::GenericProgramPoint *v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  __int128 *v16;
  char *v17;
  uint64_t *v18;
  void **v19;
  void **v20;
  void *v21;
  uint64_t v22;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  __int16 v35;
  uint64_t v36[4];
  __int16 v37;
  __int128 *v38[5];
  void *__p;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v31 = ArgValue;
  v30 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  v32 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v29 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v32, (uint64_t *)&__p);
    v28 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::CastOp &>(a3 + 13, LocationForOp, &v31, (uint64_t)&v29);
    v8 = mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::mps::MultiplyOp &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, (uint64_t)&v28);
    v9 = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(v9);
    v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v30, (uint64_t *)&__p);
    v33 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v33);
    v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
    if (!v13)
    {
      v37 = 1283;
      v36[2] = (uint64_t)"mps.multiply";
      v36[3] = 12;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v35 = 259;
      llvm::operator+(v36, (uint64_t *)&v34, (uint64_t)v38);
      llvm::report_fatal_error((llvm::Twine *)v38, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*(_DWORD *)(v8 + 36) || !*((_DWORD *)v10 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, v8 - 16, (uint64_t)v10 - 16);
    v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v14)
    {
      v15 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
      if (v15)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v15 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v16 = (__int128 *)__p;
        v17 = (char *)operator new(8uLL);
        *(_QWORD *)v17 = v15 - 16;
        v38[0] = v16;
        v18 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v16, (uint64_t)&std::piecewise_construct, v38);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v18 + 5, v17, v17 + 8, 1uLL);
        operator delete(v17);
        v19 = (void **)__p;
        if (__p)
        {
          v20 = (void **)v40;
          v21 = __p;
          if ((void *)v40 != __p)
          {
            do
            {
              if (*((char *)v20 - 1) < 0)
                operator delete(*(v20 - 3));
              v20 -= 3;
            }
            while (v20 != v19);
            v21 = __p;
          }
          *(_QWORD *)&v40 = v19;
          operator delete(v21);
        }
        return 1;
      }
      v24 = "result && \"builder didn't return the right type\"";
      v25 = 497;
      v26 = "Builders.h";
      v27 = "create";
    }
    else
    {
      v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v25 = 662;
      v26 = "Casting.h";
      v27 = "dyn_cast";
    }
    __assert_rtn(v27, v26, v25, v24);
  }
  __p = operator new(0x40uLL);
  v40 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v22 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v40) < 0)
    operator delete(__p);
  return v22;
}

void sub_180E6C4B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6C50C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

void sub_180E6C520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a30);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter8::~GeneratedRewriter8(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter8::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter8 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::SigmoidOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E6C7C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SigmoidOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sigmoid", (const unsigned __int8 *)0xB, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.sigmoid";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SigmoidOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SigmoidOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E6C978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6C990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter9::~GeneratedRewriter9(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter9::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter9 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v8;
  uint64_t v9;
  mlir::GenericProgramPoint *v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  void *v17;
  __int128 *v18;
  char *v19;
  uint64_t *v20;
  void **v21;
  void **v22;
  void *v23;
  uint64_t v24;
  const char *v26;
  int v27;
  const char *v28;
  const char *v29;
  _QWORD *AttrData;
  uint64_t v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36[4];
  __int16 v37;
  uint64_t v38[2];
  const char *v39;
  uint64_t v40;
  __int16 v41;
  __int128 *v42[5];
  void *__p;
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v33 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  v34 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v8 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v33, (uint64_t *)&__p);
    v9 = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(v9);
    v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v34, (uint64_t *)&__p);
    v35 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v35);
    v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sigmoid_hard", (const unsigned __int8 *)0x10, Context);
    if (!v13)
    {
      v41 = 1283;
      v39 = "mps.sigmoid_hard";
      v40 = 16;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v37 = 259;
      llvm::operator+(v38, v36, (uint64_t)v42);
      llvm::report_fatal_error((llvm::Twine *)v42, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*((_DWORD *)v8 + 9) || !*((_DWORD *)v10 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ClampOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue, (uint64_t)v8 - 16, (uint64_t)v10 - 16);
    v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    v15 = v14;
    if (v14)
    {
      v16 = *((_QWORD *)v14 + 6);
      v17 = *(void **)(v16 + 16);
      if (v17 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v42[0] = *(__int128 **)(v16 + 8);
        AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
        if (v31 == 16 && *AttrData == 0x6D6769732E73706DLL && AttrData[1] == 0x647261685F64696FLL)
        {
          v41 = 1283;
          v38[0] = (uint64_t)"classof on '";
          v39 = "mps.sigmoid_hard";
          v40 = 16;
          v36[0] = (uint64_t)"' failed due to the operation not being registered";
          v37 = 259;
          llvm::operator+(v38, v36, (uint64_t)v42);
          llvm::report_fatal_error((llvm::Twine *)v42, 1);
        }
      }
      else if (v17 == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidHardOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v15 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v18 = (__int128 *)__p;
        v19 = (char *)operator new(8uLL);
        *(_QWORD *)v19 = (char *)v15 - 16;
        v42[0] = v18;
        v20 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v18, (uint64_t)&std::piecewise_construct, v42);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v20 + 5, v19, v19 + 8, 1uLL);
        operator delete(v19);
        v21 = (void **)__p;
        if (__p)
        {
          v22 = (void **)v44;
          v23 = __p;
          if ((void *)v44 != __p)
          {
            do
            {
              if (*((char *)v22 - 1) < 0)
                operator delete(*(v22 - 3));
              v22 -= 3;
            }
            while (v22 != v21);
            v23 = __p;
          }
          *(_QWORD *)&v44 = v21;
          operator delete(v23);
        }
        return 1;
      }
      v26 = "result && \"builder didn't return the right type\"";
      v27 = 497;
      v28 = "Builders.h";
      v29 = "create";
    }
    else
    {
      v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v27 = 662;
      v28 = "Casting.h";
      v29 = "dyn_cast";
    }
    __assert_rtn(v29, v28, v27, v26);
  }
  __p = operator new(0x40uLL);
  v44 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v24 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v44) < 0)
    operator delete(__p);
  return v24;
}

void sub_180E6CEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  void *v28;

  operator delete(v28);
  std::vector<std::string>::~vector[abi:ne180100](&a28);
  _Unwind_Resume(a1);
}

void sub_180E6CED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6CF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void sub_180E6CF24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter10::~GeneratedRewriter10(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter10::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter10 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t *Context;
  uint64_t v8;
  char v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v11;
  __int128 *v12;
  char *v13;
  uint64_t *v14;
  void **v15;
  void **v16;
  void *v17;
  uint64_t v18;
  const char *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  __int128 *v29[5];
  void *__p;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v24 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
    v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.swish", (const unsigned __int8 *)9, Context);
    if (!v9)
    {
      v28 = 1283;
      v27[2] = (uint64_t)"mps.swish";
      v27[3] = 9;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v26 = 259;
      llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
      llvm::report_fatal_error((llvm::Twine *)v29, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    mlir::mps::ACosOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue);
    v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v10)
    {
      v11 = llvm::DefaultDoCastIfPossible<mlir::mps::SwishOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SwishOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v10);
      if (v11)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v11 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v12 = (__int128 *)__p;
        v13 = (char *)operator new(8uLL);
        *(_QWORD *)v13 = v11 - 16;
        v29[0] = v12;
        v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v12, (uint64_t)&std::piecewise_construct, v29);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v14 + 5, v13, v13 + 8, 1uLL);
        operator delete(v13);
        v15 = (void **)__p;
        if (__p)
        {
          v16 = (void **)v31;
          v17 = __p;
          if ((void *)v31 != __p)
          {
            do
            {
              if (*((char *)v16 - 1) < 0)
                operator delete(*(v16 - 3));
              v16 -= 3;
            }
            while (v16 != v15);
            v17 = __p;
          }
          *(_QWORD *)&v31 = v15;
          operator delete(v17);
        }
        return 1;
      }
      v20 = "result && \"builder didn't return the right type\"";
      v21 = 497;
      v22 = "Builders.h";
      v23 = "create";
    }
    else
    {
      v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v21 = 662;
      v22 = "Casting.h";
      v23 = "dyn_cast";
    }
    __assert_rtn(v23, v22, v21, v20);
  }
  __p = operator new(0x40uLL);
  v31 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v18 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v31) < 0)
    operator delete(__p);
  return v18;
}

void sub_180E6D2C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6D2DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6D334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SwishOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SwishOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x736977732E73706DLL && *(_BYTE *)(AttrData + 8) == 104)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.swish";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SwishOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter11::~GeneratedRewriter11(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter11::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter11 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  __int128 *v13;
  char *v14;
  uint64_t *v15;
  void **v16;
  void **v17;
  void *v18;
  uint64_t v19;
  const char *v21;
  int v22;
  const char *v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  __int128 *v30[5];
  void *__p;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v25 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
    v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softmax", (const unsigned __int8 *)0xB, Context);
    if (!v10)
    {
      v29 = 1283;
      v28[2] = (uint64_t)"mps.softmax";
      v28[3] = 11;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v27 = 259;
      llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
      llvm::report_fatal_error((llvm::Twine *)v30, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v9);
    mlir::mps::SoftmaxOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue, v7);
    v11 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v11)
    {
      v12 = llvm::DefaultDoCastIfPossible<mlir::mps::SoftmaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SoftmaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
      if (v12)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v12 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v13 = (__int128 *)__p;
        v14 = (char *)operator new(8uLL);
        *(_QWORD *)v14 = v12 - 16;
        v30[0] = v13;
        v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v13, (uint64_t)&std::piecewise_construct, v30);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v15 + 5, v14, v14 + 8, 1uLL);
        operator delete(v14);
        v16 = (void **)__p;
        if (__p)
        {
          v17 = (void **)v32;
          v18 = __p;
          if ((void *)v32 != __p)
          {
            do
            {
              if (*((char *)v17 - 1) < 0)
                operator delete(*(v17 - 3));
              v17 -= 3;
            }
            while (v17 != v16);
            v18 = __p;
          }
          *(_QWORD *)&v32 = v16;
          operator delete(v18);
        }
        return 1;
      }
      v21 = "result && \"builder didn't return the right type\"";
      v22 = 497;
      v23 = "Builders.h";
      v24 = "create";
    }
    else
    {
      v21 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v22 = 662;
      v23 = "Casting.h";
      v24 = "dyn_cast";
    }
    __assert_rtn(v24, v23, v22, v21);
  }
  __p = operator new(0x40uLL);
  v32 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v19 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v32) < 0)
    operator delete(__p);
  return v19;
}

void sub_180E6D7E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6D7F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6D84C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter12::~GeneratedRewriter12(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter12::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter12 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t *Context;
  uint64_t v8;
  char v9;
  mlir::GenericProgramPoint *v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  void *v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t AttrData;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30[4];
  __int16 v31;
  uint64_t v32[2];
  const char *v33;
  uint64_t v34;
  __int16 v35;
  __int128 *v36[5];
  void *__p;
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v29 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v29);
    v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus", (const unsigned __int8 *)0xC, Context);
    if (!v9)
    {
      v35 = 1283;
      v33 = "mps.softplus";
      v34 = 12;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v31 = 259;
      llvm::operator+(v32, v30, (uint64_t)v36);
      llvm::report_fatal_error((llvm::Twine *)v36, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    mlir::mps::ACosOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue);
    v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    v11 = v10;
    if (v10)
    {
      v12 = *((_QWORD *)v10 + 6);
      v13 = *(void **)(v12 + 16);
      if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v36[0] = *(__int128 **)(v12 + 8);
        AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v36);
        if (v27 == 12 && *(_QWORD *)AttrData == 0x74666F732E73706DLL && *(_DWORD *)(AttrData + 8) == 1937075312)
        {
          v35 = 1283;
          v32[0] = (uint64_t)"classof on '";
          v33 = "mps.softplus";
          v34 = 12;
          v30[0] = (uint64_t)"' failed due to the operation not being registered";
          v31 = 259;
          llvm::operator+(v32, v30, (uint64_t)v36);
          llvm::report_fatal_error((llvm::Twine *)v36, 1);
        }
      }
      else if (v13 == &mlir::detail::TypeIDResolver<mlir::mps::SoftplusOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v11 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v14 = (__int128 *)__p;
        v15 = (char *)operator new(8uLL);
        *(_QWORD *)v15 = (char *)v11 - 16;
        v36[0] = v14;
        v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v36);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        v17 = (void **)__p;
        if (__p)
        {
          v18 = (void **)v38;
          v19 = __p;
          if ((void *)v38 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0)
                operator delete(*(v18 - 3));
              v18 -= 3;
            }
            while (v18 != v17);
            v19 = __p;
          }
          *(_QWORD *)&v38 = v17;
          operator delete(v19);
        }
        return 1;
      }
      v22 = "result && \"builder didn't return the right type\"";
      v23 = 497;
      v24 = "Builders.h";
      v25 = "create";
    }
    else
    {
      v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v23 = 662;
      v24 = "Casting.h";
      v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  v38 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v38) < 0)
    operator delete(__p);
  return v20;
}

void sub_180E6DCA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  void *v26;

  operator delete(v26);
  std::vector<std::string>::~vector[abi:ne180100](&a26);
  _Unwind_Resume(a1);
}

void sub_180E6DCC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6DCD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6DD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter13::~GeneratedRewriter13(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter13::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter13 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v8;
  uint64_t v9;
  mlir::GenericProgramPoint *v10;
  uint64_t *Context;
  uint64_t v12;
  char v13;
  mlir::GenericProgramPoint *v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  void *v17;
  __int128 *v18;
  char *v19;
  uint64_t *v20;
  void **v21;
  void **v22;
  void *v23;
  uint64_t v24;
  const char *v26;
  int v27;
  const char *v28;
  const char *v29;
  _QWORD *AttrData;
  uint64_t v31;
  BOOL v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37[4];
  __int16 v38;
  uint64_t v39[2];
  const char *v40;
  uint64_t v41;
  __int16 v42;
  __int128 *v43[5];
  void *__p;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v34 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  v35 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v8 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v34, (uint64_t *)&__p);
    v9 = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(v9);
    v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v35, (uint64_t *)&__p);
    v36 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v36);
    v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus_parametric", (const unsigned __int8 *)0x17, Context);
    if (!v13)
    {
      v42 = 1283;
      v40 = "mps.softplus_parametric";
      v41 = 23;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v38 = 259;
      llvm::operator+(v39, v37, (uint64_t)v43);
      llvm::report_fatal_error((llvm::Twine *)v43, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*((_DWORD *)v8 + 9) || !*((_DWORD *)v10 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::BandPartOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue, (uint64_t)v8 - 16, (uint64_t)v10 - 16);
    v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    v15 = v14;
    if (v14)
    {
      v16 = *((_QWORD *)v14 + 6);
      v17 = *(void **)(v16 + 16);
      if (v17 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v43[0] = *(__int128 **)(v16 + 8);
        AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
        if (v31 == 23)
        {
          v32 = *AttrData == 0x74666F732E73706DLL && AttrData[1] == 0x7261705F73756C70;
          if (v32 && *(_QWORD *)((char *)AttrData + 15) == 0x63697274656D6172)
          {
            v42 = 1283;
            v39[0] = (uint64_t)"classof on '";
            v40 = "mps.softplus_parametric";
            v41 = 23;
            v37[0] = (uint64_t)"' failed due to the operation not being registered";
            v38 = 259;
            llvm::operator+(v39, v37, (uint64_t)v43);
            llvm::report_fatal_error((llvm::Twine *)v43, 1);
          }
        }
      }
      else if (v17 == &mlir::detail::TypeIDResolver<mlir::mps::SoftplusParametricOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v15 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v18 = (__int128 *)__p;
        v19 = (char *)operator new(8uLL);
        *(_QWORD *)v19 = (char *)v15 - 16;
        v43[0] = v18;
        v20 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v18, (uint64_t)&std::piecewise_construct, v43);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v20 + 5, v19, v19 + 8, 1uLL);
        operator delete(v19);
        v21 = (void **)__p;
        if (__p)
        {
          v22 = (void **)v45;
          v23 = __p;
          if ((void *)v45 != __p)
          {
            do
            {
              if (*((char *)v22 - 1) < 0)
                operator delete(*(v22 - 3));
              v22 -= 3;
            }
            while (v22 != v21);
            v23 = __p;
          }
          *(_QWORD *)&v45 = v21;
          operator delete(v23);
        }
        return 1;
      }
      v26 = "result && \"builder didn't return the right type\"";
      v27 = 497;
      v28 = "Builders.h";
      v29 = "create";
    }
    else
    {
      v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v27 = 662;
      v28 = "Casting.h";
      v29 = "dyn_cast";
    }
    __assert_rtn(v29, v28, v27, v26);
  }
  __p = operator new(0x40uLL);
  v45 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v24 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v45) < 0)
    operator delete(__p);
  return v24;
}

void sub_180E6E250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  void *v28;

  operator delete(v28);
  std::vector<std::string>::~vector[abi:ne180100](&a28);
  _Unwind_Resume(a1);
}

void sub_180E6E26C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6E2A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void sub_180E6E2BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter14::~GeneratedRewriter14(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter14::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter14 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t *Context;
  uint64_t v8;
  char v9;
  mlir::GenericProgramPoint *v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  void *v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t AttrData;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30[4];
  __int16 v31;
  uint64_t v32[2];
  const char *v33;
  uint64_t v34;
  __int16 v35;
  __int128 *v36[5];
  void *__p;
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v29 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v29);
    v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softsign", (const unsigned __int8 *)0xC, Context);
    if (!v9)
    {
      v35 = 1283;
      v33 = "mps.softsign";
      v34 = 12;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v31 = 259;
      llvm::operator+(v32, v30, (uint64_t)v36);
      llvm::report_fatal_error((llvm::Twine *)v36, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    mlir::mps::ACosOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue);
    v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    v11 = v10;
    if (v10)
    {
      v12 = *((_QWORD *)v10 + 6);
      v13 = *(void **)(v12 + 16);
      if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v36[0] = *(__int128 **)(v12 + 8);
        AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v36);
        if (v27 == 12 && *(_QWORD *)AttrData == 0x74666F732E73706DLL && *(_DWORD *)(AttrData + 8) == 1852270963)
        {
          v35 = 1283;
          v32[0] = (uint64_t)"classof on '";
          v33 = "mps.softsign";
          v34 = 12;
          v30[0] = (uint64_t)"' failed due to the operation not being registered";
          v31 = 259;
          llvm::operator+(v32, v30, (uint64_t)v36);
          llvm::report_fatal_error((llvm::Twine *)v36, 1);
        }
      }
      else if (v13 == &mlir::detail::TypeIDResolver<mlir::mps::SoftsignOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v11 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v14 = (__int128 *)__p;
        v15 = (char *)operator new(8uLL);
        *(_QWORD *)v15 = (char *)v11 - 16;
        v36[0] = v14;
        v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v36);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        v17 = (void **)__p;
        if (__p)
        {
          v18 = (void **)v38;
          v19 = __p;
          if ((void *)v38 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0)
                operator delete(*(v18 - 3));
              v18 -= 3;
            }
            while (v18 != v17);
            v19 = __p;
          }
          *(_QWORD *)&v38 = v17;
          operator delete(v19);
        }
        return 1;
      }
      v22 = "result && \"builder didn't return the right type\"";
      v23 = 497;
      v24 = "Builders.h";
      v25 = "create";
    }
    else
    {
      v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v23 = 662;
      v24 = "Casting.h";
      v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  v38 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v38) < 0)
    operator delete(__p);
  return v20;
}

void sub_180E6E714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  void *v26;

  operator delete(v26);
  std::vector<std::string>::~vector[abi:ne180100](&a26);
  _Unwind_Resume(a1);
}

void sub_180E6E730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E6E744(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E6E780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter15::~GeneratedRewriter15(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter15::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter15 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v8;
  uint64_t *Context;
  uint64_t v10;
  char v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  char *v23;
  uint64_t *v24;
  void **v25;
  void **v26;
  void *v27;
  uint64_t v28;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  const char *v34;
  int v35;
  const char *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42[4];
  __int16 v43;
  uint64_t v44[2];
  const char *v45;
  uint64_t v46;
  __int16 v47;
  __int128 *v48[5];
  void *__p;
  __int128 v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v40 = ArgValue;
  v39 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v8 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 13, LocationForOp, &v39, (uint64_t *)&__p);
    v41 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
    v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater_equal", (const unsigned __int8 *)0x11, Context);
    if (!v11)
    {
      v47 = 1283;
      v45 = "mps.greater_equal";
      v46 = 17;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v43 = 259;
      llvm::operator+(v44, v42, (uint64_t)v48);
      llvm::report_fatal_error((llvm::Twine *)v48, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*((_DWORD *)v8 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::EqualToOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue, (uint64_t)v8 - 16);
    v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v12)
    {
      v13 = llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        v14 = mlir::getElementTypeOrSelf(ArgValue);
        v15 = mlir::TypeAttr::get(v14);
        v41 = LocationForOp;
        v16 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
        v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, v16);
        if (!v18)
        {
          v47 = 1283;
          v45 = "mps.cast";
          v46 = 8;
                            "sn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#register"
                            "ed-loaded-dependent-whats-up-with-dialects-management";
          v43 = 259;
          llvm::operator+(v44, v42, (uint64_t)v48);
          llvm::report_fatal_error((llvm::Twine *)v48, 1);
        }
        mlir::OperationState::OperationState(&__p, LocationForOp, v17);
        if (!*(_DWORD *)(v13 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        mlir::mps::CastOp::build(a3 + 13, (uint64_t)&__p, v13 - 16, v15);
        v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
        if (v19)
        {
          v20 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
          if (v20)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
            v38 = v20;
            v21 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>(a3 + 13, LocationForOp, (uint64_t)&v38, &v40);
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
            if (!*(_DWORD *)(v21 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v22 = (__int128 *)__p;
            v23 = (char *)operator new(8uLL);
            *(_QWORD *)v23 = v21 - 16;
            v48[0] = v22;
            v24 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v22, (uint64_t)&std::piecewise_construct, v48);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v24 + 5, v23, v23 + 8, 1uLL);
            operator delete(v23);
            v25 = (void **)__p;
            if (__p)
            {
              v26 = (void **)v50;
              v27 = __p;
              if ((void *)v50 != __p)
              {
                do
                {
                  if (*((char *)v26 - 1) < 0)
                    operator delete(*(v26 - 3));
                  v26 -= 3;
                }
                while (v26 != v25);
                v27 = __p;
              }
              *(_QWORD *)&v50 = v25;
              operator delete(v27);
            }
            return 1;
          }
          v34 = "result && \"builder didn't return the right type\"";
          v35 = 497;
          v36 = "Builders.h";
          v37 = "create";
        }
        else
        {
          v34 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          v35 = 662;
          v36 = "Casting.h";
          v37 = "dyn_cast";
        }
        __assert_rtn(v37, v36, v35, v34);
      }
      v30 = "result && \"builder didn't return the right type\"";
      v31 = 497;
      v32 = "Builders.h";
      v33 = "create";
    }
    else
    {
      v30 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v31 = 662;
      v32 = "Casting.h";
      v33 = "dyn_cast";
    }
    __assert_rtn(v33, v32, v31, v30);
  }
  __p = operator new(0x40uLL);
  v50 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v28 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v50) < 0)
    operator delete(__p);
  return v28;
}

void sub_180E6ED00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter16::~GeneratedRewriter16(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter16::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter16 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E6F058(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter17::~GeneratedRewriter17(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter17::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter17 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E6F348(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter18::~GeneratedRewriter18(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter18::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter18 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::EqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E6F638(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter19::~GeneratedRewriter19(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter19::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter19 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 13, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

