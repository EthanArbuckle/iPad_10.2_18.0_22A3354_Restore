void sub_180E6F928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter20::~GeneratedRewriter20(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter20::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter20 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::PowerOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E6FC18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter21::~GeneratedRewriter21(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter21::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter21 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::MinimumOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E6FF08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter22::~GeneratedRewriter22(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter22::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter22 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E701F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter23::~GeneratedRewriter23(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter23::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter23 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ModuloOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E704E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ModuloOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.modulo", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.modulo";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::ModuloOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ModuloOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E706A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E706B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ModuloOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ModuloOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(_QWORD *)AttrData == 0x75646F6D2E73706DLL && *(_WORD *)(AttrData + 8) == 28524)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.modulo";
      v8[3] = 10;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ModuloOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter24::~GeneratedRewriter24(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter24::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter24 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E70A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter25::~GeneratedRewriter25(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter25::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter25 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E70D50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter26::~GeneratedRewriter26(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter26::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter26 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::GreaterThanOrEqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E71040(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter27::~GeneratedRewriter27(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter27::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter27 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E71330(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter28::~GeneratedRewriter28(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter28::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter28 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::LessThanOrEqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E71620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::LessThanOrEqualToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.less_equal", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.less_equal";
    v21[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::LessThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LessThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E717D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E717F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LessThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LessThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x7373656C2E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x6C617571655F7373)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.less_equal";
      v8[3] = 14;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LessThanOrEqualToOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter29::~GeneratedRewriter29(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter29::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter29 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *Context;
  uint64_t v10;
  char v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t ArgValue;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  __int128 *v33[5];
  void *__p;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v27 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::AndOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v27);
    v7 = mlir::IntegerType::get((uint64_t)a3[13], 1u, 0);
    v8 = mlir::TypeAttr::get(v7);
    v28 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
    v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
    if (!v11)
    {
      v32 = 1283;
      v31[2] = (uint64_t)"mps.cast";
      v31[3] = 8;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v30 = 259;
      llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
      llvm::report_fatal_error((llvm::Twine *)v33, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::CastOp::build(a3 + 13, (uint64_t)&__p, v6 - 16, v8);
    v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v12)
    {
      v13 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v13 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v14 = (__int128 *)__p;
        v15 = (char *)operator new(8uLL);
        *(_QWORD *)v15 = v13 - 16;
        v33[0] = v14;
        v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v33);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        v17 = (void **)__p;
        if (__p)
        {
          v18 = (void **)v35;
          v19 = __p;
          if ((void *)v35 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0)
                operator delete(*(v18 - 3));
              v18 -= 3;
            }
            while (v18 != v17);
            v19 = __p;
          }
          *(_QWORD *)&v35 = v17;
          operator delete(v19);
        }
        return 1;
      }
      v22 = "result && \"builder didn't return the right type\"";
      v23 = 497;
      v24 = "Builders.h";
      v25 = "create";
    }
    else
    {
      v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v23 = 662;
      v24 = "Casting.h";
      v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  v35 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v35) < 0)
    operator delete(__p);
  return v20;
}

void sub_180E71D04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E71D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::AndOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.and", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.and";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::AndOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AndOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E71EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E71F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::AndOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AndOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684955438)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.and";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::AndOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter30::~GeneratedRewriter30(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter30::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter30 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::NotEqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E722B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter31::~GeneratedRewriter31(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter31::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter31 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *Context;
  uint64_t v10;
  char v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t ArgValue;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  __int128 *v33[5];
  void *__p;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v27 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::OrOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v27);
    v7 = mlir::IntegerType::get((uint64_t)a3[13], 1u, 0);
    v8 = mlir::TypeAttr::get(v7);
    v28 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
    v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
    if (!v11)
    {
      v32 = 1283;
      v31[2] = (uint64_t)"mps.cast";
      v31[3] = 8;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v30 = 259;
      llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
      llvm::report_fatal_error((llvm::Twine *)v33, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::CastOp::build(a3 + 13, (uint64_t)&__p, v6 - 16, v8);
    v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v12)
    {
      v13 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v13 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v14 = (__int128 *)__p;
        v15 = (char *)operator new(8uLL);
        *(_QWORD *)v15 = v13 - 16;
        v33[0] = v14;
        v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v33);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        v17 = (void **)__p;
        if (__p)
        {
          v18 = (void **)v35;
          v19 = __p;
          if ((void *)v35 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0)
                operator delete(*(v18 - 3));
              v18 -= 3;
            }
            while (v18 != v17);
            v19 = __p;
          }
          *(_QWORD *)&v35 = v17;
          operator delete(v19);
        }
        return 1;
      }
      v22 = "result && \"builder didn't return the right type\"";
      v23 = 497;
      v24 = "Builders.h";
      v25 = "create";
    }
    else
    {
      v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v23 = 662;
      v24 = "Casting.h";
      v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  v35 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v35) < 0)
    operator delete(__p);
  return v20;
}

void sub_180E72708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E72774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::OrOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.or", (const unsigned __int8 *)6, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.or";
    v21[3] = 6;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::OrOp,mlir::Operation *,llvm::CastInfo<mlir::mps::OrOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E72900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E72918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::OrOp,mlir::Operation *,llvm::CastInfo<mlir::mps::OrOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 6 && *(_DWORD *)AttrData == 779317357 && *(_WORD *)(AttrData + 4) == 29295)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.or";
      v8[3] = 6;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::OrOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter32::~GeneratedRewriter32(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter32::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter32 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *Context;
  uint64_t v10;
  char v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  __int128 *v14;
  char *v15;
  uint64_t *v16;
  void **v17;
  void **v18;
  void *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t ArgValue;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  __int128 *v33[5];
  void *__p;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v27 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::XorOp,mlir::Value &,mlir::Value &>(a3 + 13, LocationForOp, &ArgValue, &v27);
    v7 = mlir::IntegerType::get((uint64_t)a3[13], 1u, 0);
    v8 = mlir::TypeAttr::get(v7);
    v28 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
    v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
    if (!v11)
    {
      v32 = 1283;
      v31[2] = (uint64_t)"mps.cast";
      v31[3] = 8;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v30 = 259;
      llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
      llvm::report_fatal_error((llvm::Twine *)v33, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::CastOp::build(a3 + 13, (uint64_t)&__p, v6 - 16, v8);
    v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v12)
    {
      v13 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v13 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v14 = (__int128 *)__p;
        v15 = (char *)operator new(8uLL);
        *(_QWORD *)v15 = v13 - 16;
        v33[0] = v14;
        v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v33);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        v17 = (void **)__p;
        if (__p)
        {
          v18 = (void **)v35;
          v19 = __p;
          if ((void *)v35 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0)
                operator delete(*(v18 - 3));
              v18 -= 3;
            }
            while (v18 != v17);
            v19 = __p;
          }
          *(_QWORD *)&v35 = v17;
          operator delete(v19);
        }
        return 1;
      }
      v22 = "result && \"builder didn't return the right type\"";
      v23 = 497;
      v24 = "Builders.h";
      v25 = "create";
    }
    else
    {
      v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v23 = 662;
      v24 = "Casting.h";
      v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  v35 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v35) < 0)
    operator delete(__p);
  return v20;
}

void sub_180E72E18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E72E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::XorOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.xor", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.xor";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::XorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::XorOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E73010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E73028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::XorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::XorOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1919907886)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.xor";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::XorOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter33::~GeneratedRewriter33(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter33::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter33 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  void *v14;
  __int128 *v15;
  char *v16;
  uint64_t *v17;
  void **v18;
  void **v19;
  void *v20;
  uint64_t v21;
  const char *v23;
  int v24;
  const char *v25;
  const char *v26;
  _QWORD *AttrData;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31[4];
  __int16 v32;
  uint64_t v33[2];
  const char *v34;
  uint64_t v35;
  __int16 v36;
  __int128 *v37[5];
  void *__p;
  __int128 v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v30 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
    v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor_divide", (const unsigned __int8 *)0x10, Context);
    if (!v10)
    {
      v36 = 1283;
      v34 = "mps.floor_divide";
      v35 = 16;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v32 = 259;
      llvm::operator+(v33, v31, (uint64_t)v37);
      llvm::report_fatal_error((llvm::Twine *)v37, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v9);
    mlir::mps::ATan2Op::build(a3 + 13, (uint64_t)&__p, ArgValue, v7);
    v11 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    v12 = v11;
    if (v11)
    {
      v13 = *((_QWORD *)v11 + 6);
      v14 = *(void **)(v13 + 16);
      if (v14 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v37[0] = *(__int128 **)(v13 + 8);
        AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v37);
        if (v28 == 16 && *AttrData == 0x6F6F6C662E73706DLL && AttrData[1] == 0x6564697669645F72)
        {
          v36 = 1283;
          v33[0] = (uint64_t)"classof on '";
          v34 = "mps.floor_divide";
          v35 = 16;
          v31[0] = (uint64_t)"' failed due to the operation not being registered";
          v32 = 259;
          llvm::operator+(v33, v31, (uint64_t)v37);
          llvm::report_fatal_error((llvm::Twine *)v37, 1);
        }
      }
      else if (v14 == &mlir::detail::TypeIDResolver<mlir::mps::FloorDivideOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v12 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v15 = (__int128 *)__p;
        v16 = (char *)operator new(8uLL);
        *(_QWORD *)v16 = (char *)v12 - 16;
        v37[0] = v15;
        v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v15, (uint64_t)&std::piecewise_construct, v37);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
        operator delete(v16);
        v18 = (void **)__p;
        if (__p)
        {
          v19 = (void **)v39;
          v20 = __p;
          if ((void *)v39 != __p)
          {
            do
            {
              if (*((char *)v19 - 1) < 0)
                operator delete(*(v19 - 3));
              v19 -= 3;
            }
            while (v19 != v18);
            v20 = __p;
          }
          *(_QWORD *)&v39 = v18;
          operator delete(v20);
        }
        return 1;
      }
      v23 = "result && \"builder didn't return the right type\"";
      v24 = 497;
      v25 = "Builders.h";
      v26 = "create";
    }
    else
    {
      v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v24 = 662;
      v25 = "Casting.h";
      v26 = "dyn_cast";
    }
    __assert_rtn(v26, v25, v24, v23);
  }
  __p = operator new(0x40uLL);
  v39 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v21 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v39) < 0)
    operator delete(__p);
  return v21;
}

void sub_180E73588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  void *v26;

  operator delete(v26);
  std::vector<std::string>::~vector[abi:ne180100](&a26);
  _Unwind_Resume(a1);
}

void sub_180E735A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E735B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E735F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter34::~GeneratedRewriter34(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter34::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter34 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E7389C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter35::~GeneratedRewriter35(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter35::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter35 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ACosOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E73B70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ACosOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.acos", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.acos";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ACosOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ACosOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E73D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E73D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ACosOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ACosOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x736F63612E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.acos";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ACosOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter36::~GeneratedRewriter36(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter36::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter36 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ACoshOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E740B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ACoshOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.acosh", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.acosh";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ACoshOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ACoshOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E74268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E74280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ACoshOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ACoshOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x736F63612E73706DLL && *(_BYTE *)(AttrData + 8) == 104)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.acosh";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ACoshOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter37::~GeneratedRewriter37(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter37::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter37 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ASinOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E7460C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ASinOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.asin", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.asin";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ASinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ASinOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E747BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E747D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ASinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ASinOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6E6973612E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.asin";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ASinOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter38::~GeneratedRewriter38(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter38::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter38 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ASinhOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E74B54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ASinhOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.asinh", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.asinh";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ASinhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ASinhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E74D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E74D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ASinhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ASinhOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x6E6973612E73706DLL && *(_BYTE *)(AttrData + 8) == 104)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.asinh";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ASinhOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter39::~GeneratedRewriter39(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter39::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter39 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ATanOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E750A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ATanOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atan", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.atan";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ATanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ATanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E75258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E75270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ATanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ATanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6E6174612E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.atan";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ATanOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter40::~GeneratedRewriter40(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter40::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter40 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ATanhOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E755F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ATanhOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atanh", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.atanh";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ATanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ATanhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E757A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E757B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ATanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ATanhOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x6E6174612E73706DLL && *(_BYTE *)(AttrData + 8) == 104)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.atanh";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ATanhOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter41::~GeneratedRewriter41(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter41::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter41 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::CeilOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E75B44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter42::~GeneratedRewriter42(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter42::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter42 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::CosOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E75E18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CosOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cos", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.cos";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::CosOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CosOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E75FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E75FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CosOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CosOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1936679726)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.cos";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CosOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter43::~GeneratedRewriter43(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter43::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter43 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::CoshOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E76368(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CoshOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cosh", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.cosh";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::CoshOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CoshOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E76518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E76530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CoshOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CoshOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x68736F632E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.cosh";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CoshOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter44::~GeneratedRewriter44(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter44::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter44 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t v17;
  uint64_t ArgValue;
  uint64_t v19;
  __int128 *v20;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v17 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  v19 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ClampOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v17, &v19);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v20 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v20);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E768E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter45::~GeneratedRewriter45(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter45::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter45 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E76BBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter46::~GeneratedRewriter46(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter46::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter46 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ExponentBase2Op,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E76E90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ExponentBase2Op,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent_base_2", (const unsigned __int8 *)0x13, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.exponent_base_2";
    v19[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ExponentBase2Op,mlir::Operation *,llvm::CastInfo<mlir::mps::ExponentBase2Op,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E77040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E77058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ExponentBase2Op,mlir::Operation *,llvm::CastInfo<mlir::mps::ExponentBase2Op,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 19
      && *AttrData == 0x6F7078652E73706DLL
      && AttrData[1] == 0x7361625F746E656ELL
      && *(_QWORD *)((char *)AttrData + 11) == 0x325F657361625F74)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.exponent_base_2";
      v9[3] = 19;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ExponentBase2Op,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter47::~GeneratedRewriter47(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter47::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter47 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E77404(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.floor";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::FloorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::FloorOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E775B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E775CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter48::~GeneratedRewriter48(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter48::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter48 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::NotOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E77874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::NotOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.not", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.not";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::NotOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NotOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E77A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E77A3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::NotOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NotOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1953459758)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.not";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::NotOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter49::~GeneratedRewriter49(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter49::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter49 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::RoundOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E77DC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter50::~GeneratedRewriter50(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter50::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter50 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::SignOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E78098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SignOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sign", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.sign";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SignOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SignOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E78248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E78260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SignOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SignOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6E6769732E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.sign";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SignOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter51::~GeneratedRewriter51(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter51::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter51 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::SinOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E785E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SinOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sin", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.sin";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SinOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E78790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E787A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SinOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1852404526)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.sin";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SinOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter52::~GeneratedRewriter52(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter52::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter52 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::SinhOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E78B30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SinhOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sinh", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.sinh";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SinhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SinhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E78CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E78CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SinhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SinhOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x686E69732E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.sinh";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SinhOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter53::~GeneratedRewriter53(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter53::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter53 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E79078(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.square_root";
    v19[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareRootOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E79228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E79240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter54::~GeneratedRewriter54(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter54::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter54 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E794E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter55::~GeneratedRewriter55(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter55::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter55 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::TanOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E797BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TanOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tan", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.tan";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::TanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E7996C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E79984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _DWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1851880494)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.tan";
      v8[3] = 7;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TanOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter56::~GeneratedRewriter56(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter56::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter56 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E79D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  const char *v12;
  int v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _BYTE v21[40];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tanh", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.tanh";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v13 = 662;
    v14 = "Casting.h";
    v15 = "dyn_cast";
    goto LABEL_8;
  }
  v10 = llvm::DefaultDoCastIfPossible<mlir::mps::TanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    v12 = "result && \"builder didn't return the right type\"";
    v13 = 497;
    v14 = "Builders.h";
    v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180E79EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E79ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter57::~GeneratedRewriter57(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter57::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter57 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t *Context;
  uint64_t v8;
  char v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v11;
  __int128 *v12;
  char *v13;
  uint64_t *v14;
  void **v15;
  void **v16;
  void *v17;
  uint64_t v18;
  const char *v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  uint64_t ArgValue;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  __int128 *v31[5];
  void *__p;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v24 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v24);
    v26 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
    v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
    if (!v9)
    {
      v30 = 1283;
      v29[2] = (uint64_t)"mps.select";
      v29[3] = 10;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v28 = 259;
      llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
      llvm::report_fatal_error((llvm::Twine *)v31, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::SelectOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, v6 - 16, v24, ArgValue);
    v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v10)
    {
      v11 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v10);
      if (v11)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v11 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v12 = (__int128 *)__p;
        v13 = (char *)operator new(8uLL);
        *(_QWORD *)v13 = v11 - 16;
        v31[0] = v12;
        v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v12, (uint64_t)&std::piecewise_construct, v31);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v14 + 5, v13, v13 + 8, 1uLL);
        operator delete(v13);
        v15 = (void **)__p;
        if (__p)
        {
          v16 = (void **)v33;
          v17 = __p;
          if ((void *)v33 != __p)
          {
            do
            {
              if (*((char *)v16 - 1) < 0)
                operator delete(*(v16 - 3));
              v16 -= 3;
            }
            while (v16 != v15);
            v17 = __p;
          }
          *(_QWORD *)&v33 = v15;
          operator delete(v17);
        }
        return 1;
      }
      v20 = "result && \"builder didn't return the right type\"";
      v21 = 497;
      v22 = "Builders.h";
      v23 = "create";
    }
    else
    {
      v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v21 = 662;
      v22 = "Casting.h";
      v23 = "dyn_cast";
    }
    __assert_rtn(v23, v22, v21, v20);
  }
  __p = operator new(0x40uLL);
  v33 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v18 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v33) < 0)
    operator delete(__p);
  return v18;
}

void sub_180E7A2E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E7A34C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a28);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter58::~GeneratedRewriter58(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter58::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter58 *this, const MIL::IROperation *a2, MILToMLIRRewriter *a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mlir::GenericProgramPoint *v9;
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  __int128 *v15;
  char *v16;
  uint64_t *v17;
  void **v18;
  void **v19;
  void *v20;
  uint64_t v21;
  const char *v23;
  int v24;
  const char *v25;
  const char *v26;
  uint64_t ArgValue;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  __int128 *v33[5];
  void *__p;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp((mlir::StringAttr **)a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "cond");
  v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "a");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "b");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v8 = mlir::IntegerType::get(*((_QWORD *)a3 + 13), 1u, 0);
    __p = (void *)mlir::TypeAttr::get(v8);
    v9 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)a3 + 13, LocationForOp, &ArgValue, (uint64_t *)&__p);
    v28 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
    v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
    if (!v12)
    {
      v32 = 1283;
      v31[2] = (uint64_t)"mps.select";
      v31[3] = 10;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v30 = 259;
      llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
      llvm::report_fatal_error((llvm::Twine *)v33, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v11);
    if (!*((_DWORD *)v9 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::SelectOp::build((uint64_t)a3 + 104, (uint64_t)&__p, (uint64_t)v9 - 16, v6, v7);
    v13 = mlir::OpBuilder::create((MILToMLIRRewriter *)((char *)a3 + 104), (const mlir::OperationState *)&__p);
    if (v13)
    {
      v14 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
      if (v14)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v14 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v15 = (__int128 *)__p;
        v16 = (char *)operator new(8uLL);
        *(_QWORD *)v16 = v14 - 16;
        v33[0] = v15;
        v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a3 + 64, (uint64_t)v15, (uint64_t)&std::piecewise_construct, v33);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
        operator delete(v16);
        v18 = (void **)__p;
        if (__p)
        {
          v19 = (void **)v35;
          v20 = __p;
          if ((void *)v35 != __p)
          {
            do
            {
              if (*((char *)v19 - 1) < 0)
                operator delete(*(v19 - 3));
              v19 -= 3;
            }
            while (v19 != v18);
            v20 = __p;
          }
          *(_QWORD *)&v35 = v18;
          operator delete(v20);
        }
        return 1;
      }
      v23 = "result && \"builder didn't return the right type\"";
      v24 = 497;
      v25 = "Builders.h";
      v26 = "create";
    }
    else
    {
      v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v24 = 662;
      v25 = "Casting.h";
      v26 = "dyn_cast";
    }
    __assert_rtn(v26, v25, v24, v23);
  }
  __p = operator new(0x40uLL);
  v35 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v21 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v35) < 0)
    operator delete(__p);
  return v21;
}

void sub_180E7A794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E7A800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter59::~GeneratedRewriter59(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter59::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter59 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::IdentityOp,mlir::Value>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E7AAA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter60::~GeneratedRewriter60(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter60::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter60 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t *v11;
  uint64_t UnknownLoc;
  _QWORD *v13;
  uint64_t v14;
  uint64_t *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t *Context;
  uint64_t v18;
  char v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;
  mlir::GenericProgramPoint *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  char v31;
  mlir::GenericProgramPoint *v32;
  uint64_t v33;
  __int128 *v34;
  char *v35;
  uint64_t *v36;
  void **v37;
  void **v38;
  void *v39;
  uint64_t v40;
  const char *v42;
  int v43;
  const char *v44;
  const char *v45;
  const char *v46;
  int v47;
  const char *v48;
  const char *v49;
  const char *v50;
  int v51;
  const char *v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56[4];
  __int16 v57;
  uint64_t v58[2];
  const char *v59;
  uint64_t v60;
  __int16 v61;
  __int128 *v62[5];
  void *__p;
  __int128 v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  v54 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "one_hot_vector_size");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  v8 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "on_value");
  v9 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "off_value");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v11 = (uint64_t *)(a3 + 13);
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v10);
    v13 = operator new(8uLL);
    *v13 = 1;
    v14 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v15 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v13, 1, v14, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v15, -1);
    v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)&__p);
    v55 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v55);
    v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, Context);
    if (!v19)
    {
      v61 = 1283;
      v59 = "mps.expand_dims";
      v60 = 15;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      v57 = 259;
      llvm::operator+(v58, v56, (uint64_t)v62);
      llvm::report_fatal_error((llvm::Twine *)v62, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v18);
    if (!*((_DWORD *)v16 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ExpandDimsOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue, (uint64_t)v16 - 16);
    v20 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v20)
    {
      v21 = llvm::DefaultDoCastIfPossible<mlir::mps::ExpandDimsOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ExpandDimsOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v20);
      if (v21)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        operator delete(v13);
        __p = (void *)mlir::IntegerType::get(*v11, 0x20u, 2u);
        v22 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 13, LocationForOp, &v54, (uint64_t *)&__p);
        v23 = mlir::IntegerType::get(*v11, 1u, 0);
        v55 = LocationForOp;
        v24 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v55);
        v25 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.one_hot", (const unsigned __int8 *)0xB, v24);
        if (!v26)
        {
          v61 = 1283;
          v59 = "mps.one_hot";
          v60 = 11;
                            "sn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#register"
                            "ed-loaded-dependent-whats-up-with-dialects-management";
          v57 = 259;
          llvm::operator+(v58, v56, (uint64_t)v62);
          llvm::report_fatal_error((llvm::Twine *)v62, 1);
        }
        mlir::OperationState::OperationState(&__p, LocationForOp, v25);
        if (!*(_DWORD *)(v21 + 36) || !*((_DWORD *)v22 + 9))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        mlir::mps::OneHotOp::build(a3 + 13, (uint64_t)&__p, v21 - 16, (uint64_t)v22 - 16, v7, v23);
        v27 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
        if (v27)
        {
          v28 = llvm::DefaultDoCastIfPossible<mlir::mps::OneHotOp,mlir::Operation *,llvm::CastInfo<mlir::mps::OneHotOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v27);
          if (v28)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
            v55 = LocationForOp;
            v29 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v55);
            v30 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v29);
            if (!v31)
            {
              v61 = 1283;
              v59 = "mps.select";
              v60 = 10;
                                "n hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#"
                                "registered-loaded-dependent-whats-up-with-dialects-management";
              v57 = 259;
              llvm::operator+(v58, v56, (uint64_t)v62);
              llvm::report_fatal_error((llvm::Twine *)v62, 1);
            }
            mlir::OperationState::OperationState(&__p, LocationForOp, v30);
            if (!*(_DWORD *)(v28 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            mlir::mps::SelectOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, v28 - 16, v8, v9);
            v32 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
            if (v32)
            {
              v33 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v32);
              if (v33)
              {
                mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
                (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
                if (!*(_DWORD *)(v33 + 36))
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                v34 = (__int128 *)__p;
                v35 = (char *)operator new(8uLL);
                *(_QWORD *)v35 = v33 - 16;
                v62[0] = v34;
                v36 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v34, (uint64_t)&std::piecewise_construct, v62);
                std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v36 + 5, v35, v35 + 8, 1uLL);
                operator delete(v35);
                v37 = (void **)__p;
                if (__p)
                {
                  v38 = (void **)v64;
                  v39 = __p;
                  if ((void *)v64 != __p)
                  {
                    do
                    {
                      if (*((char *)v38 - 1) < 0)
                        operator delete(*(v38 - 3));
                      v38 -= 3;
                    }
                    while (v38 != v37);
                    v39 = __p;
                  }
                  *(_QWORD *)&v64 = v37;
                  operator delete(v39);
                }
                return 1;
              }
              v50 = "result && \"builder didn't return the right type\"";
              v51 = 497;
              v52 = "Builders.h";
              v53 = "create";
            }
            else
            {
              v50 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              v51 = 662;
              v52 = "Casting.h";
              v53 = "dyn_cast";
            }
            __assert_rtn(v53, v52, v51, v50);
          }
          v46 = "result && \"builder didn't return the right type\"";
          v47 = 497;
          v48 = "Builders.h";
          v49 = "create";
        }
        else
        {
          v46 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          v47 = 662;
          v48 = "Casting.h";
          v49 = "dyn_cast";
        }
        __assert_rtn(v49, v48, v47, v46);
      }
      v42 = "result && \"builder didn't return the right type\"";
      v43 = 497;
      v44 = "Builders.h";
      v45 = "create";
    }
    else
    {
      v42 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v43 = 662;
      v44 = "Casting.h";
      v45 = "dyn_cast";
    }
    __assert_rtn(v45, v44, v43, v42);
  }
  __p = operator new(0x40uLL);
  v64 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v40 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v64) < 0)
    operator delete(__p);
  return v40;
}

void sub_180E7B244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::OneHotOp,mlir::Operation *,llvm::CastInfo<mlir::mps::OneHotOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x5F656E6F2E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x746F685F656E6F2ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.one_hot";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::OneHotOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter61::~GeneratedRewriter61(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter61::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter61 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  __int128 *v18;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v18 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E7B6A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter62::~GeneratedRewriter62(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter62::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter62 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "reps");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::TileOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E7B994(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TileOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tile", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.tile";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::TileOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::TileOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TileOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E7BB4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E7BB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TileOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TileOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v5;
  __int16 v6;
  uint64_t v7[4];
  __int16 v8;
  _QWORD v9[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x656C69742E73706DLL)
    {
      v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.tile";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TileOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter63::~GeneratedRewriter63(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter63::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter63 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v14;
  void *v15;
  char *v16;
  uint64_t *v17;
  void **v18;
  void **v19;
  void *v20;
  uint64_t v21;
  const char *v23;
  int v24;
  const char *v25;
  const char *v26;
  void *v27[2];
  char v28;
  void *v29[2];
  char v30;
  char **v31;
  char *v32[2];
  uint64_t v33;
  const char *v34;
  __int16 v35;
  uint64_t v36[4];
  __int16 v37;
  _BYTE v38[17];
  void *v39[2];
  char v40;
  int v41;
  void *v42[2];
  char v43;
  int v44;
  void *v45[2];
  char v46;
  int v47;
  void *v48[2];
  char v49;
  int v50;
  void *v51[2];
  char v52;
  int v53;
  void *v54[2];
  char v55;
  int v56;
  void *v57[2];
  char v58;
  int v59;
  void *__p;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  v8 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "updates");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "mode");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v40 = 3;
    LODWORD(v39[0]) = 6579297;
    v43 = 3;
    v41 = 0;
    LODWORD(v42[0]) = 6452595;
    v46 = 3;
    v44 = 1;
    LODWORD(v45[0]) = 7107949;
    v49 = 3;
    v47 = 2;
    LODWORD(v48[0]) = 7760228;
    v52 = 3;
    v50 = 3;
    LODWORD(v51[0]) = 7235949;
    v53 = 4;
    v55 = 3;
    LODWORD(v54[0]) = 7889261;
    v58 = 6;
    v56 = 5;
    strcpy((char *)v57, "update");
    v59 = 6;
    v32[0] = 0;
    v32[1] = 0;
    v31 = v32;
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v39, (uint64_t)v39);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v42, (uint64_t)v42);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v45, (uint64_t)v45);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v48, (uint64_t)v48);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v51, (uint64_t)v51);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v54, (uint64_t)v54);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v57, (uint64_t)v57);
    v28 = 4;
    strcpy((char *)v27, "mode");
    MIL::IROperation::TryGetParameterValue();
    MIL::IRValue::GetScalar<std::string>();
    v9 = *((_DWORD *)std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v31, (const void **)v29, (uint64_t)v29)+ 14);
    v33 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v33);
    v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter_nd", (const unsigned __int8 *)0xE, Context);
    if (!v12)
    {
      v37 = 1283;
      v36[2] = (uint64_t)"mps.scatter_nd";
      v36[3] = 14;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v35 = 259;
      llvm::operator+(v36, (uint64_t *)&v34, (uint64_t)v38);
      llvm::report_fatal_error((llvm::Twine *)v38, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v11);
    mlir::mps::ScatterNDOp::build((mlir::Builder *)(a3 + 13), (uint64_t)&__p, ArgValue, v8, v7, 0, v9);
    v13 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v13)
    {
      v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ScatterNDOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterNDOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
      if (v14)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v30 < 0)
        {
          operator delete(v29[0]);
          if ((v28 & 0x80000000) == 0)
          {
LABEL_7:
            std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v32[0]);
            if ((v58 & 0x80000000) == 0)
              goto LABEL_8;
            goto LABEL_29;
          }
        }
        else if ((v28 & 0x80000000) == 0)
        {
          goto LABEL_7;
        }
        operator delete(v27[0]);
        std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v32[0]);
        if ((v58 & 0x80000000) == 0)
        {
LABEL_8:
          if ((v55 & 0x80000000) == 0)
            goto LABEL_9;
          goto LABEL_30;
        }
LABEL_29:
        operator delete(v57[0]);
        if ((v55 & 0x80000000) == 0)
        {
LABEL_9:
          if ((v52 & 0x80000000) == 0)
            goto LABEL_10;
          goto LABEL_31;
        }
LABEL_30:
        operator delete(v54[0]);
        if ((v52 & 0x80000000) == 0)
        {
LABEL_10:
          if ((v49 & 0x80000000) == 0)
            goto LABEL_11;
          goto LABEL_32;
        }
LABEL_31:
        operator delete(v51[0]);
        if ((v49 & 0x80000000) == 0)
        {
LABEL_11:
          if ((v46 & 0x80000000) == 0)
            goto LABEL_12;
          goto LABEL_33;
        }
LABEL_32:
        operator delete(v48[0]);
        if ((v46 & 0x80000000) == 0)
        {
LABEL_12:
          if ((v43 & 0x80000000) == 0)
            goto LABEL_13;
          goto LABEL_34;
        }
LABEL_33:
        operator delete(v45[0]);
        if ((v43 & 0x80000000) == 0)
        {
LABEL_13:
          if ((v40 & 0x80000000) == 0)
          {
LABEL_14:
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
            if (!*(_DWORD *)(v14 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v15 = __p;
            v16 = (char *)operator new(8uLL);
            *(_QWORD *)v16 = v14 - 16;
            v39[0] = v15;
            v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v15, (uint64_t)&std::piecewise_construct, (__int128 **)v39);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
            operator delete(v16);
            v18 = (void **)__p;
            if (__p)
            {
              v19 = (void **)v61;
              v20 = __p;
              if ((void *)v61 != __p)
              {
                do
                {
                  if (*((char *)v19 - 1) < 0)
                    operator delete(*(v19 - 3));
                  v19 -= 3;
                }
                while (v19 != v18);
                v20 = __p;
              }
              *(_QWORD *)&v61 = v18;
              operator delete(v20);
            }
            return 1;
          }
LABEL_35:
          operator delete(v39[0]);
          goto LABEL_14;
        }
LABEL_34:
        operator delete(v42[0]);
        if ((v40 & 0x80000000) == 0)
          goto LABEL_14;
        goto LABEL_35;
      }
      v23 = "result && \"builder didn't return the right type\"";
      v24 = 497;
      v25 = "Builders.h";
      v26 = "create";
    }
    else
    {
      v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v24 = 662;
      v25 = "Casting.h";
      v26 = "dyn_cast";
    }
    __assert_rtn(v26, v25, v24, v23);
  }
  __p = operator new(0x40uLL);
  v61 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v21 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v61) < 0)
    operator delete(__p);
  return v21;
}

void sub_180E7C2CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59,uint64_t a60,void *a61,uint64_t a62,int a63)
{
  char a66;
  void *a68;
  char a72;
  void *a73;
  char a74;
  void *a75;
  char a76;
  void *a77;

  mlir::OperationState::~OperationState((mlir::OperationState *)&a77);
  if (a20 < 0)
  {
    operator delete(a15);
    if ((a14 & 0x80000000) == 0)
    {
LABEL_3:
      std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(a22);
      if ((a76 & 0x80000000) == 0)
        goto LABEL_4;
      goto LABEL_13;
    }
  }
  else if ((a14 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a9);
  std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(a22);
  if ((a76 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a74 & 0x80000000) == 0)
      goto LABEL_5;
    goto LABEL_14;
  }
LABEL_13:
  operator delete(a75);
  if ((a74 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a72 & 0x80000000) == 0)
      goto LABEL_6;
    goto LABEL_15;
  }
LABEL_14:
  operator delete(a73);
  if ((a72 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a66 & 0x80000000) == 0)
      goto LABEL_7;
    goto LABEL_16;
  }
LABEL_15:
  operator delete(a68);
  if ((a66 & 0x80000000) == 0)
  {
LABEL_7:
    if ((a59 & 0x80000000) == 0)
      goto LABEL_8;
    goto LABEL_17;
  }
LABEL_16:
  operator delete(a61);
  if ((a59 & 0x80000000) == 0)
  {
LABEL_8:
    if ((a52 & 0x80000000) == 0)
      goto LABEL_9;
    goto LABEL_18;
  }
LABEL_17:
  operator delete(a54);
  if ((a52 & 0x80000000) == 0)
  {
LABEL_9:
    if (a45 < 0)
      goto LABEL_10;
    goto LABEL_19;
  }
LABEL_18:
  operator delete(a47);
  if (a45 < 0)
  {
LABEL_10:
    operator delete(__p);
    _Unwind_Resume(a1);
  }
LABEL_19:
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ScatterNDOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterNDOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x746163732E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x646E5F7265747461)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.scatter_nd";
      v8[3] = 14;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>(uint64_t *result, uint64_t a2, const void **a3, uint64_t a4)
{
  _QWORD *v6;
  uint64_t *v7;
  _QWORD *v8;
  int v9;
  int v10;
  size_t v11;
  const void *v12;
  size_t v13;
  const void *v14;
  size_t v15;
  _BOOL4 v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  _BOOL4 v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  BOOL v25;
  int v26;
  int v27;
  size_t v28;
  const void *v29;
  size_t v30;
  const void *v31;
  size_t v32;
  BOOL v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  const void *v37;
  const void *v38;
  int v39;
  size_t v40;
  const void *v41;
  size_t v42;
  int v43;
  _BOOL4 v44;
  _BOOL4 v45;
  _QWORD *v46;
  _QWORD *v47;
  const void *v48;
  const void *v49;
  int v50;
  size_t v51;
  const void *v52;
  size_t v53;
  int v54;
  BOOL v55;
  _QWORD *v56;
  char *v57;
  std::string *v58;
  _QWORD *v59;
  const void *v60;
  const void *v61;
  int v62;
  size_t v63;
  const void *v64;
  size_t v65;
  int v66;
  _BOOL4 v67;
  _BOOL4 v68;
  uint64_t v69;

  v6 = (_QWORD *)a2;
  v7 = result;
  v8 = result + 1;
  if (result + 1 != (uint64_t *)a2)
  {
    v9 = *(char *)(a2 + 55);
    v10 = *((char *)a3 + 23);
    if (v10 >= 0)
      v11 = *((unsigned __int8 *)a3 + 23);
    else
      v11 = (size_t)a3[1];
    if (v10 >= 0)
      v12 = a3;
    else
      v12 = *a3;
    if (v9 >= 0)
      v13 = *(unsigned __int8 *)(a2 + 55);
    else
      v13 = *(_QWORD *)(a2 + 40);
    if (v9 >= 0)
      v14 = (const void *)(a2 + 32);
    else
      v14 = *(const void **)(a2 + 32);
    if (v13 >= v11)
      v15 = v11;
    else
      v15 = v13;
    result = (uint64_t *)memcmp(v12, v14, v15);
    v16 = v11 < v13;
    if ((_DWORD)result)
      v16 = (int)result < 0;
    if (!v16)
    {
      result = (uint64_t *)memcmp(v14, v12, v15);
      v20 = v13 < v11;
      if ((_DWORD)result)
        v20 = (int)result < 0;
      if (v20)
      {
        v22 = v6 + 1;
        v21 = (_QWORD *)v6[1];
        if (v21)
        {
          do
          {
            v22 = v21;
            v21 = (_QWORD *)*v21;
            v6 = v22;
            v23 = v22;
          }
          while (v21);
        }
        else
        {
          v23 = v6;
          do
          {
            v46 = v23;
            v23 = (_QWORD *)v23[2];
          }
          while ((_QWORD *)*v23 != v46);
        }
        if (v23 == v8)
          goto LABEL_96;
        v49 = (const void *)v23[4];
        v47 = v23 + 4;
        v48 = v49;
        v50 = *((char *)v47 + 23);
        if (v50 >= 0)
          v51 = *((unsigned __int8 *)v47 + 23);
        else
          v51 = v47[1];
        if (v50 >= 0)
          v52 = v47;
        else
          v52 = v48;
        if (v51 >= v11)
          v53 = v11;
        else
          v53 = v51;
        v54 = memcmp(v12, v52, v53);
        v55 = v11 < v51;
        if (v54)
          v55 = v54 < 0;
        if (v55)
          goto LABEL_96;
        v56 = (_QWORD *)*v8;
        v22 = v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_96;
        while (1)
        {
          while (1)
          {
            v6 = v56;
            v61 = (const void *)v56[4];
            v59 = v56 + 4;
            v60 = v61;
            v62 = *((char *)v59 + 23);
            if (v62 >= 0)
              v63 = *((unsigned __int8 *)v59 + 23);
            else
              v63 = v59[1];
            if (v62 >= 0)
              v64 = v59;
            else
              v64 = v60;
            if (v63 >= v11)
              v65 = v11;
            else
              v65 = v63;
            v66 = memcmp(v12, v64, v65);
            v67 = v11 < v63;
            if (v66)
              v67 = v66 < 0;
            if (!v67)
              break;
            v56 = (_QWORD *)*v6;
            v22 = v6;
            if (!*v6)
              goto LABEL_96;
          }
          result = (uint64_t *)memcmp(v64, v12, v65);
          v68 = v63 < v11;
          if ((_DWORD)result)
            v68 = (int)result < 0;
          if (!v68)
            break;
          v56 = (_QWORD *)v6[1];
          if (!v56)
          {
LABEL_79:
            v22 = v6 + 1;
            goto LABEL_96;
          }
        }
      }
      return result;
    }
  }
  v17 = *v6;
  if ((_QWORD *)*v7 == v6)
  {
    v19 = v6;
  }
  else
  {
    if (v17)
    {
      v18 = (_QWORD *)*v6;
      do
      {
        v19 = v18;
        v18 = (_QWORD *)v18[1];
      }
      while (v18);
    }
    else
    {
      v24 = v6;
      do
      {
        v19 = (_QWORD *)v24[2];
        v25 = *v19 == (_QWORD)v24;
        v24 = v19;
      }
      while (v25);
    }
    v26 = *((char *)a3 + 23);
    v27 = *((char *)v19 + 55);
    if (v27 >= 0)
      v28 = *((unsigned __int8 *)v19 + 55);
    else
      v28 = v19[5];
    if (v27 >= 0)
      v29 = v19 + 4;
    else
      v29 = (const void *)v19[4];
    if (v26 >= 0)
      v30 = *((unsigned __int8 *)a3 + 23);
    else
      v30 = (size_t)a3[1];
    if (v26 >= 0)
      v31 = a3;
    else
      v31 = *a3;
    if (v30 >= v28)
      v32 = v28;
    else
      v32 = v30;
    result = (uint64_t *)memcmp(v29, v31, v32);
    v33 = v28 < v30;
    if ((_DWORD)result)
      v33 = (int)result < 0;
    if (!v33)
    {
      v35 = (_QWORD *)*v8;
      v22 = v8;
      v6 = v8;
      if (!*v8)
        goto LABEL_96;
      while (1)
      {
        while (1)
        {
          v6 = v35;
          v38 = (const void *)v35[4];
          v36 = v35 + 4;
          v37 = v38;
          v39 = *((char *)v36 + 23);
          if (v39 >= 0)
            v40 = *((unsigned __int8 *)v36 + 23);
          else
            v40 = v36[1];
          if (v39 >= 0)
            v41 = v36;
          else
            v41 = v37;
          if (v40 >= v30)
            v42 = v30;
          else
            v42 = v40;
          v43 = memcmp(v31, v41, v42);
          v44 = v30 < v40;
          if (v43)
            v44 = v43 < 0;
          if (!v44)
            break;
          v35 = (_QWORD *)*v6;
          v22 = v6;
          if (!*v6)
            goto LABEL_96;
        }
        result = (uint64_t *)memcmp(v41, v31, v42);
        v45 = v40 < v30;
        if ((_DWORD)result)
          v45 = (int)result < 0;
        if (!v45)
          return result;
        v35 = (_QWORD *)v6[1];
        if (!v35)
          goto LABEL_79;
      }
    }
  }
  if (v17)
    v34 = v19;
  else
    v34 = v6;
  if (v17)
    v22 = v19 + 1;
  else
    v22 = v6;
  if (!*v22)
  {
    v6 = v34;
LABEL_96:
    v57 = (char *)operator new(0x40uLL);
    v58 = (std::string *)(v57 + 32);
    if (*(char *)(a4 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v58, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)&v58->__r_.__value_.__l.__data_ = *(_OWORD *)a4;
      *((_QWORD *)v57 + 6) = *(_QWORD *)(a4 + 16);
    }
    *((_DWORD *)v57 + 14) = *(_DWORD *)(a4 + 24);
    *(_QWORD *)v57 = 0;
    *((_QWORD *)v57 + 1) = 0;
    *((_QWORD *)v57 + 2) = v6;
    *v22 = v57;
    v69 = *(_QWORD *)*v7;
    if (v69)
    {
      *v7 = v69;
      v57 = (char *)*v22;
    }
    result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v7[1], (uint64_t *)v57);
    ++v7[2];
  }
  return result;
}

void sub_180E7C940(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(*((_QWORD *)a1 + 1));
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

uint64_t **std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  int v7;
  size_t v8;
  const void *v9;
  uint64_t **v10;
  _QWORD *v11;
  const void *v12;
  const void *v13;
  int v14;
  size_t v15;
  const void *v16;
  size_t v17;
  int v18;
  _BOOL4 v19;
  int v20;
  _BOOL4 v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *((char *)a2 + 23);
    if (v7 >= 0)
      v8 = *((unsigned __int8 *)a2 + 23);
    else
      v8 = (size_t)a2[1];
    if (v7 >= 0)
      v9 = a2;
    else
      v9 = *a2;
    while (1)
    {
      while (1)
      {
        v10 = (uint64_t **)v5;
        v13 = (const void *)v5[4];
        v11 = v5 + 4;
        v12 = v13;
        v14 = *((char *)v11 + 23);
        if (v14 >= 0)
          v15 = *((unsigned __int8 *)v11 + 23);
        else
          v15 = v11[1];
        if (v14 >= 0)
          v16 = v11;
        else
          v16 = v12;
        if (v15 >= v8)
          v17 = v8;
        else
          v17 = v15;
        v18 = memcmp(v9, v16, v17);
        v19 = v8 < v15;
        if (v18)
          v19 = v18 < 0;
        if (!v19)
          break;
        v5 = *v10;
        v6 = v10;
        if (!*v10)
          goto LABEL_27;
      }
      v20 = memcmp(v16, v9, v17);
      v21 = v15 < v8;
      if (v20)
        v21 = v20 < 0;
      if (!v21)
        break;
      v5 = v10[1];
      if (!v5)
      {
        v6 = v10 + 1;
        goto LABEL_27;
      }
    }
  }
  else
  {
    v10 = a1 + 1;
LABEL_27:
    v22 = (uint64_t *)v10;
    v10 = (uint64_t **)operator new(0x40uLL);
    *((_OWORD *)v10 + 2) = *(_OWORD *)a3;
    v10[6] = *(uint64_t **)(a3 + 16);
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *((_DWORD *)v10 + 14) = 0;
    *v10 = 0;
    v10[1] = 0;
    v10[2] = v22;
    *v6 = (uint64_t *)v10;
    v23 = (uint64_t *)**a1;
    v24 = (uint64_t *)v10;
    if (v23)
    {
      *a1 = v23;
      v24 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v24);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v10;
}

void `anonymous namespace'::GeneratedRewriter64::~GeneratedRewriter64(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter64::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter64 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  uint64_t v8;
  mlir::MLIRContext *v9;
  uint64_t UnknownLoc;
  uint64_t v11;
  int v12;
  uint64_t *v13;
  mlir::GenericProgramPoint *v14;
  unsigned int v15;
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  void *v21;
  char *v22;
  uint64_t *v23;
  void **v24;
  void **v25;
  void *v26;
  uint64_t v27;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *v33[2];
  char v34;
  void *v35[2];
  char v36;
  char **v37;
  char *v38[2];
  void *v39[2];
  char v40;
  uint64_t v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  _BYTE v46[17];
  void *v47[2];
  char v48;
  int v49;
  void *v50[2];
  char v51;
  int v52;
  void *v53[2];
  char v54;
  int v55;
  void *v56[2];
  char v57;
  int v58;
  void *v59[2];
  char v60;
  int v61;
  void *v62[2];
  char v63;
  int v64;
  void *v65[2];
  char v66;
  int v67;
  void *__p;
  __int128 v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  v8 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "updates");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "mode");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v9);
    v11 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v40 = 4;
    strcpy((char *)v39, "axis");
    MIL::IROperation::TryGetParameterValue();
    v12 = MIL::IRValue::GetScalar<int>();
    v13 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v11, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v13, v12);
    v14 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)&__p);
    v48 = 3;
    LODWORD(v47[0]) = 6579297;
    v51 = 3;
    v49 = 0;
    LODWORD(v50[0]) = 6452595;
    v54 = 3;
    v52 = 1;
    LODWORD(v53[0]) = 7107949;
    v57 = 3;
    v55 = 2;
    LODWORD(v56[0]) = 7760228;
    v60 = 3;
    v58 = 3;
    LODWORD(v59[0]) = 7235949;
    v61 = 4;
    v63 = 3;
    LODWORD(v62[0]) = 7889261;
    v66 = 6;
    v64 = 5;
    strcpy((char *)v65, "update");
    v67 = 6;
    v38[0] = 0;
    v38[1] = 0;
    v37 = v38;
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v47, (uint64_t)v47);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v50, (uint64_t)v50);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v53, (uint64_t)v53);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v56, (uint64_t)v56);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v59, (uint64_t)v59);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v62, (uint64_t)v62);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v65, (uint64_t)v65);
    v34 = 4;
    strcpy((char *)v33, "mode");
    MIL::IROperation::TryGetParameterValue();
    MIL::IRValue::GetScalar<std::string>();
    v15 = *((_DWORD *)std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v37, (const void **)v35, (uint64_t)v35)+ 14);
    v41 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
    v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter", (const unsigned __int8 *)0xB, Context);
    if (!v18)
    {
      v45 = 1283;
      v44[2] = (uint64_t)"mps.scatter";
      v44[3] = 11;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v43 = 259;
      llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)v46);
      llvm::report_fatal_error((llvm::Twine *)v46, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v17);
    if (!*((_DWORD *)v14 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ScatterOp::build(a3 + 13, (uint64_t)&__p, ArgValue, v8, v7, (uint64_t)v14 - 16, v15);
    v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v19)
    {
      v20 = llvm::DefaultDoCastIfPossible<mlir::mps::ScatterOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
      if (v20)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v36 < 0)
        {
          operator delete(v35[0]);
          if ((v34 & 0x80000000) == 0)
          {
LABEL_8:
            std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v38[0]);
            if ((v66 & 0x80000000) == 0)
              goto LABEL_9;
            goto LABEL_31;
          }
        }
        else if ((v34 & 0x80000000) == 0)
        {
          goto LABEL_8;
        }
        operator delete(v33[0]);
        std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v38[0]);
        if ((v66 & 0x80000000) == 0)
        {
LABEL_9:
          if ((v63 & 0x80000000) == 0)
            goto LABEL_10;
          goto LABEL_32;
        }
LABEL_31:
        operator delete(v65[0]);
        if ((v63 & 0x80000000) == 0)
        {
LABEL_10:
          if ((v60 & 0x80000000) == 0)
            goto LABEL_11;
          goto LABEL_33;
        }
LABEL_32:
        operator delete(v62[0]);
        if ((v60 & 0x80000000) == 0)
        {
LABEL_11:
          if ((v57 & 0x80000000) == 0)
            goto LABEL_12;
          goto LABEL_34;
        }
LABEL_33:
        operator delete(v59[0]);
        if ((v57 & 0x80000000) == 0)
        {
LABEL_12:
          if ((v54 & 0x80000000) == 0)
            goto LABEL_13;
          goto LABEL_35;
        }
LABEL_34:
        operator delete(v56[0]);
        if ((v54 & 0x80000000) == 0)
        {
LABEL_13:
          if ((v51 & 0x80000000) == 0)
            goto LABEL_14;
          goto LABEL_36;
        }
LABEL_35:
        operator delete(v53[0]);
        if ((v51 & 0x80000000) == 0)
        {
LABEL_14:
          if ((v48 & 0x80000000) == 0)
            goto LABEL_15;
          goto LABEL_37;
        }
LABEL_36:
        operator delete(v50[0]);
        if ((v48 & 0x80000000) == 0)
        {
LABEL_15:
          if ((v40 & 0x80000000) == 0)
          {
LABEL_16:
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
            if (!*(_DWORD *)(v20 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v21 = __p;
            v22 = (char *)operator new(8uLL);
            *(_QWORD *)v22 = v20 - 16;
            v47[0] = v21;
            v23 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v21, (uint64_t)&std::piecewise_construct, (__int128 **)v47);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v23 + 5, v22, v22 + 8, 1uLL);
            operator delete(v22);
            v24 = (void **)__p;
            if (__p)
            {
              v25 = (void **)v69;
              v26 = __p;
              if ((void *)v69 != __p)
              {
                do
                {
                  if (*((char *)v25 - 1) < 0)
                    operator delete(*(v25 - 3));
                  v25 -= 3;
                }
                while (v25 != v24);
                v26 = __p;
              }
              *(_QWORD *)&v69 = v24;
              operator delete(v26);
            }
            return 1;
          }
LABEL_38:
          operator delete(v39[0]);
          goto LABEL_16;
        }
LABEL_37:
        operator delete(v47[0]);
        if ((v40 & 0x80000000) == 0)
          goto LABEL_16;
        goto LABEL_38;
      }
      v29 = "result && \"builder didn't return the right type\"";
      v30 = 497;
      v31 = "Builders.h";
      v32 = "create";
    }
    else
    {
      v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v30 = 662;
      v31 = "Casting.h";
      v32 = "dyn_cast";
    }
    __assert_rtn(v32, v31, v30, v29);
  }
  __p = operator new(0x40uLL);
  v69 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v27 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v69) < 0)
    operator delete(__p);
  return v27;
}

void sub_180E7D26C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  char a70;

  if (a70 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ScatterOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x746163732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x726574746163732ELL)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.scatter";
      v8[3] = 11;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter65::~GeneratedRewriter65(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter65::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter65 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  uint64_t v8;
  mlir::MLIRContext *v9;
  uint64_t UnknownLoc;
  uint64_t v11;
  int v12;
  uint64_t *v13;
  mlir::GenericProgramPoint *v14;
  unsigned int v15;
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  void *v21;
  char *v22;
  uint64_t *v23;
  void **v24;
  void **v25;
  void *v26;
  uint64_t v27;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *v33[2];
  char v34;
  void *v35[2];
  char v36;
  char **v37;
  char *v38[2];
  void *v39[2];
  char v40;
  uint64_t v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  _BYTE v46[17];
  void *v47[2];
  char v48;
  int v49;
  void *v50[2];
  char v51;
  int v52;
  void *v53[2];
  char v54;
  int v55;
  void *v56[2];
  char v57;
  int v58;
  void *v59[2];
  char v60;
  int v61;
  void *v62[2];
  char v63;
  int v64;
  void *v65[2];
  char v66;
  int v67;
  void *__p;
  __int128 v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  v8 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "updates");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "mode");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v9);
    v11 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v40 = 4;
    strcpy((char *)v39, "axis");
    MIL::IROperation::TryGetParameterValue();
    v12 = MIL::IRValue::GetScalar<int>();
    v13 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v11, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v13, v12);
    v14 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)&__p);
    v48 = 3;
    LODWORD(v47[0]) = 6579297;
    v51 = 3;
    v49 = 0;
    LODWORD(v50[0]) = 6452595;
    v54 = 3;
    v52 = 1;
    LODWORD(v53[0]) = 7107949;
    v57 = 3;
    v55 = 2;
    LODWORD(v56[0]) = 7760228;
    v60 = 3;
    v58 = 3;
    LODWORD(v59[0]) = 7235949;
    v61 = 4;
    v63 = 3;
    LODWORD(v62[0]) = 7889261;
    v66 = 6;
    v64 = 5;
    strcpy((char *)v65, "update");
    v67 = 6;
    v38[0] = 0;
    v38[1] = 0;
    v37 = v38;
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v47, (uint64_t)v47);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v50, (uint64_t)v50);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v53, (uint64_t)v53);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v56, (uint64_t)v56);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v59, (uint64_t)v59);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v62, (uint64_t)v62);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v65, (uint64_t)v65);
    v34 = 4;
    strcpy((char *)v33, "mode");
    MIL::IROperation::TryGetParameterValue();
    MIL::IRValue::GetScalar<std::string>();
    v15 = *((_DWORD *)std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v37, (const void **)v35, (uint64_t)v35)+ 14);
    v41 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
    v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter_along_axis", (const unsigned __int8 *)0x16, Context);
    if (!v18)
    {
      v45 = 1283;
      v44[2] = (uint64_t)"mps.scatter_along_axis";
      v44[3] = 22;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v43 = 259;
      llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)v46);
      llvm::report_fatal_error((llvm::Twine *)v46, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v17);
    if (!*((_DWORD *)v14 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::ScatterAlongAxisOp::build(a3 + 13, (uint64_t)&__p, ArgValue, v8, v7, (uint64_t)v14 - 16, v15);
    v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v19)
    {
      v20 = llvm::DefaultDoCastIfPossible<mlir::mps::ScatterAlongAxisOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterAlongAxisOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
      if (v20)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v36 < 0)
        {
          operator delete(v35[0]);
          if ((v34 & 0x80000000) == 0)
          {
LABEL_8:
            std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v38[0]);
            if ((v66 & 0x80000000) == 0)
              goto LABEL_9;
            goto LABEL_31;
          }
        }
        else if ((v34 & 0x80000000) == 0)
        {
          goto LABEL_8;
        }
        operator delete(v33[0]);
        std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v38[0]);
        if ((v66 & 0x80000000) == 0)
        {
LABEL_9:
          if ((v63 & 0x80000000) == 0)
            goto LABEL_10;
          goto LABEL_32;
        }
LABEL_31:
        operator delete(v65[0]);
        if ((v63 & 0x80000000) == 0)
        {
LABEL_10:
          if ((v60 & 0x80000000) == 0)
            goto LABEL_11;
          goto LABEL_33;
        }
LABEL_32:
        operator delete(v62[0]);
        if ((v60 & 0x80000000) == 0)
        {
LABEL_11:
          if ((v57 & 0x80000000) == 0)
            goto LABEL_12;
          goto LABEL_34;
        }
LABEL_33:
        operator delete(v59[0]);
        if ((v57 & 0x80000000) == 0)
        {
LABEL_12:
          if ((v54 & 0x80000000) == 0)
            goto LABEL_13;
          goto LABEL_35;
        }
LABEL_34:
        operator delete(v56[0]);
        if ((v54 & 0x80000000) == 0)
        {
LABEL_13:
          if ((v51 & 0x80000000) == 0)
            goto LABEL_14;
          goto LABEL_36;
        }
LABEL_35:
        operator delete(v53[0]);
        if ((v51 & 0x80000000) == 0)
        {
LABEL_14:
          if ((v48 & 0x80000000) == 0)
            goto LABEL_15;
          goto LABEL_37;
        }
LABEL_36:
        operator delete(v50[0]);
        if ((v48 & 0x80000000) == 0)
        {
LABEL_15:
          if ((v40 & 0x80000000) == 0)
          {
LABEL_16:
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
            if (!*(_DWORD *)(v20 + 36))
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            v21 = __p;
            v22 = (char *)operator new(8uLL);
            *(_QWORD *)v22 = v20 - 16;
            v47[0] = v21;
            v23 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v21, (uint64_t)&std::piecewise_construct, (__int128 **)v47);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v23 + 5, v22, v22 + 8, 1uLL);
            operator delete(v22);
            v24 = (void **)__p;
            if (__p)
            {
              v25 = (void **)v69;
              v26 = __p;
              if ((void *)v69 != __p)
              {
                do
                {
                  if (*((char *)v25 - 1) < 0)
                    operator delete(*(v25 - 3));
                  v25 -= 3;
                }
                while (v25 != v24);
                v26 = __p;
              }
              *(_QWORD *)&v69 = v24;
              operator delete(v26);
            }
            return 1;
          }
LABEL_38:
          operator delete(v39[0]);
          goto LABEL_16;
        }
LABEL_37:
        operator delete(v47[0]);
        if ((v40 & 0x80000000) == 0)
          goto LABEL_16;
        goto LABEL_38;
      }
      v29 = "result && \"builder didn't return the right type\"";
      v30 = 497;
      v31 = "Builders.h";
      v32 = "create";
    }
    else
    {
      v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v30 = 662;
      v31 = "Casting.h";
      v32 = "dyn_cast";
    }
    __assert_rtn(v32, v31, v30, v29);
  }
  __p = operator new(0x40uLL);
  v69 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v27 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v69) < 0)
    operator delete(__p);
  return v27;
}

void sub_180E7DC58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  char a70;

  if (a70 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ScatterAlongAxisOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterAlongAxisOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 22
      && *AttrData == 0x746163732E73706DLL
      && AttrData[1] == 0x6E6F6C615F726574
      && *(_QWORD *)((char *)AttrData + 14) == 0x736978615F676E6FLL)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.scatter_along_axis";
      v9[3] = 22;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter66::~GeneratedRewriter66(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter66::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter66 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  uint64_t IntegerType;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t UnitAttr;
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  __int128 *v17;
  char *v18;
  uint64_t *v19;
  void **v20;
  void **v21;
  void *v22;
  uint64_t v23;
  const char *v25;
  int v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  __int16 v31;
  uint64_t v32[4];
  __int16 v33;
  __int128 *v34[5];
  void *__p;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 0);
    v9 = mlir::IntegerAttr::get(IntegerType, 0);
    UnitAttr = mlir::Builder::getUnitAttr(a3 + 13, v10);
    v29 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v29);
    v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather_nd", (const unsigned __int8 *)0xD, Context);
    if (!v14)
    {
      v33 = 1283;
      v32[2] = (uint64_t)"mps.gather_nd";
      v32[3] = 13;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v31 = 259;
      llvm::operator+(v32, (uint64_t *)&v30, (uint64_t)v34);
      llvm::report_fatal_error((llvm::Twine *)v34, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v13);
    mlir::mps::GatherNDOp::build(a3 + 13, (uint64_t)&__p, ArgValue, v7, v9, UnitAttr);
    v15 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v15)
    {
      v16 = llvm::DefaultDoCastIfPossible<mlir::mps::GatherNDOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherNDOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
      if (v16)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v16 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v17 = (__int128 *)__p;
        v18 = (char *)operator new(8uLL);
        *(_QWORD *)v18 = v16 - 16;
        v34[0] = v17;
        v19 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v17, (uint64_t)&std::piecewise_construct, v34);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v19 + 5, v18, v18 + 8, 1uLL);
        operator delete(v18);
        v20 = (void **)__p;
        if (__p)
        {
          v21 = (void **)v36;
          v22 = __p;
          if ((void *)v36 != __p)
          {
            do
            {
              if (*((char *)v21 - 1) < 0)
                operator delete(*(v21 - 3));
              v21 -= 3;
            }
            while (v21 != v20);
            v22 = __p;
          }
          *(_QWORD *)&v36 = v20;
          operator delete(v22);
        }
        return 1;
      }
      v25 = "result && \"builder didn't return the right type\"";
      v26 = 497;
      v27 = "Builders.h";
      v28 = "create";
    }
    else
    {
      v25 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v26 = 662;
      v27 = "Casting.h";
      v28 = "dyn_cast";
    }
    __assert_rtn(v28, v27, v26, v25);
  }
  __p = operator new(0x40uLL);
  v36 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v23 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v36) < 0)
    operator delete(__p);
  return v23;
}

void sub_180E7E2EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E7E300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E7E358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GatherNDOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherNDOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 13 && *AttrData == 0x687461672E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x646E5F7265687461)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.gather_nd";
      v8[3] = 13;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GatherNDOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter67::~GeneratedRewriter67(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter67::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter67 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  mlir::MLIRContext *v8;
  uint64_t UnknownLoc;
  uint64_t v10;
  int v11;
  uint64_t *v12;
  mlir::GenericProgramPoint *v13;
  uint64_t IntegerType;
  uint64_t v15;
  mlir::MLIRContext *v16;
  uint64_t UnitAttr;
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  uint64_t v22;
  __int128 *v23;
  char *v24;
  uint64_t *v25;
  void **v26;
  void **v27;
  void *v28;
  uint64_t v29;
  const char *v31;
  int v32;
  const char *v33;
  const char *v34;
  void *__p[2];
  char v36;
  uint64_t v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  __int128 *v42[5];
  void *Constant;
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v8);
    v10 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v36 = 4;
    strcpy((char *)__p, "axis");
    MIL::IROperation::TryGetParameterValue();
    v11 = MIL::IRValue::GetScalar<int>();
    v12 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v10, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v12, v11);
    v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)&Constant);
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 13), 0x20u, 0);
    v15 = mlir::IntegerAttr::get(IntegerType, 0);
    UnitAttr = mlir::Builder::getUnitAttr(a3 + 13, v16);
    v37 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v37);
    v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather", (const unsigned __int8 *)0xA, Context);
    if (!v20)
    {
      v41 = 1283;
      v40[2] = (uint64_t)"mps.gather";
      v40[3] = 10;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)v42);
      llvm::report_fatal_error((llvm::Twine *)v42, 1);
    }
    mlir::OperationState::OperationState(&Constant, LocationForOp, v19);
    if (!*((_DWORD *)v13 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::GatherOp::build(a3 + 13, (uint64_t)&Constant, ArgValue, v7, (uint64_t)v13 - 16, v15, UnitAttr);
    v21 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&Constant);
    if (v21)
    {
      v22 = llvm::DefaultDoCastIfPossible<mlir::mps::GatherOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
      if (v22)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&Constant);
        if (v36 < 0)
          operator delete(__p[0]);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&Constant, a2);
        if (!*(_DWORD *)(v22 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v23 = (__int128 *)Constant;
        v24 = (char *)operator new(8uLL);
        *(_QWORD *)v24 = v22 - 16;
        v42[0] = v23;
        v25 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v23, (uint64_t)&std::piecewise_construct, v42);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v25 + 5, v24, v24 + 8, 1uLL);
        operator delete(v24);
        v26 = (void **)Constant;
        if (Constant)
        {
          v27 = (void **)v44;
          v28 = Constant;
          if ((void *)v44 != Constant)
          {
            do
            {
              if (*((char *)v27 - 1) < 0)
                operator delete(*(v27 - 3));
              v27 -= 3;
            }
            while (v27 != v26);
            v28 = Constant;
          }
          *(_QWORD *)&v44 = v26;
          operator delete(v28);
        }
        return 1;
      }
      v31 = "result && \"builder didn't return the right type\"";
      v32 = 497;
      v33 = "Builders.h";
      v34 = "create";
    }
    else
    {
      v31 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v32 = 662;
      v33 = "Casting.h";
      v34 = "dyn_cast";
    }
    __assert_rtn(v34, v33, v32, v31);
  }
  Constant = operator new(0x40uLL);
  v44 = xmmword_18125E6C0;
  strcpy((char *)Constant, "The number of outputs does not match the number of results.");
  v29 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&Constant);
  if (SHIBYTE(v44) < 0)
    operator delete(Constant);
  return v29;
}

void sub_180E7E924(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GatherOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(_QWORD *)AttrData == 0x687461672E73706DLL && *(_WORD *)(AttrData + 8) == 29285)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.gather";
      v8[3] = 10;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GatherOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter68::~GeneratedRewriter68(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter68::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter68 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  uint64_t v7;
  mlir::MLIRContext *v8;
  uint64_t UnknownLoc;
  uint64_t v10;
  int v11;
  uint64_t *v12;
  mlir::GenericProgramPoint *v13;
  mlir::MLIRContext *v14;
  uint64_t UnitAttr;
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  __int128 *v21;
  char *v22;
  uint64_t *v23;
  void **v24;
  void **v25;
  void *v26;
  uint64_t v27;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *__p[2];
  char v34;
  uint64_t v35;
  const char *v36;
  __int16 v37;
  uint64_t v38[4];
  __int16 v39;
  __int128 *v40[5];
  void *Constant;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v8);
    v10 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v34 = 4;
    strcpy((char *)__p, "axis");
    MIL::IROperation::TryGetParameterValue();
    v11 = MIL::IRValue::GetScalar<int>();
    v12 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v10, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v12, v11);
    v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)&Constant);
    UnitAttr = mlir::Builder::getUnitAttr(a3 + 13, v14);
    v35 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v35);
    v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather_along_axis", (const unsigned __int8 *)0x15, Context);
    if (!v18)
    {
      v39 = 1283;
      v38[2] = (uint64_t)"mps.gather_along_axis";
      v38[3] = 21;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v37 = 259;
      llvm::operator+(v38, (uint64_t *)&v36, (uint64_t)v40);
      llvm::report_fatal_error((llvm::Twine *)v40, 1);
    }
    mlir::OperationState::OperationState(&Constant, LocationForOp, v17);
    if (!*((_DWORD *)v13 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::GatherAlongAxisOp::build((uint64_t)(a3 + 13), (uint64_t)&Constant, ArgValue, v7, (uint64_t)v13 - 16, UnitAttr);
    v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&Constant);
    if (v19)
    {
      v20 = llvm::DefaultDoCastIfPossible<mlir::mps::GatherAlongAxisOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherAlongAxisOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
      if (v20)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&Constant);
        if (v34 < 0)
          operator delete(__p[0]);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&Constant, a2);
        if (!*(_DWORD *)(v20 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v21 = (__int128 *)Constant;
        v22 = (char *)operator new(8uLL);
        *(_QWORD *)v22 = v20 - 16;
        v40[0] = v21;
        v23 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v21, (uint64_t)&std::piecewise_construct, v40);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v23 + 5, v22, v22 + 8, 1uLL);
        operator delete(v22);
        v24 = (void **)Constant;
        if (Constant)
        {
          v25 = (void **)v42;
          v26 = Constant;
          if ((void *)v42 != Constant)
          {
            do
            {
              if (*((char *)v25 - 1) < 0)
                operator delete(*(v25 - 3));
              v25 -= 3;
            }
            while (v25 != v24);
            v26 = Constant;
          }
          *(_QWORD *)&v42 = v24;
          operator delete(v26);
        }
        return 1;
      }
      v29 = "result && \"builder didn't return the right type\"";
      v30 = 497;
      v31 = "Builders.h";
      v32 = "create";
    }
    else
    {
      v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v30 = 662;
      v31 = "Casting.h";
      v32 = "dyn_cast";
    }
    __assert_rtn(v32, v31, v30, v29);
  }
  Constant = operator new(0x40uLL);
  v42 = xmmword_18125E6C0;
  strcpy((char *)Constant, "The number of outputs does not match the number of results.");
  v27 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&Constant);
  if (SHIBYTE(v42) < 0)
    operator delete(Constant);
  return v27;
}

void sub_180E7EF34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GatherAlongAxisOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherAlongAxisOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x687461672E73706DLL
      && AttrData[1] == 0x676E6F6C615F7265
      && *(_QWORD *)((char *)AttrData + 13) == 0x736978615F676E6FLL)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.gather_along_axis";
      v9[3] = 21;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GatherAlongAxisOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter69::~GeneratedRewriter69(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter69::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter69 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axes");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E7F368(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter70::~GeneratedRewriter70(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter70::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter70 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::GenericProgramPoint *v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "shape");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "value");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &v18, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = (char *)v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E7F658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter71::~GeneratedRewriter71(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter71::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter71 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  mlir::GenericProgramPoint *v7;
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  __int128 *v13;
  char *v14;
  uint64_t *v15;
  void **v16;
  void **v17;
  void *v18;
  uint64_t v19;
  const char *v21;
  int v22;
  const char *v23;
  const char *v24;
  uint64_t ArgValue;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  __int128 *v31[5];
  void *__p;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "ref_tensor");
  v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "value");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v7 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue);
    v26 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
    v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, Context);
    if (!v10)
    {
      v30 = 1283;
      v29[2] = (uint64_t)"mps.broadcast_to";
      v29[3] = 16;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v28 = 259;
      llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
      llvm::report_fatal_error((llvm::Twine *)v31, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v9);
    if (!*((_DWORD *)v7 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::BroadcastToOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, v6, (uint64_t)v7 - 16);
    v11 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v11)
    {
      v12 = llvm::DefaultDoCastIfPossible<mlir::mps::BroadcastToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BroadcastToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
      if (v12)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v12 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v13 = (__int128 *)__p;
        v14 = (char *)operator new(8uLL);
        *(_QWORD *)v14 = v12 - 16;
        v31[0] = v13;
        v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v13, (uint64_t)&std::piecewise_construct, v31);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v15 + 5, v14, v14 + 8, 1uLL);
        operator delete(v14);
        v16 = (void **)__p;
        if (__p)
        {
          v17 = (void **)v33;
          v18 = __p;
          if ((void *)v33 != __p)
          {
            do
            {
              if (*((char *)v17 - 1) < 0)
                operator delete(*(v17 - 3));
              v17 -= 3;
            }
            while (v17 != v16);
            v18 = __p;
          }
          *(_QWORD *)&v33 = v16;
          operator delete(v18);
        }
        return 1;
      }
      v21 = "result && \"builder didn't return the right type\"";
      v22 = 497;
      v23 = "Builders.h";
      v24 = "create";
    }
    else
    {
      v21 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v22 = 662;
      v23 = "Casting.h";
      v24 = "dyn_cast";
    }
    __assert_rtn(v24, v23, v22, v21);
  }
  __p = operator new(0x40uLL);
  v33 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v19 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v33) < 0)
    operator delete(__p);
  return v19;
}

void sub_180E7FA8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E7FAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter72::~GeneratedRewriter72(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter72::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter72 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t v6;
  __int128 *v7;
  char *v8;
  uint64_t *v9;
  void **v10;
  void **v11;
  void *v12;
  uint64_t result;
  uint64_t v14;
  void *__p;
  __int128 v16;
  uint64_t ArgValue;
  uint64_t v18;
  __int128 *v19;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "perm");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    v6 = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 13), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v7 = (__int128 *)__p;
    v8 = (char *)operator new(8uLL);
    *(_QWORD *)v8 = v6 - 16;
    v19 = v7;
    v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0)
            operator delete(*(v11 - 3));
          v11 -= 3;
        }
        while (v11 != v10);
        v12 = __p;
      }
      *(_QWORD *)&v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    v16 = xmmword_18125E6C0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180E7FDBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v12;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _BYTE v23[40];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.permute";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::PermuteOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_8;
  }
  v12 = llvm::DefaultDoCastIfPossible<mlir::mps::PermuteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PermuteOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180E7FF74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E7FF8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter73::~GeneratedRewriter73(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter73::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter73 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::MLIRContext *v6;
  uint64_t UnknownLoc;
  uint64_t v8;
  uint64_t *v9;
  mlir::MLIRContext *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  mlir::MLIRContext *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  __int128 *v19;
  char *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  unsigned __int8 v27;
  unsigned int v28;
  mlir::GenericProgramPoint *v29;
  mlir::GenericProgramPoint *v30;
  _BYTE __p[24];
  uint64_t ArgValue;
  mlir::GenericProgramPoint *v33;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "block_size");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v6);
    v8 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v9 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v8, 0);
    *(_QWORD *)__p = mlir::mps::getConstantAttr<int>(v9, -1);
    v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)__p);
    v11 = mlir::Builder::getUnknownLoc(a3 + 13, v10);
    v12 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v13 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v12, 0);
    *(_QWORD *)__p = mlir::mps::getConstantAttr<int>(v13, -2);
    v30 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v11, (uint64_t **)__p);
    v15 = mlir::Builder::getUnknownLoc(a3 + 13, v14);
    v16 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v17 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v16, 0);
    *(_QWORD *)__p = mlir::mps::getConstantAttr<int>(v17, -3);
    v29 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v15, (uint64_t **)__p);
    __p[23] = 10;
    strcpy(__p, "block_size");
    MIL::IROperation::TryGetParameterValue();
    v28 = MIL::IRValue::GetScalar<int>();
    v27 = 0;
    v18 = mlir::OpBuilder::create<mlir::mps::DepthToSpace2DOp,mlir::Value &,mlir::mps::ConstantOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp,int,BOOL>((mlir::Builder *)(a3 + 13), LocationForOp, &ArgValue, (uint64_t)&v33, (uint64_t)&v30, (uint64_t)&v29, &v28, &v27);
    if ((__p[23] & 0x80000000) != 0)
      operator delete(*(void **)__p);
    (*(void (**)(_BYTE *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
    if (!*(_DWORD *)(v18 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v19 = *(__int128 **)__p;
    v20 = (char *)operator new(8uLL);
    *(_QWORD *)v20 = v18 - 16;
    v33 = (mlir::GenericProgramPoint *)v19;
    v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v19, (uint64_t)&std::piecewise_construct, (__int128 **)&v33);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v21 + 5, v20, v20 + 8, 1uLL);
    operator delete(v20);
    v22 = *(_QWORD *)__p;
    if (*(_QWORD *)__p)
    {
      v23 = *(_QWORD *)&__p[8];
      v24 = *(void **)__p;
      if (*(_QWORD *)&__p[8] != *(_QWORD *)__p)
      {
        do
        {
          if (*(char *)(v23 - 1) < 0)
            operator delete(*(void **)(v23 - 24));
          v23 -= 24;
        }
        while (v23 != v22);
        v24 = *(void **)__p;
      }
      *(_QWORD *)&__p[8] = v22;
      operator delete(v24);
    }
    return 1;
  }
  else
  {
    *(_QWORD *)__p = operator new(0x40uLL);
    *(_OWORD *)&__p[8] = xmmword_18125E6C0;
    strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
    v25 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    if ((__p[23] & 0x80000000) != 0)
      operator delete(*(void **)__p);
  }
  return v25;
}

void sub_180E80378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E803D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthToSpace2DOp,mlir::Value &,mlir::mps::ConstantOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp,int,BOOL>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int *a7, unsigned __int8 *a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v20;
  const char *v22;
  int v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _BYTE v31[40];
  _QWORD v32[39];

  v32[38] = *MEMORY[0x1E0C80C00];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depth_to_space_2d", (const unsigned __int8 *)0x15, Context);
  if (!v18)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"mps.depth_to_space_2d";
    v29[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  if (!*(_DWORD *)(*(_QWORD *)a4 + 36) || !*(_DWORD *)(*(_QWORD *)a5 + 36) || !*(_DWORD *)(*(_QWORD *)a6 + 36))
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  mlir::mps::DepthToSpace2DOp::build(a1, (uint64_t)v32, *a3, *(_QWORD *)a4 - 16, *(_QWORD *)a5 - 16, *(_QWORD *)a6 - 16, *a7, *a8);
  v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    v23 = 662;
    v24 = "Casting.h";
    v25 = "dyn_cast";
    goto LABEL_12;
  }
  v20 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthToSpace2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthToSpace2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    v22 = "result && \"builder didn't return the right type\"";
    v23 = 497;
    v24 = "Builders.h";
    v25 = "create";
LABEL_12:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180E805DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

void sub_180E805F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a26);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DepthToSpace2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthToSpace2DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x747065642E73706DLL
      && AttrData[1] == 0x6170735F6F745F68
      && *(_QWORD *)((char *)AttrData + 13) == 0x64325F6563617073)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.depth_to_space_2d";
      v9[3] = 21;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DepthToSpace2DOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter74::~GeneratedRewriter74(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter74::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter74 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  mlir::MLIRContext *v7;
  uint64_t UnknownLoc;
  uint64_t v9;
  uint64_t *v10;
  mlir::GenericProgramPoint *v11;
  mlir::MLIRContext *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  mlir::GenericProgramPoint *v16;
  mlir::MLIRContext *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  mlir::GenericProgramPoint *v21;
  unsigned int v22;
  uint64_t *Context;
  uint64_t v24;
  char v25;
  mlir::GenericProgramPoint *v26;
  uint64_t v27;
  __int128 *v28;
  char *v29;
  uint64_t *v30;
  void **v31;
  void **v32;
  void *v33;
  uint64_t v34;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *__p[2];
  char v41;
  uint64_t v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  __int128 *v47[5];
  void *Constant;
  __int128 v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "block_size");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v7);
    v9 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v10 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v9, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v10, -1);
    v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)&Constant);
    v13 = mlir::Builder::getUnknownLoc(a3 + 13, v12);
    v14 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v15 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v14, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v15, -2);
    v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v13, (uint64_t **)&Constant);
    v18 = mlir::Builder::getUnknownLoc(a3 + 13, v17);
    v19 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v20 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v19, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v20, -3);
    v21 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v18, (uint64_t **)&Constant);
    v41 = 10;
    strcpy((char *)__p, "block_size");
    MIL::IROperation::TryGetParameterValue();
    v22 = MIL::IRValue::GetScalar<int>();
    v42 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v42);
    v24 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_depth_2d", (const unsigned __int8 *)0x15, Context);
    if (!v25)
    {
      v46 = 1283;
      v45[2] = (uint64_t)"mps.space_to_depth_2d";
      v45[3] = 21;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)v47);
      llvm::report_fatal_error((llvm::Twine *)v47, 1);
    }
    mlir::OperationState::OperationState(&Constant, LocationForOp, v24);
    if (!*((_DWORD *)v11 + 9) || !*((_DWORD *)v16 + 9) || !*((_DWORD *)v21 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::SpaceToDepth2DOp::build((mlir::Builder *)(a3 + 13), (uint64_t)&Constant, ArgValue, (uint64_t)v11 - 16, (uint64_t)v16 - 16, (uint64_t)v21 - 16, v22, 0);
    v26 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&Constant);
    if (v26)
    {
      v27 = llvm::DefaultDoCastIfPossible<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v26);
      if (v27)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&Constant);
        if (v41 < 0)
          operator delete(__p[0]);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&Constant, a2);
        if (!*(_DWORD *)(v27 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v28 = (__int128 *)Constant;
        v29 = (char *)operator new(8uLL);
        *(_QWORD *)v29 = v27 - 16;
        v47[0] = v28;
        v30 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v28, (uint64_t)&std::piecewise_construct, v47);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v30 + 5, v29, v29 + 8, 1uLL);
        operator delete(v29);
        v31 = (void **)Constant;
        if (Constant)
        {
          v32 = (void **)v49;
          v33 = Constant;
          if ((void *)v49 != Constant)
          {
            do
            {
              if (*((char *)v32 - 1) < 0)
                operator delete(*(v32 - 3));
              v32 -= 3;
            }
            while (v32 != v31);
            v33 = Constant;
          }
          *(_QWORD *)&v49 = v31;
          operator delete(v33);
        }
        return 1;
      }
      v36 = "result && \"builder didn't return the right type\"";
      v37 = 497;
      v38 = "Builders.h";
      v39 = "create";
    }
    else
    {
      v36 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v37 = 662;
      v38 = "Casting.h";
      v39 = "dyn_cast";
    }
    __assert_rtn(v39, v38, v37, v36);
  }
  Constant = operator new(0x40uLL);
  v49 = xmmword_18125E6C0;
  strcpy((char *)Constant, "The number of outputs does not match the number of results.");
  v34 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&Constant);
  if (SHIBYTE(v49) < 0)
    operator delete(Constant);
  return v34;
}

void sub_180E80C44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v7;
  __int16 v8;
  uint64_t v9[4];
  __int16 v10;
  _QWORD v11[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x636170732E73706DLL
      && AttrData[1] == 0x7065645F6F745F65
      && *(_QWORD *)((char *)AttrData + 13) == 0x64325F6874706564)
    {
      v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.space_to_depth_2d";
      v9[3] = 21;
      v7 = "' failed due to the operation not being registered";
      v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SpaceToDepth2DOp,void>::id)
  {
    return 0;
  }
  return result;
}

void `anonymous namespace'::GeneratedRewriter75::~GeneratedRewriter75(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter75::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter75 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  mlir::MLIRContext *v6;
  uint64_t UnknownLoc;
  uint64_t v8;
  uint64_t *v9;
  mlir::MLIRContext *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  mlir::MLIRContext *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  __int128 *v19;
  char *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  unsigned __int8 v27;
  unsigned int v28;
  mlir::GenericProgramPoint *v29;
  mlir::GenericProgramPoint *v30;
  _BYTE __p[24];
  uint64_t ArgValue;
  mlir::GenericProgramPoint *v33;

  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "upscale_factor");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v6);
    v8 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v9 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v8, 0);
    *(_QWORD *)__p = mlir::mps::getConstantAttr<int>(v9, -1);
    v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)__p);
    v11 = mlir::Builder::getUnknownLoc(a3 + 13, v10);
    v12 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v13 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v12, 0);
    *(_QWORD *)__p = mlir::mps::getConstantAttr<int>(v13, -2);
    v30 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v11, (uint64_t **)__p);
    v15 = mlir::Builder::getUnknownLoc(a3 + 13, v14);
    v16 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v17 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v16, 0);
    *(_QWORD *)__p = mlir::mps::getConstantAttr<int>(v17, -3);
    v29 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v15, (uint64_t **)__p);
    __p[23] = 14;
    strcpy(__p, "upscale_factor");
    MIL::IROperation::TryGetParameterValue();
    v28 = MIL::IRValue::GetScalar<int>();
    v27 = 1;
    v18 = mlir::OpBuilder::create<mlir::mps::DepthToSpace2DOp,mlir::Value &,mlir::mps::ConstantOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp,int,BOOL>((mlir::Builder *)(a3 + 13), LocationForOp, &ArgValue, (uint64_t)&v33, (uint64_t)&v30, (uint64_t)&v29, &v28, &v27);
    if ((__p[23] & 0x80000000) != 0)
      operator delete(*(void **)__p);
    (*(void (**)(_BYTE *__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(__p, a2);
    if (!*(_DWORD *)(v18 + 36))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    v19 = *(__int128 **)__p;
    v20 = (char *)operator new(8uLL);
    *(_QWORD *)v20 = v18 - 16;
    v33 = (mlir::GenericProgramPoint *)v19;
    v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v19, (uint64_t)&std::piecewise_construct, (__int128 **)&v33);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v21 + 5, v20, v20 + 8, 1uLL);
    operator delete(v20);
    v22 = *(_QWORD *)__p;
    if (*(_QWORD *)__p)
    {
      v23 = *(_QWORD *)&__p[8];
      v24 = *(void **)__p;
      if (*(_QWORD *)&__p[8] != *(_QWORD *)__p)
      {
        do
        {
          if (*(char *)(v23 - 1) < 0)
            operator delete(*(void **)(v23 - 24));
          v23 -= 24;
        }
        while (v23 != v22);
        v24 = *(void **)__p;
      }
      *(_QWORD *)&__p[8] = v22;
      operator delete(v24);
    }
    return 1;
  }
  else
  {
    *(_QWORD *)__p = operator new(0x40uLL);
    *(_OWORD *)&__p[8] = xmmword_18125E6C0;
    strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
    v25 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    if ((__p[23] & 0x80000000) != 0)
      operator delete(*(void **)__p);
  }
  return v25;
}

void sub_180E811A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180E81204(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::GeneratedRewriter76::~GeneratedRewriter76(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter76::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter76 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  mlir::MLIRContext *v7;
  uint64_t UnknownLoc;
  uint64_t v9;
  uint64_t *v10;
  mlir::GenericProgramPoint *v11;
  mlir::MLIRContext *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  mlir::GenericProgramPoint *v16;
  mlir::MLIRContext *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  mlir::GenericProgramPoint *v21;
  unsigned int v22;
  uint64_t *Context;
  uint64_t v24;
  char v25;
  mlir::GenericProgramPoint *v26;
  uint64_t v27;
  __int128 *v28;
  char *v29;
  uint64_t *v30;
  void **v31;
  void **v32;
  void *v33;
  uint64_t v34;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  char __p[17];
  char v41;
  uint64_t v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  __int128 *v47[5];
  void *Constant;
  __int128 v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "downscale_factor");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v7);
    v9 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v10 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v9, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v10, -1);
    v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)&Constant);
    v13 = mlir::Builder::getUnknownLoc(a3 + 13, v12);
    v14 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v15 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v14, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v15, -2);
    v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v13, (uint64_t **)&Constant);
    v18 = mlir::Builder::getUnknownLoc(a3 + 13, v17);
    v19 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v20 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v19, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v20, -3);
    v21 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v18, (uint64_t **)&Constant);
    v41 = 16;
    strcpy(__p, "downscale_factor");
    MIL::IROperation::TryGetParameterValue();
    v22 = MIL::IRValue::GetScalar<unsigned int>();
    v42 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v42);
    v24 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_depth_2d", (const unsigned __int8 *)0x15, Context);
    if (!v25)
    {
      v46 = 1283;
      v45[2] = (uint64_t)"mps.space_to_depth_2d";
      v45[3] = 21;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)v47);
      llvm::report_fatal_error((llvm::Twine *)v47, 1);
    }
    mlir::OperationState::OperationState(&Constant, LocationForOp, v24);
    if (!*((_DWORD *)v11 + 9) || !*((_DWORD *)v16 + 9) || !*((_DWORD *)v21 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::SpaceToDepth2DOp::build((mlir::Builder *)(a3 + 13), (uint64_t)&Constant, ArgValue, (uint64_t)v11 - 16, (uint64_t)v16 - 16, (uint64_t)v21 - 16, v22, 1);
    v26 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&Constant);
    if (v26)
    {
      v27 = llvm::DefaultDoCastIfPossible<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v26);
      if (v27)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&Constant);
        if (v41 < 0)
          operator delete(*(void **)__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&Constant, a2);
        if (!*(_DWORD *)(v27 + 36))
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        v28 = (__int128 *)Constant;
        v29 = (char *)operator new(8uLL);
        *(_QWORD *)v29 = v27 - 16;
        v47[0] = v28;
        v30 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v28, (uint64_t)&std::piecewise_construct, v47);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v30 + 5, v29, v29 + 8, 1uLL);
        operator delete(v29);
        v31 = (void **)Constant;
        if (Constant)
        {
          v32 = (void **)v49;
          v33 = Constant;
          if ((void *)v49 != Constant)
          {
            do
            {
              if (*((char *)v32 - 1) < 0)
                operator delete(*(v32 - 3));
              v32 -= 3;
            }
            while (v32 != v31);
            v33 = Constant;
          }
          *(_QWORD *)&v49 = v31;
          operator delete(v33);
        }
        return 1;
      }
      v36 = "result && \"builder didn't return the right type\"";
      v37 = 497;
      v38 = "Builders.h";
      v39 = "create";
    }
    else
    {
      v36 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v37 = 662;
      v38 = "Casting.h";
      v39 = "dyn_cast";
    }
    __assert_rtn(v39, v38, v37, v36);
  }
  Constant = operator new(0x40uLL);
  v49 = xmmword_18125E6C0;
  strcpy((char *)Constant, "The number of outputs does not match the number of results.");
  v34 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&Constant);
  if (SHIBYTE(v49) < 0)
    operator delete(Constant);
  return v34;
}

void sub_180E8174C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::GeneratedRewriter77::~GeneratedRewriter77(void **this)
{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = &unk_1E0E138C8;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x186DA1680);
}

uint64_t `anonymous namespace'::GeneratedRewriter77::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter77 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp;
  uint64_t ArgValue;
  mlir::MLIRContext *v7;
  uint64_t UnknownLoc;
  uint64_t v9;
  int v10;
  uint64_t *v11;
  mlir::GenericProgramPoint *v12;
  mlir::MLIRContext *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t *Context;
  uint64_t v20;
  char v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v23;
  __int128 *v24;
  char *v25;
  uint64_t *v26;
  void **v27;
  void **v28;
  void *v29;
  uint64_t v30;
  const char *v32;
  int v33;
  const char *v34;
  const char *v35;
  void *v36[2];
  char v37;
  void *v38[2];
  char v39;
  uint64_t v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  __int128 *v45[5];
  void *__p;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "lower");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "upper");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(_QWORD *)a2 + 192))(a2) == 1)
  {
    UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 13, v7);
    v9 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v39 = 5;
    strcpy((char *)v38, "lower");
    MIL::IROperation::TryGetParameterValue();
    v10 = MIL::IRValue::GetScalar<int>();
    v11 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v9, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v11, v10);
    v12 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), UnknownLoc, (uint64_t **)&__p);
    v14 = mlir::Builder::getUnknownLoc(a3 + 13, v13);
    v15 = mlir::IntegerType::get((uint64_t)a3[13], 0x20u, 1u);
    v37 = 5;
    strcpy((char *)v36, "upper");
    MIL::IROperation::TryGetParameterValue();
    v16 = MIL::IRValue::GetScalar<int>();
    v17 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v15, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v17, v16);
    v18 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 13), v14, (uint64_t **)&__p);
    v40 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v40);
    v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.band_part", (const unsigned __int8 *)0xD, Context);
    if (!v21)
    {
      v44 = 1283;
      v43[2] = (uint64_t)"mps.band_part";
      v43[3] = 13;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)v45);
      llvm::report_fatal_error((llvm::Twine *)v45, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v20);
    if (!*((_DWORD *)v12 + 9) || !*((_DWORD *)v18 + 9))
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    mlir::mps::BandPartOp::build((uint64_t)(a3 + 13), (uint64_t)&__p, ArgValue, (uint64_t)v12 - 16, (uint64_t)v18 - 16);
    v22 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 13), (const mlir::OperationState *)&__p);
    if (v22)
    {
      v23 = llvm::DefaultDoCastIfPossible<mlir::mps::BandPartOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BandPartOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v22);
      if (v23)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v37 < 0)
        {
          operator delete(v36[0]);
          if ((v39 & 0x80000000) == 0)
            goto LABEL_9;
        }
        else if ((v39 & 0x80000000) == 0)
        {
LABEL_9:
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(_QWORD *)a2 + 200))(&__p, a2);
          if (!*(_DWORD *)(v23 + 36))
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          v24 = (__int128 *)__p;
          v25 = (char *)operator new(8uLL);
          *(_QWORD *)v25 = v23 - 16;
          v45[0] = v24;
          v26 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v24, (uint64_t)&std::piecewise_construct, v45);
          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v26 + 5, v25, v25 + 8, 1uLL);
          operator delete(v25);
          v27 = (void **)__p;
          if (__p)
          {
            v28 = (void **)v47;
            v29 = __p;
            if ((void *)v47 != __p)
            {
              do
              {
                if (*((char *)v28 - 1) < 0)
                  operator delete(*(v28 - 3));
                v28 -= 3;
              }
              while (v28 != v27);
              v29 = __p;
            }
            *(_QWORD *)&v47 = v27;
            operator delete(v29);
          }
          return 1;
        }
        operator delete(v38[0]);
        goto LABEL_9;
      }
      v32 = "result && \"builder didn't return the right type\"";
      v33 = 497;
      v34 = "Builders.h";
      v35 = "create";
    }
    else
    {
      v32 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      v33 = 662;
      v34 = "Casting.h";
      v35 = "dyn_cast";
    }
    __assert_rtn(v35, v34, v33, v32);
  }
  __p = operator new(0x40uLL);
  v47 = xmmword_18125E6C0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  v30 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v47) < 0)
    operator delete(__p);
  return v30;
}

void sub_180E81D14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::BandPartOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BandPartOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  _QWORD *AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 13 && *AttrData == 0x646E61622E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x747261705F646E61)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.band_part";
      v8[3] = 13;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::BandPartOp,void>::id)
  {
    return 0;
  }
  return result;
}

void MILToMLIRRewriter::~MILToMLIRRewriter(MILToMLIRRewriter *this)
{
  char *v2;
  void *v3;
  void **v4;
  void *v5;
  char *v6;
  void *v7;
  void **v8;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2)
  {
    do
    {
      v6 = *(char **)v2;
      v7 = (void *)*((_QWORD *)v2 + 5);
      if (v7)
      {
        *((_QWORD *)v2 + 6) = v7;
        operator delete(v7);
      }
      if (v2[39] < 0)
        operator delete(*((void **)v2 + 2));
      operator delete(v2);
      v2 = v6;
    }
    while (v6);
  }
  v3 = (void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  if (v3)
    operator delete(v3);
  v4 = (void **)*((_QWORD *)this + 5);
  if (v4)
  {
    do
    {
      v8 = (void **)*v4;
      if (*((char *)v4 + 39) < 0)
        operator delete(v4[2]);
      operator delete(v4);
      v4 = v8;
    }
    while (v8);
  }
  v5 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0;
  if (v5)
    operator delete(v5);
}

void EmitViewerSPI::initializeOps(EmitViewerSPI *this)
{
  int8x8_t *v1;
  unint64_t v2;
  int8x8_t *v3;
  int8x8_t v4;
  uint64_t v5;
  void **v6;
  uint64_t v7;
  unsigned __int8 *v8;
  void **v9;
  int v10;
  uint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint8x8_t v15;
  unint64_t v16;
  uint64_t **v17;
  uint64_t *v18;
  char v19;
  void *v20;
  unint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  void *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  int v31;
  float v32;
  float v33;
  _BOOL8 v34;
  unint64_t v35;
  unint64_t v36;
  size_t v37;
  unint64_t v38;
  uint8x8_t v39;
  uint64_t v40;
  int8x8_t v41;
  unint64_t v42;
  uint8x8_t v43;
  int8x8_t *v44;
  void **v45;
  unint64_t v46;
  uint64_t i;
  void **v48;
  uint64_t Context;
  id WeakRetained;
  BOOL v51;
  llvm *v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  std::string::value_type **v56;
  int v57;
  std::string::value_type *v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint8x8_t v63;
  uint64_t **v64;
  uint64_t *v65;
  char v66;
  std::string::value_type *v67;
  std::string::value_type *v68;
  unint64_t v69;
  uint64_t v70;
  std::string::value_type *v71;
  const void **v72;
  std::string::value_type *v73;
  uint64_t v74;
  uint64_t v75;
  std::string::value_type *v76;
  const void **v77;
  std::string::value_type *v78;
  char *v79;
  std::string *v80;
  float v81;
  float v82;
  _BOOL8 v83;
  unint64_t v84;
  unint64_t v85;
  size_t prime;
  int8x8_t v87;
  unint64_t v88;
  uint8x8_t v89;
  uint64_t v90;
  unint64_t v91;
  int8x8_t *v92;
  int8x8_t *v93;
  unint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  id *v97;
  BOOL v98;
  uint64_t v99;
  _BYTE **v100;
  uint64_t v101;
  int8x8_t v102;
  unint64_t v103;
  unint64_t v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  mlir::GenericProgramPoint *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  _QWORD *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  MPSGraphViewerNodeSPI *v123;
  uint64_t MPSDataType;
  void *v125;
  MPSGraphViewerNodePortSPI *v126;
  void *v127;
  MPSGraphViewerNodeSPI *v128;
  unint64_t Body;
  uint64_t j;
  uint64_t v131;
  mlir::GenericProgramPoint *v132;
  mlir::GenericProgramPoint *v133;
  MPSGraphViewerNodePortSPI *v134;
  void *v135;
  const char *AttrData;
  size_t v137;
  size_t v138;
  __int128 *p_dst;
  uint64_t v140;
  uint64_t v141;
  void *v142;
  int v143;
  const char *v144;
  const char *v145;
  const char *v146;
  const char *v147;
  int v148;
  const char *v149;
  const char *v150;
  void *v151;
  int8x8_t *v152;
  int8x8_t *v153;
  mlir::GenericProgramPoint *v154;
  int8x8_t *v155;
  mlir::GenericProgramPoint *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  _OWORD v160[2];
  uint64_t v161;
  __int128 __dst;
  __int128 v163;
  uint64_t v164;
  uint64_t v165;
  MPSGraphViewerNodePortSPI *v166;
  _QWORD v167[3];
  _QWORD *v168;
  _QWORD v169[3];
  _QWORD *v170;
  _BYTE *v171[2];
  char v172;
  int v173;
  char v174[24];
  int v175;
  char v176[24];
  int v177;
  char v178[24];
  int v179;
  char v180[24];
  int v181;
  char v182[24];
  int v183;
  char v184[24];
  int v185;
  char v186[24];
  int v187;
  char v188[24];
  int v189;
  char v190[24];
  int v191;
  char v192[24];
  int v193;
  char v194[24];
  int v195;
  char v196[24];
  int v197;
  char v198[24];
  int v199;
  char v200[24];
  int v201;
  char v202[24];
  int v203;
  char v204[24];
  int v205;
  char v206[24];
  int v207;
  char v208[24];
  int v209;
  char v210[24];
  int v211;
  char v212[24];
  int v213;
  char v214[24];
  int v215;
  char v216[24];
  int v217;
  char v218[24];
  int v219;
  char v220[24];
  int v221;
  char v222[24];
  int v223;
  char v224[24];
  int v225;
  char v226[24];
  int v227;
  char v228[24];
  int v229;
  char *v230;
  uint64_t v231;
  unint64_t v232;
  int v233;
  char *v234;
  uint64_t v235;
  unint64_t v236;
  int v237;
  char v238[24];
  int v239;
  char v240[24];
  int v241;
  char v242[24];
  int v243;
  char *v244;
  uint64_t v245;
  unint64_t v246;
  int v247;
  char v248[24];
  int v249;
  char v250[24];
  int v251;
  char v252[24];
  int v253;
  char v254[23];
  char v255[9];
  char v256[24];
  int v257;
  char v258[24];
  int v259;
  char v260[23];
  char v261[9];
  char v262[24];
  int v263;
  char v264[24];
  int v265;
  char v266[24];
  int v267;
  char v268[24];
  int v269;
  char v270[23];
  char v271[9];
  char v272[24];
  int v273;
  char v274[23];
  char v275[9];
  char *v276;
  uint64_t v277;
  unint64_t v278;
  int v279;
  char v280[24];
  int v281;
  char v282[23];
  char v283[9];
  char *v284;
  uint64_t v285;
  unint64_t v286;
  int v287;
  char *v288;
  uint64_t v289;
  unint64_t v290;
  int v291;
  char v292[24];
  int v293;
  char v294[24];
  int v295;
  char v296[24];
  int v297;
  char v298[24];
  int v299;
  char v300[24];
  int v301;
  char v302[24];
  int v303;
  char v304[23];
  char v305[9];
  char v306[24];
  int v307;
  char v308[24];
  int v309;
  char v310[24];
  int v311;
  char v312[24];
  int v313;
  char v314[24];
  int v315;
  char v316[24];
  int v317;
  char v318[23];
  char v319[9];
  char v320[24];
  int v321;
  char v322[24];
  int v323;
  char v324[24];
  int v325;
  char v326[24];
  int v327;
  char v328[24];
  int v329;
  char v330[23];
  char v331[9];
  char v332[24];
  int v333;
  char v334[24];
  int v335;
  char v336[24];
  int v337;
  char v338[24];
  int v339;
  char v340[24];
  int v341;
  char v342[23];
  char v343[9];
  char v344[24];
  int v345;
  char v346[24];
  int v347;
  char v348[24];
  int v349;
  char v350[24];
  int v351;
  char v352[24];
  int v353;
  char v354[23];
  char v355[9];
  char v356[23];
  char v357[9];
  char v358[23];
  char v359[9];
  char v360[23];
  char v361[9];
  char v362[23];
  char v363[9];
  char v364[24];
  int v365;
  char v366[23];
  char v367[9];
  char v368[24];
  int v369;
  char *v370;
  uint64_t v371;
  unint64_t v372;
  int v373;
  char v374[24];
  int v375;
  char v376[23];
  char v377[9];
  char v378[24];
  int v379;
  char v380[23];
  char v381[9];
  char v382[23];
  char v383[9];
  char v384[24];
  int v385;
  char v386[23];
  char v387[9];
  char v388[24];
  int v389;
  char v390[24];
  int v391;
  char v392[24];
  int v393;
  char v394[24];
  int v395;
  char v396[24];
  int v397;
  char v398[24];
  int v399;
  char v400[24];
  int v401;
  char v402[24];
  int v403;
  char v404[24];
  int v405;
  char v406[24];
  int v407;
  char v408[24];
  int v409;
  char v410[24];
  int v411;
  char v412[24];
  int v413;
  char v414[24];
  int v415;
  char *v416;
  uint64_t v417;
  unint64_t v418;
  int v419;
  char v420[24];
  int v421;
  char *v422;
  uint64_t v423;
  unint64_t v424;
  int v425;
  char v426[24];
  int v427;
  char v428[24];
  int v429;
  char v430[24];
  int v431;
  char v432[24];
  int v433;
  char v434[23];
  char v435[9];
  char v436[24];
  int v437;
  char v438[23];
  char v439[9];
  char v440[24];
  int v441;
  char v442[24];
  int v443;
  char *v444;
  uint64_t v445;
  unint64_t v446;
  int v447;
  char v448[24];
  int v449;
  char *v450;
  uint64_t v451;
  unint64_t v452;
  int v453;
  char *v454;
  uint64_t v455;
  unint64_t v456;
  int v457;
  char v458[24];
  int v459;
  char *v460;
  uint64_t v461;
  unint64_t v462;
  int v463;
  char v464[24];
  int v465;
  char v466[24];
  int v467;
  char v468[24];
  int v469;
  char v470[24];
  int v471;
  char *v472;
  uint64_t v473;
  unint64_t v474;
  int v475;
  char v476[24];
  int v477;
  char v478[24];
  int v479;
  char v480[24];
  int v481;
  char v482[24];
  int v483;
  char v484[24];
  int v485;
  char v486[24];
  int v487;
  char v488[24];
  int v489;
  char v490[24];
  int v491;
  char *v492;
  uint64_t v493;
  unint64_t v494;
  int v495;
  char v496[24];
  int v497;
  char *v498;
  uint64_t v499;
  unint64_t v500;
  int v501;
  char *v502;
  uint64_t v503;
  unint64_t v504;
  int v505;
  char v506[24];
  int v507;
  char *v508;
  uint64_t v509;
  unint64_t v510;
  int v511;
  char v512[24];
  int v513;
  char v514[24];
  int v515;
  char v516[24];
  int v517;
  char v518[24];
  int v519;
  char v520[24];
  int v521;
  char v522[24];
  int v523;
  char v524[24];
  int v525;
  char v526[24];
  int v527;
  char v528[24];
  int v529;
  char v530[24];
  int v531;
  char v532[24];
  int v533;
  char v534[24];
  int v535;
  char v536[24];
  int v537;
  char *v538;
  uint64_t v539;
  unint64_t v540;
  int v541;
  char v542[24];
  int v543;
  char v544[24];
  int v545;
  char v546[24];
  int v547;
  char v548[24];
  int v549;
  char v550[24];
  int v551;
  char v552[24];
  int v553;
  char v554[24];
  int v555;
  char v556[24];
  int v557;
  char v558[24];
  int v559;
  char v560[24];
  int v561;
  char v562[24];
  int v563;
  char v564[24];
  int v565;
  char v566[24];
  int v567;
  char *v568;
  uint64_t v569;
  unint64_t v570;
  int v571;
  char v572[24];
  int v573;
  char v574[24];
  int v575;
  char v576[24];
  int v577;
  char *v578;
  uint64_t v579;
  unint64_t v580;
  int v581;
  char v582[24];
  int v583;
  char v584[24];
  int v585;
  char v586[24];
  int v587;
  char v588[24];
  int v589;
  char v590[24];
  int v591;
  char v592[24];
  int v593;
  char v594[24];
  int v595;
  char v596[24];
  int v597;
  char v598[24];
  int v599;
  char v600[24];
  int v601;
  char *v602;
  uint64_t v603;
  unint64_t v604;
  int v605;
  char v606[24];
  int v607;
  char *v608;
  uint64_t v609;
  unint64_t v610;
  int v611;
  char v612[24];
  int v613;
  char v614[24];
  int v615;
  char v616[24];
  int v617;
  char v618[24];
  int v619;
  char *v620;
  uint64_t v621;
  unint64_t v622;
  int v623;
  char *v624;
  uint64_t v625;
  unint64_t v626;
  int v627;
  char v628[24];
  int v629;
  char v630[24];
  int v631;
  char v632[24];
  int v633;
  char v634[24];
  int v635;
  char v636[24];
  int v637;
  char v638[24];
  int v639;
  char v640[24];
  int v641;
  char v642[24];
  int v643;
  char v644[24];
  int v645;
  char *v646;
  uint64_t v647;
  unint64_t v648;
  int v649;
  char v650[24];
  int v651;
  char v652[24];
  int v653;
  char v654[24];
  int v655;
  char v656[24];
  int v657;
  char v658[24];
  int v659;
  char v660[24];
  int v661;
  char v662[24];
  int v663;
  char v664[24];
  int v665;
  char v666[24];
  int v667;
  char v668[24];
  int v669;
  char v670[24];
  int v671;
  char v672[24];
  int v673;
  char *v674;
  uint64_t v675;
  unint64_t v676;
  int v677;
  char v678[24];
  int v679;
  char *v680;
  uint64_t v681;
  unint64_t v682;
  int v683;
  char v684[24];
  int v685;
  char *v686;
  uint64_t v687;
  unint64_t v688;
  int v689;
  char v690[24];
  int v691;
  char v692[24];
  int v693;
  char v694[24];
  int v695;
  char v696[24];
  int v697;
  char v698[24];
  int v699;
  char v700[24];
  int v701;
  char *v702;
  uint64_t v703;
  unint64_t v704;
  int v705;
  char v706[24];
  int v707;
  char v708[24];
  int v709;
  char v710[24];
  int v711;
  char v712[24];
  int v713;
  char *v714;
  uint64_t v715;
  unint64_t v716;
  int v717;
  char v718[24];
  int v719;
  char *v720;
  uint64_t v721;
  unint64_t v722;
  int v723;
  char v724[24];
  int v725;
  char v726[24];
  int v727;
  char v728[24];
  int v729;
  char *v730;
  uint64_t v731;
  unint64_t v732;
  int v733;
  char v734[24];
  int v735;
  char v736[24];
  int v737;
  char v738[24];
  int v739;
  char v740[24];
  int v741;
  char v742[24];
  int v743;
  char v744[24];
  int v745;
  char v746[24];
  int v747;
  char v748[24];
  int v749;
  char v750[24];
  int v751;
  char v752[24];
  int v753;
  char v754[24];
  int v755;
  char v756[24];
  int v757;
  char v758[24];
  int v759;
  char v760[24];
  int v761;
  char v762[24];
  int v763;
  char v764[24];
  int v765;
  char v766[24];
  int v767;
  char *v768;
  uint64_t v769;
  unint64_t v770;
  int v771;
  char v772[24];
  int v773;
  char v774[24];
  int v775;
  char v776[24];
  int v777;
  char v778[24];
  int v779;
  char v780[24];
  int v781;
  char v782[24];
  int v783;
  char v784[24];
  int v785;
  char *v786;
  uint64_t v787;
  unint64_t v788;
  int v789;
  char v790[24];
  int v791;
  char v792[24];
  int v793;
  char v794[24];
  int v795;
  char v796[24];
  int v797;
  char v798[24];
  int v799;
  char *v800;
  uint64_t v801;
  unint64_t v802;
  int v803;
  char v804[24];
  int v805;
  char v806[24];
  int v807;
  char v808[24];
  int v809;
  char v810[24];
  int v811;
  char v812[24];
  int v813;
  char v814[24];
  int v815;
  char *v816;
  uint64_t v817;
  unint64_t v818;
  int v819;
  char v820[24];
  int v821;
  char v822[24];
  int v823;
  char v824[24];
  int v825;
  char v826[24];
  int v827;
  char v828[24];
  int v829;
  char v830[24];
  int v831;
  char v832[24];
  int v833;
  char v834[24];
  int v835;
  char v836[24];
  int v837;
  char *v838;
  uint64_t v839;
  unint64_t v840;
  int v841;
  char v842[24];
  int v843;
  char *v844;
  uint64_t v845;
  unint64_t v846;
  int v847;
  char v848[24];
  int v849;
  char v850[24];
  int v851;
  char v852[24];
  int v853;
  char v854[24];
  int v855;
  char v856[24];
  int v857;
  char v858[24];
  int v859;
  char v860[24];
  int v861;
  char v862[24];
  int v863;
  char v864[24];
  int v865;
  char v866[24];
  int v867;
  char v868[24];
  int v869;
  char v870[24];
  int v871;
  char *v872;
  uint64_t v873;
  unint64_t v874;
  int v875;
  char *v876;
  uint64_t v877;
  unint64_t v878;
  int v879;
  char v880[24];
  int v881;
  char v882[24];
  int v883;
  char v884[24];
  int v885;
  char v886[24];
  int v887;
  _DWORD v888[5];
  char v889;
  int v890;
  char v891[24];
  int v892;
  char v893[24];
  int v894;
  char v895[24];
  int v896;
  char v897[24];
  int v898;
  char v899[24];
  int v900;
  char v901[24];
  int v902;
  char v903[24];
  int v904;
  char v905[24];
  int v906;
  char v907[24];
  int v908;
  char v909[24];
  int v910;
  char v911[24];
  int v912;
  char *v913;
  uint64_t v914;
  unint64_t v915;
  int v916;
  char v917[24];
  int v918;
  char v919[24];
  int v920;
  char v921[24];
  int v922;
  char v923[24];
  int v924;
  char v925[24];
  int v926;
  char v927[24];
  int v928;
  char v929[24];
  int v930;
  char v931[24];
  int v932;
  char v933[24];
  int v934;
  char v935[24];
  int v936;
  char v937[24];
  int v938;
  char *v939;
  uint64_t v940;
  unint64_t v941;
  int v942;
  char v943[24];
  int v944;
  char v945[24];
  int v946;
  char v947[24];
  int v948;
  char *v949;
  uint64_t v950;
  unint64_t v951;
  int v952;
  char *v953;
  uint64_t v954;
  unint64_t v955;
  int v956;
  char v957[24];
  int v958;
  char v959[24];
  int v960;
  char v961[24];
  int v962;
  char v963[24];
  int v964;
  char v965[24];
  int v966;
  char *v967;
  uint64_t v968;
  unint64_t v969;
  int v970;
  char v971[23];
  char v972;
  int v973;
  uint64_t v974;

  v1 = (int8x8_t *)MEMORY[0x1E0C80A78](this);
  v974 = *MEMORY[0x1E0C80C00];
  v172 = 14;
  strcpy((char *)v171, "anec.A11Legacy");
  v173 = 1;
  v174[23] = 8;
  strcpy(v174, "anec.A12");
  v175 = 2;
  v176[23] = 8;
  strcpy(v176, "anec.A13");
  v177 = 3;
  v178[23] = 8;
  strcpy(v178, "anec.A14");
  v179 = 4;
  v180[23] = 8;
  strcpy(v180, "anec.A15");
  v181 = 5;
  v182[23] = 8;
  strcpy(v182, "anec.A16");
  v183 = 6;
  v184[23] = 8;
  strcpy(v184, "anec.A17");
  v185 = 7;
  v186[23] = 16;
  strcpy(v186, "anec.arg_min_max");
  v187 = 8;
  v188[23] = 17;
  strcpy(v188, "anec.average_pool");
  v189 = 9;
  v190[23] = 19;
  strcpy(v190, "anec.batch_to_space");
  v191 = 10;
  v192[23] = 14;
  strcpy(v192, "anec.broadcast");
  v193 = 11;
  v194[23] = 9;
  strcpy(v194, "anec.cast");
  v195 = 12;
  v196[23] = 9;
  strcpy(v196, "anec.ceil");
  v197 = 13;
  v198[23] = 21;
  strcpy(v198, "anec.channel_to_space");
  v199 = 14;
  v200[23] = 17;
  strcpy(v200, "anec.clamped_relu");
  v201 = 15;
  v202[23] = 11;
  strcpy(v202, "anec.concat");
  v203 = 16;
  v204[23] = 16;
  strcpy(v204, "anec.convolution");
  v205 = 17;
  v206[23] = 8;
  strcpy(v206, "anec.cos");
  v207 = 18;
  v208[23] = 16;
  strcpy(v208, "anec.crop_resize");
  v209 = 19;
  v210[23] = 12;
  strcpy(v210, "anec.dequant");
  v211 = 20;
  v212[23] = 18;
  strcpy(v212, "anec.deconvolution");
  v213 = 21;
  v214[23] = 12;
  strcpy(v214, "anec.degamma");
  v215 = 22;
  v216[23] = 10;
  strcpy(v216, "anec.dirac");
  v217 = 23;
  v218[23] = 8;
  strcpy(v218, "anec.abs");
  v219 = 24;
  v220[23] = 8;
  strcpy(v220, "anec.add");
  v221 = 25;
  v222[23] = 8;
  strcpy(v222, "anec.div");
  v223 = 26;
  v224[23] = 10;
  strcpy(v224, "anec.equal");
  v225 = 27;
  v226[23] = 15;
  strcpy(v226, "anec.equal_zero");
  v227 = 28;
  v228[23] = 17;
  strcpy(v228, "anec.greater_than");
  v229 = 29;
  v230 = (char *)operator new(0x19uLL);
  v232 = 0x8000000000000019;
  v231 = 23;
  strcpy(v230, "anec.greater_than_equal");
  v233 = 30;
  v234 = (char *)operator new(0x20uLL);
  v236 = 0x8000000000000020;
  v235 = 28;
  strcpy(v234, "anec.greater_than_equal_zero");
  v237 = 31;
  strcpy(v238, "anec.greater_than_zero");
  v238[23] = 22;
  v239 = 32;
  v240[23] = 14;
  strcpy(v240, "anec.less_than");
  v241 = 33;
  v242[23] = 20;
  strcpy(v242, "anec.less_than_equal");
  v243 = 34;
  v244 = (char *)operator new(0x20uLL);
  v246 = 0x8000000000000020;
  v245 = 25;
  strcpy(v244, "anec.less_than_equal_zero");
  v247 = 35;
  v248[23] = 19;
  strcpy(v248, "anec.less_than_zero");
  v249 = 36;
  v250[23] = 8;
  strcpy(v250, "anec.max");
  v251 = 37;
  v252[23] = 8;
  strcpy(v252, "anec.min");
  v253 = 38;
  strcpy(v255, "\t'");
  strcpy(v254, "anec.mult");
  *(_WORD *)&v255[3] = 0;
  v256[23] = 14;
  strcpy(v256, "anec.not_equal");
  v257 = 40;
  v258[23] = 19;
  strcpy(v258, "anec.not_equal_zero");
  v259 = 41;
  strcpy(v261, "\n*");
  strcpy(v260, "anec.power");
  *(_WORD *)&v261[3] = 0;
  v262[23] = 11;
  strcpy(v262, "anec.square");
  v263 = 43;
  v264[23] = 8;
  strcpy(v264, "anec.sub");
  v265 = 44;
  v266[23] = 8;
  strcpy(v266, "anec.elu");
  v267 = 45;
  v268[23] = 8;
  strcpy(v268, "anec.erf");
  v269 = 46;
  strcpy(v271, "\t/");
  strcpy(v270, "anec.exp2");
  *(_WORD *)&v271[3] = 0;
  v272[23] = 12;
  strcpy(v272, "anec.flatten");
  v273 = 48;
  strcpy(v275, "\n1");
  strcpy(v274, "anec.floor");
  *(_WORD *)&v275[3] = 0;
  v276 = (char *)operator new(0x20uLL);
  v278 = 0x8000000000000020;
  v277 = 24;
  strcpy(v276, "anec.gain_offset_control");
  v279 = 50;
  v280[23] = 14;
  strcpy(v280, "anec.gather_nd");
  v281 = 51;
  strcpy(v283, "\t4");
  strcpy(v282, "anec.gelu");
  *(_WORD *)&v283[3] = 0;
  v284 = (char *)operator new(0x19uLL);
  v286 = 0x8000000000000019;
  v285 = 23;
  strcpy(v284, "anec.global_arg_min_max");
  v287 = 53;
  v288 = (char *)operator new(0x20uLL);
  v290 = 0x8000000000000020;
  v289 = 27;
  strcpy(v288, "anec.high_precision_sigmoid");
  v291 = 54;
  v292[23] = 15;
  strcpy(v292, "anec.input_view");
  v293 = 55;
  v294[23] = 18;
  strcpy(v294, "anec.instance_norm");
  v295 = 56;
  v296[23] = 11;
  strcpy(v296, "anec.invert");
  v297 = 57;
  v298[23] = 16;
  strcpy(v298, "anec.l2norm_pool");
  v299 = 58;
  v300[23] = 15;
  strcpy(v300, "anec.leaky_relu");
  v301 = 59;
  v302[23] = 11;
  strcpy(v302, "anec.linear");
  v303 = 60;
  strcpy(v305, "\t=");
  strcpy(v304, "anec.log2");
  *(_WORD *)&v305[3] = 0;
  v306[23] = 11;
  strcpy(v306, "anec.matmul");
  v307 = 62;
  v308[23] = 13;
  strcpy(v308, "anec.max_pool");
  v309 = 63;
  v310[23] = 11;
  strcpy(v310, "anec.n_relu");
  v311 = 64;
  v312[23] = 12;
  strcpy(v312, "anec.padding");
  v313 = 65;
  v314[23] = 18;
  strcpy(v314, "anec.pixel_shuffle");
  v315 = 66;
  v316[23] = 20;
  strcpy(v316, "anec.pixel_unshuffle");
  v317 = 67;
  strcpy(v319, "\nD");
  strcpy(v318, "anec.quant");
  *(_WORD *)&v319[3] = 0;
  v320[23] = 15;
  strcpy(v320, "anec.reduce_avg");
  v321 = 69;
  v322[23] = 15;
  strcpy(v322, "anec.reduce_max");
  v323 = 70;
  v324[23] = 15;
  strcpy(v324, "anec.reduce_min");
  v325 = 71;
  v326[23] = 15;
  strcpy(v326, "anec.reduce_sum");
  v327 = 72;
  v328[23] = 18;
  strcpy(v328, "anec.region_return");
  v329 = 73;
  strcpy(v331, "\tJ");
  strcpy(v330, "anec.relu");
  *(_WORD *)&v331[3] = 0;
  v332[23] = 12;
  strcpy(v332, "anec.reshape");
  v333 = 75;
  v334[23] = 11;
  strcpy(v334, "anec.resize");
  v335 = 76;
  v336[23] = 18;
  strcpy(v336, "anec.round_nearest");
  v337 = 77;
  v338[23] = 11;
  strcpy(v338, "anec.r_sqrt");
  v339 = 78;
  v340[23] = 12;
  strcpy(v340, "anec.sigmoid");
  v341 = 79;
  strcpy(v343, "\tP");
  strcpy(v342, "anec.sign");
  *(_WORD *)&v343[3] = 0;
  v344[23] = 8;
  strcpy(v344, "anec.sin");
  v345 = 81;
  v346[23] = 12;
  strcpy(v346, "anec.softmax");
  v347 = 82;
  v348[23] = 19;
  strcpy(v348, "anec.space_to_batch");
  v349 = 83;
  v350[23] = 21;
  strcpy(v350, "anec.space_to_channel");
  v351 = 84;
  v352[23] = 8;
  strcpy(v352, "anec.sqr");
  v353 = 85;
  strcpy(v355, "\tV");
  strcpy(v354, "anec.sqrt");
  *(_WORD *)&v355[3] = 0;
  strcpy(v357, "\nW");
  strcpy(v356, "anec.swish");
  *(_WORD *)&v357[3] = 0;
  strcpy(v359, "\nX");
  strcpy(v358, "anec.A12r0");
  *(_WORD *)&v359[3] = 0;
  strcpy(v361, "\tY");
  strcpy(v360, "anec.tanh");
  *(_WORD *)&v361[3] = 0;
  strcpy(v363, "\tZ");
  strcpy(v362, "anec.tile");
  *(_WORD *)&v363[3] = 0;
  v364[23] = 14;
  strcpy(v364, "anec.transpose");
  v365 = 91;
  strcpy(v367, "\n\\");
  strcpy(v366, "anec.trunc");
  *(_WORD *)&v367[3] = 0;
  v368[23] = 14;
  strcpy(v368, "anec.unflatten");
  v369 = 93;
  v370 = (char *)operator new(0x20uLL);
  v372 = 0x8000000000000020;
  v371 = 31;
  strcpy(v370, "anec.unrealized_conversion_cast");
  v373 = 94;
  v374[23] = 8;
  strcpy(v374, "mps.acos");
  v375 = 95;
  strcpy(v376, "mps.acosh");
  *(_WORD *)&v377[3] = 0;
  v378[23] = 8;
  strcpy(v378, "mps.asin");
  v379 = 97;
  strcpy(v381, "\tb");
  strcpy(v380, "mps.asinh");
  *(_WORD *)&v381[3] = 0;
  strcpy(v383, "\tc");
  strcpy(v382, "mps.atan2");
  *(_WORD *)&v383[3] = 0;
  v384[23] = 8;
  strcpy(v384, "mps.atan");
  v385 = 100;
  strcpy(v387, "\te");
  strcpy(v386, "mps.atanh");
  *(_WORD *)&v387[3] = 0;
  v388[23] = 12;
  strcpy(v388, "mps.absolute");
  v389 = 102;
  v390[23] = 19;
  strcpy(v390, "mps.absolute_square");
  v391 = 103;
  v392[23] = 7;
  strcpy(v392, "mps.add");
  v393 = 104;
  v394[23] = 7;
  strcpy(v394, "mps.and");
  v395 = 105;
  v396[23] = 19;
  strcpy(v396, "mps.assign_variable");
  v397 = 106;
  v398[23] = 13;
  strcpy(v398, "mps.band_part");
  v399 = 107;
  v400[23] = 18;
  strcpy(v400, "mps.batch_to_space");
  v401 = 108;
  v402[23] = 17;
  strcpy(v402, "mps.bias_add_grad");
  v403 = 109;
  v404[23] = 12;
  strcpy(v404, "mps.bias_add");
  v405 = 110;
  v406[23] = 15;
  strcpy(v406, "mps.bitwise_and");
  v407 = 111;
  v408[23] = 22;
  strcpy(v408, "mps.bitwise_left_shift");
  v409 = 112;
  v410[23] = 15;
  strcpy(v410, "mps.bitwise_not");
  v411 = 113;
  v412[23] = 14;
  strcpy(v412, "mps.bitwise_or");
  v413 = 114;
  v414[23] = 20;
  strcpy(v414, "mps.bitwise_popcount");
  v415 = 115;
  v416 = (char *)operator new(0x19uLL);
  v418 = 0x8000000000000019;
  v417 = 23;
  strcpy(v416, "mps.bitwise_right_shift");
  v419 = 116;
  v420[23] = 15;
  strcpy(v420, "mps.bitwise_xor");
  v421 = 117;
  v422 = (char *)operator new(0x20uLL);
  v424 = 0x8000000000000020;
  v423 = 27;
  strcpy(v422, "mps.broadcast_gradient_args");
  v425 = 118;
  v426[23] = 16;
  strcpy(v426, "mps.broadcast_to");
  v427 = 119;
  v428[23] = 8;
  strcpy(v428, "mps.call");
  v429 = 120;
  v430[23] = 8;
  strcpy(v430, "mps.cast");
  v431 = 121;
  v432[23] = 8;
  strcpy(v432, "mps.ceil");
  v433 = 122;
  strcpy(v435, "\t{");
  strcpy(v434, "mps.clamp");
  *(_WORD *)&v435[3] = 0;
  v436[23] = 13;
  strcpy(v436, "mps.col_to_im");
  v437 = 124;
  strcpy(v439, "\n}");
  strcpy(v438, "mps.concat");
  *(_WORD *)&v439[3] = 0;
  v440[23] = 13;
  strcpy(v440, "mps.conjugate");
  v441 = 126;
  v442[23] = 12;
  strcpy(v442, "mps.constant");
  v443 = 127;
  v444 = (char *)operator new(0x20uLL);
  v446 = 0x8000000000000020;
  v445 = 25;
  strcpy(v444, "mps.conv_2d_data_gradient");
  v447 = 128;
  v448[23] = 11;
  strcpy(v448, "mps.conv_2d");
  v449 = 129;
  v450 = (char *)operator new(0x20uLL);
  v452 = 0x8000000000000020;
  v451 = 28;
  strcpy(v450, "mps.conv_2d_weights_gradient");
  v453 = 130;
  v454 = (char *)operator new(0x20uLL);
  v456 = 0x8000000000000020;
  v455 = 25;
  strcpy(v454, "mps.conv_3d_data_gradient");
  v457 = 131;
  v458[23] = 11;
  strcpy(v458, "mps.conv_3d");
  v459 = 132;
  v460 = (char *)operator new(0x20uLL);
  v462 = 0x8000000000000020;
  v461 = 28;
  strcpy(v460, "mps.conv_3d_weights_gradient");
  v463 = 133;
  v464[23] = 7;
  strcpy(v464, "mps.cos");
  v465 = 134;
  v466[23] = 8;
  strcpy(v466, "mps.cosh");
  v467 = 135;
  v468[23] = 15;
  strcpy(v468, "mps.cost_volume");
  v469 = 136;
  v470[23] = 18;
  strcpy(v470, "mps.create_complex");
  v471 = 137;
  v472 = (char *)operator new(0x20uLL);
  v474 = 0x8000000000000020;
  v473 = 25;
  strcpy(v472, "mps.create_texture_tensor");
  v475 = 138;
  v476[23] = 8;
  strcpy(v476, "mps.crop");
  v477 = 139;
  v478[23] = 15;
  strcpy(v478, "mps.crop_resize");
  v479 = 140;
  strcpy(v480, "mps.cumulative_maximum");
  v480[23] = 22;
  v481 = 141;
  strcpy(v482, "mps.cumulative_minimum");
  v482[23] = 22;
  v483 = 142;
  v484[23] = 22;
  strcpy(v484, "mps.cumulative_product");
  v485 = 143;
  v486[23] = 18;
  strcpy(v486, "mps.cumulative_sum");
  v487 = 144;
  v488[23] = 11;
  strcpy(v488, "mps.degamma");
  v489 = 145;
  v490[23] = 21;
  strcpy(v490, "mps.depth_to_space_2d");
  v491 = 146;
  v492 = (char *)operator new(0x28uLL);
  v494 = 0x8000000000000028;
  v493 = 35;
  strcpy(v492, "mps.depthwise_conv_2d_data_gradient");
  v495 = 147;
  v496[23] = 21;
  strcpy(v496, "mps.depthwise_conv_2d");
  v497 = 148;
  v498 = (char *)operator new(0x28uLL);
  v500 = 0x8000000000000028;
  v499 = 38;
  strcpy(v498, "mps.depthwise_conv_2d_weights_gradient");
  v501 = 149;
  v502 = (char *)operator new(0x28uLL);
  v504 = 0x8000000000000028;
  v503 = 35;
  strcpy(v502, "mps.depthwise_conv_3d_data_gradient");
  v505 = 150;
  v506[23] = 21;
  strcpy(v506, "mps.depthwise_conv_3d");
  v507 = 151;
  v508 = (char *)operator new(0x28uLL);
  v510 = 0x8000000000000028;
  v509 = 38;
  strcpy(v508, "mps.depthwise_conv_3d_weights_gradient");
  v511 = 152;
  v512[23] = 18;
  strcpy(v512, "mps.dequantize_lut");
  v513 = 153;
  v514[23] = 14;
  strcpy(v514, "mps.dequantize");
  v515 = 154;
  v516[23] = 18;
  strcpy(v516, "mps.dimension_size");
  v517 = 155;
  v518[23] = 9;
  strcpy(v518, "mps.dirac");
  v519 = 156;
  v520[23] = 10;
  strcpy(v520, "mps.divide");
  v521 = 157;
  strcpy(v522, "mps.dynamic_shape_cast");
  v522[23] = 22;
  v523 = 158;
  v524[23] = 7;
  strcpy(v524, "mps.elu");
  v525 = 159;
  v526[23] = 9;
  strcpy(v526, "mps.equal");
  v527 = 160;
  v528[23] = 7;
  strcpy(v528, "mps.erf");
  v529 = 161;
  v530[23] = 15;
  strcpy(v530, "mps.expand_dims");
  v531 = 162;
  v532[23] = 19;
  strcpy(v532, "mps.exponent_base_2");
  v533 = 163;
  v534[23] = 20;
  strcpy(v534, "mps.exponent_base_10");
  v535 = 164;
  v536[23] = 12;
  strcpy(v536, "mps.exponent");
  v537 = 165;
  v538 = (char *)operator new(0x20uLL);
  v539 = 26;
  v540 = 0x8000000000000020;
  strcpy(v538, "mps.fast_fourier_transform");
  v541 = 166;
  v542[23] = 14;
  strcpy(v542, "mps.flatten_2d");
  v543 = 167;
  v544[23] = 16;
  strcpy(v544, "mps.floor_divide");
  v545 = 168;
  v546[23] = 9;
  strcpy(v546, "mps.floor");
  v547 = 169;
  v548[23] = 16;
  strcpy(v548, "mps.gru_gradient");
  v549 = 170;
  v550[23] = 7;
  strcpy(v550, "mps.gru");
  v551 = 171;
  v552[23] = 21;
  strcpy(v552, "mps.gather_along_axis");
  v553 = 172;
  v554[23] = 13;
  strcpy(v554, "mps.gather_nd");
  v555 = 173;
  v556[23] = 10;
  strcpy(v556, "mps.gather");
  v557 = 174;
  v558[23] = 8;
  strcpy(v558, "mps.gelu");
  v559 = 175;
  v560[23] = 19;
  strcpy(v560, "mps.get_coordinates");
  v561 = 176;
  v562[23] = 11;
  strcpy(v562, "mps.greater");
  v563 = 177;
  v564[23] = 17;
  strcpy(v564, "mps.greater_equal");
  v565 = 178;
  v566[23] = 20;
  strcpy(v566, "mps.hamming_distance");
  v567 = 179;
  v568 = (char *)operator new(0x20uLL);
  v570 = 0x8000000000000020;
  v569 = 25;
  strcpy(v568, "mps.hermitean_to_real_fft");
  v571 = 180;
  v572[23] = 12;
  strcpy(v572, "mps.identity");
  v573 = 181;
  v574[23] = 13;
  strcpy(v574, "mps.im_to_col");
  v575 = 182;
  v576[23] = 18;
  strcpy(v576, "mps.imaginary_part");
  v577 = 183;
  v578 = (char *)operator new(0x20uLL);
  v580 = 0x8000000000000020;
  v579 = 28;
  strcpy(v578, "mps.init_random_philox_state");
  v581 = 184;
  v582[23] = 17;
  strcpy(v582, "mps.instance_norm");
  v583 = 185;
  v584[23] = 13;
  strcpy(v584, "mps.is_finite");
  v585 = 186;
  v586[23] = 15;
  strcpy(v586, "mps.is_infinite");
  v587 = 187;
  v588[23] = 10;
  strcpy(v588, "mps.is_nan");
  v589 = 188;
  v590[23] = 11;
  strcpy(v590, "mps.lp_norm");
  v591 = 189;
  v592[23] = 17;
  strcpy(v592, "mps.lstm_gradient");
  v593 = 190;
  v594[23] = 8;
  strcpy(v594, "mps.lstm");
  v595 = 191;
  v596[23] = 14;
  strcpy(v596, "mps.leaky_relu");
  v597 = 192;
  v598[23] = 8;
  strcpy(v598, "mps.less");
  v599 = 193;
  v600[23] = 14;
  strcpy(v600, "mps.less_equal");
  v601 = 194;
  v602 = (char *)operator new(0x28uLL);
  v604 = 0x8000000000000028;
  v603 = 35;
  strcpy(v602, "mps.local_convolution_data_gradient");
  v605 = 195;
  v606[23] = 21;
  strcpy(v606, "mps.local_convolution");
  v607 = 196;
  v608 = (char *)operator new(0x28uLL);
  v610 = 0x8000000000000028;
  v609 = 37;
  strcpy(v608, "mps.local_convolution_weight_gradient");
  v611 = 197;
  v612[23] = 20;
  strcpy(v612, "mps.logarithm_base_2");
  v613 = 198;
  v614[23] = 21;
  strcpy(v614, "mps.logarithm_base_10");
  v615 = 199;
  v616[23] = 13;
  strcpy(v616, "mps.logarithm");
  v617 = 200;
  v618[23] = 10;
  strcpy(v618, "mps.matmul");
  v619 = 201;
  v620 = (char *)operator new(0x20uLL);
  v622 = 0x8000000000000020;
  v621 = 29;
  strcpy(v620, "mps.materialize_sparse_tensor");
  v623 = 202;
  v624 = (char *)operator new(0x20uLL);
  v626 = 0x8000000000000020;
  v625 = 27;
  strcpy(v624, "mps.matrix_decomposition_lu");
  v627 = 203;
  v628[23] = 18;
  strcpy(v628, "mps.matrix_inverse");
  v629 = 204;
  v630[23] = 20;
  strcpy(v630, "mps.matrix_solver_lu");
  v631 = 205;
  v632[23] = 11;
  strcpy(v632, "mps.maximum");
  v633 = 206;
  v634[23] = 11;
  strcpy(v634, "mps.minimum");
  v635 = 207;
  v636[23] = 10;
  strcpy(v636, "mps.modulo");
  v637 = 208;
  v638[23] = 12;
  strcpy(v638, "mps.multiply");
  v639 = 209;
  v640[23] = 10;
  strcpy(v640, "mps.n_relu");
  v641 = 210;
  v642[23] = 8;
  strcpy(v642, "mps.nand");
  v643 = 211;
  v644[23] = 12;
  strcpy(v644, "mps.negative");
  v645 = 212;
  v646 = (char *)operator new(0x20uLL);
  v648 = 0x8000000000000020;
  v647 = 27;
  strcpy(v646, "mps.non_maximum_suppression");
  v649 = 213;
  v650[23] = 12;
  strcpy(v650, "mps.non_zero");
  v651 = 214;
  v652[23] = 7;
  strcpy(v652, "mps.nor");
  v653 = 215;
  v654[23] = 17;
  strcpy(v654, "mps.normalization");
  v655 = 216;
  v656[23] = 13;
  strcpy(v656, "mps.not_equal");
  v657 = 217;
  v658[23] = 7;
  strcpy(v658, "mps.not");
  v659 = 218;
  v660[23] = 11;
  strcpy(v660, "mps.one_hot");
  v661 = 219;
  v662[23] = 6;
  strcpy(v662, "mps.or");
  v663 = 220;
  v664[23] = 9;
  strcpy(v664, "mps.prelu");
  v665 = 221;
  v666[23] = 16;
  strcpy(v666, "mps.pad_gradient");
  v667 = 222;
  v668[23] = 7;
  strcpy(v668, "mps.pad");
  v669 = 223;
  v670[23] = 11;
  strcpy(v670, "mps.permute");
  v671 = 224;
  v672[23] = 15;
  strcpy(v672, "mps.placeholder");
  v673 = 225;
  v674 = (char *)operator new(0x20uLL);
  v676 = 0x8000000000000020;
  v675 = 28;
  strcpy(v674, "mps.pooling_average_gradient");
  v677 = 226;
  v678[23] = 19;
  strcpy(v678, "mps.pooling_average");
  v679 = 227;
  v680 = (char *)operator new(0x20uLL);
  v682 = 0x8000000000000020;
  v681 = 28;
  strcpy(v680, "mps.pooling_l2_norm_gradient");
  v683 = 228;
  v684[23] = 19;
  strcpy(v684, "mps.pooling_l2_norm");
  v685 = 229;
  v686 = (char *)operator new(0x20uLL);
  v688 = 0x8000000000000020;
  v687 = 24;
  strcpy(v686, "mps.pooling_max_gradient");
  v689 = 230;
  v690[23] = 15;
  strcpy(v690, "mps.pooling_max");
  v691 = 231;
  v692[23] = 9;
  strcpy(v692, "mps.power");
  v693 = 232;
  v694[23] = 18;
  strcpy(v694, "mps.prune_gradient");
  v695 = 233;
  v696[23] = 9;
  strcpy(v696, "mps.prune");
  v697 = 234;
  v698[23] = 12;
  strcpy(v698, "mps.quantize");
  v699 = 235;
  v700[23] = 17;
  strcpy(v700, "mps.random_normal");
  v701 = 236;
  v702 = (char *)operator new(0x20uLL);
  v704 = 0x8000000000000020;
  v703 = 27;
  strcpy(v702, "mps.random_truncated_normal");
  v705 = 237;
  v706[23] = 18;
  strcpy(v706, "mps.random_uniform");
  v707 = 238;
  v708[23] = 8;
  strcpy(v708, "mps.rank");
  v709 = 239;
  v710[23] = 17;
  strcpy(v710, "mps.read_variable");
  v711 = 240;
  v712[23] = 13;
  strcpy(v712, "mps.real_part");
  v713 = 241;
  v714 = (char *)operator new(0x20uLL);
  v716 = 0x8000000000000020;
  v715 = 25;
  strcpy(v714, "mps.real_to_hermitean_fft");
  v717 = 242;
  v718[23] = 14;
  strcpy(v718, "mps.reciprocal");
  v719 = 243;
  v720 = (char *)operator new(0x20uLL);
  v722 = 0x8000000000000020;
  v721 = 26;
  strcpy(v720, "mps.reciprocal_square_root");
  v723 = 244;
  v724[23] = 17;
  strcpy(v724, "mps.reduction_and");
  v725 = 245;
  v726[23] = 20;
  strcpy(v726, "mps.reduction_argmax");
  v727 = 246;
  v728[23] = 20;
  strcpy(v728, "mps.reduction_argmin");
  v729 = 247;
  v730 = (char *)operator new(0x19uLL);
  v732 = 0x8000000000000019;
  v731 = 23;
  strcpy(v730, "mps.reduction_logsumexp");
  v733 = 248;
  v734[23] = 17;
  strcpy(v734, "mps.reduction_max");
  v735 = 249;
  v736[23] = 18;
  strcpy(v736, "mps.reduction_mean");
  v737 = 250;
  v738[23] = 17;
  strcpy(v738, "mps.reduction_min");
  v739 = 251;
  v740[23] = 16;
  strcpy(v740, "mps.reduction_or");
  v741 = 252;
  v742[23] = 18;
  strcpy(v742, "mps.reduction_prod");
  v743 = 253;
  v744[23] = 17;
  strcpy(v744, "mps.reduction_sum");
  v745 = 254;
  strcpy(v746, "mps.reduction_variance");
  v746[23] = 22;
  v747 = 255;
  v748[23] = 20;
  strcpy(v748, "mps.reinterpret_cast");
  v749 = 256;
  v750[23] = 9;
  strcpy(v750, "mps.relu6");
  v751 = 257;
  v752[23] = 13;
  strcpy(v752, "mps.relu_grad");
  v753 = 258;
  v754[23] = 8;
  strcpy(v754, "mps.relu");
  v755 = 259;
  v756[23] = 11;
  strcpy(v756, "mps.reshape");
  v757 = 260;
  v758[23] = 19;
  strcpy(v758, "mps.resize_gradient");
  v759 = 261;
  v760[23] = 10;
  strcpy(v760, "mps.resize");
  v761 = 262;
  v762[23] = 11;
  strcpy(v762, "mps.reverse");
  v763 = 263;
  v764[23] = 8;
  strcpy(v764, "mps.rint");
  v765 = 264;
  v766[23] = 9;
  strcpy(v766, "mps.round");
  v767 = 265;
  v768 = (char *)operator new(0x20uLL);
  v770 = 0x8000000000000020;
  v769 = 29;
  strcpy(v768, "mps.sample_grid_data_gradient");
  v771 = 266;
  v772[23] = 15;
  strcpy(v772, "mps.sample_grid");
  v773 = 267;
  v774[23] = 22;
  strcpy(v774, "mps.scatter_along_axis");
  v775 = 268;
  v776[23] = 14;
  strcpy(v776, "mps.scatter_nd");
  v777 = 269;
  v778[23] = 11;
  strcpy(v778, "mps.scatter");
  v779 = 270;
  v780[23] = 10;
  strcpy(v780, "mps.select");
  v781 = 271;
  v782[23] = 9;
  strcpy(v782, "mps.shape");
  v783 = 272;
  v784[23] = 20;
  strcpy(v784, "mps.sigmoid_gradient");
  v785 = 273;
  v786 = (char *)operator new(0x28uLL);
  v788 = 0x8000000000000028;
  v787 = 33;
  strcpy(v786, "mps.sigmoid_gradient_with_sigmoid");
  v789 = 274;
  v790[23] = 16;
  strcpy(v790, "mps.sigmoid_hard");
  v791 = 275;
  v792[23] = 11;
  strcpy(v792, "mps.sigmoid");
  v793 = 276;
  v794[23] = 8;
  strcpy(v794, "mps.sign");
  v795 = 277;
  v796[23] = 11;
  strcpy(v796, "mps.signbit");
  v797 = 278;
  v798[23] = 7;
  strcpy(v798, "mps.sin");
  v799 = 279;
  v2 = 0x8000000000000020;
  v800 = (char *)operator new(0x20uLL);
  v802 = 0x8000000000000020;
  v801 = 27;
  strcpy(v800, "mps.singlegate_rnn_gradient");
  v803 = 280;
  v804[23] = 18;
  strcpy(v804, "mps.singlegate_rnn");
  v805 = 281;
  v806[23] = 8;
  strcpy(v806, "mps.sinh");
  v807 = 282;
  v808[23] = 8;
  strcpy(v808, "mps.size");
  v809 = 283;
  v810[23] = 9;
  strcpy(v810, "mps.slice");
  v811 = 284;
  v812[23] = 11;
  strcpy(v812, "mps.softmax");
  v813 = 285;
  v814[23] = 12;
  strcpy(v814, "mps.softplus");
  v815 = 286;
  v816 = (char *)operator new(0x19uLL);
  v818 = 0x8000000000000019;
  v817 = 23;
  strcpy(v816, "mps.softplus_parametric");
  v819 = 287;
  v820[23] = 12;
  strcpy(v820, "mps.softsign");
  v821 = 288;
  v822[23] = 8;
  strcpy(v822, "mps.sort");
  v823 = 289;
  v824[23] = 18;
  strcpy(v824, "mps.space_to_batch");
  v825 = 290;
  v826[23] = 21;
  strcpy(v826, "mps.space_to_depth_2d");
  v827 = 291;
  v828[23] = 9;
  strcpy(v828, "mps.split");
  v829 = 292;
  v830[23] = 10;
  strcpy(v830, "mps.square");
  v831 = 293;
  v832[23] = 15;
  strcpy(v832, "mps.square_root");
  v833 = 294;
  v834[23] = 11;
  strcpy(v834, "mps.squeeze");
  v835 = 295;
  v836[23] = 11;
  strcpy(v836, "mps.stencil");
  v837 = 296;
  v838 = (char *)operator new(0x20uLL);
  v840 = 0x8000000000000020;
  v839 = 26;
  strcpy(v838, "mps.strided_slice_gradient");
  v841 = 297;
  v842[23] = 17;
  strcpy(v842, "mps.strided_slice");
  v843 = 298;
  v844 = (char *)operator new(0x20uLL);
  v846 = 0x8000000000000020;
  v845 = 24;
  strcpy(v844, "mps.strided_slice_update");
  v847 = 299;
  v848[23] = 12;
  strcpy(v848, "mps.subtract");
  v849 = 300;
  v850[23] = 9;
  strcpy(v850, "mps.swish");
  v851 = 301;
  v852[23] = 7;
  strcpy(v852, "mps.tan");
  v853 = 302;
  v854[23] = 8;
  strcpy(v854, "mps.tanh");
  v855 = 303;
  v856[23] = 17;
  strcpy(v856, "mps.tile_gradient");
  v857 = 304;
  v858[23] = 8;
  strcpy(v858, "mps.tile");
  v859 = 305;
  v860[23] = 14;
  strcpy(v860, "mps.top_k_grad");
  v861 = 306;
  v862[23] = 9;
  strcpy(v862, "mps.top_k");
  v863 = 307;
  v864[23] = 13;
  strcpy(v864, "mps.transpose");
  v865 = 308;
  v866[23] = 12;
  strcpy(v866, "mps.truncate");
  v867 = 309;
  v868[23] = 19;
  strcpy(v868, "mps.type_constraint");
  v869 = 310;
  v870[23] = 19;
  strcpy(v870, "mps.unrealized_fold");
  v871 = 311;
  v872 = (char *)operator new(0x19uLL);
  v874 = 0x8000000000000019;
  v873 = 23;
  strcpy(v872, "mps.update_random_state");
  v875 = 312;
  v876 = (char *)operator new(0x20uLL);
  v878 = 0x8000000000000020;
  v877 = 24;
  strcpy(v876, "mps.variable_from_tensor");
  v879 = 313;
  v880[23] = 8;
  strcpy(v880, "mps.xnor");
  v881 = 314;
  v882[23] = 7;
  strcpy(v882, "mps.xor");
  v883 = 315;
  v884[23] = 13;
  strcpy(v884, "mps.condition");
  v885 = 316;
  v886[23] = 7;
  strcpy(v886, "mps.for");
  v887 = 317;
  v889 = 6;
  strcpy((char *)v888, "mps.if");
  v890 = 318;
  v891[23] = 11;
  strcpy(v891, "mps.extract");
  v892 = 319;
  v893[23] = 17;
  strcpy(v893, "mps.from_elements");
  v894 = 320;
  v895[23] = 8;
  strcpy(v895, "mps.func");
  v896 = 321;
  v897[23] = 10;
  strcpy(v897, "mps.module");
  v898 = 322;
  v899[23] = 10;
  strcpy(v899, "mps.return");
  v900 = 323;
  v901[23] = 9;
  strcpy(v901, "mps.while");
  v902 = 324;
  v903[23] = 9;
  strcpy(v903, "mps.yield");
  v904 = 325;
  v905[23] = 8;
  strcpy(v905, "mpsx.ane");
  v906 = 326;
  v907[23] = 8;
  strcpy(v907, "mpsx.cpu");
  v908 = 327;
  v909[23] = 17;
  strcpy(v909, "mpsx.deinterleave");
  v910 = 328;
  v911[23] = 22;
  strcpy(v911, "mpsx.fp_to_int_clamped");
  v912 = 329;
  v913 = (char *)operator new(0x20uLL);
  v915 = 0x8000000000000020;
  v914 = 25;
  strcpy(v913, "mpsx.file_backed_constant");
  v916 = 330;
  v917[23] = 8;
  strcpy(v917, "mpsx.gpu");
  v918 = 331;
  v919[23] = 15;
  strcpy(v919, "mpsx.interleave");
  v920 = 332;
  v921[23] = 18;
  strcpy(v921, "mpsx.list_pop_back");
  v922 = 333;
  v923[23] = 19;
  strcpy(v923, "mpsx.list_push_back");
  v924 = 334;
  v925[23] = 14;
  strcpy(v925, "mpsx.make_list");
  v926 = 335;
  v927[23] = 21;
  strcpy(v927, "mpsx.quantized_gather");
  v928 = 336;
  v929[23] = 21;
  strcpy(v929, "mpsx.quantized_matmul");
  v930 = 337;
  v931[23] = 13;
  strcpy(v931, "mpsx.rms_norm");
  v932 = 338;
  v933[23] = 18;
  strcpy(v933, "mpsx.region_return");
  v934 = 339;
  v935[23] = 20;
  strcpy(v935, "mpsx.stitched_return");
  v936 = 340;
  v937[23] = 9;
  strcpy(v937, "mpsx.sdpa");
  v938 = 341;
  v939 = (char *)operator new(0x20uLL);
  v941 = 0x8000000000000020;
  v940 = 24;
  strcpy(v939, "mpsx.sparse_dense_matmul");
  v942 = 342;
  v943[23] = 13;
  strcpy(v943, "mpsx.stitched");
  v944 = 343;
  v945[23] = 15;
  strcpy(v945, "mpsx.var_handle");
  v946 = 344;
  v947[23] = 21;
  strcpy(v947, "placement.ane_io_cast");
  v948 = 345;
  v949 = (char *)operator new(0x20uLL);
  v951 = 0x8000000000000020;
  v950 = 24;
  strcpy(v949, "placement.host_type_cast");
  v952 = 346;
  v953 = (char *)operator new(0x20uLL);
  v955 = 0x8000000000000020;
  v954 = 26;
  strcpy(v953, "placement.memref_to_tensor");
  v956 = 347;
  v957[23] = 21;
  strcpy(v957, "placement.region_call");
  v958 = 348;
  v959[23] = 22;
  strcpy(v959, "placement.replaced_ops");
  v960 = 349;
  v961[23] = 19;
  strcpy(v961, "placement.live_outs");
  v962 = 350;
  v963[23] = 21;
  strcpy(v963, "placement.start_timer");
  v964 = 351;
  v965[23] = 20;
  strcpy(v965, "placement.stop_timer");
  v966 = 352;
  v967 = (char *)operator new(0x20uLL);
  v969 = 0x8000000000000020;
  v968 = 26;
  strcpy(v967, "placement.tensor_to_memref");
  v970 = 353;
  v972 = 11;
  strcpy(v971, "func.return");
  v973 = 354;
  v3 = v1 + 23;
  v4 = v1[24];
  v155 = v1 + 23;
  if (!*(_QWORD *)&v4)
  {
    v7 = 0;
LABEL_112:
    v153 = v1 + 25;
    while (1)
    {
      v56 = &v171[4 * v7];
      v57 = *((char *)v56 + 23);
      if (v57 >= 0)
        v58 = (std::string::value_type *)&v171[4 * v7];
      else
        v58 = *v56;
      if (v57 >= 0)
        v59 = *((unsigned __int8 *)v56 + 23);
      else
        v59 = (unint64_t)v56[1];
      v60 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&__dst, (uint64_t *)v58, v59);
      v61 = v60;
      v62 = (unint64_t)v1[24];
      if (v62)
      {
        v63 = (uint8x8_t)vcnt_s8((int8x8_t)v62);
        v63.i16[0] = vaddlv_u8(v63);
        if (v63.u32[0] > 1uLL)
        {
          v2 = v60;
          if (v60 >= v62)
            v2 = v60 % v62;
        }
        else
        {
          v2 = (v62 - 1) & v60;
        }
        v64 = *(uint64_t ***)(*(_QWORD *)v3 + 8 * v2);
        if (v64)
        {
          v65 = *v64;
          if (*v64)
          {
            v66 = *((_BYTE *)v56 + 23);
            if (v66 >= 0)
              v67 = (std::string::value_type *)*((unsigned __int8 *)v56 + 23);
            else
              v67 = v56[1];
            if (v66 >= 0)
              v68 = (std::string::value_type *)&v171[4 * v7];
            else
              v68 = *v56;
            if (v63.u32[0] < 2uLL)
            {
              while (1)
              {
                v74 = v65[1];
                if (v74 == v61)
                {
                  v75 = *((unsigned __int8 *)v65 + 39);
                  if ((v75 & 0x80u) == 0)
                    v76 = (std::string::value_type *)*((unsigned __int8 *)v65 + 39);
                  else
                    v76 = (std::string::value_type *)v65[3];
                  if (v76 == v67)
                  {
                    v77 = (const void **)(v65 + 2);
                    if ((v75 & 0x80) != 0)
                    {
                      if (!memcmp(*v77, v68, v65[3]))
                        goto LABEL_115;
                    }
                    else
                    {
                      if (!*((_BYTE *)v65 + 39))
                        goto LABEL_115;
                      v78 = v68;
                      while (*(unsigned __int8 *)v77 == *v78)
                      {
                        v77 = (const void **)((char *)v77 + 1);
                        ++v78;
                        if (!--v75)
                          goto LABEL_115;
                      }
                    }
                  }
                }
                else if ((v74 & (v62 - 1)) != v2)
                {
                  goto LABEL_169;
                }
                v65 = (uint64_t *)*v65;
                if (!v65)
                  goto LABEL_169;
              }
            }
            while (1)
            {
              v69 = v65[1];
              if (v69 == v61)
              {
                v70 = *((unsigned __int8 *)v65 + 39);
                if ((v70 & 0x80u) == 0)
                  v71 = (std::string::value_type *)*((unsigned __int8 *)v65 + 39);
                else
                  v71 = (std::string::value_type *)v65[3];
                if (v71 == v67)
                {
                  v72 = (const void **)(v65 + 2);
                  if ((v70 & 0x80) != 0)
                  {
                    if (!memcmp(*v72, v68, v65[3]))
                      goto LABEL_115;
                  }
                  else
                  {
                    if (!*((_BYTE *)v65 + 39))
                      goto LABEL_115;
                    v73 = v68;
                    while (*(unsigned __int8 *)v72 == *v73)
                    {
                      v72 = (const void **)((char *)v72 + 1);
                      ++v73;
                      if (!--v70)
                        goto LABEL_115;
                    }
                  }
                }
              }
              else
              {
                if (v69 >= v62)
                  v69 %= v62;
                if (v69 != v2)
                {
LABEL_169:
                  v3 = v1 + 23;
                  break;
                }
              }
              v65 = (uint64_t *)*v65;
              if (!v65)
                goto LABEL_169;
            }
          }
        }
      }
      v79 = (char *)operator new(0x30uLL);
      *(_QWORD *)&__dst = v79;
      *((_QWORD *)&__dst + 1) = v1 + 25;
      LOBYTE(v163) = 0;
      *(_QWORD *)v79 = 0;
      *((_QWORD *)v79 + 1) = v61;
      v80 = (std::string *)(v79 + 16);
      if (*((char *)v56 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v80, *v56, (std::string::size_type)v56[1]);
      }
      else
      {
        *(_OWORD *)&v80->__r_.__value_.__l.__data_ = *(_OWORD *)v56;
        *((_QWORD *)v79 + 4) = v56[2];
      }
      *((_DWORD *)v79 + 10) = *(_DWORD *)&v174[32 * v7];
      LOBYTE(v163) = 1;
      v81 = (float)(unint64_t)(*(_QWORD *)&v1[26] + 1);
      v82 = *(float *)v1[27].i32;
      if (v62 && (float)(v82 * (float)v62) >= v81)
        goto LABEL_201;
      v83 = (v62 & (v62 - 1)) != 0;
      if (v62 < 3)
        v83 = 1;
      v84 = v83 | (2 * v62);
      v85 = vcvtps_u32_f32(v81 / v82);
      if (v84 <= v85)
        prime = v85;
      else
        prime = v84;
      if (prime == 1)
      {
        prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        prime = std::__next_prime(prime);
      }
      v87 = v1[24];
      if (prime > *(_QWORD *)&v87)
        goto LABEL_185;
      if (prime < *(_QWORD *)&v87)
      {
        v88 = vcvtps_u32_f32((float)(unint64_t)v1[26] / *(float *)v1[27].i32);
        if (*(_QWORD *)&v87 < 3uLL || (v89 = (uint8x8_t)vcnt_s8(v87), v89.i16[0] = vaddlv_u8(v89), v89.u32[0] > 1uLL))
        {
          v88 = std::__next_prime(v88);
        }
        else
        {
          v90 = 1 << -(char)__clz(v88 - 1);
          if (v88 >= 2)
            v88 = v90;
        }
        if (prime <= v88)
          prime = v88;
        if (prime < *(_QWORD *)&v87)
LABEL_185:
          std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>((uint64_t)v3, prime);
      }
      v62 = (unint64_t)v1[24];
      v91 = v62 - 1;
      if ((v62 & (v62 - 1)) == 0)
      {
        v2 = v91 & v61;
        v92 = *(int8x8_t **)(*(_QWORD *)v3 + 8 * (v91 & v61));
        v93 = (int8x8_t *)__dst;
        if (v92)
          goto LABEL_113;
        goto LABEL_202;
      }
      if (v61 < v62)
        break;
      v2 = v61 % v62;
      v92 = *(int8x8_t **)(*(_QWORD *)v3 + 8 * (v61 % v62));
      v93 = (int8x8_t *)__dst;
      if (v92)
      {
LABEL_113:
        *v93 = *v92;
        *v92 = (int8x8_t)__dst;
        goto LABEL_114;
      }
LABEL_202:
      *v93 = *v153;
      *v153 = (int8x8_t)__dst;
      *(_QWORD *)(*(_QWORD *)v3 + 8 * v2) = v153;
      if (*(_QWORD *)__dst)
      {
        v94 = *(_QWORD *)(*(_QWORD *)__dst + 8);
        if ((v62 & (v62 - 1)) != 0)
        {
          if (v94 >= v62)
            v94 %= v62;
        }
        else
        {
          v94 &= v62 - 1;
        }
        *(_QWORD *)(*(_QWORD *)v3 + 8 * v94) = __dst;
      }
LABEL_114:
      ++*(_QWORD *)&v1[26];
LABEL_115:
      ++v7;
      v3 = v1 + 23;
      if (v7 == 354)
        goto LABEL_100;
    }
    v2 = v61;
LABEL_201:
    v92 = *(int8x8_t **)(*(_QWORD *)v3 + 8 * v2);
    v93 = (int8x8_t *)__dst;
    if (v92)
      goto LABEL_113;
    goto LABEL_202;
  }
  v5 = 0;
  do
    *(_QWORD *)(*(_QWORD *)v3 + 8 * v5++) = 0;
  while (*(_QWORD *)&v4 != v5);
  v6 = (void **)v1[25];
  v1[25] = 0;
  v1[26] = 0;
  v152 = v1 + 25;
  v7 = 0;
  if (!v6)
    goto LABEL_112;
  do
  {
    v8 = (unsigned __int8 *)(v6 + 2);
    std::string::operator=((std::string *)(v6 + 2), (const std::string *)&v171[4 * v7]);
    *((_DWORD *)v6 + 10) = *(_DWORD *)&v174[32 * v7];
    v9 = (void **)*v6;
    v10 = *((char *)v6 + 39);
    if (v10 >= 0)
      v11 = (uint64_t *)(v6 + 2);
    else
      v11 = (uint64_t *)v6[2];
    if (v10 >= 0)
      v12 = *((unsigned __int8 *)v6 + 39);
    else
      v12 = (unint64_t)v6[3];
    v13 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&__dst, v11, v12);
    v14 = v13;
    v6[1] = (void *)v13;
    v2 = (unint64_t)v1[24];
    if (v2)
    {
      v15 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
      v15.i16[0] = vaddlv_u8(v15);
      if (v15.u32[0] > 1uLL)
      {
        v16 = v13;
        if (v2 <= v13)
          v16 = v13 % v2;
      }
      else
      {
        v16 = (v2 - 1) & v13;
      }
      v17 = *(uint64_t ***)(*(_QWORD *)v155 + 8 * v16);
      if (v17)
      {
        v18 = *v17;
        if (*v17)
        {
          v19 = *((_BYTE *)v6 + 39);
          if (v19 >= 0)
            v20 = (void *)*((unsigned __int8 *)v6 + 39);
          else
            v20 = v6[3];
          if (v19 < 0)
            v8 = (unsigned __int8 *)v6[2];
          if (v15.u32[0] < 2uLL)
          {
            while (1)
            {
              v27 = v18[1];
              if (v27 == v14)
              {
                v28 = *((unsigned __int8 *)v18 + 39);
                if ((v28 & 0x80u) == 0)
                  v29 = (void *)*((unsigned __int8 *)v18 + 39);
                else
                  v29 = (void *)v18[3];
                if (v29 == v20)
                {
                  if ((v28 & 0x80) != 0)
                  {
                    v151 = v20;
                    v31 = memcmp((const void *)v18[2], v8, v18[3]);
                    v20 = v151;
                    if (!v31)
                      goto LABEL_96;
                  }
                  else
                  {
                    if (!*((_BYTE *)v18 + 39))
                      goto LABEL_96;
                    v30 = 0;
                    while (*((unsigned __int8 *)v18 + v30 + 16) == v8[v30])
                    {
                      if (v28 == ++v30)
                        goto LABEL_76;
                    }
                  }
                }
              }
              else if ((v27 & (v2 - 1)) != v16)
              {
                goto LABEL_57;
              }
              v18 = (uint64_t *)*v18;
              if (!v18)
                goto LABEL_57;
            }
          }
          do
          {
            v21 = v18[1];
            if (v21 == v14)
            {
              v22 = *((unsigned __int8 *)v18 + 39);
              if ((v22 & 0x80u) == 0)
                v23 = (void *)*((unsigned __int8 *)v18 + 39);
              else
                v23 = (void *)v18[3];
              if (v23 == v20)
              {
                if ((v22 & 0x80) != 0)
                {
                  v25 = v20;
                  v26 = memcmp((const void *)v18[2], v8, v18[3]);
                  v20 = v25;
                  if (!v26)
                    goto LABEL_96;
                }
                else
                {
                  if (!*((_BYTE *)v18 + 39))
                    goto LABEL_96;
                  v24 = 0;
                  while (*((unsigned __int8 *)v18 + v24 + 16) == v8[v24])
                  {
                    if (v22 == ++v24)
                    {
LABEL_76:
                      if (v18)
                        goto LABEL_96;
                      goto LABEL_82;
                    }
                  }
                }
              }
            }
            else
            {
              if (v21 >= v2)
                v21 %= v2;
              if (v21 != v16)
                break;
            }
            v18 = (uint64_t *)*v18;
          }
          while (v18);
        }
      }
    }
LABEL_57:
    v32 = (float)(unint64_t)(*(_QWORD *)&v1[26] + 1);
    v33 = *(float *)v1[27].i32;
    if (!v2 || (float)(v33 * (float)v2) < v32)
    {
      v34 = (v2 & (v2 - 1)) != 0;
      if (v2 < 3)
        v34 = 1;
      v35 = v34 | (2 * v2);
      v36 = vcvtps_u32_f32(v32 / v33);
      if (v35 <= v36)
        v37 = v36;
      else
        v37 = v35;
      if (v37 == 1)
      {
        v37 = 2;
      }
      else if ((v37 & (v37 - 1)) != 0)
      {
        v37 = std::__next_prime(v37);
        v2 = (unint64_t)v1[24];
      }
      if (v37 > v2)
        goto LABEL_69;
      if (v37 < v2)
      {
        v38 = vcvtps_u32_f32((float)(unint64_t)v1[26] / *(float *)v1[27].i32);
        if (v2 < 3 || (v39 = (uint8x8_t)vcnt_s8((int8x8_t)v2), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
        {
          v38 = std::__next_prime(v38);
        }
        else
        {
          v40 = 1 << -(char)__clz(v38 - 1);
          if (v38 >= 2)
            v38 = v40;
        }
        if (v37 <= v38)
          v37 = v38;
        if (v37 < v2)
LABEL_69:
          std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>((uint64_t)v155, v37);
      }
    }
LABEL_82:
    v41 = v1[24];
    v42 = (unint64_t)v6[1];
    v43 = (uint8x8_t)vcnt_s8(v41);
    v43.i16[0] = vaddlv_u8(v43);
    if (v43.u32[0] > 1uLL)
    {
      v44 = v1 + 23;
      if (v42 >= *(_QWORD *)&v41)
        v42 %= *(_QWORD *)&v41;
    }
    else
    {
      v42 &= *(_QWORD *)&v41 - 1;
      v44 = v1 + 23;
    }
    v45 = *(void ***)(*(_QWORD *)v44 + 8 * v42);
    if (v45)
    {
      *v6 = *v45;
LABEL_94:
      *v45 = v6;
      goto LABEL_95;
    }
    *v6 = (void *)*v152;
    *v152 = (int8x8_t)v6;
    *(_QWORD *)(*(_QWORD *)v44 + 8 * v42) = v152;
    if (*v6)
    {
      v46 = *((_QWORD *)*v6 + 1);
      if (v43.u32[0] > 1uLL)
      {
        if (v46 >= *(_QWORD *)&v41)
          v46 %= *(_QWORD *)&v41;
      }
      else
      {
        v46 &= *(_QWORD *)&v41 - 1;
      }
      v45 = (void **)(*(_QWORD *)v44 + 8 * v46);
      goto LABEL_94;
    }
LABEL_95:
    ++*(_QWORD *)&v1[26];
LABEL_96:
    ++v7;
    if (!v9)
      break;
    v6 = v9;
  }
  while (v7 != 354);
  v3 = v1 + 23;
  if (v9)
  {
    do
    {
      v48 = (void **)*v9;
      if (*((char *)v9 + 39) < 0)
        operator delete(v9[2]);
      operator delete(v9);
      v9 = v48;
    }
    while (v48);
  }
  if (v7 != 354)
    goto LABEL_112;
LABEL_100:
  for (i = 0; i != -11328; i -= 32)
  {
    if (*(&v972 + i) < 0)
      operator delete(*(void **)&v971[i]);
  }
  Context = mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)&v1[7] + 24));
  mlir::PassManager::PassManager(v171, Context, "any", 3uLL, 1);
  WeakRetained = objc_loadWeakRetained((id *)&v1[8]);
  v51 = (objc_msgSend(WeakRetained, "options") & 2) == 0;

  if (!v51)
  {
    mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)&__dst);
    v52 = (llvm *)mlir::OpPrintingFlags::elideLargeElementsAttrs((uint64_t)&__dst, 256);
    v170 = v169;
    v167[0] = &off_1E0E05530;
    v168 = v167;
    v169[0] = &off_1E0E054D8;
    v53 = llvm::dbgs(v52);
    v160[0] = __dst;
    v160[1] = v163;
    v161 = v164;
    mlir::PassManager::enableIRPrinting((uint64_t)v171, v169, v167, 0, 0, 0, v53, (uint64_t)v160);
    v54 = v168;
    if (v168 == v167)
    {
      v55 = 4;
      v54 = v167;
LABEL_211:
      (*(void (**)(void))(*v54 + 8 * v55))();
    }
    else if (v168)
    {
      v55 = 5;
      goto LABEL_211;
    }
    v95 = v170;
    if (v170 == v169)
    {
      v96 = 4;
      v95 = v169;
LABEL_216:
      (*(void (**)(void))(*v95 + 8 * v96))();
    }
    else if (v170)
    {
      v96 = 5;
      goto LABEL_216;
    }
    mlir::PassManager::enableTiming((mlir::PassManager *)v171);
  }
  v97 = (id *)objc_loadWeakRetained((id *)&v1[8]);
  v98 = (objc_msgSend(v97[17], "compilerOptions") & 0x200) == 0;

  if (!v98)
  {
    mlir::mps::createConvertF32ToF16Pass(&v159);
    mlir::OpPassManager::addPass(v171, &v159);
    v99 = v159;
    v159 = 0;
    if (v99)
      (*(void (**)(uint64_t))(*(_QWORD *)v99 + 8))(v99);
  }
  v100 = (_BYTE **)mlir::OpPassManager::nest((uint64_t *)v171, "func.func", 9uLL);
  mlir::createCanonicalizerPass(&v158);
  mlir::OpPassManager::addPass(v100, &v158);
  v101 = v158;
  v158 = 0;
  if (v101)
    (*(void (**)(uint64_t))(*(_QWORD *)v101 + 8))(v101);
  if (!mlir::PassManager::run((mlir::PassManager *)v171, *(mlir::Operation **)&v1[7])
    && MTLReportFailureTypeEnabled())
  {
    MTLReportFailure();
  }
  v102 = v1[7];
  v103 = *(unsigned int *)(*(_QWORD *)&v102 + 44);
  if ((v103 & 0x7FFFFF) == 0)
  {
    v147 = "index < numRegions && \"invalid region index\"";
    v148 = 666;
    v149 = "Operation.h";
    v150 = "getRegion";
    goto LABEL_277;
  }
  v104 = *(_QWORD *)&v102 + 16 * ((v103 >> 23) & 1) + ((v103 >> 21) & 0x7F8) + 64;
  if (v104 > 0xFFFFFFFFFFFFFFF8)
  {
    v147 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
    v148 = 191;
    v149 = "Alignment.h";
    v150 = "alignAddr";
    goto LABEL_277;
  }
  v105 = (_QWORD *)(((v104 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(*(_QWORD *)&v102 + 40));
  if ((_QWORD *)*v105 == v105)
  {
    v147 = "!region.empty() && \"unexpected empty region\"";
    v148 = 895;
    v149 = "OpDefinition.h";
    v150 = "getBody";
LABEL_277:
    __assert_rtn(v150, v149, v148, v147);
  }
  v106 = v105[1];
  if (v106)
    v107 = v106 - 8;
  else
    v107 = 0;
  v108 = *(mlir::GenericProgramPoint **)(v107 + 40);
  v154 = (mlir::GenericProgramPoint *)(v107 + 32);
  if (v108 != (mlir::GenericProgramPoint *)(v107 + 32))
  {
    v109 = MEMORY[0x1E0C9AA60];
    while (1)
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(v108);
      v111 = v110;
      v112 = llvm::DefaultDoCastIfPossible<mlir::func::FuncOp,mlir::Operation &,llvm::CastInfo<mlir::func::FuncOp,mlir::Operation,void>>::doCastIfPossible(v110);
      v156 = v108;
      v157 = v112;
      if (!v112)
        break;
      v113 = *(unsigned int *)(v112 + 44);
      if ((v113 & 0x7FFFFF) == 0)
      {
        v143 = 666;
        v144 = "index < numRegions && \"invalid region index\"";
        v145 = "Operation.h";
        v146 = "getRegion";
        goto LABEL_271;
      }
      v114 = v112 + 16 * ((v113 >> 23) & 1) + ((v113 >> 21) & 0x7F8) + 64;
      if (v114 >= 0xFFFFFFFFFFFFFFF9)
      {
        v143 = 191;
        v146 = "alignAddr";
        v145 = "Alignment.h";
        v144 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
LABEL_271:
        __assert_rtn(v146, v145, v143, v144);
      }
      v115 = (_QWORD *)(((v114 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v112 + 40));
      if ((_QWORD *)*v115 != v115)
      {
        v116 = v115[1];
        v117 = v116 ? v116 - 8 : 0;
        v118 = *(uint64_t **)(v117 + 48);
        v119 = *(_QWORD *)(v117 + 56) - (_QWORD)v118;
        if (v119)
        {
          v120 = 8 * (v119 >> 3);
          do
          {
            v121 = *v118;
            v122 = (void *)v1[22];
            v123 = [MPSGraphViewerNodeSPI alloc];
            if (v121)
            {
              MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v121 + 8) & 0xFFFFFFFFFFFFFFF8));
              getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v121 + 8) & 0xFFFFFFFFFFFFFFF8));
              v125 = (void *)objc_claimAutoreleasedReturnValue();
              v126 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("Value"), MPSDataType, v125, (*(uint64_t (**)(int8x8_t *, uint64_t))(*(_QWORD *)v1 + 32))(v1, v121));

            }
            else
            {
              v126 = 0;
            }
            v166 = v126;
            objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v166, 1);
            v127 = (void *)objc_claimAutoreleasedReturnValue();
            v128 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v123, "initWithType:inputs:outputs:properties:regions:", CFSTR("mps.placeholder"), v109, v127, v109, v109);
            objc_msgSend(v122, "addObject:", v128);

            ++v118;
            v120 -= 8;
          }
          while (v120);
        }
      }
      Body = mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v157);
      for (j = *(_QWORD *)(Body + 8); j != Body; j = *(_QWORD *)(j + 8))
      {
        v131 = j - 8;
        if (!j)
          v131 = 0;
        v132 = (mlir::GenericProgramPoint *)(v131 + 32);
        v133 = *(mlir::GenericProgramPoint **)(v131 + 40);
        if (v133 != (mlir::GenericProgramPoint *)(v131 + 32))
        {
          do
          {
            mlir::GenericProgramPoint::~GenericProgramPoint(v133);
            EmitViewerSPI::emitNode(v1, v134);
            v135 = (void *)objc_claimAutoreleasedReturnValue();
            if (v135)
              objc_msgSend(*(id *)&v1[22], "addObject:", v135);

            v133 = (mlir::GenericProgramPoint *)*((_QWORD *)v133 + 1);
          }
          while (v133 != v132);
        }
      }
LABEL_232:
      v108 = (mlir::GenericProgramPoint *)*((_QWORD *)v156 + 1);
      if (v108 == v154)
        goto LABEL_268;
    }
    v165 = *(_QWORD *)(*(_QWORD *)(v111 + 48) + 8);
    AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v165);
    v137 = strlen(AttrData);
    if (v137 > 0x7FFFFFFFFFFFFFF7)
      std::string::__throw_length_error[abi:ne180100]();
    v138 = v137;
    if (v137 >= 0x17)
    {
      v140 = (v137 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v137 | 7) != 0x17)
        v140 = v137 | 7;
      v141 = v140 + 1;
      p_dst = (__int128 *)operator new(v140 + 1);
      *(_QWORD *)&__dst = p_dst;
      *(_QWORD *)&v163 = v141 | 0x8000000000000000;
    }
    else
    {
      BYTE7(v163) = v137;
      p_dst = &__dst;
      if (!v137)
        goto LABEL_264;
    }
    memmove(p_dst, AttrData, v138);
LABEL_264:
    *((_BYTE *)p_dst + v138) = 0;
    EmitViewerSPI::emitNode(v1, (MPSGraphViewerNodePortSPI *)v111);
    v142 = (void *)objc_claimAutoreleasedReturnValue();
    if (v142)
      objc_msgSend(*(id *)&v1[22], "addObject:", v142);

    if (SBYTE7(v163) < 0)
      operator delete((void *)__dst);
    goto LABEL_232;
  }
LABEL_268:
  mlir::PassManager::~PassManager((mlir::PassManager *)v171);
}

void sub_180E874DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a16)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)a16 + 8))(a16);
    mlir::PassManager::~PassManager((mlir::PassManager *)&a38);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x180E877D0);
}

void sub_180E87520()
{
  void *v0;

  JUMPOUT(0x180E877D0);
}

void sub_180E8752C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char *a33,char a34,uint64_t a35,uint64_t a36,char *a37,char a38)
{
  char *v38;
  char *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;

  v40 = a33;
  if (a33 == v38)
  {
    v41 = 4;
    v40 = &a30;
  }
  else
  {
    if (!a33)
      goto LABEL_6;
    v41 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v40 + 8 * v41))();
LABEL_6:
  v42 = a37;
  if (a37 == &a34)
  {
    v43 = 4;
    v42 = &a34;
  }
  else
  {
    if (!a37)
      JUMPOUT(0x180E877D0);
    v43 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v42 + 8 * v43))();
  mlir::PassManager::~PassManager((mlir::PassManager *)&a38);
  _Unwind_Resume(a1);
}

void sub_180E8759C()
{
  void *v0;

  JUMPOUT(0x180E877D0);
}

void sub_180E875A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  char *v38;

  while (1)
  {
    if (*(v38 - 9) < 0)
      operator delete(*((void **)v38 - 4));
    v38 -= 32;
    if (v38 == &a38)
      _Unwind_Resume(exception_object);
  }
}

void sub_180E87694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  void *v41;

  if (a28 < 0)
  {
    operator delete(__p);
    mlir::PassManager::~PassManager((mlir::PassManager *)&a41);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x180E877D0);
}

void sub_180E876CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  char *v16;
  uint64_t v17;
  char *v18;
  int v19;
  va_list va;

  va_start(va, a15);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  v16 = (char *)(a3 + 2535);
  v17 = -11328;
  v18 = (char *)(a3 + 2535);
  while (1)
  {
    v19 = *v18;
    v18 -= 32;
    if (v19 < 0)
      operator delete(*(void **)(v16 - 23));
    v16 = v18;
    v17 += 32;
    if (!v17)
      _Unwind_Resume(a1);
  }
}

void sub_180E87708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  char *v10;
  uint64_t v11;
  char *v12;
  int v13;

  __cxa_end_catch();
  v10 = (char *)(a10 + 2535);
  v11 = -11328;
  v12 = (char *)(a10 + 2535);
  while (1)
  {
    v13 = *v12;
    v12 -= 32;
    if (v13 < 0)
      operator delete(*(void **)(v10 - 23));
    v10 = v12;
    v11 += 32;
    if (!v11)
      JUMPOUT(0x180E877C4);
  }
}

void sub_180E8775C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void sub_180E87774()
{
  void *v0;

  JUMPOUT(0x180E877D0);
}

void sub_180E8779C()
{
  void *v0;

  JUMPOUT(0x180E877D0);
}

void sub_180E877AC()
{
  void *v0;

  JUMPOUT(0x180E877D0);
}

void sub_180E877CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  mlir::PassManager::~PassManager((mlir::PassManager *)&a38);
  _Unwind_Resume(a1);
}

MPSGraphViewerNodePortSPI *EmitViewerSPI::emitNodeOutputPort(uint64_t a1, void *a2, MPSGraphViewerNodePortSPI *a3)
{
  id v5;
  uint64_t MPSDataType;
  void *v7;

  v5 = a2;
  if (a3)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&a3->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&a3->_dataType & 0xFFFFFFFFFFFFFFF8));
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    a3 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", v5, MPSDataType, v7, (*(uint64_t (**)(uint64_t, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a1 + 32))(a1, a3));

  }
  return a3;
}

void sub_180E8788C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E8789C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E878AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

MPSGraphViewerNodeSPI *EmitViewerSPI::emitNode(int8x8_t *this, MPSGraphViewerNodePortSPI *a2)
{
  const char *AttrData;
  size_t v5;
  size_t v6;
  void **p_dst;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  int8x8_t v13;
  unint64_t v14;
  uint8x8_t v15;
  unint64_t v16;
  uint64_t **v17;
  uint64_t *v18;
  size_t v19;
  void **v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  MPSGraphViewerNodeSPI *v30;
  void **v32;
  char *v33;
  void **v34;
  void *v35;
  uint64_t shape_high;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t valueRef_high;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  MPSGraphViewerNodeSPI *v56;
  void *v57;
  void *v58;
  void *v59;
  int v60;
  MPSGraphViewerNodePortSPI *v61;
  unint64_t v62;
  void *v63;
  void *v64;
  void **v65;
  const char *v66;
  const char *v67;
  char *v68;
  void *v69;
  void *v70;
  void *__p[2];
  char v72;
  id v73;
  uint64_t *__dst;
  size_t v75;
  int64_t v76;
  uint64_t v77;

  __p[0] = *(void **)(*(_QWORD *)&a2[1]._dataType + 8);
  AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__p);
  v5 = strlen(AttrData);
  if (v5 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v6 = v5;
  if (v5 >= 0x17)
  {
    v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v8 = v5 | 7;
    v9 = v8 + 1;
    p_dst = (void **)operator new(v8 + 1);
    v75 = v6;
    v76 = v9 | 0x8000000000000000;
    __dst = (uint64_t *)p_dst;
    goto LABEL_8;
  }
  HIBYTE(v76) = v5;
  p_dst = (void **)&__dst;
  if (v5)
LABEL_8:
    memmove(p_dst, AttrData, v6);
  *((_BYTE *)p_dst + v6) = 0;
  if (v76 >= 0)
    v10 = (uint64_t *)&__dst;
  else
    v10 = __dst;
  if (v76 >= 0)
    v11 = HIBYTE(v76);
  else
    v11 = v75;
  v12 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)__p, v10, v11);
  v13 = this[24];
  if (!*(_QWORD *)&v13)
    goto LABEL_422;
  v14 = v12;
  v15 = (uint8x8_t)vcnt_s8(v13);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] > 1uLL)
  {
    v16 = v12;
    if (v12 >= *(_QWORD *)&v13)
      v16 = v12 % *(_QWORD *)&v13;
  }
  else
  {
    v16 = (*(_QWORD *)&v13 - 1) & v12;
  }
  v17 = *(uint64_t ***)(*(_QWORD *)&this[23] + 8 * v16);
  if (!v17)
    goto LABEL_422;
  v18 = *v17;
  if (!*v17)
    goto LABEL_422;
  if (v76 >= 0)
    v19 = HIBYTE(v76);
  else
    v19 = v75;
  if (v76 >= 0)
    v20 = (void **)&__dst;
  else
    v20 = (void **)__dst;
  if (v15.u32[0] < 2uLL)
  {
    v21 = *(_QWORD *)&v13 - 1;
    while (1)
    {
      v26 = v18[1];
      if (v26 == v14)
      {
        v27 = *((unsigned __int8 *)v18 + 39);
        if ((v27 & 0x80u) == 0)
          v28 = *((unsigned __int8 *)v18 + 39);
        else
          v28 = v18[3];
        if (v28 == v19)
        {
          if ((v27 & 0x80) != 0)
          {
            if (!memcmp((const void *)v18[2], v20, v18[3]))
              goto LABEL_63;
          }
          else
          {
            if (!*((_BYTE *)v18 + 39))
              goto LABEL_63;
            v29 = 0;
            while (*((unsigned __int8 *)v18 + v29 + 16) == *((unsigned __int8 *)v20 + v29))
            {
              if (v27 == ++v29)
                goto LABEL_62;
            }
          }
        }
      }
      else if ((v26 & v21) != v16)
      {
        goto LABEL_422;
      }
      v18 = (uint64_t *)*v18;
      if (!v18)
        goto LABEL_422;
    }
  }
  while (1)
  {
    v22 = v18[1];
    if (v22 == v14)
      break;
    if (v22 >= *(_QWORD *)&v13)
      v22 %= *(_QWORD *)&v13;
    if (v22 != v16)
      goto LABEL_422;
LABEL_31:
    v18 = (uint64_t *)*v18;
    if (!v18)
      goto LABEL_422;
  }
  v23 = *((unsigned __int8 *)v18 + 39);
  if ((v23 & 0x80u) == 0)
    v24 = *((unsigned __int8 *)v18 + 39);
  else
    v24 = v18[3];
  if (v24 != v19)
    goto LABEL_31;
  if ((v23 & 0x80) != 0)
  {
    if (!memcmp((const void *)v18[2], v20, v18[3]))
      goto LABEL_63;
    goto LABEL_31;
  }
  if (*((_BYTE *)v18 + 39))
  {
    v25 = 0;
    do
    {
      if (*((unsigned __int8 *)v18 + v25 + 16) != *((unsigned __int8 *)v20 + v25))
        goto LABEL_31;
      ++v25;
    }
    while (v23 != v25);
LABEL_62:
    if (!v18)
LABEL_422:
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  }
LABEL_63:
  switch(*((_DWORD *)v18 + 10))
  {
    case 1:
      EmitterViewerSPI::ANECA11LegacyOpHandler::ANECA11LegacyOpHandler((EmitterViewerSPI::ANECA11LegacyOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 2:
      EmitterViewerSPI::ANECA12OpHandler::ANECA12OpHandler((EmitterViewerSPI::ANECA12OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 3:
      EmitterViewerSPI::ANECA13OpHandler::ANECA13OpHandler((EmitterViewerSPI::ANECA13OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 4:
      EmitterViewerSPI::ANECA14OpHandler::ANECA14OpHandler((EmitterViewerSPI::ANECA14OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 5:
      EmitterViewerSPI::ANECA15OpHandler::ANECA15OpHandler((EmitterViewerSPI::ANECA15OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 6:
      EmitterViewerSPI::ANECA16OpHandler::ANECA16OpHandler((EmitterViewerSPI::ANECA16OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 7:
      EmitterViewerSPI::ANECA17OpHandler::ANECA17OpHandler((EmitterViewerSPI::ANECA17OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 8:
      EmitterViewerSPI::ANECArgMinMaxOpHandler::ANECArgMinMaxOpHandler((EmitterViewerSPI::ANECArgMinMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 9:
      EmitterViewerSPI::ANECAveragePoolOpHandler::ANECAveragePoolOpHandler((EmitterViewerSPI::ANECAveragePoolOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA:
      EmitterViewerSPI::ANECBatchToSpaceOpHandler::ANECBatchToSpaceOpHandler((EmitterViewerSPI::ANECBatchToSpaceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB:
      EmitterViewerSPI::ANECBroadcastOpHandler::ANECBroadcastOpHandler((EmitterViewerSPI::ANECBroadcastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC:
      EmitterViewerSPI::ANECCastOpHandler::ANECCastOpHandler((EmitterViewerSPI::ANECCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD:
      EmitterViewerSPI::ANECCeilOpHandler::ANECCeilOpHandler((EmitterViewerSPI::ANECCeilOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE:
      EmitterViewerSPI::ANECChannelToSpaceOpHandler::ANECChannelToSpaceOpHandler((EmitterViewerSPI::ANECChannelToSpaceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF:
      EmitterViewerSPI::ANECClampedReluOpHandler::ANECClampedReluOpHandler((EmitterViewerSPI::ANECClampedReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x10:
      EmitterViewerSPI::ANECConcatOpHandler::ANECConcatOpHandler((EmitterViewerSPI::ANECConcatOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x11:
      EmitterViewerSPI::ANECConvolutionOpHandler::ANECConvolutionOpHandler((EmitterViewerSPI::ANECConvolutionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x12:
      EmitterViewerSPI::ANECCosOpHandler::ANECCosOpHandler((EmitterViewerSPI::ANECCosOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x13:
      EmitterViewerSPI::ANECCropResizeOpHandler::ANECCropResizeOpHandler((EmitterViewerSPI::ANECCropResizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x14:
      EmitterViewerSPI::ANECDeQuantOpHandler::ANECDeQuantOpHandler((EmitterViewerSPI::ANECDeQuantOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x15:
      EmitterViewerSPI::ANECDeconvolutionOpHandler::ANECDeconvolutionOpHandler((EmitterViewerSPI::ANECDeconvolutionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x16:
      EmitterViewerSPI::ANECDegammaOpHandler::ANECDegammaOpHandler((EmitterViewerSPI::ANECDegammaOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x17:
      EmitterViewerSPI::ANECDiracOpHandler::ANECDiracOpHandler((EmitterViewerSPI::ANECDiracOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x18:
      EmitterViewerSPI::ANECElementwiseAbsOpHandler::ANECElementwiseAbsOpHandler((EmitterViewerSPI::ANECElementwiseAbsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x19:
      EmitterViewerSPI::ANECElementwiseAddOpHandler::ANECElementwiseAddOpHandler((EmitterViewerSPI::ANECElementwiseAddOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x1A:
      EmitterViewerSPI::ANECElementwiseDivOpHandler::ANECElementwiseDivOpHandler((EmitterViewerSPI::ANECElementwiseDivOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x1B:
      EmitterViewerSPI::ANECElementwiseEqualOpHandler::ANECElementwiseEqualOpHandler((EmitterViewerSPI::ANECElementwiseEqualOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x1C:
      EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler::ANECElementwiseEqualZeroOpHandler((EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x1D:
      EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler::ANECElementwiseGreaterThanOpHandler((EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x1E:
      EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler::ANECElementwiseGreaterThanEqualOpHandler((EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x1F:
      EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler::ANECElementwiseGreaterThanEqualZeroOpHandler((EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x20:
      EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler::ANECElementwiseGreaterThanZeroOpHandler((EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x21:
      EmitterViewerSPI::ANECElementwiseLessThanOpHandler::ANECElementwiseLessThanOpHandler((EmitterViewerSPI::ANECElementwiseLessThanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x22:
      EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler::ANECElementwiseLessThanEqualOpHandler((EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x23:
      EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler::ANECElementwiseLessThanEqualZeroOpHandler((EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x24:
      EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler::ANECElementwiseLessThanZeroOpHandler((EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x25:
      EmitterViewerSPI::ANECElementwiseMaxOpHandler::ANECElementwiseMaxOpHandler((EmitterViewerSPI::ANECElementwiseMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x26:
      EmitterViewerSPI::ANECElementwiseMinOpHandler::ANECElementwiseMinOpHandler((EmitterViewerSPI::ANECElementwiseMinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x27:
      EmitterViewerSPI::ANECElementwiseMultOpHandler::ANECElementwiseMultOpHandler((EmitterViewerSPI::ANECElementwiseMultOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x28:
      EmitterViewerSPI::ANECElementwiseNotEqualOpHandler::ANECElementwiseNotEqualOpHandler((EmitterViewerSPI::ANECElementwiseNotEqualOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x29:
      EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler::ANECElementwiseNotEqualZeroOpHandler((EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x2A:
      EmitterViewerSPI::ANECElementwisePowerOpHandler::ANECElementwisePowerOpHandler((EmitterViewerSPI::ANECElementwisePowerOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x2B:
      EmitterViewerSPI::ANECElementwiseSquareOpHandler::ANECElementwiseSquareOpHandler((EmitterViewerSPI::ANECElementwiseSquareOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x2C:
      EmitterViewerSPI::ANECElementwiseSubOpHandler::ANECElementwiseSubOpHandler((EmitterViewerSPI::ANECElementwiseSubOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x2D:
      EmitterViewerSPI::ANECEluOpHandler::ANECEluOpHandler((EmitterViewerSPI::ANECEluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x2E:
      EmitterViewerSPI::ANECErfOpHandler::ANECErfOpHandler((EmitterViewerSPI::ANECErfOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x2F:
      EmitterViewerSPI::ANECExp2OpHandler::ANECExp2OpHandler((EmitterViewerSPI::ANECExp2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x30:
      EmitterViewerSPI::ANECFlattenOpHandler::ANECFlattenOpHandler((EmitterViewerSPI::ANECFlattenOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x31:
      EmitterViewerSPI::ANECFloorOpHandler::ANECFloorOpHandler((EmitterViewerSPI::ANECFloorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x32:
      EmitterViewerSPI::ANECGOCOpHandler::ANECGOCOpHandler((EmitterViewerSPI::ANECGOCOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x33:
      EmitterViewerSPI::ANECGatherNDOpHandler::ANECGatherNDOpHandler((EmitterViewerSPI::ANECGatherNDOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x34:
      EmitterViewerSPI::ANECGeluOpHandler::ANECGeluOpHandler((EmitterViewerSPI::ANECGeluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x35:
      EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler::ANECGlobalArgMinMaxOpHandler((EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x36:
      EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler::ANECHighPrecisionSigmoidOpHandler((EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x37:
      EmitterViewerSPI::ANECInputViewOpHandler::ANECInputViewOpHandler((EmitterViewerSPI::ANECInputViewOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x38:
      EmitterViewerSPI::ANECInstanceNormOpHandler::ANECInstanceNormOpHandler((EmitterViewerSPI::ANECInstanceNormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x39:
      EmitterViewerSPI::ANECInvertOpHandler::ANECInvertOpHandler((EmitterViewerSPI::ANECInvertOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x3A:
      EmitterViewerSPI::ANECL2NormPoolOpHandler::ANECL2NormPoolOpHandler((EmitterViewerSPI::ANECL2NormPoolOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x3B:
      EmitterViewerSPI::ANECLeakyReluOpHandler::ANECLeakyReluOpHandler((EmitterViewerSPI::ANECLeakyReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x3C:
      EmitterViewerSPI::ANECLinearOpHandler::ANECLinearOpHandler((EmitterViewerSPI::ANECLinearOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x3D:
      EmitterViewerSPI::ANECLog2OpHandler::ANECLog2OpHandler((EmitterViewerSPI::ANECLog2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x3E:
      EmitterViewerSPI::ANECMatMulOpHandler::ANECMatMulOpHandler((EmitterViewerSPI::ANECMatMulOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x3F:
      EmitterViewerSPI::ANECMaxPoolOpHandler::ANECMaxPoolOpHandler((EmitterViewerSPI::ANECMaxPoolOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x40:
      EmitterViewerSPI::ANECNReluOpHandler::ANECNReluOpHandler((EmitterViewerSPI::ANECNReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x41:
      EmitterViewerSPI::ANECPaddingOpHandler::ANECPaddingOpHandler((EmitterViewerSPI::ANECPaddingOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x42:
      EmitterViewerSPI::ANECPixelShuffleOpHandler::ANECPixelShuffleOpHandler((EmitterViewerSPI::ANECPixelShuffleOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x43:
      EmitterViewerSPI::ANECPixelUnshuffleOpHandler::ANECPixelUnshuffleOpHandler((EmitterViewerSPI::ANECPixelUnshuffleOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x44:
      EmitterViewerSPI::ANECQuantOpHandler::ANECQuantOpHandler((EmitterViewerSPI::ANECQuantOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x45:
      EmitterViewerSPI::ANECReduceAvgOpHandler::ANECReduceAvgOpHandler((EmitterViewerSPI::ANECReduceAvgOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x46:
      EmitterViewerSPI::ANECReduceMaxOpHandler::ANECReduceMaxOpHandler((EmitterViewerSPI::ANECReduceMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x47:
      EmitterViewerSPI::ANECReduceMinOpHandler::ANECReduceMinOpHandler((EmitterViewerSPI::ANECReduceMinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x48:
      EmitterViewerSPI::ANECReduceSumOpHandler::ANECReduceSumOpHandler((EmitterViewerSPI::ANECReduceSumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x49:
      EmitterViewerSPI::ANECRegionReturnOpHandler::ANECRegionReturnOpHandler((EmitterViewerSPI::ANECRegionReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x4A:
      EmitterViewerSPI::ANECReluOpHandler::ANECReluOpHandler((EmitterViewerSPI::ANECReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x4B:
      EmitterViewerSPI::ANECReshapeOpHandler::ANECReshapeOpHandler((EmitterViewerSPI::ANECReshapeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x4C:
      EmitterViewerSPI::ANECResizeOpHandler::ANECResizeOpHandler((EmitterViewerSPI::ANECResizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x4D:
      EmitterViewerSPI::ANECRoundNearestOpHandler::ANECRoundNearestOpHandler((EmitterViewerSPI::ANECRoundNearestOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x4E:
      EmitterViewerSPI::ANECRsqrtOpHandler::ANECRsqrtOpHandler((EmitterViewerSPI::ANECRsqrtOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x4F:
      EmitterViewerSPI::ANECSigmoidOpHandler::ANECSigmoidOpHandler((EmitterViewerSPI::ANECSigmoidOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x50:
      EmitterViewerSPI::ANECSignOpHandler::ANECSignOpHandler((EmitterViewerSPI::ANECSignOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x51:
      EmitterViewerSPI::ANECSinOpHandler::ANECSinOpHandler((EmitterViewerSPI::ANECSinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x52:
      EmitterViewerSPI::ANECSoftmaxOpHandler::ANECSoftmaxOpHandler((EmitterViewerSPI::ANECSoftmaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x53:
      EmitterViewerSPI::ANECSpaceToBatchOpHandler::ANECSpaceToBatchOpHandler((EmitterViewerSPI::ANECSpaceToBatchOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x54:
      EmitterViewerSPI::ANECSpaceToChannelOpHandler::ANECSpaceToChannelOpHandler((EmitterViewerSPI::ANECSpaceToChannelOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x55:
      EmitterViewerSPI::ANECSqrOpHandler::ANECSqrOpHandler((EmitterViewerSPI::ANECSqrOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x56:
      EmitterViewerSPI::ANECSqrtOpHandler::ANECSqrtOpHandler((EmitterViewerSPI::ANECSqrtOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x57:
      EmitterViewerSPI::ANECSwishOpHandler::ANECSwishOpHandler((EmitterViewerSPI::ANECSwishOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x58:
      EmitterViewerSPI::ANECT0OpHandler::ANECT0OpHandler((EmitterViewerSPI::ANECT0OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x59:
      EmitterViewerSPI::ANECTanhOpHandler::ANECTanhOpHandler((EmitterViewerSPI::ANECTanhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x5A:
      EmitterViewerSPI::ANECTileOpHandler::ANECTileOpHandler((EmitterViewerSPI::ANECTileOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x5B:
      EmitterViewerSPI::ANECTransposeOpHandler::ANECTransposeOpHandler((EmitterViewerSPI::ANECTransposeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x5C:
      EmitterViewerSPI::ANECTruncOpHandler::ANECTruncOpHandler((EmitterViewerSPI::ANECTruncOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x5D:
      EmitterViewerSPI::ANECUnflattenOpHandler::ANECUnflattenOpHandler((EmitterViewerSPI::ANECUnflattenOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x5E:
      EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler::ANECUnrealizedConversionCastOpHandler((EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x5F:
      EmitterViewerSPI::MPSACosOpHandler::MPSACosOpHandler((EmitterViewerSPI::MPSACosOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x60:
      EmitterViewerSPI::MPSACoshOpHandler::MPSACoshOpHandler((EmitterViewerSPI::MPSACoshOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x61:
      EmitterViewerSPI::MPSASinOpHandler::MPSASinOpHandler((EmitterViewerSPI::MPSASinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x62:
      EmitterViewerSPI::MPSASinhOpHandler::MPSASinhOpHandler((EmitterViewerSPI::MPSASinhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x63:
      EmitterViewerSPI::MPSATan2OpHandler::MPSATan2OpHandler((EmitterViewerSPI::MPSATan2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x64:
      EmitterViewerSPI::MPSATanOpHandler::MPSATanOpHandler((EmitterViewerSPI::MPSATanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x65:
      EmitterViewerSPI::MPSATanhOpHandler::MPSATanhOpHandler((EmitterViewerSPI::MPSATanhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x66:
      EmitterViewerSPI::MPSAbsoluteOpHandler::MPSAbsoluteOpHandler((EmitterViewerSPI::MPSAbsoluteOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x67:
      EmitterViewerSPI::MPSAbsoluteSquareOpHandler::MPSAbsoluteSquareOpHandler((EmitterViewerSPI::MPSAbsoluteSquareOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x68:
      EmitterViewerSPI::MPSAddOpHandler::MPSAddOpHandler((EmitterViewerSPI::MPSAddOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x69:
      EmitterViewerSPI::MPSAndOpHandler::MPSAndOpHandler((EmitterViewerSPI::MPSAndOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x6A:
      EmitterViewerSPI::MPSAssignVariableOpHandler::MPSAssignVariableOpHandler((EmitterViewerSPI::MPSAssignVariableOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x6B:
      EmitterViewerSPI::MPSBandPartOpHandler::MPSBandPartOpHandler((EmitterViewerSPI::MPSBandPartOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x6C:
      EmitterViewerSPI::MPSBatchToSpaceOpHandler::MPSBatchToSpaceOpHandler((EmitterViewerSPI::MPSBatchToSpaceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x6D:
      EmitterViewerSPI::MPSBiasAddGradOpHandler::MPSBiasAddGradOpHandler((EmitterViewerSPI::MPSBiasAddGradOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x6E:
      EmitterViewerSPI::MPSBiasAddOpHandler::MPSBiasAddOpHandler((EmitterViewerSPI::MPSBiasAddOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x6F:
      EmitterViewerSPI::MPSBitwiseAndOpHandler::MPSBitwiseAndOpHandler((EmitterViewerSPI::MPSBitwiseAndOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x70:
      EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler::MPSBitwiseLeftShiftOpHandler((EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x71:
      EmitterViewerSPI::MPSBitwiseNotOpHandler::MPSBitwiseNotOpHandler((EmitterViewerSPI::MPSBitwiseNotOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x72:
      EmitterViewerSPI::MPSBitwiseOrOpHandler::MPSBitwiseOrOpHandler((EmitterViewerSPI::MPSBitwiseOrOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x73:
      EmitterViewerSPI::MPSBitwisePopcountOpHandler::MPSBitwisePopcountOpHandler((EmitterViewerSPI::MPSBitwisePopcountOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x74:
      EmitterViewerSPI::MPSBitwiseRightShiftOpHandler::MPSBitwiseRightShiftOpHandler((EmitterViewerSPI::MPSBitwiseRightShiftOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x75:
      EmitterViewerSPI::MPSBitwiseXorOpHandler::MPSBitwiseXorOpHandler((EmitterViewerSPI::MPSBitwiseXorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x76:
      EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler::MPSBroadcastGradientArgsOpHandler((EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x77:
      EmitterViewerSPI::MPSBroadcastToOpHandler::MPSBroadcastToOpHandler((EmitterViewerSPI::MPSBroadcastToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x78:
      EmitterViewerSPI::MPSCallOpHandler::MPSCallOpHandler((EmitterViewerSPI::MPSCallOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x79:
      EmitterViewerSPI::MPSCastOpHandler::MPSCastOpHandler((EmitterViewerSPI::MPSCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x7A:
      EmitterViewerSPI::MPSCeilOpHandler::MPSCeilOpHandler((EmitterViewerSPI::MPSCeilOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x7B:
      EmitterViewerSPI::MPSClampOpHandler::MPSClampOpHandler((EmitterViewerSPI::MPSClampOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x7C:
      EmitterViewerSPI::MPSColToImOpHandler::MPSColToImOpHandler((EmitterViewerSPI::MPSColToImOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x7D:
      EmitterViewerSPI::MPSConcatOpHandler::MPSConcatOpHandler((EmitterViewerSPI::MPSConcatOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x7E:
      EmitterViewerSPI::MPSConjugateOpHandler::MPSConjugateOpHandler((EmitterViewerSPI::MPSConjugateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x7F:
      EmitterViewerSPI::MPSConstantOpHandler::MPSConstantOpHandler((EmitterViewerSPI::MPSConstantOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x80:
      EmitterViewerSPI::MPSConv2DDataGradientOpHandler::MPSConv2DDataGradientOpHandler((EmitterViewerSPI::MPSConv2DDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x81:
      EmitterViewerSPI::MPSConv2DOpHandler::MPSConv2DOpHandler((EmitterViewerSPI::MPSConv2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x82:
      EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler::MPSConv2DWeightsGradientOpHandler((EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x83:
      EmitterViewerSPI::MPSConv3DDataGradientOpHandler::MPSConv3DDataGradientOpHandler((EmitterViewerSPI::MPSConv3DDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x84:
      EmitterViewerSPI::MPSConv3DOpHandler::MPSConv3DOpHandler((EmitterViewerSPI::MPSConv3DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x85:
      EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler::MPSConv3DWeightsGradientOpHandler((EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x86:
      EmitterViewerSPI::MPSCosOpHandler::MPSCosOpHandler((EmitterViewerSPI::MPSCosOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x87:
      EmitterViewerSPI::MPSCoshOpHandler::MPSCoshOpHandler((EmitterViewerSPI::MPSCoshOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x88:
      EmitterViewerSPI::MPSCostVolumeOpHandler::MPSCostVolumeOpHandler((EmitterViewerSPI::MPSCostVolumeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x89:
      EmitterViewerSPI::MPSCreateComplexOpHandler::MPSCreateComplexOpHandler((EmitterViewerSPI::MPSCreateComplexOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x8A:
      EmitterViewerSPI::MPSCreateTextureTensorOpHandler::MPSCreateTextureTensorOpHandler((EmitterViewerSPI::MPSCreateTextureTensorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x8B:
      EmitterViewerSPI::MPSCropOpHandler::MPSCropOpHandler((EmitterViewerSPI::MPSCropOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x8C:
      EmitterViewerSPI::MPSCropResizeOpHandler::MPSCropResizeOpHandler((EmitterViewerSPI::MPSCropResizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x8D:
      EmitterViewerSPI::MPSCumulativeMaximumOpHandler::MPSCumulativeMaximumOpHandler((EmitterViewerSPI::MPSCumulativeMaximumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x8E:
      EmitterViewerSPI::MPSCumulativeMinimumOpHandler::MPSCumulativeMinimumOpHandler((EmitterViewerSPI::MPSCumulativeMinimumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x8F:
      EmitterViewerSPI::MPSCumulativeProductOpHandler::MPSCumulativeProductOpHandler((EmitterViewerSPI::MPSCumulativeProductOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x90:
      EmitterViewerSPI::MPSCumulativeSumOpHandler::MPSCumulativeSumOpHandler((EmitterViewerSPI::MPSCumulativeSumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x91:
      EmitterViewerSPI::MPSDegammaOpHandler::MPSDegammaOpHandler((EmitterViewerSPI::MPSDegammaOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x92:
      EmitterViewerSPI::MPSDepthToSpace2DOpHandler::MPSDepthToSpace2DOpHandler((EmitterViewerSPI::MPSDepthToSpace2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x93:
      EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler::MPSDepthwiseConv2DDataGradientOpHandler((EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x94:
      EmitterViewerSPI::MPSDepthwiseConv2DOpHandler::MPSDepthwiseConv2DOpHandler((EmitterViewerSPI::MPSDepthwiseConv2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x95:
      EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler::MPSDepthwiseConv2DWeightsGradientOpHandler((EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x96:
      EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler::MPSDepthwiseConv3DDataGradientOpHandler((EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x97:
      EmitterViewerSPI::MPSDepthwiseConv3DOpHandler::MPSDepthwiseConv3DOpHandler((EmitterViewerSPI::MPSDepthwiseConv3DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x98:
      EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler::MPSDepthwiseConv3DWeightsGradientOpHandler((EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x99:
      EmitterViewerSPI::MPSDequantizeLUTOpHandler::MPSDequantizeLUTOpHandler((EmitterViewerSPI::MPSDequantizeLUTOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x9A:
      EmitterViewerSPI::MPSDequantizeOpHandler::MPSDequantizeOpHandler((EmitterViewerSPI::MPSDequantizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x9B:
      EmitterViewerSPI::MPSDimensionSizeOpHandler::MPSDimensionSizeOpHandler((EmitterViewerSPI::MPSDimensionSizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x9C:
      EmitterViewerSPI::MPSDiracOpHandler::MPSDiracOpHandler((EmitterViewerSPI::MPSDiracOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x9D:
      EmitterViewerSPI::MPSDivideOpHandler::MPSDivideOpHandler((EmitterViewerSPI::MPSDivideOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x9E:
      EmitterViewerSPI::MPSDynamicShapeCastOpHandler::MPSDynamicShapeCastOpHandler((EmitterViewerSPI::MPSDynamicShapeCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x9F:
      EmitterViewerSPI::MPSEluOpHandler::MPSEluOpHandler((EmitterViewerSPI::MPSEluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA0:
      EmitterViewerSPI::MPSEqualToOpHandler::MPSEqualToOpHandler((EmitterViewerSPI::MPSEqualToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA1:
      EmitterViewerSPI::MPSErfOpHandler::MPSErfOpHandler((EmitterViewerSPI::MPSErfOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA2:
      EmitterViewerSPI::MPSExpandDimsOpHandler::MPSExpandDimsOpHandler((EmitterViewerSPI::MPSExpandDimsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA3:
      EmitterViewerSPI::MPSExponentBase2OpHandler::MPSExponentBase2OpHandler((EmitterViewerSPI::MPSExponentBase2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA4:
      EmitterViewerSPI::MPSExponentBase10OpHandler::MPSExponentBase10OpHandler((EmitterViewerSPI::MPSExponentBase10OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA5:
      EmitterViewerSPI::MPSExponentOpHandler::MPSExponentOpHandler((EmitterViewerSPI::MPSExponentOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA6:
      EmitterViewerSPI::MPSFastFourierTransformOpHandler::MPSFastFourierTransformOpHandler((EmitterViewerSPI::MPSFastFourierTransformOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA7:
      EmitterViewerSPI::MPSFlatten2DOpHandler::MPSFlatten2DOpHandler((EmitterViewerSPI::MPSFlatten2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA8:
      EmitterViewerSPI::MPSFloorDivideOpHandler::MPSFloorDivideOpHandler((EmitterViewerSPI::MPSFloorDivideOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xA9:
      EmitterViewerSPI::MPSFloorOpHandler::MPSFloorOpHandler((EmitterViewerSPI::MPSFloorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xAA:
      EmitterViewerSPI::MPSGRUGradientOpHandler::MPSGRUGradientOpHandler((EmitterViewerSPI::MPSGRUGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xAB:
      EmitterViewerSPI::MPSGRUOpHandler::MPSGRUOpHandler((EmitterViewerSPI::MPSGRUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xAC:
      EmitterViewerSPI::MPSGatherAlongAxisOpHandler::MPSGatherAlongAxisOpHandler((EmitterViewerSPI::MPSGatherAlongAxisOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xAD:
      EmitterViewerSPI::MPSGatherNDOpHandler::MPSGatherNDOpHandler((EmitterViewerSPI::MPSGatherNDOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xAE:
      EmitterViewerSPI::MPSGatherOpHandler::MPSGatherOpHandler((EmitterViewerSPI::MPSGatherOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xAF:
      EmitterViewerSPI::MPSGeluOpHandler::MPSGeluOpHandler((EmitterViewerSPI::MPSGeluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB0:
      EmitterViewerSPI::MPSGetCoordOpHandler::MPSGetCoordOpHandler((EmitterViewerSPI::MPSGetCoordOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB1:
      EmitterViewerSPI::MPSGreaterThanOpHandler::MPSGreaterThanOpHandler((EmitterViewerSPI::MPSGreaterThanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB2:
      EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler::MPSGreaterThanOrEqualToOpHandler((EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB3:
      EmitterViewerSPI::MPSHammingDistanceOpHandler::MPSHammingDistanceOpHandler((EmitterViewerSPI::MPSHammingDistanceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB4:
      EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler::MPSHermiteanToRealFFTOpHandler((EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB5:
      EmitterViewerSPI::MPSIdentityOpHandler::MPSIdentityOpHandler((EmitterViewerSPI::MPSIdentityOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB6:
      EmitterViewerSPI::MPSImToColOpHandler::MPSImToColOpHandler((EmitterViewerSPI::MPSImToColOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB7:
      EmitterViewerSPI::MPSImaginaryPartOpHandler::MPSImaginaryPartOpHandler((EmitterViewerSPI::MPSImaginaryPartOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB8:
      EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler::MPSInitRandomPhiloxStateOpHandler((EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xB9:
      EmitterViewerSPI::MPSInstanceNormOpHandler::MPSInstanceNormOpHandler((EmitterViewerSPI::MPSInstanceNormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xBA:
      EmitterViewerSPI::MPSIsFiniteOpHandler::MPSIsFiniteOpHandler((EmitterViewerSPI::MPSIsFiniteOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xBB:
      EmitterViewerSPI::MPSIsInfiniteOpHandler::MPSIsInfiniteOpHandler((EmitterViewerSPI::MPSIsInfiniteOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xBC:
      EmitterViewerSPI::MPSIsNaNOpHandler::MPSIsNaNOpHandler((EmitterViewerSPI::MPSIsNaNOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xBD:
      EmitterViewerSPI::MPSLPNormOpHandler::MPSLPNormOpHandler((EmitterViewerSPI::MPSLPNormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xBE:
      EmitterViewerSPI::MPSLSTMGradientOpHandler::MPSLSTMGradientOpHandler((EmitterViewerSPI::MPSLSTMGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xBF:
      EmitterViewerSPI::MPSLSTMOpHandler::MPSLSTMOpHandler((EmitterViewerSPI::MPSLSTMOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC0:
      EmitterViewerSPI::MPSLeakyReluOpHandler::MPSLeakyReluOpHandler((EmitterViewerSPI::MPSLeakyReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC1:
      EmitterViewerSPI::MPSLessThanOpHandler::MPSLessThanOpHandler((EmitterViewerSPI::MPSLessThanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC2:
      EmitterViewerSPI::MPSLessThanOrEqualToOpHandler::MPSLessThanOrEqualToOpHandler((EmitterViewerSPI::MPSLessThanOrEqualToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC3:
      EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler::MPSLocalConvolutionDataGradientOpHandler((EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC4:
      EmitterViewerSPI::MPSLocalConvolutionOpHandler::MPSLocalConvolutionOpHandler((EmitterViewerSPI::MPSLocalConvolutionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC5:
      EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler::MPSLocalConvolutionWeightGradientOpHandler((EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC6:
      EmitterViewerSPI::MPSLogarithmBase2OpHandler::MPSLogarithmBase2OpHandler((EmitterViewerSPI::MPSLogarithmBase2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC7:
      EmitterViewerSPI::MPSLogarithmBase10OpHandler::MPSLogarithmBase10OpHandler((EmitterViewerSPI::MPSLogarithmBase10OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC8:
      EmitterViewerSPI::MPSLogarithmOpHandler::MPSLogarithmOpHandler((EmitterViewerSPI::MPSLogarithmOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xC9:
      EmitterViewerSPI::MPSMatMulOpHandler::MPSMatMulOpHandler((EmitterViewerSPI::MPSMatMulOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xCA:
      EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler::MPSMaterializeSparseTensorOpHandler((EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xCB:
      EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler::MPSMatrixDecompositionLUOpHandler((EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xCC:
      EmitterViewerSPI::MPSMatrixInverseOpHandler::MPSMatrixInverseOpHandler((EmitterViewerSPI::MPSMatrixInverseOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xCD:
      EmitterViewerSPI::MPSMatrixSolverLUOpHandler::MPSMatrixSolverLUOpHandler((EmitterViewerSPI::MPSMatrixSolverLUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xCE:
      EmitterViewerSPI::MPSMaximumOpHandler::MPSMaximumOpHandler((EmitterViewerSPI::MPSMaximumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xCF:
      EmitterViewerSPI::MPSMinimumOpHandler::MPSMinimumOpHandler((EmitterViewerSPI::MPSMinimumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD0:
      EmitterViewerSPI::MPSModuloOpHandler::MPSModuloOpHandler((EmitterViewerSPI::MPSModuloOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD1:
      EmitterViewerSPI::MPSMultiplyOpHandler::MPSMultiplyOpHandler((EmitterViewerSPI::MPSMultiplyOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD2:
      EmitterViewerSPI::MPSNReluOpHandler::MPSNReluOpHandler((EmitterViewerSPI::MPSNReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD3:
      EmitterViewerSPI::MPSNandOpHandler::MPSNandOpHandler((EmitterViewerSPI::MPSNandOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD4:
      EmitterViewerSPI::MPSNegativeOpHandler::MPSNegativeOpHandler((EmitterViewerSPI::MPSNegativeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD5:
      EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler::MPSNonMaximumSuppressionOpHandler((EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD6:
      EmitterViewerSPI::MPSNonZeroOpHandler::MPSNonZeroOpHandler((EmitterViewerSPI::MPSNonZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD7:
      EmitterViewerSPI::MPSNorOpHandler::MPSNorOpHandler((EmitterViewerSPI::MPSNorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD8:
      EmitterViewerSPI::MPSNormalizationOpHandler::MPSNormalizationOpHandler((EmitterViewerSPI::MPSNormalizationOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xD9:
      EmitterViewerSPI::MPSNotEqualToOpHandler::MPSNotEqualToOpHandler((EmitterViewerSPI::MPSNotEqualToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xDA:
      EmitterViewerSPI::MPSNotOpHandler::MPSNotOpHandler((EmitterViewerSPI::MPSNotOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xDB:
      EmitterViewerSPI::MPSOneHotOpHandler::MPSOneHotOpHandler((EmitterViewerSPI::MPSOneHotOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xDC:
      EmitterViewerSPI::MPSOrOpHandler::MPSOrOpHandler((EmitterViewerSPI::MPSOrOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xDD:
      EmitterViewerSPI::MPSPReluOpHandler::MPSPReluOpHandler((EmitterViewerSPI::MPSPReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xDE:
      EmitterViewerSPI::MPSPadGradientOpHandler::MPSPadGradientOpHandler((EmitterViewerSPI::MPSPadGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xDF:
      EmitterViewerSPI::MPSPadOpHandler::MPSPadOpHandler((EmitterViewerSPI::MPSPadOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE0:
      EmitterViewerSPI::MPSPermuteOpHandler::MPSPermuteOpHandler((EmitterViewerSPI::MPSPermuteOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE1:
      EmitterViewerSPI::MPSPlaceholderOpHandler::MPSPlaceholderOpHandler((EmitterViewerSPI::MPSPlaceholderOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE2:
      EmitterViewerSPI::MPSPoolAvgGradientOpHandler::MPSPoolAvgGradientOpHandler((EmitterViewerSPI::MPSPoolAvgGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE3:
      EmitterViewerSPI::MPSPoolAvgOpHandler::MPSPoolAvgOpHandler((EmitterViewerSPI::MPSPoolAvgOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE4:
      EmitterViewerSPI::MPSPoolL2NormGradientOpHandler::MPSPoolL2NormGradientOpHandler((EmitterViewerSPI::MPSPoolL2NormGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE5:
      EmitterViewerSPI::MPSPoolL2NormOpHandler::MPSPoolL2NormOpHandler((EmitterViewerSPI::MPSPoolL2NormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE6:
      EmitterViewerSPI::MPSPoolMaxGradientOpHandler::MPSPoolMaxGradientOpHandler((EmitterViewerSPI::MPSPoolMaxGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE7:
      EmitterViewerSPI::MPSPoolMaxOpHandler::MPSPoolMaxOpHandler((EmitterViewerSPI::MPSPoolMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE8:
      EmitterViewerSPI::MPSPowerOpHandler::MPSPowerOpHandler((EmitterViewerSPI::MPSPowerOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xE9:
      EmitterViewerSPI::MPSPruningGradientOpHandler::MPSPruningGradientOpHandler((EmitterViewerSPI::MPSPruningGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xEA:
      EmitterViewerSPI::MPSPruningOpHandler::MPSPruningOpHandler((EmitterViewerSPI::MPSPruningOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xEB:
      EmitterViewerSPI::MPSQuantizeOpHandler::MPSQuantizeOpHandler((EmitterViewerSPI::MPSQuantizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xEC:
      EmitterViewerSPI::MPSRandomNormalOpHandler::MPSRandomNormalOpHandler((EmitterViewerSPI::MPSRandomNormalOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xED:
      EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler::MPSRandomTruncatedNormalOpHandler((EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xEE:
      EmitterViewerSPI::MPSRandomUniformOpHandler::MPSRandomUniformOpHandler((EmitterViewerSPI::MPSRandomUniformOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xEF:
      EmitterViewerSPI::MPSRankOpHandler::MPSRankOpHandler((EmitterViewerSPI::MPSRankOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF0:
      EmitterViewerSPI::MPSReadVariableOpHandler::MPSReadVariableOpHandler((EmitterViewerSPI::MPSReadVariableOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF1:
      EmitterViewerSPI::MPSRealPartOpHandler::MPSRealPartOpHandler((EmitterViewerSPI::MPSRealPartOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF2:
      EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler::MPSRealToHermiteanFFTOpHandler((EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF3:
      EmitterViewerSPI::MPSReciprocalOpHandler::MPSReciprocalOpHandler((EmitterViewerSPI::MPSReciprocalOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF4:
      EmitterViewerSPI::MPSReciprocalSquareRootOpHandler::MPSReciprocalSquareRootOpHandler((EmitterViewerSPI::MPSReciprocalSquareRootOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF5:
      EmitterViewerSPI::MPSReductionAndOpHandler::MPSReductionAndOpHandler((EmitterViewerSPI::MPSReductionAndOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF6:
      EmitterViewerSPI::MPSReductionArgMaxOpHandler::MPSReductionArgMaxOpHandler((EmitterViewerSPI::MPSReductionArgMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF7:
      EmitterViewerSPI::MPSReductionArgMinOpHandler::MPSReductionArgMinOpHandler((EmitterViewerSPI::MPSReductionArgMinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF8:
      EmitterViewerSPI::MPSReductionLogSumExpOpHandler::MPSReductionLogSumExpOpHandler((EmitterViewerSPI::MPSReductionLogSumExpOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xF9:
      EmitterViewerSPI::MPSReductionMaxOpHandler::MPSReductionMaxOpHandler((EmitterViewerSPI::MPSReductionMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xFA:
      EmitterViewerSPI::MPSReductionMeanOpHandler::MPSReductionMeanOpHandler((EmitterViewerSPI::MPSReductionMeanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xFB:
      EmitterViewerSPI::MPSReductionMinOpHandler::MPSReductionMinOpHandler((EmitterViewerSPI::MPSReductionMinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xFC:
      EmitterViewerSPI::MPSReductionOrOpHandler::MPSReductionOrOpHandler((EmitterViewerSPI::MPSReductionOrOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xFD:
      EmitterViewerSPI::MPSReductionProdOpHandler::MPSReductionProdOpHandler((EmitterViewerSPI::MPSReductionProdOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xFE:
      EmitterViewerSPI::MPSReductionSumOpHandler::MPSReductionSumOpHandler((EmitterViewerSPI::MPSReductionSumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0xFF:
      EmitterViewerSPI::MPSReductionVarianceOpHandler::MPSReductionVarianceOpHandler((EmitterViewerSPI::MPSReductionVarianceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x100:
      EmitterViewerSPI::MPSReinterpretCastOpHandler::MPSReinterpretCastOpHandler((EmitterViewerSPI::MPSReinterpretCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x101:
      EmitterViewerSPI::MPSRelu6OpHandler::MPSRelu6OpHandler((EmitterViewerSPI::MPSRelu6OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x102:
      EmitterViewerSPI::MPSReluGradOpHandler::MPSReluGradOpHandler((EmitterViewerSPI::MPSReluGradOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x103:
      EmitterViewerSPI::MPSReluOpHandler::MPSReluOpHandler((EmitterViewerSPI::MPSReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x104:
      EmitterViewerSPI::MPSReshapeOpHandler::MPSReshapeOpHandler((EmitterViewerSPI::MPSReshapeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x105:
      EmitterViewerSPI::MPSResizeGradientOpHandler::MPSResizeGradientOpHandler((EmitterViewerSPI::MPSResizeGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x106:
      EmitterViewerSPI::MPSResizeOpHandler::MPSResizeOpHandler((EmitterViewerSPI::MPSResizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x107:
      EmitterViewerSPI::MPSReverseOpHandler::MPSReverseOpHandler((EmitterViewerSPI::MPSReverseOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x108:
      EmitterViewerSPI::MPSRintOpHandler::MPSRintOpHandler((EmitterViewerSPI::MPSRintOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x109:
      EmitterViewerSPI::MPSRoundOpHandler::MPSRoundOpHandler((EmitterViewerSPI::MPSRoundOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x10A:
      EmitterViewerSPI::MPSSampleGridDataGradientOpHandler::MPSSampleGridDataGradientOpHandler((EmitterViewerSPI::MPSSampleGridDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x10B:
      EmitterViewerSPI::MPSSampleGridOpHandler::MPSSampleGridOpHandler((EmitterViewerSPI::MPSSampleGridOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x10C:
      EmitterViewerSPI::MPSScatterAlongAxisOpHandler::MPSScatterAlongAxisOpHandler((EmitterViewerSPI::MPSScatterAlongAxisOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x10D:
      EmitterViewerSPI::MPSScatterNDOpHandler::MPSScatterNDOpHandler((EmitterViewerSPI::MPSScatterNDOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x10E:
      EmitterViewerSPI::MPSScatterOpHandler::MPSScatterOpHandler((EmitterViewerSPI::MPSScatterOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x10F:
      EmitterViewerSPI::MPSSelectOpHandler::MPSSelectOpHandler((EmitterViewerSPI::MPSSelectOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x110:
      EmitterViewerSPI::MPSShapeOpHandler::MPSShapeOpHandler((EmitterViewerSPI::MPSShapeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x111:
      EmitterViewerSPI::MPSSigmoidGradientOpHandler::MPSSigmoidGradientOpHandler((EmitterViewerSPI::MPSSigmoidGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x112:
      EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler::MPSSigmoidGradientWithSigmoidOpHandler((EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x113:
      EmitterViewerSPI::MPSSigmoidHardOpHandler::MPSSigmoidHardOpHandler((EmitterViewerSPI::MPSSigmoidHardOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x114:
      EmitterViewerSPI::MPSSigmoidOpHandler::MPSSigmoidOpHandler((EmitterViewerSPI::MPSSigmoidOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x115:
      EmitterViewerSPI::MPSSignOpHandler::MPSSignOpHandler((EmitterViewerSPI::MPSSignOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x116:
      EmitterViewerSPI::MPSSignbitOpHandler::MPSSignbitOpHandler((EmitterViewerSPI::MPSSignbitOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x117:
      EmitterViewerSPI::MPSSinOpHandler::MPSSinOpHandler((EmitterViewerSPI::MPSSinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x118:
      EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler::MPSSingleGateRNNGradientOpHandler((EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x119:
      EmitterViewerSPI::MPSSingleGateRNNOpHandler::MPSSingleGateRNNOpHandler((EmitterViewerSPI::MPSSingleGateRNNOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x11A:
      EmitterViewerSPI::MPSSinhOpHandler::MPSSinhOpHandler((EmitterViewerSPI::MPSSinhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x11B:
      EmitterViewerSPI::MPSSizeOpHandler::MPSSizeOpHandler((EmitterViewerSPI::MPSSizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x11C:
      EmitterViewerSPI::MPSSliceOpHandler::MPSSliceOpHandler((EmitterViewerSPI::MPSSliceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x11D:
      EmitterViewerSPI::MPSSoftmaxOpHandler::MPSSoftmaxOpHandler((EmitterViewerSPI::MPSSoftmaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x11E:
      EmitterViewerSPI::MPSSoftplusOpHandler::MPSSoftplusOpHandler((EmitterViewerSPI::MPSSoftplusOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x11F:
      EmitterViewerSPI::MPSSoftplusParametricOpHandler::MPSSoftplusParametricOpHandler((EmitterViewerSPI::MPSSoftplusParametricOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x120:
      EmitterViewerSPI::MPSSoftsignOpHandler::MPSSoftsignOpHandler((EmitterViewerSPI::MPSSoftsignOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x121:
      EmitterViewerSPI::MPSSortOpHandler::MPSSortOpHandler((EmitterViewerSPI::MPSSortOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x122:
      EmitterViewerSPI::MPSSpaceToBatchOpHandler::MPSSpaceToBatchOpHandler((EmitterViewerSPI::MPSSpaceToBatchOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x123:
      EmitterViewerSPI::MPSSpaceToDepth2DOpHandler::MPSSpaceToDepth2DOpHandler((EmitterViewerSPI::MPSSpaceToDepth2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x124:
      EmitterViewerSPI::MPSSplitOpHandler::MPSSplitOpHandler((EmitterViewerSPI::MPSSplitOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x125:
      EmitterViewerSPI::MPSSquareOpHandler::MPSSquareOpHandler((EmitterViewerSPI::MPSSquareOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x126:
      EmitterViewerSPI::MPSSquareRootOpHandler::MPSSquareRootOpHandler((EmitterViewerSPI::MPSSquareRootOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x127:
      EmitterViewerSPI::MPSSqueezeOpHandler::MPSSqueezeOpHandler((EmitterViewerSPI::MPSSqueezeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x128:
      EmitterViewerSPI::MPSStencilOpHandler::MPSStencilOpHandler((EmitterViewerSPI::MPSStencilOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x129:
      EmitterViewerSPI::MPSStridedSliceGradientOpHandler::MPSStridedSliceGradientOpHandler((EmitterViewerSPI::MPSStridedSliceGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x12A:
      EmitterViewerSPI::MPSStridedSliceOpHandler::MPSStridedSliceOpHandler((EmitterViewerSPI::MPSStridedSliceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x12B:
      EmitterViewerSPI::MPSStridedSliceUpdateOpHandler::MPSStridedSliceUpdateOpHandler((EmitterViewerSPI::MPSStridedSliceUpdateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x12C:
      EmitterViewerSPI::MPSSubtractOpHandler::MPSSubtractOpHandler((EmitterViewerSPI::MPSSubtractOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x12D:
      EmitterViewerSPI::MPSSwishOpHandler::MPSSwishOpHandler((EmitterViewerSPI::MPSSwishOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x12E:
      EmitterViewerSPI::MPSTanOpHandler::MPSTanOpHandler((EmitterViewerSPI::MPSTanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x12F:
      EmitterViewerSPI::MPSTanhOpHandler::MPSTanhOpHandler((EmitterViewerSPI::MPSTanhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x130:
      EmitterViewerSPI::MPSTileGradientOpHandler::MPSTileGradientOpHandler((EmitterViewerSPI::MPSTileGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x131:
      EmitterViewerSPI::MPSTileOpHandler::MPSTileOpHandler((EmitterViewerSPI::MPSTileOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x132:
      EmitterViewerSPI::MPSTopKGradientOpHandler::MPSTopKGradientOpHandler((EmitterViewerSPI::MPSTopKGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x133:
      EmitterViewerSPI::MPSTopKOpHandler::MPSTopKOpHandler((EmitterViewerSPI::MPSTopKOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x134:
      EmitterViewerSPI::MPSTransposeOpHandler::MPSTransposeOpHandler((EmitterViewerSPI::MPSTransposeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x135:
      EmitterViewerSPI::MPSTruncateOpHandler::MPSTruncateOpHandler((EmitterViewerSPI::MPSTruncateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x136:
      EmitterViewerSPI::MPSTypeConstraintOpHandler::MPSTypeConstraintOpHandler((EmitterViewerSPI::MPSTypeConstraintOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x137:
      EmitterViewerSPI::MPSUnrealizedFoldOpHandler::MPSUnrealizedFoldOpHandler((EmitterViewerSPI::MPSUnrealizedFoldOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x138:
      EmitterViewerSPI::MPSUpdateRandomStateOpHandler::MPSUpdateRandomStateOpHandler((EmitterViewerSPI::MPSUpdateRandomStateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x139:
      EmitterViewerSPI::MPSVariableFromTensorOpHandler::MPSVariableFromTensorOpHandler((EmitterViewerSPI::MPSVariableFromTensorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x13A:
      EmitterViewerSPI::MPSXnorOpHandler::MPSXnorOpHandler((EmitterViewerSPI::MPSXnorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x13B:
      EmitterViewerSPI::MPSXorOpHandler::MPSXorOpHandler((EmitterViewerSPI::MPSXorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x13C:
      EmitterViewerSPI::ConditionOpHandler::ConditionOpHandler((EmitterViewerSPI::ConditionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x13D:
      EmitterViewerSPI::ForOpHandler::ForOpHandler((EmitterViewerSPI::ForOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x13E:
      EmitterViewerSPI::IfOpHandler::IfOpHandler((EmitterViewerSPI::IfOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x13F:
      EmitterViewerSPI::MPSExtractOpHandler::MPSExtractOpHandler((EmitterViewerSPI::MPSExtractOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x140:
      EmitterViewerSPI::MPSFromElementsOpHandler::MPSFromElementsOpHandler((EmitterViewerSPI::MPSFromElementsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x141:
      EmitterViewerSPI::MPSFuncOpHandler::MPSFuncOpHandler((EmitterViewerSPI::MPSFuncOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x142:
      EmitterViewerSPI::MPSModuleOpHandler::MPSModuleOpHandler((EmitterViewerSPI::MPSModuleOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x143:
      EmitterViewerSPI::MPSReturnOpHandler::MPSReturnOpHandler((EmitterViewerSPI::MPSReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x144:
      EmitterViewerSPI::WhileOpHandler::WhileOpHandler((EmitterViewerSPI::WhileOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x145:
      EmitterViewerSPI::YieldOpHandler::YieldOpHandler((EmitterViewerSPI::YieldOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x146:
      EmitterViewerSPI::MPSXANEOpHandler::MPSXANEOpHandler((EmitterViewerSPI::MPSXANEOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x147:
      EmitterViewerSPI::MPSXCPUOpHandler::MPSXCPUOpHandler((EmitterViewerSPI::MPSXCPUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x148:
      EmitterViewerSPI::MPSXDeinterleaveOpHandler::MPSXDeinterleaveOpHandler((EmitterViewerSPI::MPSXDeinterleaveOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x149:
      EmitterViewerSPI::MPSXFPToIntClampedOpHandler::MPSXFPToIntClampedOpHandler((EmitterViewerSPI::MPSXFPToIntClampedOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x14A:
      EmitterViewerSPI::MPSXFileBackedConstantOpHandler::MPSXFileBackedConstantOpHandler((EmitterViewerSPI::MPSXFileBackedConstantOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x14B:
      EmitterViewerSPI::MPSXGPUOpHandler::MPSXGPUOpHandler((EmitterViewerSPI::MPSXGPUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x14C:
      EmitterViewerSPI::MPSXInterleaveOpHandler::MPSXInterleaveOpHandler((EmitterViewerSPI::MPSXInterleaveOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x14D:
      EmitterViewerSPI::MPSXListPopBackOpHandler::MPSXListPopBackOpHandler((EmitterViewerSPI::MPSXListPopBackOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x14E:
      EmitterViewerSPI::MPSXListPushBackOpHandler::MPSXListPushBackOpHandler((EmitterViewerSPI::MPSXListPushBackOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x14F:
      EmitterViewerSPI::MPSXMakeListOpHandler::MPSXMakeListOpHandler((EmitterViewerSPI::MPSXMakeListOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x150:
      EmitterViewerSPI::MPSXQuantizedGatherOpHandler::MPSXQuantizedGatherOpHandler((EmitterViewerSPI::MPSXQuantizedGatherOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x151:
      EmitterViewerSPI::MPSXQuantizedMatMulOpHandler::MPSXQuantizedMatMulOpHandler((EmitterViewerSPI::MPSXQuantizedMatMulOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x152:
      EmitterViewerSPI::MPSXRMSNormOpHandler::MPSXRMSNormOpHandler((EmitterViewerSPI::MPSXRMSNormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x153:
      EmitterViewerSPI::MPSXRegionReturnOpHandler::MPSXRegionReturnOpHandler((EmitterViewerSPI::MPSXRegionReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x154:
      EmitterViewerSPI::MPSXReturnStitchedOpHandler::MPSXReturnStitchedOpHandler((EmitterViewerSPI::MPSXReturnStitchedOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x155:
      EmitterViewerSPI::MPSXScaledDotProductAttentionOpHandler::MPSXScaledDotProductAttentionOpHandler((EmitterViewerSPI::MPSXScaledDotProductAttentionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x156:
      EmitterViewerSPI::MPSXSparseDenseMatMulOpHandler::MPSXSparseDenseMatMulOpHandler((EmitterViewerSPI::MPSXSparseDenseMatMulOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x157:
      EmitterViewerSPI::MPSXStitchedOpHandler::MPSXStitchedOpHandler((EmitterViewerSPI::MPSXStitchedOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x158:
      EmitterViewerSPI::MPSXVarHandleOpHandler::MPSXVarHandleOpHandler((EmitterViewerSPI::MPSXVarHandleOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x159:
      EmitterViewerSPI::PlacementANEIOCastOpHandler::PlacementANEIOCastOpHandler((EmitterViewerSPI::PlacementANEIOCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x15A:
      EmitterViewerSPI::PlacementHostTypeCastOpHandler::PlacementHostTypeCastOpHandler((EmitterViewerSPI::PlacementHostTypeCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x15B:
      EmitterViewerSPI::PlacementMemrefToTensorOpHandler::PlacementMemrefToTensorOpHandler((EmitterViewerSPI::PlacementMemrefToTensorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x15C:
      EmitterViewerSPI::PlacementRegionCallOpHandler::PlacementRegionCallOpHandler((EmitterViewerSPI::PlacementRegionCallOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x15D:
      EmitterViewerSPI::PlacementReplacedOpsOpHandler::PlacementReplacedOpsOpHandler((EmitterViewerSPI::PlacementReplacedOpsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x15E:
      EmitterViewerSPI::PlacementReplacedOpsLiveOutsOpHandler::PlacementReplacedOpsLiveOutsOpHandler((EmitterViewerSPI::PlacementReplacedOpsLiveOutsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x15F:
      EmitterViewerSPI::PlacementStartTimerOpHandler::PlacementStartTimerOpHandler((EmitterViewerSPI::PlacementStartTimerOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x160:
      EmitterViewerSPI::PlacementStopTimerOpHandler::PlacementStopTimerOpHandler((EmitterViewerSPI::PlacementStopTimerOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x161:
      EmitterViewerSPI::PlacementTensorToMemrefOpHandler::PlacementTensorToMemrefOpHandler((EmitterViewerSPI::PlacementTensorToMemrefOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_418;
    case 0x162:
      EmitterViewerSPI::ReturnOpHandler::ReturnOpHandler((EmitterViewerSPI::ReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
LABEL_418:
      v30 = (MPSGraphViewerNodeSPI *)v73;

      goto LABEL_419;
    default:
      if (MTLReportFailureTypeEnabled())
      {
        v32 = (void **)&__dst;
        if (v76 < 0)
          v32 = (void **)__dst;
        v65 = v32;
        MTLReportFailure();
      }
      v77 = *(_QWORD *)(*(_QWORD *)&a2[1]._dataType + 8);
      v33 = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v77);
      std::string::basic_string[abi:ne180100]<0>(__p, v33);
      if (v72 >= 0)
        v34 = __p;
      else
        v34 = (void **)__p[0];
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v34, 4, v65);
      v70 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0C99DE8], "array");
      v69 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0C99DE8], "array");
      v35 = (void *)objc_claimAutoreleasedReturnValue();
      if ((BYTE6(a2[1].super.super.isa) & 0x80) == 0)
        goto LABEL_439;
      shape_high = HIDWORD(a2[1]._shape);
      if (!(_DWORD)shape_high)
        goto LABEL_439;
      v37 = 0;
      v38 = 24;
      v67 = "Operation.h";
      v68 = "hasOperandStorage && \"expected operation to have operand storage\"";
      v66 = "getOperandStorage";
      break;
  }
  while (2)
  {
    if ((BYTE6(a2[1].super.super.isa) & 0x80) == 0)
    {
      v60 = 960;
      goto LABEL_467;
    }
    if (v37 >= HIDWORD(a2[1]._shape))
    {
      v60 = 443;
      v66 = "operator[]";
      v67 = "ArrayRef.h";
      v68 = "Index < this->size() && \"Invalid index!\"";
LABEL_467:
      __assert_rtn(v66, v67, v60, v68);
    }
    v39 = *(_QWORD *)(a2[1]._valueRef + v38);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("in%d"), v37, v66, v67, v68);
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeInputPort((uint64_t)this, v40, v39);
    v41 = (void *)objc_claimAutoreleasedReturnValue();

    if (v41)
      objc_msgSend(v35, "addObject:", v41);

    ++v37;
    v38 += 32;
    if (shape_high != v37)
      continue;
    break;
  }
LABEL_439:
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  valueRef_high = HIDWORD(a2->_valueRef);
  if (!(_DWORD)valueRef_high)
    goto LABEL_463;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("out%d"), 0);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v44, (MPSGraphViewerNodePortSPI *)((char *)a2 - 16));
  v45 = (void *)objc_claimAutoreleasedReturnValue();

  if (v45)
    objc_msgSend(v42, "addObject:", v45);

  if ((_DWORD)valueRef_high == 1)
    goto LABEL_463;
  if (HIDWORD(a2->_valueRef) < 2)
    goto LABEL_473;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("out%d"), 1);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v46, (MPSGraphViewerNodePortSPI *)((char *)a2 - 32));
  v47 = (void *)objc_claimAutoreleasedReturnValue();

  if (v47)
    objc_msgSend(v42, "addObject:", v47);

  if ((_DWORD)valueRef_high == 2)
    goto LABEL_463;
  if (HIDWORD(a2->_valueRef) < 3)
    goto LABEL_473;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("out%d"), 2);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v48, (MPSGraphViewerNodePortSPI *)((char *)a2 - 48));
  v49 = (void *)objc_claimAutoreleasedReturnValue();

  if (v49)
    objc_msgSend(v42, "addObject:", v49);

  if ((_DWORD)valueRef_high == 3)
    goto LABEL_463;
  if (HIDWORD(a2->_valueRef) < 4)
    goto LABEL_473;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("out%d"), 3);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v50, (MPSGraphViewerNodePortSPI *)((char *)a2 - 64));
  v51 = (void *)objc_claimAutoreleasedReturnValue();

  if (v51)
    objc_msgSend(v42, "addObject:", v51);

  if ((_DWORD)valueRef_high == 4)
    goto LABEL_463;
  if (HIDWORD(a2->_valueRef) < 5)
    goto LABEL_473;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("out%d"), 4);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v52, a2 - 2);
  v53 = (void *)objc_claimAutoreleasedReturnValue();

  if (v53)
    objc_msgSend(v42, "addObject:", v53);

  if ((_DWORD)valueRef_high == 5)
    goto LABEL_463;
  if (HIDWORD(a2->_valueRef) < 6)
LABEL_473:
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("out%d"), 5);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v54, (MPSGraphViewerNodePortSPI *)((char *)a2 - 96));
  v55 = (void *)objc_claimAutoreleasedReturnValue();

  if (v55)
    objc_msgSend(v42, "addObject:", v55);

  if ((_DWORD)valueRef_high != 6)
  {
    v61 = a2 - 3;
    v62 = 6;
    while (v62 < HIDWORD(a2->_valueRef))
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("out%d"), v62);
      v63 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v63, v61);
      v64 = (void *)objc_claimAutoreleasedReturnValue();

      if (v64)
        objc_msgSend(v42, "addObject:", v64);

      ++v62;
      v61 = (MPSGraphViewerNodePortSPI *)((char *)v61 - 24);
      if (valueRef_high == v62)
        goto LABEL_463;
    }
    goto LABEL_473;
  }
LABEL_463:
  v56 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v35);
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v42);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v69);
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v56, "initWithType:inputs:outputs:properties:regions:", v70, v57, v58, v59, MEMORY[0x1E0C9AA60]);

  if (v72 < 0)
    operator delete(__p[0]);
LABEL_419:
  if (SHIBYTE(v76) < 0)
    operator delete(__dst);
  return v30;
}

void sub_180E8B04C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;

  JUMPOUT(0x180E8B0ECLL);
}

void sub_180E8B064()
{
  void *v0;
  void *v1;
  void *v2;

  JUMPOUT(0x180E8B0ECLL);
}

void sub_180E8B08C()
{
  JUMPOUT(0x180E8B0FCLL);
}

void sub_180E8B094()
{
  JUMPOUT(0x180E8B104);
}

void sub_180E8B09C()
{
  JUMPOUT(0x180E8B10CLL);
}

void sub_180E8B0BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0)
    JUMPOUT(0x180E8B134);
  JUMPOUT(0x180E8B124);
}

void sub_180E8B0CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;
  void *v28;

  if (a20 < 0)
  {
    operator delete(a15);
    if ((a27 & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((a27 & 0x80000000) == 0)
  {
LABEL_3:
    _Unwind_Resume(a1);
  }
  operator delete(a22);
  _Unwind_Resume(a1);
}

void sub_180E8B0DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;
  void *v28;

  if (a20 < 0)
  {
    operator delete(a15);
    if ((a27 & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((a27 & 0x80000000) == 0)
  {
LABEL_3:
    _Unwind_Resume(a1);
  }
  operator delete(a22);
  _Unwind_Resume(a1);
}

void sub_180E8B0E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;
  void *v28;

  if (a20 < 0)
  {
    operator delete(__p);
    if ((a27 & 0x80000000) == 0)
      goto LABEL_3;
  }
  else if ((a27 & 0x80000000) == 0)
  {
LABEL_3:
    _Unwind_Resume(a1);
  }
  operator delete(a22);
  _Unwind_Resume(a1);
}

MPSGraphViewerNodePortSPI *EmitViewerSPI::emitNodeInputPort(uint64_t a1, void *a2, unint64_t a3)
{
  id v5;
  uint64_t MPSDataType;
  void *v7;
  MPSGraphViewerNodePortSPI *v8;
  _QWORD *v9;
  uint64_t v10;
  MPSGraphViewerNodePortSPI *v11;
  unint64_t v13;

  v5 = a2;
  if (a3)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8));
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = [MPSGraphViewerNodePortSPI alloc];
    v9 = std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)(a1 + 232), a3);
    if (v9)
    {
      v10 = v9[3];
    }
    else
    {
      if (MTLReportFailureTypeEnabled())
      {
        v13 = a3;
        MTLReportFailure();
      }
      v10 = -1;
    }
    v11 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:](v8, "initWithName:dataType:shape:valueRef:", v5, MPSDataType, v7, v10, v13);

  }
  else
  {
    v11 = 0;
  }

  return v11;
}

void sub_180E8B22C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E8B23C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E8B24C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

MPSGraphViewerSPI *EmitViewerSPI::emitGraph(EmitViewerSPI *this)
{
  MPSGraphViewerSPI *v2;
  void *v3;
  MPSGraphViewerSPI *v4;

  v2 = [MPSGraphViewerSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", *((_QWORD *)this + 22));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = -[MPSGraphViewerSPI initWithName:nodes:](v2, "initWithName:nodes:", &stru_1E0E7A578, v3);

  return v4;
}

void sub_180E8B2C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void EmitViewerSPI::emitJSONDump(id *this, NSString *a2)
{
  NSString *v3;
  id *WeakRetained;
  id *v5;
  void *v6;
  MPSGraphViewerSPI *v7;
  void *v8;
  MPSGraphViewerSPI *v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  char v14;
  id v15;
  id v16;
  const char *v17;
  id v18;
  id v19;
  id v20;
  id v21;

  v3 = a2;
  if (!v3)
  {
    WeakRetained = (id *)objc_loadWeakRetained(this + 8);
    v3 = (NSString *)WeakRetained[72];

  }
  v5 = (id *)objc_loadWeakRetained(this + 8);
  objc_msgSend(v5[74], "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v3, 1, 0, 0);

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@/model.mpsasteria"), v3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = [MPSGraphViewerSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", this[22]);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = -[MPSGraphViewerSPI initWithName:nodes:](v7, "initWithName:nodes:", &stru_1E0E7A578, v8);

  v10 = (void *)MEMORY[0x1E0CB36D8];
  -[MPSGraphViewerSPI jsonDictionary](v9, "jsonDictionary");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v21 = 0;
  objc_msgSend(v10, "dataWithJSONObject:options:error:", v11, 1, &v21);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = v21;

  if (v12)
  {
    v20 = v13;
    v14 = objc_msgSend(v12, "writeToFile:options:error:", v6, 1, &v20);
    v15 = v20;

    if ((v14 & 1) == 0)
    {
      v16 = objc_retainAutorelease(v6);
      if (!v15)
      {
        printf("EmitViewerSPI : unable to write model to %s", (const char *)objc_msgSend(v16, "UTF8String"));
        v13 = 0;
        goto LABEL_12;
      }
      v17 = (const char *)objc_msgSend(v16, "UTF8String");
      objc_msgSend(v15, "description");
      v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      printf("EmitViewerSPI : unable to write model to %s: %s\n", v17, (const char *)objc_msgSend(v18, "UTF8String"));

    }
    v13 = v15;
  }
  else if (v13)
  {
    objc_msgSend(v13, "description");
    v19 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    printf("EmitViewerSPI : unable to serialize model: %s\n", (const char *)objc_msgSend(v19, "UTF8String"));

  }
  else
  {
    printf("EmitViewerSPI : unable to serialize model");
  }
LABEL_12:

}

void sub_180E8B51C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v6;

  _Unwind_Resume(a1);
}

void sub_180E8B5B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

MPSGraphViewerNodePortSPI *EmitViewerSPI::emitNodeOutputPort(void *a1, uint64_t **a2)
{
  id v3;
  void *v4;
  uint64_t MPSDataType;
  void *v6;
  MPSGraphViewerNodePortSPI *v7;

  v3 = a1;
  v4 = v3;
  if (a2)
  {
    MPSDataType = getMPSDataType(a2);
    getMPSShapeFromMLIR(a2);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", v4, MPSDataType, v6, -1);

    return v7;
  }
  else
  {

    return (MPSGraphViewerNodePortSPI *)0;
  }
}

void sub_180E8B65C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E8B670(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

MPSGraphViewerNodePropertyStringSPI *EmitViewerSPI::emitStringProperty(void *a1, const void *a2, size_t a3)
{
  id v5;
  void *v6;
  void **v7;
  void **p_dst;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  MPSGraphViewerNodePropertyStringSPI *v12;
  void **__dst;
  size_t v15;
  int64_t v16;

  v5 = a1;
  v6 = (void *)MEMORY[0x1E0CB3940];
  if (!a2)
  {
    __dst = 0;
    v15 = 0;
    p_dst = (void **)&__dst;
    v16 = 0;
    goto LABEL_14;
  }
  if (a3 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a3 >= 0x17)
  {
    v9 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v9 = a3 | 7;
    v10 = v9 + 1;
    v7 = (void **)operator new(v9 + 1);
    v15 = a3;
    v16 = v10 | 0x8000000000000000;
    __dst = v7;
    goto LABEL_10;
  }
  HIBYTE(v16) = a3;
  v7 = (void **)&__dst;
  if (a3)
LABEL_10:
    memmove(v7, a2, a3);
  *((_BYTE *)v7 + a3) = 0;
  if (v16 >= 0)
    p_dst = (void **)&__dst;
  else
    p_dst = __dst;
LABEL_14:
  objc_msgSend(v6, "stringWithCString:encoding:", p_dst, 4);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if (SHIBYTE(v16) < 0)
    operator delete(__dst);
  v12 = -[MPSGraphViewerNodePropertyStringSPI initWithName:value:]([MPSGraphViewerNodePropertyStringSPI alloc], "initWithName:value:", v5, v11);

  return v12;
}

void sub_180E8B7B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E8B7C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;

  if (a15 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

MPSGraphViewerNodePropertyDataSPI *EmitViewerSPI::emitElementsAttrProperty(void *a1, uint64_t a2, uint64_t a3)
{
  id v4;
  uint64_t NumElements;
  _QWORD *Type;
  uint64_t MPSDataType;
  uint64_t **v8;
  void *v9;
  MPSGraphViewerNodePropertyDataSPI *v10;
  int v11;
  void *v12;
  MPSGraphViewerNodePropertyDataSPI *v13;
  uint64_t SplatIntegerValue;
  void *v16[10];
  _QWORD v17[2];

  v17[0] = a2;
  v17[1] = a3;
  v4 = a1;
  mlir::mps::CPUNDArray::CPUNDArray(v16, a2);
  NumElements = mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v16);
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v17);
  MPSDataType = getMPSDataType(Type);
  v8 = (uint64_t **)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v17);
  getMPSShapeFromMLIR(v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", v4, MPSDataType, v9);
  if (!v10)
    goto LABEL_13;
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v17))
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v16[5], (NumElements * (unint64_t)(unsigned __int16)MPSDataType + 7) >> 3);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v10, "setValue:", v12);
    goto LABEL_6;
  }
  if (!mlir::mps::CPUNDArray::isComplexType((mlir::mps::CPUNDArray *)v16))
  {
    if (mlir::mps::CPUNDArray::isFloatType((mlir::mps::CPUNDArray *)v16))
    {
      LODWORD(SplatIntegerValue) = mlir::mps::CPUNDArray::getSplatFloatValue((mlir::mps::CPUNDArray *)v16);
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &SplatIntegerValue, 4);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setSplatValue:](v10, "setSplatValue:", v12);
      goto LABEL_6;
    }
    if (mlir::mps::CPUNDArray::isIntegerType((mlir::mps::CPUNDArray *)v16))
    {
      SplatIntegerValue = mlir::mps::CPUNDArray::getSplatIntegerValue((mlir::mps::CPUNDArray *)v16);
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &SplatIntegerValue, 8);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setSplatValue:](v10, "setSplatValue:", v12);
      goto LABEL_6;
    }
    if (MTLReportFailureTypeEnabled())
    {
      MTLReportFailure();
      v13 = 0;
      goto LABEL_14;
    }
LABEL_13:
    v13 = 0;
    goto LABEL_14;
  }
  LODWORD(SplatIntegerValue) = mlir::mps::CPUNDArray::getSplatComplexValue((__int16 **)v16);
  HIDWORD(SplatIntegerValue) = v11;
  objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &SplatIntegerValue, 8);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  -[MPSGraphViewerNodePropertyDataSPI setSplatValue:](v10, "setSplatValue:", v12);
LABEL_6:

  v13 = v10;
LABEL_14:

  mlir::mps::CPUNDArray::~CPUNDArray(v16);
  return v13;
}

void sub_180E8BA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  va_list va;

  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((void **)va);
  _Unwind_Resume(a1);
}

void sub_180E8BA78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  void *v4;
  void *v5;
  va_list va;

  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((void **)va);
  _Unwind_Resume(a1);
}

void sub_180E8BA98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  void *v4;
  void *v5;
  va_list va;

  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((void **)va);
  _Unwind_Resume(a1);
}

void sub_180E8BAB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  va_list va;

  va_start(va, a3);
  mlir::mps::CPUNDArray::~CPUNDArray((void **)va);

  _Unwind_Resume(a1);
}

void sub_180E8BAD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_180E8BAE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  void *v4;
  void *v5;
  va_list va;

  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((void **)va);
  _Unwind_Resume(a1);
}

void sub_180E8BB00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  void *v4;
  va_list va;

  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((void **)va);
  _Unwind_Resume(a1);
}

void sub_180E8BB1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  va_list va;

  va_start(va, a3);
  mlir::mps::CPUNDArray::~CPUNDArray((void **)va);

  _Unwind_Resume(a1);
}

void sub_180E8BB34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  va_list va;

  va_start(va, a3);
  mlir::mps::CPUNDArray::~CPUNDArray((void **)va);

  _Unwind_Resume(a1);
}

void EmitViewerSPI::~EmitViewerSPI(EmitViewerSPI *this)
{
  EmitViewerSPI::~EmitViewerSPI(this);
  JUMPOUT(0x186DA1680);
}

{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void **v5;
  void *v6;
  void **v7;

  *(_QWORD *)this = &off_1E0E029B8;
  v2 = (_QWORD *)*((_QWORD *)this + 31);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)*((_QWORD *)this + 29);
  *((_QWORD *)this + 29) = 0;
  if (v4)
    operator delete(v4);
  v5 = (void **)*((_QWORD *)this + 25);
  if (v5)
  {
    do
    {
      v7 = (void **)*v5;
      if (*((char *)v5 + 39) < 0)
        operator delete(v5[2]);
      operator delete(v5);
      v5 = v7;
    }
    while (v7);
  }
  v6 = (void *)*((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v6)
    operator delete(v6);

  EmitBase::~EmitBase(this);
}

uint64_t EmitViewerSPI::getNewTensorNameForValue(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  _QWORD *v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t prime;
  void *v23;
  void *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  size_t v28;
  size_t v29;
  size_t v30;
  _QWORD *i;
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint8x8_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  size_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  unint64_t v44;

  v5 = *(_QWORD *)(a1 + 224);
  *(_QWORD *)(a1 + 224) = v5 + 1;
  v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 240);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v2 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v2 = v8 % v9;
    }
    else
    {
      v2 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)(a1 + 232) + 8 * v2);
    if (v11)
    {
      v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2)
                goto LABEL_93;
            }
            else if ((v14 & (v9 - 1)) != v2)
            {
              goto LABEL_22;
            }
            v12 = (_QWORD *)*v12;
            if (!v12)
              goto LABEL_22;
          }
        }
        do
        {
          v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2)
              goto LABEL_93;
          }
          else
          {
            if (v13 >= v9)
              v13 %= v9;
            if (v13 != v2)
              break;
          }
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  v12 = operator new(0x20uLL);
  *v12 = 0;
  v12[1] = v8;
  v12[2] = a2;
  v12[3] = 0;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 256) + 1);
  v16 = *(float *)(a1 + 264);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v19 = 1;
    if (v9 >= 3)
      v19 = (v9 & (v9 - 1)) != 0;
    v20 = v19 | (2 * v9);
    v21 = vcvtps_u32_f32(v15 / v16);
    if (v20 <= v21)
      prime = v21;
    else
      prime = v20;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v9 = *(_QWORD *)(a1 + 240);
    }
    if (prime > v9)
    {
LABEL_36:
      if (prime >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v23 = operator new(8 * prime);
      v24 = *(void **)(a1 + 232);
      *(_QWORD *)(a1 + 232) = v23;
      if (v24)
        operator delete(v24);
      v25 = 0;
      *(_QWORD *)(a1 + 240) = prime;
      do
        *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v25++) = 0;
      while (prime != v25);
      v27 = a1 + 248;
      v26 = *(_QWORD **)(a1 + 248);
      if (!v26)
        goto LABEL_68;
      v28 = v26[1];
      v29 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        v30 = v28 & v29;
        *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v30) = v27;
        for (i = (_QWORD *)*v26; *v26; i = (_QWORD *)*v26)
        {
          v32 = i[1] & v29;
          if (v32 == v30)
          {
            v26 = i;
          }
          else
          {
            v33 = *(_QWORD *)(a1 + 232);
            if (*(_QWORD *)(v33 + 8 * v32))
            {
              *v26 = *i;
              v34 = 8 * v32;
              *i = **(_QWORD **)(*(_QWORD *)(a1 + 232) + v34);
              **(_QWORD **)(*(_QWORD *)(a1 + 232) + v34) = i;
            }
            else
            {
              *(_QWORD *)(v33 + 8 * v32) = v26;
              v26 = i;
              v30 = v32;
            }
          }
        }
        goto LABEL_68;
      }
      if (v28 >= prime)
        v28 %= prime;
      *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v28) = v27;
      v38 = (_QWORD *)*v26;
      if (!*v26)
      {
LABEL_68:
        v9 = prime;
        v42 = prime - 1;
        if ((prime & (prime - 1)) != 0)
          goto LABEL_69;
        goto LABEL_84;
      }
      while (1)
      {
        v40 = v38[1];
        if (v40 >= prime)
          v40 %= prime;
        if (v40 == v28)
          goto LABEL_62;
        v41 = *(_QWORD *)(a1 + 232);
        if (*(_QWORD *)(v41 + 8 * v40))
        {
          *v26 = *v38;
          v39 = 8 * v40;
          *v38 = **(_QWORD **)(*(_QWORD *)(a1 + 232) + v39);
          **(_QWORD **)(*(_QWORD *)(a1 + 232) + v39) = v38;
          v38 = v26;
LABEL_62:
          v26 = v38;
          v38 = (_QWORD *)*v38;
          if (!v38)
            goto LABEL_68;
        }
        else
        {
          *(_QWORD *)(v41 + 8 * v40) = v26;
          v26 = v38;
          v38 = (_QWORD *)*v38;
          v28 = v40;
          if (!v38)
            goto LABEL_68;
        }
      }
    }
    if (prime < v9)
    {
      v35 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 256) / *(float *)(a1 + 264));
      if (v9 < 3 || (v36 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
      {
        v35 = std::__next_prime(v35);
      }
      else
      {
        v37 = 1 << -(char)__clz(v35 - 1);
        if (v35 >= 2)
          v35 = v37;
      }
      if (prime <= v35)
        prime = v35;
      if (prime < v9)
      {
        if (!prime)
        {
          v43 = *(void **)(a1 + 232);
          *(_QWORD *)(a1 + 232) = 0;
          if (v43)
            operator delete(v43);
          v9 = 0;
          *(_QWORD *)(a1 + 240) = 0;
          v42 = -1;
          goto LABEL_84;
        }
        goto LABEL_36;
      }
      v9 = *(_QWORD *)(a1 + 240);
    }
    v42 = v9 - 1;
    if ((v9 & (v9 - 1)) != 0)
    {
LABEL_69:
      if (v8 >= v9)
      {
        v2 = v8 % v9;
        v17 = *(_QWORD *)(a1 + 232);
        v18 = *(_QWORD **)(v17 + 8 * (v8 % v9));
        if (v18)
          goto LABEL_25;
      }
      else
      {
        v2 = v8;
        v17 = *(_QWORD *)(a1 + 232);
        v18 = *(_QWORD **)(v17 + 8 * v8);
        if (v18)
          goto LABEL_25;
      }
      goto LABEL_85;
    }
LABEL_84:
    v2 = v42 & v8;
    v17 = *(_QWORD *)(a1 + 232);
    v18 = *(_QWORD **)(v17 + 8 * (v42 & v8));
    if (v18)
      goto LABEL_25;
    goto LABEL_85;
  }
  v17 = *(_QWORD *)(a1 + 232);
  v18 = *(_QWORD **)(v17 + 8 * v2);
  if (v18)
  {
LABEL_25:
    *v12 = *v18;
LABEL_91:
    *v18 = v12;
    goto LABEL_92;
  }
LABEL_85:
  *v12 = *(_QWORD *)(a1 + 248);
  *(_QWORD *)(a1 + 248) = v12;
  *(_QWORD *)(v17 + 8 * v2) = a1 + 248;
  if (*v12)
  {
    v44 = *(_QWORD *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v44 >= v9)
        v44 %= v9;
    }
    else
    {
      v44 &= v9 - 1;
    }
    v18 = (_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v44);
    goto LABEL_91;
  }
LABEL_92:
  ++*(_QWORD *)(a1 + 256);
LABEL_93:
  v12[3] = v5;
  return v5;
}

void sub_180E8C054(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::func::FuncOp,mlir::Operation &,llvm::CastInfo<mlir::func::FuncOp,mlir::Operation,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1;
  void *v2;
  uint64_t AttrData;
  uint64_t v4;
  const char *v6;
  __int16 v7;
  uint64_t v8[4];
  __int16 v9;
  _QWORD v10[5];

  v1 = *(_QWORD *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(_QWORD *)(v1 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(_QWORD *)AttrData == 0x6E75662E636E7566 && *(_BYTE *)(AttrData + 8) == 99)
    {
      v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"func.func";
      v8[3] = 9;
      v6 = "' failed due to the operation not being registered";
      v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    return 0;
  }
  return result;
}

EmitterViewerSPI::ANECA11LegacyOpHandler *EmitterViewerSPI::ANECA11LegacyOpHandler::ANECA11LegacyOpHandler(EmitterViewerSPI::ANECA11LegacyOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  void *v15;
  const void *SymName;
  size_t v17;
  void *v18;
  unint64_t v19;
  uint64_t Results;
  unint64_t v21;
  uint64_t **v22;
  void *v23;
  void *v24;
  _QWORD *Body;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  void *v34;
  id v35;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v46;
  mlir::GenericProgramPoint *v47;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v49;
  void *v50;
  _QWORD *AttrData;
  uint64_t v52;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  mlir::Operation *v58;
  const char *v59;
  __int16 v60;
  uint64_t v61[4];
  __int16 v62;
  void *__dst[2];
  int64_t v64;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03AB8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 14 && *AttrData == 0x3131412E63656E61 && *(_QWORD *)((char *)AttrData + 6) == 0x79636167654C3131)
    {
      v62 = 1283;
      v61[0] = (uint64_t)"classof on '";
      v61[2] = (uint64_t)"anec.A11Legacy";
      v61[3] = 14;
      v59 = "' failed due to the operation not being registered";
      v60 = 259;
      llvm::operator+(v61, (uint64_t *)&v59, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_58:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A11Legacy,void>::id)
    goto LABEL_58;
  v58 = a3;
  v61[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v61);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v64 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v64) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v64 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v58);
  EmitViewerSPI::emitStringProperty(CFSTR("sym_name"), SymName, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v55, "addObject:", v18);
  v19 = 0;
  v61[0] = mlir::anec::A11Legacy::getFunctionType(&v58);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v61))
  {
    Results = mlir::FunctionType::getResults((mlir::FunctionType *)v61);
    if (v21 <= v19)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v22 = *(uint64_t ***)(Results + 8 * v19);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("result%d"), v19);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeOutputPort(v23, v22);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
      objc_msgSend(v15, "addObject:", v24);

    ++v19;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  v54 = (void *)v14;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v58);
  v26 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v27 = 0;
    do
    {
      v28 = Body[1];
      v29 = v28 - 8;
      if (!v28)
        v29 = 0;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3))
        break;
      if (v27 >= v31 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v30 + 8 * v27)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        }
        v34 = (void *)objc_claimAutoreleasedReturnValue();

        if (v34)
          objc_msgSend(v57, "addObject:", v34);

        v26 = (_QWORD *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  v35 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v46 = i - 1;
    if (!i)
      v46 = 0;
    v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (j = (mlir::GenericProgramPoint *)v46[5]; j != v47; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      if (v50)
        objc_msgSend(v35, "addObject:", v50);

    }
  }
  v37 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("body"), CFSTR("anec.region_return"), v35);
  objc_msgSend(v56, "addObject:", v37);

  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v57);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v54, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v64) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E8C754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>(_QWORD *a1, unint64_t a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = (*(_QWORD *)&v2 - 1) & v5;
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    if (v6.u32[0] < 2uLL)
    {
      v10 = *(_QWORD *)&v2 - 1;
      while (1)
      {
        v12 = result[1];
        if (v12 == v5)
        {
          if (result[2] == a2)
            return result;
        }
        else if ((v12 & v10) != v7)
        {
          return 0;
        }
        result = (_QWORD *)*result;
        if (!result)
          return result;
      }
    }
    do
    {
      v11 = result[1];
      if (v11 == v5)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v11 >= *(_QWORD *)&v2)
          v11 %= *(_QWORD *)&v2;
        if (v11 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

EmitterViewerSPI::ANECA12OpHandler *EmitterViewerSPI::ANECA12OpHandler::ANECA12OpHandler(EmitterViewerSPI::ANECA12OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  void *v15;
  const void *SymName;
  size_t v17;
  void *v18;
  unint64_t v19;
  uint64_t Results;
  unint64_t v21;
  uint64_t **v22;
  void *v23;
  void *v24;
  _QWORD *Body;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  void *v34;
  id v35;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v46;
  mlir::GenericProgramPoint *v47;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v49;
  void *v50;
  _QWORD *AttrData;
  uint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  mlir::Operation *v57;
  const char *v58;
  __int16 v59;
  uint64_t v60[4];
  __int16 v61;
  void *__dst[2];
  int64_t v63;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02CD8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3231412E63656E61)
    {
      v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A12";
      v60[3] = 8;
      v58 = "' failed due to the operation not being registered";
      v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A12,void>::id)
    goto LABEL_54;
  v57 = a3;
  v60[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v63 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  EmitViewerSPI::emitStringProperty(CFSTR("sym_name"), SymName, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v54, "addObject:", v18);
  v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v22 = *(uint64_t ***)(Results + 8 * v19);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("result%d"), v19);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeOutputPort(v23, v22);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
      objc_msgSend(v15, "addObject:", v24);

    ++v19;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = (void *)v14;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  v26 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v27 = 0;
    do
    {
      v28 = Body[1];
      v29 = v28 - 8;
      if (!v28)
        v29 = 0;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3))
        break;
      if (v27 >= v31 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v30 + 8 * v27)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        }
        v34 = (void *)objc_claimAutoreleasedReturnValue();

        if (v34)
          objc_msgSend(v56, "addObject:", v34);

        v26 = (_QWORD *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  v35 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v46 = i - 1;
    if (!i)
      v46 = 0;
    v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (j = (mlir::GenericProgramPoint *)v46[5]; j != v47; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      if (v50)
        objc_msgSend(v35, "addObject:", v50);

    }
  }
  v37 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("body"), CFSTR("anec.region_return"), v35);
  objc_msgSend(v55, "addObject:", v37);

  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v54);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v53, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v63) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E8CFD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA13OpHandler *EmitterViewerSPI::ANECA13OpHandler::ANECA13OpHandler(EmitterViewerSPI::ANECA13OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  void *v15;
  const void *SymName;
  size_t v17;
  void *v18;
  unint64_t v19;
  uint64_t Results;
  unint64_t v21;
  uint64_t **v22;
  void *v23;
  void *v24;
  _QWORD *Body;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  void *v34;
  id v35;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v46;
  mlir::GenericProgramPoint *v47;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v49;
  void *v50;
  _QWORD *AttrData;
  uint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  mlir::Operation *v57;
  const char *v58;
  __int16 v59;
  uint64_t v60[4];
  __int16 v61;
  void *__dst[2];
  int64_t v63;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02CF0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3331412E63656E61)
    {
      v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A13";
      v60[3] = 8;
      v58 = "' failed due to the operation not being registered";
      v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A13,void>::id)
    goto LABEL_54;
  v57 = a3;
  v60[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v63 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  EmitViewerSPI::emitStringProperty(CFSTR("sym_name"), SymName, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v54, "addObject:", v18);
  v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v22 = *(uint64_t ***)(Results + 8 * v19);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("result%d"), v19);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeOutputPort(v23, v22);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
      objc_msgSend(v15, "addObject:", v24);

    ++v19;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = (void *)v14;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  v26 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v27 = 0;
    do
    {
      v28 = Body[1];
      v29 = v28 - 8;
      if (!v28)
        v29 = 0;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3))
        break;
      if (v27 >= v31 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v30 + 8 * v27)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        }
        v34 = (void *)objc_claimAutoreleasedReturnValue();

        if (v34)
          objc_msgSend(v56, "addObject:", v34);

        v26 = (_QWORD *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  v35 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v46 = i - 1;
    if (!i)
      v46 = 0;
    v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (j = (mlir::GenericProgramPoint *)v46[5]; j != v47; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      if (v50)
        objc_msgSend(v35, "addObject:", v50);

    }
  }
  v37 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("body"), CFSTR("anec.region_return"), v35);
  objc_msgSend(v55, "addObject:", v37);

  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v54);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v53, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v63) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E8D738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA14OpHandler *EmitterViewerSPI::ANECA14OpHandler::ANECA14OpHandler(EmitterViewerSPI::ANECA14OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  void *v15;
  const void *SymName;
  size_t v17;
  void *v18;
  unint64_t v19;
  uint64_t Results;
  unint64_t v21;
  uint64_t **v22;
  void *v23;
  void *v24;
  _QWORD *Body;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  void *v34;
  id v35;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v46;
  mlir::GenericProgramPoint *v47;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v49;
  void *v50;
  _QWORD *AttrData;
  uint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  mlir::Operation *v57;
  const char *v58;
  __int16 v59;
  uint64_t v60[4];
  __int16 v61;
  void *__dst[2];
  int64_t v63;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02D08;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3431412E63656E61)
    {
      v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A14";
      v60[3] = 8;
      v58 = "' failed due to the operation not being registered";
      v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A14,void>::id)
    goto LABEL_54;
  v57 = a3;
  v60[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v63 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  EmitViewerSPI::emitStringProperty(CFSTR("sym_name"), SymName, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v54, "addObject:", v18);
  v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v22 = *(uint64_t ***)(Results + 8 * v19);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("result%d"), v19);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeOutputPort(v23, v22);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
      objc_msgSend(v15, "addObject:", v24);

    ++v19;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = (void *)v14;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  v26 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v27 = 0;
    do
    {
      v28 = Body[1];
      v29 = v28 - 8;
      if (!v28)
        v29 = 0;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3))
        break;
      if (v27 >= v31 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v30 + 8 * v27)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        }
        v34 = (void *)objc_claimAutoreleasedReturnValue();

        if (v34)
          objc_msgSend(v56, "addObject:", v34);

        v26 = (_QWORD *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  v35 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v46 = i - 1;
    if (!i)
      v46 = 0;
    v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (j = (mlir::GenericProgramPoint *)v46[5]; j != v47; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      if (v50)
        objc_msgSend(v35, "addObject:", v50);

    }
  }
  v37 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("body"), CFSTR("anec.region_return"), v35);
  objc_msgSend(v55, "addObject:", v37);

  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v54);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v53, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v63) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E8DEA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA15OpHandler *EmitterViewerSPI::ANECA15OpHandler::ANECA15OpHandler(EmitterViewerSPI::ANECA15OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  void *v15;
  const void *SymName;
  size_t v17;
  void *v18;
  unint64_t v19;
  uint64_t Results;
  unint64_t v21;
  uint64_t **v22;
  void *v23;
  void *v24;
  _QWORD *Body;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  void *v34;
  id v35;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v46;
  mlir::GenericProgramPoint *v47;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v49;
  void *v50;
  _QWORD *AttrData;
  uint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  mlir::Operation *v57;
  const char *v58;
  __int16 v59;
  uint64_t v60[4];
  __int16 v61;
  void *__dst[2];
  int64_t v63;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02D20;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3531412E63656E61)
    {
      v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A15";
      v60[3] = 8;
      v58 = "' failed due to the operation not being registered";
      v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A15,void>::id)
    goto LABEL_54;
  v57 = a3;
  v60[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v63 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  EmitViewerSPI::emitStringProperty(CFSTR("sym_name"), SymName, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v54, "addObject:", v18);
  v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v22 = *(uint64_t ***)(Results + 8 * v19);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("result%d"), v19);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeOutputPort(v23, v22);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
      objc_msgSend(v15, "addObject:", v24);

    ++v19;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = (void *)v14;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  v26 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v27 = 0;
    do
    {
      v28 = Body[1];
      v29 = v28 - 8;
      if (!v28)
        v29 = 0;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3))
        break;
      if (v27 >= v31 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v30 + 8 * v27)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        }
        v34 = (void *)objc_claimAutoreleasedReturnValue();

        if (v34)
          objc_msgSend(v56, "addObject:", v34);

        v26 = (_QWORD *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  v35 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v46 = i - 1;
    if (!i)
      v46 = 0;
    v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (j = (mlir::GenericProgramPoint *)v46[5]; j != v47; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      if (v50)
        objc_msgSend(v35, "addObject:", v50);

    }
  }
  v37 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("body"), CFSTR("anec.region_return"), v35);
  objc_msgSend(v55, "addObject:", v37);

  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v54);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v53, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v63) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E8E608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA16OpHandler *EmitterViewerSPI::ANECA16OpHandler::ANECA16OpHandler(EmitterViewerSPI::ANECA16OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  void *v15;
  const void *SymName;
  size_t v17;
  void *v18;
  unint64_t v19;
  uint64_t Results;
  unint64_t v21;
  uint64_t **v22;
  void *v23;
  void *v24;
  _QWORD *Body;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  void *v34;
  id v35;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v46;
  mlir::GenericProgramPoint *v47;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v49;
  void *v50;
  _QWORD *AttrData;
  uint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  mlir::Operation *v57;
  const char *v58;
  __int16 v59;
  uint64_t v60[4];
  __int16 v61;
  void *__dst[2];
  int64_t v63;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02D38;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3631412E63656E61)
    {
      v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A16";
      v60[3] = 8;
      v58 = "' failed due to the operation not being registered";
      v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A16,void>::id)
    goto LABEL_54;
  v57 = a3;
  v60[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v63 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  EmitViewerSPI::emitStringProperty(CFSTR("sym_name"), SymName, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v54, "addObject:", v18);
  v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v22 = *(uint64_t ***)(Results + 8 * v19);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("result%d"), v19);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeOutputPort(v23, v22);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
      objc_msgSend(v15, "addObject:", v24);

    ++v19;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = (void *)v14;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  v26 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v27 = 0;
    do
    {
      v28 = Body[1];
      v29 = v28 - 8;
      if (!v28)
        v29 = 0;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3))
        break;
      if (v27 >= v31 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v30 + 8 * v27)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        }
        v34 = (void *)objc_claimAutoreleasedReturnValue();

        if (v34)
          objc_msgSend(v56, "addObject:", v34);

        v26 = (_QWORD *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  v35 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v46 = i - 1;
    if (!i)
      v46 = 0;
    v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (j = (mlir::GenericProgramPoint *)v46[5]; j != v47; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      if (v50)
        objc_msgSend(v35, "addObject:", v50);

    }
  }
  v37 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("body"), CFSTR("anec.region_return"), v35);
  objc_msgSend(v55, "addObject:", v37);

  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v54);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v53, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v63) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E8ED70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA17OpHandler *EmitterViewerSPI::ANECA17OpHandler::ANECA17OpHandler(EmitterViewerSPI::ANECA17OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  void *v15;
  const void *SymName;
  size_t v17;
  void *v18;
  unint64_t v19;
  uint64_t Results;
  unint64_t v21;
  uint64_t **v22;
  void *v23;
  void *v24;
  _QWORD *Body;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  void *v34;
  id v35;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v46;
  mlir::GenericProgramPoint *v47;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v49;
  void *v50;
  _QWORD *AttrData;
  uint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  mlir::Operation *v57;
  const char *v58;
  __int16 v59;
  uint64_t v60[4];
  __int16 v61;
  void *__dst[2];
  int64_t v63;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0DFA4D0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3731412E63656E61)
    {
      v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A17";
      v60[3] = 8;
      v58 = "' failed due to the operation not being registered";
      v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A17,void>::id)
    goto LABEL_54;
  v57 = a3;
  v60[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v63 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  EmitViewerSPI::emitStringProperty(CFSTR("sym_name"), SymName, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v54, "addObject:", v18);
  v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v22 = *(uint64_t ***)(Results + 8 * v19);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("result%d"), v19);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeOutputPort(v23, v22);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
      objc_msgSend(v15, "addObject:", v24);

    ++v19;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = (void *)v14;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  v26 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v27 = 0;
    do
    {
      v28 = Body[1];
      v29 = v28 - 8;
      if (!v28)
        v29 = 0;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3))
        break;
      if (v27 >= v31 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v30 + 8 * v27)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        }
        v34 = (void *)objc_claimAutoreleasedReturnValue();

        if (v34)
          objc_msgSend(v56, "addObject:", v34);

        v26 = (_QWORD *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  v35 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v46 = i - 1;
    if (!i)
      v46 = 0;
    v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (j = (mlir::GenericProgramPoint *)v46[5]; j != v47; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      if (v50)
        objc_msgSend(v35, "addObject:", v50);

    }
  }
  v37 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("body"), CFSTR("anec.region_return"), v35);
  objc_msgSend(v55, "addObject:", v37);

  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v54);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v53, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v63) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E8F4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECArgMinMaxOpHandler *EmitterViewerSPI::ANECArgMinMaxOpHandler::ANECArgMinMaxOpHandler(EmitterViewerSPI::ANECArgMinMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t Mode;
  void *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumSPI *v36;
  uint64_t **KernelSize;
  uint64_t **v38;
  uint64_t v39;
  const char *v40;
  int v41;
  const char *v42;
  const char *v43;
  void *v44;
  uint64_t **StrideValues;
  uint64_t **v46;
  uint64_t v47;
  const char *v48;
  int v49;
  const char *v50;
  const char *v51;
  void *v52;
  uint64_t **PadValues;
  uint64_t **v54;
  uint64_t v55;
  const char *v56;
  int v57;
  const char *v58;
  const char *v59;
  void *v60;
  void *v61;
  MPSGraphViewerNodeSPI *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  uint64_t v67;
  void *v68;
  _QWORD *AttrData;
  uint64_t v71;
  void *v73;
  mlir::Operation *v74;
  const char *v75;
  __int16 v76;
  uint64_t v77[4];
  __int16 v78;
  void *__dst[2];
  int64_t v80;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03AD0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v71 == 16 && *AttrData == 0x6772612E63656E61 && AttrData[1] == 0x78616D5F6E696D5FLL)
    {
      v78 = 1283;
      v77[0] = (uint64_t)"classof on '";
      v77[2] = (uint64_t)"anec.arg_min_max";
      v77[3] = 16;
      v75 = "' failed due to the operation not being registered";
      v76 = 259;
      llvm::operator+(v77, (uint64_t *)&v75, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_77:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ArgMinMax,void>::id)
    goto LABEL_77;
  v74 = a3;
  v77[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v77);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v80 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v80) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v80 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v74);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v74);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::ArgMinMax::getAxes((mlir::anec::ArgMinMax *)&v74);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_59:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_59;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("axes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  Mode = mlir::anec::ArgMinMax::getMode(&v74);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Min"), 0);
  objc_msgSend(v33, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Max"), 1);
  objc_msgSend(v33, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("mode"), CFSTR("ANECArgMinMaxMode"), v33, Mode);
  if (v36)
    objc_msgSend(v23, "addObject:", v36);

  KernelSize = (uint64_t **)mlir::anec::ArgMinMax::getKernelSize((mlir::anec::ArgMinMax *)&v74);
  v38 = KernelSize;
  if (!KernelSize)
  {
    v39 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelSize))
  {
    v40 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v41 = 692;
    v42 = "Casting.h";
    v43 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v38))
  {
    v40 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v41 = 566;
    v42 = "Casting.h";
    v43 = "cast";
LABEL_62:
    __assert_rtn(v43, v42, v41, v40);
  }
  v39 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v38);
  if (!v39)
  {
    v40 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v41 = 98;
    v42 = "InterfaceSupport.h";
    v43 = "Interface";
    goto LABEL_62;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_size"), (uint64_t)v38, v39);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  if (v44)
    objc_msgSend(v23, "addObject:", v44);
  StrideValues = (uint64_t **)mlir::anec::ArgMinMax::getStrideValues((mlir::anec::ArgMinMax *)&v74);
  v46 = StrideValues;
  if (!StrideValues)
  {
    v47 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(StrideValues))
  {
    v48 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v49 = 692;
    v50 = "Casting.h";
    v51 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v46))
  {
    v48 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v49 = 566;
    v50 = "Casting.h";
    v51 = "cast";
LABEL_65:
    __assert_rtn(v51, v50, v49, v48);
  }
  v47 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v46);
  if (!v47)
  {
    v48 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v49 = 98;
    v50 = "InterfaceSupport.h";
    v51 = "Interface";
    goto LABEL_65;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("stride_values"), (uint64_t)v46, v47);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  if (v52)
    objc_msgSend(v23, "addObject:", v52);
  PadValues = (uint64_t **)mlir::anec::ArgMinMax::getPadValues((mlir::anec::ArgMinMax *)&v74);
  v54 = PadValues;
  if (!PadValues)
  {
    v55 = 0;
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(PadValues))
  {
    v56 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v57 = 692;
    v58 = "Casting.h";
    v59 = "cast_if_present";
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v54))
  {
    v56 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v57 = 566;
    v58 = "Casting.h";
    v59 = "cast";
LABEL_68:
    __assert_rtn(v59, v58, v57, v56);
  }
  v55 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v54);
  if (!v55)
  {
    v56 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v57 = 98;
    v58 = "InterfaceSupport.h";
    v59 = "Interface";
    goto LABEL_68;
  }
LABEL_52:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("pad_values"), (uint64_t)v54, v55);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  if (v60)
    objc_msgSend(v23, "addObject:", v60);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  v62 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v65 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v61);
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  v67 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v62, "initWithType:inputs:outputs:properties:regions:", v73, v63, v64, v65, v66);
  v68 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v67;

  if (SHIBYTE(v80) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E8FE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECAveragePoolOpHandler *EmitterViewerSPI::ANECAveragePoolOpHandler::ANECAveragePoolOpHandler(EmitterViewerSPI::ANECAveragePoolOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  void *v16;
  uint64_t v17;
  __CFString *v18;
  uint64_t MPSDataType;
  void *v20;
  MPSGraphViewerNodePortSPI *v21;
  void *v22;
  uint64_t **Stride;
  uint64_t **v24;
  uint64_t InterfaceFor;
  const char *v26;
  int v27;
  const char *v28;
  const char *v29;
  void *v30;
  uint64_t **Padding;
  uint64_t **v32;
  uint64_t v33;
  const char *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  uint64_t **Dilation;
  uint64_t **v40;
  uint64_t v41;
  const char *v42;
  int v43;
  const char *v44;
  const char *v45;
  void *v46;
  MPSGraphViewerNodePropertyDataSPI *v47;
  void *v48;
  void *v49;
  MPSGraphViewerNodeSPI *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  uint64_t v55;
  void *v56;
  uint64_t AttrData;
  uint64_t v59;
  BOOL v60;
  void *v62;
  void *v63;
  mlir::Operation *v64;
  const char *v65;
  __int16 v66;
  uint64_t v67[4];
  __int16 v68;
  void *__dst[2];
  int64_t v70;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03E30;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v59 == 17)
    {
      v60 = *(_QWORD *)AttrData == 0x6576612E63656E61 && *(_QWORD *)(AttrData + 8) == 0x6F6F705F65676172;
      if (v60 && *(_BYTE *)(AttrData + 16) == 108)
      {
        v68 = 1283;
        v67[0] = (uint64_t)"classof on '";
        v67[2] = (uint64_t)"anec.average_pool";
        v67[3] = 17;
        v65 = "' failed due to the operation not being registered";
        v66 = 259;
        llvm::operator+(v67, (uint64_t *)&v65, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_69:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id)
    goto LABEL_69;
  v64 = a3;
  v67[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v70 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v70) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v70 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v64);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v63, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v64);
  v18 = CFSTR("result");
  if (v17)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v21 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v20, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v17));

    if (v21)
      objc_msgSend(v16, "addObject:", v21);
  }
  else
  {

    v21 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  Stride = (uint64_t **)mlir::anec::AveragePool::getStride((mlir::anec::AveragePool *)&v64);
  v24 = Stride;
  if (!Stride)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    v26 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v27 = 692;
    v28 = "Casting.h";
    v29 = "cast_if_present";
    goto LABEL_51;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24))
  {
    v26 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v27 = 566;
    v28 = "Casting.h";
    v29 = "cast";
LABEL_51:
    __assert_rtn(v29, v28, v27, v26);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24);
  if (!InterfaceFor)
  {
    v26 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v27 = 98;
    v28 = "InterfaceSupport.h";
    v29 = "Interface";
    goto LABEL_51;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("stride"), (uint64_t)v24, InterfaceFor);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  if (v30)
    objc_msgSend(v22, "addObject:", v30);
  Padding = (uint64_t **)mlir::anec::AveragePool::getPadding((mlir::anec::AveragePool *)&v64);
  v32 = Padding;
  if (!Padding)
  {
    v33 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v35 = 692;
    v36 = "Casting.h";
    v37 = "cast_if_present";
    goto LABEL_54;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v35 = 566;
    v36 = "Casting.h";
    v37 = "cast";
LABEL_54:
    __assert_rtn(v37, v36, v35, v34);
  }
  v33 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!v33)
  {
    v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v35 = 98;
    v36 = "InterfaceSupport.h";
    v37 = "Interface";
    goto LABEL_54;
  }
LABEL_34:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("padding"), (uint64_t)v32, v33);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  if (v38)
    objc_msgSend(v22, "addObject:", v38);
  Dilation = (uint64_t **)mlir::anec::Convolution::getDilation((mlir::anec::Convolution *)&v64);
  v40 = Dilation;
  if (!Dilation)
  {
    v41 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Dilation))
  {
    v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v43 = 692;
    v44 = "Casting.h";
    v45 = "cast_if_present";
    goto LABEL_57;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v43 = 566;
    v44 = "Casting.h";
    v45 = "cast";
LABEL_57:
    __assert_rtn(v45, v44, v43, v42);
  }
  v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v43 = 98;
    v44 = "InterfaceSupport.h";
    v45 = "Interface";
    goto LABEL_57;
  }
LABEL_42:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("ksize"), (uint64_t)v40, v41);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  if (v46)
    objc_msgSend(v22, "addObject:", v46);
  LOBYTE(v67[0]) = 0;
  LOBYTE(v67[0]) = mlir::anec::AveragePool::getIncPad(&v64);
  v47 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("inc_pad"), 2147483656, &unk_1E0E99B38);
  if (v47)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v67, 1);
    v48 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v47, "setValue:", v48);

    objc_msgSend(v22, "addObject:", v47);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v63);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v16);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v22);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v49);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  v55 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v50, "initWithType:inputs:outputs:properties:regions:", v62, v51, v52, v53, v54);
  v56 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v55;

  if (SHIBYTE(v70) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9069C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECBatchToSpaceOpHandler *EmitterViewerSPI::ANECBatchToSpaceOpHandler::ANECBatchToSpaceOpHandler(EmitterViewerSPI::ANECBatchToSpaceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  BOOL v43;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03FE0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 19)
    {
      v43 = *AttrData == 0x7461622E63656E61 && AttrData[1] == 0x70735F6F745F6863;
      if (v43 && *(_QWORD *)((char *)AttrData + 11) == 0x65636170735F6F74)
      {
        v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.batch_to_space";
        v49[3] = 19;
        v47 = "' failed due to the operation not being registered";
        v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id)
    goto LABEL_45;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("factors"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E90CC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECBroadcastOpHandler *EmitterViewerSPI::ANECBroadcastOpHandler::ANECBroadcastOpHandler(EmitterViewerSPI::ANECBroadcastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03AE8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 14 && *AttrData == 0x6F72622E63656E61 && *(_QWORD *)((char *)AttrData + 6) == 0x7473616364616F72)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.broadcast";
      v40[3] = 14;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Broadcast,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E911F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECCastOpHandler *EmitterViewerSPI::ANECCastOpHandler::ANECCastOpHandler(EmitterViewerSPI::ANECCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03038;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(_QWORD *)AttrData == 0x7361632E63656E61 && *(_BYTE *)(AttrData + 8) == 116)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.cast";
      v40[3] = 9;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Cast,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E916FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECCeilOpHandler *EmitterViewerSPI::ANECCeilOpHandler::ANECCeilOpHandler(EmitterViewerSPI::ANECCeilOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03050;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(_QWORD *)AttrData == 0x6965632E63656E61 && *(_BYTE *)(AttrData + 8) == 108)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.ceil";
      v40[3] = 9;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Ceil,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E91C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECChannelToSpaceOpHandler *EmitterViewerSPI::ANECChannelToSpaceOpHandler::ANECChannelToSpaceOpHandler(EmitterViewerSPI::ANECChannelToSpaceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  BOOL v43;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E042E0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 21)
    {
      v43 = *AttrData == 0x6168632E63656E61 && AttrData[1] == 0x5F6F745F6C656E6ELL;
      if (v43 && *(_QWORD *)((char *)AttrData + 13) == 0x65636170735F6F74)
      {
        v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.channel_to_space";
        v49[3] = 21;
        v47 = "' failed due to the operation not being registered";
        v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id)
    goto LABEL_45;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("factors"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E92200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECClampedReluOpHandler *EmitterViewerSPI::ANECClampedReluOpHandler::ANECClampedReluOpHandler(EmitterViewerSPI::ANECClampedReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  llvm::APFloatBase *v29;
  void *v30;
  void *v31;
  MPSGraphViewerNodeSPI *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  uint64_t AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  void *__dst[2];
  int64_t v47;
  __int16 v48;
  const char *v49;
  void *v50;
  _QWORD v51[2];
  __int16 v52;
  uint64_t v53;
  void *v54;
  _QWORD v55[4];

  v55[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03E48;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v53 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v53);
    if (v41 == 17)
    {
      v42 = *(_QWORD *)AttrData == 0x616C632E63656E61 && *(_QWORD *)(AttrData + 8) == 0x6C65725F6465706DLL;
      if (v42 && *(_BYTE *)(AttrData + 16) == 117)
      {
        v52 = 1283;
        v49 = "classof on '";
        v51[0] = "anec.clamped_relu";
        v51[1] = 17;
        __dst[0] = "' failed due to the operation not being registered";
        v48 = 259;
        llvm::operator+((uint64_t *)&v49, (uint64_t *)__dst, (uint64_t)&v53);
        llvm::report_fatal_error((llvm::Twine *)&v53, 1);
      }
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ClampedRelu,void>::id)
    goto LABEL_44;
  v45 = a3;
  v53 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v53);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::InstanceNorm::getEpsilon(&v45, (uint64_t)&v53);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("min_value"), 268435488, &unk_1E0E99B50);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v53, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }
  mlir::anec::DeQuant::getScale(&v45, (uint64_t)&v49);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("max_value"), 268435488, &unk_1E0E99B68);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v49, 32);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v23, "addObject:", v26);
  }

  v28 = v50;
  v30 = llvm::APFloatBase::PPCDoubleDouble(v29);
  if (v30 == v28)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v51);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v50);

  if (v30 == v54)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v55);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v54);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v32, "initWithType:inputs:outputs:properties:regions:", v44, v33, v34, v35, v36);
  v38 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v37;

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9289C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a16 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECConcatOpHandler *EmitterViewerSPI::ANECConcatOpHandler::ANECConcatOpHandler(EmitterViewerSPI::ANECConcatOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void *v13;
  uint64_t Inputs;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int v19;
  unint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  _QWORD *AttrData;
  uint64_t v44;
  void *v46;
  mlir::Operation *v48;
  uint64_t v49[4];
  __int16 v50;
  uint64_t v51[4];
  __int16 v52;
  void *__dst[2];
  int64_t v54;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E034D0;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v44 == 11 && *AttrData == 0x6E6F632E63656E61 && *(_QWORD *)((char *)AttrData + 3) == 0x7461636E6F632E63)
    {
      v52 = 1283;
      v51[0] = (uint64_t)"classof on '";
      v51[2] = (uint64_t)"anec.concat";
      v51[3] = 11;
      v49[0] = (uint64_t)"' failed due to the operation not being registered";
      v50 = 259;
      llvm::operator+(v51, v49, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::anec::Concat,void>::id)
    goto LABEL_38;
  v48 = a3;
  v51[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v51);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v54 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v54) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v54 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  Inputs = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v48);
  v16 = v15;
  if (v15)
  {
    v17 = Inputs;
    v18 = 0;
    v19 = 1;
    do
    {
      v20 = *(_QWORD *)(v17 + 32 * v18 + 24);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("inputs%d"), v19 - 1);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v21, v20);
      v22 = (void *)objc_claimAutoreleasedReturnValue();

      if (v22)
        objc_msgSend(v13, "addObject:", v22);

      v18 = v19++;
    }
    while (v16 > v18);
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v48);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v51[0] = 0;
  v51[0] = (uint64_t)mlir::anec::Concat::getAxis(&v48);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("axis"), 64, &unk_1E0E99B80);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v51, 8);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v29, "addObject:", v30);
  }
  LOBYTE(v49[0]) = 0;
  LOBYTE(v49[0]) = mlir::anec::Softmax::getSubtractMax(&v48);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("interleave"), 2147483656, &unk_1E0E99B98);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v49, 1);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v29, "addObject:", v32);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v13);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v46, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  if (SHIBYTE(v54) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E92F54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  void *v29;
  void *v30;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECConvolutionOpHandler *EmitterViewerSPI::ANECConvolutionOpHandler::ANECConvolutionOpHandler(EmitterViewerSPI::ANECConvolutionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Stride;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t **Dilation;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **Padding;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t PaddingMode;
  void *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumCaseSPI *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumSPI *v59;
  MPSGraphViewerNodePropertyDataSPI *v60;
  void *v61;
  MPSGraphViewerNodePropertyDataSPI *v62;
  void *v63;
  uint64_t **KernelScale;
  char v65;
  uint64_t **v66;
  uint64_t v67;
  const char *v68;
  int v69;
  const char *v70;
  const char *v71;
  void *v72;
  uint64_t **KernelZeroPoint;
  char v74;
  uint64_t **v75;
  uint64_t v76;
  const char *v77;
  int v78;
  const char *v79;
  const char *v80;
  void *v81;
  void *v82;
  MPSGraphViewerNodeSPI *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  uint64_t v88;
  void *v89;
  _QWORD *AttrData;
  uint64_t v92;
  void *v94;
  void *v95;
  void *v96;
  mlir::Operation *v97;
  uint64_t v98[4];
  __int16 v99;
  uint64_t v100[4];
  __int16 v101;
  void *__dst[2];
  int64_t v103;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03E60;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v92 == 16 && *AttrData == 0x6E6F632E63656E61 && AttrData[1] == 0x6E6F6974756C6F76)
    {
      v101 = 1283;
      v100[0] = (uint64_t)"classof on '";
      v100[2] = (uint64_t)"anec.convolution";
      v100[3] = 16;
      v98[0] = (uint64_t)"' failed due to the operation not being registered";
      v99 = 259;
      llvm::operator+(v100, v98, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_98:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    goto LABEL_98;
  v97 = a3;
  v100[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v100);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v103 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v103) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v103 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v94 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v96 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v97);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v96, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v97);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("filter"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v96, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v95 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v97);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v95, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Stride = (uint64_t **)mlir::anec::Convolution::getStride((mlir::anec::Convolution *)&v97);
  v25 = Stride;
  if (!Stride)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_77;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_77:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_77;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("stride"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  Dilation = (uint64_t **)mlir::anec::Convolution::getDilation((mlir::anec::Convolution *)&v97);
  v33 = Dilation;
  if (!Dilation)
  {
    v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Dilation))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_80;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_80:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_80;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  Padding = (uint64_t **)mlir::anec::Convolution::getPadding((mlir::anec::Convolution *)&v97);
  v41 = Padding;
  if (!Padding)
  {
    v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_83;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_83:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_83;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("padding"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);
  PaddingMode = mlir::anec::Convolution::getPaddingMode(&v97);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Zero"), 0);
  objc_msgSend(v49, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Negative"), 1);
  objc_msgSend(v49, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Replication"), 2);
  objc_msgSend(v49, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Positive"), 3);
  objc_msgSend(v49, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Symmetric"), 4);
  objc_msgSend(v49, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Reflective"), 5);
  objc_msgSend(v49, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Background"), 6);
  objc_msgSend(v49, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DontCare"), 7);
  objc_msgSend(v49, "addObject:", v57);

  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("None"), 8);
  objc_msgSend(v49, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_mode"), CFSTR("ANECPaddingMode"), v49, PaddingMode);
  if (v59)
    objc_msgSend(v23, "addObject:", v59);

  v100[0] = 0;
  v100[0] = (uint64_t)mlir::anec::Convolution::getGroups(&v97);
  v60 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("groups"), 64, &unk_1E0E99BB0);
  if (v60)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v100, 8);
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v60, "setValue:", v61);

    objc_msgSend(v23, "addObject:", v60);
  }
  LOBYTE(v98[0]) = 0;
  LOBYTE(v98[0]) = mlir::anec::AveragePool::getIncPad(&v97);
  v62 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("channel_wise"), 2147483656, &unk_1E0E99BC8);
  if (v62)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v98, 1);
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v62, "setValue:", v63);

    objc_msgSend(v23, "addObject:", v62);
  }
  KernelScale = (uint64_t **)mlir::anec::Convolution::getKernelScale(&v97);
  if (v65)
  {
    v66 = KernelScale;
    if (KernelScale)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelScale))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v66))
        {
          v67 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v66);
          if (!v67)
          {
            v68 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v69 = 98;
            v70 = "InterfaceSupport.h";
            v71 = "Interface";
            goto LABEL_86;
          }
          goto LABEL_59;
        }
        v68 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v69 = 566;
        v70 = "Casting.h";
        v71 = "cast";
      }
      else
      {
        v68 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v69 = 692;
        v70 = "Casting.h";
        v71 = "cast_if_present";
      }
LABEL_86:
      __assert_rtn(v71, v70, v69, v68);
    }
    v67 = 0;
LABEL_59:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_scale"), (uint64_t)v66, v67);
    v72 = (void *)objc_claimAutoreleasedReturnValue();
    if (v72)
      objc_msgSend(v23, "addObject:", v72);

  }
  KernelZeroPoint = (uint64_t **)mlir::anec::Convolution::getKernelZeroPoint(&v97);
  if (!v74)
    goto LABEL_72;
  v75 = KernelZeroPoint;
  if (KernelZeroPoint)
  {
    if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelZeroPoint))
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v75))
      {
        v76 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v75);
        if (!v76)
        {
          v77 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          v78 = 98;
          v79 = "InterfaceSupport.h";
          v80 = "Interface";
          goto LABEL_89;
        }
        goto LABEL_69;
      }
      v77 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v78 = 566;
      v79 = "Casting.h";
      v80 = "cast";
    }
    else
    {
      v77 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
      v78 = 692;
      v79 = "Casting.h";
      v80 = "cast_if_present";
    }
LABEL_89:
    __assert_rtn(v80, v79, v78, v77);
  }
  v76 = 0;
LABEL_69:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_zero_point"), (uint64_t)v75, v76);
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  if (v81)
    objc_msgSend(v23, "addObject:", v81);

LABEL_72:
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  v83 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v96);
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v95);
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v82);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  v88 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v83, "initWithType:inputs:outputs:properties:regions:", v94, v84, v85, v86, v87);
  v89 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v88;

  if (SHIBYTE(v103) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E93BE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE5048] + 16;
  __cxa_throw(exception, MEMORY[0x1E0DE4E90], MEMORY[0x1E0DE4380]);
}

EmitterViewerSPI::ANECCosOpHandler *EmitterViewerSPI::ANECCosOpHandler::ANECCosOpHandler(EmitterViewerSPI::ANECCosOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v35;
  mlir::Operation *v36;
  const char *v37;
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  void *__dst[2];
  int64_t v42;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02D50;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x736F632E63656E61)
    {
      v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.cos";
      v39[3] = 8;
      v37 = "' failed due to the operation not being registered";
      v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Cos,void>::id)
    goto LABEL_27;
  v36 = a3;
  v39[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v42 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v35, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E941FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECCropResizeOpHandler *EmitterViewerSPI::ANECCropResizeOpHandler::ANECCropResizeOpHandler(EmitterViewerSPI::ANECCropResizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **OutputDims;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  uint64_t **CropDims;
  uint64_t **v32;
  uint64_t v33;
  const char *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  uint64_t **CoordinateMode;
  uint64_t **v40;
  uint64_t v41;
  const char *v42;
  int v43;
  const char *v44;
  const char *v45;
  void *v46;
  uint64_t **NormalizedRange;
  uint64_t **v48;
  uint64_t v49;
  const char *v50;
  int v51;
  const char *v52;
  const char *v53;
  void *v54;
  uint64_t **SamplingMode;
  uint64_t **v56;
  uint64_t v57;
  const char *v58;
  int v59;
  const char *v60;
  const char *v61;
  void *v62;
  uint64_t **SamplingMethod;
  uint64_t **v64;
  uint64_t v65;
  const char *v66;
  int v67;
  const char *v68;
  const char *v69;
  void *v70;
  uint64_t **PaddingModes;
  uint64_t **v72;
  uint64_t v73;
  const char *v74;
  int v75;
  const char *v76;
  const char *v77;
  void *v78;
  MPSGraphViewerNodePropertyDataSPI *v79;
  void *v80;
  void *v81;
  llvm::APFloatBase *v82;
  void *v83;
  MPSGraphViewerNodeSPI *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  uint64_t v89;
  void *v90;
  _QWORD *AttrData;
  uint64_t v93;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  mlir::Operation *v99;
  const char *v100;
  __int16 v101;
  void *__dst[2];
  const char *v103;
  uint64_t v104;
  __int16 v105;
  uint64_t v106;
  void *v107;
  _QWORD v108[5];

  v108[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03D10;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v106 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v106);
    if (v93 == 16 && *AttrData == 0x6F72632E63656E61 && AttrData[1] == 0x657A697365725F70)
    {
      v105 = 1283;
      __dst[0] = "classof on '";
      v103 = "anec.crop_resize";
      v104 = 16;
      v100 = "' failed due to the operation not being registered";
      v101 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v100, (uint64_t)&v106);
      llvm::report_fatal_error((llvm::Twine *)&v106, 1);
    }
LABEL_115:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::CropResize,void>::id)
    goto LABEL_115;
  v99 = a3;
  v106 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v106);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v103 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v103) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v103) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v96 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v98, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("index"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v98, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v99);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v97, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  OutputDims = (uint64_t **)mlir::anec::CropResize::getOutputDims((mlir::anec::CropResize *)&v99);
  v25 = OutputDims;
  if (!OutputDims)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(OutputDims))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_88;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_88:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_88;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("output_dims"), (uint64_t)v25, InterfaceFor);
  v95 = (void *)objc_claimAutoreleasedReturnValue();
  if (v95)
    objc_msgSend(v23, "addObject:", v95);
  CropDims = (uint64_t **)mlir::anec::CropResize::getCropDims((mlir::anec::CropResize *)&v99);
  v32 = CropDims;
  if (!CropDims)
  {
    v33 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(CropDims))
  {
    v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v35 = 692;
    v36 = "Casting.h";
    v37 = "cast_if_present";
    goto LABEL_91;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v35 = 566;
    v36 = "Casting.h";
    v37 = "cast";
LABEL_91:
    __assert_rtn(v37, v36, v35, v34);
  }
  v33 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!v33)
  {
    v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v35 = 98;
    v36 = "InterfaceSupport.h";
    v37 = "Interface";
    goto LABEL_91;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("crop_dims"), (uint64_t)v32, v33);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  if (v38)
    objc_msgSend(v23, "addObject:", v38);
  mlir::anec::CropResize::getBoxCoordinateMode(&v99);
  CoordinateMode = (uint64_t **)mlir::anec::CropResize::getCoordinateMode((mlir::anec::CropResize *)&v99);
  v40 = CoordinateMode;
  if (!CoordinateMode)
  {
    v41 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(CoordinateMode))
  {
    v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v43 = 692;
    v44 = "Casting.h";
    v45 = "cast_if_present";
    goto LABEL_94;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v43 = 566;
    v44 = "Casting.h";
    v45 = "cast";
LABEL_94:
    __assert_rtn(v45, v44, v43, v42);
  }
  v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v43 = 98;
    v44 = "InterfaceSupport.h";
    v45 = "Interface";
    goto LABEL_94;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("coordinate_mode"), (uint64_t)v40, v41);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  if (v46)
    objc_msgSend(v23, "addObject:", v46);
  NormalizedRange = (uint64_t **)mlir::anec::CropResize::getNormalizedRange((mlir::anec::CropResize *)&v99);
  v48 = NormalizedRange;
  if (!NormalizedRange)
  {
    v49 = 0;
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(NormalizedRange))
  {
    v50 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v51 = 692;
    v52 = "Casting.h";
    v53 = "cast_if_present";
    goto LABEL_97;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v48))
  {
    v50 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v51 = 566;
    v52 = "Casting.h";
    v53 = "cast";
LABEL_97:
    __assert_rtn(v53, v52, v51, v50);
  }
  v49 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v48);
  if (!v49)
  {
    v50 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v51 = 98;
    v52 = "InterfaceSupport.h";
    v53 = "Interface";
    goto LABEL_97;
  }
LABEL_52:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("normalized_range"), (uint64_t)v48, v49);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  if (v54)
    objc_msgSend(v23, "addObject:", v54);
  SamplingMode = (uint64_t **)mlir::anec::CropResize::getSamplingMode((mlir::anec::CropResize *)&v99);
  v56 = SamplingMode;
  if (!SamplingMode)
  {
    v57 = 0;
    goto LABEL_60;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(SamplingMode))
  {
    v58 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v59 = 692;
    v60 = "Casting.h";
    v61 = "cast_if_present";
    goto LABEL_100;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56))
  {
    v58 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v59 = 566;
    v60 = "Casting.h";
    v61 = "cast";
LABEL_100:
    __assert_rtn(v61, v60, v59, v58);
  }
  v57 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56);
  if (!v57)
  {
    v58 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v59 = 98;
    v60 = "InterfaceSupport.h";
    v61 = "Interface";
    goto LABEL_100;
  }
LABEL_60:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("sampling_mode"), (uint64_t)v56, v57);
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  if (v62)
    objc_msgSend(v23, "addObject:", v62);
  SamplingMethod = (uint64_t **)mlir::anec::CropResize::getSamplingMethod((mlir::anec::CropResize *)&v99);
  v64 = SamplingMethod;
  if (!SamplingMethod)
  {
    v65 = 0;
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(SamplingMethod))
  {
    v66 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v67 = 692;
    v68 = "Casting.h";
    v69 = "cast_if_present";
    goto LABEL_103;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v64))
  {
    v66 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v67 = 566;
    v68 = "Casting.h";
    v69 = "cast";
LABEL_103:
    __assert_rtn(v69, v68, v67, v66);
  }
  v65 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v64);
  if (!v65)
  {
    v66 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v67 = 98;
    v68 = "InterfaceSupport.h";
    v69 = "Interface";
    goto LABEL_103;
  }
LABEL_68:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("sampling_method"), (uint64_t)v64, v65);
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  if (v70)
    objc_msgSend(v23, "addObject:", v70);
  PaddingModes = (uint64_t **)mlir::anec::CropResize::getPaddingModes((mlir::anec::CropResize *)&v99);
  v72 = PaddingModes;
  if (!PaddingModes)
  {
    v73 = 0;
    goto LABEL_76;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(PaddingModes))
  {
    v74 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v75 = 692;
    v76 = "Casting.h";
    v77 = "cast_if_present";
    goto LABEL_106;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v72))
  {
    v74 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v75 = 566;
    v76 = "Casting.h";
    v77 = "cast";
LABEL_106:
    __assert_rtn(v77, v76, v75, v74);
  }
  v73 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v72);
  if (!v73)
  {
    v74 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v75 = 98;
    v76 = "InterfaceSupport.h";
    v77 = "Interface";
    goto LABEL_106;
  }
LABEL_76:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("padding_modes"), (uint64_t)v72, v73);
  v78 = (void *)objc_claimAutoreleasedReturnValue();
  if (v78)
    objc_msgSend(v23, "addObject:", v78);
  mlir::anec::CropResize::getBackgroundValue(&v99, (uint64_t)&v106);
  v79 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("background_value"), 268435488, &unk_1E0E99BE0);
  if (v79)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v106, 32);
    v80 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v79, "setValue:", v80);

    objc_msgSend(v23, "addObject:", v79);
  }

  v81 = v107;
  if (llvm::APFloatBase::PPCDoubleDouble(v82) == v81)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v108);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v107);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  v84 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v98);
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v97);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v83);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  v89 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v84, "initWithType:inputs:outputs:properties:regions:", v96, v85, v86, v87, v88);
  v90 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v89;

  if (SHIBYTE(v103) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E94DCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, uint64_t a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;
  void *v30;

  if (a26 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECDeQuantOpHandler *EmitterViewerSPI::ANECDeQuantOpHandler::ANECDeQuantOpHandler(EmitterViewerSPI::ANECDeQuantOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  llvm::APFloatBase *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  uint64_t AttrData;
  uint64_t v40;
  void *v42;
  mlir::Operation *v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  const char *v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  void *v51;
  _QWORD v52[4];

  v52[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03740;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v50 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
    if (v40 == 12 && *(_QWORD *)AttrData == 0x7165642E63656E61 && *(_DWORD *)(AttrData + 8) == 1953390965)
    {
      v49 = 1283;
      __dst[0] = "classof on '";
      v47 = "anec.dequant";
      v48 = 12;
      v44[0] = (uint64_t)"' failed due to the operation not being registered";
      v45 = 259;
      llvm::operator+((uint64_t *)__dst, v44, (uint64_t)&v50);
      llvm::report_fatal_error((llvm::Twine *)&v50, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::DeQuant,void>::id)
    goto LABEL_38;
  v43 = a3;
  v50 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v47) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::DeQuant::getScale(&v43, (uint64_t)&v50);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("scale"), 268435488, &unk_1E0E99BF8);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v50, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }
  LODWORD(v44[0]) = 0;
  LODWORD(v44[0]) = mlir::anec::DeQuant::getZeroPoint(&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("zero_point"), 536870944, &unk_1E0E99C10);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v44, 4);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v23, "addObject:", v26);
  }

  v28 = v51;
  if (llvm::APFloatBase::PPCDoubleDouble(v29) == v28)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v52);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v51);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v42, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E954F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECDeconvolutionOpHandler *EmitterViewerSPI::ANECDeconvolutionOpHandler::ANECDeconvolutionOpHandler(EmitterViewerSPI::ANECDeconvolutionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Stride;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t **Dilation;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **Padding;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t PaddingMode;
  void *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumCaseSPI *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumSPI *v59;
  MPSGraphViewerNodePropertyDataSPI *v60;
  void *v61;
  MPSGraphViewerNodePropertyDataSPI *v62;
  void *v63;
  uint64_t **KernelScale;
  char v65;
  uint64_t **v66;
  uint64_t v67;
  const char *v68;
  int v69;
  const char *v70;
  const char *v71;
  void *v72;
  uint64_t **KernelZeroPoint;
  char v74;
  uint64_t **v75;
  uint64_t v76;
  const char *v77;
  int v78;
  const char *v79;
  const char *v80;
  void *v81;
  void *v82;
  MPSGraphViewerNodeSPI *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  uint64_t v88;
  void *v89;
  uint64_t AttrData;
  uint64_t v92;
  BOOL v93;
  void *v95;
  void *v96;
  void *v97;
  mlir::Operation *v98;
  uint64_t v99[4];
  __int16 v100;
  uint64_t v101[4];
  __int16 v102;
  void *__dst[2];
  int64_t v104;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E041D8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v92 == 18)
    {
      v93 = *(_QWORD *)AttrData == 0x6365642E63656E61 && *(_QWORD *)(AttrData + 8) == 0x6974756C6F766E6FLL;
      if (v93 && *(_WORD *)(AttrData + 16) == 28271)
      {
        v102 = 1283;
        v101[0] = (uint64_t)"classof on '";
        v101[2] = (uint64_t)"anec.deconvolution";
        v101[3] = 18;
        v99[0] = (uint64_t)"' failed due to the operation not being registered";
        v100 = 259;
        llvm::operator+(v101, v99, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_101:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id)
    goto LABEL_101;
  v98 = a3;
  v101[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v101);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v104 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v104) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v104 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v95 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v98);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v97, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v98);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("filter"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v97, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v96 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v98);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v96, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Stride = (uint64_t **)mlir::anec::Convolution::getStride((mlir::anec::Convolution *)&v98);
  v25 = Stride;
  if (!Stride)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_77;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_77:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_77;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("stride"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  Dilation = (uint64_t **)mlir::anec::Convolution::getDilation((mlir::anec::Convolution *)&v98);
  v33 = Dilation;
  if (!Dilation)
  {
    v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Dilation))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_80;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_80:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_80;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  Padding = (uint64_t **)mlir::anec::Convolution::getPadding((mlir::anec::Convolution *)&v98);
  v41 = Padding;
  if (!Padding)
  {
    v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_83;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_83:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_83;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("padding"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);
  PaddingMode = mlir::anec::Convolution::getPaddingMode(&v98);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Zero"), 0);
  objc_msgSend(v49, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Negative"), 1);
  objc_msgSend(v49, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Replication"), 2);
  objc_msgSend(v49, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Positive"), 3);
  objc_msgSend(v49, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Symmetric"), 4);
  objc_msgSend(v49, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Reflective"), 5);
  objc_msgSend(v49, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Background"), 6);
  objc_msgSend(v49, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DontCare"), 7);
  objc_msgSend(v49, "addObject:", v57);

  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("None"), 8);
  objc_msgSend(v49, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_mode"), CFSTR("ANECPaddingMode"), v49, PaddingMode);
  if (v59)
    objc_msgSend(v23, "addObject:", v59);

  v101[0] = 0;
  v101[0] = (uint64_t)mlir::anec::Convolution::getGroups(&v98);
  v60 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("groups"), 64, &unk_1E0E99C28);
  if (v60)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v101, 8);
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v60, "setValue:", v61);

    objc_msgSend(v23, "addObject:", v60);
  }
  LOBYTE(v99[0]) = 0;
  LOBYTE(v99[0]) = mlir::anec::AveragePool::getIncPad(&v98);
  v62 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("channel_wise"), 2147483656, &unk_1E0E99C40);
  if (v62)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v99, 1);
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v62, "setValue:", v63);

    objc_msgSend(v23, "addObject:", v62);
  }
  KernelScale = (uint64_t **)mlir::anec::Convolution::getKernelScale(&v98);
  if (v65)
  {
    v66 = KernelScale;
    if (KernelScale)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelScale))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v66))
        {
          v67 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v66);
          if (!v67)
          {
            v68 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v69 = 98;
            v70 = "InterfaceSupport.h";
            v71 = "Interface";
            goto LABEL_86;
          }
          goto LABEL_59;
        }
        v68 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v69 = 566;
        v70 = "Casting.h";
        v71 = "cast";
      }
      else
      {
        v68 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v69 = 692;
        v70 = "Casting.h";
        v71 = "cast_if_present";
      }
LABEL_86:
      __assert_rtn(v71, v70, v69, v68);
    }
    v67 = 0;
LABEL_59:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_scale"), (uint64_t)v66, v67);
    v72 = (void *)objc_claimAutoreleasedReturnValue();
    if (v72)
      objc_msgSend(v23, "addObject:", v72);

  }
  KernelZeroPoint = (uint64_t **)mlir::anec::Convolution::getKernelZeroPoint(&v98);
  if (!v74)
    goto LABEL_72;
  v75 = KernelZeroPoint;
  if (KernelZeroPoint)
  {
    if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelZeroPoint))
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v75))
      {
        v76 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v75);
        if (!v76)
        {
          v77 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          v78 = 98;
          v79 = "InterfaceSupport.h";
          v80 = "Interface";
          goto LABEL_89;
        }
        goto LABEL_69;
      }
      v77 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v78 = 566;
      v79 = "Casting.h";
      v80 = "cast";
    }
    else
    {
      v77 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
      v78 = 692;
      v79 = "Casting.h";
      v80 = "cast_if_present";
    }
LABEL_89:
    __assert_rtn(v80, v79, v78, v77);
  }
  v76 = 0;
LABEL_69:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_zero_point"), (uint64_t)v75, v76);
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  if (v81)
    objc_msgSend(v23, "addObject:", v81);

LABEL_72:
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  v83 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v97);
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v96);
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v82);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  v88 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v83, "initWithType:inputs:outputs:properties:regions:", v95, v84, v85, v86, v87);
  v89 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v88;

  if (SHIBYTE(v104) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E96178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECDegammaOpHandler *EmitterViewerSPI::ANECDegammaOpHandler::ANECDegammaOpHandler(EmitterViewerSPI::ANECDegammaOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03758;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 12 && *(_QWORD *)AttrData == 0x6765642E63656E61 && *(_DWORD *)(AttrData + 8) == 1634561377)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.degamma";
      v40[3] = 12;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Degamma,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E96770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECDiracOpHandler *EmitterViewerSPI::ANECDiracOpHandler::ANECDiracOpHandler(EmitterViewerSPI::ANECDiracOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E032C0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 10 && *(_QWORD *)AttrData == 0x7269642E63656E61 && *(_WORD *)(AttrData + 8) == 25441)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.dirac";
      v40[3] = 10;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Dirac,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E96C7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseAbsOpHandler *EmitterViewerSPI::ANECElementwiseAbsOpHandler::ANECElementwiseAbsOpHandler(EmitterViewerSPI::ANECElementwiseAbsOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v35;
  mlir::Operation *v36;
  const char *v37;
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  void *__dst[2];
  int64_t v42;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E042F8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x7362612E63656E61)
    {
      v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.abs";
      v39[3] = 8;
      v37 = "' failed due to the operation not being registered";
      v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAbs,void>::id)
    goto LABEL_27;
  v36 = a3;
  v39[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v42 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v35, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9717C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseAddOpHandler *EmitterViewerSPI::ANECElementwiseAddOpHandler::ANECElementwiseAddOpHandler(EmitterViewerSPI::ANECElementwiseAddOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04310;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6464612E63656E61)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.add";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
    goto LABEL_29;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v36, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E976B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E977C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseDivOpHandler *EmitterViewerSPI::ANECElementwiseDivOpHandler::ANECElementwiseDivOpHandler(EmitterViewerSPI::ANECElementwiseDivOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04328;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x7669642E63656E61)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.div";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseDiv,void>::id)
    goto LABEL_29;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v36, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E97C00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E97D18(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseEqualOpHandler *EmitterViewerSPI::ANECElementwiseEqualOpHandler::ANECElementwiseEqualOpHandler(EmitterViewerSPI::ANECElementwiseEqualOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04610;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 10 && *(_QWORD *)AttrData == 0x7571652E63656E61 && *(_WORD *)(AttrData + 8) == 27745)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.equal";
      v41[3] = 10;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqual,void>::id)
    goto LABEL_33;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v37, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9815C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E98274(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler *EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler::ANECElementwiseEqualZeroOpHandler(EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E048F8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 15 && *AttrData == 0x7571652E63656E61 && *(_QWORD *)((char *)AttrData + 7) == 0x6F72657A5F6C6175)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.equal_zero";
      v40[3] = 15;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E98690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler *EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler::ANECElementwiseGreaterThanOpHandler(EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04A00;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 17)
    {
      v36 = *(_QWORD *)AttrData == 0x6572672E63656E61 && *(_QWORD *)(AttrData + 8) == 0x6168745F72657461;
      if (v36 && *(_BYTE *)(AttrData + 16) == 110)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.greater_than";
        v42[3] = 17;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThan,void>::id)
    goto LABEL_36;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v38, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E98BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E98CFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler *EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler::ANECElementwiseGreaterThanEqualOpHandler(EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04B20;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 23)
    {
      v36 = *AttrData == 0x6572672E63656E61 && AttrData[1] == 0x6168745F72657461;
      if (v36 && *(_QWORD *)((char *)AttrData + 15) == 0x6C617571655F6E61)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.greater_than_equal";
        v42[3] = 23;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqual,void>::id)
    goto LABEL_36;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v38, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E99160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E99278(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler *EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler::ANECElementwiseGreaterThanEqualZeroOpHandler(EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  BOOL v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04BB0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 28)
    {
      v35 = *(_QWORD *)AttrData == 0x6572672E63656E61 && *(_QWORD *)(AttrData + 8) == 0x6168745F72657461;
      v36 = v35 && *(_QWORD *)(AttrData + 16) == 0x5F6C617571655F6ELL;
      if (v36 && *(_DWORD *)(AttrData + 24) == 1869768058)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.greater_than_equal_zero";
        v42[3] = 28;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqualZero,void>::id)
    goto LABEL_37;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E996B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler *EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler::ANECElementwiseGreaterThanZeroOpHandler(EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  BOOL v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04AD8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 22)
    {
      v35 = *AttrData == 0x6572672E63656E61 && AttrData[1] == 0x6168745F72657461;
      if (v35 && *(_QWORD *)((char *)AttrData + 14) == 0x6F72657A5F6E6168)
      {
        v42 = 1283;
        v41[0] = (uint64_t)"classof on '";
        v41[2] = (uint64_t)"anec.greater_than_zero";
        v41[3] = 22;
        v39 = "' failed due to the operation not being registered";
        v40 = 259;
        llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanZero,void>::id)
    goto LABEL_34;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E99BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseLessThanOpHandler *EmitterViewerSPI::ANECElementwiseLessThanOpHandler::ANECElementwiseLessThanOpHandler(EmitterViewerSPI::ANECElementwiseLessThanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04850;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 14 && *AttrData == 0x73656C2E63656E61 && *(_QWORD *)((char *)AttrData + 6) == 0x6E6168745F737365)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.less_than";
      v41[3] = 14;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThan,void>::id)
    goto LABEL_33;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v37, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9A130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9A248(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler *EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler::ANECElementwiseLessThanEqualOpHandler(EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04A60;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      v36 = *(_QWORD *)AttrData == 0x73656C2E63656E61 && *(_QWORD *)(AttrData + 8) == 0x655F6E6168745F73;
      if (v36 && *(_DWORD *)(AttrData + 16) == 1818326385)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.less_than_equal";
        v42[3] = 20;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqual,void>::id)
    goto LABEL_36;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v38, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9A6A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9A7BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler *EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler::ANECElementwiseLessThanEqualZeroOpHandler(EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  BOOL v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04B50;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 25)
    {
      v35 = *(_QWORD *)AttrData == 0x73656C2E63656E61 && *(_QWORD *)(AttrData + 8) == 0x655F6E6168745F73;
      v36 = v35 && *(_QWORD *)(AttrData + 16) == 0x72657A5F6C617571;
      if (v36 && *(_BYTE *)(AttrData + 24) == 111)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.less_than_equal_zero";
        v42[3] = 25;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqualZero,void>::id)
    goto LABEL_37;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9ABF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler *EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler::ANECElementwiseLessThanZeroOpHandler(EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  BOOL v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04A30;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 19)
    {
      v35 = *AttrData == 0x73656C2E63656E61 && AttrData[1] == 0x7A5F6E6168745F73;
      if (v35 && *(_QWORD *)((char *)AttrData + 11) == 0x6F72657A5F6E6168)
      {
        v42 = 1283;
        v41[0] = (uint64_t)"classof on '";
        v41[2] = (uint64_t)"anec.less_than_zero";
        v41[3] = 19;
        v39 = "' failed due to the operation not being registered";
        v40 = 259;
        llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanZero,void>::id)
    goto LABEL_34;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9B124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseMaxOpHandler *EmitterViewerSPI::ANECElementwiseMaxOpHandler::ANECElementwiseMaxOpHandler(EmitterViewerSPI::ANECElementwiseMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04340;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x78616D2E63656E61)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.max";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMax,void>::id)
    goto LABEL_29;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v36, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9B658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9B770(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseMinOpHandler *EmitterViewerSPI::ANECElementwiseMinOpHandler::ANECElementwiseMinOpHandler(EmitterViewerSPI::ANECElementwiseMinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04358;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6E696D2E63656E61)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.min";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMin,void>::id)
    goto LABEL_29;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v36, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9BBA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9BCC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseMultOpHandler *EmitterViewerSPI::ANECElementwiseMultOpHandler::ANECElementwiseMultOpHandler(EmitterViewerSPI::ANECElementwiseMultOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04538;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x6C756D2E63656E61 && *(_BYTE *)(AttrData + 8) == 116)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.mult";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    goto LABEL_33;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v37, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9C104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9C21C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseNotEqualOpHandler *EmitterViewerSPI::ANECElementwiseNotEqualOpHandler::ANECElementwiseNotEqualOpHandler(EmitterViewerSPI::ANECElementwiseNotEqualOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04868;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 14 && *AttrData == 0x746F6E2E63656E61 && *(_QWORD *)((char *)AttrData + 6) == 0x6C617571655F746FLL)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.not_equal";
      v41[3] = 14;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqual,void>::id)
    goto LABEL_33;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v37, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9C66C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9C784(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler *EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler::ANECElementwiseNotEqualZeroOpHandler(EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  BOOL v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04A48;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 19)
    {
      v35 = *AttrData == 0x746F6E2E63656E61 && AttrData[1] == 0x7A5F6C617571655FLL;
      if (v35 && *(_QWORD *)((char *)AttrData + 11) == 0x6F72657A5F6C6175)
      {
        v42 = 1283;
        v41[0] = (uint64_t)"classof on '";
        v41[2] = (uint64_t)"anec.not_equal_zero";
        v41[3] = 19;
        v39 = "' failed due to the operation not being registered";
        v40 = 259;
        llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqualZero,void>::id)
    goto LABEL_34;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9CBB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwisePowerOpHandler *EmitterViewerSPI::ANECElementwisePowerOpHandler::ANECElementwisePowerOpHandler(EmitterViewerSPI::ANECElementwisePowerOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04628;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 10 && *(_QWORD *)AttrData == 0x776F702E63656E61 && *(_WORD *)(AttrData + 8) == 29285)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.power";
      v41[3] = 10;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwisePower,void>::id)
    goto LABEL_33;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v37, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9D0F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9D20C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseSquareOpHandler *EmitterViewerSPI::ANECElementwiseSquareOpHandler::ANECElementwiseSquareOpHandler(EmitterViewerSPI::ANECElementwiseSquareOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04700;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 11 && *AttrData == 0x7571732E63656E61 && *(_QWORD *)((char *)AttrData + 3) == 0x6572617571732E63)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.square";
      v40[3] = 11;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSquare,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9D628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseSubOpHandler *EmitterViewerSPI::ANECElementwiseSubOpHandler::ANECElementwiseSubOpHandler(EmitterViewerSPI::ANECElementwiseSubOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04370;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6275732E63656E61)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.sub";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSub,void>::id)
    goto LABEL_29;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v36, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9DB5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9DC74(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECEluOpHandler *EmitterViewerSPI::ANECEluOpHandler::ANECEluOpHandler(EmitterViewerSPI::ANECEluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  void *v26;
  llvm::APFloatBase *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  _QWORD *AttrData;
  uint64_t v38;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  void *__dst[2];
  const char *v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  void *v48;
  _QWORD v49[4];

  v49[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02D68;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v47 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v47);
    if (v38 == 8 && *AttrData == 0x756C652E63656E61)
    {
      v46 = 1283;
      __dst[0] = "classof on '";
      v44 = "anec.elu";
      v45 = 8;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v41, (uint64_t)&v47);
      llvm::report_fatal_error((llvm::Twine *)&v47, 1);
    }
LABEL_32:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Elu,void>::id)
    goto LABEL_32;
  v40 = a3;
  v47 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v47);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v44) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::Rsqrt::getEpsilon(&v40, (uint64_t)&v47);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("alpha"), 268435488, &unk_1E0E99C58);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v47, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }

  v26 = v48;
  if (llvm::APFloatBase::PPCDoubleDouble(v27) == v26)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v49);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v48);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v39, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9E148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECErfOpHandler *EmitterViewerSPI::ANECErfOpHandler::ANECErfOpHandler(EmitterViewerSPI::ANECErfOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v35;
  mlir::Operation *v36;
  const char *v37;
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  void *__dst[2];
  int64_t v42;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02D80;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x6672652E63656E61)
    {
      v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.erf";
      v39[3] = 8;
      v37 = "' failed due to the operation not being registered";
      v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Erf,void>::id)
    goto LABEL_27;
  v36 = a3;
  v39[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v42 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v35, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9E668(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECExp2OpHandler *EmitterViewerSPI::ANECExp2OpHandler::ANECExp2OpHandler(EmitterViewerSPI::ANECExp2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03068;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(_QWORD *)AttrData == 0x7078652E63656E61 && *(_BYTE *)(AttrData + 8) == 50)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.exp2";
      v40[3] = 9;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9EB74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECFlattenOpHandler *EmitterViewerSPI::ANECFlattenOpHandler::ANECFlattenOpHandler(EmitterViewerSPI::ANECFlattenOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t FlattenMode;
  void *v25;
  MPSGraphViewerNodePropertyEnumCaseSPI *v26;
  MPSGraphViewerNodePropertyEnumCaseSPI *v27;
  MPSGraphViewerNodePropertyEnumSPI *v28;
  void *v29;
  MPSGraphViewerNodeSPI *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  uint64_t v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03770;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 12 && *(_QWORD *)AttrData == 0x616C662E63656E61 && *(_DWORD *)(AttrData + 8) == 1852142708)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"anec.flatten";
      v45[3] = 12;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Flatten,void>::id)
    goto LABEL_33;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  FlattenMode = mlir::anec::Flatten::getFlattenMode(&v42);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 1);
  objc_msgSend(v25, "addObject:", v26);

  v27 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 2);
  objc_msgSend(v25, "addObject:", v27);

  v28 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("flatten_mode"), CFSTR("ANECFlattenMode"), v25, FlattenMode);
  if (v28)
    objc_msgSend(v23, "addObject:", v28);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v30, "initWithType:inputs:outputs:properties:regions:", v41, v31, v32, v33, v34);
  v36 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v35;

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9F140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECFloorOpHandler *EmitterViewerSPI::ANECFloorOpHandler::ANECFloorOpHandler(EmitterViewerSPI::ANECFloorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E032D8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 10 && *(_QWORD *)AttrData == 0x6F6C662E63656E61 && *(_WORD *)(AttrData + 8) == 29295)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.floor";
      v40[3] = 10;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9F678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECGOCOpHandler *EmitterViewerSPI::ANECGOCOpHandler::ANECGOCOpHandler(EmitterViewerSPI::ANECGOCOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  void *v26;
  void *v27;
  MPSGraphViewerNodeSPI *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02D98;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 24)
    {
      v38 = *AttrData == 0x6961672E63656E61 && AttrData[1] == 0x74657366666F5F6ELL;
      if (v38 && AttrData[2] == 0x6C6F72746E6F635FLL)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"anec.gain_offset_control";
        v44[3] = 24;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    goto LABEL_38;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("scale"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("bias"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v22->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v22->_dataType & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v22)
      objc_msgSend(v21, "addObject:", v22);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v28, "initWithType:inputs:outputs:properties:regions:", v40, v29, v30, v31, v32);
  v34 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v33;

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180E9FC10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180E9FD40(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECGatherNDOpHandler *EmitterViewerSPI::ANECGatherNDOpHandler::ANECGatherNDOpHandler(EmitterViewerSPI::ANECGatherNDOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  uint64_t **Axes;
  uint64_t **v27;
  uint64_t InterfaceFor;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  _QWORD *AttrData;
  uint64_t v44;
  void *v46;
  mlir::Operation *v47;
  const char *v48;
  __int16 v49;
  uint64_t v50[4];
  __int16 v51;
  void *__dst[2];
  int64_t v53;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E039C8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v44 == 14 && *AttrData == 0x7461672E63656E61 && *(_QWORD *)((char *)AttrData + 6) == 0x646E5F7265687461)
    {
      v51 = 1283;
      v50[0] = (uint64_t)"classof on '";
      v50[2] = (uint64_t)"anec.gather_nd";
      v50[3] = 14;
      v48 = "' failed due to the operation not being registered";
      v49 = 259;
      llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::GatherND,void>::id)
    goto LABEL_44;
  v47 = a3;
  v50[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v53 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("data"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("index"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v47);
  v27 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v30 = 692;
    v31 = "Casting.h";
    v32 = "cast_if_present";
    goto LABEL_35;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v30 = 566;
    v31 = "Casting.h";
    v32 = "cast";
LABEL_35:
    __assert_rtn(v32, v31, v30, v29);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v30 = 98;
    v31 = "InterfaceSupport.h";
    v32 = "Interface";
    goto LABEL_35;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("axes"), (uint64_t)v27, InterfaceFor);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  if (v33)
    objc_msgSend(v25, "addObject:", v33);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v46, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  if (SHIBYTE(v53) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA0260(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECGeluOpHandler *EmitterViewerSPI::ANECGeluOpHandler::ANECGeluOpHandler(EmitterViewerSPI::ANECGeluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03080;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(_QWORD *)AttrData == 0x6C65672E63656E61 && *(_BYTE *)(AttrData + 8) == 117)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.gelu";
      v40[3] = 9;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Gelu,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA0794(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler *EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler::ANECGlobalArgMinMaxOpHandler(EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  uint64_t FlattenMode;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumSPI *v30;
  void *v31;
  MPSGraphViewerNodeSPI *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04550;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 23)
    {
      v42 = *AttrData == 0x6F6C672E63656E61 && AttrData[1] == 0x5F6772615F6C6162;
      if (v42 && *(_QWORD *)((char *)AttrData + 15) == 0x78616D5F6E696D5FLL)
      {
        v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"anec.global_arg_min_max";
        v48[3] = 23;
        v46 = "' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::GlobalArgMinMax,void>::id)
    goto LABEL_38;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v48[0]) = 0;
  LODWORD(v48[0]) = mlir::anec::GlobalArgMinMax::getAxis(&v45);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("axis"), 32, &unk_1E0E99C70);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 4);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }
  FlattenMode = mlir::anec::Unflatten::getFlattenMode(&v45);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Min"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Max"), 1);
  objc_msgSend(v27, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("mode"), CFSTR("ANECArgMinMaxMode"), v27, FlattenMode);
  if (v30)
    objc_msgSend(v23, "addObject:", v30);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v32, "initWithType:inputs:outputs:properties:regions:", v44, v33, v34, v35, v36);
  v38 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v37;

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA0DF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler *EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler::ANECHighPrecisionSigmoidOpHandler(EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  BOOL v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04910;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 27)
    {
      v35 = *AttrData == 0x6769682E63656E61 && AttrData[1] == 0x7369636572705F68;
      v36 = v35 && AttrData[2] == 0x6D6769735F6E6F69;
      if (v36 && *(_QWORD *)((char *)AttrData + 19) == 0x64696F6D6769735FLL)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.high_precision_sigmoid";
        v42[3] = 27;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::HighPrecisionSigmoid,void>::id)
    goto LABEL_37;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA1388(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECInputViewOpHandler *EmitterViewerSPI::ANECInputViewOpHandler::ANECInputViewOpHandler(EmitterViewerSPI::ANECInputViewOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  void *v16;
  uint64_t v17;
  __CFString *v18;
  uint64_t MPSDataType;
  void *v20;
  MPSGraphViewerNodePortSPI *v21;
  void *v22;
  MPSGraphViewerNodePropertyDataSPI *v23;
  void *v24;
  MPSGraphViewerNodePropertyDataSPI *v25;
  void *v26;
  MPSGraphViewerNodePropertyDataSPI *v27;
  void *v28;
  MPSGraphViewerNodePropertyDataSPI *v29;
  void *v30;
  void *v31;
  MPSGraphViewerNodeSPI *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  void *v43;
  void *v44;
  void *Step;
  void *Size;
  mlir::Operation *v47;
  uint64_t v48[4];
  __int16 v49;
  uint64_t v50[4];
  __int16 v51;
  void *__dst[2];
  int64_t v53;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03B00;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 15 && *AttrData == 0x706E692E63656E61 && *(_QWORD *)((char *)AttrData + 7) == 0x776569765F747570)
    {
      v51 = 1283;
      v50[0] = (uint64_t)"classof on '";
      v50[2] = (uint64_t)"anec.input_view";
      v50[3] = 15;
      v48[0] = (uint64_t)"' failed due to the operation not being registered";
      v49 = 259;
      llvm::operator+(v50, v48, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    goto LABEL_39;
  v47 = a3;
  v50[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v53 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v44, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  v18 = CFSTR("result");
  if (v17)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v21 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v20, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v17));

    if (v21)
      objc_msgSend(v16, "addObject:", v21);
  }
  else
  {

    v21 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v50[0] = 0;
  v50[0] = (uint64_t)mlir::anec::Resize::getHeight(&v47);
  v23 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("dimension"), 64, &unk_1E0E99C88);
  if (v23)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v50, 8);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v23, "setValue:", v24);

    objc_msgSend(v22, "addObject:", v23);
  }
  v48[0] = 0;
  v48[0] = (uint64_t)mlir::anec::InputView::getOffset(&v47);
  v25 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("offset"), 64, &unk_1E0E99CA0);
  if (v25)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 8);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v25, "setValue:", v26);

    objc_msgSend(v22, "addObject:", v25);
  }
  Size = mlir::anec::InputView::getSize(&v47);
  v27 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("size"), 64, &unk_1E0E99CB8);
  if (v27)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &Size, 8);
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v27, "setValue:", v28);

    objc_msgSend(v22, "addObject:", v27);
  }
  Step = mlir::anec::InputView::getStep(&v47);
  v29 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("step"), 64, &unk_1E0E99CD0);
  if (v29)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &Step, 8);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v29, "setValue:", v30);

    objc_msgSend(v22, "addObject:", v29);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v44);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v16);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v22);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v32, "initWithType:inputs:outputs:properties:regions:", v43, v33, v34, v35, v36);
  v38 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v37;

  if (SHIBYTE(v53) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA1A6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;
  void *v32;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180EA1BCC()
{
  JUMPOUT(0x180EA1B8CLL);
}

void sub_180EA1BD4()
{
  JUMPOUT(0x180EA1B90);
}

void sub_180EA1BDC()
{
  JUMPOUT(0x180EA1B94);
}

void sub_180EA1BE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECInstanceNormOpHandler *EmitterViewerSPI::ANECInstanceNormOpHandler::ANECInstanceNormOpHandler(EmitterViewerSPI::ANECInstanceNormOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **DestinationSize;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  llvm::APFloatBase *v35;
  void *v36;
  MPSGraphViewerNodeSPI *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  void *v43;
  uint64_t AttrData;
  uint64_t v46;
  BOOL v47;
  void *v49;
  mlir::Operation *v50;
  const char *v51;
  __int16 v52;
  void *__dst[2];
  const char *v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  void *v58;
  _QWORD v59[4];

  v59[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03FF8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v57 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v57);
    if (v46 == 18)
    {
      v47 = *(_QWORD *)AttrData == 0x736E692E63656E61 && *(_QWORD *)(AttrData + 8) == 0x6F6E5F65636E6174;
      if (v47 && *(_WORD *)(AttrData + 16) == 28018)
      {
        v56 = 1283;
        __dst[0] = "classof on '";
        v54 = "anec.instance_norm";
        v55 = 18;
        v51 = "' failed due to the operation not being registered";
        v52 = 259;
        llvm::operator+((uint64_t *)__dst, (uint64_t *)&v51, (uint64_t)&v57);
        llvm::report_fatal_error((llvm::Twine *)&v57, 1);
      }
    }
LABEL_50:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::InstanceNorm,void>::id)
    goto LABEL_50;
  v50 = a3;
  v57 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v57);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v54 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v54) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v54) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v50);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v50);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  DestinationSize = (uint64_t **)mlir::anec::Unflatten::getDestinationSize((mlir::anec::Unflatten *)&v50);
  v25 = DestinationSize;
  if (!DestinationSize)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(DestinationSize))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_38:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_38;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("axes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  mlir::anec::InstanceNorm::getEpsilon(&v50, (uint64_t)&v57);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("epsilon"), 268435488, &unk_1E0E99CE8);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v57, 32);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v23, "addObject:", v32);
  }

  v34 = v58;
  if (llvm::APFloatBase::PPCDoubleDouble(v35) == v34)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v59);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v58);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v36);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  v42 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v37, "initWithType:inputs:outputs:properties:regions:", v49, v38, v39, v40, v41);
  v43 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v42;

  if (SHIBYTE(v54) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA21A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECInvertOpHandler *EmitterViewerSPI::ANECInvertOpHandler::ANECInvertOpHandler(EmitterViewerSPI::ANECInvertOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  void *v26;
  llvm::APFloatBase *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  _QWORD *AttrData;
  uint64_t v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  void *__dst[2];
  const char *v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  void *v49;
  _QWORD v50[4];

  v50[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E034E8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v48 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
    if (v38 == 11 && *AttrData == 0x766E692E63656E61 && *(_QWORD *)((char *)AttrData + 3) == 0x747265766E692E63)
    {
      v47 = 1283;
      __dst[0] = "classof on '";
      v45 = "anec.invert";
      v46 = 11;
      v42 = "' failed due to the operation not being registered";
      v43 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v42, (uint64_t)&v48);
      llvm::report_fatal_error((llvm::Twine *)&v48, 1);
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id)
    goto LABEL_36;
  v41 = a3;
  v48 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v45) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::Rsqrt::getEpsilon(&v41, (uint64_t)&v48);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("epsilon"), 268435488, &unk_1E0E99D00);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v48, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }

  v26 = v49;
  if (llvm::APFloatBase::PPCDoubleDouble(v27) == v26)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v40, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA27C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECL2NormPoolOpHandler *EmitterViewerSPI::ANECL2NormPoolOpHandler::ANECL2NormPoolOpHandler(EmitterViewerSPI::ANECL2NormPoolOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Stride;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t **Padding;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **Ksize;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  void *v48;
  MPSGraphViewerNodeSPI *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  _QWORD *AttrData;
  uint64_t v58;
  void *v60;
  mlir::Operation *v61;
  const char *v62;
  __int16 v63;
  uint64_t v64[4];
  __int16 v65;
  void *__dst[2];
  int64_t v67;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03D28;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v58 == 16 && *AttrData == 0x6E326C2E63656E61 && AttrData[1] == 0x6C6F6F705F6D726FLL)
    {
      v65 = 1283;
      v64[0] = (uint64_t)"classof on '";
      v64[2] = (uint64_t)"anec.l2norm_pool";
      v64[3] = 16;
      v62 = "' failed due to the operation not being registered";
      v63 = 259;
      llvm::operator+(v64, (uint64_t *)&v62, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_64:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::L2NormPool,void>::id)
    goto LABEL_64;
  v61 = a3;
  v64[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v64);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v67 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v67) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v67 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v61);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v61);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Stride = (uint64_t **)mlir::anec::MaxPool::getStride((mlir::anec::MaxPool *)&v61);
  v25 = Stride;
  if (!Stride)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_49;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_49:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_49;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("stride"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  Padding = (uint64_t **)mlir::anec::MaxPool::getPadding((mlir::anec::MaxPool *)&v61);
  v33 = Padding;
  if (!Padding)
  {
    v34 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_52:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_52;
  }
LABEL_34:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("padding"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  Ksize = (uint64_t **)mlir::anec::MaxPool::getKsize((mlir::anec::MaxPool *)&v61);
  v41 = Ksize;
  if (!Ksize)
  {
    v42 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Ksize))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_55;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_55:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_55;
  }
LABEL_42:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("ksize"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  v49 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v48);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  v54 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v49, "initWithType:inputs:outputs:properties:regions:", v60, v50, v51, v52, v53);
  v55 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v54;

  if (SHIBYTE(v67) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA2F5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECLeakyReluOpHandler *EmitterViewerSPI::ANECLeakyReluOpHandler::ANECLeakyReluOpHandler(EmitterViewerSPI::ANECLeakyReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  llvm::APFloatBase *v29;
  void *v30;
  void *v31;
  MPSGraphViewerNodeSPI *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  void *v43;
  mlir::Operation *v44;
  void *__dst[2];
  int64_t v46;
  __int16 v47;
  const char *v48;
  void *v49;
  _QWORD v50[2];
  __int16 v51;
  uint64_t v52;
  void *v53;
  _QWORD v54[4];

  v54[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03B18;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v52 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
    if (v41 == 15 && *AttrData == 0x61656C2E63656E61 && *(_QWORD *)((char *)AttrData + 7) == 0x756C65725F796B61)
    {
      v51 = 1283;
      v48 = "classof on '";
      v50[0] = "anec.leaky_relu";
      v50[1] = 15;
      __dst[0] = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+((uint64_t *)&v48, (uint64_t *)__dst, (uint64_t)&v52);
      llvm::report_fatal_error((llvm::Twine *)&v52, 1);
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::LeakyRelu,void>::id)
    goto LABEL_41;
  v44 = a3;
  v52 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::DeQuant::getScale(&v44, (uint64_t)&v52);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("offset"), 268435488, &unk_1E0E99D18);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v52, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }
  mlir::anec::InstanceNorm::getEpsilon(&v44, (uint64_t)&v48);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("slope"), 268435488, &unk_1E0E99D30);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v48, 32);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v23, "addObject:", v26);
  }

  v28 = v49;
  v30 = llvm::APFloatBase::PPCDoubleDouble(v29);
  if (v30 == v28)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);

  if (v30 == v53)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v54);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v53);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v32, "initWithType:inputs:outputs:properties:regions:", v43, v33, v34, v35, v36);
  v38 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v37;

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA3608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a16 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECLinearOpHandler *EmitterViewerSPI::ANECLinearOpHandler::ANECLinearOpHandler(EmitterViewerSPI::ANECLinearOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  uint64_t **KernelScale;
  char v27;
  uint64_t **v28;
  uint64_t InterfaceFor;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  void *v34;
  uint64_t **KernelZeroPoint;
  char v36;
  uint64_t **v37;
  uint64_t v38;
  const char *v39;
  int v40;
  const char *v41;
  const char *v42;
  void *v43;
  void *v44;
  MPSGraphViewerNodeSPI *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  _QWORD *AttrData;
  uint64_t v54;
  void *v56;
  mlir::Operation *v57;
  const char *v58;
  __int16 v59;
  uint64_t v60[4];
  __int16 v61;
  void *__dst[2];
  int64_t v63;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03500;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v54 == 11 && *AttrData == 0x6E696C2E63656E61 && *(_QWORD *)((char *)AttrData + 3) == 0x7261656E696C2E63)
    {
      v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.linear";
      v60[3] = 11;
      v58 = "' failed due to the operation not being registered";
      v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_59:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id)
    goto LABEL_59;
  v57 = a3;
  v60[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v63 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v57);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("kernel"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  KernelScale = (uint64_t **)mlir::anec::Linear::getKernelScale(&v57);
  if (v27)
  {
    v28 = KernelScale;
    if (KernelScale)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelScale))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28))
        {
          InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28);
          if (!InterfaceFor)
          {
            v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v31 = 98;
            v32 = "InterfaceSupport.h";
            v33 = "Interface";
            goto LABEL_47;
          }
          goto LABEL_29;
        }
        v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v31 = 566;
        v32 = "Casting.h";
        v33 = "cast";
      }
      else
      {
        v30 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v31 = 692;
        v32 = "Casting.h";
        v33 = "cast_if_present";
      }
LABEL_47:
      __assert_rtn(v33, v32, v31, v30);
    }
    InterfaceFor = 0;
LABEL_29:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_scale"), (uint64_t)v28, InterfaceFor);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    if (v34)
      objc_msgSend(v25, "addObject:", v34);

  }
  KernelZeroPoint = (uint64_t **)mlir::anec::Linear::getKernelZeroPoint(&v57);
  if (!v36)
    goto LABEL_42;
  v37 = KernelZeroPoint;
  if (KernelZeroPoint)
  {
    if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelZeroPoint))
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v37))
      {
        v38 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v37);
        if (!v38)
        {
          v39 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          v40 = 98;
          v41 = "InterfaceSupport.h";
          v42 = "Interface";
          goto LABEL_50;
        }
        goto LABEL_39;
      }
      v39 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      v40 = 566;
      v41 = "Casting.h";
      v42 = "cast";
    }
    else
    {
      v39 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
      v40 = 692;
      v41 = "Casting.h";
      v42 = "cast_if_present";
    }
LABEL_50:
    __assert_rtn(v42, v41, v40, v39);
  }
  v38 = 0;
LABEL_39:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_zero_point"), (uint64_t)v37, v38);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  if (v43)
    objc_msgSend(v25, "addObject:", v43);

LABEL_42:
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v45 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v44);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v45, "initWithType:inputs:outputs:properties:regions:", v56, v46, v47, v48, v49);
  v51 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v50;

  if (SHIBYTE(v63) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA3D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECLog2OpHandler *EmitterViewerSPI::ANECLog2OpHandler::ANECLog2OpHandler(EmitterViewerSPI::ANECLog2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  void *v26;
  llvm::APFloatBase *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  uint64_t AttrData;
  uint64_t v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  void *__dst[2];
  const char *v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  void *v49;
  _QWORD v50[4];

  v50[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03098;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v48 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
    if (v38 == 9 && *(_QWORD *)AttrData == 0x676F6C2E63656E61 && *(_BYTE *)(AttrData + 8) == 50)
    {
      v47 = 1283;
      __dst[0] = "classof on '";
      v45 = "anec.log2";
      v46 = 9;
      v42 = "' failed due to the operation not being registered";
      v43 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v42, (uint64_t)&v48);
      llvm::report_fatal_error((llvm::Twine *)&v48, 1);
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Log2,void>::id)
    goto LABEL_36;
  v41 = a3;
  v48 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v45) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::Rsqrt::getEpsilon(&v41, (uint64_t)&v48);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("epsilon"), 268435488, &unk_1E0E99D48);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v48, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }

  v26 = v49;
  if (llvm::APFloatBase::PPCDoubleDouble(v27) == v26)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v40, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA4360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECMatMulOpHandler *EmitterViewerSPI::ANECMatMulOpHandler::ANECMatMulOpHandler(EmitterViewerSPI::ANECMatMulOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  llvm::APFloatBase *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  _QWORD *AttrData;
  uint64_t v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  void *__dst[2];
  const char *v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  char v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03518;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v50 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
    if (v40 == 11 && *AttrData == 0x74616D2E63656E61 && *(_QWORD *)((char *)AttrData + 3) == 0x6C756D74616D2E63)
    {
      v49 = 1283;
      __dst[0] = "classof on '";
      v47 = "anec.matmul";
      v48 = 11;
      v44 = "' failed due to the operation not being registered";
      v45 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v44, (uint64_t)&v50);
      llvm::report_fatal_error((llvm::Twine *)&v50, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id)
    goto LABEL_42;
  v43 = a3;
  v50 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v47) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::MatMul::getBias(&v43, (uint64_t)&v50);
  if (v53)
  {
    v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("bias"), 268435488, &unk_1E0E99D60);
    if (v26)
    {
      if (!v53)
        std::__throw_bad_optional_access[abi:ne180100]();
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v50, 40);
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

      objc_msgSend(v25, "addObject:", v26);
    }

    if (v53)
    {
      v29 = v51;
      if (llvm::APFloatBase::PPCDoubleDouble(v28) == v29)
        std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v52);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v51);
    }
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v42, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA49C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  std::optional<llvm::APFloat>::~optional(&a24);
  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

_BYTE *std::optional<llvm::APFloat>::~optional(_BYTE *a1)
{
  void *v2;

  if (!a1[32])
    return a1;
  v2 = (void *)*((_QWORD *)a1 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v2)
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)(a1 + 8));
    return a1;
  }
  std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)(a1 + 16));
  return a1;
}

EmitterViewerSPI::ANECMaxPoolOpHandler *EmitterViewerSPI::ANECMaxPoolOpHandler::ANECMaxPoolOpHandler(EmitterViewerSPI::ANECMaxPoolOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Stride;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t **Padding;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **Ksize;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  void *v48;
  MPSGraphViewerNodeSPI *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  _QWORD *AttrData;
  uint64_t v58;
  void *v60;
  mlir::Operation *v61;
  const char *v62;
  __int16 v63;
  uint64_t v64[4];
  __int16 v65;
  void *__dst[2];
  int64_t v67;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03788;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v58 == 13 && *AttrData == 0x78616D2E63656E61 && *(_QWORD *)((char *)AttrData + 5) == 0x6C6F6F705F78616DLL)
    {
      v65 = 1283;
      v64[0] = (uint64_t)"classof on '";
      v64[2] = (uint64_t)"anec.max_pool";
      v64[3] = 13;
      v62 = "' failed due to the operation not being registered";
      v63 = 259;
      llvm::operator+(v64, (uint64_t *)&v62, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_64:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::MaxPool,void>::id)
    goto LABEL_64;
  v61 = a3;
  v64[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v64);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v67 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v67) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v67 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v61);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v61);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Stride = (uint64_t **)mlir::anec::MaxPool::getStride((mlir::anec::MaxPool *)&v61);
  v25 = Stride;
  if (!Stride)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_49;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_49:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_49;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("stride"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  Padding = (uint64_t **)mlir::anec::MaxPool::getPadding((mlir::anec::MaxPool *)&v61);
  v33 = Padding;
  if (!Padding)
  {
    v34 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_52:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_52;
  }
LABEL_34:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("padding"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  Ksize = (uint64_t **)mlir::anec::MaxPool::getKsize((mlir::anec::MaxPool *)&v61);
  v41 = Ksize;
  if (!Ksize)
  {
    v42 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Ksize))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_55;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_55:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_55;
  }
LABEL_42:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("ksize"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  v49 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v48);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  v54 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v49, "initWithType:inputs:outputs:properties:regions:", v60, v50, v51, v52, v53);
  v55 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v54;

  if (SHIBYTE(v67) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA51DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECNReluOpHandler *EmitterViewerSPI::ANECNReluOpHandler::ANECNReluOpHandler(EmitterViewerSPI::ANECNReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  llvm::APFloatBase *v29;
  void *v30;
  void *v31;
  MPSGraphViewerNodeSPI *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  void *v43;
  mlir::Operation *v44;
  void *__dst[2];
  int64_t v46;
  __int16 v47;
  const char *v48;
  void *v49;
  _QWORD v50[2];
  __int16 v51;
  uint64_t v52;
  void *v53;
  _QWORD v54[4];

  v54[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E032F0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v52 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
    if (v41 == 11 && *AttrData == 0x725F6E2E63656E61 && *(_QWORD *)((char *)AttrData + 3) == 0x756C65725F6E2E63)
    {
      v51 = 1283;
      v48 = "classof on '";
      v50[0] = "anec.n_relu";
      v50[1] = 11;
      __dst[0] = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+((uint64_t *)&v48, (uint64_t *)__dst, (uint64_t)&v52);
      llvm::report_fatal_error((llvm::Twine *)&v52, 1);
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::NRelu,void>::id)
    goto LABEL_41;
  v44 = a3;
  v52 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::DeQuant::getScale(&v44, (uint64_t)&v52);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("max_value"), 268435488, &unk_1E0E99D78);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v52, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }
  mlir::anec::InstanceNorm::getEpsilon(&v44, (uint64_t)&v48);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("slope"), 268435488, &unk_1E0E99D90);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v48, 32);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v23, "addObject:", v26);
  }

  v28 = v49;
  v30 = llvm::APFloatBase::PPCDoubleDouble(v29);
  if (v30 == v28)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);

  if (v30 == v53)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v54);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v53);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v32, "initWithType:inputs:outputs:properties:regions:", v43, v33, v34, v35, v36);
  v38 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v37;

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA5888(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a16 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECPaddingOpHandler *EmitterViewerSPI::ANECPaddingOpHandler::ANECPaddingOpHandler(EmitterViewerSPI::ANECPaddingOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Padding;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t **Stride;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  MPSGraphViewerNodePropertyDataSPI *v40;
  void *v41;
  void *v42;
  llvm::APFloatBase *v43;
  void *v44;
  MPSGraphViewerNodeSPI *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  uint64_t AttrData;
  uint64_t v54;
  void *v56;
  mlir::Operation *v57;
  const char *v58;
  __int16 v59;
  void *__dst[2];
  const char *v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  void *v65;
  _QWORD v66[4];

  v66[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E037A0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v64 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v64);
    if (v54 == 12 && *(_QWORD *)AttrData == 0x6461702E63656E61 && *(_DWORD *)(AttrData + 8) == 1735289188)
    {
      v63 = 1283;
      __dst[0] = "classof on '";
      v61 = "anec.padding";
      v62 = 12;
      v58 = "' failed due to the operation not being registered";
      v59 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v58, (uint64_t)&v64);
      llvm::report_fatal_error((llvm::Twine *)&v64, 1);
    }
LABEL_58:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Padding,void>::id)
    goto LABEL_58;
  v57 = a3;
  v64 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v64);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v61 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v61) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v61) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Padding = (uint64_t **)mlir::anec::MaxPool::getPadding((mlir::anec::MaxPool *)&v57);
  v25 = Padding;
  if (!Padding)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_46:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_46;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("padding_modes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  Stride = (uint64_t **)mlir::anec::MaxPool::getStride((mlir::anec::MaxPool *)&v57);
  v33 = Stride;
  if (!Stride)
  {
    v34 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_49;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_49:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_49;
  }
LABEL_34:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("padding_sizes"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  mlir::anec::Padding::getBackgroundValue(&v57, (uint64_t)&v64);
  v40 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("background_value"), 268435488, &unk_1E0E99DA8);
  if (v40)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v64, 32);
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v40, "setValue:", v41);

    objc_msgSend(v23, "addObject:", v40);
  }

  v42 = v65;
  if (llvm::APFloatBase::PPCDoubleDouble(v43) == v42)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v66);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v65);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v45 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v44);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v45, "initWithType:inputs:outputs:properties:regions:", v56, v46, v47, v48, v49);
  v51 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v50;

  if (SHIBYTE(v61) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA6050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECPixelShuffleOpHandler *EmitterViewerSPI::ANECPixelShuffleOpHandler::ANECPixelShuffleOpHandler(EmitterViewerSPI::ANECPixelShuffleOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  uint64_t AttrData;
  uint64_t v42;
  BOOL v43;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04010;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 18)
    {
      v43 = *(_QWORD *)AttrData == 0x7869702E63656E61 && *(_QWORD *)(AttrData + 8) == 0x66667568735F6C65;
      if (v43 && *(_WORD *)(AttrData + 16) == 25964)
      {
        v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.pixel_shuffle";
        v49[3] = 18;
        v47 = "' failed due to the operation not being registered";
        v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id)
    goto LABEL_45;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("factors"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA6688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECPixelUnshuffleOpHandler *EmitterViewerSPI::ANECPixelUnshuffleOpHandler::ANECPixelUnshuffleOpHandler(EmitterViewerSPI::ANECPixelUnshuffleOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  uint64_t AttrData;
  uint64_t v42;
  BOOL v43;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04388;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 20)
    {
      v43 = *(_QWORD *)AttrData == 0x7869702E63656E61 && *(_QWORD *)(AttrData + 8) == 0x7568736E755F6C65;
      if (v43 && *(_DWORD *)(AttrData + 16) == 1701602918)
      {
        v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.pixel_unshuffle";
        v49[3] = 20;
        v47 = "' failed due to the operation not being registered";
        v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id)
    goto LABEL_45;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("factors"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA6C88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECQuantOpHandler *EmitterViewerSPI::ANECQuantOpHandler::ANECQuantOpHandler(EmitterViewerSPI::ANECQuantOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  llvm::APFloatBase *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  uint64_t AttrData;
  uint64_t v40;
  void *v42;
  mlir::Operation *v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  const char *v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  void *v51;
  _QWORD v52[4];

  v52[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03308;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v50 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
    if (v40 == 10 && *(_QWORD *)AttrData == 0x6175712E63656E61 && *(_WORD *)(AttrData + 8) == 29806)
    {
      v49 = 1283;
      __dst[0] = "classof on '";
      v47 = "anec.quant";
      v48 = 10;
      v44[0] = (uint64_t)"' failed due to the operation not being registered";
      v45 = 259;
      llvm::operator+((uint64_t *)__dst, v44, (uint64_t)&v50);
      llvm::report_fatal_error((llvm::Twine *)&v50, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Quant,void>::id)
    goto LABEL_38;
  v43 = a3;
  v50 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v47) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::DeQuant::getScale(&v43, (uint64_t)&v50);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("scale"), 268435488, &unk_1E0E99DC0);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v50, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }
  LODWORD(v44[0]) = 0;
  LODWORD(v44[0]) = mlir::anec::DeQuant::getZeroPoint(&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("zero_point"), 536870944, &unk_1E0E99DD8);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v44, 4);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v23, "addObject:", v26);
  }

  v28 = v51;
  if (llvm::APFloatBase::PPCDoubleDouble(v29) == v28)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v52);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v51);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v42, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA72E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReduceAvgOpHandler *EmitterViewerSPI::ANECReduceAvgOpHandler::ANECReduceAvgOpHandler(EmitterViewerSPI::ANECReduceAvgOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03B30;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 15 && *AttrData == 0x6465722E63656E61 && *(_QWORD *)((char *)AttrData + 7) == 0x6776615F65637564)
    {
      v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.reduce_avg";
      v48[3] = 15;
      v46 = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceAvg,void>::id)
    goto LABEL_42;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("axes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v44, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA790C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReduceMaxOpHandler *EmitterViewerSPI::ANECReduceMaxOpHandler::ANECReduceMaxOpHandler(EmitterViewerSPI::ANECReduceMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03B48;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 15 && *AttrData == 0x6465722E63656E61 && *(_QWORD *)((char *)AttrData + 7) == 0x78616D5F65637564)
    {
      v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.reduce_max";
      v48[3] = 15;
      v46 = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceMax,void>::id)
    goto LABEL_42;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("axes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v44, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA7F00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReduceMinOpHandler *EmitterViewerSPI::ANECReduceMinOpHandler::ANECReduceMinOpHandler(EmitterViewerSPI::ANECReduceMinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03B60;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 15 && *AttrData == 0x6465722E63656E61 && *(_QWORD *)((char *)AttrData + 7) == 0x6E696D5F65637564)
    {
      v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.reduce_min";
      v48[3] = 15;
      v46 = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceMin,void>::id)
    goto LABEL_42;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("axes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v44, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA84F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReduceSumOpHandler *EmitterViewerSPI::ANECReduceSumOpHandler::ANECReduceSumOpHandler(EmitterViewerSPI::ANECReduceSumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03B78;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 15 && *AttrData == 0x6465722E63656E61 && *(_QWORD *)((char *)AttrData + 7) == 0x6D75735F65637564)
    {
      v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.reduce_sum";
      v48[3] = 15;
      v46 = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceSum,void>::id)
    goto LABEL_42;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("axes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v44, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA8AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECRegionReturnOpHandler *EmitterViewerSPI::ANECRegionReturnOpHandler::ANECRegionReturnOpHandler(EmitterViewerSPI::ANECRegionReturnOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void *v13;
  uint64_t Inputs;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int v19;
  unint64_t v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04028;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 18)
    {
      v36 = *(_QWORD *)AttrData == 0x6765722E63656E61 && *(_QWORD *)(AttrData + 8) == 0x757465725F6E6F69;
      if (v36 && *(_WORD *)(AttrData + 16) == 28274)
      {
        v44 = 1283;
        v43[0] = (uint64_t)"classof on '";
        v43[2] = (uint64_t)"anec.region_return";
        v43[3] = 18;
        v41 = "' failed due to the operation not being registered";
        v42 = 259;
        llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::anec::RegionReturn,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v46 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v46) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v46 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  Inputs = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v40);
  v16 = v15;
  if (v15)
  {
    v17 = Inputs;
    v18 = 0;
    v19 = 1;
    do
    {
      v20 = *(_QWORD *)(v17 + 32 * v18 + 24);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("inputs%d"), v19 - 1);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v21, v20);
      v22 = (void *)objc_claimAutoreleasedReturnValue();

      if (v22)
        objc_msgSend(v13, "addObject:", v22);

      v18 = v19++;
    }
    while (v16 > v18);
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v13);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v38, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA8FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReluOpHandler *EmitterViewerSPI::ANECReluOpHandler::ANECReluOpHandler(EmitterViewerSPI::ANECReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E030B0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(_QWORD *)AttrData == 0x6C65722E63656E61 && *(_BYTE *)(AttrData + 8) == 117)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.relu";
      v40[3] = 9;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA94A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReshapeOpHandler *EmitterViewerSPI::ANECReshapeOpHandler::ANECReshapeOpHandler(EmitterViewerSPI::ANECReshapeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E037B8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 12 && *(_QWORD *)AttrData == 0x7365722E63656E61 && *(_DWORD *)(AttrData + 8) == 1701863784)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.reshape";
      v40[3] = 12;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EA99B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECResizeOpHandler *EmitterViewerSPI::ANECResizeOpHandler::ANECResizeOpHandler(EmitterViewerSPI::ANECResizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  void *v16;
  uint64_t v17;
  __CFString *v18;
  uint64_t MPSDataType;
  void *v20;
  MPSGraphViewerNodePortSPI *v21;
  void *v22;
  MPSGraphViewerNodePropertyDataSPI *v23;
  void *v24;
  MPSGraphViewerNodePropertyDataSPI *v25;
  void *v26;
  MPSGraphViewerNodePropertyDataSPI *v27;
  void *v28;
  MPSGraphViewerNodePropertyDataSPI *v29;
  void *v30;
  uint64_t **SamplingMethods;
  uint64_t **v32;
  uint64_t InterfaceFor;
  const char *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  uint64_t **SamplingModes;
  uint64_t **v40;
  uint64_t v41;
  const char *v42;
  int v43;
  const char *v44;
  const char *v45;
  void *v46;
  void *v47;
  llvm::APFloatBase *v48;
  void *v49;
  void *v50;
  MPSGraphViewerNodeSPI *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  uint64_t v56;
  void *v57;
  _QWORD *AttrData;
  uint64_t v60;
  void *v62;
  void *v63;
  void *Width;
  void *Height;
  mlir::Operation *v66;
  void *__dst[2];
  int64_t v68;
  __int16 v69;
  const char *v70;
  void *v71;
  _QWORD v72[2];
  __int16 v73;
  uint64_t v74;
  void *v75;
  _QWORD v76[5];

  v76[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03530;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v74 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v74);
    if (v60 == 11 && *AttrData == 0x7365722E63656E61 && *(_QWORD *)((char *)AttrData + 3) == 0x657A697365722E63)
    {
      v73 = 1283;
      v70 = "classof on '";
      v72[0] = "anec.resize";
      v72[1] = 11;
      __dst[0] = "' failed due to the operation not being registered";
      v69 = 259;
      llvm::operator+((uint64_t *)&v70, (uint64_t *)__dst, (uint64_t)&v74);
      llvm::report_fatal_error((llvm::Twine *)&v74, 1);
    }
LABEL_67:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Resize,void>::id)
    goto LABEL_67;
  v66 = a3;
  v74 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v74);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v68 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v68) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v68 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v66);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v63, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v66);
  v18 = CFSTR("result");
  if (v17)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v21 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v20, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v17));

    if (v21)
      objc_msgSend(v16, "addObject:", v21);
  }
  else
  {

    v21 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  Height = mlir::anec::Resize::getHeight(&v66);
  v23 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("height"), 64, &unk_1E0E99DF0);
  if (v23)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &Height, 8);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v23, "setValue:", v24);

    objc_msgSend(v22, "addObject:", v23);
  }
  Width = mlir::anec::Resize::getWidth(&v66);
  v25 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("width"), 64, &unk_1E0E99E08);
  if (v25)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &Width, 8);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v25, "setValue:", v26);

    objc_msgSend(v22, "addObject:", v25);
  }
  mlir::anec::Resize::getScaleFactorX(&v66, (uint64_t)&v74);
  v27 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("scale_factor_x"), 268435488, &unk_1E0E99E20);
  if (v27)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v74, 32);
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v27, "setValue:", v28);

    objc_msgSend(v22, "addObject:", v27);
  }
  mlir::anec::Resize::getScaleFactorY(&v66, (uint64_t)&v70);
  v29 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("scale_factor_y"), 268435488, &unk_1E0E99E38);
  if (v29)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v70, 32);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v29, "setValue:", v30);

    objc_msgSend(v22, "addObject:", v29);
  }
  SamplingMethods = (uint64_t **)mlir::anec::Resize::getSamplingMethods((mlir::anec::Resize *)&v66);
  v32 = SamplingMethods;
  if (!SamplingMethods)
  {
    InterfaceFor = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(SamplingMethods))
  {
    v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v35 = 692;
    v36 = "Casting.h";
    v37 = "cast_if_present";
    goto LABEL_55;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v35 = 566;
    v36 = "Casting.h";
    v37 = "cast";
LABEL_55:
    __assert_rtn(v37, v36, v35, v34);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!InterfaceFor)
  {
    v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v35 = 98;
    v36 = "InterfaceSupport.h";
    v37 = "Interface";
    goto LABEL_55;
  }
LABEL_34:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("sampling_methods"), (uint64_t)v32, InterfaceFor);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  if (v38)
    objc_msgSend(v22, "addObject:", v38);
  SamplingModes = (uint64_t **)mlir::anec::Resize::getSamplingModes((mlir::anec::Resize *)&v66);
  v40 = SamplingModes;
  if (!SamplingModes)
  {
    v41 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(SamplingModes))
  {
    v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v43 = 692;
    v44 = "Casting.h";
    v45 = "cast_if_present";
    goto LABEL_58;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v43 = 566;
    v44 = "Casting.h";
    v45 = "cast";
LABEL_58:
    __assert_rtn(v45, v44, v43, v42);
  }
  v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v43 = 98;
    v44 = "InterfaceSupport.h";
    v45 = "Interface";
    goto LABEL_58;
  }
LABEL_42:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("sampling_modes"), (uint64_t)v40, v41);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  if (v46)
    objc_msgSend(v22, "addObject:", v46);

  v47 = v71;
  v49 = llvm::APFloatBase::PPCDoubleDouble(v48);
  if (v49 == v47)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v72);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v71);

  if (v49 == v75)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v76);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v75);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v51 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v63);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v16);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v22);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v50);
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v56 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v51, "initWithType:inputs:outputs:properties:regions:", v62, v52, v53, v54, v55);
  v57 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v56;

  if (SHIBYTE(v68) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAA2B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;

  if (a19 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECRoundNearestOpHandler *EmitterViewerSPI::ANECRoundNearestOpHandler::ANECRoundNearestOpHandler(EmitterViewerSPI::ANECRoundNearestOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  BOOL v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04040;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 18)
    {
      v35 = *(_QWORD *)AttrData == 0x756F722E63656E61 && *(_QWORD *)(AttrData + 8) == 0x657261656E5F646ELL;
      if (v35 && *(_WORD *)(AttrData + 16) == 29811)
      {
        v42 = 1283;
        v41[0] = (uint64_t)"classof on '";
        v41[2] = (uint64_t)"anec.round_nearest";
        v41[3] = 18;
        v39 = "' failed due to the operation not being registered";
        v40 = 259;
        llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::RoundNearest,void>::id)
    goto LABEL_34;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAA8A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECRsqrtOpHandler *EmitterViewerSPI::ANECRsqrtOpHandler::ANECRsqrtOpHandler(EmitterViewerSPI::ANECRsqrtOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  MPSGraphViewerNodePropertyDataSPI *v24;
  void *v25;
  void *v26;
  llvm::APFloatBase *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  _QWORD *AttrData;
  uint64_t v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  void *__dst[2];
  const char *v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  void *v49;
  _QWORD v50[4];

  v50[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03320;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v48 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
    if (v38 == 11 && *AttrData == 0x735F722E63656E61 && *(_QWORD *)((char *)AttrData + 3) == 0x747271735F722E63)
    {
      v47 = 1283;
      __dst[0] = "classof on '";
      v45 = "anec.r_sqrt";
      v46 = 11;
      v42 = "' failed due to the operation not being registered";
      v43 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v42, (uint64_t)&v48);
      llvm::report_fatal_error((llvm::Twine *)&v48, 1);
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Rsqrt,void>::id)
    goto LABEL_36;
  v41 = a3;
  v48 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v45) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::anec::Rsqrt::getEpsilon(&v41, (uint64_t)&v48);
  v24 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("epsilon"), 268435488, &unk_1E0E99E50);
  if (v24)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v48, 32);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v24, "setValue:", v25);

    objc_msgSend(v23, "addObject:", v24);
  }

  v26 = v49;
  if (llvm::APFloatBase::PPCDoubleDouble(v27) == v26)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v40, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAAE8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSigmoidOpHandler *EmitterViewerSPI::ANECSigmoidOpHandler::ANECSigmoidOpHandler(EmitterViewerSPI::ANECSigmoidOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E037D0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 12 && *(_QWORD *)AttrData == 0x6769732E63656E61 && *(_DWORD *)(AttrData + 8) == 1684631405)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.sigmoid";
      v40[3] = 12;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sigmoid,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAB3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSignOpHandler *EmitterViewerSPI::ANECSignOpHandler::ANECSignOpHandler(EmitterViewerSPI::ANECSignOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E030C8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(_QWORD *)AttrData == 0x6769732E63656E61 && *(_BYTE *)(AttrData + 8) == 110)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.sign";
      v40[3] = 9;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sign,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAB8C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSinOpHandler *EmitterViewerSPI::ANECSinOpHandler::ANECSinOpHandler(EmitterViewerSPI::ANECSinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v35;
  mlir::Operation *v36;
  const char *v37;
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  void *__dst[2];
  int64_t v42;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02DB0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x6E69732E63656E61)
    {
      v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.sin";
      v39[3] = 8;
      v37 = "' failed due to the operation not being registered";
      v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sin,void>::id)
    goto LABEL_27;
  v36 = a3;
  v39[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v42 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v35, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EABDC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSoftmaxOpHandler *EmitterViewerSPI::ANECSoftmaxOpHandler::ANECSoftmaxOpHandler(EmitterViewerSPI::ANECSoftmaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  uint64_t AttrData;
  uint64_t v44;
  void *v46;
  mlir::Operation *v47;
  const char *v48;
  __int16 v49;
  uint64_t v50[4];
  __int16 v51;
  void *__dst[2];
  int64_t v53;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E037E8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v44 == 12 && *(_QWORD *)AttrData == 0x666F732E63656E61 && *(_DWORD *)(AttrData + 8) == 2019650932)
    {
      v51 = 1283;
      v50[0] = (uint64_t)"classof on '";
      v50[2] = (uint64_t)"anec.softmax";
      v50[3] = 12;
      v48 = "' failed due to the operation not being registered";
      v49 = 259;
      llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Softmax,void>::id)
    goto LABEL_44;
  v47 = a3;
  v50[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v53 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v47);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_35;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_35:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_35;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("axes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::anec::Softmax::getSubtractMax(&v47);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("subtractMax"), 2147483656, &unk_1E0E99E68);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v50, 1);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v23, "addObject:", v32);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v46, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  if (SHIBYTE(v53) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAC420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSpaceToBatchOpHandler *EmitterViewerSPI::ANECSpaceToBatchOpHandler::ANECSpaceToBatchOpHandler(EmitterViewerSPI::ANECSpaceToBatchOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  BOOL v43;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04058;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 19)
    {
      v43 = *AttrData == 0x6170732E63656E61 && AttrData[1] == 0x61625F6F745F6563;
      if (v43 && *(_QWORD *)((char *)AttrData + 11) == 0x68637461625F6F74)
      {
        v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.space_to_batch";
        v49[3] = 19;
        v47 = "' failed due to the operation not being registered";
        v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id)
    goto LABEL_45;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("factors"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EACA38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSpaceToChannelOpHandler *EmitterViewerSPI::ANECSpaceToChannelOpHandler::ANECSpaceToChannelOpHandler(EmitterViewerSPI::ANECSpaceToChannelOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  BOOL v43;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E043A0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 21)
    {
      v43 = *AttrData == 0x6170732E63656E61 && AttrData[1] == 0x68635F6F745F6563;
      if (v43 && *(_QWORD *)((char *)AttrData + 13) == 0x6C656E6E6168635FLL)
      {
        v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.space_to_channel";
        v49[3] = 21;
        v47 = "' failed due to the operation not being registered";
        v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id)
    goto LABEL_45;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("factors"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAD040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSqrOpHandler *EmitterViewerSPI::ANECSqrOpHandler::ANECSqrOpHandler(EmitterViewerSPI::ANECSqrOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v35;
  mlir::Operation *v36;
  const char *v37;
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  void *__dst[2];
  int64_t v42;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02DC8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x7271732E63656E61)
    {
      v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.sqr";
      v39[3] = 8;
      v37 = "' failed due to the operation not being registered";
      v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sqr,void>::id)
    goto LABEL_27;
  v36 = a3;
  v39[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v42 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v35, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAD550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSqrtOpHandler *EmitterViewerSPI::ANECSqrtOpHandler::ANECSqrtOpHandler(EmitterViewerSPI::ANECSqrtOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E030E0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(_QWORD *)AttrData == 0x7271732E63656E61 && *(_BYTE *)(AttrData + 8) == 116)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.sqrt";
      v40[3] = 9;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sqrt,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EADA5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSwishOpHandler *EmitterViewerSPI::ANECSwishOpHandler::ANECSwishOpHandler(EmitterViewerSPI::ANECSwishOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03338;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 10 && *(_QWORD *)AttrData == 0x6977732E63656E61 && *(_WORD *)(AttrData + 8) == 26739)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.swish";
      v40[3] = 10;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Swish,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EADF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECT0OpHandler *EmitterViewerSPI::ANECT0OpHandler::ANECT0OpHandler(EmitterViewerSPI::ANECT0OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  void *v15;
  const void *SymName;
  size_t v17;
  void *v18;
  unint64_t v19;
  uint64_t Results;
  unint64_t v21;
  uint64_t **v22;
  void *v23;
  void *v24;
  _QWORD *Body;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  void *v34;
  id v35;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v46;
  mlir::GenericProgramPoint *v47;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v49;
  void *v50;
  uint64_t AttrData;
  uint64_t v52;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  mlir::Operation *v58;
  const char *v59;
  __int16 v60;
  uint64_t v61[4];
  __int16 v62;
  void *__dst[2];
  int64_t v64;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02B88;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 10 && *(_QWORD *)AttrData == 0x3231412E63656E61 && *(_WORD *)(AttrData + 8) == 12402)
    {
      v62 = 1283;
      v61[0] = (uint64_t)"classof on '";
      v61[2] = (uint64_t)"anec.A12r0";
      v61[3] = 10;
      v59 = "' failed due to the operation not being registered";
      v60 = 259;
      llvm::operator+(v61, (uint64_t *)&v59, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_58:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::T0,void>::id)
    goto LABEL_58;
  v58 = a3;
  v61[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v61);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v64 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v64) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v64 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v58);
  EmitViewerSPI::emitStringProperty(CFSTR("sym_name"), SymName, v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v55, "addObject:", v18);
  v19 = 0;
  v61[0] = mlir::anec::A11Legacy::getFunctionType(&v58);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v61))
  {
    Results = mlir::FunctionType::getResults((mlir::FunctionType *)v61);
    if (v21 <= v19)
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    v22 = *(uint64_t ***)(Results + 8 * v19);
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("result%d"), v19);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    EmitViewerSPI::emitNodeOutputPort(v23, v22);
    v24 = (void *)objc_claimAutoreleasedReturnValue();

    if (v24)
      objc_msgSend(v15, "addObject:", v24);

    ++v19;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  v54 = (void *)v14;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v58);
  v26 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v27 = 0;
    do
    {
      v28 = Body[1];
      v29 = v28 - 8;
      if (!v28)
        v29 = 0;
      v30 = *(_QWORD *)(v29 + 48);
      v31 = *(_QWORD *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3))
        break;
      if (v27 >= v31 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v30 + 8 * v27)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("body_arg%d"), v27);
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        }
        v34 = (void *)objc_claimAutoreleasedReturnValue();

        if (v34)
          objc_msgSend(v57, "addObject:", v34);

        v26 = (_QWORD *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  v35 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v46 = i - 1;
    if (!i)
      v46 = 0;
    v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (j = (mlir::GenericProgramPoint *)v46[5]; j != v47; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v49);
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      if (v50)
        objc_msgSend(v35, "addObject:", v50);

    }
  }
  v37 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("body"), CFSTR("anec.region_return"), v35);
  objc_msgSend(v56, "addObject:", v37);

  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v57);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v54, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v64) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAE674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECTanhOpHandler *EmitterViewerSPI::ANECTanhOpHandler::ANECTanhOpHandler(EmitterViewerSPI::ANECTanhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E030F8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(_QWORD *)AttrData == 0x6E61742E63656E61 && *(_BYTE *)(AttrData + 8) == 104)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.tanh";
      v40[3] = 9;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Tanh,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAEBE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECTileOpHandler *EmitterViewerSPI::ANECTileOpHandler::ANECTileOpHandler(EmitterViewerSPI::ANECTileOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  uint64_t AttrData;
  uint64_t v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03110;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 9 && *(_QWORD *)AttrData == 0x6C69742E63656E61 && *(_BYTE *)(AttrData + 8) == 101)
    {
      v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.tile";
      v48[3] = 9;
      v46 = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Tile,void>::id)
    goto LABEL_42;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("data"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("multipliers"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v44, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAF1C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECTransposeOpHandler *EmitterViewerSPI::ANECTransposeOpHandler::ANECTransposeOpHandler(EmitterViewerSPI::ANECTransposeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Axes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  _QWORD *AttrData;
  uint64_t v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03B90;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 14 && *AttrData == 0x6172742E63656E61 && *(_QWORD *)((char *)AttrData + 6) == 0x65736F70736E6172)
    {
      v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.transpose";
      v48[3] = 14;
      v46 = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id)
    goto LABEL_42;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  v25 = Axes;
  if (!Axes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("transpose_list"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v44, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAF7B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECTruncOpHandler *EmitterViewerSPI::ANECTruncOpHandler::ANECTruncOpHandler(EmitterViewerSPI::ANECTruncOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t AttrData;
  uint64_t v34;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03350;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 10 && *(_QWORD *)AttrData == 0x7572742E63656E61 && *(_WORD *)(AttrData + 8) == 25454)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.trunc";
      v40[3] = 10;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Trunc,void>::id)
    goto LABEL_31;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EAFCD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECUnflattenOpHandler *EmitterViewerSPI::ANECUnflattenOpHandler::ANECUnflattenOpHandler(EmitterViewerSPI::ANECUnflattenOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t FlattenMode;
  void *v25;
  MPSGraphViewerNodePropertyEnumCaseSPI *v26;
  MPSGraphViewerNodePropertyEnumCaseSPI *v27;
  MPSGraphViewerNodePropertyEnumSPI *v28;
  uint64_t **DestinationSize;
  uint64_t **v30;
  uint64_t InterfaceFor;
  const char *v32;
  int v33;
  const char *v34;
  const char *v35;
  void *v36;
  void *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *AttrData;
  uint64_t v47;
  void *v49;
  mlir::Operation *v50;
  const char *v51;
  __int16 v52;
  uint64_t v53[4];
  __int16 v54;
  void *__dst[2];
  int64_t v56;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03BA8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v47 == 14 && *AttrData == 0x666E752E63656E61 && *(_QWORD *)((char *)AttrData + 6) == 0x6E657474616C666ELL)
    {
      v54 = 1283;
      v53[0] = (uint64_t)"classof on '";
      v53[2] = (uint64_t)"anec.unflatten";
      v53[3] = 14;
      v51 = "' failed due to the operation not being registered";
      v52 = 259;
      llvm::operator+(v53, (uint64_t *)&v51, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Unflatten,void>::id)
    goto LABEL_44;
  v50 = a3;
  v53[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v53);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v56 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v56) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v56 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v50);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v50);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  FlattenMode = mlir::anec::Unflatten::getFlattenMode(&v50);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 1);
  objc_msgSend(v25, "addObject:", v26);

  v27 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 2);
  objc_msgSend(v25, "addObject:", v27);

  v28 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("flatten_mode"), CFSTR("ANECFlattenMode"), v25, FlattenMode);
  if (v28)
    objc_msgSend(v23, "addObject:", v28);

  DestinationSize = (uint64_t **)mlir::anec::Unflatten::getDestinationSize((mlir::anec::Unflatten *)&v50);
  v30 = DestinationSize;
  if (!DestinationSize)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(DestinationSize))
  {
    v32 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v33 = 692;
    v34 = "Casting.h";
    v35 = "cast_if_present";
    goto LABEL_35;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v30))
  {
    v32 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v33 = 566;
    v34 = "Casting.h";
    v35 = "cast";
LABEL_35:
    __assert_rtn(v35, v34, v33, v32);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v30);
  if (!InterfaceFor)
  {
    v32 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v33 = 98;
    v34 = "InterfaceSupport.h";
    v35 = "Interface";
    goto LABEL_35;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("destination_size"), (uint64_t)v30, InterfaceFor);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  if (v36)
    objc_msgSend(v23, "addObject:", v36);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v37);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v49, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  if (SHIBYTE(v56) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB0370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler *EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler::ANECUnrealizedConversionCastOpHandler(EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  BOOL v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04A78;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 31)
    {
      v35 = *AttrData == 0x726E752E63656E61 && AttrData[1] == 0x5F64657A696C6165;
      v36 = v35 && AttrData[2] == 0x69737265766E6F63;
      if (v36 && *(_QWORD *)((char *)AttrData + 23) == 0x747361635F6E6F69)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.unrealized_conversion_cast";
        v42[3] = 31;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::UnrealizedConversionCast,void>::id)
    goto LABEL_37;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("output");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB08E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSACosOpHandler *EmitterViewerSPI::MPSACosOpHandler::MPSACosOpHandler(EmitterViewerSPI::MPSACosOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02DE0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x736F63612E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.acos";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ACosOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB0E14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSACoshOpHandler *EmitterViewerSPI::MPSACoshOpHandler::MPSACoshOpHandler(EmitterViewerSPI::MPSACoshOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03128;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x736F63612E73706DLL && *(_BYTE *)(AttrData + 8) == 104)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.acosh";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ACoshOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB135C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSASinOpHandler *EmitterViewerSPI::MPSASinOpHandler::MPSASinOpHandler(EmitterViewerSPI::MPSASinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02DF8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6E6973612E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.asin";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ASinOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB1898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSASinhOpHandler *EmitterViewerSPI::MPSASinhOpHandler::MPSASinhOpHandler(EmitterViewerSPI::MPSASinhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03140;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x6E6973612E73706DLL && *(_BYTE *)(AttrData + 8) == 104)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.asinh";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ASinhOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB1DE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSATan2OpHandler *EmitterViewerSPI::MPSATan2OpHandler::MPSATan2OpHandler(EmitterViewerSPI::MPSATan2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03158;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 9 && *(_QWORD *)AttrData == 0x6E6174612E73706DLL && *(_BYTE *)(AttrData + 8) == 50)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.atan2";
      v43[3] = 9;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ATan2Op,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB2360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSATanOpHandler *EmitterViewerSPI::MPSATanOpHandler::MPSATanOpHandler(EmitterViewerSPI::MPSATanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02E10;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6E6174612E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.atan";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ATanOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB28B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSATanhOpHandler *EmitterViewerSPI::MPSATanhOpHandler::MPSATanhOpHandler(EmitterViewerSPI::MPSATanhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03170;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x6E6174612E73706DLL && *(_BYTE *)(AttrData + 8) == 104)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.atanh";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ATanhOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB2DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAbsoluteOpHandler *EmitterViewerSPI::MPSAbsoluteOpHandler::MPSAbsoluteOpHandler(EmitterViewerSPI::MPSAbsoluteOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03800;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(_QWORD *)AttrData == 0x6F7362612E73706DLL && *(_DWORD *)(AttrData + 8) == 1702131052)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.absolute";
      v41[3] = 12;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB3348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAbsoluteSquareOpHandler *EmitterViewerSPI::MPSAbsoluteSquareOpHandler::MPSAbsoluteSquareOpHandler(EmitterViewerSPI::MPSAbsoluteSquareOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E041F0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 19)
    {
      v36 = *AttrData == 0x6F7362612E73706DLL && AttrData[1] == 0x7571735F6574756CLL;
      if (v36 && *(_QWORD *)((char *)AttrData + 11) == 0x6572617571735F65)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.absolute_square";
        v42[3] = 19;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteSquareOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Returns absolute square element-wise");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB38B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAddOpHandler *EmitterViewerSPI::MPSAddOpHandler::MPSAddOpHandler(EmitterViewerSPI::MPSAddOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _DWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02BA0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684300078)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.add";
      v43[3] = 7;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB3E2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAndOpHandler *EmitterViewerSPI::MPSAndOpHandler::MPSAndOpHandler(EmitterViewerSPI::MPSAndOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _DWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02BB8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684955438)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.and";
      v43[3] = 7;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AndOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB43C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAssignVariableOpHandler *EmitterViewerSPI::MPSAssignVariableOpHandler::MPSAssignVariableOpHandler(EmitterViewerSPI::MPSAssignVariableOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  MPSGraphViewerNodeSPI *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  _QWORD *AttrData;
  uint64_t v32;
  BOOL v33;
  void *v35;
  mlir::Operation *v36;
  const char *v37;
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  void *__dst[2];
  int64_t v42;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04208;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v32 == 19)
    {
      v33 = *AttrData == 0x697373612E73706DLL && AttrData[1] == 0x61697261765F6E67;
      if (v33 && *(_QWORD *)((char *)AttrData + 11) == 0x656C626169726176)
      {
        v40 = 1283;
        v39[0] = (uint64_t)"classof on '";
        v39[2] = (uint64_t)"mps.assign_variable";
        v39[3] = 19;
        v37 = "' failed due to the operation not being registered";
        v38 = 259;
        llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_32:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AssignVariableOp,void>::id)
    goto LABEL_32;
  v36 = a3;
  v39[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v42 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("resource"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v36);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v20);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v22, "initWithType:inputs:outputs:properties:regions:", v35, v23, v24, v25, v26);
  v28 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v27;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Inserts a variableHandle for a tensor resource.");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v29);

  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB48BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBandPartOpHandler *EmitterViewerSPI::MPSBandPartOpHandler::MPSBandPartOpHandler(EmitterViewerSPI::MPSBandPartOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03818;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 13 && *AttrData == 0x646E61622E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x747261705F646E61)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.band_part";
      v45[3] = 13;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BandPartOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("num_lower"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("num_upper"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Copy a tensor setting everything outside a central band in each innermost matrix to zero. For rank one and rank zero inputs this operation behaves as it would if the missing dimensions had extent of one. This means that for rank one the values after 'num_upper' are zeroed out and for rank zero the input is simply copied to the output. If num_lower or num_upper are negative, keep entire lower or upper triangle, respectively.");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB4E60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBatchToSpaceOpHandler *EmitterViewerSPI::MPSBatchToSpaceOpHandler::MPSBatchToSpaceOpHandler(EmitterViewerSPI::MPSBatchToSpaceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  uint64_t AttrData;
  uint64_t v43;
  BOOL v44;
  void *v46;
  mlir::Operation *v47;
  const char *v48;
  __int16 v49;
  uint64_t v50[4];
  __int16 v51;
  void *__dst[2];
  int64_t v53;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03E78;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 18)
    {
      v44 = *(_QWORD *)AttrData == 0x637461622E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6170735F6F745F68;
      if (v44 && *(_WORD *)(AttrData + 16) == 25955)
      {
        v51 = 1283;
        v50[0] = (uint64_t)"classof on '";
        v50[2] = (uint64_t)"mps.batch_to_space";
        v50[3] = 18;
        v48 = "' failed due to the operation not being registered";
        v49 = 259;
        llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BatchToSpaceOp,void>::id)
    goto LABEL_42;
  v47 = a3;
  v50[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v53 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("spatial_axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("batch_axis"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("block_dimensions"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v47);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("pixel_shuffle"), 2147483656, &unk_1E0E99E80);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v50, 1);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v29, "addObject:", v30);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v46, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v40);

  if (SHIBYTE(v53) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB5510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBiasAddGradOpHandler *EmitterViewerSPI::MPSBiasAddGradOpHandler::MPSBiasAddGradOpHandler(EmitterViewerSPI::MPSBiasAddGradOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  unsigned int StorageType;
  void *v25;
  MPSGraphViewerNodePropertyEnumCaseSPI *v26;
  MPSGraphViewerNodePropertyEnumCaseSPI *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumSPI *v37;
  void *v38;
  MPSGraphViewerNodeSPI *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  uint64_t AttrData;
  uint64_t v48;
  BOOL v49;
  void *v51;
  mlir::Operation *v52;
  const char *v53;
  __int16 v54;
  uint64_t v55[4];
  __int16 v56;
  void *__dst[2];
  int64_t v58;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03D40;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v48 == 17)
    {
      v49 = *(_QWORD *)AttrData == 0x736169622E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6172675F6464615FLL;
      if (v49 && *(_BYTE *)(AttrData + 16) == 100)
      {
        v56 = 1283;
        v55[0] = (uint64_t)"classof on '";
        v55[2] = (uint64_t)"mps.bias_add_grad";
        v55[3] = 17;
        v53 = "' failed due to the operation not being registered";
        v54 = 259;
        llvm::operator+(v55, (uint64_t *)&v53, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BiasAddGradOp,void>::id)
    goto LABEL_36;
  v52 = a3;
  v55[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v55);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v58 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v58) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v58 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v52);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("out_backprop"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v52);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v52);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v25, "addObject:", v26);

  v27 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v25, "addObject:", v27);

  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v25, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v25, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v25, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v25, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v25, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v25, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v25, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v25, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v25, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_format"), CFSTR("MPSTensorDataLayout"), v25, StorageType);
  if (v37)
    objc_msgSend(v23, "addObject:", v37);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v38);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  v44 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v39, "initWithType:inputs:outputs:properties:regions:", v51, v40, v41, v42, v43);
  v45 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v44;

  if (SHIBYTE(v58) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB5CF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBiasAddOpHandler *EmitterViewerSPI::MPSBiasAddOpHandler::MPSBiasAddOpHandler(EmitterViewerSPI::MPSBiasAddOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  unsigned int StorageType;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumSPI *v39;
  void *v40;
  MPSGraphViewerNodeSPI *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  void *v48;
  uint64_t AttrData;
  uint64_t v51;
  void *v53;
  mlir::Operation *v54;
  const char *v55;
  __int16 v56;
  uint64_t v57[4];
  __int16 v58;
  void *__dst[2];
  int64_t v60;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03548;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v51 == 12 && *(_QWORD *)AttrData == 0x736169622E73706DLL && *(_DWORD *)(AttrData + 8) == 1684300127)
    {
      v58 = 1283;
      v57[0] = (uint64_t)"classof on '";
      v57[2] = (uint64_t)"mps.bias_add";
      v57[3] = 12;
      v55 = "' failed due to the operation not being registered";
      v56 = 259;
      llvm::operator+(v57, (uint64_t *)&v55, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id)
    goto LABEL_35;
  v54 = a3;
  v57[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v57);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v60 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v60) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v60 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("value"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("bias"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v54);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v27, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v27, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v27, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v27, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v27, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v27, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v27, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v27, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v27, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v27, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_format"), CFSTR("MPSTensorDataLayout"), v27, StorageType);
  if (v39)
    objc_msgSend(v25, "addObject:", v39);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v40);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v41, "initWithType:inputs:outputs:properties:regions:", v53, v42, v43, v44, v45);
  v47 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v46;

  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v48);

  if (SHIBYTE(v60) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB6500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseAndOpHandler *EmitterViewerSPI::MPSBitwiseAndOpHandler::MPSBitwiseAndOpHandler(EmitterViewerSPI::MPSBitwiseAndOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03BC0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 15 && *AttrData == 0x777469622E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x646E615F65736977)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.bitwise_and";
      v43[3] = 15;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseAndOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB6AEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler *EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler::MPSBitwiseLeftShiftOpHandler(EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04568;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 22)
    {
      v38 = *AttrData == 0x777469622E73706DLL && AttrData[1] == 0x7466656C5F657369;
      if (v38 && *(_QWORD *)((char *)AttrData + 14) == 0x74666968735F7466)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"mps.bitwise_left_shift";
        v44[3] = 22;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseLeftShiftOp,void>::id)
    goto LABEL_36;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v40, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB70A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseNotOpHandler *EmitterViewerSPI::MPSBitwiseNotOpHandler::MPSBitwiseNotOpHandler(EmitterViewerSPI::MPSBitwiseNotOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03BD8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 15 && *AttrData == 0x777469622E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x746F6E5F65736977)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.bitwise_not";
      v41[3] = 15;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseNotOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB7610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseOrOpHandler *EmitterViewerSPI::MPSBitwiseOrOpHandler::MPSBitwiseOrOpHandler(EmitterViewerSPI::MPSBitwiseOrOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E039E0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 14 && *AttrData == 0x777469622E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x726F5F6573697774)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.bitwise_or";
      v43[3] = 14;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseOrOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB7B9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwisePopcountOpHandler *EmitterViewerSPI::MPSBitwisePopcountOpHandler::MPSBitwisePopcountOpHandler(EmitterViewerSPI::MPSBitwisePopcountOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E043B8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      v36 = *(_QWORD *)AttrData == 0x777469622E73706DLL && *(_QWORD *)(AttrData + 8) == 0x63706F705F657369;
      if (v36 && *(_DWORD *)(AttrData + 16) == 1953396079)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.bitwise_popcount";
        v42[3] = 20;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwisePopcountOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Returns number of ON bits element-wise");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB8114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseRightShiftOpHandler *EmitterViewerSPI::MPSBitwiseRightShiftOpHandler::MPSBitwiseRightShiftOpHandler(EmitterViewerSPI::MPSBitwiseRightShiftOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04640;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 23)
    {
      v38 = *AttrData == 0x777469622E73706DLL && AttrData[1] == 0x686769725F657369;
      if (v38 && *(_QWORD *)((char *)AttrData + 15) == 0x74666968735F7468)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"mps.bitwise_right_shift";
        v44[3] = 23;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseRightShiftOp,void>::id)
    goto LABEL_36;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v40, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB86B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseXorOpHandler *EmitterViewerSPI::MPSBitwiseXorOpHandler::MPSBitwiseXorOpHandler(EmitterViewerSPI::MPSBitwiseXorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03BF0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 15 && *AttrData == 0x777469622E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x726F785F65736977)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.bitwise_xor";
      v43[3] = 15;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseXorOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB8C58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler *EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler::MPSBroadcastGradientArgsOpHandler(EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  BOOL v38;
  BOOL v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04928;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 27)
    {
      v38 = *AttrData == 0x616F72622E73706DLL && AttrData[1] == 0x72675F7473616364;
      v39 = v38 && AttrData[2] == 0x615F746E65696461;
      if (v39 && *(_QWORD *)((char *)AttrData + 19) == 0x736772615F746E65)
      {
        v46 = 1283;
        v45[0] = (uint64_t)"classof on '";
        v45[2] = (uint64_t)"mps.broadcast_gradient_args";
        v45[3] = 27;
        v43 = "' failed due to the operation not being registered";
        v44 = 259;
        llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BroadcastGradientArgsOp,void>::id)
    goto LABEL_39;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input0"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input1"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v21 = CFSTR("reductionAxes");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("reductionAxes"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v41, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "This is typically used by gradient computations for a broadcasting operation.");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB9228(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBroadcastToOpHandler *EmitterViewerSPI::MPSBroadcastToOpHandler::MPSBroadcastToOpHandler(EmitterViewerSPI::MPSBroadcastToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03D58;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 16 && *AttrData == 0x616F72622E73706DLL && AttrData[1] == 0x6F745F7473616364)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.broadcast_to";
      v43[3] = 16;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Broadcast will transform the input shape to be the one specified. Note that the input shape and the desired shape need to be broadcast compatible. Two shapes are broadcast compatible if, for each dimension pair, they are either equal or one of them is one.");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB97C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCallOpHandler *EmitterViewerSPI::MPSCallOpHandler::MPSCallOpHandler(EmitterViewerSPI::MPSCallOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  uint64_t Inputs;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  void *v20;
  void *v21;
  uint64_t Results;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unsigned int v27;
  MPSGraphViewerNodePortSPI *v28;
  uint64_t NextResultAtOffset;
  id v30;
  void *v31;
  uint64_t MPSDataType;
  void *v33;
  void *v34;
  const void *Name;
  size_t v36;
  void *v37;
  unsigned int StorageType;
  void *v39;
  MPSGraphViewerNodePropertyEnumCaseSPI *v40;
  MPSGraphViewerNodePropertyEnumCaseSPI *v41;
  MPSGraphViewerNodePropertyEnumCaseSPI *v42;
  MPSGraphViewerNodePropertyEnumSPI *v43;
  void *v44;
  MPSGraphViewerNodeSPI *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  void *v52;
  _QWORD *AttrData;
  uint64_t v55;
  void *v56;
  void *v58;
  void *v59;
  mlir::Operation *v60;
  const char *v61;
  __int16 v62;
  uint64_t v63[4];
  __int16 v64;
  void *__dst[2];
  int64_t v66;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02E28;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v55 == 8 && *AttrData == 0x6C6C61632E73706DLL)
    {
      v64 = 1283;
      v63[0] = (uint64_t)"classof on '";
      v63[2] = (uint64_t)"mps.call";
      v63[3] = 8;
      v61 = "' failed due to the operation not being registered";
      v62 = 259;
      llvm::operator+(v63, (uint64_t *)&v61, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::CallOp,void>::id)
    goto LABEL_38;
  v60 = a3;
  v63[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v66 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v66) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v66 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  Inputs = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v60);
  v15 = v14;
  if (v14)
  {
    v16 = Inputs;
    v17 = 0;
    v18 = 1;
    do
    {
      v19 = *(_QWORD *)(v16 + 32 * v17 + 24);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("inputs%d"), v18 - 1);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v20, v19);
      v21 = (void *)objc_claimAutoreleasedReturnValue();

      if (v21)
        objc_msgSend(v59, "addObject:", v21);

      v17 = v18++;
    }
    while (v15 > v17);
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  Results = mlir::pdl::ApplyNativeRewriteOp::getResults((mlir::pdl::ApplyNativeRewriteOp *)&v60);
  v24 = v23;
  if (v23)
  {
    v25 = Results;
    v26 = 0;
    v27 = 1;
    do
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v25, v26);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("outputs%d"), v27 - 1);
      v30 = (id)objc_claimAutoreleasedReturnValue();
      v31 = v30;
      if (NextResultAtOffset)
      {
        MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", v31, MPSDataType, v33, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, NextResultAtOffset));

        if (v28)
          objc_msgSend(v58, "addObject:", v28);
      }
      else
      {
        v28 = 0;

      }
      v26 = v27++;
    }
    while (v24 > v26);
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  Name = (const void *)mlir::pdl::ApplyNativeConstraintOp::getName((mlir::pdl::ApplyNativeConstraintOp *)&v60);
  EmitViewerSPI::emitStringProperty(CFSTR("symbolName"), Name, v36);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  if (v37)
    objc_msgSend(v34, "addObject:", v37);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v60);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("off"), 0);
  objc_msgSend(v39, "addObject:", v40);

  v41 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("on"), 1);
  objc_msgSend(v39, "addObject:", v41);

  v42 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("automatic"), 2);
  objc_msgSend(v39, "addObject:", v42);

  v43 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("inlineMode"), CFSTR("MPSCallInlineMode"), v39, StorageType);
  if (v43)
    objc_msgSend(v34, "addObject:", v43);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v45 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v59);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v58);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v44);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v45, "initWithType:inputs:outputs:properties:regions:", v56, v46, v47, v48, v49);
  v51 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v50;

  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v52);

  if (SHIBYTE(v66) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EB9F08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCastOpHandler *EmitterViewerSPI::MPSCastOpHandler::MPSCastOpHandler(EmitterViewerSPI::MPSCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02E40;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x747361632E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.cast";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v37);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Returns a tensor with the same shape and set resultElementType.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBA4C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCeilOpHandler *EmitterViewerSPI::MPSCeilOpHandler::MPSCeilOpHandler(EmitterViewerSPI::MPSCeilOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02E58;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6C6965632E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.ceil";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CeilOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBAA04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSClampOpHandler *EmitterViewerSPI::MPSClampOpHandler::MPSClampOpHandler(EmitterViewerSPI::MPSClampOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03188;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 9 && *(_QWORD *)AttrData == 0x6D616C632E73706DLL && *(_BYTE *)(AttrData + 8) == 112)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.clamp";
      v45[3] = 9;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ClampOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("primary"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("secondary"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("tertiary"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBAFBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSColToImOpHandler *EmitterViewerSPI::MPSColToImOpHandler::MPSColToImOpHandler(EmitterViewerSPI::MPSColToImOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  MPSGraphViewerNodePortSPI *v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  void *v22;
  uint64_t **KernelSizes;
  uint64_t **v24;
  uint64_t InterfaceFor;
  const char *v26;
  int v27;
  const char *v28;
  const char *v29;
  void *v30;
  uint64_t **Strides;
  uint64_t **v32;
  uint64_t v33;
  const char *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  uint64_t **InputAttributeNames;
  uint64_t **v40;
  uint64_t v41;
  const char *v42;
  int v43;
  const char *v44;
  const char *v45;
  void *v46;
  uint64_t **Rewriter;
  uint64_t **v48;
  uint64_t v49;
  const char *v50;
  int v51;
  const char *v52;
  const char *v53;
  void *v54;
  unsigned int StorageType;
  void *v56;
  MPSGraphViewerNodePropertyEnumCaseSPI *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumSPI *v68;
  void *v69;
  MPSGraphViewerNodeSPI *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  uint64_t v75;
  void *v76;
  void *v77;
  _QWORD *AttrData;
  uint64_t v80;
  void *v82;
  void *v83;
  void *v84;
  mlir::Operation *v85;
  const char *v86;
  __int16 v87;
  uint64_t v88[4];
  __int16 v89;
  void *__dst[2];
  int64_t v91;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03560;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v80 == 13 && *AttrData == 0x5F6C6F632E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x6D695F6F745F6C6FLL)
    {
      v89 = 1283;
      v88[0] = (uint64_t)"classof on '";
      v88[2] = (uint64_t)"mps.col_to_im";
      v88[3] = 13;
      v86 = "' failed due to the operation not being registered";
      v87 = 259;
      llvm::operator+(v88, (uint64_t *)&v86, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_79:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ColToImOp,void>::id)
    goto LABEL_79;
  v85 = a3;
  v88[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v88);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v91 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v91) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v91 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v85);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v84, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v85);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v84, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v85);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v18->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v18->_dataType & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v18 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v18)
      objc_msgSend(v83, "addObject:", v18);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  KernelSizes = (uint64_t **)mlir::mps::ColToImOp::getKernelSizes((mlir::mps::ColToImOp *)&v85);
  v24 = KernelSizes;
  if (!KernelSizes)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelSizes))
  {
    v26 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v27 = 692;
    v28 = "Casting.h";
    v29 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24))
  {
    v26 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v27 = 566;
    v28 = "Casting.h";
    v29 = "cast";
LABEL_61:
    __assert_rtn(v29, v28, v27, v26);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24);
  if (!InterfaceFor)
  {
    v26 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v27 = 98;
    v28 = "InterfaceSupport.h";
    v29 = "Interface";
    goto LABEL_61;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_sizes"), (uint64_t)v24, InterfaceFor);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  if (v30)
    objc_msgSend(v22, "addObject:", v30);
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v85);
  v32 = Strides;
  if (!Strides)
  {
    v33 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v35 = 692;
    v36 = "Casting.h";
    v37 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v35 = 566;
    v36 = "Casting.h";
    v37 = "cast";
LABEL_64:
    __assert_rtn(v37, v36, v35, v34);
  }
  v33 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!v33)
  {
    v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v35 = 98;
    v36 = "InterfaceSupport.h";
    v37 = "Interface";
    goto LABEL_64;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v32, v33);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  if (v38)
    objc_msgSend(v22, "addObject:", v38);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v85);
  v40 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v41 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v43 = 692;
    v44 = "Casting.h";
    v45 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v43 = 566;
    v44 = "Casting.h";
    v45 = "cast";
LABEL_67:
    __assert_rtn(v45, v44, v43, v42);
  }
  v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v43 = 98;
    v44 = "InterfaceSupport.h";
    v45 = "Interface";
    goto LABEL_67;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v40, v41);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  if (v46)
    objc_msgSend(v22, "addObject:", v46);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v85);
  v48 = Rewriter;
  if (!Rewriter)
  {
    v49 = 0;
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v50 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v51 = 692;
    v52 = "Casting.h";
    v53 = "cast_if_present";
    goto LABEL_70;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v48))
  {
    v50 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v51 = 566;
    v52 = "Casting.h";
    v53 = "cast";
LABEL_70:
    __assert_rtn(v53, v52, v51, v50);
  }
  v49 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v48);
  if (!v49)
  {
    v50 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v51 = 98;
    v52 = "InterfaceSupport.h";
    v53 = "Interface";
    goto LABEL_70;
  }
LABEL_52:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v48, v49);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  if (v54)
    objc_msgSend(v22, "addObject:", v54);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v85);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  v57 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v56, "addObject:", v57);

  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v56, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v56, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v56, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v56, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v56, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v56, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v56, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v56, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v56, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v56, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v56, StorageType);
  if (v68)
    objc_msgSend(v22, "addObject:", v68);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  v70 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v84);
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v83);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v22);
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v69);
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  v75 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v70, "initWithType:inputs:outputs:properties:regions:", v82, v71, v72, v73, v74);
  v76 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v75;

  v77 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v77);

  if (SHIBYTE(v91) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBBB04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConcatOpHandler *EmitterViewerSPI::MPSConcatOpHandler::MPSConcatOpHandler(EmitterViewerSPI::MPSConcatOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void *v13;
  uint64_t Values;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int v19;
  unint64_t v20;
  void *v21;
  void *v22;
  unint64_t Axis;
  void *v24;
  void *v25;
  uint64_t v26;
  __CFString *v27;
  uint64_t MPSDataType;
  void *v29;
  MPSGraphViewerNodePortSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  uint64_t AttrData;
  uint64_t v45;
  void *v47;
  mlir::Operation *v49;
  const char *v50;
  __int16 v51;
  uint64_t v52[4];
  __int16 v53;
  void *__dst[2];
  int64_t v55;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03380;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 10 && *(_QWORD *)AttrData == 0x636E6F632E73706DLL && *(_WORD *)(AttrData + 8) == 29793)
    {
      v53 = 1283;
      v52[0] = (uint64_t)"classof on '";
      v52[2] = (uint64_t)"mps.concat";
      v52[3] = 10;
      v50 = "' failed due to the operation not being registered";
      v51 = 259;
      llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id)
    goto LABEL_38;
  v49 = a3;
  v52[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v55 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v55) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v55 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  Values = mlir::mps::ConcatOp::getValues((mlir::mps::ConcatOp *)&v49);
  v16 = v15;
  if (v15)
  {
    v17 = Values;
    v18 = 0;
    v19 = 1;
    do
    {
      v20 = *(_QWORD *)(v17 + 32 * v18 + 24);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("values%d"), v19 - 1);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v21, v20);
      v22 = (void *)objc_claimAutoreleasedReturnValue();

      if (v22)
        objc_msgSend(v13, "addObject:", v22);

      v18 = v19++;
    }
    while (v16 > v18);
  }
  Axis = mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Axis);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v24)
    objc_msgSend(v13, "addObject:", v24);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  v27 = CFSTR("result");
  if (v26)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v30 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v29, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v26));

    if (v30)
      objc_msgSend(v25, "addObject:", v30);
  }
  else
  {

    v30 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v52[0]) = 0;
  LOBYTE(v52[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v49);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("interleave"), 2147483656, &unk_1E0E99E98);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v52, 1);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v31, "addObject:", v32);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v13);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v47, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v42);

  if (SHIBYTE(v55) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBC220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  void *v29;
  void *v30;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConjugateOpHandler *EmitterViewerSPI::MPSConjugateOpHandler::MPSConjugateOpHandler(EmitterViewerSPI::MPSConjugateOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E039F8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x6A6E6F632E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x65746167756A6E6FLL)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.conjugate";
      v41[3] = 13;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ConjugateOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Calculates the complex complex conjugate of a tensor. For non-complex type tensors this is equivelent to an identity operation.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBC7B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConstantOpHandler *EmitterViewerSPI::MPSConstantOpHandler::MPSConstantOpHandler(EmitterViewerSPI::MPSConstantOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  void *v15;
  uint64_t v16;
  __CFString *v17;
  uint64_t MPSDataType;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  void *v21;
  _QWORD *Value;
  uint64_t v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  void *v33;
  uint64_t AttrData;
  uint64_t v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03830;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v36 == 12 && *(_QWORD *)AttrData == 0x736E6F632E73706DLL && *(_DWORD *)(AttrData + 8) == 1953390964)
    {
      v43 = 1283;
      v42[0] = (uint64_t)"classof on '";
      v42[2] = (uint64_t)"mps.constant";
      v42[3] = 12;
      v40 = "' failed due to the operation not being registered";
      v41 = 259;
      llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    goto LABEL_33;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v17 = CFSTR("result");
  if (v16)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v19, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v16));

    if (v20)
      objc_msgSend(v15, "addObject:", v20);
  }
  else
  {

    v20 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  if (*((_BYTE *)v39 + 47))
  {
    Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v39);
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("value"), (uint64_t)Value, v23);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    if (v24)
      objc_msgSend(v21, "addObject:", v24);

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v38, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Turn a literal into an SSA value. The data is attached to the operation as an attribute.");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v33);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBCD18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv2DDataGradientOpHandler *EmitterViewerSPI::MPSConv2DDataGradientOpHandler::MPSConv2DDataGradientOpHandler(EmitterViewerSPI::MPSConv2DDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t SplitSizes;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  uint64_t **Strides;
  uint64_t **v27;
  uint64_t InterfaceFor;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t **InputAttributeNames;
  uint64_t **v34;
  uint64_t v35;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *v40;
  uint64_t **Rewriter;
  uint64_t **v42;
  uint64_t v43;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  void *v48;
  unsigned int PaddingStyle;
  void *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumSPI *v56;
  unsigned int StorageType;
  void *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumSPI *v70;
  unsigned int WeightsLayout;
  void *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumSPI *v84;
  void *v85;
  MPSGraphViewerNodeSPI *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  uint64_t v91;
  void *v92;
  void *v93;
  uint64_t AttrData;
  uint64_t v96;
  BOOL v97;
  BOOL v98;
  void *v100;
  MPSGraphViewerNodePropertyDataSPI *v101;
  void *v102;
  void *v103;
  void *v104;
  mlir::Operation *v105;
  const char *v106;
  __int16 v107;
  uint64_t v108[4];
  __int16 v109;
  void *__dst[2];
  int64_t v111;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04718;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 25)
    {
      v97 = *(_QWORD *)AttrData == 0x766E6F632E73706DLL && *(_QWORD *)(AttrData + 8) == 0x617461645F64325FLL;
      v98 = v97 && *(_QWORD *)(AttrData + 16) == 0x6E6569646172675FLL;
      if (v98 && *(_BYTE *)(AttrData + 24) == 116)
      {
        v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.conv_2d_data_gradient";
        v108[3] = 25;
        v106 = "' failed due to the operation not being registered";
        v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_82:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id)
    goto LABEL_82;
  v105 = a3;
  v108[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v111 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v102 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v104, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v104, "addObject:", v17);
  SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("outputShape"), SplitSizes);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v104, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v103, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v108[0] = 0;
  v108[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v105);
  v101 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("groups"), 64, &unk_1E0E99EB0);
  if (v101)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v108, 8);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v101, "setValue:", v25);

    objc_msgSend(v24, "addObject:", v101);
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v105);
  v27 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v30 = 692;
    v31 = "Casting.h";
    v32 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v30 = 566;
    v31 = "Casting.h";
    v32 = "cast";
LABEL_61:
    __assert_rtn(v32, v31, v30, v29);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v30 = 98;
    v31 = "InterfaceSupport.h";
    v32 = "Interface";
    goto LABEL_61;
  }
LABEL_32:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v27, InterfaceFor);
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  if (v100)
    objc_msgSend(v24, "addObject:", v100);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  v34 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v35 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v37 = 692;
    v38 = "Casting.h";
    v39 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v37 = 566;
    v38 = "Casting.h";
    v39 = "cast";
LABEL_64:
    __assert_rtn(v39, v38, v37, v36);
  }
  v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v37 = 98;
    v38 = "InterfaceSupport.h";
    v39 = "Interface";
    goto LABEL_64;
  }
LABEL_40:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v34, v35);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  if (v40)
    objc_msgSend(v24, "addObject:", v40);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  v42 = Rewriter;
  if (!Rewriter)
  {
    v43 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v45 = 692;
    v46 = "Casting.h";
    v47 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v45 = 566;
    v46 = "Casting.h";
    v47 = "cast";
LABEL_67:
    __assert_rtn(v47, v46, v45, v44);
  }
  v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v45 = 98;
    v46 = "InterfaceSupport.h";
    v47 = "Interface";
    goto LABEL_67;
  }
LABEL_48:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v42, v43);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  if (v48)
    objc_msgSend(v24, "addObject:", v48);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v50, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v50, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v50, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v50, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v50, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v50, PaddingStyle);
  if (v56)
    objc_msgSend(v24, "addObject:", v56);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v58, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v58, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v58, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v58, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v58, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v58, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v58, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v58, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v58, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v58, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v58, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v58, StorageType);
  if (v70)
    objc_msgSend(v24, "addObject:", v70);

  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v72, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v72, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v72, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v72, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v72, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v72, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v72, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v72, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v72, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v72, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v72, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v72, WeightsLayout);
  if (v84)
    objc_msgSend(v24, "addObject:", v84);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  v86 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v104);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v103);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v85);
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  v91 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v86, "initWithType:inputs:outputs:properties:regions:", v102, v87, v88, v89, v90);
  v92 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v91;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "conv2DDataGradient operation");
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v93);

  if (SHIBYTE(v111) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBDBA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  uint64_t v15;
  void *v16;
  uint64_t v17;

  if (*(char *)(v17 - 105) < 0)
    operator delete(*(void **)(v17 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv2DOpHandler *EmitterViewerSPI::MPSConv2DOpHandler::MPSConv2DOpHandler(EmitterViewerSPI::MPSConv2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  uint64_t **Strides;
  uint64_t **v26;
  uint64_t InterfaceFor;
  const char *v28;
  int v29;
  const char *v30;
  const char *v31;
  uint64_t **InputAttributeNames;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **Rewriter;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  unsigned int PaddingStyle;
  void *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumSPI *v55;
  unsigned int StorageType;
  void *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumSPI *v69;
  unsigned int WeightsLayout;
  void *v71;
  MPSGraphViewerNodePropertyEnumCaseSPI *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumSPI *v83;
  void *v84;
  MPSGraphViewerNodeSPI *v85;
  void *v86;
  void *v87;
  void *v88;
  void *v89;
  uint64_t v90;
  void *v91;
  void *v92;
  _QWORD *AttrData;
  uint64_t v95;
  void *v97;
  MPSGraphViewerNodePropertyDataSPI *v98;
  void *v99;
  void *v100;
  void *v101;
  mlir::Operation *v102;
  const char *v103;
  __int16 v104;
  uint64_t v105[4];
  __int16 v106;
  void *__dst[2];
  int64_t v108;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03398;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v95 == 11 && *AttrData == 0x766E6F632E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x64325F766E6F632ELL)
    {
      v106 = 1283;
      v105[0] = (uint64_t)"classof on '";
      v105[2] = (uint64_t)"mps.conv_2d";
      v105[3] = 11;
      v103 = "' failed due to the operation not being registered";
      v104 = 259;
      llvm::operator+(v105, (uint64_t *)&v103, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_74:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    goto LABEL_74;
  v102 = a3;
  v105[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v105);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v108 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v108) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v108 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v99 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v102);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v101, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v102);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v101, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v102);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v100, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v105[0] = 0;
  v105[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v102);
  v98 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("groups"), 64, &unk_1E0E99EC8);
  if (v98)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v105, 8);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v98, "setValue:", v24);

    objc_msgSend(v23, "addObject:", v98);
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v102);
  v26 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v28 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v29 = 692;
    v30 = "Casting.h";
    v31 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26))
  {
    v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v29 = 566;
    v30 = "Casting.h";
    v31 = "cast";
LABEL_59:
    __assert_rtn(v31, v30, v29, v28);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26);
  if (!InterfaceFor)
  {
    v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v29 = 98;
    v30 = "InterfaceSupport.h";
    v31 = "Interface";
    goto LABEL_59;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v26, InterfaceFor);
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  if (v97)
    objc_msgSend(v23, "addObject:", v97);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v102);
  v33 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v34 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_62:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_62;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v102);
  v41 = Rewriter;
  if (!Rewriter)
  {
    v42 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_65:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_65;
  }
LABEL_46:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v102);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v49, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v49, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v49, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v49, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v49, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v49, PaddingStyle);
  if (v55)
    objc_msgSend(v23, "addObject:", v55);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v102);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v57, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v57, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v57, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v57, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v57, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v57, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v57, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v57, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v57, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v57, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v57, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v57, StorageType);
  if (v69)
    objc_msgSend(v23, "addObject:", v69);

  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v102);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  v72 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v71, "addObject:", v72);

  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v71, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v71, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v71, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v71, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v71, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v71, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v71, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v71, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v71, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v71, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v71, WeightsLayout);
  if (v83)
    objc_msgSend(v23, "addObject:", v83);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  v85 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v101);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v100);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v84);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  v90 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v85, "initWithType:inputs:outputs:properties:regions:", v99, v86, v87, v88, v89);
  v91 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v90;

  v92 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v92);

  if (SHIBYTE(v108) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBEB90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler *EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler::MPSConv2DWeightsGradientOpHandler(EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t Bias;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  uint64_t **Strides;
  uint64_t **v27;
  uint64_t InterfaceFor;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t **InputAttributeNames;
  uint64_t **v34;
  uint64_t v35;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *v40;
  uint64_t **Rewriter;
  uint64_t **v42;
  uint64_t v43;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  void *v48;
  unsigned int PaddingStyle;
  void *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumSPI *v56;
  unsigned int StorageType;
  void *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumSPI *v70;
  unsigned int WeightsLayout;
  void *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumSPI *v84;
  void *v85;
  MPSGraphViewerNodeSPI *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  uint64_t v91;
  void *v92;
  void *v93;
  uint64_t AttrData;
  uint64_t v96;
  BOOL v97;
  BOOL v98;
  void *v100;
  MPSGraphViewerNodePropertyDataSPI *v101;
  void *v102;
  void *v103;
  void *v104;
  mlir::Operation *v105;
  const char *v106;
  __int16 v107;
  uint64_t v108[4];
  __int16 v109;
  void *__dst[2];
  int64_t v111;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04940;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 28)
    {
      v97 = *(_QWORD *)AttrData == 0x766E6F632E73706DLL && *(_QWORD *)(AttrData + 8) == 0x676965775F64325FLL;
      v98 = v97 && *(_QWORD *)(AttrData + 16) == 0x646172675F737468;
      if (v98 && *(_DWORD *)(AttrData + 24) == 1953391977)
      {
        v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.conv_2d_weights_gradient";
        v108[3] = 28;
        v106 = "' failed due to the operation not being registered";
        v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_82:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DWeightsGradientOp,void>::id)
    goto LABEL_82;
  v105 = a3;
  v108[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v111 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v102 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v104, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v104, "addObject:", v17);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("outputShape"), Bias);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v104, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v103, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v108[0] = 0;
  v108[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v105);
  v101 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("groups"), 64, &unk_1E0E99EE0);
  if (v101)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v108, 8);
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v101, "setValue:", v25);

    objc_msgSend(v24, "addObject:", v101);
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v105);
  v27 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v30 = 692;
    v31 = "Casting.h";
    v32 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v30 = 566;
    v31 = "Casting.h";
    v32 = "cast";
LABEL_61:
    __assert_rtn(v32, v31, v30, v29);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v30 = 98;
    v31 = "InterfaceSupport.h";
    v32 = "Interface";
    goto LABEL_61;
  }
LABEL_32:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v27, InterfaceFor);
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  if (v100)
    objc_msgSend(v24, "addObject:", v100);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  v34 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v35 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v37 = 692;
    v38 = "Casting.h";
    v39 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v37 = 566;
    v38 = "Casting.h";
    v39 = "cast";
LABEL_64:
    __assert_rtn(v39, v38, v37, v36);
  }
  v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v37 = 98;
    v38 = "InterfaceSupport.h";
    v39 = "Interface";
    goto LABEL_64;
  }
LABEL_40:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v34, v35);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  if (v40)
    objc_msgSend(v24, "addObject:", v40);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  v42 = Rewriter;
  if (!Rewriter)
  {
    v43 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v45 = 692;
    v46 = "Casting.h";
    v47 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v45 = 566;
    v46 = "Casting.h";
    v47 = "cast";
LABEL_67:
    __assert_rtn(v47, v46, v45, v44);
  }
  v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v45 = 98;
    v46 = "InterfaceSupport.h";
    v47 = "Interface";
    goto LABEL_67;
  }
LABEL_48:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v42, v43);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  if (v48)
    objc_msgSend(v24, "addObject:", v48);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v50, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v50, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v50, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v50, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v50, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v50, PaddingStyle);
  if (v56)
    objc_msgSend(v24, "addObject:", v56);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v58, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v58, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v58, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v58, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v58, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v58, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v58, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v58, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v58, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v58, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v58, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v58, StorageType);
  if (v70)
    objc_msgSend(v24, "addObject:", v70);

  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v72, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v72, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v72, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v72, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v72, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v72, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v72, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v72, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v72, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v72, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v72, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v72, WeightsLayout);
  if (v84)
    objc_msgSend(v24, "addObject:", v84);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  v86 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v104);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v103);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v85);
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  v91 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v86, "initWithType:inputs:outputs:properties:regions:", v102, v87, v88, v89, v90);
  v92 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v91;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "conv2DDataGradient operation");
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v93);

  if (SHIBYTE(v111) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EBFBA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  uint64_t v15;
  void *v16;
  uint64_t v17;

  if (*(char *)(v17 - 105) < 0)
    operator delete(*(void **)(v17 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv3DDataGradientOpHandler *EmitterViewerSPI::MPSConv3DDataGradientOpHandler::MPSConv3DDataGradientOpHandler(EmitterViewerSPI::MPSConv3DDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t SplitSizes;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  uint64_t **Strides;
  uint64_t **v28;
  uint64_t InterfaceFor;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  uint64_t **InputAttributeNames;
  uint64_t **v35;
  uint64_t v36;
  const char *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t **Rewriter;
  uint64_t **v43;
  uint64_t v44;
  const char *v45;
  int v46;
  const char *v47;
  const char *v48;
  void *v49;
  unsigned int PaddingStyle;
  void *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumSPI *v57;
  unsigned int StorageType;
  void *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumCaseSPI *v70;
  MPSGraphViewerNodePropertyEnumSPI *v71;
  unsigned int WeightsLayout;
  void *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumCaseSPI *v84;
  MPSGraphViewerNodePropertyEnumSPI *v85;
  void *v86;
  MPSGraphViewerNodeSPI *v87;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  uint64_t v92;
  void *v93;
  uint64_t AttrData;
  uint64_t v96;
  BOOL v97;
  BOOL v98;
  void *v100;
  void *v101;
  MPSGraphViewerNodePropertyDataSPI *v102;
  void *v103;
  void *v104;
  mlir::Operation *v105;
  const char *v106;
  __int16 v107;
  uint64_t v108[4];
  __int16 v109;
  void *__dst[2];
  int64_t v111;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04730;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 25)
    {
      v97 = *(_QWORD *)AttrData == 0x766E6F632E73706DLL && *(_QWORD *)(AttrData + 8) == 0x617461645F64335FLL;
      v98 = v97 && *(_QWORD *)(AttrData + 16) == 0x6E6569646172675FLL;
      if (v98 && *(_BYTE *)(AttrData + 24) == 116)
      {
        v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.conv_3d_data_gradient";
        v108[3] = 25;
        v106 = "' failed due to the operation not being registered";
        v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_82:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id)
    goto LABEL_82;
  v105 = a3;
  v108[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v111 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v104, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v104, "addObject:", v17);
  SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("outputShape"), SplitSizes);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v104, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v103, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v108[0] = 0;
  v108[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v105);
  v102 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("groups"), 64, &unk_1E0E99EF8);
  if (v102)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v108, 8);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v102, "setValue:", v26);

    objc_msgSend(v25, "addObject:", v102);
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v105);
  v28 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v30 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v31 = 692;
    v32 = "Casting.h";
    v33 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28))
  {
    v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v31 = 566;
    v32 = "Casting.h";
    v33 = "cast";
LABEL_61:
    __assert_rtn(v33, v32, v31, v30);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28);
  if (!InterfaceFor)
  {
    v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v31 = 98;
    v32 = "InterfaceSupport.h";
    v33 = "Interface";
    goto LABEL_61;
  }
LABEL_32:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v28, InterfaceFor);
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  if (v101)
    objc_msgSend(v25, "addObject:", v101);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  v35 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v36 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v37 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v38 = 692;
    v39 = "Casting.h";
    v40 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35))
  {
    v37 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v38 = 566;
    v39 = "Casting.h";
    v40 = "cast";
LABEL_64:
    __assert_rtn(v40, v39, v38, v37);
  }
  v36 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35);
  if (!v36)
  {
    v37 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v38 = 98;
    v39 = "InterfaceSupport.h";
    v40 = "Interface";
    goto LABEL_64;
  }
LABEL_40:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v35, v36);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  if (v41)
    objc_msgSend(v25, "addObject:", v41);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  v43 = Rewriter;
  if (!Rewriter)
  {
    v44 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v45 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v46 = 692;
    v47 = "Casting.h";
    v48 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43))
  {
    v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v46 = 566;
    v47 = "Casting.h";
    v48 = "cast";
LABEL_67:
    __assert_rtn(v48, v47, v46, v45);
  }
  v44 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43);
  if (!v44)
  {
    v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v46 = 98;
    v47 = "InterfaceSupport.h";
    v48 = "Interface";
    goto LABEL_67;
  }
LABEL_48:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v43, v44);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  if (v49)
    objc_msgSend(v25, "addObject:", v49);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v51, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v51, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v51, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v51, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v51, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v51, PaddingStyle);
  if (v57)
    objc_msgSend(v25, "addObject:", v57);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v59, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v59, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v59, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v59, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v59, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v59, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v59, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v59, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v59, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v59, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v59, "addObject:", v70);

  v71 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v59, StorageType);
  if (v71)
    objc_msgSend(v25, "addObject:", v71);

  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v73, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v73, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v73, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v73, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v73, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v73, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v73, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v73, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v73, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v73, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v73, "addObject:", v84);

  v85 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v73, WeightsLayout);
  if (v85)
    objc_msgSend(v25, "addObject:", v85);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v87 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v104);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v103);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v86);
  v91 = (void *)objc_claimAutoreleasedReturnValue();
  v92 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v87, "initWithType:inputs:outputs:properties:regions:", v100, v88, v89, v90, v91);
  v93 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v92;

  if (SHIBYTE(v111) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC0BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv3DOpHandler *EmitterViewerSPI::MPSConv3DOpHandler::MPSConv3DOpHandler(EmitterViewerSPI::MPSConv3DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  uint64_t **Strides;
  uint64_t **v26;
  uint64_t InterfaceFor;
  const char *v28;
  int v29;
  const char *v30;
  const char *v31;
  uint64_t **InputAttributeNames;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **Rewriter;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  unsigned int PaddingStyle;
  void *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumSPI *v55;
  unsigned int StorageType;
  void *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumSPI *v69;
  unsigned int WeightsLayout;
  void *v71;
  MPSGraphViewerNodePropertyEnumCaseSPI *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumSPI *v83;
  void *v84;
  MPSGraphViewerNodeSPI *v85;
  void *v86;
  void *v87;
  void *v88;
  void *v89;
  uint64_t v90;
  void *v91;
  void *v92;
  _QWORD *AttrData;
  uint64_t v95;
  void *v97;
  MPSGraphViewerNodePropertyDataSPI *v98;
  void *v99;
  void *v100;
  void *v101;
  mlir::Operation *v102;
  const char *v103;
  __int16 v104;
  uint64_t v105[4];
  __int16 v106;
  void *__dst[2];
  int64_t v108;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E033B0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v95 == 11 && *AttrData == 0x766E6F632E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x64335F766E6F632ELL)
    {
      v106 = 1283;
      v105[0] = (uint64_t)"classof on '";
      v105[2] = (uint64_t)"mps.conv_3d";
      v105[3] = 11;
      v103 = "' failed due to the operation not being registered";
      v104 = 259;
      llvm::operator+(v105, (uint64_t *)&v103, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_74:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id)
    goto LABEL_74;
  v102 = a3;
  v105[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v105);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v108 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v108) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v108 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v99 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v102);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v101, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v102);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v101, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v102);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v100, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v105[0] = 0;
  v105[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v102);
  v98 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("groups"), 64, &unk_1E0E99F10);
  if (v98)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v105, 8);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v98, "setValue:", v24);

    objc_msgSend(v23, "addObject:", v98);
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v102);
  v26 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v28 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v29 = 692;
    v30 = "Casting.h";
    v31 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26))
  {
    v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v29 = 566;
    v30 = "Casting.h";
    v31 = "cast";
LABEL_59:
    __assert_rtn(v31, v30, v29, v28);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26);
  if (!InterfaceFor)
  {
    v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v29 = 98;
    v30 = "InterfaceSupport.h";
    v31 = "Interface";
    goto LABEL_59;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v26, InterfaceFor);
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  if (v97)
    objc_msgSend(v23, "addObject:", v97);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v102);
  v33 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v34 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_62:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_62;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v102);
  v41 = Rewriter;
  if (!Rewriter)
  {
    v42 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_65:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_65;
  }
LABEL_46:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v102);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v49, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v49, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v49, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v49, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v49, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v49, PaddingStyle);
  if (v55)
    objc_msgSend(v23, "addObject:", v55);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v102);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v57, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v57, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v57, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v57, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v57, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v57, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v57, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v57, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v57, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v57, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v57, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v57, StorageType);
  if (v69)
    objc_msgSend(v23, "addObject:", v69);

  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v102);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  v72 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v71, "addObject:", v72);

  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v71, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v71, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v71, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v71, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v71, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v71, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v71, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v71, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v71, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v71, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v71, WeightsLayout);
  if (v83)
    objc_msgSend(v23, "addObject:", v83);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  v85 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v101);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v100);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v84);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  v90 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v85, "initWithType:inputs:outputs:properties:regions:", v99, v86, v87, v88, v89);
  v91 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v90;

  v92 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v92);

  if (SHIBYTE(v108) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC1B90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler *EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler::MPSConv3DWeightsGradientOpHandler(EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t Bias;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  uint64_t **Strides;
  uint64_t **v28;
  uint64_t InterfaceFor;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  uint64_t **InputAttributeNames;
  uint64_t **v35;
  uint64_t v36;
  const char *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t **Rewriter;
  uint64_t **v43;
  uint64_t v44;
  const char *v45;
  int v46;
  const char *v47;
  const char *v48;
  void *v49;
  unsigned int PaddingStyle;
  void *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumSPI *v57;
  unsigned int StorageType;
  void *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumCaseSPI *v70;
  MPSGraphViewerNodePropertyEnumSPI *v71;
  unsigned int WeightsLayout;
  void *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumCaseSPI *v84;
  MPSGraphViewerNodePropertyEnumSPI *v85;
  void *v86;
  MPSGraphViewerNodeSPI *v87;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  uint64_t v92;
  void *v93;
  uint64_t AttrData;
  uint64_t v96;
  BOOL v97;
  BOOL v98;
  void *v100;
  void *v101;
  MPSGraphViewerNodePropertyDataSPI *v102;
  void *v103;
  void *v104;
  mlir::Operation *v105;
  const char *v106;
  __int16 v107;
  uint64_t v108[4];
  __int16 v109;
  void *__dst[2];
  int64_t v111;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04958;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 28)
    {
      v97 = *(_QWORD *)AttrData == 0x766E6F632E73706DLL && *(_QWORD *)(AttrData + 8) == 0x676965775F64335FLL;
      v98 = v97 && *(_QWORD *)(AttrData + 16) == 0x646172675F737468;
      if (v98 && *(_DWORD *)(AttrData + 24) == 1953391977)
      {
        v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.conv_3d_weights_gradient";
        v108[3] = 28;
        v106 = "' failed due to the operation not being registered";
        v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_82:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DWeightsGradientOp,void>::id)
    goto LABEL_82;
  v105 = a3;
  v108[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v111 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v104, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v104, "addObject:", v17);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("outputShape"), Bias);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v104, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v103, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v108[0] = 0;
  v108[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v105);
  v102 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("groups"), 64, &unk_1E0E99F28);
  if (v102)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v108, 8);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v102, "setValue:", v26);

    objc_msgSend(v25, "addObject:", v102);
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v105);
  v28 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v30 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v31 = 692;
    v32 = "Casting.h";
    v33 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28))
  {
    v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v31 = 566;
    v32 = "Casting.h";
    v33 = "cast";
LABEL_61:
    __assert_rtn(v33, v32, v31, v30);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28);
  if (!InterfaceFor)
  {
    v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v31 = 98;
    v32 = "InterfaceSupport.h";
    v33 = "Interface";
    goto LABEL_61;
  }
LABEL_32:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v28, InterfaceFor);
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  if (v101)
    objc_msgSend(v25, "addObject:", v101);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  v35 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v36 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v37 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v38 = 692;
    v39 = "Casting.h";
    v40 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35))
  {
    v37 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v38 = 566;
    v39 = "Casting.h";
    v40 = "cast";
LABEL_64:
    __assert_rtn(v40, v39, v38, v37);
  }
  v36 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35);
  if (!v36)
  {
    v37 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v38 = 98;
    v39 = "InterfaceSupport.h";
    v40 = "Interface";
    goto LABEL_64;
  }
LABEL_40:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v35, v36);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  if (v41)
    objc_msgSend(v25, "addObject:", v41);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  v43 = Rewriter;
  if (!Rewriter)
  {
    v44 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v45 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v46 = 692;
    v47 = "Casting.h";
    v48 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43))
  {
    v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v46 = 566;
    v47 = "Casting.h";
    v48 = "cast";
LABEL_67:
    __assert_rtn(v48, v47, v46, v45);
  }
  v44 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43);
  if (!v44)
  {
    v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v46 = 98;
    v47 = "InterfaceSupport.h";
    v48 = "Interface";
    goto LABEL_67;
  }
LABEL_48:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v43, v44);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  if (v49)
    objc_msgSend(v25, "addObject:", v49);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v51, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v51, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v51, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v51, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v51, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v51, PaddingStyle);
  if (v57)
    objc_msgSend(v25, "addObject:", v57);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v59, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v59, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v59, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v59, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v59, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v59, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v59, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v59, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v59, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v59, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v59, "addObject:", v70);

  v71 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v59, StorageType);
  if (v71)
    objc_msgSend(v25, "addObject:", v71);

  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v73, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v73, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v73, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v73, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v73, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v73, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v73, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v73, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v73, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v73, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v73, "addObject:", v84);

  v85 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v73, WeightsLayout);
  if (v85)
    objc_msgSend(v25, "addObject:", v85);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v87 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v104);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v103);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v86);
  v91 = (void *)objc_claimAutoreleasedReturnValue();
  v92 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v87, "initWithType:inputs:outputs:properties:regions:", v100, v88, v89, v90, v91);
  v93 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v92;

  if (SHIBYTE(v111) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC2B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCosOpHandler *EmitterViewerSPI::MPSCosOpHandler::MPSCosOpHandler(EmitterViewerSPI::MPSCosOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _DWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02BD0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1936679726)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.cos";
      v41[3] = 7;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CosOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC325C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCoshOpHandler *EmitterViewerSPI::MPSCoshOpHandler::MPSCoshOpHandler(EmitterViewerSPI::MPSCoshOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02E70;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x68736F632E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.cosh";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CoshOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC3798(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCostVolumeOpHandler *EmitterViewerSPI::MPSCostVolumeOpHandler::MPSCostVolumeOpHandler(EmitterViewerSPI::MPSCostVolumeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t Bias;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  unsigned int PaddingStyle;
  void *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumSPI *v38;
  unsigned int Layout;
  void *v40;
  MPSGraphViewerNodePropertyEnumCaseSPI *v41;
  MPSGraphViewerNodePropertyEnumCaseSPI *v42;
  MPSGraphViewerNodePropertyEnumCaseSPI *v43;
  MPSGraphViewerNodePropertyEnumCaseSPI *v44;
  MPSGraphViewerNodePropertyEnumCaseSPI *v45;
  MPSGraphViewerNodePropertyEnumCaseSPI *v46;
  MPSGraphViewerNodePropertyEnumCaseSPI *v47;
  MPSGraphViewerNodePropertyEnumCaseSPI *v48;
  MPSGraphViewerNodePropertyEnumCaseSPI *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumSPI *v52;
  MPSGraphViewerNodePropertyDataSPI *v53;
  void *v54;
  void *v55;
  MPSGraphViewerNodeSPI *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  uint64_t v61;
  void *v62;
  void *v63;
  _QWORD *AttrData;
  uint64_t v66;
  void *v68;
  void *v69;
  void *v70;
  unsigned __int16 IsXOnly;
  BOOL ResetAfter;
  BOOL NormalizeCoordinates;
  mlir::Operation *v74;
  uint64_t v75[4];
  __int16 v76;
  uint64_t v77[4];
  __int16 v78;
  void *__dst[2];
  int64_t v80;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03C08;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v66 == 15 && *AttrData == 0x74736F632E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x656D756C6F765F74)
    {
      v78 = 1283;
      v77[0] = (uint64_t)"classof on '";
      v77[2] = (uint64_t)"mps.cost_volume";
      v77[3] = 15;
      v75[0] = (uint64_t)"' failed due to the operation not being registered";
      v76 = 259;
      llvm::operator+(v77, v75, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_53:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CostVolumeOp,void>::id)
    goto LABEL_53;
  v74 = a3;
  v77[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v77);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v80 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v80) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v80 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v68 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v74);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("ref"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v70, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v74);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v70, "addObject:", v17);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v74);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("coordinates"), Bias);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v70, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v74);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v69, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  NormalizeCoordinates = mlir::mps::CostVolumeOp::getNormalizeCoordinates((mlir::mps::CostVolumeOp *)&v74);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("normalize_coordinates"), 2147483656, &unk_1E0E99F40);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &NormalizeCoordinates, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v74);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("relative_coordinates"), 2147483656, &unk_1E0E99F58);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &ResetAfter, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }
  v77[0] = 0;
  v77[0] = (uint64_t)mlir::mps::CostVolumeOp::getWindowHeight((mlir::mps::CostVolumeOp *)&v74);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("window_height"), 64, &unk_1E0E99F70);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v77, 8);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v25, "addObject:", v30);
  }
  v75[0] = 0;
  v75[0] = (uint64_t)mlir::mps::CostVolumeOp::getWindowWidth((mlir::mps::CostVolumeOp *)&v74);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("window_width"), 64, &unk_1E0E99F88);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v75, 8);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v25, "addObject:", v32);
  }
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v74);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("dot_product"), 0);
  objc_msgSend(v35, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("abs_diff"), 1);
  objc_msgSend(v35, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("similarity_type"), CFSTR("MPSSimilarityType"), v35, PaddingStyle);
  if (v38)
    objc_msgSend(v25, "addObject:", v38);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v74);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v40, "addObject:", v41);

  v42 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v40, "addObject:", v42);

  v43 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v40, "addObject:", v43);

  v44 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v40, "addObject:", v44);

  v45 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v40, "addObject:", v45);

  v46 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v40, "addObject:", v46);

  v47 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v40, "addObject:", v47);

  v48 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v40, "addObject:", v48);

  v49 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v40, "addObject:", v49);

  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v40, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v40, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v40, Layout);
  if (v52)
    objc_msgSend(v25, "addObject:", v52);

  IsXOnly = mlir::mps::CostVolumeOp::getCoordIsXOnly((mlir::mps::CostVolumeOp *)&v74);
  if (IsXOnly >= 0x100u)
  {
    v53 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("coord_is_x_only"), 2147483656, &unk_1E0E99FA0);
    if (v53)
    {
      if (!HIBYTE(IsXOnly))
        std::__throw_bad_optional_access[abi:ne180100]();
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &IsXOnly, 2);
      v54 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setValue:](v53, "setValue:", v54);

      objc_msgSend(v25, "addObject:", v53);
    }

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v56 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v70);
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v69);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v55);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  v61 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v56, "initWithType:inputs:outputs:properties:regions:", v68, v57, v58, v59, v60);
  v62 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v61;

    "rue, sampling_mode=\"bilinear\"\n"
    "\n"
    "Data type: float\n"
    "\n"
    "\n"
    "put HW. Otherwise, the coordinates are absolute and directly used for sampling. Note that if the final coordinate fo"
    "r sampling (absolute or relative + fixed) exceeds pixel boundaries, the sampled data will be 0 prior to doing any ca"
    "\n"
    " Similarity computation method between two feature vectors A, B. \"dot_product\" or \"absolute difference\" only. De"
    "fault: \"dot_product\". \"dot_product\": dot_product(A,B) \"abs_diff\": sum(abs(A-B))\n"
    "\n"
    "fault: NCHW.\n"
    "\n"
    " is along W dimension. Otherwise, it is along H dimension.\n"
    "\n"
    "When C2 = 2, it should not be provided and will be ignored. Data type: BoolAttr.\n"
    "\n"
    "\n"
    "Core Computation Code:\n"
    "For 2D case, i.e., C = 2 in coordinates. \n"
    "\n"
    "For 1D case, i.e., C = 1 in coordinates. window_height = 1; max_displacement = window_width - 1");
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v63);

  if (SHIBYTE(v80) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC42F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCreateComplexOpHandler *EmitterViewerSPI::MPSCreateComplexOpHandler::MPSCreateComplexOpHandler(EmitterViewerSPI::MPSCreateComplexOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04070;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 18)
    {
      v38 = *(_QWORD *)AttrData == 0x616572632E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6C706D6F635F6574;
      if (v38 && *(_WORD *)(AttrData + 16) == 30821)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"mps.create_complex";
        v44[3] = 18;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CreateComplexOp,void>::id)
    goto LABEL_36;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("real"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("imag"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v21 = CFSTR("output");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v40, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC4A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCreateTextureTensorOpHandler *EmitterViewerSPI::MPSCreateTextureTensorOpHandler::MPSCreateTextureTensorOpHandler(EmitterViewerSPI::MPSCreateTextureTensorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  unsigned int Layout;
  void *v25;
  MPSGraphViewerNodePropertyEnumCaseSPI *v26;
  MPSGraphViewerNodePropertyEnumCaseSPI *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumSPI *v36;
  MPSGraphViewerNodePropertyDataSPI *v37;
  void *v38;
  void *v39;
  MPSGraphViewerNodeSPI *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  uint64_t v45;
  void *v46;
  void *v47;
  uint64_t AttrData;
  uint64_t v50;
  BOOL v51;
  BOOL v52;
  void *v54;
  mlir::Operation *v55;
  const char *v56;
  __int16 v57;
  uint64_t v58[4];
  __int16 v59;
  void *__dst[2];
  int64_t v61;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04820;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 25)
    {
      v51 = *(_QWORD *)AttrData == 0x616572632E73706DLL && *(_QWORD *)(AttrData + 8) == 0x75747865745F6574;
      v52 = v51 && *(_QWORD *)(AttrData + 16) == 0x6F736E65745F6572;
      if (v52 && *(_BYTE *)(AttrData + 24) == 114)
      {
        v59 = 1283;
        v58[0] = (uint64_t)"classof on '";
        v58[2] = (uint64_t)"mps.create_texture_tensor";
        v58[3] = 25;
        v56 = "' failed due to the operation not being registered";
        v57 = 259;
        llvm::operator+(v58, (uint64_t *)&v56, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CreateTextureTensorOp,void>::id)
    goto LABEL_41;
  v55 = a3;
  v58[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v58);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v61 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v61) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v61 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v55);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v55);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v55);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("R8Unorm"), 0);
  objc_msgSend(v25, "addObject:", v26);

  v27 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("RG8Unorm"), 1);
  objc_msgSend(v25, "addObject:", v27);

  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("RGBA8Unorm"), 2);
  objc_msgSend(v25, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("BGRA8Unorm"), 3);
  objc_msgSend(v25, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("R16Float"), 4);
  objc_msgSend(v25, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("RG16Float"), 5);
  objc_msgSend(v25, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("RGBA16Float"), 6);
  objc_msgSend(v25, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("R32Float"), 7);
  objc_msgSend(v25, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("RG32Float"), 8);
  objc_msgSend(v25, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("RGBA32Float"), 9);
  objc_msgSend(v25, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("pixel_format"), CFSTR("MPSMetalPixelFormat"), v25, Layout);
  if (v36)
    objc_msgSend(v23, "addObject:", v36);

  LOBYTE(v58[0]) = 0;
  LOBYTE(v58[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v55);
  v37 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("compressed"), 2147483656, &unk_1E0E99FB8);
  if (v37)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v58, 1);
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v37, "setValue:", v38);

    objc_msgSend(v23, "addObject:", v37);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v39);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v45 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v40, "initWithType:inputs:outputs:properties:regions:", v54, v41, v42, v43, v44);
  v46 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v45;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Creates a textureTensor op with a specified pixel format format from a tensor. The input is expected to be in NHWC data layout.");
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v47);

  if (SHIBYTE(v61) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC5244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCropOpHandler *EmitterViewerSPI::MPSCropOpHandler::MPSCropOpHandler(EmitterViewerSPI::MPSCropOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  void *v28;
  void *v29;
  MPSGraphViewerNodeSPI *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  uint64_t v35;
  void *v36;
  void *v37;
  _QWORD *AttrData;
  uint64_t v40;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02E88;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 8 && *AttrData == 0x706F72632E73706DLL)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.crop";
      v45[3] = 8;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id)
    goto LABEL_33;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("amount_before"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("amount_after"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v24)
      objc_msgSend(v23, "addObject:", v24);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v30, "initWithType:inputs:outputs:properties:regions:", v41, v31, v32, v33, v34);
  v36 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v35;

  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v37);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC5880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCropResizeOpHandler *EmitterViewerSPI::MPSCropResizeOpHandler::MPSCropResizeOpHandler(EmitterViewerSPI::MPSCropResizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodePropertyDataSPI *v25;
  void *v26;
  MPSGraphViewerNodePropertyDataSPI *v27;
  void *v28;
  MPSGraphViewerNodePropertyDataSPI *v29;
  void *v30;
  unsigned int GateLayout;
  void *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumSPI *v35;
  unsigned int StorageType;
  void *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumCaseSPI *v39;
  MPSGraphViewerNodePropertyEnumCaseSPI *v40;
  MPSGraphViewerNodePropertyEnumSPI *v41;
  unsigned int Layout;
  void *v43;
  MPSGraphViewerNodePropertyEnumCaseSPI *v44;
  MPSGraphViewerNodePropertyEnumCaseSPI *v45;
  MPSGraphViewerNodePropertyEnumCaseSPI *v46;
  MPSGraphViewerNodePropertyEnumCaseSPI *v47;
  MPSGraphViewerNodePropertyEnumSPI *v48;
  void *v49;
  llvm::APFloatBase *v50;
  void *v51;
  MPSGraphViewerNodeSPI *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  uint64_t v57;
  void *v58;
  void *v59;
  _QWORD *AttrData;
  uint64_t v62;
  void *v64;
  MPSGraphViewerNodePropertyDataSPI *v65;
  void *v66;
  void *v67;
  BOOL ResetAfter;
  unsigned int WindowHeight;
  mlir::Operation *v70;
  uint64_t v71[4];
  __int16 v72;
  void *__dst[2];
  const char *v74;
  uint64_t v75;
  __int16 v76;
  uint64_t v77;
  void *v78;
  _QWORD v79[5];

  v79[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03C20;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v77 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v77);
    if (v62 == 15 && *AttrData == 0x706F72632E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x657A697365725F70)
    {
      v76 = 1283;
      __dst[0] = "classof on '";
      v74 = "mps.crop_resize";
      v75 = 15;
      v71[0] = (uint64_t)"' failed due to the operation not being registered";
      v72 = 259;
      llvm::operator+((uint64_t *)__dst, v71, (uint64_t)&v77);
      llvm::report_fatal_error((llvm::Twine *)&v77, 1);
    }
LABEL_50:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeOp,void>::id)
    goto LABEL_50;
  v70 = a3;
  v77 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v77);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v74 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v74) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v74) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v70);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("images"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v67, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v70);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("boxes"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v67, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v70);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v66, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v71[0]) = 0;
  LODWORD(v71[0]) = mlir::mps::CropResizeOp::getResizeHeight((mlir::mps::CropResizeOp *)&v70);
  v65 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("resize_height"), 32, &unk_1E0E99FD0);
  if (v65)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v71, 4);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v65, "setValue:", v24);

    objc_msgSend(v23, "addObject:", v65);
  }
  WindowHeight = mlir::mps::CostVolumeOp::getWindowHeight((mlir::mps::CostVolumeOp *)&v70);
  v25 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("resize_width"), 32, &unk_1E0E99FE8);
  if (v25)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &WindowHeight, 4);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v25, "setValue:", v26);

    objc_msgSend(v23, "addObject:", v25);
  }
  ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v70);
  v27 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("normalize_coordinates"), 2147483656, &unk_1E0E9A000);
  if (v27)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &ResetAfter, 1);
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v27, "setValue:", v28);

    objc_msgSend(v23, "addObject:", v27);
  }
  mlir::mps::CropResizeOp::getSpatialScale((mlir::mps::CropResizeOp *)&v70, (uint64_t)&v77);
  v29 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("spatial_scale"), 268435488, &unk_1E0E9A018);
  if (v29)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v77, 32);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v29, "setValue:", v30);

    objc_msgSend(v23, "addObject:", v29);
  }
  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v70);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("nearest"), 0);
  objc_msgSend(v32, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("bilinear"), 1);
  objc_msgSend(v32, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("interpolation_mode"), CFSTR("MPSSamplingMode"), v32, GateLayout);
  if (v35)
    objc_msgSend(v23, "addObject:", v35);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v70);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("defaultAlignment"), 0);
  objc_msgSend(v37, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("alignCorners"), 1);
  objc_msgSend(v37, "addObject:", v39);

  v40 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("offsetCorners"), 2);
  objc_msgSend(v37, "addObject:", v40);

  v41 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("alignment_mode"), CFSTR("MPSCropResizeAlignmentMode"), v37, StorageType);
  if (v41)
    objc_msgSend(v23, "addObject:", v41);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v70);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  v44 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("cornersHeightFirst"), 0);
  objc_msgSend(v43, "addObject:", v44);

  v45 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("cornersWidthFirst"), 1);
  objc_msgSend(v43, "addObject:", v45);

  v46 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("centersHeightFirst"), 2);
  objc_msgSend(v43, "addObject:", v46);

  v47 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("centersWidthFirst"), 3);
  objc_msgSend(v43, "addObject:", v47);

  v48 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("coordinate_mode"), CFSTR("MPSCropResizeCoordinateMode"), v43, Layout);
  if (v48)
    objc_msgSend(v23, "addObject:", v48);

  v49 = v78;
  if (llvm::APFloatBase::PPCDoubleDouble(v50) == v49)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v79);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v78);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  v52 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v67);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v66);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v51);
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  v57 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v52, "initWithType:inputs:outputs:properties:regions:", v64, v53, v54, v55, v56);
  v58 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v57;

    "follows Default:\n"
    "spacing = (Xin - Xin/Xout) / (Xout - 1)\n"
    "grid_point[i] = min(Xin-1, max(0, i*spacing)), for i=0,1,...,Xout-1\n"
    "\n"
    "Align Corners: spacing = (Xin - 1) / (Xout - 1) grid_point[0] = (Xin-1) / 2, if Xout==1 grid_point[i] = min(Xin-1, m"
    "ax(0, i*spacing)), for i=0,1,...,Xout-1\n"
    "\n"
    "Offset Corners: delta = max(1, Xin - 1) / Xout spacing = ((Xout - 1) * delta) / (Xout - 1) grid_point[i] = min(Xin-1"
    ", max(0, 0.5*delta + i*spacing)), for i=0,1,...,Xout-1\n"
    "\n"
    "d ending at end point. End coordinates less than start coordinates are supported, and in such cases input images are"
    " flipped along that axis. Center coordinate modes define a box with center point and provided height and width. Corn"
    "ersHeightFirst:\n"
    "[h_start, w_start, h_end, w_end]\n"
    "\n"
    "CornersWidthFirst: [w_start, h_start, w_end, h_end]\n"
    "\n"
    "CentersHeightFirst: [h_center, w_center, box_height, box_width]\n"
    "\n"
    "CentersWidthFirst: [w_center, h_center, box_width, box_height]");
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v59);

  if (SHIBYTE(v74) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC6334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;
  void *v30;

  if (a26 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCumulativeMaximumOpHandler *EmitterViewerSPI::MPSCumulativeMaximumOpHandler::MPSCumulativeMaximumOpHandler(EmitterViewerSPI::MPSCumulativeMaximumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  uint64_t v46[4];
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04658;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 22)
    {
      v42 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x6D5F65766974616CLL;
      if (v42 && *(_QWORD *)((char *)AttrData + 14) == 0x6D756D6978616D5FLL)
      {
        v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.cumulative_maximum";
        v48[3] = 22;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id)
    goto LABEL_40;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("exclusive"), 2147483656, &unk_1E0E9A030);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("reverse"), 2147483656, &unk_1E0E9A048);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v44, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC6B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCumulativeMinimumOpHandler *EmitterViewerSPI::MPSCumulativeMinimumOpHandler::MPSCumulativeMinimumOpHandler(EmitterViewerSPI::MPSCumulativeMinimumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  uint64_t v46[4];
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04670;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 22)
    {
      v42 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x6D5F65766974616CLL;
      if (v42 && *(_QWORD *)((char *)AttrData + 14) == 0x6D756D696E696D5FLL)
      {
        v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.cumulative_minimum";
        v48[3] = 22;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id)
    goto LABEL_40;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("exclusive"), 2147483656, &unk_1E0E9A060);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("reverse"), 2147483656, &unk_1E0E9A078);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v44, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC724C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCumulativeProductOpHandler *EmitterViewerSPI::MPSCumulativeProductOpHandler::MPSCumulativeProductOpHandler(EmitterViewerSPI::MPSCumulativeProductOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  uint64_t v46[4];
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04688;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 22)
    {
      v42 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x705F65766974616CLL;
      if (v42 && *(_QWORD *)((char *)AttrData + 14) == 0x746375646F72705FLL)
      {
        v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.cumulative_product";
        v48[3] = 22;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id)
    goto LABEL_40;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("exclusive"), 2147483656, &unk_1E0E9A090);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("reverse"), 2147483656, &unk_1E0E9A0A8);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v44, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC7930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCumulativeSumOpHandler *EmitterViewerSPI::MPSCumulativeSumOpHandler::MPSCumulativeSumOpHandler(EmitterViewerSPI::MPSCumulativeSumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  uint64_t v46[4];
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04088;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 18)
    {
      v42 = *(_QWORD *)AttrData == 0x756D75632E73706DLL && *(_QWORD *)(AttrData + 8) == 0x735F65766974616CLL;
      if (v42 && *(_WORD *)(AttrData + 16) == 28021)
      {
        v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.cumulative_sum";
        v48[3] = 18;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id)
    goto LABEL_40;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("exclusive"), 2147483656, &unk_1E0E9A0C0);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("reverse"), 2147483656, &unk_1E0E9A0D8);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v44, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC8008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDegammaOpHandler *EmitterViewerSPI::MPSDegammaOpHandler::MPSDegammaOpHandler(EmitterViewerSPI::MPSDegammaOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03578;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 11 && *AttrData == 0x616765642E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x616D6D616765642ELL)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.degamma";
      v41[3] = 11;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DegammaOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC85B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthToSpace2DOpHandler *EmitterViewerSPI::MPSDepthToSpace2DOpHandler::MPSDepthToSpace2DOpHandler(EmitterViewerSPI::MPSDepthToSpace2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  _QWORD *AttrData;
  uint64_t v45;
  BOOL v46;
  void *v48;
  mlir::Operation *v49;
  uint64_t v50[4];
  __int16 v51;
  uint64_t v52[4];
  __int16 v53;
  void *__dst[2];
  int64_t v55;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04220;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 21)
    {
      v46 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6170735F6F745F68;
      if (v46 && *(_QWORD *)((char *)AttrData + 13) == 0x64325F6563617073)
      {
        v53 = 1283;
        v52[0] = (uint64_t)"classof on '";
        v52[2] = (uint64_t)"mps.depth_to_space_2d";
        v52[3] = 21;
        v50[0] = (uint64_t)"' failed due to the operation not being registered";
        v51 = 259;
        llvm::operator+(v52, v50, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthToSpace2DOp,void>::id)
    goto LABEL_44;
  v49 = a3;
  v52[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v55 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("width_axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("height_axis"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("depth_axis"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v52[0]) = 0;
  LODWORD(v52[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v49);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("block_size"), 32, &unk_1E0E9A0F0);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v52, 4);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v29, "addObject:", v30);
  }
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v49);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("pixel_shuffle"), 2147483656, &unk_1E0E9A108);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v50, 1);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v29, "addObject:", v32);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v48, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v42);

  if (SHIBYTE(v55) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC8CAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler *EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler::MPSDepthwiseConv2DDataGradientOpHandler(EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t Bias;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  uint64_t **Strides;
  uint64_t **v27;
  uint64_t InterfaceFor;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t **InputAttributeNames;
  uint64_t **v34;
  uint64_t v35;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *v40;
  uint64_t **Rewriter;
  uint64_t **v42;
  uint64_t v43;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  void *v48;
  unsigned int PaddingStyle;
  void *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumSPI *v56;
  unsigned int StorageType;
  void *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumSPI *v70;
  unsigned int v71;
  void *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumSPI *v84;
  void *v85;
  MPSGraphViewerNodeSPI *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  uint64_t v91;
  void *v92;
  void *v93;
  _QWORD *AttrData;
  uint64_t v96;
  BOOL v97;
  BOOL v98;
  BOOL v99;
  void *v101;
  void *v102;
  void *v103;
  void *v104;
  mlir::Operation *v105;
  const char *v106;
  __int16 v107;
  uint64_t v108[4];
  __int16 v109;
  void *__dst[2];
  int64_t v111;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04AF0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 35)
    {
      v97 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      v98 = v97 && AttrData[2] == 0x61645F64325F766ELL;
      v99 = v98 && AttrData[3] == 0x69646172675F6174;
      if (v99 && *(_QWORD *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.depthwise_conv_2d_data_gradient";
        v108[3] = 35;
        v106 = "' failed due to the operation not being registered";
        v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_83:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id)
    goto LABEL_83;
  v105 = a3;
  v108[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v111 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v102 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v104, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v104, "addObject:", v17);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("outputShape"), Bias);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v104, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v103, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v105);
  v27 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v30 = 692;
    v31 = "Casting.h";
    v32 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v30 = 566;
    v31 = "Casting.h";
    v32 = "cast";
LABEL_59:
    __assert_rtn(v32, v31, v30, v29);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v30 = 98;
    v31 = "InterfaceSupport.h";
    v32 = "Interface";
    goto LABEL_59;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v27, InterfaceFor);
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  if (v101)
    objc_msgSend(v25, "addObject:", v101);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  v34 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v35 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v37 = 692;
    v38 = "Casting.h";
    v39 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v37 = 566;
    v38 = "Casting.h";
    v39 = "cast";
LABEL_62:
    __assert_rtn(v39, v38, v37, v36);
  }
  v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v37 = 98;
    v38 = "InterfaceSupport.h";
    v39 = "Interface";
    goto LABEL_62;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v34, v35);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  if (v40)
    objc_msgSend(v25, "addObject:", v40);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  v42 = Rewriter;
  if (!Rewriter)
  {
    v43 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v45 = 692;
    v46 = "Casting.h";
    v47 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v45 = 566;
    v46 = "Casting.h";
    v47 = "cast";
LABEL_65:
    __assert_rtn(v47, v46, v45, v44);
  }
  v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v45 = 98;
    v46 = "InterfaceSupport.h";
    v47 = "Interface";
    goto LABEL_65;
  }
LABEL_46:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v42, v43);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  if (v48)
    objc_msgSend(v25, "addObject:", v48);
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v50, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v50, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v50, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v50, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v50, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v50, PaddingStyle);
  if (v56)
    objc_msgSend(v25, "addObject:", v56);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v58, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v58, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v58, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v58, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v58, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v58, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v58, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v58, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v58, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v58, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v58, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v58, StorageType);
  if (v70)
    objc_msgSend(v25, "addObject:", v70);

  v71 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v72, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v72, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v72, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v72, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v72, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v72, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v72, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v72, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v72, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v72, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v72, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v72, v71);
  if (v84)
    objc_msgSend(v25, "addObject:", v84);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  v86 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v104);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v103);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v85);
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  v91 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v86, "initWithType:inputs:outputs:properties:regions:", v102, v87, v88, v89, v90);
  v92 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v91;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Depthwise Conv2D operation");
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v93);

  if (SHIBYTE(v111) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EC9B70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv2DOpHandler *EmitterViewerSPI::MPSDepthwiseConv2DOpHandler::MPSDepthwiseConv2DOpHandler(EmitterViewerSPI::MPSDepthwiseConv2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Strides;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  uint64_t **InputAttributeNames;
  uint64_t **v32;
  uint64_t v33;
  const char *v34;
  int v35;
  const char *v36;
  const char *v37;
  void *v38;
  uint64_t **Rewriter;
  uint64_t **v40;
  uint64_t v41;
  const char *v42;
  int v43;
  const char *v44;
  const char *v45;
  void *v46;
  unsigned int PaddingStyle;
  void *v48;
  MPSGraphViewerNodePropertyEnumCaseSPI *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumSPI *v54;
  unsigned int StorageType;
  void *v56;
  MPSGraphViewerNodePropertyEnumCaseSPI *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumSPI *v68;
  unsigned int v69;
  void *v70;
  MPSGraphViewerNodePropertyEnumCaseSPI *v71;
  MPSGraphViewerNodePropertyEnumCaseSPI *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumSPI *v82;
  void *v83;
  MPSGraphViewerNodeSPI *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  uint64_t v89;
  void *v90;
  void *v91;
  _QWORD *AttrData;
  uint64_t v94;
  BOOL v95;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  mlir::Operation *v101;
  const char *v102;
  __int16 v103;
  uint64_t v104[4];
  __int16 v105;
  void *__dst[2];
  int64_t v107;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E043D0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v94 == 21)
    {
      v95 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v95 && *(_QWORD *)((char *)AttrData + 13) == 0x64325F766E6F635FLL)
      {
        v105 = 1283;
        v104[0] = (uint64_t)"classof on '";
        v104[2] = (uint64_t)"mps.depthwise_conv_2d";
        v104[3] = 21;
        v102 = "' failed due to the operation not being registered";
        v103 = 259;
        llvm::operator+(v104, (uint64_t *)&v102, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_75:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id)
    goto LABEL_75;
  v101 = a3;
  v104[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v104);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v107 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v107) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v107 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v101);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v100, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v101);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v100, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v99 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v101);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v99, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v101);
  v25 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_57;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_57:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_57;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v25, InterfaceFor);
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  if (v97)
    objc_msgSend(v23, "addObject:", v97);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v101);
  v32 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v33 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v35 = 692;
    v36 = "Casting.h";
    v37 = "cast_if_present";
    goto LABEL_60;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v35 = 566;
    v36 = "Casting.h";
    v37 = "cast";
LABEL_60:
    __assert_rtn(v37, v36, v35, v34);
  }
  v33 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!v33)
  {
    v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v35 = 98;
    v36 = "InterfaceSupport.h";
    v37 = "Interface";
    goto LABEL_60;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v32, v33);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  if (v38)
    objc_msgSend(v23, "addObject:", v38);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v101);
  v40 = Rewriter;
  if (!Rewriter)
  {
    v41 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v43 = 692;
    v44 = "Casting.h";
    v45 = "cast_if_present";
    goto LABEL_63;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v43 = 566;
    v44 = "Casting.h";
    v45 = "cast";
LABEL_63:
    __assert_rtn(v45, v44, v43, v42);
  }
  v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v43 = 98;
    v44 = "InterfaceSupport.h";
    v45 = "Interface";
    goto LABEL_63;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v40, v41);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  if (v46)
    objc_msgSend(v23, "addObject:", v46);
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v101);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  v49 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v48, "addObject:", v49);

  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v48, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v48, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v48, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v48, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v48, PaddingStyle);
  if (v54)
    objc_msgSend(v23, "addObject:", v54);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v101);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  v57 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v56, "addObject:", v57);

  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v56, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v56, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v56, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v56, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v56, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v56, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v56, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v56, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v56, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v56, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v56, StorageType);
  if (v68)
    objc_msgSend(v23, "addObject:", v68);

  v69 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v101);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  v71 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v70, "addObject:", v71);

  v72 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v70, "addObject:", v72);

  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v70, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v70, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v70, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v70, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v70, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v70, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v70, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v70, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v70, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v70, v69);
  if (v82)
    objc_msgSend(v23, "addObject:", v82);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  v84 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v100);
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v99);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v83);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  v89 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v84, "initWithType:inputs:outputs:properties:regions:", v98, v85, v86, v87, v88);
  v90 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v89;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Depthwise Conv2D operation");
  v91 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v91);

  if (SHIBYTE(v107) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECAA90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler *EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler::MPSDepthwiseConv2DWeightsGradientOpHandler(EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t Bias;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  uint64_t **Strides;
  uint64_t **v27;
  uint64_t InterfaceFor;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t **InputAttributeNames;
  uint64_t **v34;
  uint64_t v35;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *v40;
  uint64_t **Rewriter;
  uint64_t **v42;
  uint64_t v43;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  void *v48;
  unsigned int PaddingStyle;
  void *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumSPI *v56;
  unsigned int StorageType;
  void *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumSPI *v70;
  unsigned int v71;
  void *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumSPI *v84;
  void *v85;
  MPSGraphViewerNodeSPI *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  uint64_t v91;
  void *v92;
  void *v93;
  _QWORD *AttrData;
  uint64_t v96;
  BOOL v97;
  BOOL v98;
  BOOL v99;
  void *v101;
  void *v102;
  void *v103;
  void *v104;
  mlir::Operation *v105;
  const char *v106;
  __int16 v107;
  uint64_t v108[4];
  __int16 v109;
  void *__dst[2];
  int64_t v111;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04B68;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 38)
    {
      v97 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      v98 = v97 && AttrData[2] == 0x65775F64325F766ELL;
      v99 = v98 && AttrData[3] == 0x72675F7374686769;
      if (v99 && *(_QWORD *)((char *)AttrData + 30) == 0x746E656964617267)
      {
        v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.depthwise_conv_2d_weights_gradient";
        v108[3] = 38;
        v106 = "' failed due to the operation not being registered";
        v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_83:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DWeightsGradientOp,void>::id)
    goto LABEL_83;
  v105 = a3;
  v108[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v111 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v102 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v104, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v104, "addObject:", v17);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("outputShape"), Bias);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v104, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v103, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v105);
  v27 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v30 = 692;
    v31 = "Casting.h";
    v32 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v30 = 566;
    v31 = "Casting.h";
    v32 = "cast";
LABEL_59:
    __assert_rtn(v32, v31, v30, v29);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v30 = 98;
    v31 = "InterfaceSupport.h";
    v32 = "Interface";
    goto LABEL_59;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v27, InterfaceFor);
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  if (v101)
    objc_msgSend(v25, "addObject:", v101);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  v34 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v35 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v37 = 692;
    v38 = "Casting.h";
    v39 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v37 = 566;
    v38 = "Casting.h";
    v39 = "cast";
LABEL_62:
    __assert_rtn(v39, v38, v37, v36);
  }
  v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v37 = 98;
    v38 = "InterfaceSupport.h";
    v39 = "Interface";
    goto LABEL_62;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v34, v35);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  if (v40)
    objc_msgSend(v25, "addObject:", v40);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  v42 = Rewriter;
  if (!Rewriter)
  {
    v43 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v45 = 692;
    v46 = "Casting.h";
    v47 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v45 = 566;
    v46 = "Casting.h";
    v47 = "cast";
LABEL_65:
    __assert_rtn(v47, v46, v45, v44);
  }
  v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v45 = 98;
    v46 = "InterfaceSupport.h";
    v47 = "Interface";
    goto LABEL_65;
  }
LABEL_46:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v42, v43);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  if (v48)
    objc_msgSend(v25, "addObject:", v48);
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v50, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v50, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v50, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v50, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v50, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v50, PaddingStyle);
  if (v56)
    objc_msgSend(v25, "addObject:", v56);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v58, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v58, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v58, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v58, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v58, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v58, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v58, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v58, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v58, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v58, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v58, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v58, StorageType);
  if (v70)
    objc_msgSend(v25, "addObject:", v70);

  v71 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v72, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v72, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v72, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v72, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v72, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v72, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v72, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v72, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v72, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v72, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v72, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("weights_layout"), CFSTR("MPSTensorDataLayout"), v72, v71);
  if (v84)
    objc_msgSend(v25, "addObject:", v84);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  v86 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v104);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v103);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v85);
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  v91 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v86, "initWithType:inputs:outputs:properties:regions:", v102, v87, v88, v89, v90);
  v92 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v91;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "DepthwiseConv2DWeightsGradient operation");
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v93);

  if (SHIBYTE(v111) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECB9F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler *EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler::MPSDepthwiseConv3DDataGradientOpHandler(EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t SplitSizes;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  uint64_t **Strides;
  uint64_t **v27;
  uint64_t InterfaceFor;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *v33;
  uint64_t **InputAttributeNames;
  uint64_t **v35;
  uint64_t v36;
  const char *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t **Rewriter;
  uint64_t **v43;
  uint64_t v44;
  const char *v45;
  int v46;
  const char *v47;
  const char *v48;
  void *v49;
  unsigned int PaddingStyle;
  void *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumSPI *v57;
  MPSGraphViewerNodePropertyDataSPI *v58;
  void *v59;
  void *v60;
  MPSGraphViewerNodeSPI *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  void *v67;
  void *v68;
  _QWORD *AttrData;
  uint64_t v71;
  BOOL v72;
  BOOL v73;
  BOOL v74;
  void *v76;
  void *v77;
  void *v78;
  mlir::Operation *v79;
  const char *v80;
  __int16 v81;
  uint64_t v82[4];
  __int16 v83;
  void *__dst[2];
  int64_t v85;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04B08;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v71 == 35)
    {
      v72 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      v73 = v72 && AttrData[2] == 0x61645F64335F766ELL;
      v74 = v73 && AttrData[3] == 0x69646172675F6174;
      if (v74 && *(_QWORD *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        v83 = 1283;
        v82[0] = (uint64_t)"classof on '";
        v82[2] = (uint64_t)"mps.depthwise_conv_3d_data_gradient";
        v82[3] = 35;
        v80 = "' failed due to the operation not being registered";
        v81 = 259;
        llvm::operator+(v82, (uint64_t *)&v80, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_81:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id)
    goto LABEL_81;
  v79 = a3;
  v82[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v82);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v85 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v85) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v85 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v76 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v78 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v79);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v78, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v79);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v78, "addObject:", v17);
  SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v79);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("output_shape"), SplitSizes);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v78, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v79);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v77, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v79);
  v27 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v30 = 692;
    v31 = "Casting.h";
    v32 = "cast_if_present";
    goto LABEL_57;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v30 = 566;
    v31 = "Casting.h";
    v32 = "cast";
LABEL_57:
    __assert_rtn(v32, v31, v30, v29);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v30 = 98;
    v31 = "InterfaceSupport.h";
    v32 = "Interface";
    goto LABEL_57;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v27, InterfaceFor);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  if (v33)
    objc_msgSend(v25, "addObject:", v33);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v79);
  v35 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v36 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v37 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v38 = 692;
    v39 = "Casting.h";
    v40 = "cast_if_present";
    goto LABEL_60;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35))
  {
    v37 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v38 = 566;
    v39 = "Casting.h";
    v40 = "cast";
LABEL_60:
    __assert_rtn(v40, v39, v38, v37);
  }
  v36 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35);
  if (!v36)
  {
    v37 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v38 = 98;
    v39 = "InterfaceSupport.h";
    v40 = "Interface";
    goto LABEL_60;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v35, v36);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  if (v41)
    objc_msgSend(v25, "addObject:", v41);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v79);
  v43 = Rewriter;
  if (!Rewriter)
  {
    v44 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v45 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v46 = 692;
    v47 = "Casting.h";
    v48 = "cast_if_present";
    goto LABEL_63;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43))
  {
    v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v46 = 566;
    v47 = "Casting.h";
    v48 = "cast";
LABEL_63:
    __assert_rtn(v48, v47, v46, v45);
  }
  v44 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43);
  if (!v44)
  {
    v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v46 = 98;
    v47 = "InterfaceSupport.h";
    v48 = "Interface";
    goto LABEL_63;
  }
LABEL_46:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v43, v44);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  if (v49)
    objc_msgSend(v25, "addObject:", v49);
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v79);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v51, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v51, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v51, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v51, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v51, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v51, PaddingStyle);
  if (v57)
    objc_msgSend(v25, "addObject:", v57);

  LODWORD(v82[0]) = 0;
  LODWORD(v82[0]) = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v79);
  v58 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("channelAxis"), 536870944, &unk_1E0E9A120);
  if (v58)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v82, 4);
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v58, "setValue:", v59);

    objc_msgSend(v25, "addObject:", v58);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  v61 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v78);
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v77);
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v60);
  v65 = (void *)objc_claimAutoreleasedReturnValue();
  v66 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v61, "initWithType:inputs:outputs:properties:regions:", v76, v62, v63, v64, v65);
  v67 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v66;

  v68 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v68);

  if (SHIBYTE(v85) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECC56C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv3DOpHandler *EmitterViewerSPI::MPSDepthwiseConv3DOpHandler::MPSDepthwiseConv3DOpHandler(EmitterViewerSPI::MPSDepthwiseConv3DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Strides;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t **InputAttributeNames;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **Rewriter;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  unsigned int PaddingStyle;
  void *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumSPI *v55;
  MPSGraphViewerNodePropertyDataSPI *v56;
  void *v57;
  void *v58;
  MPSGraphViewerNodeSPI *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  void *v65;
  void *v66;
  _QWORD *AttrData;
  uint64_t v69;
  BOOL v70;
  void *v72;
  void *v73;
  void *v74;
  mlir::Operation *v75;
  const char *v76;
  __int16 v77;
  uint64_t v78[4];
  __int16 v79;
  void *__dst[2];
  int64_t v81;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E043E8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v69 == 21)
    {
      v70 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v70 && *(_QWORD *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        v79 = 1283;
        v78[0] = (uint64_t)"classof on '";
        v78[2] = (uint64_t)"mps.depthwise_conv_3d";
        v78[3] = 21;
        v76 = "' failed due to the operation not being registered";
        v77 = 259;
        llvm::operator+(v78, (uint64_t *)&v76, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_73:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id)
    goto LABEL_73;
  v75 = a3;
  v78[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v78);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v81 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v81) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v81 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v75);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v74, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v75);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v74, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v75);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v73, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v75);
  v25 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_55;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_55:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_55;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v75);
  v33 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_58;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_58:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_58;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v75);
  v41 = Rewriter;
  if (!Rewriter)
  {
    v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_61:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_61;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v75);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v49, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v49, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v49, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v49, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v49, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v49, PaddingStyle);
  if (v55)
    objc_msgSend(v23, "addObject:", v55);

  LODWORD(v78[0]) = 0;
  LODWORD(v78[0]) = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v75);
  v56 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("channelAxis"), 536870944, &unk_1E0E9A138);
  if (v56)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v78, 4);
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v56, "setValue:", v57);

    objc_msgSend(v23, "addObject:", v56);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v59 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v74);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v73);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v58);
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  v64 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v59, "initWithType:inputs:outputs:properties:regions:", v72, v60, v61, v62, v63);
  v65 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v64;

  v66 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v66);

  if (SHIBYTE(v81) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECD004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler *EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler::MPSDepthwiseConv3DWeightsGradientOpHandler(EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t Bias;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  uint64_t **Strides;
  uint64_t **v27;
  uint64_t InterfaceFor;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  void *v33;
  uint64_t **InputAttributeNames;
  uint64_t **v35;
  uint64_t v36;
  const char *v37;
  int v38;
  const char *v39;
  const char *v40;
  void *v41;
  uint64_t **Rewriter;
  uint64_t **v43;
  uint64_t v44;
  const char *v45;
  int v46;
  const char *v47;
  const char *v48;
  void *v49;
  unsigned int PaddingStyle;
  void *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumSPI *v57;
  MPSGraphViewerNodePropertyDataSPI *v58;
  void *v59;
  void *v60;
  MPSGraphViewerNodeSPI *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  uint64_t v66;
  void *v67;
  void *v68;
  _QWORD *AttrData;
  uint64_t v71;
  BOOL v72;
  BOOL v73;
  BOOL v74;
  void *v76;
  void *v77;
  void *v78;
  mlir::Operation *v79;
  const char *v80;
  __int16 v81;
  uint64_t v82[4];
  __int16 v83;
  void *__dst[2];
  int64_t v85;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04B80;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v71 == 38)
    {
      v72 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      v73 = v72 && AttrData[2] == 0x65775F64335F766ELL;
      v74 = v73 && AttrData[3] == 0x72675F7374686769;
      if (v74 && *(_QWORD *)((char *)AttrData + 30) == 0x746E656964617267)
      {
        v83 = 1283;
        v82[0] = (uint64_t)"classof on '";
        v82[2] = (uint64_t)"mps.depthwise_conv_3d_weights_gradient";
        v82[3] = 38;
        v80 = "' failed due to the operation not being registered";
        v81 = 259;
        llvm::operator+(v82, (uint64_t *)&v80, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_81:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DWeightsGradientOp,void>::id)
    goto LABEL_81;
  v79 = a3;
  v82[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v82);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v85 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v85) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v85 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v76 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v78 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v79);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v78, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v79);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v78, "addObject:", v17);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v79);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("output_shape"), Bias);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v78, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v79);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v77, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v79);
  v27 = Strides;
  if (!Strides)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v30 = 692;
    v31 = "Casting.h";
    v32 = "cast_if_present";
    goto LABEL_57;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v30 = 566;
    v31 = "Casting.h";
    v32 = "cast";
LABEL_57:
    __assert_rtn(v32, v31, v30, v29);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v30 = 98;
    v31 = "InterfaceSupport.h";
    v32 = "Interface";
    goto LABEL_57;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v27, InterfaceFor);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  if (v33)
    objc_msgSend(v25, "addObject:", v33);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v79);
  v35 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v36 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v37 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v38 = 692;
    v39 = "Casting.h";
    v40 = "cast_if_present";
    goto LABEL_60;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35))
  {
    v37 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v38 = 566;
    v39 = "Casting.h";
    v40 = "cast";
LABEL_60:
    __assert_rtn(v40, v39, v38, v37);
  }
  v36 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35);
  if (!v36)
  {
    v37 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v38 = 98;
    v39 = "InterfaceSupport.h";
    v40 = "Interface";
    goto LABEL_60;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v35, v36);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  if (v41)
    objc_msgSend(v25, "addObject:", v41);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v79);
  v43 = Rewriter;
  if (!Rewriter)
  {
    v44 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v45 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v46 = 692;
    v47 = "Casting.h";
    v48 = "cast_if_present";
    goto LABEL_63;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43))
  {
    v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v46 = 566;
    v47 = "Casting.h";
    v48 = "cast";
LABEL_63:
    __assert_rtn(v48, v47, v46, v45);
  }
  v44 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43);
  if (!v44)
  {
    v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v46 = 98;
    v47 = "InterfaceSupport.h";
    v48 = "Interface";
    goto LABEL_63;
  }
LABEL_46:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v43, v44);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  if (v49)
    objc_msgSend(v25, "addObject:", v49);
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v79);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v51, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v51, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v51, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v51, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v51, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v51, PaddingStyle);
  if (v57)
    objc_msgSend(v25, "addObject:", v57);

  LODWORD(v82[0]) = 0;
  LODWORD(v82[0]) = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v79);
  v58 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("channelAxis"), 536870944, &unk_1E0E9A150);
  if (v58)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v82, 4);
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v58, "setValue:", v59);

    objc_msgSend(v25, "addObject:", v58);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  v61 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v78);
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v77);
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v60);
  v65 = (void *)objc_claimAutoreleasedReturnValue();
  v66 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v61, "initWithType:inputs:outputs:properties:regions:", v76, v62, v63, v64, v65);
  v67 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v66;

  v68 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v68);

  if (SHIBYTE(v85) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECDADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDequantizeLUTOpHandler *EmitterViewerSPI::MPSDequantizeLUTOpHandler::MPSDequantizeLUTOpHandler(EmitterViewerSPI::MPSDequantizeLUTOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E040A0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 18)
    {
      v40 = *(_QWORD *)AttrData == 0x757165642E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6C5F657A69746E61;
      if (v40 && *(_WORD *)(AttrData + 16) == 29813)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.dequantize_lut";
        v46[3] = 18;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id)
    goto LABEL_42;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("palette_lut"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v46[0] = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v43);
  if ((v46[0] & 0xFF00000000) != 0)
  {
    v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("axis"), 536870944, &unk_1E0E9A168);
    if (v26)
    {
      if (!BYTE4(v46[0]))
        std::__throw_bad_optional_access[abi:ne180100]();
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 8);
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

      objc_msgSend(v25, "addObject:", v26);
    }

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

    ", -3.0, -2.0].\n"
    "\n"
    "ow on which dim the vector is mapped to. out_shape[axis] = in_shape[axis] * vec_size.\n"
    "\n"
    "Example:\n"
    "\n"
    "0, 3.0, 2.0], [4.5, 1.5, 3.5, 3.5, 2.5]].\n"
    "\n"
    "Conv Weights example:\n"
    "If the weights shape are (O, I, H, W) = (36, 8, 3, 3), and the LUT has 16 entries, each of vec size 2,\n"
    "Then the quantized weights will be of shape (18, 8, 3, 3) and element type ui4 (16 entries).\n"
    "Each quantized entry o set the corresponding weight FP value for the output channels [2*o, 2*o+1].");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECE1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDequantizeOpHandler *EmitterViewerSPI::MPSDequantizeOpHandler::MPSDequantizeOpHandler(EmitterViewerSPI::MPSDequantizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  _QWORD *AttrData;
  uint64_t v43;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03C38;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 14 && *AttrData == 0x757165642E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x657A69746E617571)
    {
      v50 = 1283;
      v49[0] = (uint64_t)"classof on '";
      v49[2] = (uint64_t)"mps.dequantize";
      v49[3] = 14;
      v47 = "' failed due to the operation not being registered";
      v48 = 259;
      llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_43:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
    goto LABEL_43;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("scale"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("zero_point"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("min"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v46);
  v49[0] = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v46);
  if ((v49[0] & 0xFF00000000) != 0)
  {
    v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("axis"), 536870944, &unk_1E0E9A180);
    if (v30)
    {
      if (!BYTE4(v49[0]))
        std::__throw_bad_optional_access[abi:ne180100]();
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v49, 8);
      v31 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

      objc_msgSend(v29, "addObject:", v30);
    }

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v40);

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECE894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDimensionSizeOpHandler *EmitterViewerSPI::MPSDimensionSizeOpHandler::MPSDimensionSizeOpHandler(EmitterViewerSPI::MPSDimensionSizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E040B8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 18)
    {
      v36 = *(_QWORD *)AttrData == 0x656D69642E73706DLL && *(_QWORD *)(AttrData + 8) == 0x69735F6E6F69736ELL;
      if (v36 && *(_WORD *)(AttrData + 16) == 25978)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.dimension_size";
        v42[3] = 18;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DimensionSizeOp,void>::id)
    goto LABEL_36;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v38, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECEE6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180ECEF84(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDiracOpHandler *EmitterViewerSPI::MPSDiracOpHandler::MPSDiracOpHandler(EmitterViewerSPI::MPSDiracOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E031A0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x617269642E73706DLL && *(_BYTE *)(AttrData + 8) == 99)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.dirac";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DiracOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECF3C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDivideOpHandler *EmitterViewerSPI::MPSDivideOpHandler::MPSDivideOpHandler(EmitterViewerSPI::MPSDivideOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E033C8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 10 && *(_QWORD *)AttrData == 0x697669642E73706DLL && *(_WORD *)(AttrData + 8) == 25956)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.divide";
      v43[3] = 10;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECF940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDynamicShapeCastOpHandler *EmitterViewerSPI::MPSDynamicShapeCastOpHandler::MPSDynamicShapeCastOpHandler(EmitterViewerSPI::MPSDynamicShapeCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04580;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 22)
    {
      v40 = *AttrData == 0x616E79642E73706DLL && AttrData[1] == 0x706168735F63696DLL;
      if (v40 && *(_QWORD *)((char *)AttrData + 14) == 0x747361635F657061)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.dynamic_shape_cast";
        v46[3] = 22;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DynamicShapeCastOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("unranked"), 2147483656, &unk_1E0E9A198);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ECFF74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSEluOpHandler *EmitterViewerSPI::MPSEluOpHandler::MPSEluOpHandler(EmitterViewerSPI::MPSEluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _DWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02BE8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970038062)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.elu";
      v43[3] = 7;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::EluOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED0520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSEqualToOpHandler *EmitterViewerSPI::MPSEqualToOpHandler::MPSEqualToOpHandler(EmitterViewerSPI::MPSEqualToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03590;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 9 && *(_QWORD *)AttrData == 0x617571652E73706DLL && *(_BYTE *)(AttrData + 8) == 108)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.equal";
      v43[3] = 9;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::EqualToOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED0AB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSErfOpHandler *EmitterViewerSPI::MPSErfOpHandler::MPSErfOpHandler(EmitterViewerSPI::MPSErfOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _DWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02C00;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1718773038)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.erf";
      v41[3] = 7;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ErfOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED1014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExpandDimsOpHandler *EmitterViewerSPI::MPSExpandDimsOpHandler::MPSExpandDimsOpHandler(EmitterViewerSPI::MPSExpandDimsOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03C50;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 15 && *AttrData == 0x617078652E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x736D69645F646E61)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.expand_dims";
      v43[3] = 15;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Insert a single-dimension at each axis in axes of the result tensor. Valid axis values must be in range - |result| <= axis < |result| |result| = |input| + K, where K = axes.shape[0].");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED15A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExponentBase2OpHandler *EmitterViewerSPI::MPSExponentBase2OpHandler::MPSExponentBase2OpHandler(EmitterViewerSPI::MPSExponentBase2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E040D0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 19)
    {
      v36 = *AttrData == 0x6F7078652E73706DLL && AttrData[1] == 0x7361625F746E656ELL;
      if (v36 && *(_QWORD *)((char *)AttrData + 11) == 0x325F657361625F74)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.exponent_base_2";
        v42[3] = 19;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ExponentBase2Op,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED1B20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExponentBase10OpHandler *EmitterViewerSPI::MPSExponentBase10OpHandler::MPSExponentBase10OpHandler(EmitterViewerSPI::MPSExponentBase10OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04238;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      v36 = *(_QWORD *)AttrData == 0x6F7078652E73706DLL && *(_QWORD *)(AttrData + 8) == 0x7361625F746E656ELL;
      if (v36 && *(_DWORD *)(AttrData + 16) == 808542053)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.exponent_base_10";
        v42[3] = 20;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ExponentBase10Op,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED2080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExponentOpHandler *EmitterViewerSPI::MPSExponentOpHandler::MPSExponentOpHandler(EmitterViewerSPI::MPSExponentOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03848;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(_QWORD *)AttrData == 0x6F7078652E73706DLL && *(_DWORD *)(AttrData + 8) == 1953391982)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.exponent";
      v41[3] = 12;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED25CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSFastFourierTransformOpHandler *EmitterViewerSPI::MPSFastFourierTransformOpHandler::MPSFastFourierTransformOpHandler(EmitterViewerSPI::MPSFastFourierTransformOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  unsigned int Layout;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumSPI *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  uint64_t AttrData;
  uint64_t v45;
  BOOL v46;
  BOOL v47;
  void *v49;
  mlir::Operation *v50;
  const char *v51;
  __int16 v52;
  uint64_t v53[4];
  __int16 v54;
  void *__dst[2];
  int64_t v56;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04880;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 26)
    {
      v46 = *(_QWORD *)AttrData == 0x747361662E73706DLL && *(_QWORD *)(AttrData + 8) == 0x72656972756F665FLL;
      v47 = v46 && *(_QWORD *)(AttrData + 16) == 0x6F66736E6172745FLL;
      if (v47 && *(_WORD *)(AttrData + 24) == 28018)
      {
        v54 = 1283;
        v53[0] = (uint64_t)"classof on '";
        v53[2] = (uint64_t)"mps.fast_fourier_transform";
        v53[3] = 26;
        v51 = "' failed due to the operation not being registered";
        v52 = 259;
        llvm::operator+(v53, (uint64_t *)&v51, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_43:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id)
    goto LABEL_43;
  v50 = a3;
  v53[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v53);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v56 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v56) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v56 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v50);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v50);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v50);
  v21 = CFSTR("output");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v50);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("size"), 1);
  objc_msgSend(v27, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("unitary"), 2);
  objc_msgSend(v27, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("scaling_mode"), CFSTR("MPSFFTScalingMode"), v27, Layout);
  if (v31)
    objc_msgSend(v25, "addObject:", v31);

  LOBYTE(v53[0]) = 0;
  LOBYTE(v53[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v50);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("inverse"), 2147483656, &unk_1E0E9A1B0);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v53, 1);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v25, "addObject:", v32);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v49, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v42);

  if (SHIBYTE(v56) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED2CDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSFlatten2DOpHandler *EmitterViewerSPI::MPSFlatten2DOpHandler::MPSFlatten2DOpHandler(EmitterViewerSPI::MPSFlatten2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03A10;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 14 && *AttrData == 0x74616C662E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x64325F6E65747461)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.flatten_2d";
      v43[3] = 14;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Flatten2DOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED32C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSFloorDivideOpHandler *EmitterViewerSPI::MPSFloorDivideOpHandler::MPSFloorDivideOpHandler(EmitterViewerSPI::MPSFloorDivideOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03D70;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 16 && *AttrData == 0x6F6F6C662E73706DLL && AttrData[1] == 0x6564697669645F72)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.floor_divide";
      v43[3] = 16;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FloorDivideOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED3860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSFloorOpHandler *EmitterViewerSPI::MPSFloorOpHandler::MPSFloorOpHandler(EmitterViewerSPI::MPSFloorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E031B8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x6F6F6C662E73706DLL && *(_BYTE *)(AttrData + 8) == 114)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.floor";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FloorOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED3DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGRUGradientOpHandler *EmitterViewerSPI::MPSGRUGradientOpHandler::MPSGRUGradientOpHandler(EmitterViewerSPI::MPSGRUGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t RecurrentWeight;
  void *v18;
  unint64_t TrainingState;
  void *v20;
  unint64_t OutputCellFwd;
  void *v22;
  unint64_t InputState;
  void *v24;
  unint64_t InputCell;
  void *v26;
  unint64_t Mask;
  void *v28;
  MPSGraphViewerNodePortSPI *v29;
  __CFString *v30;
  uint64_t MPSDataType;
  void *v32;
  MPSGraphViewerNodePortSPI *Element;
  __CFString *v34;
  uint64_t v35;
  void *v36;
  MPSGraphViewerNodePortSPI *GradientInputState;
  __CFString *v38;
  uint64_t v39;
  void *v40;
  uint64_t GradientBias;
  __CFString *v42;
  uint64_t v43;
  void *v44;
  MPSGraphViewerNodePortSPI *v45;
  void *v46;
  unsigned int PaddingStyle;
  void *v48;
  MPSGraphViewerNodePropertyEnumCaseSPI *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumSPI *v55;
  unsigned int v56;
  void *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumSPI *v64;
  unsigned int GateLayout;
  void *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumCaseSPI *v70;
  MPSGraphViewerNodePropertyEnumCaseSPI *v71;
  MPSGraphViewerNodePropertyEnumCaseSPI *v72;
  MPSGraphViewerNodePropertyEnumSPI *v73;
  unsigned int Layout;
  void *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumSPI *v79;
  MPSGraphViewerNodePropertyDataSPI *v80;
  void *v81;
  MPSGraphViewerNodePropertyDataSPI *v82;
  void *v83;
  void *v84;
  MPSGraphViewerNodeSPI *v85;
  void *v86;
  void *v87;
  void *v88;
  void *v89;
  uint64_t v90;
  void *v91;
  void *v92;
  _QWORD *AttrData;
  uint64_t v95;
  void *v97;
  void *v98;
  mlir::Operation *v99;
  uint64_t v100[4];
  __int16 v101;
  uint64_t v102[4];
  __int16 v103;
  void *__dst[2];
  int64_t v105;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03D88;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v95 == 16 && *AttrData == 0x5F7572672E73706DLL && AttrData[1] == 0x746E656964617267)
    {
      v103 = 1283;
      v102[0] = (uint64_t)"classof on '";
      v102[2] = (uint64_t)"mps.gru_gradient";
      v102[3] = 16;
      v100[0] = (uint64_t)"' failed due to the operation not being registered";
      v101 = 259;
      llvm::operator+(v102, v100, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_67:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GRUGradientOp,void>::id)
    goto LABEL_67;
  v99 = a3;
  v102[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v102);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v105 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v105) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v105 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient_input_sequence"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  RecurrentWeight = mlir::mps::LSTMGradientOp::getRecurrentWeight((mlir::mps::LSTMGradientOp *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("recurrent_weight"), RecurrentWeight);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  TrainingState = mlir::mps::LSTMGradientOp::getTrainingState((mlir::mps::LSTMGradientOp *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("training_state"), TrainingState);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  OutputCellFwd = mlir::mps::LSTMGradientOp::getOutputCellFwd((mlir::mps::LSTMGradientOp *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("result_forward"), OutputCellFwd);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);
  InputState = mlir::mps::LSTMGradientOp::getInputState((mlir::mps::LSTMGradientOp *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_state"), InputState);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v24)
    objc_msgSend(v14, "addObject:", v24);

  InputCell = mlir::mps::LSTMGradientOp::getInputCell((mlir::mps::LSTMGradientOp *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("mask"), InputCell);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  if (v26)
    objc_msgSend(v14, "addObject:", v26);

  Mask = mlir::mps::LSTMGradientOp::getMask((mlir::mps::LSTMGradientOp *)&v99);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("bias"), Mask);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  if (v28)
    objc_msgSend(v14, "addObject:", v28);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v99);
  v30 = CFSTR("gradient_output_sequence");
  if (v29)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v29->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v29->_dataType & 0xFFFFFFFFFFFFFFF8));
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v29 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_output_sequence"), MPSDataType, v32, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v29));

    if (v29)
      objc_msgSend(v98, "addObject:", v29);
  }
  else
  {

  }
  Element = (MPSGraphViewerNodePortSPI *)mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v99);
  v34 = CFSTR("gradient_recurrent_weight");
  if (Element)
  {
    v35 = getMPSDataType((_QWORD *)(*(_QWORD *)&Element->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&Element->_dataType & 0xFFFFFFFFFFFFFFF8));
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    Element = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_recurrent_weight"), v35, v36, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, Element));

    if (Element)
      objc_msgSend(v98, "addObject:", Element);
  }
  else
  {

  }
  GradientInputState = (MPSGraphViewerNodePortSPI *)mlir::mps::GRUGradientOp::getGradientInputState((mlir::mps::GRUGradientOp *)&v99);
  v38 = CFSTR("gradient_input_state");
  if (GradientInputState)
  {
    v39 = getMPSDataType((_QWORD *)(*(_QWORD *)&GradientInputState->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&GradientInputState->_dataType & 0xFFFFFFFFFFFFFFF8));
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    GradientInputState = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_input_state"), v39, v40, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, GradientInputState));

    if (GradientInputState)
      objc_msgSend(v98, "addObject:", GradientInputState);
  }
  else
  {

  }
  GradientBias = mlir::mps::GRUGradientOp::getGradientBias((mlir::mps::GRUGradientOp *)&v99);
  v42 = CFSTR("gradient_bias");
  if (GradientBias)
  {
    v43 = getMPSDataType((_QWORD *)(*(_QWORD *)(GradientBias + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(GradientBias + 8) & 0xFFFFFFFFFFFFFFF8));
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    v45 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_bias"), v43, v44, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, GradientBias));

    if (v45)
      objc_msgSend(v98, "addObject:", v45);
  }
  else
  {

    v45 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v99);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  v49 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v48, "addObject:", v49);

  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v48, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v48, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v48, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v48, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v48, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("zgate_activation"), CFSTR("MPSRNNActivation"), v48, PaddingStyle);
  if (v55)
    objc_msgSend(v46, "addObject:", v55);

  v56 = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v99);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v57, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v57, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v57, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v57, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v57, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v57, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("rgate_activation"), CFSTR("MPSRNNActivation"), v57, v56);
  if (v64)
    objc_msgSend(v46, "addObject:", v64);

  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v99);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v66, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v66, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v66, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v66, "addObject:", v70);

  v71 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v66, "addObject:", v71);

  v72 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v66, "addObject:", v72);

  v73 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("ogate_activation"), CFSTR("MPSRNNActivation"), v66, GateLayout);
  if (v73)
    objc_msgSend(v46, "addObject:", v73);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v99);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v75 = (void *)objc_claimAutoreleasedReturnValue();
  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ZRO"), 0);
  objc_msgSend(v75, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("RZO"), 1);
  objc_msgSend(v75, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ROZ"), 2);
  objc_msgSend(v75, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("gate_layout"), CFSTR("MPSGRUGateLayout"), v75, Layout);
  if (v79)
    objc_msgSend(v46, "addObject:", v79);

  LOBYTE(v102[0]) = 0;
  LOBYTE(v102[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v99);
  v80 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("reset_after"), 2147483656, &unk_1E0E9A1C8);
  if (v80)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v102, 1);
    v81 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v80, "setValue:", v81);

    objc_msgSend(v46, "addObject:", v80);
  }
  LOBYTE(v100[0]) = 0;
  LOBYTE(v100[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v99);
  v82 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("flip_z"), 2147483656, &unk_1E0E9A1E0);
  if (v82)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v100, 1);
    v83 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v82, "setValue:", v83);

    objc_msgSend(v46, "addObject:", v82);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  v85 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v98);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v46);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v84);
  v89 = (void *)objc_claimAutoreleasedReturnValue();
  v90 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v85, "initWithType:inputs:outputs:properties:regions:", v97, v86, v87, v88, v89);
  v91 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v90;

  v92 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v92);

  if (SHIBYTE(v105) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED4CA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGRUOpHandler *EmitterViewerSPI::MPSGRUOpHandler::MPSGRUOpHandler(EmitterViewerSPI::MPSGRUOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t RecurrentWeight;
  void *v18;
  unint64_t InputState;
  void *v20;
  unint64_t InputCell;
  void *v22;
  unint64_t Mask;
  void *v24;
  MPSGraphViewerNodePortSPI *v25;
  __CFString *v26;
  uint64_t MPSDataType;
  void *v28;
  uint64_t TrainingState;
  __CFString *v30;
  uint64_t v31;
  void *v32;
  MPSGraphViewerNodePortSPI *v33;
  void *v34;
  unsigned int WeightsLayout;
  void *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumCaseSPI *v39;
  MPSGraphViewerNodePropertyEnumCaseSPI *v40;
  MPSGraphViewerNodePropertyEnumCaseSPI *v41;
  MPSGraphViewerNodePropertyEnumCaseSPI *v42;
  MPSGraphViewerNodePropertyEnumSPI *v43;
  unsigned int PaddingStyle;
  void *v45;
  MPSGraphViewerNodePropertyEnumCaseSPI *v46;
  MPSGraphViewerNodePropertyEnumCaseSPI *v47;
  MPSGraphViewerNodePropertyEnumCaseSPI *v48;
  MPSGraphViewerNodePropertyEnumCaseSPI *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumSPI *v52;
  unsigned int GateLayout;
  void *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumCaseSPI *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumSPI *v61;
  unsigned int Layout;
  void *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumSPI *v67;
  MPSGraphViewerNodePropertyDataSPI *v68;
  void *v69;
  MPSGraphViewerNodePropertyDataSPI *v70;
  void *v71;
  MPSGraphViewerNodePropertyDataSPI *v72;
  void *v73;
  void *v74;
  MPSGraphViewerNodeSPI *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  uint64_t v80;
  void *v81;
  void *v82;
  _DWORD *AttrData;
  uint64_t v85;
  void *v87;
  void *v88;
  BOOL InferredResultTypes;
  mlir::Operation *v90;
  uint64_t v91[4];
  __int16 v92;
  uint64_t v93[4];
  __int16 v94;
  void *__dst[2];
  int64_t v96;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02C18;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v85 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970431790)
    {
      v94 = 1283;
      v93[0] = (uint64_t)"classof on '";
      v93[2] = (uint64_t)"mps.gru";
      v93[3] = 7;
      v91[0] = (uint64_t)"' failed due to the operation not being registered";
      v92 = 259;
      llvm::operator+(v93, v91, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_57:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GRUOp,void>::id)
    goto LABEL_57;
  v90 = a3;
  v93[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v93);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v96 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v96) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v96 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v90);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_sequence"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  RecurrentWeight = mlir::mps::LSTMOp::getRecurrentWeight((mlir::mps::LSTMOp *)&v90);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("recurrent_weight"), RecurrentWeight);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  InputState = mlir::mps::LSTMOp::getInputState((mlir::mps::LSTMOp *)&v90);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_state"), InputState);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  InputCell = mlir::mps::LSTMOp::getInputCell((mlir::mps::LSTMOp *)&v90);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("mask"), InputCell);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  Mask = mlir::mps::LSTMOp::getMask((mlir::mps::LSTMOp *)&v90);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("bias"), Mask);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v24)
    objc_msgSend(v14, "addObject:", v24);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v90);
  v26 = CFSTR("result");
  if (v25)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v25->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v25->_dataType & 0xFFFFFFFFFFFFFFF8));
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v25 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v28, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v25));

    if (v25)
      objc_msgSend(v88, "addObject:", v25);
  }
  else
  {

  }
  TrainingState = mlir::mps::GRUOp::getTrainingState((mlir::mps::GRUOp *)&v90);
  v30 = CFSTR("training_state");
  if (TrainingState)
  {
    v31 = getMPSDataType((_QWORD *)(*(_QWORD *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v33 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("training_state"), v31, v32, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, TrainingState));

    if (v33)
      objc_msgSend(v88, "addObject:", v33);
  }
  else
  {

    v33 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v90);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v36, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v36, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v36, "addObject:", v39);

  v40 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v36, "addObject:", v40);

  v41 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v36, "addObject:", v41);

  v42 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v36, "addObject:", v42);

  v43 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("zgate_activation"), CFSTR("MPSRNNActivation"), v36, WeightsLayout);
  if (v43)
    objc_msgSend(v34, "addObject:", v43);

  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v90);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v45, "addObject:", v46);

  v47 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v45, "addObject:", v47);

  v48 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v45, "addObject:", v48);

  v49 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v45, "addObject:", v49);

  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v45, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v45, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("rgate_activation"), CFSTR("MPSRNNActivation"), v45, PaddingStyle);
  if (v52)
    objc_msgSend(v34, "addObject:", v52);

  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v90);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v54, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v54, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v54, "addObject:", v57);

  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v54, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v54, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v54, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("ogate_activation"), CFSTR("MPSRNNActivation"), v54, GateLayout);
  if (v61)
    objc_msgSend(v34, "addObject:", v61);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v90);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ZRO"), 0);
  objc_msgSend(v63, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("RZO"), 1);
  objc_msgSend(v63, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ROZ"), 2);
  objc_msgSend(v63, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("gate_layout"), CFSTR("MPSGRUGateLayout"), v63, Layout);
  if (v67)
    objc_msgSend(v34, "addObject:", v67);

  LOBYTE(v93[0]) = 0;
  LOBYTE(v93[0]) = mlir::mps::GRUOp::getTraining((mlir::mps::GRUOp *)&v90);
  v68 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("training"), 2147483656, &unk_1E0E9A1F8);
  if (v68)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v93, 1);
    v69 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v68, "setValue:", v69);

    objc_msgSend(v34, "addObject:", v68);
  }
  LOBYTE(v91[0]) = 0;
  LOBYTE(v91[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v90);
  v70 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("reset_after"), 2147483656, &unk_1E0E9A210);
  if (v70)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v91, 1);
    v71 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v70, "setValue:", v71);

    objc_msgSend(v34, "addObject:", v70);
  }
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v90);
  v72 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("flip_z"), 2147483656, &unk_1E0E9A228);
  if (v72)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &InferredResultTypes, 1);
    v73 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v72, "setValue:", v73);

    objc_msgSend(v34, "addObject:", v72);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  v75 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v76 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v88);
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v78 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v74);
  v79 = (void *)objc_claimAutoreleasedReturnValue();
  v80 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v75, "initWithType:inputs:outputs:properties:regions:", v87, v76, v77, v78, v79);
  v81 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v80;

  v82 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v82);

  if (SHIBYTE(v96) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED5C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGatherAlongAxisOpHandler *EmitterViewerSPI::MPSGatherAlongAxisOpHandler::MPSGatherAlongAxisOpHandler(EmitterViewerSPI::MPSGatherAlongAxisOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04400;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 21)
    {
      v42 = *AttrData == 0x687461672E73706DLL && AttrData[1] == 0x676E6F6C615F7265;
      if (v42 && *(_QWORD *)((char *)AttrData + 13) == 0x736978615F676E6FLL)
      {
        v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.gather_along_axis";
        v48[3] = 21;
        v46 = "' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GatherAlongAxisOp,void>::id)
    goto LABEL_40;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("updates"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("indices"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("allow_negative_indices"), 2147483656, &unk_1E0E9A240);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v27, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v44, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED6464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGatherNDOpHandler *EmitterViewerSPI::MPSGatherNDOpHandler::MPSGatherNDOpHandler(EmitterViewerSPI::MPSGatherNDOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  _QWORD *AttrData;
  uint64_t v40;
  void *v42;
  mlir::Operation *v43;
  uint64_t v44[4];
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03860;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 13 && *AttrData == 0x687461672E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x646E5F7265687461)
    {
      v47 = 1283;
      v46[0] = (uint64_t)"classof on '";
      v46[2] = (uint64_t)"mps.gather_nd";
      v46[3] = 13;
      v44[0] = (uint64_t)"' failed due to the operation not being registered";
      v45 = 259;
      llvm::operator+(v46, v44, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GatherNDOp,void>::id)
    goto LABEL_37;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("updates"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("indices"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v46[0]) = 0;
  LODWORD(v46[0]) = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("batch_dims"), 32, &unk_1E0E9A258);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 4);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v44[0]) = 0;
  LOBYTE(v44[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("allow_negative_indices"), 2147483656, &unk_1E0E9A270);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v44, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v42, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED6AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180ED6C3C()
{
  JUMPOUT(0x180ED6C08);
}

void sub_180ED6C44(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGatherOpHandler *EmitterViewerSPI::MPSGatherOpHandler::MPSGatherOpHandler(EmitterViewerSPI::MPSGatherOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  uint64_t AttrData;
  uint64_t v43;
  void *v45;
  mlir::Operation *v46;
  uint64_t v47[4];
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E033E0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 10 && *(_QWORD *)AttrData == 0x687461672E73706DLL && *(_WORD *)(AttrData + 8) == 29285)
    {
      v50 = 1283;
      v49[0] = (uint64_t)"classof on '";
      v49[2] = (uint64_t)"mps.gather";
      v49[3] = 10;
      v47[0] = (uint64_t)"' failed due to the operation not being registered";
      v48 = 259;
      llvm::operator+(v49, v47, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GatherOp,void>::id)
    goto LABEL_39;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("updates"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("indices"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v49[0]) = 0;
  LODWORD(v49[0]) = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v46);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("batch_dims"), 32, &unk_1E0E9A288);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v49, 4);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v27, "addObject:", v28);
  }
  LOBYTE(v47[0]) = 0;
  LOBYTE(v47[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v46);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("allow_negative_indices"), 2147483656, &unk_1E0E9A2A0);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v47, 1);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v27, "addObject:", v30);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v40);

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED71DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGeluOpHandler *EmitterViewerSPI::MPSGeluOpHandler::MPSGeluOpHandler(EmitterViewerSPI::MPSGeluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02EB8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x756C65672E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.gelu";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GeluOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED7784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGetCoordOpHandler *EmitterViewerSPI::MPSGetCoordOpHandler::MPSGetCoordOpHandler(EmitterViewerSPI::MPSGetCoordOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03878;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 19)
    {
      v38 = *AttrData == 0x5F7465672E73706DLL && AttrData[1] == 0x616E6964726F6F63;
      if (v38 && *(_QWORD *)((char *)AttrData + 11) == 0x736574616E696472)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"mps.get_coordinates";
        v44[3] = 19;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GetCoordOp,void>::id)
    goto LABEL_36;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::mps::GetCoordOp::getResultType((mlir::mps::GetCoordOp *)&v41);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v40, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "The generated values start from zero on a given axis and increase with stride of one along that axis.");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED7D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGreaterThanOpHandler *EmitterViewerSPI::MPSGreaterThanOpHandler::MPSGreaterThanOpHandler(EmitterViewerSPI::MPSGreaterThanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03DA0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x616572672E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x726574616572672ELL)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.greater";
      v43[3] = 11;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED82D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler *EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler::MPSGreaterThanOrEqualToOpHandler(EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04898;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 17)
    {
      v38 = *(_QWORD *)AttrData == 0x616572672E73706DLL && *(_QWORD *)(AttrData + 8) == 0x617571655F726574;
      if (v38 && *(_BYTE *)(AttrData + 16) == 108)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"mps.greater_equal";
        v44[3] = 17;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOrEqualToOp,void>::id)
    goto LABEL_36;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v40, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED8884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSHammingDistanceOpHandler *EmitterViewerSPI::MPSHammingDistanceOpHandler::MPSHammingDistanceOpHandler(EmitterViewerSPI::MPSHammingDistanceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04418;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 20)
    {
      v38 = *(_QWORD *)AttrData == 0x6D6D61682E73706DLL && *(_QWORD *)(AttrData + 8) == 0x747369645F676E69;
      if (v38 && *(_DWORD *)(AttrData + 16) == 1701015137)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"mps.hamming_distance";
        v44[3] = 20;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::HammingDistanceOp,void>::id)
    goto LABEL_36;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v41);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v40, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED8E3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler *EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler::MPSHermiteanToRealFFTOpHandler(EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  unsigned int GateLayout;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumSPI *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  MPSGraphViewerNodePropertyDataSPI *v34;
  void *v35;
  void *v36;
  MPSGraphViewerNodeSPI *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  void *v43;
  void *v44;
  uint64_t AttrData;
  uint64_t v47;
  BOOL v48;
  BOOL v49;
  void *v51;
  mlir::Operation *v52;
  uint64_t v53[4];
  __int16 v54;
  uint64_t v55[4];
  __int16 v56;
  void *__dst[2];
  int64_t v58;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04748;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v47 == 25)
    {
      v48 = *(_QWORD *)AttrData == 0x6D7265682E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6F745F6E61657469;
      v49 = v48 && *(_QWORD *)(AttrData + 16) == 0x66665F6C6165725FLL;
      if (v49 && *(_BYTE *)(AttrData + 24) == 116)
      {
        v56 = 1283;
        v55[0] = (uint64_t)"classof on '";
        v55[2] = (uint64_t)"mps.hermitean_to_real_fft";
        v55[3] = 25;
        v53[0] = (uint64_t)"' failed due to the operation not being registered";
        v54 = 259;
        llvm::operator+(v55, v53, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::HermiteanToRealFFTOp,void>::id)
    goto LABEL_45;
  v52 = a3;
  v55[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v55);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v58 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v58) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v58 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v52);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v52);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v52);
  v21 = CFSTR("output");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v52);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("size"), 1);
  objc_msgSend(v27, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("unitary"), 2);
  objc_msgSend(v27, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("scaling_mode"), CFSTR("MPSFFTScalingMode"), v27, GateLayout);
  if (v31)
    objc_msgSend(v25, "addObject:", v31);

  LOBYTE(v55[0]) = 0;
  LOBYTE(v55[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v52);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("inverse"), 2147483656, &unk_1E0E9A2B8);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v55, 1);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v25, "addObject:", v32);
  }
  LOBYTE(v53[0]) = 0;
  LOBYTE(v53[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v52);
  v34 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("round_to_odd"), 2147483656, &unk_1E0E9A2D0);
  if (v34)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v53, 1);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v34, "setValue:", v35);

    objc_msgSend(v25, "addObject:", v34);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v36);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  v42 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v37, "initWithType:inputs:outputs:properties:regions:", v51, v38, v39, v40, v41);
  v43 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v42;

  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v44);

  if (SHIBYTE(v58) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED95E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSIdentityOpHandler *EmitterViewerSPI::MPSIdentityOpHandler::MPSIdentityOpHandler(EmitterViewerSPI::MPSIdentityOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03890;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(_QWORD *)AttrData == 0x6E6564692E73706DLL && *(_DWORD *)(AttrData + 8) == 2037672308)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.identity";
      v41[3] = 12;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::IdentityOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Returns a tensor with the same shape and contents as input.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180ED9BA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSImToColOpHandler *EmitterViewerSPI::MPSImToColOpHandler::MPSImToColOpHandler(EmitterViewerSPI::MPSImToColOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  MPSGraphViewerNodePortSPI *v16;
  __CFString *v17;
  uint64_t MPSDataType;
  void *v19;
  void *v20;
  uint64_t **KernelSizes;
  uint64_t **v22;
  uint64_t InterfaceFor;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  void *v28;
  uint64_t **Strides;
  uint64_t **v30;
  uint64_t v31;
  const char *v32;
  int v33;
  const char *v34;
  const char *v35;
  void *v36;
  uint64_t **InputAttributeNames;
  uint64_t **v38;
  uint64_t v39;
  const char *v40;
  int v41;
  const char *v42;
  const char *v43;
  void *v44;
  uint64_t **Rewriter;
  uint64_t **v46;
  uint64_t v47;
  const char *v48;
  int v49;
  const char *v50;
  const char *v51;
  void *v52;
  unsigned int StorageType;
  void *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumCaseSPI *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumSPI *v66;
  void *v67;
  MPSGraphViewerNodeSPI *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  void *v75;
  _QWORD *AttrData;
  uint64_t v78;
  void *v80;
  void *v81;
  void *v82;
  mlir::Operation *v83;
  const char *v84;
  __int16 v85;
  uint64_t v86[4];
  __int16 v87;
  void *__dst[2];
  int64_t v89;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E035C0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v78 == 13 && *AttrData == 0x745F6D692E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x6C6F635F6F745F6DLL)
    {
      v87 = 1283;
      v86[0] = (uint64_t)"classof on '";
      v86[2] = (uint64_t)"mps.im_to_col";
      v86[3] = 13;
      v84 = "' failed due to the operation not being registered";
      v85 = 259;
      llvm::operator+(v86, (uint64_t *)&v84, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_77:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ImToColOp,void>::id)
    goto LABEL_77;
  v83 = a3;
  v86[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v86);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v89 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v89) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v89 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v83);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v82, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v83);
  v17 = CFSTR("result");
  if (v16)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v16->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v16->_dataType & 0xFFFFFFFFFFFFFFF8));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v16 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v19, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v16));

    if (v16)
      objc_msgSend(v81, "addObject:", v16);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  KernelSizes = (uint64_t **)mlir::mps::ColToImOp::getKernelSizes((mlir::mps::ColToImOp *)&v83);
  v22 = KernelSizes;
  if (!KernelSizes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelSizes))
  {
    v24 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v25 = 692;
    v26 = "Casting.h";
    v27 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v22))
  {
    v24 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v25 = 566;
    v26 = "Casting.h";
    v27 = "cast";
LABEL_59:
    __assert_rtn(v27, v26, v25, v24);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v22);
  if (!InterfaceFor)
  {
    v24 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v25 = 98;
    v26 = "InterfaceSupport.h";
    v27 = "Interface";
    goto LABEL_59;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_sizes"), (uint64_t)v22, InterfaceFor);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  if (v28)
    objc_msgSend(v20, "addObject:", v28);
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v83);
  v30 = Strides;
  if (!Strides)
  {
    v31 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v32 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v33 = 692;
    v34 = "Casting.h";
    v35 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v30))
  {
    v32 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v33 = 566;
    v34 = "Casting.h";
    v35 = "cast";
LABEL_62:
    __assert_rtn(v35, v34, v33, v32);
  }
  v31 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v30);
  if (!v31)
  {
    v32 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v33 = 98;
    v34 = "InterfaceSupport.h";
    v35 = "Interface";
    goto LABEL_62;
  }
LABEL_34:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v30, v31);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  if (v36)
    objc_msgSend(v20, "addObject:", v36);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v83);
  v38 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v39 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v40 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v41 = 692;
    v42 = "Casting.h";
    v43 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v38))
  {
    v40 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v41 = 566;
    v42 = "Casting.h";
    v43 = "cast";
LABEL_65:
    __assert_rtn(v43, v42, v41, v40);
  }
  v39 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v38);
  if (!v39)
  {
    v40 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v41 = 98;
    v42 = "InterfaceSupport.h";
    v43 = "Interface";
    goto LABEL_65;
  }
LABEL_42:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v38, v39);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  if (v44)
    objc_msgSend(v20, "addObject:", v44);
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v83);
  v46 = Rewriter;
  if (!Rewriter)
  {
    v47 = 0;
    goto LABEL_50;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v48 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v49 = 692;
    v50 = "Casting.h";
    v51 = "cast_if_present";
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v46))
  {
    v48 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v49 = 566;
    v50 = "Casting.h";
    v51 = "cast";
LABEL_68:
    __assert_rtn(v51, v50, v49, v48);
  }
  v47 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v46);
  if (!v47)
  {
    v48 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v49 = 98;
    v50 = "InterfaceSupport.h";
    v51 = "Interface";
    goto LABEL_68;
  }
LABEL_50:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v46, v47);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  if (v52)
    objc_msgSend(v20, "addObject:", v52);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v83);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v54, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v54, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v54, "addObject:", v57);

  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v54, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v54, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v54, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v54, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v54, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v54, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v54, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v54, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v54, StorageType);
  if (v66)
    objc_msgSend(v20, "addObject:", v66);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  v68 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v82);
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v81);
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v20);
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v67);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v68, "initWithType:inputs:outputs:properties:regions:", v80, v69, v70, v71, v72);
  v74 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v73;

  v75 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v75);

  if (SHIBYTE(v89) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDA688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSImaginaryPartOpHandler *EmitterViewerSPI::MPSImaginaryPartOpHandler::MPSImaginaryPartOpHandler(EmitterViewerSPI::MPSImaginaryPartOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E040E8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 18)
    {
      v36 = *(_QWORD *)AttrData == 0x67616D692E73706DLL && *(_QWORD *)(AttrData + 8) == 0x61705F7972616E69;
      if (v36 && *(_WORD *)(AttrData + 16) == 29810)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.imaginary_part";
        v42[3] = 18;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ImaginaryPartOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("output");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Extracts the imaginary part of the input tensor.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDAC90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler *EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler::MPSInitRandomPhiloxStateOpHandler(EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  BOOL v41;
  void *v43;
  mlir::Operation *v44;
  const char *v45;
  __int16 v46;
  uint64_t v47[4];
  __int16 v48;
  void *__dst[2];
  int64_t v50;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04970;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 28)
    {
      v40 = *(_QWORD *)AttrData == 0x74696E692E73706DLL && *(_QWORD *)(AttrData + 8) == 0x5F6D6F646E61725FLL;
      v41 = v40 && *(_QWORD *)(AttrData + 16) == 0x735F786F6C696870;
      if (v41 && *(_DWORD *)(AttrData + 24) == 1702125940)
      {
        v48 = 1283;
        v47[0] = (uint64_t)"classof on '";
        v47[2] = (uint64_t)"mps.init_random_philox_state";
        v47[3] = 28;
        v45 = "' failed due to the operation not being registered";
        v46 = 259;
        llvm::operator+(v47, (uint64_t *)&v45, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::InitRandomPhiloxStateOp,void>::id)
    goto LABEL_41;
  v44 = a3;
  v47[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v50 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("counter_low"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("counter_high"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("key"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v43, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v50) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDB278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSInstanceNormOpHandler *EmitterViewerSPI::MPSInstanceNormOpHandler::MPSInstanceNormOpHandler(EmitterViewerSPI::MPSInstanceNormOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  llvm::APFloatBase *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  void *__dst[2];
  const char *v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  void *v53;
  _QWORD v54[4];

  v54[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03EA8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v52 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
    if (v41 == 17)
    {
      v42 = *(_QWORD *)AttrData == 0x74736E692E73706DLL && *(_QWORD *)(AttrData + 8) == 0x726F6E5F65636E61;
      if (v42 && *(_BYTE *)(AttrData + 16) == 109)
      {
        v51 = 1283;
        __dst[0] = "classof on '";
        v49 = "mps.instance_norm";
        v50 = 17;
        v46 = "' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+((uint64_t *)__dst, (uint64_t *)&v46, (uint64_t)&v52);
        llvm::report_fatal_error((llvm::Twine *)&v52, 1);
      }
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::InstanceNormOp,void>::id)
    goto LABEL_41;
  v45 = a3;
  v52 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v49) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v45, (uint64_t)&v52);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("epsilon"), 268435488, &unk_1E0E9A2E8);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v52, 32);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  v28 = v53;
  if (llvm::APFloatBase::PPCDoubleDouble(v29) == v28)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v54);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v53);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v44, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDB90C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSIsFiniteOpHandler *EmitterViewerSPI::MPSIsFiniteOpHandler::MPSIsFiniteOpHandler(EmitterViewerSPI::MPSIsFiniteOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E038A8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x665F73692E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x6574696E69665F73)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.is_finite";
      v41[3] = 13;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::IsFiniteOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDBE94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSIsInfiniteOpHandler *EmitterViewerSPI::MPSIsInfiniteOpHandler::MPSIsInfiniteOpHandler(EmitterViewerSPI::MPSIsInfiniteOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03C68;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 15 && *AttrData == 0x695F73692E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x6574696E69666E69)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.is_infinite";
      v41[3] = 15;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::IsInfiniteOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDC3E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSIsNaNOpHandler *EmitterViewerSPI::MPSIsNaNOpHandler::MPSIsNaNOpHandler(EmitterViewerSPI::MPSIsNaNOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E031D0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 10 && *(_QWORD *)AttrData == 0x6E5F73692E73706DLL && *(_WORD *)(AttrData + 8) == 28257)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.is_nan";
      v41[3] = 10;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::IsNaNOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDC930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLPNormOpHandler *EmitterViewerSPI::MPSLPNormOpHandler::MPSLPNormOpHandler(EmitterViewerSPI::MPSLPNormOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  void *v28;
  void *v29;
  MPSGraphViewerNodeSPI *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  uint64_t v35;
  void *v36;
  void *v37;
  _QWORD *AttrData;
  uint64_t v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E033F8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 11 && *AttrData == 0x6E5F706C2E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6D726F6E5F706C2ELL)
    {
      v47 = 1283;
      v46[0] = (uint64_t)"classof on '";
      v46[2] = (uint64_t)"mps.lp_norm";
      v46[3] = 11;
      v44 = "' failed due to the operation not being registered";
      v45 = 259;
      llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LPNormOp,void>::id)
    goto LABEL_37;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("p"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("epsilon"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v24)
      objc_msgSend(v23, "addObject:", v24);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v30, "initWithType:inputs:outputs:properties:regions:", v42, v31, v32, v33, v34);
  v36 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v35;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Computes x = x / ||x||_{p} elementwise, where:\n* ||x||_{p} =\n(pow(pow(abs(x0), p) + pow(abs(x1), p) + ... + pow(abs(xn), p), 1/p);\n"
    "\n"
    "* p > 0.");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v37);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDCF28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLSTMGradientOpHandler *EmitterViewerSPI::MPSLSTMGradientOpHandler::MPSLSTMGradientOpHandler(EmitterViewerSPI::MPSLSTMGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void *v13;
  unint64_t Input;
  void *v15;
  unint64_t RecurrentWeight;
  void *v17;
  unint64_t TrainingState;
  void *v19;
  unint64_t OutputCellFwd;
  void *v21;
  unint64_t InputState;
  void *v23;
  unint64_t InputCell;
  void *v25;
  unint64_t Mask;
  void *v27;
  unint64_t Peephole;
  void *v29;
  unint64_t CellClip;
  void *v31;
  unint64_t CellGradient;
  void *v33;
  uint64_t v34;
  __CFString *v35;
  uint64_t MPSDataType;
  void *v37;
  MPSGraphViewerNodePortSPI *v38;
  uint64_t Element;
  __CFString *v40;
  uint64_t v41;
  void *v42;
  MPSGraphViewerNodePortSPI *v43;
  uint64_t GradientInputState;
  __CFString *v45;
  uint64_t v46;
  void *v47;
  MPSGraphViewerNodePortSPI *v48;
  MPSGraphViewerNodePortSPI *GradientInputCell;
  __CFString *v50;
  uint64_t v51;
  void *v52;
  MPSGraphViewerNodePortSPI *GradientPeephole;
  __CFString *v54;
  uint64_t v55;
  void *v56;
  void *v57;
  unsigned int PaddingStyle;
  void *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumSPI *v66;
  unsigned int Layout;
  void *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumCaseSPI *v70;
  MPSGraphViewerNodePropertyEnumCaseSPI *v71;
  MPSGraphViewerNodePropertyEnumCaseSPI *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumSPI *v75;
  unsigned int v76;
  void *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumSPI *v84;
  unsigned int v85;
  void *v86;
  MPSGraphViewerNodePropertyEnumCaseSPI *v87;
  MPSGraphViewerNodePropertyEnumCaseSPI *v88;
  MPSGraphViewerNodePropertyEnumCaseSPI *v89;
  MPSGraphViewerNodePropertyEnumCaseSPI *v90;
  MPSGraphViewerNodePropertyEnumCaseSPI *v91;
  MPSGraphViewerNodePropertyEnumCaseSPI *v92;
  MPSGraphViewerNodePropertyEnumSPI *v93;
  unsigned int StorageType;
  void *v95;
  MPSGraphViewerNodePropertyEnumCaseSPI *v96;
  MPSGraphViewerNodePropertyEnumCaseSPI *v97;
  MPSGraphViewerNodePropertyEnumCaseSPI *v98;
  MPSGraphViewerNodePropertyEnumCaseSPI *v99;
  MPSGraphViewerNodePropertyEnumCaseSPI *v100;
  MPSGraphViewerNodePropertyEnumCaseSPI *v101;
  MPSGraphViewerNodePropertyEnumSPI *v102;
  unsigned int GateLayout;
  void *v104;
  MPSGraphViewerNodePropertyEnumCaseSPI *v105;
  MPSGraphViewerNodePropertyEnumCaseSPI *v106;
  MPSGraphViewerNodePropertyEnumCaseSPI *v107;
  MPSGraphViewerNodePropertyEnumCaseSPI *v108;
  MPSGraphViewerNodePropertyEnumSPI *v109;
  void *v110;
  MPSGraphViewerNodeSPI *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  uint64_t v116;
  void *v117;
  void *v118;
  uint64_t AttrData;
  uint64_t v121;
  BOOL v122;
  void *v124;
  void *v126;
  mlir::Operation *v127;
  const char *v128;
  __int16 v129;
  uint64_t v130[4];
  __int16 v131;
  void *__dst[2];
  int64_t v133;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03EC0;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v121 == 17)
    {
      v122 = *(_QWORD *)AttrData == 0x6D74736C2E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6E6569646172675FLL;
      if (v122 && *(_BYTE *)(AttrData + 16) == 116)
      {
        v131 = 1283;
        v130[0] = (uint64_t)"classof on '";
        v130[2] = (uint64_t)"mps.lstm_gradient";
        v130[3] = 17;
        v128 = "' failed due to the operation not being registered";
        v129 = 259;
        llvm::operator+(v130, (uint64_t *)&v128, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_80:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGradientOp,void>::id)
    goto LABEL_80;
  v127 = a3;
  v130[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v130);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v133 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v133) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v133 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v124 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient_input_sequence"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v13, "addObject:", v15);
  RecurrentWeight = mlir::mps::LSTMGradientOp::getRecurrentWeight((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("recurrent_weight"), RecurrentWeight);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v13, "addObject:", v17);
  TrainingState = mlir::mps::LSTMGradientOp::getTrainingState((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("training_state"), TrainingState);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v13, "addObject:", v19);
  OutputCellFwd = mlir::mps::LSTMGradientOp::getOutputCellFwd((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("output_cell_fwd"), OutputCellFwd);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  if (v21)
    objc_msgSend(v13, "addObject:", v21);
  InputState = mlir::mps::LSTMGradientOp::getInputState((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_state"), InputState);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  if (v23)
    objc_msgSend(v13, "addObject:", v23);

  InputCell = mlir::mps::LSTMGradientOp::getInputCell((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_cell"), InputCell);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  if (v25)
    objc_msgSend(v13, "addObject:", v25);

  Mask = mlir::mps::LSTMGradientOp::getMask((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("mask"), Mask);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  if (v27)
    objc_msgSend(v13, "addObject:", v27);

  Peephole = mlir::mps::LSTMGradientOp::getPeephole((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("peephole"), Peephole);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  if (v29)
    objc_msgSend(v13, "addObject:", v29);

  CellClip = mlir::mps::LSTMGradientOp::getCellClip((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("cell_clip"), CellClip);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v13, "addObject:", v31);

  CellGradient = mlir::mps::LSTMGradientOp::getCellGradient((mlir::mps::LSTMGradientOp *)&v127);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("cell_gradient"), CellGradient);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  if (v33)
    objc_msgSend(v13, "addObject:", v33);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v126 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v127);
  v35 = CFSTR("gradient_output_sequence");
  if (v34)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v34 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v34 + 8) & 0xFFFFFFFFFFFFFFF8));
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    v38 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_output_sequence"), MPSDataType, v37, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v34));

    if (v38)
      objc_msgSend(v126, "addObject:", v38);
  }
  else
  {

    v38 = 0;
  }
  Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v127);
  v40 = CFSTR("gradient_recurrent_weight");
  if (Element)
  {
    v41 = getMPSDataType((_QWORD *)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    v43 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_recurrent_weight"), v41, v42, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Element));

    if (v43)
      objc_msgSend(v126, "addObject:", v43);
  }
  else
  {

    v43 = 0;
  }
  GradientInputState = mlir::mps::GRUGradientOp::getGradientInputState((mlir::mps::GRUGradientOp *)&v127);
  v45 = CFSTR("gradient_input_state");
  if (GradientInputState)
  {
    v46 = getMPSDataType((_QWORD *)(*(_QWORD *)(GradientInputState + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(GradientInputState + 8) & 0xFFFFFFFFFFFFFFF8));
    v47 = (void *)objc_claimAutoreleasedReturnValue();
    v48 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_input_state"), v46, v47, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, GradientInputState));

    if (v48)
      objc_msgSend(v126, "addObject:", v48);
  }
  else
  {

    v48 = 0;
  }
  GradientInputCell = (MPSGraphViewerNodePortSPI *)mlir::mps::LSTMGradientOp::getGradientInputCell((mlir::mps::LSTMGradientOp *)&v127);
  v50 = CFSTR("gradient_input_cell");
  if (GradientInputCell)
  {
    v51 = getMPSDataType((_QWORD *)(*(_QWORD *)&GradientInputCell->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&GradientInputCell->_dataType & 0xFFFFFFFFFFFFFFF8));
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    GradientInputCell = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_input_cell"), v51, v52, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, GradientInputCell));

    if (GradientInputCell)
      objc_msgSend(v126, "addObject:", GradientInputCell);
  }
  else
  {

  }
  GradientPeephole = (MPSGraphViewerNodePortSPI *)mlir::mps::LSTMGradientOp::getGradientPeephole((mlir::mps::LSTMGradientOp *)&v127);
  v54 = CFSTR("gradient_peephole");
  if (GradientPeephole)
  {
    v55 = getMPSDataType((_QWORD *)(*(_QWORD *)&GradientPeephole->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&GradientPeephole->_dataType & 0xFFFFFFFFFFFFFFF8));
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    GradientPeephole = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_peephole"), v55, v56, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, GradientPeephole));

    if (GradientPeephole)
      objc_msgSend(v126, "addObject:", GradientPeephole);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v127);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v59, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v59, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v59, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v59, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v59, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v59, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("igate_activation"), CFSTR("MPSRNNActivation"), v59, PaddingStyle);
  if (v66)
    objc_msgSend(v57, "addObject:", v66);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v127);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v68 = (void *)objc_claimAutoreleasedReturnValue();
  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v68, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v68, "addObject:", v70);

  v71 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v68, "addObject:", v71);

  v72 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v68, "addObject:", v72);

  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v68, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v68, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("fgate_activation"), CFSTR("MPSRNNActivation"), v68, Layout);
  if (v75)
    objc_msgSend(v57, "addObject:", v75);

  v76 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v127);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v77, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v77, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v77, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v77, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v77, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v77, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("zgate_activation"), CFSTR("MPSRNNActivation"), v77, v76);
  if (v84)
    objc_msgSend(v57, "addObject:", v84);

  v85 = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v127);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v87 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v86, "addObject:", v87);

  v88 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v86, "addObject:", v88);

  v89 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v86, "addObject:", v89);

  v90 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v86, "addObject:", v90);

  v91 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v86, "addObject:", v91);

  v92 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v86, "addObject:", v92);

  v93 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("ogate_activation"), CFSTR("MPSRNNActivation"), v86, v85);
  if (v93)
    objc_msgSend(v57, "addObject:", v93);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v127);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v95 = (void *)objc_claimAutoreleasedReturnValue();
  v96 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v95, "addObject:", v96);

  v97 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v95, "addObject:", v97);

  v98 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v95, "addObject:", v98);

  v99 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v95, "addObject:", v99);

  v100 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v95, "addObject:", v100);

  v101 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v95, "addObject:", v101);

  v102 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("cell_activation"), CFSTR("MPSRNNActivation"), v95, StorageType);
  if (v102)
    objc_msgSend(v57, "addObject:", v102);

  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v127);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  v105 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("IFZO"), 0);
  objc_msgSend(v104, "addObject:", v105);

  v106 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("IZFO"), 1);
  objc_msgSend(v104, "addObject:", v106);

  v107 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("IFOZ"), 2);
  objc_msgSend(v104, "addObject:", v107);

  v108 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("IOFZ"), 3);
  objc_msgSend(v104, "addObject:", v108);

  v109 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("gate_layout"), CFSTR("MPSLSTMGateLayout"), v104, GateLayout);
  if (v109)
    objc_msgSend(v57, "addObject:", v109);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v110 = (void *)objc_claimAutoreleasedReturnValue();
  v111 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v13);
  v112 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v126);
  v113 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v57);
  v114 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v110);
  v115 = (void *)objc_claimAutoreleasedReturnValue();
  v116 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v111, "initWithType:inputs:outputs:properties:regions:", v124, v112, v113, v114, v115);
  v117 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v116;

  v118 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v118);

  if (SHIBYTE(v133) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDE1C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLSTMOpHandler *EmitterViewerSPI::MPSLSTMOpHandler::MPSLSTMOpHandler(EmitterViewerSPI::MPSLSTMOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t RecurrentWeight;
  void *v17;
  unint64_t InputState;
  void *v19;
  unint64_t InputCell;
  void *v21;
  unint64_t Mask;
  void *v23;
  unint64_t Peephole;
  void *v25;
  unint64_t CellClip;
  void *v27;
  uint64_t v28;
  __CFString *v29;
  uint64_t MPSDataType;
  void *v31;
  MPSGraphViewerNodePortSPI *v32;
  uint64_t Element;
  __CFString *v34;
  uint64_t v35;
  void *v36;
  MPSGraphViewerNodePortSPI *v37;
  uint64_t TrainingState;
  __CFString *v39;
  uint64_t v40;
  void *v41;
  MPSGraphViewerNodePortSPI *v42;
  void *v43;
  unsigned int PaddingStyle;
  void *v45;
  MPSGraphViewerNodePropertyEnumCaseSPI *v46;
  MPSGraphViewerNodePropertyEnumCaseSPI *v47;
  MPSGraphViewerNodePropertyEnumCaseSPI *v48;
  MPSGraphViewerNodePropertyEnumCaseSPI *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumSPI *v52;
  unsigned int Layout;
  void *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumCaseSPI *v57;
  MPSGraphViewerNodePropertyEnumCaseSPI *v58;
  MPSGraphViewerNodePropertyEnumCaseSPI *v59;
  MPSGraphViewerNodePropertyEnumCaseSPI *v60;
  MPSGraphViewerNodePropertyEnumSPI *v61;
  unsigned int WeightsLayout;
  void *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumCaseSPI *v67;
  MPSGraphViewerNodePropertyEnumCaseSPI *v68;
  MPSGraphViewerNodePropertyEnumCaseSPI *v69;
  MPSGraphViewerNodePropertyEnumSPI *v70;
  unsigned int v71;
  void *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumSPI *v79;
  unsigned int StorageType;
  void *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumCaseSPI *v84;
  MPSGraphViewerNodePropertyEnumCaseSPI *v85;
  MPSGraphViewerNodePropertyEnumCaseSPI *v86;
  MPSGraphViewerNodePropertyEnumCaseSPI *v87;
  MPSGraphViewerNodePropertyEnumSPI *v88;
  unsigned int GateLayout;
  void *v90;
  MPSGraphViewerNodePropertyEnumCaseSPI *v91;
  MPSGraphViewerNodePropertyEnumCaseSPI *v92;
  MPSGraphViewerNodePropertyEnumCaseSPI *v93;
  MPSGraphViewerNodePropertyEnumCaseSPI *v94;
  MPSGraphViewerNodePropertyEnumSPI *v95;
  MPSGraphViewerNodePropertyDataSPI *v96;
  void *v97;
  void *v98;
  MPSGraphViewerNodeSPI *v99;
  void *v100;
  void *v101;
  void *v102;
  void *v103;
  uint64_t v104;
  void *v105;
  void *v106;
  _QWORD *AttrData;
  uint64_t v109;
  void *v110;
  void *v111;
  void *v112;
  mlir::Operation *v113;
  const char *v114;
  __int16 v115;
  uint64_t v116[4];
  __int16 v117;
  void *__dst[2];
  int64_t v119;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02ED0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v109 == 8 && *AttrData == 0x6D74736C2E73706DLL)
    {
      v117 = 1283;
      v116[0] = (uint64_t)"classof on '";
      v116[2] = (uint64_t)"mps.lstm";
      v116[3] = 8;
      v114 = "' failed due to the operation not being registered";
      v115 = 259;
      llvm::operator+(v116, (uint64_t *)&v114, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_61:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMOp,void>::id)
    goto LABEL_61;
  v113 = a3;
  v116[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v116);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v119 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v119) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v119 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v110 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v112 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v113);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_sequence"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v112, "addObject:", v15);
  RecurrentWeight = mlir::mps::LSTMOp::getRecurrentWeight((mlir::mps::LSTMOp *)&v113);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("recurrent_weight"), RecurrentWeight);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v112, "addObject:", v17);
  InputState = mlir::mps::LSTMOp::getInputState((mlir::mps::LSTMOp *)&v113);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_state"), InputState);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v112, "addObject:", v19);

  InputCell = mlir::mps::LSTMOp::getInputCell((mlir::mps::LSTMOp *)&v113);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_cell"), InputCell);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  if (v21)
    objc_msgSend(v112, "addObject:", v21);

  Mask = mlir::mps::LSTMOp::getMask((mlir::mps::LSTMOp *)&v113);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("mask"), Mask);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  if (v23)
    objc_msgSend(v112, "addObject:", v23);

  Peephole = mlir::mps::LSTMOp::getPeephole((mlir::mps::LSTMOp *)&v113);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("peephole"), Peephole);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  if (v25)
    objc_msgSend(v112, "addObject:", v25);

  CellClip = mlir::mps::LSTMOp::getCellClip((mlir::mps::LSTMOp *)&v113);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("cell_clip"), CellClip);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  if (v27)
    objc_msgSend(v112, "addObject:", v27);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v111 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v113);
  v29 = CFSTR("result");
  if (v28)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v28 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v28 + 8) & 0xFFFFFFFFFFFFFFF8));
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    v32 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v31, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v28));

    if (v32)
      objc_msgSend(v111, "addObject:", v32);
  }
  else
  {

    v32 = 0;
  }
  Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v113);
  v34 = CFSTR("output_cell");
  if (Element)
  {
    v35 = getMPSDataType((_QWORD *)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    v37 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output_cell"), v35, v36, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Element));

    if (v37)
      objc_msgSend(v111, "addObject:", v37);
  }
  else
  {

    v37 = 0;
  }
  TrainingState = mlir::mps::LSTMOp::getTrainingState((mlir::mps::LSTMOp *)&v113);
  v39 = CFSTR("training_state");
  if (TrainingState)
  {
    v40 = getMPSDataType((_QWORD *)(*(_QWORD *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    v42 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("training_state"), v40, v41, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, TrainingState));

    if (v42)
      objc_msgSend(v111, "addObject:", v42);
  }
  else
  {

    v42 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v113);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v45, "addObject:", v46);

  v47 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v45, "addObject:", v47);

  v48 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v45, "addObject:", v48);

  v49 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v45, "addObject:", v49);

  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v45, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v45, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("igate_activation"), CFSTR("MPSRNNActivation"), v45, PaddingStyle);
  if (v52)
    objc_msgSend(v43, "addObject:", v52);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v113);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v54, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v54, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v54, "addObject:", v57);

  v58 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v54, "addObject:", v58);

  v59 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v54, "addObject:", v59);

  v60 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v54, "addObject:", v60);

  v61 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("fgate_activation"), CFSTR("MPSRNNActivation"), v54, Layout);
  if (v61)
    objc_msgSend(v43, "addObject:", v61);

  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v113);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v63, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v63, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v63, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v63, "addObject:", v67);

  v68 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v63, "addObject:", v68);

  v69 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v63, "addObject:", v69);

  v70 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("zgate_activation"), CFSTR("MPSRNNActivation"), v63, WeightsLayout);
  if (v70)
    objc_msgSend(v43, "addObject:", v70);

  v71 = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v113);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v72, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v72, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v72, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v72, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v72, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v72, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("ogate_activation"), CFSTR("MPSRNNActivation"), v72, v71);
  if (v79)
    objc_msgSend(v43, "addObject:", v79);

  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v113);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v81, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v81, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v81, "addObject:", v84);

  v85 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v81, "addObject:", v85);

  v86 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v81, "addObject:", v86);

  v87 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v81, "addObject:", v87);

  v88 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("cell_activation"), CFSTR("MPSRNNActivation"), v81, StorageType);
  if (v88)
    objc_msgSend(v43, "addObject:", v88);

  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v113);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  v91 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("IFZO"), 0);
  objc_msgSend(v90, "addObject:", v91);

  v92 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("IZFO"), 1);
  objc_msgSend(v90, "addObject:", v92);

  v93 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("IFOZ"), 2);
  objc_msgSend(v90, "addObject:", v93);

  v94 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("IOFZ"), 3);
  objc_msgSend(v90, "addObject:", v94);

  v95 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("gate_layout"), CFSTR("MPSLSTMGateLayout"), v90, GateLayout);
  if (v95)
    objc_msgSend(v43, "addObject:", v95);

  LOBYTE(v116[0]) = 0;
  LOBYTE(v116[0]) = mlir::mps::GRUOp::getTraining((mlir::mps::GRUOp *)&v113);
  v96 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("training"), 2147483656, &unk_1E0E9A300);
  if (v96)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v116, 1);
    v97 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v96, "setValue:", v97);

    objc_msgSend(v43, "addObject:", v96);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  v99 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v112);
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v111);
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v43);
  v102 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v98);
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  v104 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v99, "initWithType:inputs:outputs:properties:regions:", v110, v100, v101, v102, v103);
  v105 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v104;

  v106 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v106);

  if (SHIBYTE(v119) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDF538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLeakyReluOpHandler *EmitterViewerSPI::MPSLeakyReluOpHandler::MPSLeakyReluOpHandler(EmitterViewerSPI::MPSLeakyReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03A28;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 14 && *AttrData == 0x6B61656C2E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x756C65725F796B61)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.leaky_relu";
      v43[3] = 14;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LeakyReluOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EDFD04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLessThanOpHandler *EmitterViewerSPI::MPSLessThanOpHandler::MPSLessThanOpHandler(EmitterViewerSPI::MPSLessThanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E038C0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 8 && *AttrData == 0x7373656C2E73706DLL)
    {
      v43 = 1283;
      v42[0] = (uint64_t)"classof on '";
      v42[2] = (uint64_t)"mps.less";
      v42[3] = 8;
      v40 = "' failed due to the operation not being registered";
      v41 = 259;
      llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LessThanOp,void>::id)
    goto LABEL_29;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v38, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE0290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLessThanOrEqualToOpHandler *EmitterViewerSPI::MPSLessThanOrEqualToOpHandler::MPSLessThanOrEqualToOpHandler(EmitterViewerSPI::MPSLessThanOrEqualToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E046A0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 14 && *AttrData == 0x7373656C2E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x6C617571655F7373)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.less_equal";
      v43[3] = 14;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LessThanOrEqualToOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE0834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler *EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler::MPSLocalConvolutionDataGradientOpHandler(EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  unsigned int StorageType;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumSPI *v39;
  uint64_t **Rewriter;
  uint64_t **v41;
  uint64_t InterfaceFor;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t **InputAttributeNames;
  uint64_t **v49;
  uint64_t v50;
  const char *v51;
  int v52;
  const char *v53;
  const char *v54;
  void *v55;
  void *v56;
  MPSGraphViewerNodeSPI *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  void *v63;
  void *v64;
  _QWORD *AttrData;
  uint64_t v67;
  BOOL v68;
  BOOL v69;
  BOOL v70;
  void *v72;
  mlir::Operation *v73;
  const char *v74;
  __int16 v75;
  uint64_t v76[4];
  __int16 v77;
  void *__dst[2];
  int64_t v79;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04B38;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v67 == 35)
    {
      v68 = *AttrData == 0x61636F6C2E73706DLL && AttrData[1] == 0x6C6F766E6F635F6CLL;
      v69 = v68 && AttrData[2] == 0x61645F6E6F697475;
      v70 = v69 && AttrData[3] == 0x69646172675F6174;
      if (v70 && *(_QWORD *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        v77 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v76[2] = (uint64_t)"mps.local_convolution_data_gradient";
        v76[3] = 35;
        v74 = "' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, (uint64_t *)&v74, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_66:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LocalConvolutionDataGradientOp,void>::id)
    goto LABEL_66;
  v73 = a3;
  v76[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v76);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v79 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v79) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v79 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v73);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v73);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v27, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v27, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v27, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v27, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v27, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v27, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v27, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v27, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v27, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v27, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v27, StorageType);
  if (v39)
    objc_msgSend(v25, "addObject:", v39);

  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v73);
  v41 = Rewriter;
  if (!Rewriter)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_45;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_45:
    __assert_rtn(v46, v45, v44, v43);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!InterfaceFor)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_45;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_sizes"), (uint64_t)v41, InterfaceFor);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v25, "addObject:", v47);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v73);
  v49 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v50 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v51 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v52 = 692;
    v53 = "Casting.h";
    v54 = "cast_if_present";
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49))
  {
    v51 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v52 = 566;
    v53 = "Casting.h";
    v54 = "cast";
LABEL_48:
    __assert_rtn(v54, v53, v52, v51);
  }
  v50 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49);
  if (!v50)
  {
    v51 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v52 = 98;
    v53 = "InterfaceSupport.h";
    v54 = "Interface";
    goto LABEL_48;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v49, v50);
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  if (v55)
    objc_msgSend(v25, "addObject:", v55);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  v57 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  v62 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v57, "initWithType:inputs:outputs:properties:regions:", v72, v58, v59, v60, v61);
  v63 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v62;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "returns the gradient of the local_convolution operation relative to the input tensor.");
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v64);

  if (SHIBYTE(v79) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE11F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLocalConvolutionOpHandler *EmitterViewerSPI::MPSLocalConvolutionOpHandler::MPSLocalConvolutionOpHandler(EmitterViewerSPI::MPSLocalConvolutionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  unsigned int StorageType;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumSPI *v39;
  uint64_t **Rewriter;
  uint64_t **v41;
  uint64_t InterfaceFor;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t **InputAttributeNames;
  uint64_t **v49;
  uint64_t v50;
  const char *v51;
  int v52;
  const char *v53;
  const char *v54;
  void *v55;
  void *v56;
  MPSGraphViewerNodeSPI *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  void *v63;
  void *v64;
  _QWORD *AttrData;
  uint64_t v67;
  BOOL v68;
  void *v70;
  mlir::Operation *v71;
  const char *v72;
  __int16 v73;
  uint64_t v74[4];
  __int16 v75;
  void *__dst[2];
  int64_t v77;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04598;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v67 == 21)
    {
      v68 = *AttrData == 0x61636F6C2E73706DLL && AttrData[1] == 0x6C6F766E6F635F6CLL;
      if (v68 && *(_QWORD *)((char *)AttrData + 13) == 0x6E6F6974756C6F76)
      {
        v75 = 1283;
        v74[0] = (uint64_t)"classof on '";
        v74[2] = (uint64_t)"mps.local_convolution";
        v74[3] = 21;
        v72 = "' failed due to the operation not being registered";
        v73 = 259;
        llvm::operator+(v74, (uint64_t *)&v72, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_60:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LocalConvolutionOp,void>::id)
    goto LABEL_60;
  v71 = a3;
  v74[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v74);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v77 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v77) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v77 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v71);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v71);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v71);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v71);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v27, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v27, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v27, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v27, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v27, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v27, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v27, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v27, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v27, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v27, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v27, StorageType);
  if (v39)
    objc_msgSend(v25, "addObject:", v39);

  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v71);
  v41 = Rewriter;
  if (!Rewriter)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_45;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_45:
    __assert_rtn(v46, v45, v44, v43);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!InterfaceFor)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_45;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_sizes"), (uint64_t)v41, InterfaceFor);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v25, "addObject:", v47);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v71);
  v49 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v50 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v51 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v52 = 692;
    v53 = "Casting.h";
    v54 = "cast_if_present";
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49))
  {
    v51 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v52 = 566;
    v53 = "Casting.h";
    v54 = "cast";
LABEL_48:
    __assert_rtn(v54, v53, v52, v51);
  }
  v50 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49);
  if (!v50)
  {
    v51 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v52 = 98;
    v53 = "InterfaceSupport.h";
    v54 = "Interface";
    goto LABEL_48;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v49, v50);
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  if (v55)
    objc_msgSend(v25, "addObject:", v55);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  v57 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  v62 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v57, "initWithType:inputs:outputs:properties:regions:", v70, v58, v59, v60, v61);
  v63 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v62;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "For each pixel of the input image, a different set of weights is provided in the channels of the weight tensor and form a 2d filter for that pixel. The weights are arranged in HW order inside the channels of the weight tensor. The destination pixel is calculated as the weighted sum of the pixels surrounding the pixel at the same location of the input image. The input image is zero padded when the filter reaches outside of the input.");
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v64);

  if (SHIBYTE(v77) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE1BE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler *EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler::MPSLocalConvolutionWeightGradientOpHandler(EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  unsigned int StorageType;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumSPI *v39;
  uint64_t **Rewriter;
  uint64_t **v41;
  uint64_t InterfaceFor;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t **InputAttributeNames;
  uint64_t **v49;
  uint64_t v50;
  const char *v51;
  int v52;
  const char *v53;
  const char *v54;
  void *v55;
  void *v56;
  MPSGraphViewerNodeSPI *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  void *v63;
  void *v64;
  _QWORD *AttrData;
  uint64_t v67;
  BOOL v68;
  BOOL v69;
  BOOL v70;
  void *v72;
  mlir::Operation *v73;
  const char *v74;
  __int16 v75;
  uint64_t v76[4];
  __int16 v77;
  void *__dst[2];
  int64_t v79;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04B98;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v67 == 37)
    {
      v68 = *AttrData == 0x61636F6C2E73706DLL && AttrData[1] == 0x6C6F766E6F635F6CLL;
      v69 = v68 && AttrData[2] == 0x65775F6E6F697475;
      v70 = v69 && AttrData[3] == 0x6172675F74686769;
      if (v70 && *(_QWORD *)((char *)AttrData + 29) == 0x746E656964617267)
      {
        v77 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v76[2] = (uint64_t)"mps.local_convolution_weight_gradient";
        v76[3] = 37;
        v74 = "' failed due to the operation not being registered";
        v75 = 259;
        llvm::operator+(v76, (uint64_t *)&v74, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_66:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LocalConvolutionWeightGradientOp,void>::id)
    goto LABEL_66;
  v73 = a3;
  v76[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v76);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v79 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v79) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v79 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v73);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v73);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v27, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v27, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v27, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v27, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v27, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v27, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v27, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v27, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v27, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v27, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("data_layout"), CFSTR("MPSTensorDataLayout"), v27, StorageType);
  if (v39)
    objc_msgSend(v25, "addObject:", v39);

  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v73);
  v41 = Rewriter;
  if (!Rewriter)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_45;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_45:
    __assert_rtn(v46, v45, v44, v43);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!InterfaceFor)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_45;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("kernel_sizes"), (uint64_t)v41, InterfaceFor);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v25, "addObject:", v47);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v73);
  v49 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v50 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v51 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v52 = 692;
    v53 = "Casting.h";
    v54 = "cast_if_present";
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49))
  {
    v51 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v52 = 566;
    v53 = "Casting.h";
    v54 = "cast";
LABEL_48:
    __assert_rtn(v54, v53, v52, v51);
  }
  v50 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49);
  if (!v50)
  {
    v51 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v52 = 98;
    v53 = "InterfaceSupport.h";
    v54 = "Interface";
    goto LABEL_48;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v49, v50);
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  if (v55)
    objc_msgSend(v25, "addObject:", v55);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  v57 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v56);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  v62 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v57, "initWithType:inputs:outputs:properties:regions:", v72, v58, v59, v60, v61);
  v63 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v62;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "returns the gradient of the local_convolution operation relative to the weight tensor.");
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v64);

  if (SHIBYTE(v79) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE25FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLogarithmBase2OpHandler *EmitterViewerSPI::MPSLogarithmBase2OpHandler::MPSLogarithmBase2OpHandler(EmitterViewerSPI::MPSLogarithmBase2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04250;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      v36 = *(_QWORD *)AttrData == 0x61676F6C2E73706DLL && *(_QWORD *)(AttrData + 8) == 0x61625F6D68746972;
      if (v36 && *(_DWORD *)(AttrData + 16) == 845112691)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.logarithm_base_2";
        v42[3] = 20;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LogarithmBase2Op,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE2BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLogarithmBase10OpHandler *EmitterViewerSPI::MPSLogarithmBase10OpHandler::MPSLogarithmBase10OpHandler(EmitterViewerSPI::MPSLogarithmBase10OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04430;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 21)
    {
      v36 = *AttrData == 0x61676F6C2E73706DLL && AttrData[1] == 0x61625F6D68746972;
      if (v36 && *(_QWORD *)((char *)AttrData + 13) == 0x30315F657361625FLL)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.logarithm_base_10";
        v42[3] = 21;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LogarithmBase10Op,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE3130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLogarithmOpHandler *EmitterViewerSPI::MPSLogarithmOpHandler::MPSLogarithmOpHandler(EmitterViewerSPI::MPSLogarithmOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03A40;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x61676F6C2E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x6D6874697261676FLL)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.logarithm";
      v41[3] = 13;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LogarithmOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE3684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMatMulOpHandler *EmitterViewerSPI::MPSMatMulOpHandler::MPSMatMulOpHandler(EmitterViewerSPI::MPSMatMulOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t AttrData;
  uint64_t v41;
  void *v43;
  mlir::Operation *v44;
  uint64_t v45[4];
  __int16 v46;
  uint64_t v47[4];
  __int16 v48;
  void *__dst[2];
  int64_t v50;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03410;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 10 && *(_QWORD *)AttrData == 0x6D74616D2E73706DLL && *(_WORD *)(AttrData + 8) == 27765)
    {
      v48 = 1283;
      v47[0] = (uint64_t)"classof on '";
      v47[2] = (uint64_t)"mps.matmul";
      v47[3] = 10;
      v45[0] = (uint64_t)"' failed due to the operation not being registered";
      v46 = 259;
      llvm::operator+(v47, v45, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
    goto LABEL_37;
  v44 = a3;
  v47[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v50 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v47[0]) = 0;
  LOBYTE(v47[0]) = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v44);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("transpose_lhs"), 2147483656, &unk_1E0E9A318);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v47, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v45[0]) = 0;
  LOBYTE(v45[0]) = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v44);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("transpose_rhs"), 2147483656, &unk_1E0E9A330);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v45, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v43, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v50) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE3CF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler *EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler::MPSMaterializeSparseTensorOpHandler(EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void *v13;
  unint64_t Input;
  void *v15;
  uint64_t Indices;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  unint64_t v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  __CFString *v27;
  uint64_t MPSDataType;
  void *v29;
  MPSGraphViewerNodePortSPI *v30;
  void *v31;
  unsigned int StorageType;
  void *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumSPI *v37;
  void *v38;
  MPSGraphViewerNodeSPI *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  _QWORD *AttrData;
  uint64_t v49;
  BOOL v50;
  BOOL v51;
  void *v53;
  mlir::Operation *v55;
  const char *v56;
  __int16 v57;
  uint64_t v58[4];
  __int16 v59;
  void *__dst[2];
  int64_t v61;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04A18;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v49 == 29)
    {
      v50 = *AttrData == 0x6574616D2E73706DLL && AttrData[1] == 0x5F657A696C616972;
      v51 = v50 && AttrData[2] == 0x745F657372617073;
      if (v51 && *(_QWORD *)((char *)AttrData + 21) == 0x726F736E65745F65)
      {
        v59 = 1283;
        v58[0] = (uint64_t)"classof on '";
        v58[2] = (uint64_t)"mps.materialize_sparse_tensor";
        v58[3] = 29;
        v56 = "' failed due to the operation not being registered";
        v57 = 259;
        llvm::operator+(v58, (uint64_t *)&v56, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id)
    goto LABEL_44;
  v55 = a3;
  v58[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v58);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v61 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v61) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v61 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v55);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("sparse_values"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v13, "addObject:", v15);
  Indices = mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v55);
  v18 = v17;
  if (v17)
  {
    v19 = Indices;
    v20 = 0;
    v21 = 1;
    do
    {
      v22 = *(_QWORD *)(v19 + 32 * v20 + 24);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("index_tensors%d"), v21 - 1);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v23, v22);
      v24 = (void *)objc_claimAutoreleasedReturnValue();

      if (v24)
        objc_msgSend(v13, "addObject:", v24);

      v20 = v21++;
    }
    while (v18 > v20);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v55);
  v27 = CFSTR("result");
  if (v26)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v30 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v29, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v26));

    if (v30)
      objc_msgSend(v25, "addObject:", v30);
  }
  else
  {

    v30 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v55);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("COO"), 0);
  objc_msgSend(v33, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CSC"), 1);
  objc_msgSend(v33, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CSR"), 2);
  objc_msgSend(v33, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("storage_type"), CFSTR("MPSSparseTensorStorage"), v33, StorageType);
  if (v37)
    objc_msgSend(v31, "addObject:", v37);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v13);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v38);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  v44 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v39, "initWithType:inputs:outputs:properties:regions:", v53, v40, v41, v42, v43);
  v45 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v44;

  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v46);

  if (SHIBYTE(v61) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE4448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  void *v29;
  void *v30;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler *EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler::MPSMatrixDecompositionLUOpHandler(EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  void *v16;
  MPSGraphViewerNodePortSPI *v17;
  __CFString *v18;
  uint64_t MPSDataType;
  void *v20;
  MPSGraphViewerNodePortSPI *Element;
  __CFString *v22;
  uint64_t v23;
  void *v24;
  MPSGraphViewerNodePortSPI *GradientInputState;
  __CFString *v26;
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  BOOL v42;
  BOOL v43;
  void *v45;
  void *v46;
  mlir::Operation *v47;
  const char *v48;
  __int16 v49;
  uint64_t v50[4];
  __int16 v51;
  void *__dst[2];
  int64_t v53;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04988;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 27)
    {
      v42 = *AttrData == 0x7274616D2E73706DLL && AttrData[1] == 0x6D6F6365645F7869;
      v43 = v42 && AttrData[2] == 0x6E6F697469736F70;
      if (v43 && *(_QWORD *)((char *)AttrData + 19) == 0x756C5F6E6F697469)
      {
        v51 = 1283;
        v50[0] = (uint64_t)"classof on '";
        v50[2] = (uint64_t)"mps.matrix_decomposition_lu";
        v50[3] = 27;
        v48 = "' failed due to the operation not being registered";
        v49 = 259;
        llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatrixDecompositionLUOp,void>::id)
    goto LABEL_45;
  v47 = a3;
  v50[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v53 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v46, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v17 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  v18 = CFSTR("lu_matrix");
  if (v17)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v17->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v17->_dataType & 0xFFFFFFFFFFFFFFF8));
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("lu_matrix"), MPSDataType, v20, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v17));

    if (v17)
      objc_msgSend(v16, "addObject:", v17);
  }
  else
  {

  }
  Element = (MPSGraphViewerNodePortSPI *)mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v47);
  v22 = CFSTR("pivot_indices");
  if (Element)
  {
    v23 = getMPSDataType((_QWORD *)(*(_QWORD *)&Element->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&Element->_dataType & 0xFFFFFFFFFFFFFFF8));
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    Element = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("pivot_indices"), v23, v24, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, Element));

    if (Element)
      objc_msgSend(v16, "addObject:", Element);
  }
  else
  {

  }
  GradientInputState = (MPSGraphViewerNodePortSPI *)mlir::mps::GRUGradientOp::getGradientInputState((mlir::mps::GRUGradientOp *)&v47);
  v26 = CFSTR("lu_status");
  if (GradientInputState)
  {
    v27 = getMPSDataType((_QWORD *)(*(_QWORD *)&GradientInputState->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&GradientInputState->_dataType & 0xFFFFFFFFFFFFFFF8));
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    GradientInputState = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("lu_status"), v27, v28, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, GradientInputState));

    if (GradientInputState)
      objc_msgSend(v16, "addObject:", GradientInputState);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v46);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v16);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v45, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Return the LU decomposition of an input matrix A as A = P*L*U The result contains the LU decomposition in packed form, a pivot_indices matrix to track matrix pivots and a status");
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v53) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE4B90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMatrixInverseOpHandler *EmitterViewerSPI::MPSMatrixInverseOpHandler::MPSMatrixInverseOpHandler(EmitterViewerSPI::MPSMatrixInverseOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04100;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 18)
    {
      v36 = *(_QWORD *)AttrData == 0x7274616D2E73706DLL && *(_QWORD *)(AttrData + 8) == 0x7265766E695F7869;
      if (v36 && *(_WORD *)(AttrData + 16) == 25971)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.matrix_inverse";
        v42[3] = 18;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatrixInverseOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_matrix"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("inverse_matrix");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("inverse_matrix"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Computes inverse for a square input");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE515C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMatrixSolverLUOpHandler *EmitterViewerSPI::MPSMatrixSolverLUOpHandler::MPSMatrixSolverLUOpHandler(EmitterViewerSPI::MPSMatrixSolverLUOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04268;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 20)
    {
      v40 = *(_QWORD *)AttrData == 0x7274616D2E73706DLL && *(_QWORD *)(AttrData + 8) == 0x65766C6F735F7869;
      if (v40 && *(_DWORD *)(AttrData + 16) == 1970036594)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.matrix_solver_lu";
        v46[3] = 20;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatrixSolverLUOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lu_matrix"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("pivot_indices"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs_matrix"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v23 = CFSTR("solution_matrix");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("solution_matrix"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Solves for x, in the equation Ax = b. Inputs are LU factorized matrix of A, permutation matrix (P), rhs matrix (b). Returns x");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE572C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMaximumOpHandler *EmitterViewerSPI::MPSMaximumOpHandler::MPSMaximumOpHandler(EmitterViewerSPI::MPSMaximumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E035D8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x6978616D2E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6D756D6978616D2ELL)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.maximum";
      v43[3] = 11;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MaximumOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE5CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMinimumOpHandler *EmitterViewerSPI::MPSMinimumOpHandler::MPSMinimumOpHandler(EmitterViewerSPI::MPSMinimumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E035F0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x696E696D2E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6D756D696E696D2ELL)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.minimum";
      v43[3] = 11;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MinimumOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE628C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSModuloOpHandler *EmitterViewerSPI::MPSModuloOpHandler::MPSModuloOpHandler(EmitterViewerSPI::MPSModuloOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03440;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 10 && *(_QWORD *)AttrData == 0x75646F6D2E73706DLL && *(_WORD *)(AttrData + 8) == 28524)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.modulo";
      v43[3] = 10;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ModuloOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE6824(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMultiplyOpHandler *EmitterViewerSPI::MPSMultiplyOpHandler::MPSMultiplyOpHandler(EmitterViewerSPI::MPSMultiplyOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E038D8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 12 && *(_QWORD *)AttrData == 0x746C756D2E73706DLL && *(_DWORD *)(AttrData + 8) == 2037149801)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.multiply";
      v43[3] = 12;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE6DC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNReluOpHandler *EmitterViewerSPI::MPSNReluOpHandler::MPSNReluOpHandler(EmitterViewerSPI::MPSNReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E031E8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 10 && *(_QWORD *)AttrData == 0x65725F6E2E73706DLL && *(_WORD *)(AttrData + 8) == 30060)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.n_relu";
      v45[3] = 10;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NReluOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("primary"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("secondary"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("tertiary"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE7390(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNandOpHandler *EmitterViewerSPI::MPSNandOpHandler::MPSNandOpHandler(EmitterViewerSPI::MPSNandOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02EE8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 8 && *AttrData == 0x646E616E2E73706DLL)
    {
      v43 = 1283;
      v42[0] = (uint64_t)"classof on '";
      v42[2] = (uint64_t)"mps.nand";
      v42[3] = 8;
      v40 = "' failed due to the operation not being registered";
      v41 = 259;
      llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NandOp,void>::id)
    goto LABEL_29;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v38, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE7934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNegativeOpHandler *EmitterViewerSPI::MPSNegativeOpHandler::MPSNegativeOpHandler(EmitterViewerSPI::MPSNegativeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E038F0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(_QWORD *)AttrData == 0x6167656E2E73706DLL && *(_DWORD *)(AttrData + 8) == 1702259060)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.negative";
      v41[3] = 12;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NegativeOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE7E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler *EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler::MPSNonMaximumSuppressionOpHandler(EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t ClassIndices;
  void *v20;
  unint64_t IouThreshold;
  void *v22;
  unint64_t Axis;
  void *v24;
  MPSGraphViewerNodePortSPI *v25;
  __CFString *v26;
  uint64_t MPSDataType;
  void *v28;
  uint64_t Element;
  __CFString *v30;
  uint64_t v31;
  void *v32;
  MPSGraphViewerNodePortSPI *v33;
  void *v34;
  MPSGraphViewerNodePropertyDataSPI *v35;
  void *v36;
  unsigned int StorageType;
  void *v38;
  MPSGraphViewerNodePropertyEnumCaseSPI *v39;
  MPSGraphViewerNodePropertyEnumCaseSPI *v40;
  MPSGraphViewerNodePropertyEnumCaseSPI *v41;
  MPSGraphViewerNodePropertyEnumCaseSPI *v42;
  MPSGraphViewerNodePropertyEnumSPI *v43;
  MPSGraphViewerNodePropertyDataSPI *v44;
  void *v45;
  void *v46;
  MPSGraphViewerNodeSPI *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  void *v53;
  void *v54;
  _QWORD *AttrData;
  uint64_t v57;
  BOOL v58;
  BOOL v59;
  void *v61;
  void *v62;
  mlir::Operation *v63;
  uint64_t v64[4];
  __int16 v65;
  uint64_t v66[4];
  __int16 v67;
  void *__dst[2];
  int64_t v69;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E049A0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v57 == 27)
    {
      v58 = *AttrData == 0x5F6E6F6E2E73706DLL && AttrData[1] == 0x5F6D756D6978616DLL;
      v59 = v58 && AttrData[2] == 0x7373657270707573;
      if (v59 && *(_QWORD *)((char *)AttrData + 19) == 0x6E6F697373657270)
      {
        v67 = 1283;
        v66[0] = (uint64_t)"classof on '";
        v66[2] = (uint64_t)"mps.non_maximum_suppression";
        v66[3] = 27;
        v64[0] = (uint64_t)"' failed due to the operation not being registered";
        v65 = 259;
        llvm::operator+(v66, v64, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_59:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NonMaximumSuppressionOp,void>::id)
    goto LABEL_59;
  v63 = a3;
  v66[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v66);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v69 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v69) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v69 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v63);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("boxes"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v63);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("scores"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  ClassIndices = mlir::mps::NonMaximumSuppressionOp::getClassIndices((mlir::mps::NonMaximumSuppressionOp *)&v63);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("class_indices"), ClassIndices);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  IouThreshold = mlir::mps::NonMaximumSuppressionOp::getIouThreshold((mlir::mps::NonMaximumSuppressionOp *)&v63);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("iou_threshold"), IouThreshold);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);
  Axis = mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v63);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("score_threshold"), Axis);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v24)
    objc_msgSend(v14, "addObject:", v24);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v63);
  v26 = CFSTR("selected_indices");
  if (v25)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v25->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v25->_dataType & 0xFFFFFFFFFFFFFFF8));
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v25 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("selected_indices"), MPSDataType, v28, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v25));

    if (v25)
      objc_msgSend(v62, "addObject:", v25);
  }
  else
  {

  }
  Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v63);
  v30 = CFSTR("num_boxes");
  if (Element)
  {
    v31 = getMPSDataType((_QWORD *)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    v33 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("num_boxes"), v31, v32, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Element));

    if (v33)
      objc_msgSend(v62, "addObject:", v33);
  }
  else
  {

    v33 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v64[0]) = 0;
  LOBYTE(v64[0]) = mlir::mps::CostVolumeOp::getNormalizeCoordinates((mlir::mps::CostVolumeOp *)&v63);
  v35 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("per_class_suppression"), 2147483656, &unk_1E0E9A348);
  if (v35)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v64, 1);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v35, "setValue:", v36);

    objc_msgSend(v34, "addObject:", v35);
  }
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v63);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("cornersHeightFirst"), 0);
  objc_msgSend(v38, "addObject:", v39);

  v40 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("cornersWidthFirst"), 1);
  objc_msgSend(v38, "addObject:", v40);

  v41 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("centersHeightFirst"), 2);
  objc_msgSend(v38, "addObject:", v41);

  v42 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("centersWidthFirst"), 3);
  objc_msgSend(v38, "addObject:", v42);

  v43 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("coordinate_mode"), CFSTR("MPSCropResizeCoordinateMode"), v38, StorageType);
  if (v43)
    objc_msgSend(v34, "addObject:", v43);

  v66[0] = mlir::mps::NonMaximumSuppressionOp::getMaxBoxes((mlir::mps::NonMaximumSuppressionOp *)&v63);
  if ((v66[0] & 0xFF00000000) != 0)
  {
    v44 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("max_boxes"), 32, &unk_1E0E9A360);
    if (v44)
    {
      if (!BYTE4(v66[0]))
        std::__throw_bad_optional_access[abi:ne180100]();
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v66, 8);
      v45 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setValue:](v44, "setValue:", v45);

      objc_msgSend(v34, "addObject:", v44);
    }

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  v47 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v62);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v46);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  v52 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v47, "initWithType:inputs:outputs:properties:regions:", v61, v48, v49, v50, v51);
  v53 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v52;

    "f it is already known.\n"
    "\n"
    "Non maximum suppression is performed by sorting the boxes by their maximum score across all classes. A box will be s"
    "ppress other boxes with a maximum score in the same class.\n"
    "\n"
    "\n"
    " the selected box within the batch, in range [0,B), and the second index is the index of the box's' maximum score, i"
    "\n"
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v54);

  if (SHIBYTE(v69) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE87C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNonZeroOpHandler *EmitterViewerSPI::MPSNonZeroOpHandler::MPSNonZeroOpHandler(EmitterViewerSPI::MPSNonZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03608;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(_QWORD *)AttrData == 0x5F6E6F6E2E73706DLL && *(_DWORD *)(AttrData + 8) == 1869768058)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.non_zero";
      v41[3] = 12;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NonZeroOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE8E2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNorOpHandler *EmitterViewerSPI::MPSNorOpHandler::MPSNorOpHandler(EmitterViewerSPI::MPSNorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _DWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02C30;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1919905326)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.nor";
      v43[3] = 7;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NorOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE93A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNormalizationOpHandler *EmitterViewerSPI::MPSNormalizationOpHandler::MPSNormalizationOpHandler(EmitterViewerSPI::MPSNormalizationOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  unint64_t Dense;
  void *v24;
  void *v25;
  uint64_t v26;
  __CFString *v27;
  uint64_t MPSDataType;
  void *v29;
  MPSGraphViewerNodePortSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  llvm::APFloatBase *v35;
  void *v36;
  MPSGraphViewerNodeSPI *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  void *v43;
  void *v44;
  uint64_t AttrData;
  uint64_t v47;
  BOOL v48;
  void *v50;
  mlir::Operation *v51;
  const char *v52;
  __int16 v53;
  void *__dst[2];
  const char *v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  void *v59;
  _QWORD v60[4];

  v60[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04118;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v58 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v58);
    if (v47 == 17)
    {
      v48 = *(_QWORD *)AttrData == 0x6D726F6E2E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6F6974617A696C61;
      if (v48 && *(_BYTE *)(AttrData + 16) == 110)
      {
        v57 = 1283;
        __dst[0] = "classof on '";
        v55 = "mps.normalization";
        v56 = 17;
        v52 = "' failed due to the operation not being registered";
        v53 = 259;
        llvm::operator+((uint64_t *)__dst, (uint64_t *)&v52, (uint64_t)&v58);
        llvm::report_fatal_error((llvm::Twine *)&v58, 1);
      }
    }
LABEL_47:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id)
    goto LABEL_47;
  v51 = a3;
  v58 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v58);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v55 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v55) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("mean"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("variance"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gamma"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);
  Dense = mlir::mpsx::SparseDenseMatMulOp::getDense((mlir::mpsx::SparseDenseMatMulOp *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("beta"), Dense);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v24)
    objc_msgSend(v14, "addObject:", v24);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51);
  v27 = CFSTR("result");
  if (v26)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v30 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v29, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v26));

    if (v30)
      objc_msgSend(v25, "addObject:", v30);
  }
  else
  {

    v30 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v51, (uint64_t)&v58);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("epsilon"), 268435488, &unk_1E0E9A378);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v58, 32);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v31, "addObject:", v32);
  }

  v34 = v59;
  if (llvm::APFloatBase::PPCDoubleDouble(v35) == v34)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v60);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v59);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v36);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  v42 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v37, "initWithType:inputs:outputs:properties:regions:", v50, v38, v39, v40, v41);
  v43 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v42;

  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v44);

  if (SHIBYTE(v55) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EE9ACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNotEqualToOpHandler *EmitterViewerSPI::MPSNotEqualToOpHandler::MPSNotEqualToOpHandler(EmitterViewerSPI::MPSNotEqualToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03C80;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 13 && *AttrData == 0x5F746F6E2E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x6C617571655F746FLL)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.not_equal";
      v43[3] = 13;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NotEqualToOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEA0C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNotOpHandler *EmitterViewerSPI::MPSNotOpHandler::MPSNotOpHandler(EmitterViewerSPI::MPSNotOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _DWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02C48;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1953459758)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.not";
      v41[3] = 7;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NotOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEA624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSOneHotOpHandler *EmitterViewerSPI::MPSOneHotOpHandler::MPSOneHotOpHandler(EmitterViewerSPI::MPSOneHotOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03458;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 11 && *AttrData == 0x5F656E6F2E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x746F685F656E6F2ELL)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.one_hot";
      v45[3] = 11;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::OneHotOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("indices"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("depth"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v42);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEABF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSOrOpHandler *EmitterViewerSPI::MPSOrOpHandler::MPSOrOpHandler(EmitterViewerSPI::MPSOrOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02B40;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 6 && *(_DWORD *)AttrData == 779317357 && *(_WORD *)(AttrData + 4) == 29295)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.or";
      v43[3] = 6;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::OrOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEB1A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPReluOpHandler *EmitterViewerSPI::MPSPReluOpHandler::MPSPReluOpHandler(EmitterViewerSPI::MPSPReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03200;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 9 && *(_QWORD *)AttrData == 0x6C6572702E73706DLL && *(_BYTE *)(AttrData + 8) == 117)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.prelu";
      v43[3] = 9;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PReluOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Where i = 1 ... C, if x_i > 0, return x_i, otherwise return alpha_i * x_i.");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEB738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPadGradientOpHandler *EmitterViewerSPI::MPSPadGradientOpHandler::MPSPadGradientOpHandler(EmitterViewerSPI::MPSPadGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  unsigned int StorageType;
  void *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumSPI *v34;
  void *v35;
  MPSGraphViewerNodeSPI *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  void *v43;
  _QWORD *AttrData;
  uint64_t v46;
  void *v48;
  mlir::Operation *v49;
  const char *v50;
  __int16 v51;
  uint64_t v52[4];
  __int16 v53;
  void *__dst[2];
  int64_t v55;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03DB8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v46 == 16 && *AttrData == 0x5F6461702E73706DLL && AttrData[1] == 0x746E656964617267)
    {
      v53 = 1283;
      v52[0] = (uint64_t)"classof on '";
      v52[2] = (uint64_t)"mps.pad_gradient";
      v52[3] = 16;
      v50 = "' failed due to the operation not being registered";
      v51 = 259;
      llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PadGradientOp,void>::id)
    goto LABEL_37;
  v49 = a3;
  v52[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v55 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("paddings"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v49);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("constant"), 0);
  objc_msgSend(v29, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("reflect"), 1);
  objc_msgSend(v29, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("symmetric"), 2);
  objc_msgSend(v29, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("clampToEdge"), 3);
  objc_msgSend(v29, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("paddingMode"), CFSTR("MPSPaddingMode"), v29, StorageType);
  if (v34)
    objc_msgSend(v27, "addObject:", v34);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v35);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v36, "initWithType:inputs:outputs:properties:regions:", v48, v37, v38, v39, v40);
  v42 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v41;

  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v43);

  if (SHIBYTE(v55) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEBE24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPadOpHandler *EmitterViewerSPI::MPSPadOpHandler::MPSPadOpHandler(EmitterViewerSPI::MPSPadOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  unsigned int StorageType;
  void *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumSPI *v34;
  void *v35;
  MPSGraphViewerNodeSPI *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  void *v43;
  _DWORD *AttrData;
  uint64_t v46;
  void *v48;
  mlir::Operation *v49;
  const char *v50;
  __int16 v51;
  uint64_t v52[4];
  __int16 v53;
  void *__dst[2];
  int64_t v55;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02C60;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v46 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684107310)
    {
      v53 = 1283;
      v52[0] = (uint64_t)"classof on '";
      v52[2] = (uint64_t)"mps.pad";
      v52[3] = 7;
      v50 = "' failed due to the operation not being registered";
      v51 = 259;
      llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
    goto LABEL_37;
  v49 = a3;
  v52[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v55 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("paddings"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("constant_values"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v49);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("constant"), 0);
  objc_msgSend(v29, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("reflect"), 1);
  objc_msgSend(v29, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("symmetric"), 2);
  objc_msgSend(v29, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("clampToEdge"), 3);
  objc_msgSend(v29, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("paddingMode"), CFSTR("MPSPaddingMode"), v29, StorageType);
  if (v34)
    objc_msgSend(v27, "addObject:", v34);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v35);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v36, "initWithType:inputs:outputs:properties:regions:", v48, v37, v38, v39, v40);
  v42 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v41;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Pad the input tensor specifying padding values and padding mode");
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v43);

  if (SHIBYTE(v55) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEC548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPermuteOpHandler *EmitterViewerSPI::MPSPermuteOpHandler::MPSPermuteOpHandler(EmitterViewerSPI::MPSPermuteOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03620;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x6D7265702E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6574756D7265702ELL)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.permute";
      v43[3] = 11;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("perm"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EECB30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPlaceholderOpHandler *EmitterViewerSPI::MPSPlaceholderOpHandler::MPSPlaceholderOpHandler(EmitterViewerSPI::MPSPlaceholderOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  void *v15;
  uint64_t v16;
  __CFString *v17;
  uint64_t MPSDataType;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  void *v21;
  void *v22;
  MPSGraphViewerNodeSPI *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  void *v29;
  void *v30;
  _QWORD *AttrData;
  uint64_t v33;
  void *v35;
  mlir::Operation *v36;
  const char *v37;
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  void *__dst[2];
  int64_t v42;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03DD0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v33 == 15 && *AttrData == 0x63616C702E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x7265646C6F686563)
    {
      v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"mps.placeholder";
      v39[3] = 15;
      v37 = "' failed due to the operation not being registered";
      v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PlaceholderOp,void>::id)
    goto LABEL_29;
  v36 = a3;
  v39[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v42 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  v17 = CFSTR("result");
  if (v16)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v19, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v16));

    if (v20)
      objc_msgSend(v15, "addObject:", v20);
  }
  else
  {

    v20 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v23 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v15);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v22);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v23, "initWithType:inputs:outputs:properties:regions:", v35, v24, v25, v26, v27);
  v29 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v28;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Inserts a placeholder for a tensor that will be always fed.");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v30);

  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EED064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolAvgGradientOpHandler *EmitterViewerSPI::MPSPoolAvgGradientOpHandler::MPSPoolAvgGradientOpHandler(EmitterViewerSPI::MPSPoolAvgGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **WindowSizes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t **Strides;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **InputAttributeNames;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  unsigned int PaddingStyle;
  void *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumSPI *v55;
  uint64_t **Offsets;
  char v57;
  uint64_t **v58;
  uint64_t v59;
  const char *v60;
  int v61;
  const char *v62;
  const char *v63;
  void *v64;
  MPSGraphViewerNodePropertyDataSPI *v65;
  void *v66;
  MPSGraphViewerNodePropertyDataSPI *v67;
  void *v68;
  void *v69;
  MPSGraphViewerNodeSPI *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  uint64_t v75;
  void *v76;
  void *v77;
  uint64_t AttrData;
  uint64_t v80;
  BOOL v81;
  BOOL v82;
  void *v84;
  void *v85;
  void *v86;
  mlir::Operation *v87;
  uint64_t v88[4];
  __int16 v89;
  uint64_t v90[4];
  __int16 v91;
  void *__dst[2];
  int64_t v93;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04448;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v80 == 28)
    {
      v81 = *(_QWORD *)AttrData == 0x6C6F6F702E73706DLL && *(_QWORD *)(AttrData + 8) == 0x726576615F676E69;
      v82 = v81 && *(_QWORD *)(AttrData + 16) == 0x646172675F656761;
      if (v82 && *(_DWORD *)(AttrData + 24) == 1953391977)
      {
        v91 = 1283;
        v90[0] = (uint64_t)"classof on '";
        v90[2] = (uint64_t)"mps.pooling_average_gradient";
        v90[3] = 28;
        v88[0] = (uint64_t)"' failed due to the operation not being registered";
        v89 = 259;
        llvm::operator+(v90, v88, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_91:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgGradientOp,void>::id)
    goto LABEL_91;
  v87 = a3;
  v90[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v90);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v93 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v93) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v93 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v87);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v86, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v87);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v86, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v87);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v85, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  WindowSizes = (uint64_t **)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v87);
  v25 = WindowSizes;
  if (!WindowSizes)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_67:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_67;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("window_sizes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v87);
  v33 = Strides;
  if (!Strides)
  {
    v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_70;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_70:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_70;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v87);
  v41 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_73;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_73:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_73;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v87);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v49, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v49, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v49, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v49, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v49, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v49, PaddingStyle);
  if (v55)
    objc_msgSend(v23, "addObject:", v55);

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v87);
  if (v57)
  {
    v58 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v58))
        {
          v59 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v58);
          if (!v59)
          {
            v60 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v61 = 98;
            v62 = "InterfaceSupport.h";
            v63 = "Interface";
            goto LABEL_76;
          }
          goto LABEL_55;
        }
        v60 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v61 = 566;
        v62 = "Casting.h";
        v63 = "cast";
      }
      else
      {
        v60 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v61 = 692;
        v62 = "Casting.h";
        v63 = "cast_if_present";
      }
LABEL_76:
      __assert_rtn(v63, v62, v61, v60);
    }
    v59 = 0;
LABEL_55:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v58, v59);
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    if (v64)
      objc_msgSend(v23, "addObject:", v64);

  }
  LOBYTE(v90[0]) = 0;
  LOBYTE(v90[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v87);
  v65 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("ceil_mode"), 2147483656, &unk_1E0E9A390);
  if (v65)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v90, 1);
    v66 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v65, "setValue:", v66);

    objc_msgSend(v23, "addObject:", v65);
  }
  LOBYTE(v88[0]) = 0;
  LOBYTE(v88[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v87);
  v67 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("include_zero_pad"), 2147483656, &unk_1E0E9A3A8);
  if (v67)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v88, 1);
    v68 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v67, "setValue:", v68);

    objc_msgSend(v23, "addObject:", v67);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  v70 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v86);
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v85);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v69);
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  v75 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v70, "initWithType:inputs:outputs:properties:regions:", v84, v71, v72, v73, v74);
  v76 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v75;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Computes the gradient backpropagation for the pooling operation in four dimensions. If indices are provided, then output_shape should be provided too and input should not be provided. If input is provided, then indices and output_shape should not be provided.");
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v77);

  if (SHIBYTE(v93) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEDB68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolAvgOpHandler *EmitterViewerSPI::MPSPoolAvgOpHandler::MPSPoolAvgOpHandler(EmitterViewerSPI::MPSPoolAvgOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  uint64_t v16;
  __CFString *v17;
  uint64_t MPSDataType;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  void *v21;
  uint64_t **WindowSizes;
  uint64_t **v23;
  uint64_t InterfaceFor;
  const char *v25;
  int v26;
  const char *v27;
  const char *v28;
  void *v29;
  uint64_t **Strides;
  uint64_t **v31;
  uint64_t v32;
  const char *v33;
  int v34;
  const char *v35;
  const char *v36;
  void *v37;
  uint64_t **InputAttributeNames;
  uint64_t **v39;
  uint64_t v40;
  const char *v41;
  int v42;
  const char *v43;
  const char *v44;
  void *v45;
  unsigned int PaddingStyle;
  void *v47;
  MPSGraphViewerNodePropertyEnumCaseSPI *v48;
  MPSGraphViewerNodePropertyEnumCaseSPI *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumSPI *v53;
  uint64_t **Offsets;
  char v55;
  uint64_t **v56;
  uint64_t v57;
  const char *v58;
  int v59;
  const char *v60;
  const char *v61;
  void *v62;
  MPSGraphViewerNodePropertyDataSPI *v63;
  void *v64;
  MPSGraphViewerNodePropertyDataSPI *v65;
  void *v66;
  void *v67;
  MPSGraphViewerNodeSPI *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  void *v75;
  _QWORD *AttrData;
  uint64_t v78;
  BOOL v79;
  void *v81;
  void *v82;
  void *v83;
  mlir::Operation *v84;
  uint64_t v85[4];
  __int16 v86;
  uint64_t v87[4];
  __int16 v88;
  void *__dst[2];
  int64_t v90;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03638;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v78 == 19)
    {
      v79 = *AttrData == 0x6C6F6F702E73706DLL && AttrData[1] == 0x726576615F676E69;
      if (v79 && *(_QWORD *)((char *)AttrData + 11) == 0x656761726576615FLL)
      {
        v88 = 1283;
        v87[0] = (uint64_t)"classof on '";
        v87[2] = (uint64_t)"mps.pooling_average";
        v87[3] = 19;
        v85[0] = (uint64_t)"' failed due to the operation not being registered";
        v86 = 259;
        llvm::operator+(v87, v85, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_86:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgOp,void>::id)
    goto LABEL_86;
  v84 = a3;
  v87[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v87);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v90 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v90) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v90 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v84);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v83, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v84);
  v17 = CFSTR("result");
  if (v16)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v19, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v16));

    if (v20)
      objc_msgSend(v82, "addObject:", v20);
  }
  else
  {

    v20 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  WindowSizes = (uint64_t **)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v84);
  v23 = WindowSizes;
  if (!WindowSizes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    v25 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v26 = 692;
    v27 = "Casting.h";
    v28 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v23))
  {
    v25 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v26 = 566;
    v27 = "Casting.h";
    v28 = "cast";
LABEL_65:
    __assert_rtn(v28, v27, v26, v25);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v23);
  if (!InterfaceFor)
  {
    v25 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v26 = 98;
    v27 = "InterfaceSupport.h";
    v28 = "Interface";
    goto LABEL_65;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("window_sizes"), (uint64_t)v23, InterfaceFor);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  if (v29)
    objc_msgSend(v21, "addObject:", v29);
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v84);
  v31 = Strides;
  if (!Strides)
  {
    v32 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v33 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v34 = 692;
    v35 = "Casting.h";
    v36 = "cast_if_present";
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v31))
  {
    v33 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v34 = 566;
    v35 = "Casting.h";
    v36 = "cast";
LABEL_68:
    __assert_rtn(v36, v35, v34, v33);
  }
  v32 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v31);
  if (!v32)
  {
    v33 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v34 = 98;
    v35 = "InterfaceSupport.h";
    v36 = "Interface";
    goto LABEL_68;
  }
LABEL_34:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v31, v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  if (v37)
    objc_msgSend(v21, "addObject:", v37);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v84);
  v39 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v40 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v41 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v42 = 692;
    v43 = "Casting.h";
    v44 = "cast_if_present";
    goto LABEL_71;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v39))
  {
    v41 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v42 = 566;
    v43 = "Casting.h";
    v44 = "cast";
LABEL_71:
    __assert_rtn(v44, v43, v42, v41);
  }
  v40 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v39);
  if (!v40)
  {
    v41 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v42 = 98;
    v43 = "InterfaceSupport.h";
    v44 = "Interface";
    goto LABEL_71;
  }
LABEL_42:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v39, v40);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  if (v45)
    objc_msgSend(v21, "addObject:", v45);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v84);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  v48 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v47, "addObject:", v48);

  v49 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v47, "addObject:", v49);

  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v47, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v47, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v47, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v47, PaddingStyle);
  if (v53)
    objc_msgSend(v21, "addObject:", v53);

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v84);
  if (v55)
  {
    v56 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56))
        {
          v57 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56);
          if (!v57)
          {
            v58 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v59 = 98;
            v60 = "InterfaceSupport.h";
            v61 = "Interface";
            goto LABEL_74;
          }
          goto LABEL_53;
        }
        v58 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v59 = 566;
        v60 = "Casting.h";
        v61 = "cast";
      }
      else
      {
        v58 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v59 = 692;
        v60 = "Casting.h";
        v61 = "cast_if_present";
      }
LABEL_74:
      __assert_rtn(v61, v60, v59, v58);
    }
    v57 = 0;
LABEL_53:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v56, v57);
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    if (v62)
      objc_msgSend(v21, "addObject:", v62);

  }
  LOBYTE(v87[0]) = 0;
  LOBYTE(v87[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v84);
  v63 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("ceil_mode"), 2147483656, &unk_1E0E9A3C0);
  if (v63)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v87, 1);
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v63, "setValue:", v64);

    objc_msgSend(v21, "addObject:", v63);
  }
  LOBYTE(v85[0]) = 0;
  LOBYTE(v85[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v84);
  v65 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("include_zero_pad"), 2147483656, &unk_1E0E9A3D8);
  if (v65)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v85, 1);
    v66 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v65, "setValue:", v66);

    objc_msgSend(v21, "addObject:", v65);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  v68 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v83);
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v82);
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v67);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v68, "initWithType:inputs:outputs:properties:regions:", v81, v69, v70, v71, v72);
  v74 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v73;

  v75 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v75);

  if (SHIBYTE(v90) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEE714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolL2NormGradientOpHandler *EmitterViewerSPI::MPSPoolL2NormGradientOpHandler::MPSPoolL2NormGradientOpHandler(EmitterViewerSPI::MPSPoolL2NormGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **WindowSizes;
  uint64_t **v25;
  uint64_t InterfaceFor;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t **Strides;
  uint64_t **v33;
  uint64_t v34;
  const char *v35;
  int v36;
  const char *v37;
  const char *v38;
  void *v39;
  uint64_t **InputAttributeNames;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  unsigned int PaddingStyle;
  void *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumSPI *v55;
  uint64_t **Offsets;
  char v57;
  uint64_t **v58;
  uint64_t v59;
  const char *v60;
  int v61;
  const char *v62;
  const char *v63;
  void *v64;
  MPSGraphViewerNodePropertyDataSPI *v65;
  void *v66;
  MPSGraphViewerNodePropertyDataSPI *v67;
  void *v68;
  void *v69;
  MPSGraphViewerNodeSPI *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  uint64_t v75;
  void *v76;
  void *v77;
  uint64_t AttrData;
  uint64_t v80;
  BOOL v81;
  BOOL v82;
  void *v84;
  void *v85;
  void *v86;
  mlir::Operation *v87;
  uint64_t v88[4];
  __int16 v89;
  uint64_t v90[4];
  __int16 v91;
  void *__dst[2];
  int64_t v93;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04760;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v80 == 28)
    {
      v81 = *(_QWORD *)AttrData == 0x6C6F6F702E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6E5F326C5F676E69;
      v82 = v81 && *(_QWORD *)(AttrData + 16) == 0x646172675F6D726FLL;
      if (v82 && *(_DWORD *)(AttrData + 24) == 1953391977)
      {
        v91 = 1283;
        v90[0] = (uint64_t)"classof on '";
        v90[2] = (uint64_t)"mps.pooling_l2_norm_gradient";
        v90[3] = 28;
        v88[0] = (uint64_t)"' failed due to the operation not being registered";
        v89 = 259;
        llvm::operator+(v90, v88, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_91:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormGradientOp,void>::id)
    goto LABEL_91;
  v87 = a3;
  v90[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v90);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v93 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v93) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v93 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v87);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v86, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v87);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v86, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v87);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v85, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  WindowSizes = (uint64_t **)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v87);
  v25 = WindowSizes;
  if (!WindowSizes)
  {
    InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v28 = 692;
    v29 = "Casting.h";
    v30 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v28 = 566;
    v29 = "Casting.h";
    v30 = "cast";
LABEL_67:
    __assert_rtn(v30, v29, v28, v27);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v28 = 98;
    v29 = "InterfaceSupport.h";
    v30 = "Interface";
    goto LABEL_67;
  }
LABEL_28:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("window_sizes"), (uint64_t)v25, InterfaceFor);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  if (v31)
    objc_msgSend(v23, "addObject:", v31);
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v87);
  v33 = Strides;
  if (!Strides)
  {
    v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v36 = 692;
    v37 = "Casting.h";
    v38 = "cast_if_present";
    goto LABEL_70;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v36 = 566;
    v37 = "Casting.h";
    v38 = "cast";
LABEL_70:
    __assert_rtn(v38, v37, v36, v35);
  }
  v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v36 = 98;
    v37 = "InterfaceSupport.h";
    v38 = "Interface";
    goto LABEL_70;
  }
LABEL_36:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v33, v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  if (v39)
    objc_msgSend(v23, "addObject:", v39);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v87);
  v41 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_73;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_73:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_73;
  }
LABEL_44:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v87);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v49, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v49, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v49, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v49, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v49, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v49, PaddingStyle);
  if (v55)
    objc_msgSend(v23, "addObject:", v55);

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v87);
  if (v57)
  {
    v58 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v58))
        {
          v59 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v58);
          if (!v59)
          {
            v60 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v61 = 98;
            v62 = "InterfaceSupport.h";
            v63 = "Interface";
            goto LABEL_76;
          }
          goto LABEL_55;
        }
        v60 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v61 = 566;
        v62 = "Casting.h";
        v63 = "cast";
      }
      else
      {
        v60 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v61 = 692;
        v62 = "Casting.h";
        v63 = "cast_if_present";
      }
LABEL_76:
      __assert_rtn(v63, v62, v61, v60);
    }
    v59 = 0;
LABEL_55:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v58, v59);
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    if (v64)
      objc_msgSend(v23, "addObject:", v64);

  }
  LOBYTE(v90[0]) = 0;
  LOBYTE(v90[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v87);
  v65 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("ceil_mode"), 2147483656, &unk_1E0E9A3F0);
  if (v65)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v90, 1);
    v66 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v65, "setValue:", v66);

    objc_msgSend(v23, "addObject:", v65);
  }
  LOBYTE(v88[0]) = 0;
  LOBYTE(v88[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v87);
  v67 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("include_zero_pad"), 2147483656, &unk_1E0E9A408);
  if (v67)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v88, 1);
    v68 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v67, "setValue:", v68);

    objc_msgSend(v23, "addObject:", v67);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  v70 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v86);
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v85);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v69);
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  v75 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v70, "initWithType:inputs:outputs:properties:regions:", v84, v71, v72, v73, v74);
  v76 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v75;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Computes the gradient backpropagation for the pooling operation in four dimensions. If indices are provided, then output_shape should be provided too and input should not be provided. If input is provided, then indices and output_shape should not be provided.");
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v77);

  if (SHIBYTE(v93) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEF2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolL2NormOpHandler *EmitterViewerSPI::MPSPoolL2NormOpHandler::MPSPoolL2NormOpHandler(EmitterViewerSPI::MPSPoolL2NormOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  uint64_t v16;
  __CFString *v17;
  uint64_t MPSDataType;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  void *v21;
  uint64_t **WindowSizes;
  uint64_t **v23;
  uint64_t InterfaceFor;
  const char *v25;
  int v26;
  const char *v27;
  const char *v28;
  void *v29;
  uint64_t **Strides;
  uint64_t **v31;
  uint64_t v32;
  const char *v33;
  int v34;
  const char *v35;
  const char *v36;
  void *v37;
  uint64_t **InputAttributeNames;
  uint64_t **v39;
  uint64_t v40;
  const char *v41;
  int v42;
  const char *v43;
  const char *v44;
  void *v45;
  unsigned int PaddingStyle;
  void *v47;
  MPSGraphViewerNodePropertyEnumCaseSPI *v48;
  MPSGraphViewerNodePropertyEnumCaseSPI *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumSPI *v53;
  uint64_t **Offsets;
  char v55;
  uint64_t **v56;
  uint64_t v57;
  const char *v58;
  int v59;
  const char *v60;
  const char *v61;
  void *v62;
  MPSGraphViewerNodePropertyDataSPI *v63;
  void *v64;
  MPSGraphViewerNodePropertyDataSPI *v65;
  void *v66;
  void *v67;
  MPSGraphViewerNodeSPI *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  uint64_t v73;
  void *v74;
  void *v75;
  _QWORD *AttrData;
  uint64_t v78;
  BOOL v79;
  void *v81;
  void *v82;
  void *v83;
  mlir::Operation *v84;
  uint64_t v85[4];
  __int16 v86;
  uint64_t v87[4];
  __int16 v88;
  void *__dst[2];
  int64_t v90;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03C98;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v78 == 19)
    {
      v79 = *AttrData == 0x6C6F6F702E73706DLL && AttrData[1] == 0x6E5F326C5F676E69;
      if (v79 && *(_QWORD *)((char *)AttrData + 11) == 0x6D726F6E5F326C5FLL)
      {
        v88 = 1283;
        v87[0] = (uint64_t)"classof on '";
        v87[2] = (uint64_t)"mps.pooling_l2_norm";
        v87[3] = 19;
        v85[0] = (uint64_t)"' failed due to the operation not being registered";
        v86 = 259;
        llvm::operator+(v87, v85, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_86:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id)
    goto LABEL_86;
  v84 = a3;
  v87[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v87);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v90 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v90) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v90 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v84);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v83, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v84);
  v17 = CFSTR("result");
  if (v16)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v19, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v16));

    if (v20)
      objc_msgSend(v82, "addObject:", v20);
  }
  else
  {

    v20 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  WindowSizes = (uint64_t **)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v84);
  v23 = WindowSizes;
  if (!WindowSizes)
  {
    InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    v25 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v26 = 692;
    v27 = "Casting.h";
    v28 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v23))
  {
    v25 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v26 = 566;
    v27 = "Casting.h";
    v28 = "cast";
LABEL_65:
    __assert_rtn(v28, v27, v26, v25);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v23);
  if (!InterfaceFor)
  {
    v25 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v26 = 98;
    v27 = "InterfaceSupport.h";
    v28 = "Interface";
    goto LABEL_65;
  }
LABEL_26:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("window_sizes"), (uint64_t)v23, InterfaceFor);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  if (v29)
    objc_msgSend(v21, "addObject:", v29);
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v84);
  v31 = Strides;
  if (!Strides)
  {
    v32 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v33 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v34 = 692;
    v35 = "Casting.h";
    v36 = "cast_if_present";
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v31))
  {
    v33 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v34 = 566;
    v35 = "Casting.h";
    v36 = "cast";
LABEL_68:
    __assert_rtn(v36, v35, v34, v33);
  }
  v32 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v31);
  if (!v32)
  {
    v33 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v34 = 98;
    v35 = "InterfaceSupport.h";
    v36 = "Interface";
    goto LABEL_68;
  }
LABEL_34:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v31, v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  if (v37)
    objc_msgSend(v21, "addObject:", v37);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v84);
  v39 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v40 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v41 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v42 = 692;
    v43 = "Casting.h";
    v44 = "cast_if_present";
    goto LABEL_71;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v39))
  {
    v41 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v42 = 566;
    v43 = "Casting.h";
    v44 = "cast";
LABEL_71:
    __assert_rtn(v44, v43, v42, v41);
  }
  v40 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v39);
  if (!v40)
  {
    v41 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v42 = 98;
    v43 = "InterfaceSupport.h";
    v44 = "Interface";
    goto LABEL_71;
  }
LABEL_42:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v39, v40);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  if (v45)
    objc_msgSend(v21, "addObject:", v45);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v84);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  v48 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v47, "addObject:", v48);

  v49 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v47, "addObject:", v49);

  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v47, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v47, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v47, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v47, PaddingStyle);
  if (v53)
    objc_msgSend(v21, "addObject:", v53);

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v84);
  if (v55)
  {
    v56 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56))
        {
          v57 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56);
          if (!v57)
          {
            v58 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v59 = 98;
            v60 = "InterfaceSupport.h";
            v61 = "Interface";
            goto LABEL_74;
          }
          goto LABEL_53;
        }
        v58 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v59 = 566;
        v60 = "Casting.h";
        v61 = "cast";
      }
      else
      {
        v58 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v59 = 692;
        v60 = "Casting.h";
        v61 = "cast_if_present";
      }
LABEL_74:
      __assert_rtn(v61, v60, v59, v58);
    }
    v57 = 0;
LABEL_53:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v56, v57);
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    if (v62)
      objc_msgSend(v21, "addObject:", v62);

  }
  LOBYTE(v87[0]) = 0;
  LOBYTE(v87[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v84);
  v63 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("ceil_mode"), 2147483656, &unk_1E0E9A420);
  if (v63)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v87, 1);
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v63, "setValue:", v64);

    objc_msgSend(v21, "addObject:", v63);
  }
  LOBYTE(v85[0]) = 0;
  LOBYTE(v85[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v84);
  v65 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("include_zero_pad"), 2147483656, &unk_1E0E9A438);
  if (v65)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v85, 1);
    v66 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v65, "setValue:", v66);

    objc_msgSend(v21, "addObject:", v65);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  v68 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v83);
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v82);
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v67);
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v68, "initWithType:inputs:outputs:properties:regions:", v81, v69, v70, v71, v72);
  v74 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v73;

  v75 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v75);

  if (SHIBYTE(v90) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EEFE9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolMaxGradientOpHandler *EmitterViewerSPI::MPSPoolMaxGradientOpHandler::MPSPoolMaxGradientOpHandler(EmitterViewerSPI::MPSPoolMaxGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t v16;
  void *v17;
  unint64_t Indices;
  void *v19;
  unint64_t OutputShape;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  uint64_t **WindowSizes;
  uint64_t **v29;
  uint64_t InterfaceFor;
  const char *v31;
  int v32;
  const char *v33;
  const char *v34;
  uint64_t **Strides;
  uint64_t **v36;
  uint64_t v37;
  const char *v38;
  int v39;
  const char *v40;
  const char *v41;
  void *v42;
  uint64_t **InputAttributeNames;
  uint64_t **v44;
  uint64_t v45;
  const char *v46;
  int v47;
  const char *v48;
  const char *v49;
  void *v50;
  unsigned int WeightsLayout;
  void *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumCaseSPI *v57;
  MPSGraphViewerNodePropertyEnumSPI *v58;
  uint64_t **Offsets;
  char v60;
  uint64_t **v61;
  uint64_t v62;
  const char *v63;
  int v64;
  const char *v65;
  const char *v66;
  void *v67;
  MPSGraphViewerNodePropertyDataSPI *v68;
  void *v69;
  MPSGraphViewerNodePropertyDataSPI *v70;
  void *v71;
  unsigned int PaddingStyle;
  void *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumSPI *v82;
  void *v83;
  MPSGraphViewerNodeSPI *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  uint64_t v89;
  void *v90;
  void *v91;
  _QWORD *AttrData;
  uint64_t v94;
  BOOL v95;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  mlir::Operation *v101;
  uint64_t v102[4];
  __int16 v103;
  uint64_t v104[4];
  __int16 v105;
  void *__dst[2];
  int64_t v107;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04460;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v94 == 24)
    {
      v95 = *AttrData == 0x6C6F6F702E73706DLL && AttrData[1] == 0x5F78616D5F676E69;
      if (v95 && AttrData[2] == 0x746E656964617267)
      {
        v105 = 1283;
        v104[0] = (uint64_t)"classof on '";
        v104[2] = (uint64_t)"mps.pooling_max_gradient";
        v104[3] = 24;
        v102[0] = (uint64_t)"' failed due to the operation not being registered";
        v103 = 259;
        llvm::operator+(v104, v102, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolMaxGradientOp,void>::id)
    goto LABEL_94;
  v101 = a3;
  v104[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v104);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v107 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v107) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v107 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v98 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v100 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v101);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v100, "addObject:", v15);
  v16 = mlir::mps::PoolMaxGradientOp::getInput((mlir::mps::PoolMaxGradientOp *)&v101);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), v16);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v100, "addObject:", v17);

  Indices = mlir::mps::PoolMaxGradientOp::getIndices((mlir::mps::PoolMaxGradientOp *)&v101);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("indices"), Indices);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v100, "addObject:", v19);

  OutputShape = mlir::mps::PoolMaxGradientOp::getOutputShape((mlir::mps::PoolMaxGradientOp *)&v101);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("output_shape"), OutputShape);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  if (v21)
    objc_msgSend(v100, "addObject:", v21);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v99 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v101);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v99, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  WindowSizes = (uint64_t **)mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v101);
  v29 = WindowSizes;
  if (!WindowSizes)
  {
    InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    v31 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v32 = 692;
    v33 = "Casting.h";
    v34 = "cast_if_present";
    goto LABEL_73;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v29))
  {
    v31 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v32 = 566;
    v33 = "Casting.h";
    v34 = "cast";
LABEL_73:
    __assert_rtn(v34, v33, v32, v31);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v29);
  if (!InterfaceFor)
  {
    v31 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v32 = 98;
    v33 = "InterfaceSupport.h";
    v34 = "Interface";
    goto LABEL_73;
  }
LABEL_32:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("window_sizes"), (uint64_t)v29, InterfaceFor);
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  if (v97)
    objc_msgSend(v27, "addObject:", v97);
  Strides = (uint64_t **)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v101);
  v36 = Strides;
  if (!Strides)
  {
    v37 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v38 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v39 = 692;
    v40 = "Casting.h";
    v41 = "cast_if_present";
    goto LABEL_76;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v36))
  {
    v38 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v39 = 566;
    v40 = "Casting.h";
    v41 = "cast";
LABEL_76:
    __assert_rtn(v41, v40, v39, v38);
  }
  v37 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v36);
  if (!v37)
  {
    v38 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v39 = 98;
    v40 = "InterfaceSupport.h";
    v41 = "Interface";
    goto LABEL_76;
  }
LABEL_40:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v36, v37);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  if (v42)
    objc_msgSend(v27, "addObject:", v42);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v101);
  v44 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v45 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v46 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v47 = 692;
    v48 = "Casting.h";
    v49 = "cast_if_present";
    goto LABEL_79;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v44))
  {
    v46 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v47 = 566;
    v48 = "Casting.h";
    v49 = "cast";
LABEL_79:
    __assert_rtn(v49, v48, v47, v46);
  }
  v45 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v44);
  if (!v45)
  {
    v46 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v47 = 98;
    v48 = "InterfaceSupport.h";
    v49 = "Interface";
    goto LABEL_79;
  }
LABEL_48:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v44, v45);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  if (v50)
    objc_msgSend(v27, "addObject:", v50);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v101);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v52, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v52, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v52, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v52, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v52, "addObject:", v57);

  v58 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v52, WeightsLayout);
  if (v58)
    objc_msgSend(v27, "addObject:", v58);

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v101);
  if (v60)
  {
    v61 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v61))
        {
          v62 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v61);
          if (!v62)
          {
            v63 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v64 = 98;
            v65 = "InterfaceSupport.h";
            v66 = "Interface";
            goto LABEL_82;
          }
          goto LABEL_59;
        }
        v63 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v64 = 566;
        v65 = "Casting.h";
        v66 = "cast";
      }
      else
      {
        v63 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v64 = 692;
        v65 = "Casting.h";
        v66 = "cast_if_present";
      }
LABEL_82:
      __assert_rtn(v66, v65, v64, v63);
    }
    v62 = 0;
LABEL_59:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v61, v62);
    v67 = (void *)objc_claimAutoreleasedReturnValue();
    if (v67)
      objc_msgSend(v27, "addObject:", v67);

  }
  LOBYTE(v104[0]) = 0;
  LOBYTE(v104[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v101);
  v68 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("ceil_mode"), 2147483656, &unk_1E0E9A450);
  if (v68)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v104, 1);
    v69 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v68, "setValue:", v69);

    objc_msgSend(v27, "addObject:", v68);
  }
  LOBYTE(v102[0]) = 0;
  LOBYTE(v102[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v101);
  v70 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("include_zero_pad"), 2147483656, &unk_1E0E9A468);
  if (v70)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v102, 1);
    v71 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v70, "setValue:", v71);

    objc_msgSend(v27, "addObject:", v70);
  }
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v101);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Global_Flatten1D"), 0);
  objc_msgSend(v73, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Global_Flatten2D"), 1);
  objc_msgSend(v73, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Global_Flatten3D"), 2);
  objc_msgSend(v73, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Global_Flatten4D"), 3);
  objc_msgSend(v73, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Local_Flatten1D"), 4);
  objc_msgSend(v73, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Local_Flatten2D"), 5);
  objc_msgSend(v73, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Local_Flatten3D"), 6);
  objc_msgSend(v73, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Local_Flatten4D"), 7);
  objc_msgSend(v73, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("indices_mode"), CFSTR("MPSPoolIndicesMode"), v73, PaddingStyle);
  if (v82)
    objc_msgSend(v27, "addObject:", v82);

  mlir::mps::PoolMaxGradientOp::getIndicesResultType((mlir::mps::PoolMaxGradientOp *)&v101);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  v84 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v100);
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v99);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v87 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v83);
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  v89 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v84, "initWithType:inputs:outputs:properties:regions:", v98, v85, v86, v87, v88);
  v90 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v89;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Computes the gradient backpropagation for the pooling operation in four dimensions. If indices are provided, then output_shape should be provided too and input should not be provided. If input is provided, then indices and output_shape should not be provided.");
  v91 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v91);

  if (SHIBYTE(v107) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF0CB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolMaxOpHandler *EmitterViewerSPI::MPSPoolMaxOpHandler::MPSPoolMaxOpHandler(EmitterViewerSPI::MPSPoolMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  MPSGraphViewerNodePortSPI *v16;
  __CFString *v17;
  uint64_t MPSDataType;
  void *v19;
  uint64_t Element;
  __CFString *v21;
  uint64_t v22;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  uint64_t **WindowSizes;
  uint64_t **v27;
  uint64_t InterfaceFor;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t **Strides;
  uint64_t **v34;
  uint64_t v35;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  void *v40;
  uint64_t **InputAttributeNames;
  uint64_t **v42;
  uint64_t v43;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  void *v48;
  unsigned int WeightsLayout;
  void *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumSPI *v56;
  uint64_t **Offsets;
  char v58;
  uint64_t **v59;
  uint64_t v60;
  const char *v61;
  int v62;
  const char *v63;
  const char *v64;
  void *v65;
  MPSGraphViewerNodePropertyDataSPI *v66;
  void *v67;
  MPSGraphViewerNodePropertyDataSPI *v68;
  void *v69;
  unsigned int PaddingStyle;
  void *v71;
  MPSGraphViewerNodePropertyEnumCaseSPI *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumCaseSPI *v77;
  MPSGraphViewerNodePropertyEnumCaseSPI *v78;
  MPSGraphViewerNodePropertyEnumCaseSPI *v79;
  MPSGraphViewerNodePropertyEnumSPI *v80;
  void *v81;
  MPSGraphViewerNodeSPI *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  uint64_t v87;
  void *v88;
  void *v89;
  _QWORD *AttrData;
  uint64_t v92;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  mlir::Operation *v98;
  uint64_t v99[4];
  __int16 v100;
  uint64_t v101[4];
  __int16 v102;
  void *__dst[2];
  int64_t v104;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03650;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v92 == 15 && *AttrData == 0x6C6F6F702E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x78616D5F676E696CLL)
    {
      v102 = 1283;
      v101[0] = (uint64_t)"classof on '";
      v101[2] = (uint64_t)"mps.pooling_max";
      v101[3] = 15;
      v99[0] = (uint64_t)"' failed due to the operation not being registered";
      v100 = 259;
      llvm::operator+(v101, v99, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_89:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolMaxOp,void>::id)
    goto LABEL_89;
  v98 = a3;
  v101[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v101);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v104 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v104) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v104 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v95 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v96 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v98);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v96, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v97 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v98);
  v17 = CFSTR("result");
  if (v16)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v16->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v16->_dataType & 0xFFFFFFFFFFFFFFF8));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v16 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v19, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v16));

    if (v16)
      objc_msgSend(v97, "addObject:", v16);
  }
  else
  {

  }
  Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v98);
  v21 = CFSTR("indices");
  if (Element)
  {
    v22 = getMPSDataType((_QWORD *)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("indices"), v22, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Element));

    if (v24)
      objc_msgSend(v97, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  WindowSizes = (uint64_t **)mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v98);
  v27 = WindowSizes;
  if (!WindowSizes)
  {
    InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v30 = 692;
    v31 = "Casting.h";
    v32 = "cast_if_present";
    goto LABEL_71;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v30 = 566;
    v31 = "Casting.h";
    v32 = "cast";
LABEL_71:
    __assert_rtn(v32, v31, v30, v29);
  }
  InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v30 = 98;
    v31 = "InterfaceSupport.h";
    v32 = "Interface";
    goto LABEL_71;
  }
LABEL_30:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("window_sizes"), (uint64_t)v27, InterfaceFor);
  v94 = (void *)objc_claimAutoreleasedReturnValue();
  if (v94)
    objc_msgSend(v25, "addObject:", v94);
  Strides = (uint64_t **)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v98);
  v34 = Strides;
  if (!Strides)
  {
    v35 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v37 = 692;
    v38 = "Casting.h";
    v39 = "cast_if_present";
    goto LABEL_74;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v37 = 566;
    v38 = "Casting.h";
    v39 = "cast";
LABEL_74:
    __assert_rtn(v39, v38, v37, v36);
  }
  v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v37 = 98;
    v38 = "InterfaceSupport.h";
    v39 = "Interface";
    goto LABEL_74;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v34, v35);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  if (v40)
    objc_msgSend(v25, "addObject:", v40);
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v98);
  v42 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    v43 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v45 = 692;
    v46 = "Casting.h";
    v47 = "cast_if_present";
    goto LABEL_77;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v45 = 566;
    v46 = "Casting.h";
    v47 = "cast";
LABEL_77:
    __assert_rtn(v47, v46, v45, v44);
  }
  v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v45 = 98;
    v46 = "InterfaceSupport.h";
    v47 = "Interface";
    goto LABEL_77;
  }
LABEL_46:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v42, v43);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  if (v48)
    objc_msgSend(v25, "addObject:", v48);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v98);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v50, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v50, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v50, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v50, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v50, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v50, WeightsLayout);
  if (v56)
    objc_msgSend(v25, "addObject:", v56);

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v98);
  if (v58)
  {
    v59 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v59))
        {
          v60 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v59);
          if (!v60)
          {
            v61 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v62 = 98;
            v63 = "InterfaceSupport.h";
            v64 = "Interface";
            goto LABEL_80;
          }
          goto LABEL_57;
        }
        v61 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v62 = 566;
        v63 = "Casting.h";
        v64 = "cast";
      }
      else
      {
        v61 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v62 = 692;
        v63 = "Casting.h";
        v64 = "cast_if_present";
      }
LABEL_80:
      __assert_rtn(v64, v63, v62, v61);
    }
    v60 = 0;
LABEL_57:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v59, v60);
    v65 = (void *)objc_claimAutoreleasedReturnValue();
    if (v65)
      objc_msgSend(v25, "addObject:", v65);

  }
  LOBYTE(v101[0]) = 0;
  LOBYTE(v101[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v98);
  v66 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("ceil_mode"), 2147483656, &unk_1E0E9A480);
  if (v66)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v101, 1);
    v67 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v66, "setValue:", v67);

    objc_msgSend(v25, "addObject:", v66);
  }
  LOBYTE(v99[0]) = 0;
  LOBYTE(v99[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v98);
  v68 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("include_zero_pad"), 2147483656, &unk_1E0E9A498);
  if (v68)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v99, 1);
    v69 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v68, "setValue:", v69);

    objc_msgSend(v25, "addObject:", v68);
  }
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v98);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  v72 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Global_Flatten1D"), 0);
  objc_msgSend(v71, "addObject:", v72);

  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Global_Flatten2D"), 1);
  objc_msgSend(v71, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Global_Flatten3D"), 2);
  objc_msgSend(v71, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Global_Flatten4D"), 3);
  objc_msgSend(v71, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Local_Flatten1D"), 4);
  objc_msgSend(v71, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Local_Flatten2D"), 5);
  objc_msgSend(v71, "addObject:", v77);

  v78 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Local_Flatten3D"), 6);
  objc_msgSend(v71, "addObject:", v78);

  v79 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("Local_Flatten4D"), 7);
  objc_msgSend(v71, "addObject:", v79);

  v80 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("indices_mode"), CFSTR("MPSPoolIndicesMode"), v71, PaddingStyle);
  if (v80)
    objc_msgSend(v25, "addObject:", v80);

  mlir::mps::PoolMaxGradientOp::getIndicesResultType((mlir::mps::PoolMaxGradientOp *)&v98);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v81 = (void *)objc_claimAutoreleasedReturnValue();
  v82 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v96);
  v83 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v97);
  v84 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v81);
  v86 = (void *)objc_claimAutoreleasedReturnValue();
  v87 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v82, "initWithType:inputs:outputs:properties:regions:", v95, v83, v84, v85, v86);
  v88 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v87;

  v89 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v89);

  if (SHIBYTE(v104) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF1B70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPowerOpHandler *EmitterViewerSPI::MPSPowerOpHandler::MPSPowerOpHandler(EmitterViewerSPI::MPSPowerOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03218;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 9 && *(_QWORD *)AttrData == 0x65776F702E73706DLL && *(_BYTE *)(AttrData + 8) == 114)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.power";
      v43[3] = 9;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF2264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPruningGradientOpHandler *EmitterViewerSPI::MPSPruningGradientOpHandler::MPSPruningGradientOpHandler(EmitterViewerSPI::MPSPruningGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  unsigned int StorageType;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumSPI *v29;
  unsigned int Layout;
  void *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumSPI *v34;
  MPSGraphViewerNodePropertyDataSPI *v35;
  void *v36;
  void *v37;
  llvm::APFloatBase *v38;
  void *v39;
  MPSGraphViewerNodeSPI *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  uint64_t v45;
  void *v46;
  void *v47;
  uint64_t AttrData;
  uint64_t v50;
  BOOL v51;
  void *v53;
  mlir::Operation *v54;
  const char *v55;
  __int16 v56;
  void *__dst[2];
  const char *v58;
  uint64_t v59;
  __int16 v60;
  uint64_t v61;
  void *v62;
  _QWORD v63[5];

  v63[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04478;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v61 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v61);
    if (v50 == 18)
    {
      v51 = *(_QWORD *)AttrData == 0x6E7572702E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6569646172675F65;
      if (v51 && *(_WORD *)(AttrData + 16) == 29806)
      {
        v60 = 1283;
        __dst[0] = "classof on '";
        v58 = "mps.prune_gradient";
        v59 = 18;
        v55 = "' failed due to the operation not being registered";
        v56 = 259;
        llvm::operator+((uint64_t *)__dst, (uint64_t *)&v55, (uint64_t)&v61);
        llvm::report_fatal_error((llvm::Twine *)&v61, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PruningGradientOp,void>::id)
    goto LABEL_45;
  v54 = a3;
  v61 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v61);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v58 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v58) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v58) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("incoming_gradient"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v54);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("magnitude_pruning"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("pruning_metric"), CFSTR("MPSPruningMetric"), v27, StorageType);
  if (v29)
    objc_msgSend(v25, "addObject:", v29);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v54);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("random_pruning"), 0);
  objc_msgSend(v31, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("block_1d_2_4_pruning"), 1);
  objc_msgSend(v31, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("pruning_structure"), CFSTR("MPSPruningStructure"), v31, Layout);
  if (v34)
    objc_msgSend(v25, "addObject:", v34);

  mlir::mps::PruningOp::getSparsity((mlir::mps::PruningOp *)&v54, (uint64_t)&v61);
  v35 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("sparsity"), 268435488, &unk_1E0E9A4B0);
  if (v35)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v61, 32);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v35, "setValue:", v36);

    objc_msgSend(v25, "addObject:", v35);
  }

  v37 = v62;
  if (llvm::APFloatBase::PPCDoubleDouble(v38) == v37)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v63);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v62);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v39);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v45 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v40, "initWithType:inputs:outputs:properties:regions:", v53, v41, v42, v43, v44);
  v46 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v45;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Gradient of prune tensor. Computed based on a pruning metric, a target sparsity and a pruning structure.");
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v47);

  if (SHIBYTE(v58) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF2A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25)
{
  uint64_t v25;
  void *v26;
  void *v27;
  void *v28;

  if (a22 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPruningOpHandler *EmitterViewerSPI::MPSPruningOpHandler::MPSPruningOpHandler(EmitterViewerSPI::MPSPruningOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  unsigned int StorageType;
  void *v25;
  MPSGraphViewerNodePropertyEnumCaseSPI *v26;
  MPSGraphViewerNodePropertyEnumSPI *v27;
  unsigned int Layout;
  void *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumCaseSPI *v31;
  MPSGraphViewerNodePropertyEnumSPI *v32;
  MPSGraphViewerNodePropertyDataSPI *v33;
  void *v34;
  void *v35;
  llvm::APFloatBase *v36;
  void *v37;
  MPSGraphViewerNodeSPI *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  void *v44;
  void *v45;
  uint64_t AttrData;
  uint64_t v48;
  void *v50;
  mlir::Operation *v51;
  const char *v52;
  __int16 v53;
  void *__dst[2];
  const char *v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  void *v59;
  _QWORD v60[5];

  v60[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03668;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v58 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v58);
    if (v48 == 9 && *(_QWORD *)AttrData == 0x6E7572702E73706DLL && *(_BYTE *)(AttrData + 8) == 101)
    {
      v57 = 1283;
      __dst[0] = "classof on '";
      v55 = "mps.prune";
      v56 = 9;
      v52 = "' failed due to the operation not being registered";
      v53 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v52, (uint64_t)&v58);
      llvm::report_fatal_error((llvm::Twine *)&v58, 1);
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PruningOp,void>::id)
    goto LABEL_40;
  v51 = a3;
  v58 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v58);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v55 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v55) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v51);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("magnitude_pruning"), 0);
  objc_msgSend(v25, "addObject:", v26);

  v27 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("pruning_metric"), CFSTR("MPSPruningMetric"), v25, StorageType);
  if (v27)
    objc_msgSend(v23, "addObject:", v27);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v51);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("random_pruning"), 0);
  objc_msgSend(v29, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("block_1d_2_4_pruning"), 1);
  objc_msgSend(v29, "addObject:", v31);

  v32 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("pruning_structure"), CFSTR("MPSPruningStructure"), v29, Layout);
  if (v32)
    objc_msgSend(v23, "addObject:", v32);

  mlir::mps::PruningOp::getSparsity((mlir::mps::PruningOp *)&v51, (uint64_t)&v58);
  v33 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("sparsity"), 268435488, &unk_1E0E9A4C8);
  if (v33)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v58, 32);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v33, "setValue:", v34);

    objc_msgSend(v23, "addObject:", v33);
  }

  v35 = v59;
  if (llvm::APFloatBase::PPCDoubleDouble(v36) == v35)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v60);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v59);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v37);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v38, "initWithType:inputs:outputs:properties:regions:", v50, v39, v40, v41, v42);
  v44 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v43;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Prune a tensor based on a pruning metric, a target sparsity and a pruning structure.");
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v45);

  if (SHIBYTE(v55) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF322C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25)
{
  uint64_t v25;
  void *v26;
  void *v27;
  void *v28;

  if (a22 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSQuantizeOpHandler *EmitterViewerSPI::MPSQuantizeOpHandler::MPSQuantizeOpHandler(EmitterViewerSPI::MPSQuantizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t AttrData;
  uint64_t v41;
  void *v43;
  mlir::Operation *v44;
  const char *v45;
  __int16 v46;
  uint64_t v47[4];
  __int16 v48;
  void *__dst[2];
  int64_t v50;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03908;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 12 && *(_QWORD *)AttrData == 0x6E6175712E73706DLL && *(_DWORD *)(AttrData + 8) == 1702521204)
    {
      v48 = 1283;
      v47[0] = (uint64_t)"classof on '";
      v47[2] = (uint64_t)"mps.quantize";
      v47[3] = 12;
      v45 = "' failed due to the operation not being registered";
      v46 = 259;
      llvm::operator+(v47, (uint64_t *)&v45, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id)
    goto LABEL_41;
  v44 = a3;
  v47[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v50 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("scale"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("zero_point"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v44);
  v47[0] = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v44);
  if ((v47[0] & 0xFF00000000) != 0)
  {
    v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("axis"), 536870944, &unk_1E0E9A4E0);
    if (v28)
    {
      if (!BYTE4(v47[0]))
        std::__throw_bad_optional_access[abi:ne180100]();
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v47, 8);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

      objc_msgSend(v27, "addObject:", v28);
    }

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v43, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v50) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF3918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRandomNormalOpHandler *EmitterViewerSPI::MPSRandomNormalOpHandler::MPSRandomNormalOpHandler(EmitterViewerSPI::MPSRandomNormalOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  llvm::APFloatBase *v31;
  void *v32;
  void *v33;
  MPSGraphViewerNodeSPI *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  uint64_t v39;
  void *v40;
  void *v41;
  uint64_t AttrData;
  uint64_t v44;
  BOOL v45;
  void *v47;
  mlir::Operation *v48;
  void *__dst[2];
  int64_t v50;
  __int16 v51;
  const char *v52;
  void *v53;
  _QWORD v54[2];
  __int16 v55;
  uint64_t v56;
  void *v57;
  _QWORD v58[4];

  v58[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03ED8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v56 = *(_QWORD *)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v56);
    if (v44 == 17)
    {
      v45 = *(_QWORD *)AttrData == 0x646E61722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x616D726F6E5F6D6FLL;
      if (v45 && *(_BYTE *)(AttrData + 16) == 108)
      {
        v55 = 1283;
        v52 = "classof on '";
        v54[0] = "mps.random_normal";
        v54[1] = 17;
        __dst[0] = "' failed due to the operation not being registered";
        v51 = 259;
        llvm::operator+((uint64_t *)&v52, (uint64_t *)__dst, (uint64_t)&v56);
        llvm::report_fatal_error((llvm::Twine *)&v56, 1);
      }
    }
LABEL_46:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RandomNormalOp,void>::id)
    goto LABEL_46;
  v48 = a3;
  v56 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v56);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v50 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("state"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v48);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v48);
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v48, (uint64_t)&v56);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("mean"), 268435488, &unk_1E0E9A4F8);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v56, 32);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  mlir::mps::RandomNormalOp::getStdDev((mlir::mps::RandomNormalOp *)&v48, (uint64_t)&v52);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("std_dev"), 268435488, &unk_1E0E9A510);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v52, 32);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }
  mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v48);

  v30 = v53;
  v32 = llvm::APFloatBase::PPCDoubleDouble(v31);
  if (v32 == v30)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v54);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v53);

  if (v32 == v57)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v58);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v57);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v33);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v34, "initWithType:inputs:outputs:properties:regions:", v47, v35, v36, v37, v38);
  v40 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v39;

  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v41);

  if (SHIBYTE(v50) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF4078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  if (a16 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler *EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler::MPSRandomTruncatedNormalOpHandler(EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  uint64_t v19;
  __CFString *v20;
  uint64_t MPSDataType;
  void *v22;
  MPSGraphViewerNodePortSPI *v23;
  void *v24;
  MPSGraphViewerNodePropertyDataSPI *v25;
  void *v26;
  MPSGraphViewerNodePropertyDataSPI *v27;
  void *v28;
  MPSGraphViewerNodePropertyDataSPI *v29;
  void *v30;
  MPSGraphViewerNodePropertyDataSPI *v31;
  void *v32;
  void *v33;
  llvm::APFloatBase *v34;
  void *v35;
  void *v36;
  MPSGraphViewerNodeSPI *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  void *v43;
  void *v44;
  _QWORD *AttrData;
  uint64_t v47;
  BOOL v48;
  BOOL v49;
  void *v51;
  void *v52;
  void *__dst[2];
  int64_t v54;
  mlir::Operation *v55;
  char v56[8];
  void *v57;
  uint64_t v58;
  const char *v59;
  void *v60;
  _WORD v61[12];
  const char *v62;
  void *v63;
  _QWORD v64[2];
  __int16 v65;
  uint64_t v66;
  void *v67;
  _QWORD v68[5];

  v68[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E049B8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v66 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v66);
    if (v47 == 27)
    {
      v48 = *AttrData == 0x646E61722E73706DLL && AttrData[1] == 0x636E7572745F6D6FLL;
      v49 = v48 && AttrData[2] == 0x726F6E5F64657461;
      if (v49 && *(_QWORD *)((char *)AttrData + 19) == 0x6C616D726F6E5F64)
      {
        v65 = 1283;
        v62 = "classof on '";
        v64[0] = "mps.random_truncated_normal";
        v64[1] = 27;
        v59 = "' failed due to the operation not being registered";
        v61[8] = 259;
        llvm::operator+((uint64_t *)&v62, (uint64_t *)&v59, (uint64_t)&v66);
        llvm::report_fatal_error((llvm::Twine *)&v66, 1);
      }
    }
LABEL_59:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RandomTruncatedNormalOp,void>::id)
    goto LABEL_59;
  v55 = a3;
  v66 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v66);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v54 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v54) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v54 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v51 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v55);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("state"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v55);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  v19 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v55);
  v20 = CFSTR("result");
  if (v19)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v22, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v19));

    if (v23)
      objc_msgSend(v52, "addObject:", v23);
  }
  else
  {

    v23 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::mps::RandomTruncatedNormalOp::getResultElementType((mlir::mps::RandomTruncatedNormalOp *)&v55);
  mlir::mps::RandomTruncatedNormalOp::getMean((mlir::mps::RandomTruncatedNormalOp *)&v55, (uint64_t)&v66);
  v25 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("mean"), 268435488, &unk_1E0E9A528);
  if (v25)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v66, 32);
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v25, "setValue:", v26);

    objc_msgSend(v24, "addObject:", v25);
  }
  mlir::mps::RandomTruncatedNormalOp::getStdDev((mlir::mps::RandomTruncatedNormalOp *)&v55, (uint64_t)&v62);
  v27 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("std_dev"), 268435488, &unk_1E0E9A540);
  if (v27)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v62, 32);
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v27, "setValue:", v28);

    objc_msgSend(v24, "addObject:", v27);
  }
  mlir::mps::PruningOp::getSparsity((mlir::mps::PruningOp *)&v55, (uint64_t)&v59);
  v29 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("minimum"), 268435488, &unk_1E0E9A558);
  if (v29)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v59, 32);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v29, "setValue:", v30);

    objc_msgSend(v24, "addObject:", v29);
  }
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v55, (uint64_t)v56);
  v31 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("maximum"), 268435488, &unk_1E0E9A570);
  if (v31)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v56, 32);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v31, "setValue:", v32);

    objc_msgSend(v24, "addObject:", v31);
  }
  mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v55);

  v33 = v57;
  v35 = llvm::APFloatBase::PPCDoubleDouble(v34);
  if (v35 == v33)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v58);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v57);

  if (v35 == v60)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v61);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v60);

  if (v35 == v63)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v64);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v63);

  if (v35 == v67)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v68);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v67);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v52);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v36);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  v42 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v37, "initWithType:inputs:outputs:properties:regions:", v51, v38, v39, v40, v41);
  v43 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v42;

  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v44);

  if (SHIBYTE(v54) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF4950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;
  void *v29;
  void *v30;

  if (a17 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRandomUniformOpHandler *EmitterViewerSPI::MPSRandomUniformOpHandler::MPSRandomUniformOpHandler(EmitterViewerSPI::MPSRandomUniformOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  void *v28;
  void *v29;
  MPSGraphViewerNodeSPI *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  uint64_t v35;
  void *v36;
  void *v37;
  uint64_t AttrData;
  uint64_t v40;
  BOOL v41;
  void *v43;
  mlir::Operation *v44;
  const char *v45;
  __int16 v46;
  uint64_t v47[4];
  __int16 v48;
  void *__dst[2];
  int64_t v50;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04130;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 18)
    {
      v41 = *(_QWORD *)AttrData == 0x646E61722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6F66696E755F6D6FLL;
      if (v41 && *(_WORD *)(AttrData + 16) == 28018)
      {
        v48 = 1283;
        v47[0] = (uint64_t)"classof on '";
        v47[2] = (uint64_t)"mps.random_uniform";
        v47[3] = 18;
        v45 = "' failed due to the operation not being registered";
        v46 = 259;
        llvm::operator+(v47, (uint64_t *)&v45, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RandomUniformOp,void>::id)
    goto LABEL_40;
  v44 = a3;
  v47[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v50 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("state"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("minimum"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v44);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("maximum"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v24)
      objc_msgSend(v23, "addObject:", v24);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v44);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v30, "initWithType:inputs:outputs:properties:regions:", v43, v31, v32, v33, v34);
  v36 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v35;

  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v37);

  if (SHIBYTE(v50) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF5028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRankOpHandler *EmitterViewerSPI::MPSRankOpHandler::MPSRankOpHandler(EmitterViewerSPI::MPSRankOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02F00;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6B6E61722E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.rank";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RankOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "This op computes the rank of the input tensor and returns it as a scalar tensor.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF55A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReadVariableOpHandler *EmitterViewerSPI::MPSReadVariableOpHandler::MPSReadVariableOpHandler(EmitterViewerSPI::MPSReadVariableOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03EF0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 17)
    {
      v36 = *(_QWORD *)AttrData == 0x646165722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6C6261697261765FLL;
      if (v36 && *(_BYTE *)(AttrData + 16) == 101)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.read_variable";
        v42[3] = 17;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReadVariableOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("resource"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Inserts a variableHandle for a tensor resource.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF5B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRealPartOpHandler *EmitterViewerSPI::MPSRealPartOpHandler::MPSRealPartOpHandler(EmitterViewerSPI::MPSRealPartOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03920;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x6C6165722E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x747261705F6C6165)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.real_part";
      v41[3] = 13;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RealPartOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("output");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Extracts the real part of the input tensor.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF6054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler *EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler::MPSRealToHermiteanFFTOpHandler(EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  unsigned int Layout;
  void *v27;
  MPSGraphViewerNodePropertyEnumCaseSPI *v28;
  MPSGraphViewerNodePropertyEnumCaseSPI *v29;
  MPSGraphViewerNodePropertyEnumCaseSPI *v30;
  MPSGraphViewerNodePropertyEnumSPI *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  uint64_t AttrData;
  uint64_t v45;
  BOOL v46;
  BOOL v47;
  void *v49;
  mlir::Operation *v50;
  const char *v51;
  __int16 v52;
  uint64_t v53[4];
  __int16 v54;
  void *__dst[2];
  int64_t v56;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04778;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 25)
    {
      v46 = *(_QWORD *)AttrData == 0x6C6165722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6D7265685F6F745FLL;
      v47 = v46 && *(_QWORD *)(AttrData + 16) == 0x66665F6E61657469;
      if (v47 && *(_BYTE *)(AttrData + 24) == 116)
      {
        v54 = 1283;
        v53[0] = (uint64_t)"classof on '";
        v53[2] = (uint64_t)"mps.real_to_hermitean_fft";
        v53[3] = 25;
        v51 = "' failed due to the operation not being registered";
        v52 = 259;
        llvm::operator+(v53, (uint64_t *)&v51, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_43:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RealToHermiteanFFTOp,void>::id)
    goto LABEL_43;
  v50 = a3;
  v53[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v53);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v56 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v56) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v56 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v50);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v50);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v50);
  v21 = CFSTR("output");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v50);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v27, "addObject:", v28);

  v29 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("size"), 1);
  objc_msgSend(v27, "addObject:", v29);

  v30 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("unitary"), 2);
  objc_msgSend(v27, "addObject:", v30);

  v31 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("scaling_mode"), CFSTR("MPSFFTScalingMode"), v27, Layout);
  if (v31)
    objc_msgSend(v25, "addObject:", v31);

  LOBYTE(v53[0]) = 0;
  LOBYTE(v53[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v50);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("inverse"), 2147483656, &unk_1E0E9A588);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v53, 1);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v25, "addObject:", v32);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v49, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v42);

  if (SHIBYTE(v56) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF6764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReciprocalOpHandler *EmitterViewerSPI::MPSReciprocalOpHandler::MPSReciprocalOpHandler(EmitterViewerSPI::MPSReciprocalOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03CB0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 14 && *AttrData == 0x696365722E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x6C61636F72706963)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.reciprocal";
      v41[3] = 14;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF6D10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReciprocalSquareRootOpHandler *EmitterViewerSPI::MPSReciprocalSquareRootOpHandler::MPSReciprocalSquareRootOpHandler(EmitterViewerSPI::MPSReciprocalSquareRootOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  BOOL v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0DFA530;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 26)
    {
      v36 = *(_QWORD *)AttrData == 0x696365722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x735F6C61636F7270;
      v37 = v36 && *(_QWORD *)(AttrData + 16) == 0x6F725F6572617571;
      if (v37 && *(_WORD *)(AttrData + 24) == 29807)
      {
        v44 = 1283;
        v43[0] = (uint64_t)"classof on '";
        v43[2] = (uint64_t)"mps.reciprocal_square_root";
        v43[3] = 26;
        v41 = "' failed due to the operation not being registered";
        v42 = 259;
        llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id)
    goto LABEL_37;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v39, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF7284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionAndOpHandler *EmitterViewerSPI::MPSReductionAndOpHandler::MPSReductionAndOpHandler(EmitterViewerSPI::MPSReductionAndOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03F08;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 17)
    {
      v40 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6E615F6E6F697463;
      if (v40 && *(_BYTE *)(AttrData + 16) == 100)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_and";
        v46[3] = 17;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionAndOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A5A0);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF7894(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionArgMaxOpHandler *EmitterViewerSPI::MPSReductionArgMaxOpHandler::MPSReductionArgMaxOpHandler(EmitterViewerSPI::MPSReductionArgMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04490;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 20)
    {
      v40 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x72615F6E6F697463;
      if (v40 && *(_DWORD *)(AttrData + 16) == 2019650919)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_argmax";
        v46[3] = 20;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMaxOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A5B8);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF7ED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionArgMinOpHandler *EmitterViewerSPI::MPSReductionArgMinOpHandler::MPSReductionArgMinOpHandler(EmitterViewerSPI::MPSReductionArgMinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E044A8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 20)
    {
      v40 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x72615F6E6F697463;
      if (v40 && *(_DWORD *)(AttrData + 16) == 1852403047)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_argmin";
        v46[3] = 20;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMinOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A5D0);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF851C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionLogSumExpOpHandler *EmitterViewerSPI::MPSReductionLogSumExpOpHandler::MPSReductionLogSumExpOpHandler(EmitterViewerSPI::MPSReductionLogSumExpOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04790;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 23)
    {
      v40 = *AttrData == 0x756465722E73706DLL && AttrData[1] == 0x6F6C5F6E6F697463;
      if (v40 && *(_QWORD *)((char *)AttrData + 15) == 0x7078656D7573676FLL)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_logsumexp";
        v46[3] = 23;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionLogSumExpOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A5E8);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF8B68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionMaxOpHandler *EmitterViewerSPI::MPSReductionMaxOpHandler::MPSReductionMaxOpHandler(EmitterViewerSPI::MPSReductionMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  uint64_t v46[4];
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03F20;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 17)
    {
      v42 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x616D5F6E6F697463;
      if (v42 && *(_BYTE *)(AttrData + 16) == 120)
      {
        v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.reduction_max";
        v48[3] = 17;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id)
    goto LABEL_40;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A600);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("propagate_nans"), 2147483656, &unk_1E0E9A618);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v44, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF921C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionMeanOpHandler *EmitterViewerSPI::MPSReductionMeanOpHandler::MPSReductionMeanOpHandler(EmitterViewerSPI::MPSReductionMeanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04148;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 18)
    {
      v40 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x656D5F6E6F697463;
      if (v40 && *(_WORD *)(AttrData + 16) == 28257)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_mean";
        v46[3] = 18;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A630);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF9880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionMinOpHandler *EmitterViewerSPI::MPSReductionMinOpHandler::MPSReductionMinOpHandler(EmitterViewerSPI::MPSReductionMinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  void *v30;
  MPSGraphViewerNodeSPI *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t AttrData;
  uint64_t v41;
  BOOL v42;
  void *v44;
  mlir::Operation *v45;
  uint64_t v46[4];
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03F38;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 17)
    {
      v42 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x696D5F6E6F697463;
      if (v42 && *(_BYTE *)(AttrData + 16) == 110)
      {
        v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.reduction_min";
        v48[3] = 17;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMinOp,void>::id)
    goto LABEL_40;
  v45 = a3;
  v48[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v51 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A648);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v48, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("propagate_nans"), 2147483656, &unk_1E0E9A660);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v31, "initWithType:inputs:outputs:properties:regions:", v44, v32, v33, v34, v35);
  v37 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v36;

  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v38);

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EF9F34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionOrOpHandler *EmitterViewerSPI::MPSReductionOrOpHandler::MPSReductionOrOpHandler(EmitterViewerSPI::MPSReductionOrOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03DE8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 16 && *AttrData == 0x756465722E73706DLL && AttrData[1] == 0x726F5F6E6F697463)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.reduction_or";
      v45[3] = 16;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionOrOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v45[0]) = 0;
  LOBYTE(v45[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v42);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A678);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v45, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFA58C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionProdOpHandler *EmitterViewerSPI::MPSReductionProdOpHandler::MPSReductionProdOpHandler(EmitterViewerSPI::MPSReductionProdOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04160;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 18)
    {
      v40 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x72705F6E6F697463;
      if (v40 && *(_WORD *)(AttrData + 16) == 25711)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_prod";
        v46[3] = 18;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A690);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFABCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionSumOpHandler *EmitterViewerSPI::MPSReductionSumOpHandler::MPSReductionSumOpHandler(EmitterViewerSPI::MPSReductionSumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03F50;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 17)
    {
      v40 = *(_QWORD *)AttrData == 0x756465722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x75735F6E6F697463;
      if (v40 && *(_BYTE *)(AttrData + 16) == 109)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_sum";
        v46[3] = 17;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A6A8);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFB20C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionVarianceOpHandler *EmitterViewerSPI::MPSReductionVarianceOpHandler::MPSReductionVarianceOpHandler(EmitterViewerSPI::MPSReductionVarianceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E046B8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 22)
    {
      v40 = *AttrData == 0x756465722E73706DLL && AttrData[1] == 0x61765F6E6F697463;
      if (v40 && *(_QWORD *)((char *)AttrData + 14) == 0x65636E6169726176)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_variance";
        v46[3] = 22;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("keep_dims"), 2147483656, &unk_1E0E9A6C0);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v46, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFB858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReinterpretCastOpHandler *EmitterViewerSPI::MPSReinterpretCastOpHandler::MPSReinterpretCastOpHandler(EmitterViewerSPI::MPSReinterpretCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E044C0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      v36 = *(_QWORD *)AttrData == 0x6E6965722E73706DLL && *(_QWORD *)(AttrData + 8) == 0x5F74657270726574;
      if (v36 && *(_DWORD *)(AttrData + 16) == 1953718627)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.reinterpret_cast";
        v42[3] = 20;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReinterpretCastOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v39);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Returns the input tensor reinterpreted to result_element_type type with the innermost dimension scaled by sizeof(type(input)) / sizeof(result_element_type).");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFBDF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRelu6OpHandler *EmitterViewerSPI::MPSRelu6OpHandler::MPSRelu6OpHandler(EmitterViewerSPI::MPSRelu6OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03230;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x756C65722E73706DLL && *(_BYTE *)(AttrData + 8) == 54)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.relu6";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Relu6Op,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFC340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReluGradOpHandler *EmitterViewerSPI::MPSReluGradOpHandler::MPSReluGradOpHandler(EmitterViewerSPI::MPSReluGradOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  MPSGraphViewerNodePortSPI *v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodeSPI *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03938;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x756C65722E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x646172675F756C65)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.relu_grad";
      v41[3] = 13;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReluGradOp,void>::id)
    goto LABEL_33;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradients"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("features"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v21 = CFSTR("backprops");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("backprops"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v20)
      objc_msgSend(v19, "addObject:", v20);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v26, "initWithType:inputs:outputs:properties:regions:", v37, v27, v28, v29, v30);
  v32 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v31;

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFC89C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180EFC9B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReluOpHandler *EmitterViewerSPI::MPSReluOpHandler::MPSReluOpHandler(EmitterViewerSPI::MPSReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02F18;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x756C65722E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.relu";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFCDE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReshapeOpHandler *EmitterViewerSPI::MPSReshapeOpHandler::MPSReshapeOpHandler(EmitterViewerSPI::MPSReshapeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03680;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 11 && *AttrData == 0x687365722E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x657061687365722ELL)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.reshape";
      v45[3] = 11;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v45[0]) = 0;
  LOBYTE(v45[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v42);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("zero_is_copy"), 2147483656, &unk_1E0E9A6D8);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v45, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFD3EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSResizeGradientOpHandler *EmitterViewerSPI::MPSResizeGradientOpHandler::MPSResizeGradientOpHandler(EmitterViewerSPI::MPSResizeGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Shape;
  void *v18;
  unint64_t Scale;
  void *v20;
  unint64_t Offset;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  unsigned int GateLayout;
  void *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumSPI *v34;
  MPSGraphViewerNodePropertyDataSPI *v35;
  void *v36;
  MPSGraphViewerNodePropertyDataSPI *v37;
  void *v38;
  void *v39;
  MPSGraphViewerNodeSPI *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  uint64_t v45;
  void *v46;
  void *v47;
  _QWORD *AttrData;
  uint64_t v50;
  BOOL v51;
  void *v53;
  mlir::Operation *v54;
  uint64_t v55[4];
  __int16 v56;
  uint64_t v57[4];
  __int16 v58;
  void *__dst[2];
  int64_t v60;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04280;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 19)
    {
      v51 = *AttrData == 0x697365722E73706DLL && AttrData[1] == 0x69646172675F657ALL;
      if (v51 && *(_QWORD *)((char *)AttrData + 11) == 0x746E656964617267)
      {
        v58 = 1283;
        v57[0] = (uint64_t)"classof on '";
        v57[2] = (uint64_t)"mps.resize_gradient";
        v57[3] = 19;
        v55[0] = (uint64_t)"' failed due to the operation not being registered";
        v56 = 259;
        llvm::operator+(v57, v55, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_46:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeGradientOp,void>::id)
    goto LABEL_46;
  v54 = a3;
  v57[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v57);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v60 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v60) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v60 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_gradient"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Shape = mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_shape"), Shape);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Scale = mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("scale"), Scale);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  Offset = mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("offset"), Offset);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v54);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("nearest"), 0);
  objc_msgSend(v31, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("bilinear"), 1);
  objc_msgSend(v31, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("mode"), CFSTR("MPSSamplingMode"), v31, GateLayout);
  if (v34)
    objc_msgSend(v29, "addObject:", v34);

  LOBYTE(v57[0]) = 0;
  LOBYTE(v57[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v54);
  v35 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("center_result"), 2147483656, &unk_1E0E9A6F0);
  if (v35)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v57, 1);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v35, "setValue:", v36);

    objc_msgSend(v29, "addObject:", v35);
  }
  LOBYTE(v55[0]) = 0;
  LOBYTE(v55[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v54);
  v37 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("align_corners"), 2147483656, &unk_1E0E9A708);
  if (v37)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v55, 1);
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v37, "setValue:", v38);

    objc_msgSend(v29, "addObject:", v37);
  }
  mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)&v54);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v39);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v45 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v40, "initWithType:inputs:outputs:properties:regions:", v53, v41, v42, v43, v44);
  v46 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v45;

  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v47);

  if (SHIBYTE(v60) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFDBE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSResizeOpHandler *EmitterViewerSPI::MPSResizeOpHandler::MPSResizeOpHandler(EmitterViewerSPI::MPSResizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Shape;
  void *v18;
  unint64_t Scale;
  void *v20;
  unint64_t Offset;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  unsigned int GateLayout;
  void *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumSPI *v34;
  MPSGraphViewerNodePropertyDataSPI *v35;
  void *v36;
  MPSGraphViewerNodePropertyDataSPI *v37;
  void *v38;
  void *v39;
  MPSGraphViewerNodeSPI *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  uint64_t v45;
  void *v46;
  void *v47;
  uint64_t AttrData;
  uint64_t v50;
  void *v52;
  mlir::Operation *v53;
  uint64_t v54[4];
  __int16 v55;
  uint64_t v56[4];
  __int16 v57;
  void *__dst[2];
  int64_t v59;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03470;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 10 && *(_QWORD *)AttrData == 0x697365722E73706DLL && *(_WORD *)(AttrData + 8) == 25978)
    {
      v57 = 1283;
      v56[0] = (uint64_t)"classof on '";
      v56[2] = (uint64_t)"mps.resize";
      v56[3] = 10;
      v54[0] = (uint64_t)"' failed due to the operation not being registered";
      v55 = 259;
      llvm::operator+(v56, v54, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_43:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id)
    goto LABEL_43;
  v53 = a3;
  v56[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v56);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v59 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v59) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v59 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Shape = mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Shape);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Scale = mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("scale"), Scale);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  Offset = mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("offset"), Offset);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v53);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v53);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("nearest"), 0);
  objc_msgSend(v31, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("bilinear"), 1);
  objc_msgSend(v31, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("mode"), CFSTR("MPSSamplingMode"), v31, GateLayout);
  if (v34)
    objc_msgSend(v29, "addObject:", v34);

  LOBYTE(v56[0]) = 0;
  LOBYTE(v56[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v53);
  v35 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("center_result"), 2147483656, &unk_1E0E9A720);
  if (v35)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v56, 1);
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v35, "setValue:", v36);

    objc_msgSend(v29, "addObject:", v35);
  }
  LOBYTE(v54[0]) = 0;
  LOBYTE(v54[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v53);
  v37 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("align_corners"), 2147483656, &unk_1E0E9A738);
  if (v37)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v54, 1);
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v37, "setValue:", v38);

    objc_msgSend(v29, "addObject:", v37);
  }
  mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)&v53);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v39);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  v45 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v40, "initWithType:inputs:outputs:properties:regions:", v52, v41, v42, v43, v44);
  v46 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v45;

  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v47);

  if (SHIBYTE(v59) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFE424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReverseOpHandler *EmitterViewerSPI::MPSReverseOpHandler::MPSReverseOpHandler(EmitterViewerSPI::MPSReverseOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03698;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x657665722E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x657372657665722ELL)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.reverse";
      v43[3] = 11;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReverseOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Reverse values within tensor along provided axes. If no axes are provided then all axes are reversed.");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFEA50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRintOpHandler *EmitterViewerSPI::MPSRintOpHandler::MPSRintOpHandler(EmitterViewerSPI::MPSRintOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02F30;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x746E69722E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.rint";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RintOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFEFA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRoundOpHandler *EmitterViewerSPI::MPSRoundOpHandler::MPSRoundOpHandler(EmitterViewerSPI::MPSRoundOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03248;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x6E756F722E73706DLL && *(_BYTE *)(AttrData + 8) == 100)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.round";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RoundOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFF4EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSampleGridDataGradientOpHandler *EmitterViewerSPI::MPSSampleGridDataGradientOpHandler::MPSSampleGridDataGradientOpHandler(EmitterViewerSPI::MPSSampleGridDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t Bias;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  unsigned int Layout;
  void *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumSPI *v36;
  unsigned int PaddingStyle;
  void *v38;
  MPSGraphViewerNodePropertyEnumCaseSPI *v39;
  MPSGraphViewerNodePropertyEnumCaseSPI *v40;
  MPSGraphViewerNodePropertyEnumSPI *v41;
  void *v42;
  MPSGraphViewerNodeSPI *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  uint64_t v48;
  void *v49;
  void *v50;
  _QWORD *AttrData;
  uint64_t v53;
  BOOL v54;
  BOOL v55;
  void *v57;
  void *v58;
  void *v59;
  mlir::Operation *v60;
  uint64_t v61[4];
  __int16 v62;
  uint64_t v63[4];
  __int16 v64;
  void *__dst[2];
  int64_t v66;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E049E8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v53 == 29)
    {
      v54 = *AttrData == 0x706D61732E73706DLL && AttrData[1] == 0x5F646972675F656CLL;
      v55 = v54 && AttrData[2] == 0x6172675F61746164;
      if (v55 && *(_QWORD *)((char *)AttrData + 21) == 0x746E656964617267)
      {
        v64 = 1283;
        v63[0] = (uint64_t)"classof on '";
        v63[2] = (uint64_t)"mps.sample_grid_data_gradient";
        v63[3] = 29;
        v61[0] = (uint64_t)"' failed due to the operation not being registered";
        v62 = 259;
        llvm::operator+(v63, v61, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_49:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SampleGridDataGradientOp,void>::id)
    goto LABEL_49;
  v60 = a3;
  v63[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v66 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v66) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v66 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v60);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v59, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v60);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("coordinates"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v59, "addObject:", v17);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v60);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("outputShape"), Bias);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v59, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v58, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v63[0]) = 0;
  LOBYTE(v63[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v60);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("normalize_coordinates"), 2147483656, &unk_1E0E9A750);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v63, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v61[0]) = 0;
  LOBYTE(v61[0]) = mlir::mps::CostVolumeOp::getNormalizeCoordinates((mlir::mps::CostVolumeOp *)&v60);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("relative_coordinates"), 2147483656, &unk_1E0E9A768);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v61, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }
  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v60);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("constant"), 0);
  objc_msgSend(v31, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("reflect"), 1);
  objc_msgSend(v31, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("symmetric"), 2);
  objc_msgSend(v31, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("clampToEdge"), 3);
  objc_msgSend(v31, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_mode"), CFSTR("MPSPaddingMode"), v31, Layout);
  if (v36)
    objc_msgSend(v25, "addObject:", v36);

  PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v60);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("nearest"), 0);
  objc_msgSend(v38, "addObject:", v39);

  v40 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("bilinear"), 1);
  objc_msgSend(v38, "addObject:", v40);

  v41 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("sampling_mode"), CFSTR("MPSSamplingMode"), v38, PaddingStyle);
  if (v41)
    objc_msgSend(v25, "addObject:", v41);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v59);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v58);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  v48 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v43, "initWithType:inputs:outputs:properties:regions:", v57, v44, v45, v46, v47);
  v49 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v48;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Gradient of sample_grid operation relative to the input data.");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v50);

  if (SHIBYTE(v66) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180EFFD9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;
  void *v29;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSampleGridOpHandler *EmitterViewerSPI::MPSSampleGridOpHandler::MPSSampleGridOpHandler(EmitterViewerSPI::MPSSampleGridOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  unint64_t Bias;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  MPSGraphViewerNodePropertyDataSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  unsigned int PaddingStyle;
  void *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumSPI *v38;
  unsigned int WeightsLayout;
  void *v40;
  MPSGraphViewerNodePropertyEnumCaseSPI *v41;
  MPSGraphViewerNodePropertyEnumCaseSPI *v42;
  MPSGraphViewerNodePropertyEnumSPI *v43;
  unsigned int Layout;
  void *v45;
  MPSGraphViewerNodePropertyEnumCaseSPI *v46;
  MPSGraphViewerNodePropertyEnumCaseSPI *v47;
  MPSGraphViewerNodePropertyEnumCaseSPI *v48;
  MPSGraphViewerNodePropertyEnumCaseSPI *v49;
  MPSGraphViewerNodePropertyEnumCaseSPI *v50;
  MPSGraphViewerNodePropertyEnumCaseSPI *v51;
  MPSGraphViewerNodePropertyEnumCaseSPI *v52;
  MPSGraphViewerNodePropertyEnumCaseSPI *v53;
  MPSGraphViewerNodePropertyEnumCaseSPI *v54;
  MPSGraphViewerNodePropertyEnumCaseSPI *v55;
  MPSGraphViewerNodePropertyEnumCaseSPI *v56;
  MPSGraphViewerNodePropertyEnumSPI *v57;
  void *v58;
  MPSGraphViewerNodeSPI *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  void *v65;
  void *v66;
  _QWORD *AttrData;
  uint64_t v69;
  void *v71;
  void *v72;
  void *v73;
  BOOL InferredResultTypes;
  mlir::Operation *v75;
  uint64_t v76[4];
  __int16 v77;
  uint64_t v78[4];
  __int16 v79;
  void *__dst[2];
  int64_t v81;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03CC8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v69 == 15 && *AttrData == 0x706D61732E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x646972675F656C70)
    {
      v79 = 1283;
      v78[0] = (uint64_t)"classof on '";
      v78[2] = (uint64_t)"mps.sample_grid";
      v78[3] = 15;
      v76[0] = (uint64_t)"' failed due to the operation not being registered";
      v77 = 259;
      llvm::operator+(v78, v76, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_47:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SampleGridOp,void>::id)
    goto LABEL_47;
  v75 = a3;
  v78[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v78);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v81 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v81) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v81 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v75);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v73, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v75);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("coordinates"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v73, "addObject:", v17);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v75);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("constant_values"), Bias);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  if (v19)
    objc_msgSend(v73, "addObject:", v19);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v72 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v75);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v72, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v78[0]) = 0;
  LOBYTE(v78[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v75);
  v26 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("normalize_coordinates"), 2147483656, &unk_1E0E9A780);
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v78, 1);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v26, "setValue:", v27);

    objc_msgSend(v25, "addObject:", v26);
  }
  LOBYTE(v76[0]) = 0;
  LOBYTE(v76[0]) = mlir::mps::GRUOp::getTraining((mlir::mps::GRUOp *)&v75);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("relative_coordinates"), 2147483656, &unk_1E0E9A798);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v76, 1);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v25, "addObject:", v28);
  }
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v75);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("align_corners"), 2147483656, &unk_1E0E9A7B0);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &InferredResultTypes, 1);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v25, "addObject:", v30);
  }
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v75);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("constant"), 0);
  objc_msgSend(v33, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("reflect"), 1);
  objc_msgSend(v33, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("symmetric"), 2);
  objc_msgSend(v33, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("clampToEdge"), 3);
  objc_msgSend(v33, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_mode"), CFSTR("MPSPaddingMode"), v33, PaddingStyle);
  if (v38)
    objc_msgSend(v25, "addObject:", v38);

  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v75);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("nearest"), 0);
  objc_msgSend(v40, "addObject:", v41);

  v42 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("bilinear"), 1);
  objc_msgSend(v40, "addObject:", v42);

  v43 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("sampling_mode"), CFSTR("MPSSamplingMode"), v40, WeightsLayout);
  if (v43)
    objc_msgSend(v25, "addObject:", v43);

  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v75);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCHW"), 0);
  objc_msgSend(v45, "addObject:", v46);

  v47 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NHWC"), 1);
  objc_msgSend(v45, "addObject:", v47);

  v48 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIHW"), 2);
  objc_msgSend(v45, "addObject:", v48);

  v49 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWIO"), 3);
  objc_msgSend(v45, "addObject:", v49);

  v50 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("CHW"), 4);
  objc_msgSend(v45, "addObject:", v50);

  v51 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HWC"), 5);
  objc_msgSend(v45, "addObject:", v51);

  v52 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("HW"), 6);
  objc_msgSend(v45, "addObject:", v52);

  v53 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NCDHW"), 7);
  objc_msgSend(v45, "addObject:", v53);

  v54 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("NDHWC"), 8);
  objc_msgSend(v45, "addObject:", v54);

  v55 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("OIDHW"), 9);
  objc_msgSend(v45, "addObject:", v55);

  v56 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("DHWIO"), 10);
  objc_msgSend(v45, "addObject:", v56);

  v57 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("layout"), CFSTR("MPSTensorDataLayout"), v45, Layout);
  if (v57)
    objc_msgSend(v25, "addObject:", v57);

  mlir::mps::SampleGridOp::getNearestRoundingMode((mlir::mps::SampleGridOp *)&v75);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v59 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v73);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v72);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v62 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v58);
  v63 = (void *)objc_claimAutoreleasedReturnValue();
  v64 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v59, "initWithType:inputs:outputs:properties:regions:", v71, v60, v61, v62, v63);
  v65 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v64;

  v66 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v66);

  if (SHIBYTE(v81) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F009CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;
  void *v31;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSScatterAlongAxisOpHandler *EmitterViewerSPI::MPSScatterAlongAxisOpHandler::MPSScatterAlongAxisOpHandler(EmitterViewerSPI::MPSScatterAlongAxisOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  unsigned int StorageType;
  void *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumSPI *v39;
  void *v40;
  MPSGraphViewerNodeSPI *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  _QWORD *AttrData;
  uint64_t v50;
  BOOL v51;
  void *v53;
  mlir::Operation *v54;
  const char *v55;
  __int16 v56;
  uint64_t v57[4];
  __int16 v58;
  void *__dst[2];
  int64_t v60;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E045B0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 22)
    {
      v51 = *AttrData == 0x746163732E73706DLL && AttrData[1] == 0x6E6F6C615F726574;
      if (v51 && *(_QWORD *)((char *)AttrData + 14) == 0x736978615F676E6FLL)
      {
        v58 = 1283;
        v57[0] = (uint64_t)"classof on '";
        v57[2] = (uint64_t)"mps.scatter_along_axis";
        v57[3] = 22;
        v55 = "' failed due to the operation not being registered";
        v56 = 259;
        llvm::operator+(v57, (uint64_t *)&v55, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id)
    goto LABEL_42;
  v54 = a3;
  v57[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v57);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v60 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v60) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v60 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("data"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("updates"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("indices"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v54);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v54);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("add"), 0);
  objc_msgSend(v31, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("subtract"), 1);
  objc_msgSend(v31, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("multiply"), 2);
  objc_msgSend(v31, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("divide"), 3);
  objc_msgSend(v31, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("min"), 4);
  objc_msgSend(v31, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("max"), 5);
  objc_msgSend(v31, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("set"), 6);
  objc_msgSend(v31, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("mode"), CFSTR("MPSScatterMode"), v31, StorageType);
  if (v39)
    objc_msgSend(v29, "addObject:", v39);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v40);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v41, "initWithType:inputs:outputs:properties:regions:", v53, v42, v43, v44, v45);
  v47 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v46;

  if (SHIBYTE(v60) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F01278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSScatterNDOpHandler *EmitterViewerSPI::MPSScatterNDOpHandler::MPSScatterNDOpHandler(EmitterViewerSPI::MPSScatterNDOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  MPSGraphViewerNodePropertyDataSPI *v28;
  void *v29;
  unsigned int Layout;
  void *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumSPI *v39;
  void *v40;
  MPSGraphViewerNodeSPI *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  _QWORD *AttrData;
  uint64_t v50;
  void *v52;
  mlir::Operation *v53;
  const char *v54;
  __int16 v55;
  uint64_t v56[4];
  __int16 v57;
  void *__dst[2];
  int64_t v59;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03A58;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 14 && *AttrData == 0x746163732E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x646E5F7265747461)
    {
      v57 = 1283;
      v56[0] = (uint64_t)"classof on '";
      v56[2] = (uint64_t)"mps.scatter_nd";
      v56[3] = 14;
      v54 = "' failed due to the operation not being registered";
      v55 = 259;
      llvm::operator+(v56, (uint64_t *)&v54, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id)
    goto LABEL_39;
  v53 = a3;
  v56[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v56);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v59 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v59) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v59 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("data"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("updates"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("indices"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v53);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v56[0]) = 0;
  LODWORD(v56[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v53);
  v28 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("batch_dims"), 32, &unk_1E0E9A7C8);
  if (v28)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v56, 4);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v28, "setValue:", v29);

    objc_msgSend(v27, "addObject:", v28);
  }
  Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v53);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("add"), 0);
  objc_msgSend(v31, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("subtract"), 1);
  objc_msgSend(v31, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("multiply"), 2);
  objc_msgSend(v31, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("divide"), 3);
  objc_msgSend(v31, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("min"), 4);
  objc_msgSend(v31, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("max"), 5);
  objc_msgSend(v31, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("set"), 6);
  objc_msgSend(v31, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("mode"), CFSTR("MPSScatterMode"), v31, Layout);
  if (v39)
    objc_msgSend(v27, "addObject:", v39);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v40);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v41, "initWithType:inputs:outputs:properties:regions:", v52, v42, v43, v44, v45);
  v47 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v46;

  if (SHIBYTE(v59) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F01AA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSScatterOpHandler *EmitterViewerSPI::MPSScatterOpHandler::MPSScatterOpHandler(EmitterViewerSPI::MPSScatterOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  unsigned int StorageType;
  void *v31;
  MPSGraphViewerNodePropertyEnumCaseSPI *v32;
  MPSGraphViewerNodePropertyEnumCaseSPI *v33;
  MPSGraphViewerNodePropertyEnumCaseSPI *v34;
  MPSGraphViewerNodePropertyEnumCaseSPI *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumSPI *v39;
  void *v40;
  MPSGraphViewerNodeSPI *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  _QWORD *AttrData;
  uint64_t v50;
  void *v52;
  mlir::Operation *v53;
  const char *v54;
  __int16 v55;
  uint64_t v56[4];
  __int16 v57;
  void *__dst[2];
  int64_t v59;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E036B0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 11 && *AttrData == 0x746163732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x726574746163732ELL)
    {
      v57 = 1283;
      v56[0] = (uint64_t)"classof on '";
      v56[2] = (uint64_t)"mps.scatter";
      v56[3] = 11;
      v54 = "' failed due to the operation not being registered";
      v55 = 259;
      llvm::operator+(v56, (uint64_t *)&v54, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id)
    goto LABEL_39;
  v53 = a3;
  v56[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v56);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v59 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v59) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v59 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("data"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("updates"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("indices"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v53);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v53);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("add"), 0);
  objc_msgSend(v31, "addObject:", v32);

  v33 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("subtract"), 1);
  objc_msgSend(v31, "addObject:", v33);

  v34 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("multiply"), 2);
  objc_msgSend(v31, "addObject:", v34);

  v35 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("divide"), 3);
  objc_msgSend(v31, "addObject:", v35);

  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("min"), 4);
  objc_msgSend(v31, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("max"), 5);
  objc_msgSend(v31, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("set"), 6);
  objc_msgSend(v31, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("mode"), CFSTR("MPSScatterMode"), v31, StorageType);
  if (v39)
    objc_msgSend(v29, "addObject:", v39);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v40);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v41, "initWithType:inputs:outputs:properties:regions:", v52, v42, v43, v44, v45);
  v47 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v46;

  if (SHIBYTE(v59) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F02290(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSelectOpHandler *EmitterViewerSPI::MPSSelectOpHandler::MPSSelectOpHandler(EmitterViewerSPI::MPSSelectOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E034A0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 10 && *(_QWORD *)AttrData == 0x656C65732E73706DLL && *(_WORD *)(AttrData + 8) == 29795)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.select";
      v45[3] = 10;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("condition"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("true_value"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("false_value"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F028CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSShapeOpHandler *EmitterViewerSPI::MPSShapeOpHandler::MPSShapeOpHandler(EmitterViewerSPI::MPSShapeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03260;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x706168732E73706DLL && *(_BYTE *)(AttrData + 8) == 101)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.shape";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ShapeOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "This op computes the shape if the input tensor and returns it as a 1-dimensional tensor.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F02E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSigmoidGradientOpHandler *EmitterViewerSPI::MPSSigmoidGradientOpHandler::MPSSigmoidGradientOpHandler(EmitterViewerSPI::MPSSigmoidGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E044D8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 20)
    {
      v38 = *(_QWORD *)AttrData == 0x6D6769732E73706DLL && *(_QWORD *)(AttrData + 8) == 0x646172675F64696FLL;
      if (v38 && *(_DWORD *)(AttrData + 16) == 1953391977)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"mps.sigmoid_gradient";
        v44[3] = 20;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientOp,void>::id)
    goto LABEL_36;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_gradient"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v40, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F033DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler *EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler::MPSSigmoidGradientWithSigmoidOpHandler(EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  BOOL v38;
  BOOL v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04AA8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 33)
    {
      v38 = *(_QWORD *)AttrData == 0x6D6769732E73706DLL && *(_QWORD *)(AttrData + 8) == 0x646172675F64696FLL;
      v39 = v38 && *(_QWORD *)(AttrData + 16) == 0x7469775F746E6569;
      v40 = v39 && *(_QWORD *)(AttrData + 24) == 0x696F6D6769735F68;
      if (v40 && *(_BYTE *)(AttrData + 32) == 100)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.sigmoid_gradient_with_sigmoid";
        v46[3] = 33;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientWithSigmoidOp,void>::id)
    goto LABEL_42;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("dy"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("y"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v42, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F039B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSigmoidHardOpHandler *EmitterViewerSPI::MPSSigmoidHardOpHandler::MPSSigmoidHardOpHandler(EmitterViewerSPI::MPSSigmoidHardOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03E00;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 16 && *AttrData == 0x6D6769732E73706DLL && AttrData[1] == 0x647261685F64696FLL)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.sigmoid_hard";
      v45[3] = 16;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidHardOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("primary"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("secondary"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("tertiary"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F03F8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSigmoidOpHandler *EmitterViewerSPI::MPSSigmoidOpHandler::MPSSigmoidOpHandler(EmitterViewerSPI::MPSSigmoidOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E036C8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 11 && *AttrData == 0x6D6769732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x64696F6D6769732ELL)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.sigmoid";
      v41[3] = 11;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F04510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSignOpHandler *EmitterViewerSPI::MPSSignOpHandler::MPSSignOpHandler(EmitterViewerSPI::MPSSignOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02F48;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6E6769732E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.sign";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SignOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F04A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSignbitOpHandler *EmitterViewerSPI::MPSSignbitOpHandler::MPSSignbitOpHandler(EmitterViewerSPI::MPSSignbitOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E036E0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 11 && *AttrData == 0x6E6769732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x7469626E6769732ELL)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.signbit";
      v41[3] = 11;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SignbitOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F04FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSinOpHandler *EmitterViewerSPI::MPSSinOpHandler::MPSSinOpHandler(EmitterViewerSPI::MPSSinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _DWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02C78;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1852404526)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.sin";
      v41[3] = 7;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SinOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F054E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler *EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler::MPSSingleGateRNNGradientOpHandler(EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t RecurrentWeight;
  void *v18;
  unint64_t TrainingState;
  void *v20;
  unint64_t InputState;
  void *v22;
  unint64_t Mask;
  void *v24;
  uint64_t v25;
  __CFString *v26;
  uint64_t MPSDataType;
  void *v28;
  MPSGraphViewerNodePortSPI *v29;
  uint64_t Element;
  __CFString *v31;
  uint64_t v32;
  void *v33;
  MPSGraphViewerNodePortSPI *v34;
  uint64_t v35;
  __CFString *v36;
  uint64_t v37;
  void *v38;
  MPSGraphViewerNodePortSPI *v39;
  void *v40;
  unsigned int StorageType;
  void *v42;
  MPSGraphViewerNodePropertyEnumCaseSPI *v43;
  MPSGraphViewerNodePropertyEnumCaseSPI *v44;
  MPSGraphViewerNodePropertyEnumCaseSPI *v45;
  MPSGraphViewerNodePropertyEnumCaseSPI *v46;
  MPSGraphViewerNodePropertyEnumCaseSPI *v47;
  MPSGraphViewerNodePropertyEnumCaseSPI *v48;
  MPSGraphViewerNodePropertyEnumSPI *v49;
  MPSGraphViewerNodePropertyDataSPI *v50;
  void *v51;
  void *v52;
  MPSGraphViewerNodeSPI *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  uint64_t v58;
  void *v59;
  void *v60;
  _QWORD *AttrData;
  uint64_t v63;
  BOOL v64;
  BOOL v65;
  void *v67;
  void *v68;
  mlir::Operation *v69;
  const char *v70;
  __int16 v71;
  uint64_t v72[4];
  __int16 v73;
  void *__dst[2];
  int64_t v75;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E049D0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v63 == 27)
    {
      v64 = *AttrData == 0x676E69732E73706DLL && AttrData[1] == 0x725F65746167656CLL;
      v65 = v64 && AttrData[2] == 0x69646172675F6E6ELL;
      if (v65 && *(_QWORD *)((char *)AttrData + 19) == 0x746E656964617267)
      {
        v73 = 1283;
        v72[0] = (uint64_t)"classof on '";
        v72[2] = (uint64_t)"mps.singlegate_rnn_gradient";
        v72[3] = 27;
        v70 = "' failed due to the operation not being registered";
        v71 = 259;
        llvm::operator+(v72, (uint64_t *)&v70, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_57:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SingleGateRNNGradientOp,void>::id)
    goto LABEL_57;
  v69 = a3;
  v72[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v72);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v75 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v75) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v75 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v69);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient_input_sequence"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  RecurrentWeight = mlir::mps::SingleGateRNNGradientOp::getRecurrentWeight((mlir::mps::SingleGateRNNGradientOp *)&v69);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("recurrent_weight"), RecurrentWeight);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  TrainingState = mlir::mps::SingleGateRNNGradientOp::getTrainingState((mlir::mps::SingleGateRNNGradientOp *)&v69);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("training_state"), TrainingState);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  InputState = mlir::mps::SingleGateRNNGradientOp::getInputState((mlir::mps::SingleGateRNNGradientOp *)&v69);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_state"), InputState);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  Mask = mlir::mps::SingleGateRNNGradientOp::getMask((mlir::mps::SingleGateRNNGradientOp *)&v69);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("mask"), Mask);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v24)
    objc_msgSend(v14, "addObject:", v24);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v68 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v69);
  v26 = CFSTR("gradient_output_sequence");
  if (v25)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v25 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v25 + 8) & 0xFFFFFFFFFFFFFFF8));
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v29 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_output_sequence"), MPSDataType, v28, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v25));

    if (v29)
      objc_msgSend(v68, "addObject:", v29);
  }
  else
  {

    v29 = 0;
  }
  Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v69);
  v31 = CFSTR("gradient_recurrent_weight");
  if (Element)
  {
    v32 = getMPSDataType((_QWORD *)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    v34 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_recurrent_weight"), v32, v33, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Element));

    if (v34)
      objc_msgSend(v68, "addObject:", v34);
  }
  else
  {

    v34 = 0;
  }
  v35 = mlir::mps::LSTMOp::getTrainingState((mlir::mps::LSTMOp *)&v69);
  v36 = CFSTR("gradient_input_state");
  if (v35)
  {
    v37 = getMPSDataType((_QWORD *)(*(_QWORD *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8));
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    v39 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("gradient_input_state"), v37, v38, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v35));

    if (v39)
      objc_msgSend(v68, "addObject:", v39);
  }
  else
  {

    v39 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v69);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v42, "addObject:", v43);

  v44 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v42, "addObject:", v44);

  v45 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v42, "addObject:", v45);

  v46 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v42, "addObject:", v46);

  v47 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v42, "addObject:", v47);

  v48 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v42, "addObject:", v48);

  v49 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("activation"), CFSTR("MPSRNNActivation"), v42, StorageType);
  if (v49)
    objc_msgSend(v40, "addObject:", v49);

  LOBYTE(v72[0]) = 0;
  LOBYTE(v72[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v69);
  v50 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("gradient_for_input_state"), 2147483656, &unk_1E0E9A7E0);
  if (v50)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v72, 1);
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v50, "setValue:", v51);

    objc_msgSend(v40, "addObject:", v50);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  v53 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v68);
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v40);
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v52);
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  v58 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v53, "initWithType:inputs:outputs:properties:regions:", v67, v54, v55, v56, v57);
  v59 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v58;

  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v60);

  if (SHIBYTE(v75) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F05EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSingleGateRNNOpHandler *EmitterViewerSPI::MPSSingleGateRNNOpHandler::MPSSingleGateRNNOpHandler(EmitterViewerSPI::MPSSingleGateRNNOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t RecurrentWeight;
  void *v18;
  unint64_t InputState;
  void *v20;
  unint64_t v21;
  void *v22;
  uint64_t v23;
  __CFString *v24;
  uint64_t MPSDataType;
  void *v26;
  MPSGraphViewerNodePortSPI *v27;
  uint64_t TrainingState;
  __CFString *v29;
  uint64_t v30;
  void *v31;
  MPSGraphViewerNodePortSPI *v32;
  void *v33;
  unsigned int StorageType;
  void *v35;
  MPSGraphViewerNodePropertyEnumCaseSPI *v36;
  MPSGraphViewerNodePropertyEnumCaseSPI *v37;
  MPSGraphViewerNodePropertyEnumCaseSPI *v38;
  MPSGraphViewerNodePropertyEnumCaseSPI *v39;
  MPSGraphViewerNodePropertyEnumCaseSPI *v40;
  MPSGraphViewerNodePropertyEnumCaseSPI *v41;
  MPSGraphViewerNodePropertyEnumSPI *v42;
  MPSGraphViewerNodePropertyDataSPI *v43;
  void *v44;
  void *v45;
  MPSGraphViewerNodeSPI *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  uint64_t v51;
  void *v52;
  void *v53;
  uint64_t AttrData;
  uint64_t v56;
  BOOL v57;
  void *v59;
  void *v60;
  mlir::Operation *v61;
  const char *v62;
  __int16 v63;
  uint64_t v64[4];
  __int16 v65;
  void *__dst[2];
  int64_t v67;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04178;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v56 == 18)
    {
      v57 = *(_QWORD *)AttrData == 0x676E69732E73706DLL && *(_QWORD *)(AttrData + 8) == 0x725F65746167656CLL;
      if (v57 && *(_WORD *)(AttrData + 16) == 28270)
      {
        v65 = 1283;
        v64[0] = (uint64_t)"classof on '";
        v64[2] = (uint64_t)"mps.singlegate_rnn";
        v64[3] = 18;
        v62 = "' failed due to the operation not being registered";
        v63 = 259;
        llvm::operator+(v64, (uint64_t *)&v62, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_48:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SingleGateRNNOp,void>::id)
    goto LABEL_48;
  v61 = a3;
  v64[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v64);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v67 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v67) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v67 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v61);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_sequence"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  RecurrentWeight = mlir::mps::SingleGateRNNGradientOp::getRecurrentWeight((mlir::mps::SingleGateRNNGradientOp *)&v61);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("recurrent_weight"), RecurrentWeight);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  InputState = mlir::mps::SingleGateRNNOp::getInputState((mlir::mps::SingleGateRNNOp *)&v61);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_state"), InputState);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  v21 = mlir::mps::SingleGateRNNGradientOp::getInputState((mlir::mps::SingleGateRNNGradientOp *)&v61);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("mask"), v21);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  v23 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v61);
  v24 = CFSTR("result");
  if (v23)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8));
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    v27 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v26, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v23));

    if (v27)
      objc_msgSend(v60, "addObject:", v27);
  }
  else
  {

    v27 = 0;
  }
  TrainingState = mlir::mps::GRUOp::getTrainingState((mlir::mps::GRUOp *)&v61);
  v29 = CFSTR("training_state");
  if (TrainingState)
  {
    v30 = getMPSDataType((_QWORD *)(*(_QWORD *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    v32 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("training_state"), v30, v31, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, TrainingState));

    if (v32)
      objc_msgSend(v60, "addObject:", v32);
  }
  else
  {

    v32 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v61);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("none"), 0);
  objc_msgSend(v35, "addObject:", v36);

  v37 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("relu"), 1);
  objc_msgSend(v35, "addObject:", v37);

  v38 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("tanh"), 2);
  objc_msgSend(v35, "addObject:", v38);

  v39 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sigmoid"), 3);
  objc_msgSend(v35, "addObject:", v39);

  v40 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("hard_sigmoid"), 4);
  objc_msgSend(v35, "addObject:", v40);

  v41 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("scaled_tanh"), 5);
  objc_msgSend(v35, "addObject:", v41);

  v42 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("activation"), CFSTR("MPSRNNActivation"), v35, StorageType);
  if (v42)
    objc_msgSend(v33, "addObject:", v42);

  LOBYTE(v64[0]) = 0;
  LOBYTE(v64[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v61);
  v43 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("training"), 2147483656, &unk_1E0E9A7F8);
  if (v43)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v64, 1);
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v43, "setValue:", v44);

    objc_msgSend(v33, "addObject:", v43);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v60);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v33);
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v45);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v51 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v46, "initWithType:inputs:outputs:properties:regions:", v59, v47, v48, v49, v50);
  v52 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v51;

  v53 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v53);

  if (SHIBYTE(v67) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F06890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSinhOpHandler *EmitterViewerSPI::MPSSinhOpHandler::MPSSinhOpHandler(EmitterViewerSPI::MPSSinhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02F60;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x686E69732E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.sinh";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SinhOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F06EA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSizeOpHandler *EmitterViewerSPI::MPSSizeOpHandler::MPSSizeOpHandler(EmitterViewerSPI::MPSSizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  _QWORD *AttrData;
  uint64_t v34;
  void *v35;
  mlir::Operation *v36;
  const char *v37;
  __int16 v38;
  uint64_t v39[4];
  __int16 v40;
  void *__dst[2];
  int64_t v42;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02F78;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x657A69732E73706DLL)
    {
      v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"mps.size";
      v39[3] = 8;
      v37 = "' failed due to the operation not being registered";
      v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SizeOp,void>::id)
    goto LABEL_27;
  v36 = a3;
  v39[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v42 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v35, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  if (SHIBYTE(v42) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F073B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSliceOpHandler *EmitterViewerSPI::MPSSliceOpHandler::MPSSliceOpHandler(EmitterViewerSPI::MPSSliceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  void *v28;
  void *v29;
  MPSGraphViewerNodeSPI *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  uint64_t v35;
  void *v36;
  void *v37;
  uint64_t AttrData;
  uint64_t v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03278;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 9 && *(_QWORD *)AttrData == 0x63696C732E73706DLL && *(_BYTE *)(AttrData + 8) == 101)
    {
      v47 = 1283;
      v46[0] = (uint64_t)"classof on '";
      v46[2] = (uint64_t)"mps.slice";
      v46[3] = 9;
      v44 = "' failed due to the operation not being registered";
      v45 = 259;
      llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SliceOp,void>::id)
    goto LABEL_37;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("start"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("length"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v24)
      objc_msgSend(v23, "addObject:", v24);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v30, "initWithType:inputs:outputs:properties:regions:", v42, v31, v32, v33, v34);
  v36 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v35;

  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v37);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F07994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSoftmaxOpHandler *EmitterViewerSPI::MPSSoftmaxOpHandler::MPSSoftmaxOpHandler(EmitterViewerSPI::MPSSoftmaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E036F8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x74666F732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x78616D74666F732ELL)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.softmax";
      v43[3] = 11;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F07F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSoftplusOpHandler *EmitterViewerSPI::MPSSoftplusOpHandler::MPSSoftplusOpHandler(EmitterViewerSPI::MPSSoftplusOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03950;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(_QWORD *)AttrData == 0x74666F732E73706DLL && *(_DWORD *)(AttrData + 8) == 1937075312)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.softplus";
      v41[3] = 12;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SoftplusOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F084BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSoftplusParametricOpHandler *EmitterViewerSPI::MPSSoftplusParametricOpHandler::MPSSoftplusParametricOpHandler(EmitterViewerSPI::MPSSoftplusParametricOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E047A8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 23)
    {
      v40 = *AttrData == 0x74666F732E73706DLL && AttrData[1] == 0x7261705F73756C70;
      if (v40 && *(_QWORD *)((char *)AttrData + 15) == 0x63697274656D6172)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.softplus_parametric";
        v46[3] = 23;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SoftplusParametricOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("primary"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("secondary"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("tertiary"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Return alpha_i * log( 1 + e^( beta_i * x_i)), where i = 1 ... C.");
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F08A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSoftsignOpHandler *EmitterViewerSPI::MPSSoftsignOpHandler::MPSSoftsignOpHandler(EmitterViewerSPI::MPSSoftsignOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03968;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(_QWORD *)AttrData == 0x74666F732E73706DLL && *(_DWORD *)(AttrData + 8) == 1852270963)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.softsign";
      v41[3] = 12;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SoftsignOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F09010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSortOpHandler *EmitterViewerSPI::MPSSortOpHandler::MPSSortOpHandler(EmitterViewerSPI::MPSSortOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  void *v18;
  uint64_t v19;
  __CFString *v20;
  uint64_t MPSDataType;
  void *v22;
  MPSGraphViewerNodePortSPI *v23;
  uint64_t Element;
  __CFString *v25;
  uint64_t v26;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  _QWORD *AttrData;
  uint64_t v43;
  void *v44;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02F90;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 8 && *AttrData == 0x74726F732E73706DLL)
    {
      v50 = 1283;
      v49[0] = (uint64_t)"classof on '";
      v49[2] = (uint64_t)"mps.sort";
      v49[3] = 8;
      v47 = "' failed due to the operation not being registered";
      v48 = 259;
      llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SortOp,void>::id)
    goto LABEL_35;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v45, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v45, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v19 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v20 = CFSTR("result");
  if (v19)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v22, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v19));

    if (v23)
      objc_msgSend(v18, "addObject:", v23);
  }
  else
  {

    v23 = 0;
  }
  Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v46);
  v25 = CFSTR("indices");
  if (Element)
  {
    v26 = getMPSDataType((_QWORD *)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("indices"), v26, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Element));

    if (v28)
      objc_msgSend(v18, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v49[0]) = 0;
  LOBYTE(v49[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v46);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("descending"), 2147483656, &unk_1E0E9A810);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v49, 1);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v29, "addObject:", v30);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v45);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v18);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v44, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v40);

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F096BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSpaceToBatchOpHandler *EmitterViewerSPI::MPSSpaceToBatchOpHandler::MPSSpaceToBatchOpHandler(EmitterViewerSPI::MPSSpaceToBatchOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  uint64_t AttrData;
  uint64_t v43;
  BOOL v44;
  void *v46;
  mlir::Operation *v47;
  const char *v48;
  __int16 v49;
  uint64_t v50[4];
  __int16 v51;
  void *__dst[2];
  int64_t v53;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03F68;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 18)
    {
      v44 = *(_QWORD *)AttrData == 0x636170732E73706DLL && *(_QWORD *)(AttrData + 8) == 0x7461625F6F745F65;
      if (v44 && *(_WORD *)(AttrData + 16) == 26723)
      {
        v51 = 1283;
        v50[0] = (uint64_t)"classof on '";
        v50[2] = (uint64_t)"mps.space_to_batch";
        v50[3] = 18;
        v48 = "' failed due to the operation not being registered";
        v49 = 259;
        llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SpaceToBatchOp,void>::id)
    goto LABEL_42;
  v47 = a3;
  v50[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v53 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("spatial_axes"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("batch_axis"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v47);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("block_dimensions"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v47);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("pixel_shuffle"), 2147483656, &unk_1E0E9A828);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v50, 1);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v29, "addObject:", v30);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v46, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v40);

  if (SHIBYTE(v53) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F09DB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSpaceToDepth2DOpHandler *EmitterViewerSPI::MPSSpaceToDepth2DOpHandler::MPSSpaceToDepth2DOpHandler(EmitterViewerSPI::MPSSpaceToDepth2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  _QWORD *AttrData;
  uint64_t v45;
  BOOL v46;
  void *v48;
  mlir::Operation *v49;
  uint64_t v50[4];
  __int16 v51;
  uint64_t v52[4];
  __int16 v53;
  void *__dst[2];
  int64_t v55;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E04298;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 21)
    {
      v46 = *AttrData == 0x636170732E73706DLL && AttrData[1] == 0x7065645F6F745F65;
      if (v46 && *(_QWORD *)((char *)AttrData + 13) == 0x64325F6874706564)
      {
        v53 = 1283;
        v52[0] = (uint64_t)"classof on '";
        v52[2] = (uint64_t)"mps.space_to_depth_2d";
        v52[3] = 21;
        v50[0] = (uint64_t)"' failed due to the operation not being registered";
        v51 = 259;
        llvm::operator+(v52, v50, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SpaceToDepth2DOp,void>::id)
    goto LABEL_44;
  v49 = a3;
  v52[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v55 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("width_axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("height_axis"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("depth_axis"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v52[0]) = 0;
  LODWORD(v52[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v49);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("block_size"), 32, &unk_1E0E9A840);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v52, 4);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v29, "addObject:", v30);
  }
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v49);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("pixel_shuffle"), 2147483656, &unk_1E0E9A858);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v50, 1);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v29, "addObject:", v32);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v48, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v42);

  if (SHIBYTE(v55) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0A51C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSplitOpHandler *EmitterViewerSPI::MPSSplitOpHandler::MPSSplitOpHandler(EmitterViewerSPI::MPSSplitOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  unint64_t Input;
  void *v14;
  unint64_t Filter;
  void *v16;
  unint64_t SplitSizes;
  void *v18;
  uint64_t Results;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unsigned int v24;
  MPSGraphViewerNodePortSPI *v25;
  uint64_t NextResultAtOffset;
  id v27;
  void *v28;
  uint64_t MPSDataType;
  void *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  void *v34;
  MPSGraphViewerNodeSPI *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  void *v41;
  void *v42;
  uint64_t AttrData;
  uint64_t v45;
  void *v47;
  void *v49;
  void *v50;
  mlir::Operation *v51;
  const char *v52;
  __int16 v53;
  uint64_t v54[4];
  __int16 v55;
  void *__dst[2];
  int64_t v57;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03290;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 9 && *(_QWORD *)AttrData == 0x696C70732E73706DLL && *(_BYTE *)(AttrData + 8) == 116)
    {
      v55 = 1283;
      v54[0] = (uint64_t)"classof on '";
      v54[2] = (uint64_t)"mps.split";
      v54[3] = 9;
      v52 = "' failed due to the operation not being registered";
      v53 = 259;
      llvm::operator+(v54, (uint64_t *)&v52, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::SplitOp,void>::id)
    goto LABEL_45;
  v51 = a3;
  v54[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v54);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v57 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v57) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v57 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("x"), Input);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  if (v14)
    objc_msgSend(v49, "addObject:", v14);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v49, "addObject:", v16);
  SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v51);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("split_sizes"), SplitSizes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v49, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  Results = mlir::pdl::ApplyNativeRewriteOp::getResults((mlir::pdl::ApplyNativeRewriteOp *)&v51);
  v21 = v20;
  if (v20)
  {
    v22 = Results;
    v23 = 0;
    v24 = 1;
    do
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v22, v23);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("results%d"), v24 - 1);
      v27 = (id)objc_claimAutoreleasedReturnValue();
      v28 = v27;
      if (NextResultAtOffset)
      {
        MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        v30 = (void *)objc_claimAutoreleasedReturnValue();
        v25 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", v28, MPSDataType, v30, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, NextResultAtOffset));

        if (v25)
          objc_msgSend(v50, "addObject:", v25);
      }
      else
      {
        v25 = 0;

      }
      v23 = v24++;
    }
    while (v21 > v23);
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v54[0] = mlir::pdl::ResultsOp::getIndex((mlir::pdl::ResultsOp *)&v51);
  if ((v54[0] & 0xFF00000000) != 0)
  {
    v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("num_splits"), 32, &unk_1E0E9A870);
    if (v32)
    {
      if (!BYTE4(v54[0]))
        std::__throw_bad_optional_access[abi:ne180100]();
      objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v54, 8);
      v33 = (void *)objc_claimAutoreleasedReturnValue();
      -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

      objc_msgSend(v31, "addObject:", v32);
    }

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v49);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v50);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v34);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  v40 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v35, "initWithType:inputs:outputs:properties:regions:", v47, v36, v37, v38, v39);
  v41 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v40;

  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v42);

  if (SHIBYTE(v57) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0AC54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  void *v30;
  void *v31;
  void *v32;

  if (a30 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSquareOpHandler *EmitterViewerSPI::MPSSquareOpHandler::MPSSquareOpHandler(EmitterViewerSPI::MPSSquareOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E034B8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 10 && *(_QWORD *)AttrData == 0x617571732E73706DLL && *(_WORD *)(AttrData + 8) == 25970)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.square";
      v41[3] = 10;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0B218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSquareRootOpHandler *EmitterViewerSPI::MPSSquareRootOpHandler::MPSSquareRootOpHandler(EmitterViewerSPI::MPSSquareRootOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03CE0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 15 && *AttrData == 0x617571732E73706DLL && *(_QWORD *)((char *)AttrData + 7) == 0x746F6F725F657261)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.square_root";
      v41[3] = 15;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0B76C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSqueezeOpHandler *EmitterViewerSPI::MPSSqueezeOpHandler::MPSSqueezeOpHandler(EmitterViewerSPI::MPSSqueezeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Axes;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03710;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x657571732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x657A65657571732ELL)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.squeeze";
      v43[3] = 11;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axes"), Axes);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0BCF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSStencilOpHandler *EmitterViewerSPI::MPSStencilOpHandler::MPSStencilOpHandler(EmitterViewerSPI::MPSStencilOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  unint64_t Input;
  void *v15;
  unint64_t Filter;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  uint64_t **Offsets;
  char v25;
  uint64_t **v26;
  uint64_t InterfaceFor;
  const char *v28;
  int v29;
  const char *v30;
  const char *v31;
  void *v32;
  uint64_t **Strides;
  uint64_t **v34;
  uint64_t v35;
  const char *v36;
  int v37;
  const char *v38;
  const char *v39;
  uint64_t **FastmathAttr;
  uint64_t **v41;
  uint64_t v42;
  const char *v43;
  int v44;
  const char *v45;
  const char *v46;
  void *v47;
  uint64_t **ExplicitPadding;
  char v49;
  uint64_t **v50;
  uint64_t v51;
  const char *v52;
  int v53;
  const char *v54;
  const char *v55;
  void *v56;
  MPSGraphViewerNodePropertyDataSPI *v57;
  void *v58;
  unsigned int WeightsLayout;
  void *v60;
  MPSGraphViewerNodePropertyEnumCaseSPI *v61;
  MPSGraphViewerNodePropertyEnumCaseSPI *v62;
  MPSGraphViewerNodePropertyEnumCaseSPI *v63;
  MPSGraphViewerNodePropertyEnumCaseSPI *v64;
  MPSGraphViewerNodePropertyEnumCaseSPI *v65;
  MPSGraphViewerNodePropertyEnumCaseSPI *v66;
  MPSGraphViewerNodePropertyEnumSPI *v67;
  unsigned int PaddingStyle;
  void *v69;
  MPSGraphViewerNodePropertyEnumCaseSPI *v70;
  MPSGraphViewerNodePropertyEnumCaseSPI *v71;
  MPSGraphViewerNodePropertyEnumCaseSPI *v72;
  MPSGraphViewerNodePropertyEnumCaseSPI *v73;
  MPSGraphViewerNodePropertyEnumCaseSPI *v74;
  MPSGraphViewerNodePropertyEnumCaseSPI *v75;
  MPSGraphViewerNodePropertyEnumCaseSPI *v76;
  MPSGraphViewerNodePropertyEnumSPI *v77;
  unsigned int v78;
  void *v79;
  MPSGraphViewerNodePropertyEnumCaseSPI *v80;
  MPSGraphViewerNodePropertyEnumCaseSPI *v81;
  MPSGraphViewerNodePropertyEnumCaseSPI *v82;
  MPSGraphViewerNodePropertyEnumCaseSPI *v83;
  MPSGraphViewerNodePropertyEnumCaseSPI *v84;
  MPSGraphViewerNodePropertyEnumSPI *v85;
  void *v86;
  llvm::APFloatBase *v87;
  void *v88;
  MPSGraphViewerNodeSPI *v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  uint64_t v94;
  void *v95;
  void *v96;
  _QWORD *AttrData;
  uint64_t v99;
  void *v101;
  void *v102;
  void *v103;
  void *v104;
  mlir::Operation *v105;
  const char *v106;
  __int16 v107;
  void *__dst[2];
  const char *v109;
  uint64_t v110;
  __int16 v111;
  uint64_t v112;
  void *v113;
  _QWORD v114[5];

  v114[3] = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03728;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v112 = *(_QWORD *)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v112);
    if (v99 == 11 && *AttrData == 0x6E6574732E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      v111 = 1283;
      __dst[0] = "classof on '";
      v109 = "mps.stencil";
      v110 = 11;
      v106 = "' failed due to the operation not being registered";
      v107 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v106, (uint64_t)&v112);
      llvm::report_fatal_error((llvm::Twine *)&v112, 1);
    }
LABEL_92:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id)
    goto LABEL_92;
  v105 = a3;
  v112 = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v112);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v109 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v109) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (SHIBYTE(v109) >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v102 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v104 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v104, "addObject:", v15);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("weights"), Filter);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  if (v17)
    objc_msgSend(v104, "addObject:", v17);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v103 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v103, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v105);
  if (v25)
  {
    v26 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26))
        {
          InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26);
          if (!InterfaceFor)
          {
            v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v29 = 98;
            v30 = "InterfaceSupport.h";
            v31 = "Interface";
            goto LABEL_80;
          }
          goto LABEL_29;
        }
        v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v29 = 566;
        v30 = "Casting.h";
        v31 = "cast";
      }
      else
      {
        v28 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v29 = 692;
        v30 = "Casting.h";
        v31 = "cast_if_present";
      }
LABEL_80:
      __assert_rtn(v31, v30, v29, v28);
    }
    InterfaceFor = 0;
LABEL_29:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("offsets"), (uint64_t)v26, InterfaceFor);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    if (v32)
      objc_msgSend(v23, "addObject:", v32);

  }
  Strides = (uint64_t **)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v105);
  v34 = Strides;
  if (!Strides)
  {
    v35 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v37 = 692;
    v38 = "Casting.h";
    v39 = "cast_if_present";
    goto LABEL_74;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v37 = 566;
    v38 = "Casting.h";
    v39 = "cast";
LABEL_74:
    __assert_rtn(v39, v38, v37, v36);
  }
  v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v37 = 98;
    v38 = "InterfaceSupport.h";
    v39 = "Interface";
    goto LABEL_74;
  }
LABEL_38:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("strides"), (uint64_t)v34, v35);
  v101 = (void *)objc_claimAutoreleasedReturnValue();
  if (v101)
    objc_msgSend(v23, "addObject:", v101);
  FastmathAttr = (uint64_t **)mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v105);
  v41 = FastmathAttr;
  if (!FastmathAttr)
  {
    v42 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(FastmathAttr))
  {
    v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    v44 = 692;
    v45 = "Casting.h";
    v46 = "cast_if_present";
    goto LABEL_77;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    v44 = 566;
    v45 = "Casting.h";
    v46 = "cast";
LABEL_77:
    __assert_rtn(v46, v45, v44, v43);
  }
  v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    v44 = 98;
    v45 = "InterfaceSupport.h";
    v46 = "Interface";
    goto LABEL_77;
  }
LABEL_46:
  EmitViewerSPI::emitElementsAttrProperty(CFSTR("dilation_rates"), (uint64_t)v41, v42);
  v47 = (void *)objc_claimAutoreleasedReturnValue();
  if (v47)
    objc_msgSend(v23, "addObject:", v47);
  ExplicitPadding = (uint64_t **)mlir::mps::StencilOp::getExplicitPadding((mlir::mps::StencilOp *)&v105);
  if (v49)
  {
    v50 = ExplicitPadding;
    if (ExplicitPadding)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(ExplicitPadding))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v50))
        {
          v51 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v50);
          if (!v51)
          {
            v52 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            v53 = 98;
            v54 = "InterfaceSupport.h";
            v55 = "Interface";
            goto LABEL_83;
          }
          goto LABEL_55;
        }
        v52 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        v53 = 566;
        v54 = "Casting.h";
        v55 = "cast";
      }
      else
      {
        v52 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        v53 = 692;
        v54 = "Casting.h";
        v55 = "cast_if_present";
      }
LABEL_83:
      __assert_rtn(v55, v54, v53, v52);
    }
    v51 = 0;
LABEL_55:
    EmitViewerSPI::emitElementsAttrProperty(CFSTR("explicit_padding"), (uint64_t)v50, v51);
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    if (v56)
      objc_msgSend(v23, "addObject:", v56);

  }
  mlir::mps::RandomNormalOp::getStdDev((mlir::mps::RandomNormalOp *)&v105, (uint64_t)&v112);
  v57 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("paddingConstant"), 268435488, &unk_1E0E9A888);
  if (v57)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v112, 32);
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v57, "setValue:", v58);

    objc_msgSend(v23, "addObject:", v57);
  }
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  v61 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("min"), 0);
  objc_msgSend(v60, "addObject:", v61);

  v62 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("max"), 1);
  objc_msgSend(v60, "addObject:", v62);

  v63 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("sum"), 2);
  objc_msgSend(v60, "addObject:", v63);

  v64 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("product"), 3);
  objc_msgSend(v60, "addObject:", v64);

  v65 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("argMin "), 4);
  objc_msgSend(v60, "addObject:", v65);

  v66 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("argMax"), 5);
  objc_msgSend(v60, "addObject:", v66);

  v67 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("reductionMode"), CFSTR("MPSReductionMode"), v60, WeightsLayout);
  if (v67)
    objc_msgSend(v23, "addObject:", v67);

  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  v70 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("zero"), 4);
  objc_msgSend(v69, "addObject:", v70);

  v71 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("constant"), 0);
  objc_msgSend(v69, "addObject:", v71);

  v72 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("clampToEdge"), 3);
  objc_msgSend(v69, "addObject:", v72);

  v73 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("mirror"), 1);
  objc_msgSend(v69, "addObject:", v73);

  v74 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("mirrorWithEdge"), 2);
  objc_msgSend(v69, "addObject:", v74);

  v75 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("periodic"), 5);
  objc_msgSend(v69, "addObject:", v75);

  v76 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("antiPeriodic"), 6);
  objc_msgSend(v69, "addObject:", v76);

  v77 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("paddingMode"), CFSTR("MPSStencilPaddingMode"), v69, PaddingStyle);
  if (v77)
    objc_msgSend(v23, "addObject:", v77);

  v78 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v105);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v79 = (void *)objc_claimAutoreleasedReturnValue();
  v80 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT"), 0);
  objc_msgSend(v79, "addObject:", v80);

  v81 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_VALID"), 1);
  objc_msgSend(v79, "addObject:", v81);

  v82 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("TF_SAME"), 2);
  objc_msgSend(v79, "addObject:", v82);

  v83 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("EXPLICIT_OFFSET"), 3);
  objc_msgSend(v79, "addObject:", v83);

  v84 = -[MPSGraphViewerNodePropertyEnumCaseSPI initWithName:value:]([MPSGraphViewerNodePropertyEnumCaseSPI alloc], "initWithName:value:", CFSTR("ONNX_SAME_LOWER"), 4);
  objc_msgSend(v79, "addObject:", v84);

  v85 = -[MPSGraphViewerNodePropertyEnumSPI initWithName:type:cases:value:]([MPSGraphViewerNodePropertyEnumSPI alloc], "initWithName:type:cases:value:", CFSTR("padding_style"), CFSTR("MPSPaddingStyle"), v79, v78);
  if (v85)
    objc_msgSend(v23, "addObject:", v85);

  v86 = v113;
  if (llvm::APFloatBase::PPCDoubleDouble(v87) == v86)
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v114);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v113);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v88 = (void *)objc_claimAutoreleasedReturnValue();
  v89 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v104);
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v103);
  v91 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v92 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v88);
  v93 = (void *)objc_claimAutoreleasedReturnValue();
  v94 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v89, "initWithType:inputs:outputs:properties:regions:", v102, v90, v91, v92, v93);
  v95 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v94;

  v96 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v96);

  if (SHIBYTE(v109) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0CAEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a24 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSStridedSliceGradientOpHandler *EmitterViewerSPI::MPSStridedSliceGradientOpHandler::MPSStridedSliceGradientOpHandler(EmitterViewerSPI::MPSStridedSliceGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  unint64_t Dense;
  void *v24;
  void *v25;
  uint64_t v26;
  __CFString *v27;
  uint64_t MPSDataType;
  void *v29;
  MPSGraphViewerNodePortSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  MPSGraphViewerNodePropertyDataSPI *v34;
  void *v35;
  MPSGraphViewerNodePropertyDataSPI *v36;
  void *v37;
  MPSGraphViewerNodePropertyDataSPI *v38;
  void *v39;
  void *v40;
  MPSGraphViewerNodeSPI *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  void *v48;
  uint64_t AttrData;
  uint64_t v51;
  BOOL v52;
  BOOL v53;
  void *v55;
  BOOL IsSize;
  unsigned int Groups;
  mlir::Operation *v58;
  uint64_t v59[4];
  __int16 v60;
  uint64_t v61[4];
  __int16 v62;
  void *__dst[2];
  int64_t v64;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E048B0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v51 == 26)
    {
      v52 = *(_QWORD *)AttrData == 0x697274732E73706DLL && *(_QWORD *)(AttrData + 8) == 0x63696C735F646564;
      v53 = v52 && *(_QWORD *)(AttrData + 16) == 0x6569646172675F65;
      if (v53 && *(_WORD *)(AttrData + 24) == 29806)
      {
        v62 = 1283;
        v61[0] = (uint64_t)"classof on '";
        v61[2] = (uint64_t)"mps.strided_slice_gradient";
        v61[3] = 26;
        v59[0] = (uint64_t)"' failed due to the operation not being registered";
        v60 = 259;
        llvm::operator+(v61, v59, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_53:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceGradientOp,void>::id)
    goto LABEL_53;
  v58 = a3;
  v61[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v61);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v64 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v64) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v64 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v58);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("grad_input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v58);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("fwd_shape"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v58);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("begin"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v58);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("end"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);
  Dense = mlir::mpsx::SparseDenseMatMulOp::getDense((mlir::mpsx::SparseDenseMatMulOp *)&v58);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("stride"), Dense);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v24)
    objc_msgSend(v14, "addObject:", v24);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v58);
  v27 = CFSTR("result");
  if (v26)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v30 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v29, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v26));

    if (v30)
      objc_msgSend(v25, "addObject:", v30);
  }
  else
  {

    v30 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v61[0]) = 0;
  LODWORD(v61[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v58);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("begin_mask"), 32, &unk_1E0E9A8A0);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v61, 4);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v31, "addObject:", v32);
  }
  LODWORD(v59[0]) = 0;
  LODWORD(v59[0]) = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v58);
  v34 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("end_mask"), 32, &unk_1E0E9A8B8);
  if (v34)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v59, 4);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v34, "setValue:", v35);

    objc_msgSend(v31, "addObject:", v34);
  }
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v58);
  v36 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("shrink_axis_mask"), 32, &unk_1E0E9A8D0);
  if (v36)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &Groups, 4);
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v36, "setValue:", v37);

    objc_msgSend(v31, "addObject:", v36);
  }
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v58);
  v38 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("end_is_size"), 2147483656, &unk_1E0E9A8E8);
  if (v38)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &IsSize, 1);
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v38, "setValue:", v39);

    objc_msgSend(v31, "addObject:", v38);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v40);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v41, "initWithType:inputs:outputs:properties:regions:", v55, v42, v43, v44, v45);
  v47 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v46;

  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v48);

  if (SHIBYTE(v64) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0D500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSStridedSliceOpHandler *EmitterViewerSPI::MPSStridedSliceOpHandler::MPSStridedSliceOpHandler(EmitterViewerSPI::MPSStridedSliceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  MPSGraphViewerNodePropertyDataSPI *v34;
  void *v35;
  MPSGraphViewerNodePropertyDataSPI *v36;
  void *v37;
  void *v38;
  MPSGraphViewerNodeSPI *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  uint64_t AttrData;
  uint64_t v49;
  BOOL v50;
  void *v52;
  BOOL IsSize;
  unsigned int Groups;
  mlir::Operation *v55;
  uint64_t v56[4];
  __int16 v57;
  uint64_t v58[4];
  __int16 v59;
  void *__dst[2];
  int64_t v61;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03F80;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v49 == 17)
    {
      v50 = *(_QWORD *)AttrData == 0x697274732E73706DLL && *(_QWORD *)(AttrData + 8) == 0x63696C735F646564;
      if (v50 && *(_BYTE *)(AttrData + 16) == 101)
      {
        v59 = 1283;
        v58[0] = (uint64_t)"classof on '";
        v58[2] = (uint64_t)"mps.strided_slice";
        v58[3] = 17;
        v56[0] = (uint64_t)"' failed due to the operation not being registered";
        v57 = 259;
        llvm::operator+(v58, v56, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_48:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceOp,void>::id)
    goto LABEL_48;
  v55 = a3;
  v58[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v58);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v61 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v61) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v61 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v55);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v55);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("begin"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v55);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("end"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v55);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("stride"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v55);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v58[0]) = 0;
  LODWORD(v58[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v55);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("begin_mask"), 32, &unk_1E0E9A900);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v58, 4);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v29, "addObject:", v30);
  }
  LODWORD(v56[0]) = 0;
  LODWORD(v56[0]) = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v55);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("end_mask"), 32, &unk_1E0E9A918);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v56, 4);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v29, "addObject:", v32);
  }
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v55);
  v34 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("shrink_axis_mask"), 32, &unk_1E0E9A930);
  if (v34)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &Groups, 4);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v34, "setValue:", v35);

    objc_msgSend(v29, "addObject:", v34);
  }
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v55);
  v36 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("end_is_size"), 2147483656, &unk_1E0E9A948);
  if (v36)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &IsSize, 1);
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v36, "setValue:", v37);

    objc_msgSend(v29, "addObject:", v36);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  v39 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v38);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  v44 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v39, "initWithType:inputs:outputs:properties:regions:", v52, v40, v41, v42, v43);
  v45 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v44;

  v46 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v46);

  if (SHIBYTE(v61) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0DDC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSStridedSliceUpdateOpHandler *EmitterViewerSPI::MPSStridedSliceUpdateOpHandler::MPSStridedSliceUpdateOpHandler(EmitterViewerSPI::MPSStridedSliceUpdateOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  unint64_t Dense;
  void *v24;
  void *v25;
  uint64_t v26;
  __CFString *v27;
  uint64_t MPSDataType;
  void *v29;
  MPSGraphViewerNodePortSPI *v30;
  void *v31;
  MPSGraphViewerNodePropertyDataSPI *v32;
  void *v33;
  MPSGraphViewerNodePropertyDataSPI *v34;
  void *v35;
  MPSGraphViewerNodePropertyDataSPI *v36;
  void *v37;
  MPSGraphViewerNodePropertyDataSPI *v38;
  void *v39;
  void *v40;
  MPSGraphViewerNodeSPI *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  void *v48;
  _QWORD *AttrData;
  uint64_t v51;
  BOOL v52;
  void *v54;
  BOOL IsSize;
  unsigned int Groups;
  mlir::Operation *v57;
  uint64_t v58[4];
  __int16 v59;
  uint64_t v60[4];
  __int16 v61;
  void *__dst[2];
  int64_t v63;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E047C0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v51 == 24)
    {
      v52 = *AttrData == 0x697274732E73706DLL && AttrData[1] == 0x63696C735F646564;
      if (v52 && AttrData[2] == 0x6574616470755F65)
      {
        v61 = 1283;
        v60[0] = (uint64_t)"classof on '";
        v60[2] = (uint64_t)"mps.strided_slice_update";
        v60[3] = 24;
        v58[0] = (uint64_t)"' failed due to the operation not being registered";
        v59 = 259;
        llvm::operator+(v60, v58, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_50:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceUpdateOp,void>::id)
    goto LABEL_50;
  v57 = a3;
  v60[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v63 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("data"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v57);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("update"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v57);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("begin"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v57);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("end"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);
  Dense = mlir::mpsx::SparseDenseMatMulOp::getDense((mlir::mpsx::SparseDenseMatMulOp *)&v57);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("stride"), Dense);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  if (v24)
    objc_msgSend(v14, "addObject:", v24);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  v27 = CFSTR("result");
  if (v26)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v30 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v29, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v26));

    if (v30)
      objc_msgSend(v25, "addObject:", v30);
  }
  else
  {

    v30 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v60[0]) = 0;
  LODWORD(v60[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v57);
  v32 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("begin_mask"), 32, &unk_1E0E9A960);
  if (v32)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v60, 4);
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v32, "setValue:", v33);

    objc_msgSend(v31, "addObject:", v32);
  }
  LODWORD(v58[0]) = 0;
  LODWORD(v58[0]) = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v57);
  v34 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("end_mask"), 32, &unk_1E0E9A978);
  if (v34)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v58, 4);
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v34, "setValue:", v35);

    objc_msgSend(v31, "addObject:", v34);
  }
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v57);
  v36 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("shrink_axis_mask"), 32, &unk_1E0E9A990);
  if (v36)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &Groups, 4);
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v36, "setValue:", v37);

    objc_msgSend(v31, "addObject:", v36);
  }
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v57);
  v38 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("end_is_size"), 2147483656, &unk_1E0E9A9A8);
  if (v38)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &IsSize, 1);
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v38, "setValue:", v39);

    objc_msgSend(v31, "addObject:", v38);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v40);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  v46 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v41, "initWithType:inputs:outputs:properties:regions:", v54, v42, v43, v44, v45);
  v47 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v46;

  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v48);

  if (SHIBYTE(v63) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0E6B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSubtractOpHandler *EmitterViewerSPI::MPSSubtractOpHandler::MPSSubtractOpHandler(EmitterViewerSPI::MPSSubtractOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03980;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 12 && *(_QWORD *)AttrData == 0x746275732E73706DLL && *(_DWORD *)(AttrData + 8) == 1952670066)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.subtract";
      v43[3] = 12;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0ED18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSwishOpHandler *EmitterViewerSPI::MPSSwishOpHandler::MPSSwishOpHandler(EmitterViewerSPI::MPSSwishOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E032A8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(_QWORD *)AttrData == 0x736977732E73706DLL && *(_BYTE *)(AttrData + 8) == 104)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.swish";
      v41[3] = 9;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SwishOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0F278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTanOpHandler *EmitterViewerSPI::MPSTanOpHandler::MPSTanOpHandler(EmitterViewerSPI::MPSTanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _DWORD *AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02C90;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1851880494)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.tan";
      v41[3] = 7;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TanOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0F7BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTanhOpHandler *EmitterViewerSPI::MPSTanhOpHandler::MPSTanhOpHandler(EmitterViewerSPI::MPSTanhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  void *v36;
  mlir::Operation *v37;
  const char *v38;
  __int16 v39;
  uint64_t v40[4];
  __int16 v41;
  void *__dst[2];
  int64_t v43;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02FA8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x686E61742E73706DLL)
    {
      v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.tanh";
      v40[3] = 8;
      v38 = "' failed due to the operation not being registered";
      v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TanhOp,void>::id)
    goto LABEL_27;
  v37 = a3;
  v40[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v43 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v36, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v43) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F0FCF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTileGradientOpHandler *EmitterViewerSPI::MPSTileGradientOpHandler::MPSTileGradientOpHandler(EmitterViewerSPI::MPSTileGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t AttrData;
  uint64_t v39;
  BOOL v40;
  void *v42;
  mlir::Operation *v43;
  const char *v44;
  __int16 v45;
  uint64_t v46[4];
  __int16 v47;
  void *__dst[2];
  int64_t v49;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03F98;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 17)
    {
      v40 = *(_QWORD *)AttrData == 0x656C69742E73706DLL && *(_QWORD *)(AttrData + 8) == 0x6E6569646172675FLL;
      if (v40 && *(_BYTE *)(AttrData + 16) == 116)
      {
        v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.tile_gradient";
        v46[3] = 17;
        v44 = "' failed due to the operation not being registered";
        v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TileGradientOp,void>::id)
    goto LABEL_38;
  v43 = a3;
  v46[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v49 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("gradient"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("multiplier"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v42, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v49) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F102C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTileOpHandler *EmitterViewerSPI::MPSTileOpHandler::MPSTileOpHandler(EmitterViewerSPI::MPSTileOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02FC0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 8 && *AttrData == 0x656C69742E73706DLL)
    {
      v43 = 1283;
      v42[0] = (uint64_t)"classof on '";
      v42[2] = (uint64_t)"mps.tile";
      v42[3] = 8;
      v40 = "' failed due to the operation not being registered";
      v41 = 259;
      llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TileOp,void>::id)
    goto LABEL_29;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("multiplier"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v38, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F10868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTopKGradientOpHandler *EmitterViewerSPI::MPSTopKGradientOpHandler::MPSTopKGradientOpHandler(EmitterViewerSPI::MPSTopKGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  unint64_t SparseShape;
  void *v22;
  void *v23;
  uint64_t v24;
  __CFString *v25;
  uint64_t MPSDataType;
  void *v27;
  MPSGraphViewerNodePortSPI *v28;
  void *v29;
  MPSGraphViewerNodePropertyDataSPI *v30;
  void *v31;
  void *v32;
  MPSGraphViewerNodeSPI *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  _QWORD *AttrData;
  uint64_t v43;
  void *v45;
  mlir::Operation *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49[4];
  __int16 v50;
  void *__dst[2];
  int64_t v52;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03FB0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 14 && *AttrData == 0x5F706F742E73706DLL && *(_QWORD *)((char *)AttrData + 6) == 0x646172675F6B5F70)
    {
      v50 = 1283;
      v49[0] = (uint64_t)"classof on '";
      v49[2] = (uint64_t)"mps.top_k_grad";
      v49[3] = 14;
      v47 = "' failed due to the operation not being registered";
      v48 = 259;
      llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TopKGradientOp,void>::id)
    goto LABEL_39;
  v46 = a3;
  v49[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v52 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input_gradient"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v46);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("k"), SparseShape);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  if (v22)
    objc_msgSend(v14, "addObject:", v22);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  v25 = CFSTR("result");
  if (v24)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v27, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v24));

    if (v28)
      objc_msgSend(v23, "addObject:", v28);
  }
  else
  {

    v28 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v49[0]) = 0;
  LOBYTE(v49[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v46);
  v30 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("smallest"), 2147483656, &unk_1E0E9A9C0);
  if (v30)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v49, 1);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v30, "setValue:", v31);

    objc_msgSend(v29, "addObject:", v30);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v29);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  v38 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v33, "initWithType:inputs:outputs:properties:regions:", v45, v34, v35, v36, v37);
  v39 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v38;

  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v40);

  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F10EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTopKOpHandler *EmitterViewerSPI::MPSTopKOpHandler::MPSTopKOpHandler(EmitterViewerSPI::MPSTopKOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  uint64_t Element;
  __CFString *v28;
  uint64_t v29;
  void *v30;
  MPSGraphViewerNodePortSPI *v31;
  void *v32;
  MPSGraphViewerNodePropertyDataSPI *v33;
  void *v34;
  void *v35;
  MPSGraphViewerNodeSPI *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  void *v42;
  void *v43;
  uint64_t AttrData;
  uint64_t v46;
  void *v48;
  mlir::Operation *v49;
  const char *v50;
  __int16 v51;
  uint64_t v52[4];
  __int16 v53;
  void *__dst[2];
  int64_t v55;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02FD8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v46 == 9 && *(_QWORD *)AttrData == 0x5F706F742E73706DLL && *(_BYTE *)(AttrData + 8) == 107)
    {
      v53 = 1283;
      v52[0] = (uint64_t)"classof on '";
      v52[2] = (uint64_t)"mps.top_k";
      v52[3] = 9;
      v50 = "' failed due to the operation not being registered";
      v51 = 259;
      llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TopKOp,void>::id)
    goto LABEL_41;
  v49 = a3;
  v52[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v55 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("k"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  v23 = CFSTR("values");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("values"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }
  Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v49);
  v28 = CFSTR("indices");
  if (Element)
  {
    v29 = getMPSDataType((_QWORD *)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v31 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("indices"), v29, v30, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Element));

    if (v31)
      objc_msgSend(v21, "addObject:", v31);
  }
  else
  {

    v31 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v52[0]) = 0;
  LOBYTE(v52[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v49);
  v33 = -[MPSGraphViewerNodePropertyDataSPI initWithName:dataType:shape:]([MPSGraphViewerNodePropertyDataSPI alloc], "initWithName:dataType:shape:", CFSTR("smallest"), 2147483656, &unk_1E0E9A9D8);
  if (v33)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v52, 1);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    -[MPSGraphViewerNodePropertyDataSPI setValue:](v33, "setValue:", v34);

    objc_msgSend(v32, "addObject:", v33);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  v36 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v32);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v35);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  v41 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v36, "initWithType:inputs:outputs:properties:regions:", v48, v37, v38, v39, v40);
  v42 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v41;

  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v43);

  if (SHIBYTE(v55) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F1165C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTransposeOpHandler *EmitterViewerSPI::MPSTransposeOpHandler::MPSTransposeOpHandler(EmitterViewerSPI::MPSTransposeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  void *v21;
  uint64_t v22;
  __CFString *v23;
  uint64_t MPSDataType;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  void *v27;
  void *v28;
  MPSGraphViewerNodeSPI *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  _QWORD *AttrData;
  uint64_t v39;
  void *v41;
  mlir::Operation *v42;
  const char *v43;
  __int16 v44;
  uint64_t v45[4];
  __int16 v46;
  void *__dst[2];
  int64_t v48;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03A70;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 13 && *AttrData == 0x6E6172742E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x65736F70736E6172)
    {
      v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.transpose";
      v45[3] = 13;
      v43 = "' failed due to the operation not being registered";
      v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
    goto LABEL_35;
  v42 = a3;
  v45[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v48 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis1"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("axis2"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v14, "addObject:", v20);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  v23 = CFSTR("result");
  if (v22)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v25, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v22));

    if (v26)
      objc_msgSend(v21, "addObject:", v26);
  }
  else
  {

    v26 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v29 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v21);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v28);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v29, "initWithType:inputs:outputs:properties:regions:", v41, v30, v31, v32, v33);
  v35 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v34;

  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v36);

  if (SHIBYTE(v48) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F11CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTruncateOpHandler *EmitterViewerSPI::MPSTruncateOpHandler::MPSTruncateOpHandler(EmitterViewerSPI::MPSTruncateOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t AttrData;
  uint64_t v35;
  void *v37;
  mlir::Operation *v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  void *__dst[2];
  int64_t v44;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03998;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(_QWORD *)AttrData == 0x6E7572742E73706DLL && *(_DWORD *)(AttrData + 8) == 1702125923)
    {
      v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.truncate";
      v41[3] = 12;
      v39 = "' failed due to the operation not being registered";
      v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TruncateOp,void>::id)
    goto LABEL_31;
  v38 = a3;
  v41[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v44 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v37, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v44) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F12220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTypeConstraintOpHandler *EmitterViewerSPI::MPSTypeConstraintOpHandler::MPSTypeConstraintOpHandler(EmitterViewerSPI::MPSTypeConstraintOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E042B0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 19)
    {
      v36 = *AttrData == 0x657079742E73706DLL && AttrData[1] == 0x617274736E6F635FLL;
      if (v36 && *(_QWORD *)((char *)AttrData + 11) == 0x746E69617274736ELL)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.type_constraint";
        v42[3] = 19;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TypeConstraintOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("output");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v39);
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "This operation does not modify the input value in any way. It enforces the input value type to be more specialized than (or the same as) the constraint type.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F12790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSUnrealizedFoldOpHandler *EmitterViewerSPI::MPSUnrealizedFoldOpHandler::MPSUnrealizedFoldOpHandler(EmitterViewerSPI::MPSUnrealizedFoldOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E042C8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 19)
    {
      v36 = *AttrData == 0x65726E752E73706DLL && AttrData[1] == 0x665F64657A696C61;
      if (v36 && *(_QWORD *)((char *)AttrData + 11) == 0x646C6F665F64657ALL)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.unrealized_fold";
        v42[3] = 19;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::UnrealizedFoldOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("output");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("output"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "This op serves the purpose of representing a folding mechanism expected to materialize. It is meant to be used within the conversion mechanism where we expect a less specialized, or generic return type for an operation, but we already have a more specialized type (in most cases, statically defined).\n\nThis op is valid if the input is more specialized than the output.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F12D00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSUpdateRandomStateOpHandler *EmitterViewerSPI::MPSUpdateRandomStateOpHandler::MPSUpdateRandomStateOpHandler(EmitterViewerSPI::MPSUpdateRandomStateOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  BOOL v38;
  void *v40;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E046D0;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 23)
    {
      v38 = *AttrData == 0x616470752E73706DLL && AttrData[1] == 0x6F646E61725F6574;
      if (v38 && *(_QWORD *)((char *)AttrData + 15) == 0x65746174735F6D6FLL)
      {
        v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        v44[2] = (uint64_t)"mps.update_random_state";
        v44[3] = 23;
        v42 = "' failed due to the operation not being registered";
        v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::UpdateRandomStateOp,void>::id)
    goto LABEL_36;
  v41 = a3;
  v44[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v47 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("state"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("shape"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v40, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F132A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSVariableFromTensorOpHandler *EmitterViewerSPI::MPSVariableFromTensorOpHandler::MPSVariableFromTensorOpHandler(EmitterViewerSPI::MPSVariableFromTensorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  void *v17;
  uint64_t v18;
  __CFString *v19;
  uint64_t MPSDataType;
  void *v21;
  MPSGraphViewerNodePortSPI *v22;
  void *v23;
  void *v24;
  MPSGraphViewerNodeSPI *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  void *v32;
  _QWORD *AttrData;
  uint64_t v35;
  BOOL v36;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E047D8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 24)
    {
      v36 = *AttrData == 0x697261762E73706DLL && AttrData[1] == 0x6F72665F656C6261;
      if (v36 && AttrData[2] == 0x726F736E65745F6DLL)
      {
        v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.variable_from_tensor";
        v42[3] = 24;
        v40 = "' failed due to the operation not being registered";
        v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::VariableFromTensorOp,void>::id)
    goto LABEL_34;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("input"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v19 = CFSTR("result");
  if (v18)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    v22 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v21, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v18));

    if (v22)
      objc_msgSend(v17, "addObject:", v22);
  }
  else
  {

    v22 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v25 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v17);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v23);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v24);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v30 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v25, "initWithType:inputs:outputs:properties:regions:", v38, v26, v27, v28, v29);
  v31 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v30;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Create and return a variable formed from input tensor. This variable will be used to make changes to the original input tensor data, and will not persist across multiple executions of the same graph.");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v32);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F13820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSXnorOpHandler *EmitterViewerSPI::MPSXnorOpHandler::MPSXnorOpHandler(EmitterViewerSPI::MPSXnorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v38;
  mlir::Operation *v39;
  const char *v40;
  __int16 v41;
  uint64_t v42[4];
  __int16 v43;
  void *__dst[2];
  int64_t v45;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03020;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 8 && *AttrData == 0x726F6E782E73706DLL)
    {
      v43 = 1283;
      v42[0] = (uint64_t)"classof on '";
      v42[2] = (uint64_t)"mps.xnor";
      v42[3] = 8;
      v40 = "' failed due to the operation not being registered";
      v41 = 259;
      llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::XnorOp,void>::id)
    goto LABEL_29;
  v39 = a3;
  v42[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v45 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v38, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v45) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F13D94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSXorOpHandler *EmitterViewerSPI::MPSXorOpHandler::MPSXorOpHandler(EmitterViewerSPI::MPSXorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  void *v14;
  unint64_t Input;
  void *v16;
  unint64_t Filter;
  void *v18;
  void *v19;
  uint64_t v20;
  __CFString *v21;
  uint64_t MPSDataType;
  void *v23;
  MPSGraphViewerNodePortSPI *v24;
  void *v25;
  void *v26;
  MPSGraphViewerNodeSPI *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _DWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v40;
  const char *v41;
  __int16 v42;
  uint64_t v43[4];
  __int16 v44;
  void *__dst[2];
  int64_t v46;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02CA8;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1919907886)
    {
      v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.xor";
      v43[3] = 7;
      v41 = "' failed due to the operation not being registered";
      v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::XorOp,void>::id)
    goto LABEL_33;
  v40 = a3;
  v43[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v46 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lhs"), Input);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  if (v16)
    objc_msgSend(v14, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("rhs"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v14, "addObject:", v18);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  v21 = CFSTR("result");
  if (v20)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v23, (*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(_QWORD *)a2 + 32))(a2, v20));

    if (v24)
      objc_msgSend(v19, "addObject:", v24);
  }
  else
  {

    v24 = 0;
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v27 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v14);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v19);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v27, "initWithType:inputs:outputs:properties:regions:", v39, v28, v29, v30, v31);
  v33 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v32;

  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*((id *)this + 3), "setLocalizedDescription:", v34);

  if (SHIBYTE(v46) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F14328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  void *v28;
  void *v29;
  void *v30;

  if (a27 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ConditionOpHandler *EmitterViewerSPI::ConditionOpHandler::ConditionOpHandler(EmitterViewerSPI::ConditionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void *v13;
  unint64_t Input;
  void *v15;
  uint64_t Indices;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  unint64_t v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  MPSGraphViewerNodeSPI *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  _QWORD *AttrData;
  uint64_t v37;
  void *v39;
  mlir::Operation *v41;
  const char *v42;
  __int16 v43;
  uint64_t v44[4];
  __int16 v45;
  void *__dst[2];
  int64_t v47;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E03368;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 13 && *AttrData == 0x646E6F632E73706DLL && *(_QWORD *)((char *)AttrData + 5) == 0x6E6F697469646E6FLL)
    {
      v45 = 1283;
      v44[0] = (uint64_t)"classof on '";
      v44[2] = (uint64_t)"mps.condition";
      v44[3] = 13;
      v42 = "' failed due to the operation not being registered";
      v43 = 259;
      llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_32:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::serialization::ConditionOp,void>::id)
    goto LABEL_32;
  v41 = a3;
  v44[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v47 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v47) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v47 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("condition"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v13, "addObject:", v15);
  Indices = mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v41);
  v18 = v17;
  if (v17)
  {
    v19 = Indices;
    v20 = 0;
    v21 = 1;
    do
    {
      v22 = *(_QWORD *)(v19 + 32 * v20 + 24);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("args%d"), v21 - 1);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v23, v22);
      v24 = (void *)objc_claimAutoreleasedReturnValue();

      if (v24)
        objc_msgSend(v13, "addObject:", v24);

      v20 = v21++;
    }
    while (v18 > v20);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v13);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v26);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v27);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v33 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v28, "initWithType:inputs:outputs:properties:regions:", v39, v29, v30, v31, v32);
  v34 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v33;

  if (SHIBYTE(v47) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F14844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  void *v29;

  if (a28 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ForOpHandler *EmitterViewerSPI::ForOpHandler::ForOpHandler(EmitterViewerSPI::ForOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v4;
  void *v5;
  const char *v7;
  size_t v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  uint64_t v14;
  unint64_t Input;
  uint64_t v16;
  unint64_t Filter;
  void *v18;
  unint64_t Bias;
  void *v20;
  uint64_t InitArgs;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int v26;
  unint64_t v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t Results;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int v36;
  MPSGraphViewerNodePortSPI *NextResultAtOffset;
  void *v38;
  void *v39;
  uint64_t v40;
  _QWORD *Body;
  _QWORD *v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  MPSGraphViewerNodePortSPI *v48;
  void *v49;
  void *v50;
  id v51;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v53;
  MPSGraphViewerNodeSPI *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  uint64_t v59;
  void *v60;
  _QWORD *v62;
  mlir::GenericProgramPoint *v63;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v65;
  void *v66;
  _DWORD *AttrData;
  uint64_t v68;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  mlir::Operation *v75;
  const char *v76;
  __int16 v77;
  uint64_t v78[4];
  __int16 v79;
  void *__dst[2];
  int64_t v81;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02B28;
  *((_QWORD *)this + 1) = a2;
  v4 = *((_QWORD *)a3 + 6);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v68 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1919903278)
    {
      v79 = 1283;
      v78[0] = (uint64_t)"classof on '";
      v78[2] = (uint64_t)"mps.for";
      v78[3] = 7;
      v76 = "' failed due to the operation not being registered";
      v77 = 259;
      llvm::operator+(v78, (uint64_t *)&v76, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_65:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::serialization::ForOp,void>::id)
    goto LABEL_65;
  v75 = a3;
  v78[0] = *(_QWORD *)(v4 + 8);
  v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v78);
  v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    v81 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v81) = v8;
  v10 = __dst;
  if (v8)
LABEL_10:
    memmove(v10, v7, (size_t)v9);
  *((_BYTE *)v9 + (_QWORD)v10) = 0;
  if (v81 >= 0)
    v13 = __dst;
  else
    v13 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
  v14 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  v71 = (void *)v14;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v75);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("lowerBound"), Input);
  v16 = objc_claimAutoreleasedReturnValue();
  v72 = (void *)v16;
  if (v16)
    objc_msgSend(v74, "addObject:", v16);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v75);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("upperBound"), Filter);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18)
    objc_msgSend(v74, "addObject:", v18);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v75);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("step"), Bias);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  if (v20)
    objc_msgSend(v74, "addObject:", v20);
  InitArgs = mlir::mps::serialization::ForOp::getInitArgs((mlir::mps::serialization::ForOp *)&v75);
  v23 = v22;
  if (v22)
  {
    v24 = InitArgs;
    v25 = 0;
    v26 = 1;
    do
    {
      v27 = *(_QWORD *)(v24 + 32 * v25 + 24);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("initArgs%d"), v26 - 1);
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v28, v27);
      v29 = (void *)objc_claimAutoreleasedReturnValue();

      if (v29)
        objc_msgSend(v74, "addObject:", v29);

      v25 = v26++;
    }
    while (v23 > v25);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  Results = mlir::pdl::ApplyNativeRewriteOp::getResults((mlir::pdl::ApplyNativeRewriteOp *)&v75);
  v33 = v32;
  if (v32)
  {
    v34 = Results;
    v35 = 0;
    v36 = 1;
    do
    {
      NextResultAtOffset = (MPSGraphViewerNodePortSPI *)mlir::detail::OpResultImpl::getNextResultAtOffset(v34, v35);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("results%d"), v36 - 1);
      v38 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v38, NextResultAtOffset);
      v39 = (void *)objc_claimAutoreleasedReturnValue();

      if (v39)
        objc_msgSend(v30, "addObject:", v39);

      v35 = v36++;
    }
    while (v33 > v35);
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v40 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v73 = (void *)objc_claimAutoreleasedReturnValue();
  v70 = (void *)v40;
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v75);
  v42 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v43 = 0;
    do
    {
      v44 = Body[1];
      v45 = v44 - 8;
      if (!v44)
        v45 = 0;
      v46 = *(_QWORD *)(v45 + 48);
      v47 = *(_QWORD *)(v45 + 56) - v46;
      if (v43 >= ((unint64_t)v47 >> 3))
        break;
      if (v43 >= v47 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v48 = *(MPSGraphViewerNodePortSPI **)(v46 + 8 * v43);
      if (v48)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v46 + 8 * v43)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("region_arg%d"), v43);
          v49 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v49, (unint64_t)v48);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("region_arg%d"), v43);
          v49 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v49, v48);
        }
        v50 = (void *)objc_claimAutoreleasedReturnValue();

        if (v50)
          objc_msgSend(v74, "addObject:", v50);

        v42 = (_QWORD *)*Body;
      }
      ++v43;
    }
    while (v42 != Body);
  }
  v51 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v62 = i - 1;
    if (!i)
      v62 = 0;
    v63 = (mlir::GenericProgramPoint *)(v62 + 4);
    for (j = (mlir::GenericProgramPoint *)v62[5]; j != v63; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v65);
      v66 = (void *)objc_claimAutoreleasedReturnValue();
      if (v66)
        objc_msgSend(v51, "addObject:", v66);

    }
  }
  v53 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("region"), 0, v51);
  objc_msgSend(v73, "addObject:", v53);

  v54 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v74);
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v56 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v70);
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v73);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  v59 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v54, "initWithType:inputs:outputs:properties:regions:", v71, v55, v56, v57, v58);
  v60 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v59;

  if (SHIBYTE(v81) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F1502C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::IfOpHandler *EmitterViewerSPI::IfOpHandler::IfOpHandler(EmitterViewerSPI::IfOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  uint64_t v13;
  unint64_t Input;
  void *v15;
  void *v16;
  uint64_t Results;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  MPSGraphViewerNodePortSPI *NextResultAtOffset;
  void *v24;
  void *v25;
  _QWORD *Body;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  MPSGraphViewerNodePortSPI *v33;
  void *v34;
  void *v35;
  id v36;
  _QWORD *i;
  MPSGraphViewerNodeRegionSPI *v38;
  _QWORD *v39;
  _QWORD *v40;
  unint64_t v41;
  _QWORD *v42;
  mlir::GenericProgramPoint *v43;
  mlir::GenericProgramPoint *j;
  mlir::Operation *v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  MPSGraphViewerNodePortSPI *v51;
  void *v52;
  void *v53;
  id v54;
  _QWORD *k;
  MPSGraphViewerNodeRegionSPI *v56;
  MPSGraphViewerNodeSPI *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  void *v63;
  _QWORD *v65;
  mlir::GenericProgramPoint *v66;
  mlir::GenericProgramPoint *m;
  mlir::Operation *v68;
  void *v69;
  uint64_t AttrData;
  uint64_t v71;
  void *v73;
  void *v75;
  void *v76;
  void *v77;
  mlir::Operation *v78;
  const char *v79;
  __int16 v80;
  uint64_t v81[4];
  __int16 v82;
  void *__dst[2];
  int64_t v84;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E02B10;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v71 == 6 && *(_DWORD *)AttrData == 779317357 && *(_WORD *)(AttrData + 4) == 26217)
    {
      v82 = 1283;
      v81[0] = (uint64_t)"classof on '";
      v81[2] = (uint64_t)"mps.if";
      v81[3] = 6;
      v79 = "' failed due to the operation not being registered";
      v80 = 259;
      llvm::operator+(v81, (uint64_t *)&v79, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_80:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::serialization::IfOp,void>::id)
    goto LABEL_80;
  v78 = a3;
  v81[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v81);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v84 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v84) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v84 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v13 = objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v77 = (void *)objc_claimAutoreleasedReturnValue();
  v73 = (void *)v13;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v78);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("condition"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v77, "addObject:", v15);

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  Results = mlir::pdl::ApplyNativeRewriteOp::getResults((mlir::pdl::ApplyNativeRewriteOp *)&v78);
  v19 = v18;
  if (v18)
  {
    v20 = Results;
    v21 = 0;
    v22 = 1;
    do
    {
      NextResultAtOffset = (MPSGraphViewerNodePortSPI *)mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("results%d"), v22 - 1);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v24, NextResultAtOffset);
      v25 = (void *)objc_claimAutoreleasedReturnValue();

      if (v25)
        objc_msgSend(v16, "addObject:", v25);

      v21 = v22++;
    }
    while (v19 > v21);
  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v75 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v76 = (void *)objc_claimAutoreleasedReturnValue();
  Body = (_QWORD *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v78);
  v27 = (_QWORD *)*Body;
  if ((_QWORD *)*Body != Body)
  {
    v28 = 0;
    do
    {
      v29 = Body[1];
      v30 = v29 - 8;
      if (!v29)
        v30 = 0;
      v31 = *(_QWORD *)(v30 + 48);
      v32 = *(_QWORD *)(v30 + 56) - v31;
      if (v28 >= ((unint64_t)v32 >> 3))
        break;
      if (v28 >= v32 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v33 = *(MPSGraphViewerNodePortSPI **)(v31 + 8 * v28);
      if (v33)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v31 + 8 * v28)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("then_arg%d"), v28);
          v34 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v34, (unint64_t)v33);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("then_arg%d"), v28);
          v34 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v34, v33);
        }
        v35 = (void *)objc_claimAutoreleasedReturnValue();

        if (v35)
          objc_msgSend(v77, "addObject:", v35);

        v27 = (_QWORD *)*Body;
      }
      ++v28;
    }
    while (v27 != Body);
  }
  v36 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (i = (_QWORD *)Body[1]; i != Body; i = (_QWORD *)i[1])
  {
    v42 = i - 1;
    if (!i)
      v42 = 0;
    v43 = (mlir::GenericProgramPoint *)(v42 + 4);
    for (j = (mlir::GenericProgramPoint *)v42[5]; j != v43; j = (mlir::GenericProgramPoint *)*((_QWORD *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      EmitViewerSPI::emitNode(a2, v45);
      v46 = (void *)objc_claimAutoreleasedReturnValue();
      if (v46)
        objc_msgSend(v36, "addObject:", v46);

    }
  }
  v38 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("then"), 0, v36);
  objc_msgSend(v76, "addObject:", v38);

  v39 = (_QWORD *)mlir::scf::WhileOp::getAfter((mlir::scf::WhileOp *)&v78);
  v40 = (_QWORD *)*v39;
  if ((_QWORD *)*v39 != v39)
  {
    v41 = 0;
    do
    {
      v47 = v39[1];
      v48 = v47 - 8;
      if (!v47)
        v48 = 0;
      v49 = *(_QWORD *)(v48 + 48);
      v50 = *(_QWORD *)(v48 + 56) - v49;
      if (v41 >= ((unint64_t)v50 >> 3))
        break;
      if (v41 >= v50 >> 3)
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      v51 = *(MPSGraphViewerNodePortSPI **)(v49 + 8 * v41);
      if (v51)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((_QWORD *)a2 + 29, *(_QWORD *)(v49 + 8 * v41)))
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("else_arg%d"), v41);
          v52 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v52, (unint64_t)v51);
        }
        else
        {
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("else_arg%d"), v41);
          v52 = (void *)objc_claimAutoreleasedReturnValue();
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v52, v51);
        }
        v53 = (void *)objc_claimAutoreleasedReturnValue();

        if (v53)
          objc_msgSend(v77, "addObject:", v53);

        v40 = (_QWORD *)*v39;
      }
      ++v41;
    }
    while (v40 != v39);
  }
  v54 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  for (k = (_QWORD *)v39[1]; k != v39; k = (_QWORD *)k[1])
  {
    v65 = k - 1;
    if (!k)
      v65 = 0;
    v66 = (mlir::GenericProgramPoint *)(v65 + 4);
    for (m = (mlir::GenericProgramPoint *)v65[5]; m != v66; m = (mlir::GenericProgramPoint *)*((_QWORD *)m + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(m);
      EmitViewerSPI::emitNode(a2, v68);
      v69 = (void *)objc_claimAutoreleasedReturnValue();
      if (v69)
        objc_msgSend(v54, "addObject:", v69);

    }
  }
  v56 = -[MPSGraphViewerNodeRegionSPI initWithName:returnType:nodes:]([MPSGraphViewerNodeRegionSPI alloc], "initWithName:returnType:nodes:", CFSTR("else"), 0, v54);
  objc_msgSend(v76, "addObject:", v56);

  v57 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v77);
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v16);
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v75);
  v60 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v76);
  v61 = (void *)objc_claimAutoreleasedReturnValue();
  v62 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v57, "initWithType:inputs:outputs:properties:regions:", v73, v58, v59, v60, v61);
  v63 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v62;

  if (SHIBYTE(v84) < 0)
    operator delete(__dst[0]);
  return this;
}

void sub_180F159B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  uint64_t v16;

  if (*(char *)(v16 - 105) < 0)
    operator delete(*(void **)(v16 - 128));

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExtractOpHandler *EmitterViewerSPI::MPSExtractOpHandler::MPSExtractOpHandler(EmitterViewerSPI::MPSExtractOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v3;
  void *v4;
  const char *v6;
  size_t v7;
  void *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  void *v13;
  unint64_t Input;
  void *v15;
  uint64_t Indices;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  unint64_t v22;
  void *v23;
  void *v24;
  void *v25;
  MPSGraphViewerNodePortSPI *v26;
  __CFString *v27;
  uint64_t MPSDataType;
  void *v29;
  void *v30;
  void *v31;
  MPSGraphViewerNodeSPI *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;
  void *v38;
  _QWORD *AttrData;
  uint64_t v41;
  void *v43;
  mlir::Operation *v45;
  const char *v46;
  __int16 v47;
  uint64_t v48[4];
  __int16 v49;
  void *__dst[2];
  int64_t v51;

  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E0E035A8;
  *((_QWORD *)this + 1) = a2;
  v3 = *((_QWORD *)a3 + 6);
  v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 11 && *AttrData == 0x727478652E73706DLL && *(_QWORD *)((char *)AttrData + 3) == 0x746361727478652ELL)
    {
      v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"mps.extract";
      v48[3] = 11;
      v46 = "' failed due to the operation not being registered";
      v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::serialization::ExtractOp,void>::id)
    goto LABEL_36;
  v45 = a3;
  v48[0] = *(_QWORD *)(v3 + 8);
  v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v10 = v7 | 7;
    v11 = v10 + 1;
    v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    v51 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v51) = v7;
  v9 = __dst;
  if (v7)
LABEL_10:
    memmove(v9, v6, (size_t)v8);
  *((_BYTE *)v8 + (_QWORD)v9) = 0;
  if (v51 >= 0)
    v12 = __dst;
  else
    v12 = (void **)__dst[0];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v12, 4);
  v43 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  EmitViewerSPI::emitNodeInputPort((uint64_t)a2, CFSTR("tensor"), Input);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15)
    objc_msgSend(v13, "addObject:", v15);
  Indices = mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v45);
  v18 = v17;
  if (v17)
  {
    v19 = Indices;
    v20 = 0;
    v21 = 1;
    do
    {
      v22 = *(_QWORD *)(v19 + 32 * v20 + 24);
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("indices%d"), v21 - 1);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v23, v22);
      v24 = (void *)objc_claimAutoreleasedReturnValue();

      if (v24)
        objc_msgSend(v13, "addObject:", v24);

      v20 = v21++;
    }
    while (v18 > v20);
  }

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v26 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  v27 = CFSTR("result");
  if (v26)
  {
    MPSDataType = getMPSDataType((_QWORD *)(*(_QWORD *)&v26->_dataType & 0xFFFFFFFFFFFFFFF8));
    getMPSShapeFromMLIR((uint64_t **)(*(_QWORD *)&v26->_dataType & 0xFFFFFFFFFFFFFFF8));
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v26 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:]([MPSGraphViewerNodePortSPI alloc], "initWithName:dataType:shape:valueRef:", CFSTR("result"), MPSDataType, v29, (*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(_QWORD *)a2 + 32))(a2, v26));

    if (v26)
      objc_msgSend(v25, "addObject:", v26);
  }
  else
  {

  }
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = [MPSGraphViewerNodeSPI alloc];
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v13);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v25);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v30);
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v31);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  v37 = -[MPSGraphViewerNodeSPI initWithType:inputs:outputs:properties:regions:](v32, "initWithType:inputs:outputs:properties:regions:", v43, v33, v34, v35, v36);
  v38 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v37;

  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  return this;
}

